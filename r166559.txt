Index: kernel/drivers/input/misc/kxtj-lis3dh.c
===================================================================
--- kernel/drivers/input/misc/kxtj-lis3dh.c	(revision 0)
+++ kernel/drivers/input/misc/kxtj-lis3dh.c	(revision 166559)
@@ -0,0 +1,1908 @@
+/******************** (C) COPYRIGHT 2010 STMicroelectronics ********************
+ *
+ * File Name          : kxtj9_acc.c
+ * Authors            : MSH - Motion Mems BU - Application Team
+ *		      : Carmine Iascone (carmine.iascone@st.com)
+ *		      : Matteo Dameno (matteo.dameno@st.com)
+ * Version            : V.1.0.5
+ * Date               : 16/08/2010
+ * Description        : KXTJ9 accelerometer sensor API
+ *
+ *******************************************************************************
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+ * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+ * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+ * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+ * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ * THIS SOFTWARE IS SPECIFICALLY DESIGNED FOR EXCLUSIVE USE WITH ST PARTS.
+ *
+ ******************************************************************************
+ Revision 1.0.0 05/11/09
+ First Release
+ Revision 1.0.3 22/01/2010
+  Linux K&R Compliant Release;
+ Revision 1.0.5 16/08/2010
+ modified _get_acceleration_data function
+ modified _update_odr function
+ manages 2 interrupts
+
+ ******************************************************************************/
+
+#include	<linux/module.h>
+#include	<linux/err.h>
+#include	<linux/errno.h>
+#include	<linux/delay.h>
+#include	<linux/fs.h>
+#include	<linux/i2c.h>
+
+#include	<linux/input.h>
+#include	<linux/input-polldev.h>
+#include	<linux/miscdevice.h>
+#include	<linux/uaccess.h>
+#include        <linux/slab.h>
+#include 	<linux/proc_fs.h>  /*proc*/
+
+#include	<linux/workqueue.h>
+#include	<linux/irq.h>
+#include	<linux/gpio.h>
+#include	<linux/interrupt.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include        <linux/earlysuspend.h>
+#endif
+
+#include        <linux/i2c/kxtj-lis3dh.h>
+
+#define	INTERRUPT_MANAGEMENT 1
+
+#define	G_MAX		16000	/** Maximum polled-device-reported g value */
+
+/*
+#define	SHIFT_ADJ_2G		4
+#define	SHIFT_ADJ_4G		3
+#define	SHIFT_ADJ_8G		2
+#define	SHIFT_ADJ_16G		1
+*/
+
+#define SENSITIVITY_2G		1	/**	mg/LSB	*/
+#define SENSITIVITY_4G		2	/**	mg/LSB	*/
+#define SENSITIVITY_8G		4	/**	mg/LSB	*/
+#define SENSITIVITY_16G		12	/**	mg/LSB	*/
+
+#define	HIGH_RESOLUTION		0x08
+
+#define	AXISDATA_REG		0x28
+#define WHOAMI_KXTJ9_ACC	0x09
+#define WHOAMI1_KXTJ9_ACC	0x05	/*      Expctd content for WAI  */
+#define WHOAMI2_KXTJ9_ACC	0x08	
+/*	CONTROL REGISTERS	*/
+#define G_MAX			8000
+/* OUTPUT REGISTERS */
+#define XOUT_L			0x06
+#define WHO_AM_I		0x0F	/*      WhoAmI register         */
+#define INT_REL			0x1A
+#define CTRL_REG1		0x1B
+#define INT_CTRL1		0x1E
+#define DATA_CTRL		0x21
+/* CONTROL REGISTER 1 BITS */
+#define PC1_OFF			0x7F
+#define PC1_ON			(1 << 7)
+/* Data ready funtion enable bit: set during probe if using irq mode */
+#define DRDYE			(1 << 5)
+/*	end CONTROL REGISTRES	*/
+
+int accel_cali[3];
+#define KXTJ_CAL_FILE_PATH	"/productinfo/kxtj_cal"       //kxtj Calbration file path 
+#define ODR12_5F		0
+#define ODR25F			1
+#define ODR50F			2
+#define ODR100F		3
+#define ODR200F		4
+#define ODR400F		5
+#define ODR800F		6
+/* INTERRUPT CONTROL REGISTER 1 BITS */
+/* Set these during probe if using irq mode */
+#define KXTJ9_IEL		(1 << 3)
+#define KXTJ9_IEA		(1 << 4)
+#define KXTJ9_IEN		(1 << 5)
+/* INPUT_ABS CONSTANTS */
+#define FUZZ			3
+#define FLAT			3
+/* RESUME STATE INDICES */
+#define RES_DATA_CTRL		0
+#define RES_CTRL_REG1		1
+#define RES_INT_CTRL1		2
+#define RESUME_ENTRIES		3
+
+#define	RESUME_ENTRIES		20
+#define DEVICE_INFO             "ST, LIS3DH"
+#define DEVICE_INFO_LEN         32
+/* end RESUME STATE INDICES */
+
+#define GSENSOR_GINT1_GPI 0
+#define GSENSOR_GINT2_GPI 1
+
+
+#define	FUZZ			32
+#define	FLAT			32
+#define	I2C_RETRY_DELAY		5
+#define	I2C_RETRIES		5
+#define	I2C_AUTO_INCREMENT	0x80
+struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} kxtj9_acc_odr_table[] = {
+	
+	{ 3,	ODR800F },
+	{ 5,	ODR400F },
+	{ 10,	ODR200F },
+	{ 20,	ODR100F },
+	{ 40,	ODR50F  },
+	{ 80,	ODR25F  },
+	{ 0,	ODR12_5F},
+};
+
+struct kxtj9_acc_data {
+	struct i2c_client *client;
+	struct kxtj9_acc_platform_data *pdata;
+
+	struct mutex lock;
+	struct delayed_work input_work;
+
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	atomic_t enabled;
+	int on_before_suspend;
+
+	u8 sensitivity;
+	u8 shift;
+	u8 ctrl_reg1;
+	u8 data_ctrl;
+	u8 int_ctrl;
+	u8 resume_state[RESUME_ENTRIES];
+	bool cal_file_exist;
+	bool get_cali_flag;
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif
+};
+
+/*
+ * Because misc devices can not carry a pointer from driver register to
+ * open, we keep this global.  This limits the driver to a single instance.
+ */
+struct kxtj9_acc_data *kxtj9_acc_misc_data;
+struct i2c_client *kxtj9_i2c_client;
+int kxtj9_acc_update_g_range(struct kxtj9_acc_data *acc, u8 new_g_range);
+int kxtj9_acc_update_odr(struct kxtj9_acc_data *acc, int poll_interval_ms);
+static struct proc_dir_entry *kxtj_cali_proc = NULL;
+
+static int kxtj9_acc_i2c_read(struct kxtj9_acc_data *acc, u8 * buf, int len)
+{
+	int err;
+	int tries = 0;
+
+	struct i2c_msg msgs[] = {
+		{
+		 .addr = acc->client->addr,
+		 .flags = acc->client->flags & I2C_M_TEN,
+		 .len = 1,
+		 .buf = buf,},
+		{
+		 .addr = acc->client->addr,
+		 .flags = (acc->client->flags & I2C_M_TEN) | I2C_M_RD,
+		 .len = len,
+		 .buf = buf,},
+	};
+
+	do {
+		err = i2c_transfer(acc->client->adapter, msgs, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 2) && (++tries < I2C_RETRIES));
+
+	if (err != 2) {
+		dev_err(&acc->client->dev, "read transfer error\n");
+		err = -EIO;
+	} else {
+		err = 0;
+	}
+
+	return err;
+}
+
+static int kxtj9_acc_i2c_write(struct kxtj9_acc_data *acc, u8 * buf, int len)
+{
+	int err;
+	int tries = 0;
+
+	struct i2c_msg msgs[] = { {.addr = acc->client->addr,
+				   .flags = acc->client->flags & I2C_M_TEN,
+				   .len = len + 1,.buf = buf,},
+	};
+	do {
+		err = i2c_transfer(acc->client->adapter, msgs, 1);
+		if (err != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 1) && (++tries < I2C_RETRIES));
+
+	if (err != 1) {
+		dev_err(&acc->client->dev, "write transfer error\n");
+		err = -EIO;
+	} else {
+		err = 0;
+	}
+
+	return err;
+}
+
+static int kxtj9_acc_hw_init(struct kxtj9_acc_data *acc)
+{
+	int err = -1;
+	u8 buf[7];
+
+	pr_debug("%s: hw init start\n", KXTJ9_ACC_DEV_NAME);
+
+
+#if 0
+
+	buf[0] = CTRL_REG1;
+	buf[1] = acc->resume_state[RES_CTRL_REG1];
+	err = kxtj9_acc_i2c_write(acc, buf, 1);
+	if (err < 0)
+		goto error1;
+
+	buf[0] = TEMP_CFG_REG;
+	buf[1] = acc->resume_state[RES_TEMP_CFG_REG];
+	err = kxtj9_acc_i2c_write(acc, buf, 1);
+	if (err < 0)
+		goto error1;
+
+	buf[0] = FIFO_CTRL_REG;
+	buf[1] = acc->resume_state[RES_FIFO_CTRL_REG];
+	err = kxtj9_acc_i2c_write(acc, buf, 1);
+	if (err < 0)
+		goto error1;
+
+	buf[0] = (I2C_AUTO_INCREMENT | TT_THS);
+	buf[1] = acc->resume_state[RES_TT_THS];
+	buf[2] = acc->resume_state[RES_TT_LIM];
+	buf[3] = acc->resume_state[RES_TT_TLAT];
+	buf[4] = acc->resume_state[RES_TT_TW];
+	err = kxtj9_acc_i2c_write(acc, buf, 4);
+	if (err < 0)
+		goto error1;
+	buf[0] = TT_CFG;
+	buf[1] = acc->resume_state[RES_TT_CFG];
+	err = kxtj9_acc_i2c_write(acc, buf, 1);
+	if (err < 0)
+		goto error1;
+
+	buf[0] = (I2C_AUTO_INCREMENT | INT_THS1);
+	buf[1] = acc->resume_state[RES_INT_THS1];
+	buf[2] = acc->resume_state[RES_INT_DUR1];
+	err = kxtj9_acc_i2c_write(acc, buf, 2);
+	if (err < 0)
+		goto error1;
+	buf[0] = INT_CFG1;
+	buf[1] = acc->resume_state[RES_INT_CFG1];
+	err = kxtj9_acc_i2c_write(acc, buf, 1);
+	if (err < 0)
+		goto error1;
+
+	buf[0] = (I2C_AUTO_INCREMENT | INT_THS2);
+	buf[1] = acc->resume_state[RES_INT_THS2];
+	buf[2] = acc->resume_state[RES_INT_DUR2];
+	err = kxtj9_acc_i2c_write(acc, buf, 2);
+	if (err < 0)
+		goto error1;
+	buf[0] = INT_CFG2;
+	buf[1] = acc->resume_state[RES_INT_CFG2];
+	err = kxtj9_acc_i2c_write(acc, buf, 1);
+	if (err < 0)
+		goto error1;
+
+	buf[0] = (I2C_AUTO_INCREMENT | CTRL_REG2);
+	buf[1] = acc->resume_state[RES_CTRL_REG2];
+	buf[2] = acc->resume_state[RES_CTRL_REG3];
+	buf[3] = acc->resume_state[RES_CTRL_REG4];
+	buf[4] = acc->resume_state[RES_CTRL_REG5];
+	buf[5] = acc->resume_state[RES_CTRL_REG6];
+	err = kxtj9_acc_i2c_write(acc, buf, 5);
+	if (err < 0)
+		goto error1;
+#endif
+/* ensure that PC1 is cleared before updating control registers */
+  buf[0] = CTRL_REG1;
+	buf[1] = 0;
+	err = kxtj9_acc_i2c_write(acc, buf, 1);
+	if (err < 0)
+		goto error1;
+
+#if 0
+	/* only write INT_CTRL_REG1 if in irq mode */
+	if (acc->client->irq) {
+		err = i2c_smbus_write_byte_data(acc->client,
+						INT_CTRL1, acc->int_ctrl);
+		if (err < 0)
+			return err;
+	}
+#endif
+
+
+  err = kxtj9_acc_update_g_range(acc, acc->pdata->g_range);
+	if (err < 0) {
+//		dev_err(&client->dev, "update_g_range failed\n");
+		goto error1;
+	}
+
+
+
+
+
+	/* turn on outputs */
+	acc->ctrl_reg1 |= PC1_ON | RES_12BIT;  //12-bits
+
+
+  buf[0] = CTRL_REG1;
+	buf[1] = acc->ctrl_reg1;
+	err = kxtj9_acc_i2c_write(acc, buf, 1);
+	if (err < 0)
+		goto error1;
+
+
+
+	err = kxtj9_acc_update_odr(acc, acc->pdata->poll_interval);
+	if (err < 0) {
+		//dev_err(&client->dev, "update_odr failed\n");
+		goto error1;
+	}
+
+
+#if 0
+	/* clear initial interrupt if in irq mode */
+	if (tj9->client->irq) {
+		err = i2c_smbus_read_byte_data(tj9->client, INT_REL);
+		if (err < 0) {
+			dev_err(&tj9->client->dev,
+				"error clearing interrupt: %d\n", err);
+			goto fail;
+		}
+	}
+#endif
+	return 0;
+	acc->hw_initialized = 1;
+	pr_debug("%s: hw init done\n", KXTJ9_ACC_DEV_NAME);
+	return 0;
+
+error_firstread:
+	acc->hw_working = 0;
+	dev_warn(&acc->client->dev, "Error reading WHO_AM_I: is device "
+		 "available/working?\n");
+	goto error1;
+error_unknown_device:
+	dev_err(&acc->client->dev,
+		"device unknown. Expected: 0x%x,"
+		" Replies: 0x%x\n", WHOAMI_KXTJ9_ACC, buf[0]);
+error1:
+	acc->hw_initialized = 0;
+	dev_err(&acc->client->dev, "hw init error 0x%x,0x%x: %d\n", buf[0],
+		buf[1], err);
+	return err;
+}
+
+static void kxtj9_acc_device_power_off(struct kxtj9_acc_data *acc)
+{
+	int err;
+	u8 buf[2];
+	#if 0
+	u8 buf[2] = { CTRL_REG1, KXTJ9_ACC_PM_OFF };
+
+	err = kxtj9_acc_i2c_write(acc, buf, 1);
+	if (err < 0)
+		dev_err(&acc->client->dev, "soft power off failed: %d\n", err);
+#endif
+  acc->ctrl_reg1 &= PC1_OFF;
+	
+  buf[0] = CTRL_REG1;
+	buf[1] = acc->ctrl_reg1;
+	err = kxtj9_acc_i2c_write(acc, buf, 1);
+	if (err < 0)
+		dev_err(&acc->client->dev, "soft power off failed\n");
+
+	if (acc->pdata->power_off) {
+		if (acc->irq1 != 0)
+			disable_irq_nosync(acc->irq1);
+		if (acc->irq2 != 0)
+			disable_irq_nosync(acc->irq2);
+		acc->pdata->power_off();
+		acc->hw_initialized = 0;
+	}
+	if (acc->hw_initialized) {
+		if (acc->irq1 != 0)
+			disable_irq_nosync(acc->irq1);
+		if (acc->irq2 != 0)
+			disable_irq_nosync(acc->irq2);
+		acc->hw_initialized = 0;
+	}
+}
+
+static int kxtj9_acc_device_power_on(struct kxtj9_acc_data *acc)
+{
+	int err = -1;
+
+
+	if (acc->pdata->power_on) {
+		err = acc->pdata->power_on();
+		if (err < 0) {
+			dev_err(&acc->client->dev,
+				"power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+
+	if (!acc->hw_initialized) {
+		err = kxtj9_acc_hw_init(acc);
+		if (acc->hw_working == 1 && err < 0) {
+			kxtj9_acc_device_power_off(acc);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static irqreturn_t kxtj9_acc_isr1(int irq, void *dev)
+{
+	struct kxtj9_acc_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq1_work_queue, &acc->irq1_work);
+
+	pr_debug("%s: isr1 queued\n", KXTJ9_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t kxtj9_acc_isr2(int irq, void *dev)
+{
+	struct kxtj9_acc_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq2_work_queue, &acc->irq2_work);
+
+	pr_debug("%s: isr2 queued\n", KXTJ9_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static void kxtj9_acc_irq1_work_func(struct work_struct *work)
+{
+
+	/*struct kxtj9_acc_data *acc =
+	    container_of(work, struct kxtj9_acc_data, irq1_work);
+	*/
+	/* TODO  add interrupt service procedure.
+	   ie:kxtj9_acc_get_int1_source(acc); */
+	;
+	/*  */
+	pr_debug("%s: IRQ1 triggered\n", KXTJ9_ACC_DEV_NAME);
+}
+
+static void kxtj9_acc_irq2_work_func(struct work_struct *work)
+{
+
+	/*struct kxtj9_acc_data *acc =
+	    container_of(work, struct kxtj9_acc_data, irq2_work);
+	*/
+	/* TODO  add interrupt service procedure.
+	   ie:kxtj9_acc_get_tap_source(acc); */
+	;
+	/*  */
+
+	pr_debug("%s: IRQ2 triggered\n", KXTJ9_ACC_DEV_NAME);
+}
+
+int kxtj9_acc_update_g_range(struct kxtj9_acc_data *acc, u8 new_g_range)
+{
+	int err;
+
+	u8 sensitivity;
+	u8 buf[2];
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+
+	pr_debug("%s\n", __func__);
+
+	switch (new_g_range) {
+	case KXTJ9_ACC_G_2G:
+
+		sensitivity = 4;
+		break;
+	case KXTJ9_ACC_G_4G:
+
+		sensitivity = 3;
+		break;
+	case KXTJ9_ACC_G_8G:
+
+		sensitivity = 2;
+		break;
+	default:
+		dev_err(&acc->client->dev, "invalid g range requested: %u\n",
+			new_g_range);
+		return -EINVAL;
+	}
+
+	if (atomic_read(&acc->enabled)) {
+		/* Set configuration register 4, which contains g range setting
+		 *  NOTE: this is a straight overwrite because this driver does
+		 *  not use any of the other configuration bits in this
+		 *  register.  Should this become untrue, we will have to read
+		 *  out the value and only change the relevant bits --XX----
+		 *  (marked by X) */
+	  acc->ctrl_reg1 &= 0xe7;
+	  acc->ctrl_reg1 |= new_g_range;
+	  buf[0] = CTRL_REG1;
+	  buf[1] = acc->ctrl_reg1;
+	  err = kxtj9_acc_i2c_write(acc, buf, 1);
+	  if (err < 0)
+		   dev_err(&acc->client->dev, "soft power off failed\n");
+		acc->sensitivity = sensitivity;
+
+		pr_debug("%s sensitivity %d g-range %d\n", __func__, sensitivity,new_g_range);
+	}
+
+	return 0;
+error:
+	dev_err(&acc->client->dev, "update g range failed 0x%x,0x%x: %d\n",
+		buf[0], buf[1], err);
+
+	return err;
+}
+
+int kxtj9_acc_update_odr(struct kxtj9_acc_data *acc, int poll_interval_ms)
+{
+	int err = -1;
+	int i;
+  u8 buf[2];
+#if 0
+	for (i = ARRAY_SIZE(lis3dh_acc_odr_table) - 1; i >= 0; i--) {
+		if (lis3dh_acc_odr_table[i].cutoff_ms <= poll_interval_ms)
+			break;
+	}
+#endif	
+	for (i = 0; i < ARRAY_SIZE(kxtj9_acc_odr_table); i++) {
+		acc->data_ctrl = kxtj9_acc_odr_table[i].mask;
+		if (poll_interval_ms < kxtj9_acc_odr_table[i].cutoff_ms)
+			break;
+	}
+//err = i2c_smbus_write_byte_data(acc->client, CTRL_REG1, 0);
+	buf[0] = CTRL_REG1;
+  buf[1] = 0;//acc->ctrl_reg1;
+	err = kxtj9_acc_i2c_write(acc, buf, 1);
+	if (err < 0)
+		return err;
+
+	//err = i2c_smbus_write_byte_data(acc->client, DATA_CTRL, acc->data_ctrl);
+	buf[0] = DATA_CTRL;
+  buf[1] = acc->data_ctrl;
+	err = kxtj9_acc_i2c_write(acc, buf, 1);
+	if (err < 0)
+		return err;
+
+	buf[0] = CTRL_REG1;
+  buf[1] = acc->ctrl_reg1;
+	err = kxtj9_acc_i2c_write(acc, buf, 1);
+	if (err < 0)
+		return err;
+	
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/* */
+
+static int kxtj9_acc_register_write(struct kxtj9_acc_data *acc, u8 * buf,
+				     u8 reg_address, u8 new_value)
+{
+	int err = -1;
+
+	if (atomic_read(&acc->enabled)) {
+		/* Sets configuration register at reg_address
+		 *  NOTE: this is a straight overwrite  */
+		buf[0] = reg_address;
+		buf[1] = new_value;
+		err = kxtj9_acc_i2c_write(acc, buf, 1);
+		if (err < 0)
+			return err;
+	}
+	return err;
+}
+
+static int kxtj9_acc_register_read(struct kxtj9_acc_data *acc, u8 * buf,
+				    u8 reg_address)
+{
+
+	int err = -1;
+	buf[0] = (reg_address);
+	err = kxtj9_acc_i2c_read(acc, buf, 1);
+	return err;
+}
+
+static int kxtj9_acc_register_update(struct kxtj9_acc_data *acc, u8 * buf,
+				      u8 reg_address, u8 mask,
+				      u8 new_bit_values)
+{
+	int err = -1;
+	u8 init_val;
+	u8 updated_val;
+	err = kxtj9_acc_register_read(acc, buf, reg_address);
+	if (!(err < 0)) {
+		init_val = buf[1];
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		err = kxtj9_acc_register_write(acc, buf, reg_address,
+						updated_val);
+	}
+	return err;
+}
+
+/* */
+
+static int kxtj9_acc_get_acceleration_data(struct kxtj9_acc_data *acc,
+					    int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	s16 acc_data[3];
+	s16 hw_d[3] = { 0 };
+//	acc_data
+	/* x,y,z hardware data */
+	acc_data[0] = (I2C_AUTO_INCREMENT | XOUT_L);
+	err = kxtj9_acc_i2c_read(acc, (u8 *)acc_data, 6);
+	if (err < 0)
+		dev_err(&acc->client->dev, "accelerometer data read failed\n");
+
+	//x = le16_to_cpu(acc_data[tj9->pdata.axis_map_x]);
+	//y = le16_to_cpu(acc_data[tj9->pdata.axis_map_y]);
+	//z = le16_to_cpu(acc_data[tj9->pdata.axis_map_z]);
+
+	//x >>= tj9->shift;
+	//y >>= tj9->shift;
+	//z >>= tj9->shift;
+  pr_debug("%s read x=%d, y=%d, z=%d\n",
+	       KXTJ9_ACC_DEV_NAME, acc_data[0], acc_data[1], acc_data[2]);
+	xyz[1] = ((acc->pdata->negate_y) ? (acc_data[acc->pdata->axis_map_y])
+		  : (-acc_data[acc->pdata->axis_map_y]));
+	xyz[0] = ((acc->pdata->negate_x) ? (acc_data[acc->pdata->axis_map_x])
+		  : (-acc_data[acc->pdata->axis_map_x]));
+	//xyz[2] = ((acc->pdata->negate_z) ? (acc_data[acc->pdata->axis_map_z])
+	//	  : (-acc_data[acc->pdata->axis_map_z]));
+	xyz[2] = ((acc->pdata->negate_z) ? (-acc_data[acc->pdata->axis_map_z])
+		  : (acc_data[acc->pdata->axis_map_z]));
+
+  xyz[0]>>= acc->sensitivity;
+  xyz[1]>>= acc->sensitivity;
+  xyz[2]>>= acc->sensitivity;
+  
+  xyz[0] -=accel_cali[0];
+  xyz[1] -=accel_cali[1];
+  xyz[2] -=accel_cali[2];
+  
+	//printk("%s read x=%d, y=%d, z=%d\n",
+	//       KXTJ9_ACC_I2C_NAME, xyz[0], xyz[1], xyz[2]);
+
+	return err;
+}
+
+
+static int write_factory_calibration(int *buf)
+{
+    	struct file *fp_cal;
+	
+	mm_segment_t fs;
+	loff_t pos;
+	printk("[%s]: start: \n", __func__);
+	
+    	pos = 0;
+	
+		
+	fp_cal = filp_open(KXTJ_CAL_FILE_PATH, O_CREAT|O_RDWR|O_TRUNC, 0777);
+	if (IS_ERR(fp_cal))
+	{
+		printk("[ELAN]create file error\n");
+		return -1;
+	}
+
+    	fs = get_fs();
+	set_fs(KERNEL_DS);
+        
+	vfs_write(fp_cal, buf, 12, &pos);
+	
+    	filp_close(fp_cal, NULL);
+
+	set_fs(fs);
+	kxtj9_acc_misc_data->cal_file_exist = 1;
+	
+	printk("[%s]: end-> %d,%d,%d,%d  \n", __func__,buf[0],buf[1],buf[2],sizeof(buf));
+	return 0;
+}
+
+
+static bool read_factory_calibration(int *buf)
+{
+	//struct i2c_client *client = epl_data->client;
+	struct file *fp;
+	mm_segment_t fs;
+	loff_t pos;
+        int *data_ptr=NULL;
+	char buffer[12]= {0};
+	
+	int i;
+	printk("[%s]: start \n", __func__);
+
+	//if(kxtj9_acc_misc_data->cal_file_exist == 1)
+	{
+		printk("[%s]: kxtj cal_file_exist  \n", __func__);
+		fp = filp_open(KXTJ_CAL_FILE_PATH, O_RDONLY, 0/*S_IRUSR*/);
+
+		if (IS_ERR(fp))
+		{
+			printk("NO kxtj calibration file(%d,%d)\n", (int)IS_ERR(fp),fp);
+			kxtj9_acc_misc_data->cal_file_exist =  0;
+			return -EINVAL;
+		}
+		else
+		{
+			printk("[%s]: read cali value  \n", __func__);
+		  
+			pos = 0;
+			fs = get_fs();
+			set_fs(KERNEL_DS);
+			vfs_read(fp, (char *)buf, 12, &pos);
+			filp_close(fp, NULL);
+			data_ptr=(int *)buffer;
+			//sscanf(buffer, "%d,%d,%d", &x, &y,&z);
+					
+			set_fs(fs);
+	
+			printk("[%s]: x =%d, y=%d z=%d\n",__func__, *buf,*(buf+1),*(buf+2));
+			
+		}
+
+		
+	}
+	printk("[%s]: end \n", __func__);
+	return 0;
+}
+
+static int kxtj9_acc_cali_data(int sample_cnt,int *buf)
+{
+	int i=0;
+	int sum_x=0,sum_y=0,sum_z=0;
+	int xyz_data[3];
+	
+	if(kxtj9_acc_misc_data==NULL || buf==NULL || sizeof(buf)<3)
+	   return -1;
+         
+	accel_cali[0]=0;
+  	accel_cali[1]=0;
+  	accel_cali[2]=0;
+
+	for(i=0;i<sample_cnt;i++)
+	{
+	    kxtj9_acc_get_acceleration_data(kxtj9_acc_misc_data,xyz_data); 
+	    sum_x += xyz_data[0]; //x raw data
+	    sum_y += xyz_data[1];
+	    sum_z += xyz_data[2];
+	    msleep(20);
+	    
+	}
+	
+	*buf++ = sum_x/sample_cnt;
+	*buf++ = sum_y/sample_cnt;
+	*buf = sum_z/sample_cnt-1024;
+        
+	return 0;
+}
+
+
+static void kxtj9_acc_report_values(struct kxtj9_acc_data *acc, int *xyz)
+{
+	input_report_abs(acc->input_dev, ABS_X, xyz[0]);
+	input_report_abs(acc->input_dev, ABS_Y, xyz[1]);
+	input_report_abs(acc->input_dev, ABS_Z, xyz[2]);
+	input_sync(acc->input_dev);
+}
+
+static int kxtj9_acc_enable(struct kxtj9_acc_data *acc)
+{
+	int err;
+	printk("sprd-gsensor: -- %s -- !\n",__func__);
+	if (!atomic_cmpxchg(&acc->enabled, 0, 1)) {
+
+		//read acc cali-value from "/productinfo/kxtj_cal"
+		if(kxtj9_acc_misc_data->get_cali_flag==0)
+		{
+		 if(err=read_factory_calibration(accel_cali))
+		    {
+			   printk("read_factory_calibration failed\n");
+			   //return err;
+		    }
+		    printk("-- %s --accel_cali: x=%d,y=%d,z=%d !\n",__func__,accel_cali[0],accel_cali[1],accel_cali[2]);
+	            kxtj9_acc_misc_data->get_cali_flag = 1;
+         }
+		err = kxtj9_acc_device_power_on(acc);
+		if (err < 0) {
+			atomic_set(&acc->enabled, 0);
+			return err;
+		}
+
+		if (acc->hw_initialized) {
+			if (acc->irq1 != 0)
+				enable_irq(acc->irq1);
+			if (acc->irq2 != 0)
+				enable_irq(acc->irq2);
+			pr_debug("%s: power on: irq enabled\n",
+			       KXTJ9_ACC_DEV_NAME);
+		}
+
+		schedule_delayed_work(&acc->input_work,
+				      msecs_to_jiffies(acc->pdata->
+						       poll_interval));
+	}
+	printk("sprd-gsensor: -- %s -- success!\n",__func__);
+	return 0;
+}
+
+static int kxtj9_acc_disable(struct kxtj9_acc_data *acc)
+{
+
+	if (atomic_cmpxchg(&acc->enabled, 1, 0)) {
+		cancel_delayed_work_sync(&acc->input_work);
+		kxtj9_acc_device_power_off(acc);
+	}
+
+	return 0;
+}
+
+static int kxtj9_acc_misc_open(struct inode *inode, struct file *file)
+{
+	int err;
+	err = nonseekable_open(inode, file);
+	if (err < 0)
+		return err;
+
+	file->private_data = kxtj9_acc_misc_data;
+
+	return 0;
+}
+
+static long kxtj9_acc_misc_ioctl(struct file *file, unsigned int cmd,
+				unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	u8 buf[4];
+	u8 mask;
+	u8 reg_address;
+	u8 bit_values;
+	int err;
+	int interval;
+	int xyz[3] = { 0 };
+	struct kxtj9_acc_data *acc = file->private_data;
+
+	switch (cmd) {
+	case KXTJ9_ACC_IOCTL_GET_DELAY:
+		interval = acc->pdata->poll_interval;
+		if (copy_to_user(argp, &interval, sizeof(interval)))
+			return -EFAULT;
+		break;
+
+	case KXTJ9_ACC_IOCTL_SET_DELAY:
+		if (copy_from_user(&interval, argp, sizeof(interval)))
+			return -EFAULT;
+		if (interval < 0 || interval > 1000)
+			return -EINVAL;
+
+		acc->pdata->poll_interval = max(interval,
+						acc->pdata->min_interval);
+		err = kxtj9_acc_update_odr(acc, acc->pdata->poll_interval);
+		/* TODO: if update fails poll is still set */
+		if (err < 0)
+			return err;
+		break;
+
+	case KXTJ9_ACC_IOCTL_SET_ENABLE:
+		if (copy_from_user(&interval, argp, sizeof(interval)))
+			return -EFAULT;
+		if (interval > 1)
+			return -EINVAL;
+		if (interval)
+			err = kxtj9_acc_enable(acc);
+		else
+			err = kxtj9_acc_disable(acc);
+		return err;
+		break;
+
+	case KXTJ9_ACC_IOCTL_GET_ENABLE:
+		interval = atomic_read(&acc->enabled);
+		if (copy_to_user(argp, &interval, sizeof(interval)))
+			return -EINVAL;
+		break;
+
+	case KXTJ9_ACC_IOCTL_SET_G_RANGE:
+		if (copy_from_user(buf, argp, 1))
+			return -EFAULT;
+		bit_values = buf[0];
+		err = kxtj9_acc_update_g_range(acc, bit_values);
+		if (err < 0)
+			return err;
+		break;
+
+#if 0//def INTERRUPT_MANAGEMENT
+	case KXTJ9_ACC_IOCTL_SET_CTRL_REG3:
+		if (copy_from_user(buf, argp, 2))
+			return -EFAULT;
+		reg_address = CTRL_REG3;
+		mask = buf[1];
+		bit_values = buf[0];
+		err = kxtj9_acc_register_update(acc, (u8 *) arg, reg_address,
+						 mask, bit_values);
+		if (err < 0)
+			return err;
+		acc->resume_state[RES_CTRL_REG3] = ((mask & bit_values) |
+						    (~mask & acc->
+						     resume_state
+						     [RES_CTRL_REG3]));
+		break;
+
+	case KXTJ9_ACC_IOCTL_SET_CTRL_REG6:
+		if (copy_from_user(buf, argp, 2))
+			return -EFAULT;
+		reg_address = CTRL_REG6;
+		mask = buf[1];
+		bit_values = buf[0];
+		err = kxtj9_acc_register_update(acc, (u8 *) arg, reg_address,
+						 mask, bit_values);
+		if (err < 0)
+			return err;
+		acc->resume_state[RES_CTRL_REG6] = ((mask & bit_values) |
+						    (~mask & acc->
+						     resume_state
+						     [RES_CTRL_REG6]));
+		break;
+
+	case KXTJ9_ACC_IOCTL_SET_DURATION1:
+		if (copy_from_user(buf, argp, 1))
+			return -EFAULT;
+		reg_address = INT_DUR1;
+		mask = 0x7F;
+		bit_values = buf[0];
+		err = kxtj9_acc_register_update(acc, (u8 *) arg, reg_address,
+						 mask, bit_values);
+		if (err < 0)
+			return err;
+		acc->resume_state[RES_INT_DUR1] = ((mask & bit_values) |
+						   (~mask & acc->
+						    resume_state
+						    [RES_INT_DUR1]));
+		break;
+
+	case KXTJ9_ACC_IOCTL_SET_THRESHOLD1:
+		if (copy_from_user(buf, argp, 1))
+			return -EFAULT;
+		reg_address = INT_THS1;
+		mask = 0x7F;
+		bit_values = buf[0];
+		err = kxtj9_acc_register_update(acc, (u8 *) arg, reg_address,
+						 mask, bit_values);
+		if (err < 0)
+			return err;
+		acc->resume_state[RES_INT_THS1] = ((mask & bit_values) |
+						   (~mask & acc->
+						    resume_state
+						    [RES_INT_THS1]));
+		break;
+
+	case KXTJ9_ACC_IOCTL_SET_CONFIG1:
+		if (copy_from_user(buf, argp, 2))
+			return -EFAULT;
+		reg_address = INT_CFG1;
+		mask = buf[1];
+		bit_values = buf[0];
+		err = kxtj9_acc_register_update(acc, (u8 *) arg, reg_address,
+						 mask, bit_values);
+		if (err < 0)
+			return err;
+		acc->resume_state[RES_INT_CFG1] = ((mask & bit_values) |
+						   (~mask & acc->
+						    resume_state
+						    [RES_INT_CFG1]));
+		break;
+
+	case KXTJ9_ACC_IOCTL_GET_SOURCE1:
+		err = kxtj9_acc_register_read(acc, buf, INT_SRC1);
+		if (err < 0)
+			return err;
+
+		pr_debug("INT1_SRC content: %d , 0x%x\n", buf[0], buf[0]);
+
+		if (copy_to_user(argp, buf, 1))
+			return -EINVAL;
+		break;
+
+	case KXTJ9_ACC_IOCTL_SET_DURATION2:
+		if (copy_from_user(buf, argp, 1))
+			return -EFAULT;
+		reg_address = INT_DUR2;
+		mask = 0x7F;
+		bit_values = buf[0];
+		err = kxtj9_acc_register_update(acc, (u8 *) arg, reg_address,
+						 mask, bit_values);
+		if (err < 0)
+			return err;
+		acc->resume_state[RES_INT_DUR2] = ((mask & bit_values) |
+						   (~mask & acc->
+						    resume_state
+						    [RES_INT_DUR2]));
+		break;
+
+	case KXTJ9_ACC_IOCTL_SET_THRESHOLD2:
+		if (copy_from_user(buf, argp, 1))
+			return -EFAULT;
+		reg_address = INT_THS2;
+		mask = 0x7F;
+		bit_values = buf[0];
+		err = kxtj9_acc_register_update(acc, (u8 *) arg, reg_address,
+						 mask, bit_values);
+		if (err < 0)
+			return err;
+		acc->resume_state[RES_INT_THS2] = ((mask & bit_values) |
+						   (~mask & acc->
+						    resume_state
+						    [RES_INT_THS2]));
+		break;
+
+	case KXTJ9_ACC_IOCTL_SET_CONFIG2:
+		if (copy_from_user(buf, argp, 2))
+			return -EFAULT;
+		reg_address = INT_CFG2;
+		mask = buf[1];
+		bit_values = buf[0];
+		err = kxtj9_acc_register_update(acc, (u8 *) arg, reg_address,
+						 mask, bit_values);
+		if (err < 0)
+			return err;
+		acc->resume_state[RES_INT_CFG2] = ((mask & bit_values) |
+						   (~mask & acc->
+						    resume_state
+						    [RES_INT_CFG2]));
+		break;
+
+	case KXTJ9_ACC_IOCTL_GET_SOURCE2:
+		err = kxtj9_acc_register_read(acc, buf, INT_SRC2);
+		if (err < 0)
+			return err;
+
+		pr_debug("INT2_SRC content: %d , 0x%x\n", buf[0], buf[0]);
+
+		if (copy_to_user(argp, buf, 1))
+			return -EINVAL;
+		break;
+
+	case KXTJ9_ACC_IOCTL_GET_TAP_SOURCE:
+		err = kxtj9_acc_register_read(acc, buf, TT_SRC);
+		if (err < 0)
+			return err;
+		pr_debug("TT_SRC content: %d , 0x%x\n", buf[0], buf[0]);
+
+		if (copy_to_user(argp, buf, 1)) {
+			pr_err("%s: %s error in copy_to_user \n",
+			       KXTJ9_ACC_DEV_NAME, __func__);
+			return -EINVAL;
+		}
+		break;
+
+	case KXTJ9_ACC_IOCTL_SET_TAP_CFG:
+		if (copy_from_user(buf, argp, 2))
+			return -EFAULT;
+		reg_address = TT_CFG;
+		mask = buf[1];
+		bit_values = buf[0];
+		err = kxtj9_acc_register_update(acc, (u8 *) arg, reg_address,
+						 mask, bit_values);
+		if (err < 0)
+			return err;
+		acc->resume_state[RES_TT_CFG] = ((mask & bit_values) |
+						 (~mask & acc->
+						  resume_state[RES_TT_CFG]));
+		break;
+
+	case KXTJ9_ACC_IOCTL_SET_TAP_TLIM:
+		if (copy_from_user(buf, argp, 2))
+			return -EFAULT;
+		reg_address = TT_LIM;
+		mask = buf[1];
+		bit_values = buf[0];
+		err = kxtj9_acc_register_update(acc, (u8 *) arg, reg_address,
+						 mask, bit_values);
+		if (err < 0)
+			return err;
+		acc->resume_state[RES_TT_LIM] = ((mask & bit_values) |
+						 (~mask & acc->
+						  resume_state[RES_TT_LIM]));
+		break;
+
+	case KXTJ9_ACC_IOCTL_SET_TAP_THS:
+		if (copy_from_user(buf, argp, 2))
+			return -EFAULT;
+		reg_address = TT_THS;
+		mask = buf[1];
+		bit_values = buf[0];
+		err = kxtj9_acc_register_update(acc, (u8 *) arg, reg_address,
+						 mask, bit_values);
+		if (err < 0)
+			return err;
+		acc->resume_state[RES_TT_THS] = ((mask & bit_values) |
+						 (~mask & acc->
+						  resume_state[RES_TT_THS]));
+		break;
+
+	case KXTJ9_ACC_IOCTL_SET_TAP_TLAT:
+		if (copy_from_user(buf, argp, 2))
+			return -EFAULT;
+		reg_address = TT_TLAT;
+		mask = buf[1];
+		bit_values = buf[0];
+		err = kxtj9_acc_register_update(acc, (u8 *) arg, reg_address,
+						 mask, bit_values);
+		if (err < 0)
+			return err;
+		acc->resume_state[RES_TT_TLAT] = ((mask & bit_values) |
+						  (~mask & acc->
+						   resume_state[RES_TT_TLAT]));
+		break;
+
+	case KXTJ9_ACC_IOCTL_SET_TAP_TW:
+		if (copy_from_user(buf, argp, 2))
+			return -EFAULT;
+		reg_address = TT_TW;
+		mask = buf[1];
+		bit_values = buf[0];
+		err = kxtj9_acc_register_update(acc, (u8 *) arg, reg_address,
+						 mask, bit_values);
+		if (err < 0)
+			return err;
+		acc->resume_state[RES_TT_TW] = ((mask & bit_values) |
+						(~mask & acc->
+						 resume_state[RES_TT_TW]));
+		break;
+
+#endif /* INTERRUPT_MANAGEMENT */
+  	case KXTJ9_ACC_IOCTL_GET_COOR_XYZ:
+		err = kxtj9_acc_get_acceleration_data(acc, xyz);
+		if (err < 0)
+			return err;
+
+		if (copy_to_user(argp, xyz, sizeof(xyz))) {
+			pr_err(" %s %d error in copy_to_user \n",
+			       __func__, __LINE__);
+			return -EINVAL;
+		}
+		break;
+	case KXTJ9_ACC_IOCTL_GET_CHIP_ID:
+	    {
+	        u8 devid = 0;
+	        u8 devinfo[DEVICE_INFO_LEN] = {0};
+	        err = kxtj9_acc_register_read(acc, &devid, WHO_AM_I);
+	        if (err < 0) {
+	            printk("__func__, error read register WHO_AM_I\n", __func__);
+	            return -EAGAIN;
+	        }
+	        sprintf(devinfo, "%s, %#x", DEVICE_INFO, devid);
+
+	        if (copy_to_user(argp, devinfo, sizeof(devinfo))) {
+	            printk("%s error in copy_to_user(IOCTL_GET_CHIP_ID)\n", __func__);
+	            return -EINVAL;
+	        }
+	    }
+	   break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct file_operations kxtj9_acc_misc_fops = {
+	.owner = THIS_MODULE,
+	.open = kxtj9_acc_misc_open,
+	.unlocked_ioctl = kxtj9_acc_misc_ioctl,
+};
+
+static struct miscdevice kxtj9_acc_misc_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = KXTJ9_ACC_DEV_NAME,
+	.fops = &kxtj9_acc_misc_fops,
+};
+
+static void kxtj9_acc_input_work_func(struct work_struct *work)
+{
+	struct kxtj9_acc_data *acc;
+
+	int xyz[3] = { 0 };
+	int err;
+
+	acc = container_of((struct delayed_work *)work,
+			   struct kxtj9_acc_data, input_work);
+
+	mutex_lock(&acc->lock);
+	err = kxtj9_acc_get_acceleration_data(acc, xyz);
+	if (err < 0)
+		dev_err(&acc->client->dev, "get_acceleration_data failed\n");
+	else
+		kxtj9_acc_report_values(acc, xyz);
+
+	schedule_delayed_work(&acc->input_work,
+			      msecs_to_jiffies(acc->pdata->poll_interval));
+	mutex_unlock(&acc->lock);
+}
+
+#ifdef KXTJ9_OPEN_ENABLE
+int kxtj9_acc_input_open(struct input_dev *input)
+{
+	struct kxtj9_acc_data *acc = input_get_drvdata(input);
+
+	return kxtj9_acc_enable(acc);
+}
+
+void kxtj9_acc_input_close(struct input_dev *dev)
+{
+	struct kxtj9_acc_data *acc = input_get_drvdata(dev);
+
+	kxtj9_acc_disable(acc);
+}
+#endif
+
+static int kxtj9_acc_validate_pdata(struct kxtj9_acc_data *acc)
+{
+	acc->pdata->poll_interval = max(acc->pdata->poll_interval,
+					acc->pdata->min_interval);
+
+	if (acc->pdata->axis_map_x > 2 || acc->pdata->axis_map_y > 2
+	    || acc->pdata->axis_map_z > 2) {
+		dev_err(&acc->client->dev, "invalid axis_map value "
+			"x:%u y:%u z%u\n", acc->pdata->axis_map_x,
+			acc->pdata->axis_map_y, acc->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (acc->pdata->negate_x > 1 || acc->pdata->negate_y > 1
+	    || acc->pdata->negate_z > 1) {
+		dev_err(&acc->client->dev, "invalid negate value "
+			"x:%u y:%u z:%u\n", acc->pdata->negate_x,
+			acc->pdata->negate_y, acc->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (acc->pdata->poll_interval < acc->pdata->min_interval) {
+		dev_err(&acc->client->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int kxtj9_acc_input_init(struct kxtj9_acc_data *acc)
+{
+	int err;
+	/* Polling rx data when the interrupt is not used.*/
+	if (1 /*acc->irq1 == 0 && acc->irq1 == 0 */ ) {
+		INIT_DELAYED_WORK(&acc->input_work, kxtj9_acc_input_work_func);
+	}
+
+	acc->input_dev = input_allocate_device();
+	if (!acc->input_dev) {
+		err = -ENOMEM;
+		dev_err(&acc->client->dev, "input device allocate failed\n");
+		goto err0;
+	}
+#ifdef KXTJ9_ACC_OPEN_ENABLE
+	acc->input_dev->open = kxtj9_acc_input_open;
+	acc->input_dev->close = kxtj9_acc_input_close;
+#endif
+
+	input_set_drvdata(acc->input_dev, acc);
+
+	set_bit(EV_ABS, acc->input_dev->evbit);
+	/*      next is used for interruptA sources data if the case */
+	set_bit(ABS_MISC, acc->input_dev->absbit);
+	/*      next is used for interruptB sources data if the case */
+	set_bit(ABS_WHEEL, acc->input_dev->absbit);
+
+	input_set_abs_params(acc->input_dev, ABS_X, -G_MAX, G_MAX, FUZZ, FLAT);
+	input_set_abs_params(acc->input_dev, ABS_Y, -G_MAX, G_MAX, FUZZ, FLAT);
+	input_set_abs_params(acc->input_dev, ABS_Z, -G_MAX, G_MAX, FUZZ, FLAT);
+	/*      next is used for interruptA sources data if the case */
+	input_set_abs_params(acc->input_dev, ABS_MISC, INT_MIN, INT_MAX, 0, 0);
+	/*      next is used for interruptB sources data if the case */
+	input_set_abs_params(acc->input_dev, ABS_WHEEL, INT_MIN, INT_MAX, 0, 0);
+
+	acc->input_dev->name = "accelerometer";
+
+	err = input_register_device(acc->input_dev);
+	if (err) {
+		dev_err(&acc->client->dev,
+			"unable to register input polled device %s\n",
+			acc->input_dev->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(acc->input_dev);
+err0:
+	return err;
+}
+
+static void kxtj9_acc_input_cleanup(struct kxtj9_acc_data *acc)
+{
+	input_unregister_device(acc->input_dev);
+	input_free_device(acc->input_dev);
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void kxtj9_early_suspend(struct early_suspend *es);
+static void kxtj9_early_resume(struct early_suspend *es);
+#endif
+
+#ifdef CONFIG_OF
+static struct kxtj9_acc_platform_data *kxtj9_acc_parse_dt(struct device *dev)
+{
+	struct kxtj9_acc_platform_data *pdata;
+	struct device_node *np = dev->of_node;
+	int ret;
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (!pdata) {
+		dev_err(dev, "Could not allocate struct lis3dh_acc_platform_data");
+		return NULL;
+	}
+	ret = of_property_read_u32(np, "poll_interval", &pdata->poll_interval);
+	if(ret){
+		dev_err(dev, "fail to get poll_interval\n");
+		goto fail;
+	}
+	ret = of_property_read_u32(np, "min_interval", &pdata->min_interval);
+	if(ret){
+		dev_err(dev, "fail to get min_interval\n");
+		goto fail;
+	}
+	ret = of_property_read_u32(np, "g_range", &pdata->g_range);
+	if(ret){
+		dev_err(dev, "fail to get g_range\n");
+		goto fail;
+	}
+	ret = of_property_read_u32(np, "axis_map_x", &pdata->axis_map_x);
+	if(ret){
+		dev_err(dev, "fail to get axis_map_x\n");
+		goto fail;
+	}
+	ret = of_property_read_u32(np, "axis_map_y", &pdata->axis_map_y);
+	if(ret){
+		dev_err(dev, "fail to get axis_map_y\n");
+		goto fail;
+	}
+	ret = of_property_read_u32(np, "axis_map_z", &pdata->axis_map_z);
+	if(ret){
+		dev_err(dev, "fail to get axis_map_z\n");
+		goto fail;
+	}
+	ret = of_property_read_u32(np, "negate_x", &pdata->negate_x);
+	if(ret){
+		dev_err(dev, "fail to get negate_x\n");
+		goto fail;
+	}
+	ret = of_property_read_u32(np, "negate_y", &pdata->negate_y);
+	if(ret){
+		dev_err(dev, "fail to get negate_y\n");
+		goto fail;
+	}
+	ret = of_property_read_u32(np, "negate_z", &pdata->negate_z);
+	if(ret){
+		dev_err(dev, "fail to get negate_z\n");
+		goto fail;
+	}
+	return pdata;
+fail:
+	kfree(pdata);
+	return NULL;
+}
+#endif
+
+static int kxtj_cali_write_proc(struct file *file, const char *buffer, size_t count, loff_t *ppos)
+{
+    //int buf[3]={1122,3344,5566};
+    int *cali_ptr=accel_cali;
+ 
+    if(kxtj9_acc_cali_data(5,cali_ptr)==0 )
+    {
+//printk("%s: x=%d,y=%d,z=%d\n",__func__,*cali_ptr,*(accel_cali+1),*(accel_cali+2));
+
+	if(write_factory_calibration(cali_ptr)<0)
+		return -1;
+	
+	
+	return count;
+    }	
+   
+    return -1;
+}
+
+static int kxtj_cali_read_proc(struct file *file, char *buffer, size_t count, loff_t *ppos)
+{
+    int *cali_ptr=accel_cali; 
+    
+    if(0>read_factory_calibration(cali_ptr))
+    {
+           printk("%s failed\n", __func__);
+	   return 0;
+    }
+    // printk("%s: #### x=%d,y=%d,z=%d\n",__func__,*cali_ptr,*(cali_ptr+1),*(cali_ptr+2));
+
+    return sprintf(buffer,"x=%d,y=%d,z=%d\n",*cali_ptr,*(cali_ptr+1),*(cali_ptr+2));
+    
+
+}
+
+static const struct file_operations kxtj_cali_proc_fops = { 
+    .write = kxtj_cali_write_proc,
+    .read = kxtj_cali_read_proc
+};
+
+
+static int kxtj9_acc_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+
+	struct kxtj9_acc_data *acc;
+	struct lis3dh_acc_platform_data *pdata = client->dev.platform_data;
+
+	int err = -1;
+	int tempvalue;
+
+	pr_debug("%s: probe start .\n", KXTJ9_ACC_DEV_NAME);
+  
+#ifdef CONFIG_OF
+	struct device_node *np = client->dev.of_node;
+	if (np && !pdata){
+		pdata = kxtj9_acc_parse_dt(&client->dev);
+		if(pdata){
+			client->dev.platform_data = pdata;
+		}
+		if(!pdata){
+			err = -ENOMEM;
+			goto exit_alloc_platform_data_failed;
+		}
+	}
+#endif
+	/*
+	if (client->dev.platform_data == NULL) {
+		dev_err(&client->dev, "platform data is NULL. exiting.\n");
+		err = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+	*/
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "client not i2c capable\n");
+		err = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+
+	if (!i2c_check_functionality(client->adapter,
+				     I2C_FUNC_SMBUS_BYTE |
+				     I2C_FUNC_SMBUS_BYTE_DATA |
+				     I2C_FUNC_SMBUS_WORD_DATA)) {
+		dev_err(&client->dev, "client not smb-i2c capable:2\n");
+		err = -EIO;
+		goto exit_check_functionality_failed;
+	}
+
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK)) {
+		dev_err(&client->dev, "client not smb-i2c capable:3\n");
+		err = -EIO;
+		goto exit_check_functionality_failed;
+	}
+
+	/*
+	 * OK. From now, we presume we have a valid client. We now create the
+	 * client structure, even though we cannot fill it completely yet.
+	 */
+	acc = kzalloc(sizeof(struct kxtj9_acc_data), GFP_KERNEL);
+	if (acc == NULL) {
+		err = -ENOMEM;
+		dev_err(&client->dev,
+			"failed to allocate memory for module data: "
+			"%d\n", err);
+		goto exit_alloc_data_failed;
+	}
+
+
+	mutex_init(&acc->lock);
+	mutex_lock(&acc->lock);
+
+	acc->client = client;
+	kxtj9_i2c_client = client;
+	i2c_set_clientdata(client, acc);
+
+#if 1	
+		tempvalue = i2c_smbus_read_byte_data(client, WHO_AM_I);
+		if((tempvalue & 0x00FF) == WHOAMI_KXTJ9_ACC){
+			printk( "%s I2C driver registered!\n",
+								KXTJ9_ACC_DEV_NAME);
+		} else {
+		//	acc->client = NULL;
+			printk("I2C driver not registered!"
+					" Device unknown 0x%x\n", tempvalue);
+			//goto exit_check_functionality_failed;
+		}
+	
+#endif
+	pr_debug("%s: %s has set irq1 to irq: %d\n",
+	       KXTJ9_ACC_DEV_NAME, __func__, acc->irq1);
+	pr_debug("%s: %s has set irq2 to irq: %d\n",
+	       KXTJ9_ACC_DEV_NAME, __func__, acc->irq2);
+
+	gpio_request(GSENSOR_GINT1_GPI, "GSENSOR_INT1");
+	gpio_request(GSENSOR_GINT2_GPI, "GSENSOR_INT2");
+	acc->irq1 = 0; /* gpio_to_irq(GSENSOR_GINT1_GPI); */
+	acc->irq2 = 0; /* gpio_to_irq(GSENSOR_GINT2_GPI); */
+
+	if (acc->irq1 != 0) {
+		pr_debug("%s request irq1\n", __func__);
+		err =
+		    request_irq(acc->irq1, kxtj9_acc_isr1, IRQF_TRIGGER_RISING,
+				"kxtj9_acc_irq1", acc);
+		if (err < 0) {
+			dev_err(&client->dev, "request irq1 failed: %d\n", err);
+			goto err_mutexunlockfreedata;
+		}
+
+		disable_irq_nosync(acc->irq1);
+
+		INIT_WORK(&acc->irq1_work, kxtj9_acc_irq1_work_func);
+		acc->irq1_work_queue =
+		    create_singlethread_workqueue("kxtj9_acc_wq1");
+		if (!acc->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(&client->dev, "cannot create work queue1: %d\n",
+				err);
+			goto err_free_irq1;
+		}
+
+	}
+
+
+	if (acc->irq2 != 0) {
+		err =
+		    request_irq(acc->irq2, kxtj9_acc_isr2, IRQF_TRIGGER_RISING,
+				"kxtj9_acc_irq2", acc);
+		if (err < 0) {
+			dev_err(&client->dev, "request irq2 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+
+		disable_irq_nosync(acc->irq2);
+
+/*		 Create workqueue for IRQ.*/
+
+		INIT_WORK(&acc->irq2_work, kxtj9_acc_irq2_work_func);
+		acc->irq2_work_queue =
+		    create_singlethread_workqueue("kxtj9_acc_wq2");
+		if (!acc->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(&client->dev, "cannot create work queue2: %d\n",
+				err);
+			goto err_free_irq2;
+		}
+
+	}
+
+
+	acc->pdata = kmalloc(sizeof(*acc->pdata), GFP_KERNEL);
+	if (acc->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(&client->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_destoyworkqueue2;
+	}
+
+
+	memcpy(acc->pdata, client->dev.platform_data, sizeof(*acc->pdata));
+
+	err = kxtj9_acc_validate_pdata(acc);
+	if (err < 0) {
+		dev_err(&client->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+
+	//acc->client->addr = KXTJ9_ACC_I2C_ADDR;
+	
+	i2c_set_clientdata(client, acc);
+
+	if (acc->pdata->init) {
+		err = acc->pdata->init();
+		if (err < 0) {
+			dev_err(&client->dev, "init failed: %d\n", err);
+			goto err2;
+		}
+
+	}
+
+  err = kxtj9_acc_device_power_on(acc);
+	if (err < 0) {
+		dev_err(&client->dev, "power on failed: %d\n", err);
+		goto err2;
+	}
+
+
+
+
+	memset(acc->resume_state, 0, ARRAY_SIZE(acc->resume_state));
+#if 0
+	acc->resume_state[RES_CTRL_REG1] = KXTJ9_ACC_ENABLE_ALL_AXES;
+	acc->resume_state[RES_CTRL_REG2] = 0x00;
+	acc->resume_state[RES_CTRL_REG3] = 0x00;
+	acc->resume_state[RES_CTRL_REG4] = 0x00;
+	acc->resume_state[RES_CTRL_REG5] = 0x00;
+	acc->resume_state[RES_CTRL_REG6] = 0x00;
+
+	acc->resume_state[RES_TEMP_CFG_REG] = 0x00;
+	acc->resume_state[RES_FIFO_CTRL_REG] = 0x00;
+	acc->resume_state[RES_INT_CFG1] = 0x00;
+	acc->resume_state[RES_INT_THS1] = 0x00;
+	acc->resume_state[RES_INT_DUR1] = 0x00;
+	acc->resume_state[RES_INT_CFG2] = 0x00;
+	acc->resume_state[RES_INT_THS2] = 0x00;
+	acc->resume_state[RES_INT_DUR2] = 0x00;
+
+	acc->resume_state[RES_TT_CFG] = 0x00;
+	acc->resume_state[RES_TT_THS] = 0x00;
+	acc->resume_state[RES_TT_LIM] = 0x00;
+	acc->resume_state[RES_TT_TLAT] = 0x00;
+	acc->resume_state[RES_TT_TW] = 0x00;
+#endif
+
+	atomic_set(&acc->enabled, 1);
+
+	
+
+	err = kxtj9_acc_input_init(acc);
+	if (err < 0) {
+		dev_err(&client->dev, "input init failed\n");
+		goto err_power_off;
+	}
+	kxtj9_acc_misc_data = acc;
+
+	kxtj9_acc_misc_data->get_cali_flag = 0;
+
+	err = misc_register(&kxtj9_acc_misc_device);
+	if (err < 0) {
+		dev_err(&client->dev,
+			"misc KXTJ9_ACC_DEV_NAME register failed\n");
+		goto err_input_cleanup;
+	}
+        
+	 // Create proc file system
+   	kxtj_cali_proc = proc_create(KXTJ_CALI_PROC_FILE, 0666, NULL, &kxtj_cali_proc_fops);
+    	if (kxtj_cali_proc == NULL)
+    	{
+        	printk("create_proc_entry %s failed\n", KXTJ_CALI_PROC_FILE);
+    	}
+  
+           
+	kxtj9_acc_device_power_off(acc);
+
+	/* As default, do not report information */
+	atomic_set(&acc->enabled, 0);
+/*
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	acc->early_suspend.suspend = kxtj9_early_suspend;
+	acc->early_suspend.resume = kxtj9_early_resume;
+	acc->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+	register_early_suspend(&acc->early_suspend);
+#endif
+*/
+	mutex_unlock(&acc->lock);
+	dev_info(&client->dev, "###%s###\n", __func__);
+	printk("sprd-gsensor: -- %s -- success !\n",__func__);
+	return 0;
+
+err_input_cleanup:
+	kxtj9_acc_input_cleanup(acc);
+
+err_power_off:
+	kxtj9_acc_device_power_off(acc);
+
+err2:
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+
+exit_kfree_pdata:
+	kfree(acc->pdata);
+
+err_destoyworkqueue2:
+	if (acc->irq2_work_queue)
+		destroy_workqueue(acc->irq2_work_queue);
+
+err_free_irq2:
+	if (acc->irq2) {
+		free_irq(acc->irq2, acc);
+		gpio_free(GSENSOR_GINT2_GPI);
+	}
+
+err_destoyworkqueue1:
+	if (acc->irq1_work_queue)
+		destroy_workqueue(acc->irq1_work_queue);
+
+err_free_irq1:
+	if (acc->irq1) {
+		free_irq(acc->irq1, acc);
+		gpio_free(GSENSOR_GINT1_GPI);
+	}
+
+err_mutexunlockfreedata:
+	i2c_set_clientdata(client, NULL);
+	mutex_unlock(&acc->lock);
+	kfree(acc);
+	kxtj9_acc_misc_data = NULL;
+
+exit_alloc_data_failed:
+exit_check_functionality_failed:
+	pr_err("%s: Driver Init failed\n", KXTJ9_ACC_DEV_NAME);
+exit_alloc_platform_data_failed:
+	return err;
+}
+
+static int  kxtj9_acc_remove(struct i2c_client *client)
+{
+	/* TODO: revisit ordering here once _probe order is finalized */
+
+	struct kxtj9_acc_data *acc = i2c_get_clientdata(client);
+	if (acc != NULL) {
+		if (acc->irq1) {
+			free_irq(acc->irq1, acc);
+			gpio_free(GSENSOR_GINT1_GPI);
+		}
+		if (acc->irq2) {
+			free_irq(acc->irq2, acc);
+			gpio_free(GSENSOR_GINT2_GPI);
+		}
+
+		if (acc->irq1_work_queue)
+			destroy_workqueue(acc->irq1_work_queue);
+		if (acc->irq2_work_queue)
+			destroy_workqueue(acc->irq2_work_queue);
+		misc_deregister(&kxtj9_acc_misc_device);
+		kxtj9_acc_input_cleanup(acc);
+		kxtj9_acc_device_power_off(acc);
+		if (acc->pdata->exit)
+			acc->pdata->exit();
+		kfree(acc->pdata);
+		kfree(acc);
+	}
+
+	return 0;
+}
+
+static int kxtj9_acc_resume(struct i2c_client *client)
+{
+	struct kxtj9_acc_data *acc = i2c_get_clientdata(client);
+	//printk("sprd-gsensor: -- %s -- !\n",__func__);
+	dev_dbg(&client->dev, "###%s###\n", __func__);
+
+	if (acc != NULL && acc->on_before_suspend)
+		return kxtj9_acc_enable(acc);
+
+	return 0;
+}
+
+static int kxtj9_acc_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct kxtj9_acc_data *acc = i2c_get_clientdata(client);
+	//printk("sprd-gsensor: -- %s -- !\n",__func__);
+	dev_dbg(&client->dev, "###%s###\n", __func__);
+
+	if (acc != NULL) {
+		acc->on_before_suspend = atomic_read(&acc->enabled);
+		return kxtj9_acc_disable(acc);
+	}
+	return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+
+static void kxtj9_early_suspend(struct early_suspend *es)
+{
+	kxtj9_acc_suspend(kxtj9_i2c_client, (pm_message_t) {
+			   .event = 0});
+}
+
+static void kxtj9_early_resume(struct early_suspend *es)
+{
+	kxtj9_acc_resume(kxtj9_i2c_client);
+}
+
+#endif /* CONFIG_HAS_EARLYSUSPEND */
+
+static const struct i2c_device_id kxtj9_acc_id[]
+= { {KXTJ9_ACC_I2C_NAME, 0}, {}, };
+
+MODULE_DEVICE_TABLE(i2c, kxtj9_acc_id);
+
+static const struct of_device_id kxtj9_acc_of_match[] = {
+       { .compatible = "kionix,kxtj9_acc", },
+       { }
+};
+MODULE_DEVICE_TABLE(of, kxtj9_acc_of_match);
+
+static struct i2c_driver kxtj9_acc_driver = {
+	.driver = {
+		   .name = KXTJ9_ACC_I2C_NAME,
+		   .of_match_table = kxtj9_acc_of_match,
+		   },
+	.probe = kxtj9_acc_probe,
+	.remove = kxtj9_acc_remove,
+	.resume = kxtj9_acc_resume,
+	.suspend = kxtj9_acc_suspend,
+	.id_table = kxtj9_acc_id,
+};
+
+
+static int __init kxtj9_acc_init(void)
+{
+	pr_debug("%s accelerometer driver: init\n", KXTJ9_ACC_I2C_NAME);
+
+
+	return i2c_add_driver(&kxtj9_acc_driver);
+}
+
+static void __exit kxtj9_acc_exit(void)
+{
+	pr_debug("%s accelerometer driver exit\n", KXTJ9_ACC_DEV_NAME);
+
+
+	i2c_del_driver(&kxtj9_acc_driver);
+	return;
+}
+
+module_init(kxtj9_acc_init);
+module_exit(kxtj9_acc_exit);
+
+MODULE_DESCRIPTION("kxtj9 accelerometer misc driver");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL");
Index: kernel/drivers/input/misc/stk3x1x.c
===================================================================
--- kernel/drivers/input/misc/stk3x1x.c	(revision 166558)
+++ kernel/drivers/input/misc/stk3x1x.c	(revision 166559)
@@ -1,8 +1,10 @@
 /*
- *  stk3x1x.c - Linux kernel modules for sensortek stk301x, stk321x, stk331x 
+ *  stk3x1x.c - Linux kernel modules for sensortek stk301x, stk321x, stk331x
  *  , and stk3410 proximity/ambient light sensor
  *
- *  Copyright (C) 2012~2014 Lex Hsieh / sensortek <lex_hsieh@sensortek.com.tw>
+ *  Copyright (C) :
+ *  1)2012~2015 Lex Hsieh / sensortek <lex_hsieh@sensortek.com.tw>
+ *  
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -19,284 +21,97 @@
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include <linux/delay.h>
 #include <linux/module.h>
-#include <linux/init.h>
+#include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/i2c.h>
-#include <linux/mutex.h>
-#include <linux/kdev_t.h>
-#include <linux/fs.h>
+#include <linux/irq.h>
 #include <linux/input.h>
-#include <linux/workqueue.h>
-#include <linux/irq.h>
-#include <linux/delay.h>
-#include <linux/sched.h>
-#include <linux/kthread.h>
-#include <linux/errno.h>
-#include <linux/wakelock.h>
-#include <linux/interrupt.h>
 #include <linux/gpio.h>
-#include   <linux/fs.h>   
-#include  <asm/uaccess.h> 
-#include <linux/device.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
 #include <linux/miscdevice.h>
-#ifdef CONFIG_OF
-#include <linux/of_gpio.h>
-#endif
-#ifdef CONFIG_HAS_EARLYSUSPEND
-//#include <linux/earlysuspend.h>
-#endif
+#include <linux/wakelock.h>
+#include "stk3x1x.h"
 
-#define DRIVER_VERSION  "3.8.0"
+#define DRIVER_VERSION  "3.10.1 20160628"
+#define PRINT_WARN(x...)  printk(KERN_INFO "[STK3x1x_WARN] " x)
+#define PRINT_ERR(format,x...)  printk(KERN_ERR "[STK3x1x] func: %s  line: %04d  info: " format, __func__, __LINE__, ## x) 
 
-/* Driver Settings */
-#define CONFIG_STK_PS_ALS_USE_CHANGE_THRESHOLD
-#ifdef CONFIG_STK_PS_ALS_USE_CHANGE_THRESHOLD
-#define STK_ALS_CHANGE_THD	0	/* The threshold to trigger ALS interrupt, unit: lux */	
-#endif	/* #ifdef CONFIG_STK_PS_ALS_USE_CHANGE_THRESHOLD */
-#define STK_INT_PS_MODE			1	/* 1, 2, or 3	*/
-//#define STK_POLL_PS
-#define STK_POLL_ALS		/* ALS interrupt is valid only when STK_INT_PS_MODE = 1	or 4*/
-//#define STK_TUNE0
-//#define CALI_PS_EVERY_TIME
-#define STK_DEBUG_PRINTF
-//#define SPREADTRUM_PLATFORM
-#define STK_ALS_FIR
+#define STK_FLG_ALSDR_MASK            0x80
+#define STK_FLG_PSDR_MASK             0x40
+#define STK_FLG_ALSINT_MASK           0x20
+#define STK_FLG_PSINT_MASK            0x10
+#define STK_FLG_OUI_MASK              0x04
+#define STK_FLG_IR_RDY_MASK           0x02
+#define STK_FLG_NF_MASK               0x01
 
-#define STK_WRITE_CALI 1
+#define STK_IRC_MAX_ALS_CODE                20000
+#define STK_IRC_MIN_ALS_CODE                25
+#define STK_IRC_MIN_IR_CODE                 50
+#define STK_IRC_ALS_DENOMI          	    2
+#define STK_IRC_ALS_NUMERA         		    5
+#define STK_IRC_ALS_CORREC         		    850
 
-//#define STK_IRS
-//#define STK_CHK_REG
-//#define STK_GES
-//#define QUALCOMM_PLATFORM
+#define STK_IRS_IT_REDUCE                   2
+#define STK_ALS_READ_IRS_IT_REDUCE          5
+#define STK_ALS_THRESHOLD                   30
 
+#define STK3310SA_PID               0x17
+#define STK3311SA_PID               0x1E
+#define STK3311WV_PID               0x1D
 
-#ifdef QUALCOMM_PLATFORM
-	#include <linux/sensors.h>
-	#include <linux/regulator/consumer.h>	
-	#define STK_QUALCOMM_POWER_CTRL
-#endif
-
-#ifdef SPREADTRUM_PLATFORM
-	#include "stk3x1x.h"
-#else
-	#include "linux/i2c/stk3x1x.h"
-#endif
-/* Define Register Map */
-#define STK_STATE_REG 			0x00
-#define STK_PSCTRL_REG 			0x01
-#define STK_ALSCTRL_REG 			0x02
-#define STK_LEDCTRL_REG 			0x03
-#define STK_INT_REG 				0x04
-#define STK_WAIT_REG 			0x05
-#define STK_THDH1_PS_REG 		0x06
-#define STK_THDH2_PS_REG 		0x07
-#define STK_THDL1_PS_REG 		0x08
-#define STK_THDL2_PS_REG 		0x09
-#define STK_THDH1_ALS_REG 		0x0A
-#define STK_THDH2_ALS_REG 		0x0B
-#define STK_THDL1_ALS_REG 		0x0C
-#define STK_THDL2_ALS_REG 		0x0D
-#define STK_FLAG_REG 			0x10
-#define STK_DATA1_PS_REG	 	0x11
-#define STK_DATA2_PS_REG 		0x12
-#define STK_DATA1_ALS_REG 		0x13
-#define STK_DATA2_ALS_REG 		0x14
-#define STK_DATA1_OFFSET_REG 	0x15
-#define STK_DATA2_OFFSET_REG 	0x16
-#define STK_DATA1_IR_REG 		0x17
-#define STK_DATA2_IR_REG 		0x18
-#define STK_PDT_ID_REG 			0x3E
-#define STK_RSRVD_REG 			0x3F
-#define STK_SW_RESET_REG		0x80
-
-#define STK_GSCTRL_REG			0x1A
-#define STK_FLAG2_REG			0x1C
-
-/* Define state reg */
-#define STK_STATE_EN_IRS_SHIFT  	7
-#define STK_STATE_EN_AK_SHIFT  	6
-#define STK_STATE_EN_ASO_SHIFT  	5
-#define STK_STATE_EN_IRO_SHIFT  	4
-#define STK_STATE_EN_WAIT_SHIFT  	2
-#define STK_STATE_EN_ALS_SHIFT  	1
-#define STK_STATE_EN_PS_SHIFT  	0
-
-#define STK_STATE_EN_IRS_MASK	0x80
-#define STK_STATE_EN_AK_MASK	0x40
-#define STK_STATE_EN_ASO_MASK	0x20
-#define STK_STATE_EN_IRO_MASK	0x10
-#define STK_STATE_EN_WAIT_MASK	0x04
-#define STK_STATE_EN_ALS_MASK	0x02
-#define STK_STATE_EN_PS_MASK	0x01
-
-/* Define PS ctrl reg */
-#define STK_PS_PRS_SHIFT  		6
-#define STK_PS_GAIN_SHIFT  		4
-#define STK_PS_IT_SHIFT  			0
-
-#define STK_PS_PRS_MASK			0xC0
-#define STK_PS_GAIN_MASK			0x30
-#define STK_PS_IT_MASK			0x0F
-
-/* Define ALS ctrl reg */
-#define STK_ALS_PRS_SHIFT  		6
-#define STK_ALS_GAIN_SHIFT  		4
-#define STK_ALS_IT_SHIFT  			0
-
-#define STK_ALS_PRS_MASK		0xC0
-#define STK_ALS_GAIN_MASK		0x30
-#define STK_ALS_IT_MASK			0x0F
-	
-/* Define LED ctrl reg */
-#define STK_LED_IRDR_SHIFT  		6
-#define STK_LED_DT_SHIFT  		0
-
-#define STK_LED_IRDR_MASK		0xC0
-#define STK_LED_DT_MASK			0x3F
-	
-/* Define interrupt reg */
-#define STK_INT_CTRL_SHIFT  		7
-#define STK_INT_OUI_SHIFT  		4
-#define STK_INT_ALS_SHIFT  		3
-#define STK_INT_PS_SHIFT  			0
-
-#define STK_INT_CTRL_MASK		0x80
-#define STK_INT_OUI_MASK			0x10
-#define STK_INT_ALS_MASK			0x08
-#define STK_INT_PS_MASK			0x07
-
-#define STK_INT_ALS				0x08
-
-/* Define flag reg */
-#define STK_FLG_ALSDR_SHIFT  		7
-#define STK_FLG_PSDR_SHIFT  		6
-#define STK_FLG_ALSINT_SHIFT  		5
-#define STK_FLG_PSINT_SHIFT  		4
-#define STK_FLG_OUI_SHIFT  		2
-#define STK_FLG_IR_RDY_SHIFT  		1
-#define STK_FLG_NF_SHIFT  		0
-
-#define STK_FLG_ALSDR_MASK		0x80
-#define STK_FLG_PSDR_MASK		0x40
-#define STK_FLG_ALSINT_MASK		0x20
-#define STK_FLG_PSINT_MASK		0x10
-#define STK_FLG_OUI_MASK			0x04
-#define STK_FLG_IR_RDY_MASK		0x02
-#define STK_FLG_NF_MASK			0x01
-	
-/* Define flag2 reg */
-#define STK_FLG2_INT_GS_SHIFT		6
-#define STK_FLG2_GS10_SHIFT		5
-#define STK_FLG2_GS01_SHIFT		4
-
-#define STK_FLG2_INT_GS_MASK	0x40
-#define STK_FLG2_GS10_MASK		0x20
-#define STK_FLG2_GS01_MASK		0x10
-
-	
 /* misc define */
-#define MIN_ALS_POLL_DELAY_NS	60000000
+#define MIN_ALS_POLL_DELAY_NS               60000000
 
+/* Driver Settings */
+#define CONFIG_STK_PS_ALS_USE_CHANGE_THRESHOLD
+#ifdef CONFIG_STK_PS_ALS_USE_CHANGE_THRESHOLD
+#define STK_ALS_CHANGE_THD              5   //10      /* The threshold to trigger ALS interrupt, unit: lux */
+#endif 
 
-#ifdef STK_TUNE0
-	#define STK_MAX_MIN_DIFF	100
-	#define STK_LT_N_CT	50//100
-	#define STK_HT_N_CT	85//150
-#endif	/* #ifdef STK_TUNE0 */
+#define STK_INT_PS_MODE                     1       /* 1, 2, or 3   */
+#define STK_DEBUG_PRINTF
+#define STK_ALS_FIR
 
-#define STK_IRC_MAX_ALS_CODE		20000
-#define STK_IRC_MIN_ALS_CODE		25
-#define STK_IRC_MIN_IR_CODE		50
-#define STK_IRC_ALS_DENOMI		2		
-#define STK_IRC_ALS_NUMERA		5
-#define STK_IRC_ALS_CORREC		850
+#define STK3X1X_DEV_NAME      "stk3x1x_pls"
+#define STK3X1X_INPUT_DEV     "alps_pxy"
+#define STK3X1X_IRQ_GPIO_NUMBER             140
+static struct i2c_client *this_client;
 
-#define DEVICE_NAME		"stk_ps"
-#ifdef QUALCOMM_PLATFORM
-	#define ALS_NAME		"stk3x1x-ls"
-#else
-	#define ALS_NAME "lightsensor-level"
-#endif
-#define PS_NAME "proximity"
+#define MAX_PS_NOISE                3250
+extern int sprd_3rdparty_gpio_pls_irq;
+//#define HQ_PSENSOR_CALIBRATION
 
 
+#define STK_WRITE_CALI 1
 #if STK_WRITE_CALI
 static int cal_finished = 0;
-static int PS_MAX_XTALK = 500;
-static int PS_l_offset	= 100;//100;
-static int PS_h_offset	= 150;//150;
+static int PS_MAX_XTALK = 800;
 #endif
 
 
-
-#ifdef STK_QUALCOMM_POWER_CTRL
-	/* POWER SUPPLY VOLTAGE RANGE */
-	#define STK3X1X_VDD_MIN_UV	2000000
-	#define STK3X1X_VDD_MAX_UV	3300000
-	#define STK3X1X_VIO_MIN_UV	1750000
-	#define STK3X1X_VIO_MAX_UV	1950000
+#ifdef HQ_PSENSOR_CALIBRATION
+static int stk3x1x_psensor_calibrate(void);
+static int stk3x1x_get_init_noise(void);
 #endif
 
-#ifdef QUALCOMM_PLATFORM
-
-static struct sensors_classdev sensors_light_cdev = {
-	.name = "stk3x1x-light",
-	.vendor = "Sensortek",
-	.version = 1,
-	.handle = SENSORS_LIGHT_HANDLE,
-	.type = SENSOR_TYPE_LIGHT,
-	.max_range = "6500",
-	.resolution = "0.0625",
-	.sensor_power = "0.09",
-	.min_delay = (MIN_ALS_POLL_DELAY_NS / 1000),	/* us */
-	.fifo_reserved_event_count = 0,
-	.fifo_max_event_count = 0,
-	.enabled = 0,
-	.delay_msec = 200,
-	.sensors_enable = NULL,
-	.sensors_poll_delay = NULL,
+static struct stk3x1x_platform_data stk3x1x_pfdata = {
+  .state_reg = 0x02,    /* disable all */
+  .psctrl_reg = 0x31,    /* ps_persistance = 1, ps_gain = 64X, PS_IT = 0.391ms */
+  .alsctrl_reg = 0x39,  /* als_persistance=1, als_gain = 64X, ALS_IT = 100ms */
+  .ledctrl_reg = 0xFF,   /* 100mA IRDR, 64/64 LED duty */
+  .wait_reg = 0xF,    /* 100 ms */
+  .ps_thd_h = 102, //
+  .ps_thd_l = 67, //
+  .int_pin = STK3X1X_IRQ_GPIO_NUMBER,//GPIO_PROX_INT//sprd_3rdparty_gpio_pls_irq
+  .transmittance = 500,     //500 . raw data trans to lux para,   report lux value
 };
 
-static struct sensors_classdev sensors_proximity_cdev = {
-	.name = "stk3x1x-proximity",
-	.vendor = "Sensortek",
-	.version = 1,
-	.handle = SENSORS_PROXIMITY_HANDLE,
-	.type = SENSOR_TYPE_PROXIMITY,
-	.max_range = "5.0",
-	.resolution = "5.0",
-	.sensor_power = "0.1",
-	.min_delay = 0,
-	.fifo_reserved_event_count = 0,
-	.fifo_max_event_count = 0,
-	.enabled = 0,
-	.delay_msec = 200,
-	.sensors_enable = NULL,
-	.sensors_poll_delay = NULL,
-};
-#endif
-
-#if 1//def SPREADTRUM_PLATFORM
-//extern int sprd_3rdparty_gpio_pls_irq;
-
-static struct stk3x1x_platform_data stk3x1x_pfdata={ 
-  .state_reg = 0x0,    /* disable all */ 
-  .psctrl_reg = 0x31,    /* ps_persistance=1, ps_gain=64X, PS_IT=0.391ms */ 
-  .alsctrl_reg = 0x2A, 	/* als_persistance=1, als_gain=16X, ALS_IT=200ms */
-  .ledctrl_reg = 0x3F,   /* 100mA IRDR, 64/64 LED duty */ 
-  .wait_reg = 0x07,    /* 50 ms */   
-  .ps_thd_h =1700, 
-  .ps_thd_l = 1500, 
-  .int_pin = 192,  
-  .transmittance = 500, 
-}; 
-#endif
-
-#ifdef STK_ALS_FIR
-	#define STK_FIR_LEN	8
-	#define MAX_FIR_LEN 32
-	
+#ifdef STK_ALS_FIR//avg
+    #define STK_FIR_LEN             3
+    #define MAX_FIR_LEN             32
 struct data_filter {
     u16 raw[MAX_FIR_LEN];
     int sum;
@@ -305,267 +120,227 @@
 };
 #endif
 
-#ifdef STK_GES
-union stk_ges_operation{
-	uint8_t ops[4];
-	struct {
-		uint8_t rw_len_retry;
-		uint8_t reg;
-		uint8_t reg_value_retry_crit;
-		uint8_t sleep_10ns;
-	}action;
-};
-
-union stk_ges_operation stk_ges_op[10] =
-{
-	{.ops={0xc1, 0x24, 0, 0}},
-	{.ops={0, 0, 0, 0}},	
-	{.ops={0, 0, 0, 0}},	
-	{.ops={0, 0, 0, 0}},	
-	{.ops={0, 0, 0, 0}},	
-	{.ops={0, 0, 0, 0}},	
-	{.ops={0, 0, 0, 0}},	
-	{.ops={0, 0, 0, 0}},	
-	{.ops={0, 0, 0, 0}},	
-	{.ops={0, 0, 0, 0}}
-};
-#endif
-
 struct stk3x1x_data {
-	struct i2c_client *client;
-	struct stk3x1x_platform_data *pdata;
-#ifdef QUALCOMM_PLATFORM
-	struct sensors_classdev als_cdev;
-	struct sensors_classdev ps_cdev;
-#endif
-#if (!defined(STK_POLL_PS) || !defined(STK_POLL_ALS))
+    struct i2c_client *client;
+    struct stk3x1x_platform_data *pdata;
     int32_t irq;
+    int int_pin;
     struct work_struct stk_work;
-	struct workqueue_struct *stk_wq;	
-#endif	
-	uint16_t ir_code;
-	uint16_t als_correct_factor;
-	uint8_t alsctrl_reg;
-	uint8_t psctrl_reg;
-	uint8_t ledctrl_reg;
-	uint8_t state_reg;
-	int		int_pin;
-	uint8_t wait_reg;
-	uint8_t int_reg;
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	//struct early_suspend stk_early_suspend;
-#endif	
-	uint16_t ps_thd_h;
-	uint16_t ps_thd_l;
-#ifdef CALI_PS_EVERY_TIME	
-	uint16_t ps_high_thd_boot;
-	uint16_t ps_low_thd_boot;
-#endif	
-	struct mutex io_lock;
-	struct input_dev *ps_input_dev;
-	int32_t ps_distance_last;
-	bool ps_enabled;
-	bool re_enable_ps;
-	struct wake_lock ps_wakelock;	
-#ifdef STK_POLL_PS		
-	struct hrtimer ps_timer;	
-    struct work_struct stk_ps_work;
-	struct workqueue_struct *stk_ps_wq;
-	struct wake_lock ps_nosuspend_wl;		
-#endif
-	struct input_dev *als_input_dev;
-	int32_t als_lux_last;
-	uint32_t als_transmittance;	
-	bool als_enabled;
-	bool re_enable_als;
-	ktime_t ps_poll_delay;
-	ktime_t als_poll_delay;
-#ifdef STK_POLL_ALS		
+    struct workqueue_struct *stk_wq;
+    uint16_t ir_code;
+    uint16_t als_correct_factor;
+    uint8_t state_reg;
+    uint8_t psctrl_reg;
+    uint8_t alsctrl_reg;
+    uint8_t ledctrl_reg;
+    uint8_t wait_reg;
+    uint8_t int_reg;
+    uint16_t ps_thd_h;
+    uint16_t ps_thd_l;
+    struct mutex io_lock;
+    struct input_dev *ps_input_dev;
+    int32_t ps_distance_last;
+    bool ps_enabled;
+    bool re_enable_ps;
+    struct wake_lock ps_wakelock;
+    struct input_dev *als_input_dev;
+    int32_t als_lux_last;
+    uint32_t als_transmittance;
+    bool als_enabled;
+    bool re_enable_als;
+    ktime_t ps_poll_delay;
+    ktime_t als_poll_delay;
     struct work_struct stk_als_work;
-	struct hrtimer als_timer;	
-	struct workqueue_struct *stk_als_wq;
-#endif	
-	bool first_boot;
-#ifdef STK_TUNE0
-	uint16_t psa;
-	uint16_t psi;	
-	uint16_t psi_set;	
-	struct hrtimer ps_tune0_timer;	
-	struct workqueue_struct *stk_ps_tune0_wq;
-    struct work_struct stk_ps_tune0_work;
-	ktime_t ps_tune0_delay;
-	bool tune_zero_init_proc;
-	uint32_t ps_stat_data[3];
-	int data_count;
-
-	int stk_max_min_diff;
-#endif
-	int stk_lt_n_ct;
-	int stk_ht_n_ct;
-	
+    struct hrtimer als_timer;
+    struct workqueue_struct *stk_als_wq;
 #ifdef STK_ALS_FIR
-	struct data_filter      fir;
-	atomic_t                firlength;	
+    struct data_filter fir;
+    atomic_t firlength;
 #endif
-	atomic_t	recv_reg;
-
-#ifdef STK_GES		
-	struct input_dev *ges_input_dev;
-	int ges_enabled;
-	int re_enable_ges;	
-	atomic_t gesture2;
-#endif	
-#ifdef STK_IRS
-	int als_data_index;
-#endif	
-#ifdef STK_QUALCOMM_POWER_CTRL
-	struct regulator *vdd;
-	struct regulator *vio;
-	bool power_enabled;
-#endif	
+    atomic_t recv_reg;
+    uint8_t pid;
+    uint8_t p_wv_r_bd_with_co;
+    uint32_t als_code_last;
+#ifdef HQ_PSENSOR_CALIBRATION
+    int init_noise;
+    int current_xtalk;
+#endif
 };
 
-struct stk3x1x_data *stk3x1x_i2c_data = NULL;
-
 #if( !defined(CONFIG_STK_PS_ALS_USE_CHANGE_THRESHOLD))
-static uint32_t lux_threshold_table[] =
-{
-	3,
-	10,
-	40,
-	65,
-	145,
-	300,
-	550,
-	930,
-	1250,
-	1700,
-};
+static uint32_t lux_threshold_table[] = { 3,10,40,65,145,300,550,930,1250,1700,};
 
 #define LUX_THD_TABLE_SIZE (sizeof(lux_threshold_table)/sizeof(uint32_t)+1)
 static uint16_t code_threshold_table[LUX_THD_TABLE_SIZE+1];
-#endif 	
+#endif
 
-static int32_t stk3x1x_enable_ps(struct stk3x1x_data *ps_data, uint8_t enable, uint8_t validate_reg);
+static int32_t stk3x1x_enable_ps(struct stk3x1x_data *ps_data, uint8_t enable);
 static int32_t stk3x1x_enable_als(struct stk3x1x_data *ps_data, uint8_t enable);
 static int32_t stk3x1x_set_ps_thd_l(struct stk3x1x_data *ps_data, uint16_t thd_l);
 static int32_t stk3x1x_set_ps_thd_h(struct stk3x1x_data *ps_data, uint16_t thd_h);
 static int32_t stk3x1x_set_als_thd_l(struct stk3x1x_data *ps_data, uint16_t thd_l);
 static int32_t stk3x1x_set_als_thd_h(struct stk3x1x_data *ps_data, uint16_t thd_h);
-static int32_t stk3x1x_get_ir_reading(struct stk3x1x_data *ps_data);
-#ifdef STK_TUNE0
-static int stk_ps_tune_zero_func_fae(struct stk3x1x_data *ps_data);
-#endif
-#ifdef STK_CHK_REG
-static int stk3x1x_validate_n_handle(struct i2c_client *client);
-#endif
-static int stk_ps_val(struct stk3x1x_data *ps_data);
-#ifdef STK_QUALCOMM_POWER_CTRL
-static int stk3x1x_device_ctl(struct stk3x1x_data *ps_data, bool enable);
-#endif
+static int32_t stk3x1x_get_ir_reading(struct stk3x1x_data *ps_data, int32_t als_it_reduce);
+static int32_t stk3x1x_init_all_setting(struct i2c_client *client, struct stk3x1x_platform_data *plat_data);
 
-static int stk3x1x_i2c_read_data(struct i2c_client *client, unsigned char command, int length, unsigned char *values)
+
+#if STK_WRITE_CALI
+#define PS_CAL_FILE_PATH	"/productinfo/xtalk_cal"
+
+static int write_factory_calibration(char* ps_data, int ps_cal_len)
 {
-	uint8_t retry;	
-	int err;
-	struct i2c_msg msgs[] = 
+	struct file *fp_cal;
+	mm_segment_t fs;
+	loff_t pos;
+
+	pos = 0;
+	fp_cal = filp_open(PS_CAL_FILE_PATH, O_CREAT|O_RDWR|O_TRUNC, 0660);
+	if (IS_ERR(fp_cal))
 	{
-		{
-			.addr = client->addr,
-			.flags = 0,
-			.len = 1,
-			.buf = &command,
-		},
-		{
-			.addr = client->addr,
-			.flags = I2C_M_RD,
-			.len = length,
-			.buf = values,
-		},
-	};
-	
-	for (retry = 0; retry < 5; retry++) 
-	{
-		err = i2c_transfer(client->adapter, msgs, 2);
-		if (err == 2)
-			break;
-		else
-			mdelay(5);
+		printk("[stk3x1x %s] create file error\n", __func__);
+		return -1;
 	}
-	
-	if (retry >= 5) 
-	{
-		printk(KERN_ERR "%s: i2c read fail, err=%d\n", __func__, err);
-		return -EIO;
-	} 
-	return 0;		
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	vfs_write(fp_cal, ps_data, ps_cal_len, &pos);
+	filp_close(fp_cal, NULL);
+	set_fs(fs);
+
+	return 0;
 }
 
-static int stk3x1x_i2c_write_data(struct i2c_client *client, unsigned char command, int length, unsigned char *values)
+static int read_factory_calibration(struct stk3x1x_data *pstk_data)
 {
-	int retry;
-	int err;	
-	unsigned char data[11];
-	struct i2c_msg msg;
-	int index;
+	struct file *fp;
+	mm_segment_t fs;
+	loff_t pos;
+	char buffer[100]= {0};
 
-    if (!client)
+	fp = filp_open(PS_CAL_FILE_PATH, O_RDWR, S_IRUSR);
+	if (IS_ERR(fp))
+	{
+		printk("[stk3x1x %s] no PS calibration file(%d)\n", __func__, (int)IS_ERR(fp));
 		return -EINVAL;
-    else if (length >= 10) 
-	{        
-        printk(KERN_ERR "%s:length %d exceeds 10\n", __func__, length);
-        return -EINVAL;
-    }   	
-	
-	data[0] = command;
-	for (index=1;index<=length;index++)
-		data[index] = values[index-1];	
-	
-	msg.addr = client->addr;
-	msg.flags = 0;
-	msg.len = length+1;
-	msg.buf = data;
-	
-	for (retry = 0; retry < 5; retry++) 
-	{
-		err = i2c_transfer(client->adapter, &msg, 1);
-		if (err == 1)
-			break;
-		else
-			mdelay(5);
 	}
-	
-	if (retry >= 5) 
+	else
 	{
-		printk(KERN_ERR "%s: i2c write fail, err=%d\n", __func__, err);		
-		return -EIO;
+		int ps_hthr = 0, ps_lthr = 0;
+
+		pos = 0;
+		fs = get_fs();
+		set_fs(KERNEL_DS);
+		vfs_read(fp, buffer, sizeof(buffer), &pos);
+		filp_close(fp, NULL);
+		sscanf(buffer, "%d,%d", &ps_hthr, &ps_lthr);
+		set_fs(fs);
+		pstk_data->ps_thd_h = ps_hthr;
+		pstk_data->ps_thd_l = ps_lthr;
+
+		printk("[stk3x1x %s] high:%d low:%d\n", __func__, pstk_data->ps_thd_h, pstk_data->ps_thd_l);
 	}
 	return 0;
 }
+#endif
 
+static int stk3x1x_i2c_read_data(struct i2c_client *client, unsigned char command, int length, unsigned char *values)
+{
+    uint8_t retry;
+    int err;
+    struct i2c_msg msgs[] = {
+        {
+            .addr = client->addr,
+            .flags = 0,
+            .len = 1,
+            .buf = &command,
+        },
+        {
+            .addr = client->addr,
+            .flags = I2C_M_RD,
+            .len = length,
+            .buf = values,
+        },
+    };
+
+    for (retry = 0; retry < 5; retry++) {
+        err = i2c_transfer(client->adapter, msgs, 2);
+        if (err == 2)
+            break;
+        else
+            mdelay(5);
+    }
+
+    if (retry >= 5) {
+        PRINT_ERR("%s: i2c read fail, err = %d\n", __func__, err);
+        return -EIO;
+    }
+    return 0;
+}
+
+static int stk3x1x_i2c_write_data(struct i2c_client *client, unsigned char command, int length, unsigned char *values)
+{
+    int retry;
+    int err;
+    unsigned char data[11];
+    struct i2c_msg msg;
+    int index;
+    //printk("stk3x1x_i2c_write_data");
+
+    if (!client)
+        return -EINVAL;
+    else if (length >= 10) {
+        PRINT_ERR("%s:length %d exceeds 10\n", __func__, length);
+        return -EINVAL;
+    }
+
+    data[0] = command;
+    for (index = 1;index<= length;index++) {
+        data[index] = values[index-1];
+        }
+
+    msg.addr = client->addr;
+    msg.flags = 0;
+    msg.len = length+1;
+    msg.buf = data;
+
+    for (retry = 0; retry < 5; retry++) {
+        err = i2c_transfer(client->adapter, &msg, 1);
+        if (err == 1)
+                break;
+        else
+                mdelay(5);
+    }
+
+    if (retry >= 5) {
+        PRINT_ERR( "%s: i2c write fail, err=%d\n", __func__, err);
+        return -EIO;
+    }
+    return 0;
+}
+
 static int stk3x1x_i2c_smbus_read_byte_data(struct i2c_client *client, unsigned char command)
 {
-	unsigned char value;
-	int err;
-	err = stk3x1x_i2c_read_data(client, command, 1, &value);
-	if(err < 0)
-		return err;
-	return value;
+    unsigned char value;
+    int err;
+    err = stk3x1x_i2c_read_data(client, command, 1, &value);
+    if (err < 0)
+        return err;
+    return value;
 }
 
 static int stk3x1x_i2c_smbus_write_byte_data(struct i2c_client *client, unsigned char command, unsigned char value)
 {
-	int err;
-	err = stk3x1x_i2c_write_data(client, command, 1, &value);
-	return err;
+    int err;
+    err = stk3x1x_i2c_write_data(client, command, 1, &value);
+    return err;
 }
 
 uint32_t stk_alscode2lux(struct stk3x1x_data *ps_data, uint32_t alscode)
 {
-	alscode += ((alscode<<7)+(alscode<<3)+(alscode>>1));   
-    alscode<<=3; 
+    alscode += ((alscode<<7)+(alscode<<3)+(alscode>>1));
+    alscode<<=3;
     alscode/=ps_data->als_transmittance;
-	return alscode;
+    return alscode;
 }
 
 uint32_t stk_lux2alscode(struct stk3x1x_data *ps_data, uint32_t lux)
@@ -572,8 +347,9 @@
 {
     lux*=ps_data->als_transmittance;
     lux/=1100;
-    if (unlikely(lux>=(1<<16)))
+    if (unlikely(lux>=(1<<16))) {
         lux = (1<<16) -1;
+    }
     return lux;
 }
 
@@ -584,26 +360,23 @@
     uint32_t alscode;
 
     code_threshold_table[0] = 0;
-#ifdef STK_DEBUG_PRINTF	
-    printk(KERN_INFO "alscode[0]=%d\n",0);
-#endif	
-    for (i=1,j=0;i<LUX_THD_TABLE_SIZE;i++,j++)
-    {
+#ifdef STK_DEBUG_PRINTF
+    PRINT_WARN( "alscode[0]=%d\n",0);
+#endif
+    for (i=1,j=0;i<LUX_THD_TABLE_SIZE;i++,j++) {
         alscode = stk_lux2alscode(ps_data, lux_threshold_table[j]);
-        printk(KERN_INFO "alscode[%d]=%d\n",i,alscode);
+        PRINT_WARN( "alscode[%d]=%d\n",i,alscode);
         code_threshold_table[i] = (uint16_t)(alscode);
     }
     code_threshold_table[i] = 0xffff;
-    printk(KERN_INFO "alscode[%d]=%d\n",i,alscode);
+    PRINT_WARN( "alscode[%d]=%d\n",i,alscode);
 }
 
 static uint32_t stk_get_lux_interval_index(uint16_t alscode)
 {
     uint32_t i;
-    for (i=1;i<=LUX_THD_TABLE_SIZE;i++)
-    {
-        if ((alscode>=code_threshold_table[i-1])&&(alscode<code_threshold_table[i]))
-        {
+    for (i=1;i<=LUX_THD_TABLE_SIZE;i++) {
+        if ((alscode>=code_threshold_table[i-1])&&(alscode<code_threshold_table[i])){
             return i;
         }
     }
@@ -615,698 +388,353 @@
     int32_t high_thd,low_thd;
     high_thd = alscode + stk_lux2alscode(ps_data, STK_ALS_CHANGE_THD);
     low_thd = alscode - stk_lux2alscode(ps_data, STK_ALS_CHANGE_THD);
-    if (high_thd >= (1<<16))
+    if (high_thd >= (1<<16)) {
         high_thd = (1<<16) -1;
-    if (low_thd <0)
+    }
+    if (low_thd <0) {
         low_thd = 0;
+    }
     stk3x1x_set_als_thd_h(ps_data, (uint16_t)high_thd);
     stk3x1x_set_als_thd_l(ps_data, (uint16_t)low_thd);
 }
 #endif // CONFIG_STK_PS_ALS_USE_CHANGE_THRESHOLD
 
-#if STK_WRITE_CALI
-#define PS_CAL_FILE_PATH	"/productinfo/xtalk_cal"
 
-static int write_factory_calibration(char* ps_data, int ps_cal_len)
+static void stk3x1x_proc_plat_data(struct stk3x1x_data *ps_data, struct stk3x1x_platform_data *plat_data)
 {
-	struct file *fp_cal;
-	mm_segment_t fs;
-	loff_t pos;
+    uint8_t w_reg;
 
-	pos = 0;
-	fp_cal = filp_open(PS_CAL_FILE_PATH, O_CREAT|O_RDWR|O_TRUNC, 0660);
-	if (IS_ERR(fp_cal))
-	{
-		printk("[stk3x1x %s] create file error\n", __func__);
-		return -1;
-	}
+    ps_data->state_reg = plat_data->state_reg;
+    ps_data->psctrl_reg = plat_data->psctrl_reg;
+    ps_data->alsctrl_reg = plat_data->alsctrl_reg;
+    ps_data->ledctrl_reg = plat_data->ledctrl_reg;
+    if (ps_data->pid == STK3310SA_PID || ps_data->pid == STK3311SA_PID) {
+        ps_data->ledctrl_reg &= 0x3F;
+    }
 
-	fs = get_fs();
-	set_fs(KERNEL_DS);
-	vfs_write(fp_cal, ps_data, ps_cal_len, &pos);
-	filp_close(fp_cal, NULL);
-	set_fs(fs);
+    ps_data->wait_reg = plat_data->wait_reg;
+    if (ps_data->wait_reg < 2) {
+        printk(KERN_WARNING "%s: wait_reg should be larger than 2, force to write 2\n", __func__);
+        ps_data->wait_reg = 2;
+    }
+    else if (ps_data->wait_reg > 0xFF) {
+        printk(KERN_WARNING "%s: wait_reg should be less than 0xFF, force to write 0xFF\n", __func__);
+        ps_data->wait_reg = 0xFF;
+    }
+    
+    if (ps_data->ps_thd_h == 0 && ps_data->ps_thd_l == 0) {
+        ps_data->ps_thd_h = plat_data->ps_thd_h;
+        ps_data->ps_thd_l = plat_data->ps_thd_l;
+    }
+    
+    w_reg = 0;
+    w_reg |= STK_INT_PS_MODE;
 
-	return 0;
+    ps_data->int_reg = w_reg;
+    return;
 }
 
-static int read_factory_calibration(struct stk3x1x_data *pstk_data)
-{
-	struct file *fp;
-	mm_segment_t fs;
-	loff_t pos;
-	char buffer[100]= {0};
-
-	fp = filp_open(PS_CAL_FILE_PATH, O_RDWR, S_IRUSR);
-	if (IS_ERR(fp))
-	{
-		printk("[stk3x1x %s] no PS calibration file(%d)\n", __func__, (int)IS_ERR(fp));
-		return -EINVAL;
-	}
-	else
-	{
-		int ps_hthr = 0, ps_lthr = 0;
-
-		pos = 0;
-		fs = get_fs();
-		set_fs(KERNEL_DS);
-		vfs_read(fp, buffer, sizeof(buffer), &pos);
-		filp_close(fp, NULL);
-		sscanf(buffer, "%d,%d", &ps_hthr, &ps_lthr);
-		set_fs(fs);
-		pstk_data->ps_thd_h = ps_hthr;
-		pstk_data->ps_thd_l = ps_lthr;
-
-		printk("[stk3x1x %s] high:%d low:%d\n", __func__, pstk_data->ps_thd_h, pstk_data->ps_thd_l);
-	}
-	return 0;
-}
-#endif
-
-static void stk3x1x_proc_plat_data(struct stk3x1x_data *ps_data, struct stk3x1x_platform_data *plat_data)
-{
-	uint8_t w_reg;
-	
-	ps_data->state_reg = plat_data->state_reg;
-	ps_data->psctrl_reg = plat_data->psctrl_reg;
-#ifdef STK_POLL_PS		
-	ps_data->psctrl_reg &= 0x3F;
-#endif		
-	ps_data->alsctrl_reg = plat_data->alsctrl_reg;
-	ps_data->ledctrl_reg = plat_data->ledctrl_reg;
-	
-	ps_data->wait_reg = plat_data->wait_reg;	
-	if(ps_data->wait_reg < 2)
-	{
-		printk(KERN_WARNING "%s: wait_reg should be larger than 2, force to write 2\n", __func__);
-		ps_data->wait_reg = 2;
-	}
-	else if (ps_data->wait_reg > 0xFF)
-	{
-		printk(KERN_WARNING "%s: wait_reg should be less than 0xFF, force to write 0xFF\n", __func__);
-		ps_data->wait_reg = 0xFF;		
-	}
-//#ifndef STK_TUNE0		
-	if(ps_data->ps_thd_h == 0 && ps_data->ps_thd_l == 0)
-	{
-		ps_data->ps_thd_h = plat_data->ps_thd_h;
-		ps_data->ps_thd_l = plat_data->ps_thd_l;		
-	}
-//#endif	
-#ifdef CALI_PS_EVERY_TIME
-	ps_data->ps_high_thd_boot = plat_data->ps_thd_h;
-	ps_data->ps_low_thd_boot = plat_data->ps_thd_l;	
-#endif	
-	w_reg = 0;
-#ifndef STK_POLL_PS	
-	w_reg |= STK_INT_PS_MODE;	
-#else
-	w_reg |= 0x01;		
-#endif	
-
-#if (!defined(STK_POLL_ALS) && (STK_INT_PS_MODE != 0x02) && (STK_INT_PS_MODE != 0x03))
-	w_reg |= STK_INT_ALS;
-#endif	
-	ps_data->int_reg = w_reg;
-	return;
-}
-
 static int32_t stk3x1x_init_all_reg(struct stk3x1x_data *ps_data)
 {
-	int32_t ret;
-	
+    int32_t ret;
+     PRINT_WARN( "stk3x1x_init_all_reg\n");
     ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_STATE_REG, ps_data->state_reg);
-    if (ret < 0)
-    {
-        printk(KERN_ERR "%s: write i2c error\n", __func__);
+    if (ret < 0) {
+        PRINT_ERR( "%s: write i2c error\n", __func__);
         return ret;
-    }		
+    }
     ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_PSCTRL_REG, ps_data->psctrl_reg);
-    if (ret < 0)
-    {
-        printk(KERN_ERR "%s: write i2c error\n", __func__);
+    if (ret < 0) {
+        PRINT_ERR( "%s: write i2c error\n", __func__);
         return ret;
-    }	
+    }
     ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_ALSCTRL_REG, ps_data->alsctrl_reg);
-    if (ret < 0)
-    {
-        printk(KERN_ERR "%s: write i2c error\n", __func__);
+    if (ret < 0) {
+        PRINT_ERR( "%s: write i2c error\n", __func__);
         return ret;
-    }		
+    }
     ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_LEDCTRL_REG, ps_data->ledctrl_reg);
-    if (ret < 0)
-    {
-        printk(KERN_ERR "%s: write i2c error\n", __func__);
+    if (ret < 0) {
+        PRINT_ERR( "%s: write i2c error\n", __func__);
         return ret;
-    }	
+    }
     ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_WAIT_REG, ps_data->wait_reg);
-    if (ret < 0)
-    {
-        printk(KERN_ERR "%s: write i2c error\n", __func__);
+    if (ret < 0) {
+        PRINT_ERR( "%s: write i2c error\n", __func__);
         return ret;
-    }	
-#ifdef STK_TUNE0	
-	ps_data->psa = 0x0;
-	ps_data->psi = 0xFFFF;	
-#endif	
-//#else
-	stk3x1x_set_ps_thd_h(ps_data, ps_data->ps_thd_h);
-	stk3x1x_set_ps_thd_l(ps_data, ps_data->ps_thd_l);	
-//#endif	
+    }
+    stk3x1x_set_ps_thd_h(ps_data, ps_data->ps_thd_h);
+    stk3x1x_set_ps_thd_l(ps_data, ps_data->ps_thd_l);
+    PRINT_WARN( "%s: ps_data->ps_thd_h:%d,ps_data->ps_thd_l:%d\n", __func__,ps_data->ps_thd_h,ps_data->ps_thd_l);
 
     ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_INT_REG, ps_data->int_reg);
-    if (ret < 0)
-	{
-		printk(KERN_ERR "%s: write i2c error\n", __func__);
-		return ret;
-	}		
-	
-	/*
-    ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, 0x87, 0x60);
-    if (ret < 0)
-	{
-		printk(KERN_ERR "%s: write i2c error\n", __func__);
-		return ret;
-	}		
-	*/
-		
-	return 0;	
+    if (ret < 0) {
+        PRINT_ERR( "%s: write i2c error\n", __func__);
+        return ret;
+    }
+    return 0;
 }
-	
 
+static int32_t stk3x1x_read_otp25(struct stk3x1x_data *ps_data)
+{
+    int32_t ret, otp25;
+
+    ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, 0x0, 0x2);
+    if (ret < 0) {
+        PRINT_ERR( "%s: write i2c error\n", __func__);
+        return ret;
+    }
+
+    ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, 0x90, 0x25);
+    if (ret < 0) {
+        PRINT_ERR( "%s: write i2c error\n", __func__);
+        return ret;
+    }
+
+    ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, 0x92, 0x82);
+    if (ret < 0) {
+        PRINT_ERR( "%s: write i2c error\n", __func__);
+        return ret;
+    }
+    usleep_range(1000, 5000);
+
+    ret = stk3x1x_i2c_smbus_read_byte_data(ps_data->client,0x91);
+    if (ret < 0) {
+        PRINT_ERR( "%s: fail, ret=%d\n", __func__, ret);
+        return ret;
+    }
+    otp25 = ret;
+
+    ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, 0x0, 0x0);
+    if (ret < 0) {
+        PRINT_ERR( "%s: write i2c error\n", __func__);
+        return ret;
+    }
+    PRINT_WARN( "%s: otp25=0x%x\n", __func__, otp25);
+    if (otp25 & 0x80)
+        return 1;
+    return 0;
+}
+
 static int32_t stk3x1x_check_pid(struct stk3x1x_data *ps_data)
 {
-	unsigned char value[2], pid_msb;
-	int err;
-	
-	err = stk3x1x_i2c_read_data(ps_data->client, STK_PDT_ID_REG, 2, &value[0]);
-	if(err < 0)
-	{
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, err);
-		return err;
-	}
-	
-	printk(KERN_INFO "%s: PID=0x%x, RID=0x%x\n", __func__, value[0], value[1]);
-	
-	if(value[1] == 0xC0)
-		printk(KERN_INFO "%s: RID=0xC0!!!!!!!!!!!!!\n", __func__);	
-		
-	if(value[0] == 0)
-	{
-		printk(KERN_ERR "PID=0x0, please make sure the chip is stk3x1x!\n");
-		return -2;			
-	}
-	
-	pid_msb = value[0] & 0xF0;
-	switch(pid_msb)
-	{
-	case 0x10:
-	case 0x20:
-	case 0x30:
-	case 0x50:
-		return 0;
-	default:
-		printk(KERN_ERR "%s: invalid PID(%#x)\n", __func__, value[0]);	
-		return -1;
-	}
-	return 0;
+    unsigned char value[2], pid_msb;
+    int err;
+
+    ps_data->p_wv_r_bd_with_co = 0;
+
+    err = stk3x1x_i2c_read_data(ps_data->client, STK_PDT_ID_REG, 2, &value[0]);
+    if (err < 0) {
+        PRINT_ERR( "%s: fail, ret=%d\n", __func__, err);
+        return err;
+    }
+
+    printk("%s: PID=0x%x, RID=0x%x\n", __func__, value[0], value[1]);
+    ps_data->pid = value[0];
+
+    if (value[0] == STK3311WV_PID)
+        ps_data->p_wv_r_bd_with_co |= 0b100;
+    if (value[1] == 0xC3)
+        ps_data->p_wv_r_bd_with_co |= 0b010;
+
+    if (stk3x1x_read_otp25(ps_data) == 1) {
+        ps_data->p_wv_r_bd_with_co |= 0b001;
+    }
+    PRINT_WARN( "%s: p_wv_r_bd_with_co = 0x%x\n", __func__, ps_data->p_wv_r_bd_with_co);
+
+    if (value[0] == 0) {
+        printk("PID=0x0, please make sure the chip is stk3x1x!\n");
+        return -2;
+    }
+
+    pid_msb = value[0] & 0xF0;
+    switch(pid_msb) {
+    case 0x10:
+    case 0x20:
+    case 0x30:
+        return 0;
+    default:
+        printk("%s: invalid PID(%#x)\n", __func__, value[0]);
+        return -1;
+    }
+    return 0;
 }
 
-
 static int32_t stk3x1x_software_reset(struct stk3x1x_data *ps_data)
 {
     int32_t r;
     uint8_t w_reg;
-	
     w_reg = 0x7F;
     r = stk3x1x_i2c_smbus_write_byte_data(ps_data->client,STK_WAIT_REG,w_reg);
-    if (r<0)
-    {
-        printk(KERN_ERR "%s: software reset: write i2c error, ret=%d\n", __func__, r);
+    if (r<0) {
+        PRINT_ERR( "%s: software reset: write i2c error, ret=%d\n", __func__, r);
         return r;
     }
+
     r = stk3x1x_i2c_smbus_read_byte_data(ps_data->client,STK_WAIT_REG);
-    if (w_reg != r)
-    {
-        printk(KERN_ERR "%s: software reset: read-back value is not the same\n", __func__);
+    if (w_reg != r) {
+        PRINT_ERR( "%s: software reset: read-back value is not the same\n", __func__);
         return -1;
     }
-	
+
     r = stk3x1x_i2c_smbus_write_byte_data(ps_data->client,STK_SW_RESET_REG,0);
-    if (r<0)
-    {
-        printk(KERN_ERR "%s: software reset: read error after reset\n", __func__);
+    if (r<0) {
+        PRINT_ERR( "%s: software reset: read error after reset\n", __func__);
         return r;
     }
-	usleep_range(1000, 5000);
+    usleep_range(13000, 15000);
     return 0;
 }
 
-
 static int32_t stk3x1x_set_als_thd_l(struct stk3x1x_data *ps_data, uint16_t thd_l)
 {
-	unsigned char val[2];
-	int ret;
-	val[0] = (thd_l & 0xFF00) >> 8;
-	val[1] = thd_l & 0x00FF;
-	ret = stk3x1x_i2c_write_data(ps_data->client, STK_THDL1_ALS_REG, 2, val);
-	if(ret < 0)
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, ret);	
-	return ret;		
+    unsigned char val[2];
+    int ret;
+    val[0] = (thd_l & 0xFF00) >> 8;
+    val[1] = thd_l & 0x00FF;
+    ret = stk3x1x_i2c_write_data(ps_data->client, STK_THDL1_ALS_REG, 2, val);
+    if (ret < 0) {
+        PRINT_ERR( "%s: fail, ret=%d\n", __func__, ret);
+    }
+
+    return ret;
 }
+
 static int32_t stk3x1x_set_als_thd_h(struct stk3x1x_data *ps_data, uint16_t thd_h)
 {
-	unsigned char val[2];
-	int ret;
-	val[0] = (thd_h & 0xFF00) >> 8;
-	val[1] = thd_h & 0x00FF;
-	ret = stk3x1x_i2c_write_data(ps_data->client, STK_THDH1_ALS_REG, 2, val);		
-	if(ret < 0)
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, ret);	
-	return ret;	
+    unsigned char val[2];
+    int ret;
+    val[0] = (thd_h & 0xFF00) >> 8;
+    val[1] = thd_h & 0x00FF;
+    ret = stk3x1x_i2c_write_data(ps_data->client, STK_THDH1_ALS_REG, 2, val);
+    if (ret < 0) {
+        PRINT_ERR( "%s: fail, ret=%d\n", __func__, ret);
+    }
+    return ret;
 }
 
 static int32_t stk3x1x_set_ps_thd_l(struct stk3x1x_data *ps_data, uint16_t thd_l)
 {
-	unsigned char val[2];
-	int ret;
-	val[0] = (thd_l & 0xFF00) >> 8;
-	val[1] = thd_l & 0x00FF;
-	ret = stk3x1x_i2c_write_data(ps_data->client, STK_THDL1_PS_REG, 2, val);		
-	if(ret < 0)
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, ret);	
-	return ret;	
+    unsigned char val[2];
+    int ret;
+    val[0] = (thd_l & 0xFF00) >> 8;
+    val[1] = thd_l & 0x00FF;
+    ret = stk3x1x_i2c_write_data(ps_data->client, STK_THDL1_PS_REG, 2, val);
+    if (ret < 0) {
+        PRINT_ERR( "%s: fail, ret=%d\n", __func__, ret);
+    }
+
+    return ret;
 }
 static int32_t stk3x1x_set_ps_thd_h(struct stk3x1x_data *ps_data, uint16_t thd_h)
-{	
-	unsigned char val[2];
-	int ret;
-	val[0] = (thd_h & 0xFF00) >> 8;
-	val[1] = thd_h & 0x00FF;
-	ret = stk3x1x_i2c_write_data(ps_data->client, STK_THDH1_PS_REG, 2, val);		
-	if(ret < 0)
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, ret);	
-	return ret;
+{
+    unsigned char val[2];
+    int ret;
+    val[0] = (thd_h & 0xFF00) >> 8;
+    val[1] = thd_h & 0x00FF;
+    ret = stk3x1x_i2c_write_data(ps_data->client, STK_THDH1_PS_REG, 2, val);
+    if (ret < 0) {
+        PRINT_ERR( "%s: fail, ret=%d\n", __func__, ret);
+    }
+
+    return ret;
 }
 
 static uint32_t stk3x1x_get_ps_reading(struct stk3x1x_data *ps_data)
-{	
-	unsigned char value[2];
-	int err;
-	err = stk3x1x_i2c_read_data(ps_data->client, STK_DATA1_PS_REG, 2, &value[0]);
-	if(err < 0)
-	{
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, err);
-		return err;
-	}
-	return ((value[0]<<8) | value[1]);	
+{
+    unsigned char value[2];
+    int err;
+    err = stk3x1x_i2c_read_data(ps_data->client, STK_DATA1_PS_REG, 2, &value[0]);
+    if (err < 0) {
+        PRINT_ERR( "%s: fail, ret=%d\n", __func__, err);
+        return err;
+    }
+    return ((value[0]<<8) | value[1]);
 }
 
-
 static int32_t stk3x1x_set_flag(struct stk3x1x_data *ps_data, uint8_t org_flag_reg, uint8_t clr)
 {
-	uint8_t w_flag;
-	int ret;
-	
-	w_flag = org_flag_reg | (STK_FLG_ALSINT_MASK | STK_FLG_PSINT_MASK | STK_FLG_OUI_MASK | STK_FLG_IR_RDY_MASK);
-	w_flag &= (~clr);
-	//printk(KERN_INFO "%s: org_flag_reg=0x%x, w_flag = 0x%x\n", __func__, org_flag_reg, w_flag);		
-    ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client,STK_FLAG_REG, w_flag);	
-	if(ret < 0)
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, ret);
-	return ret;
+    uint8_t w_flag;
+    int ret;
+
+    w_flag = org_flag_reg | (STK_FLG_ALSINT_MASK | STK_FLG_PSINT_MASK | STK_FLG_OUI_MASK | STK_FLG_IR_RDY_MASK);
+    w_flag &= (~clr);
+    PRINT_WARN( "%s: org_flag_reg=0x%x, w_flag = 0x%x\n", __func__, org_flag_reg, w_flag);
+    ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client,STK_FLAG_REG, w_flag);
+    if (ret < 0) {
+        PRINT_ERR( "%s: fail, ret=%d\n", __func__, ret);
+    }
+
+    return ret;
 }
 
 static int32_t stk3x1x_get_flag(struct stk3x1x_data *ps_data)
-{	
-	int ret;
-    ret = stk3x1x_i2c_smbus_read_byte_data(ps_data->client,STK_FLAG_REG);	
-	if(ret < 0)
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, ret);
-	return ret;
-}
-
-#ifdef STK_GES			
-static int32_t stk3x1x_set_flag2(struct stk3x1x_data *ps_data, uint8_t org_flag2_reg, uint8_t clr)
 {
-	uint8_t w_flag2;
-	int ret;
-	
-	w_flag2 = org_flag2_reg | 0x72;
-	w_flag2 &= (~clr);
-	//printk(KERN_INFO "%s: org_flag2_reg=0x%x, w_flag2 = 0x%x\n", __func__, org_flag2_reg, w_flag2);		
-    ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client,STK_FLAG2_REG, w_flag2);	
-	if(ret < 0)
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, ret);
-	return ret;
-}
+    int ret;
+    ret = stk3x1x_i2c_smbus_read_byte_data(ps_data->client,STK_FLAG_REG);
+    if (ret < 0) {
+        PRINT_ERR( "%s: fail, ret=%d\n", __func__, ret);
+    }
 
-static int32_t stk3x1x_get_flag2(struct stk3x1x_data *ps_data)
-{	
-	int ret;
-    ret = stk3x1x_i2c_smbus_read_byte_data(ps_data->client,STK_FLAG2_REG);	
-	if(ret < 0)
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, ret);
-	return ret;
+    return ret;
 }
-#endif
 
 static int32_t stk3x1x_set_state(struct stk3x1x_data *ps_data, uint8_t state)
 {
-	int ret;		
-    ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client,STK_STATE_REG, state);	
-	if(ret < 0)
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, ret);
-	return ret;
+    int ret;
+    ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client,STK_STATE_REG, state);
+    if (ret < 0) {
+        PRINT_ERR( "%s: fail, ret=%d\n", __func__, ret);
+    }
+
+    return ret;
 }
 
 static int32_t stk3x1x_get_state(struct stk3x1x_data *ps_data)
-{	
-	int ret;
-    ret = stk3x1x_i2c_smbus_read_byte_data(ps_data->client,STK_STATE_REG);	
-	if(ret < 0)
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, ret);
-	return ret;
-}
-
-#ifdef STK_GES		
-static int32_t stk3x1x_set_gsctrl(struct stk3x1x_data *ps_data, uint8_t state)
 {
-	int ret;		
-    ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client,STK_GSCTRL_REG, state);	
-	if(ret < 0)
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, ret);
-	return ret;
-}
+    int ret;
+    ret = stk3x1x_i2c_smbus_read_byte_data(ps_data->client,STK_STATE_REG);
+    if (ret < 0) {
+        PRINT_ERR( "%s: fail, ret=%d\n", __func__, ret);
+    }
 
-static int32_t stk3x1x_get_gsctrl(struct stk3x1x_data *ps_data)
-{	
-	int ret;
-    ret = stk3x1x_i2c_smbus_read_byte_data(ps_data->client,STK_GSCTRL_REG);	
-	if(ret < 0)
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, ret);
-	return ret;
+    return ret;
 }
 
-#if 0
-static uint32_t stk3x1x_get_ges_reading(struct stk3x1x_data *ps_data, unsigned int *ges0,
-				unsigned int *ges1, unsigned int *ges2)
+static int32_t stk3x1x_enable_ps(struct stk3x1x_data *ps_data, uint8_t enable)
 {
-	int retry, len, no = 0;
-	uint8_t reg_val_crit;
-	int err;
-	unsigned char value[10];
-	
-	while(stk_ges_op[no].ops[1] != 0)
-	{
-		retry = stk_ges_op[no].action.rw_len_retry & 0x0F;
-		len = (stk_ges_op[no].action.rw_len_retry & 0x70) >> 4;
-		reg_val_crit = stk_ges_op[no].action.reg_value_retry_crit;
-		if(stk_ges_op[no].action.rw_len_retry & 0x80)
-		{
-			while(retry != 0)
-			{
-				err = stk3x1x_i2c_read_data(ps_data->client, 
-								stk_ges_op[no].action.reg, len, value);								
-				if(err < 0)
-				{
-					printk(KERN_ERR "%s: fail, ret=%d\n", __func__, err);
-					return err;
-				}
-				if(reg_val_crit)
-				{
-					if(value[0] & reg_val_crit)
-						break;
-				}
-				if(stk_ges_op[no].action.sleep_10ns != 0)
-					usleep_range(stk_ges_op[no].action.sleep_10ns*10, 
-									stk_ges_op[no].action.sleep_10ns*10+300);
-				retry--;
-			}			
-		}
-		else
-		{
-			while(retry != 0)
-			{
-				err = stk3x1x_i2c_write_data(ps_data->client, stk_ges_op[no].action.reg, 
-								len, &reg_val_crit);		
-				if(err < 0)
-				{
-					printk(KERN_ERR "%s: fail, err=%d\n", __func__, err);			
-					return err;
-				}
-
-				if(stk_ges_op[no].action.sleep_10ns != 0)
-					usleep_range(stk_ges_op[no].action.sleep_10ns*10, 
-									stk_ges_op[no].action.sleep_10ns*10+300);
-				retry--;
-			}			
-		}
-		
-		if(stk_ges_op[no].action.reg == 0x24)
-		{
-			*ges0 = (value[0]<<8) | value[1];	
-			*ges1 = (value[2]<<8) | value[3];
-		}
-		else if(stk_ges_op[no].action.reg == stk_ges_op[9].ops[0])
-		{
-			*ges2 = (value[0]<<8) | value[1];
-		}
-		
-		no++;
-	}
-	return 0;
-}
-
-#else
-static uint32_t stk3x1x_get_ges_reading(struct stk3x1x_data *ps_data, unsigned int *ges0,unsigned int *ges1,unsigned int *ges2)
-{
-	unsigned char value[4];
-	int err, retry = 10;
-	
-	do {
-		err = stk3x1x_get_flag(ps_data);	
-		if(err < 0)
-			return err;
-		if(err & STK_FLG_PSDR_MASK)
-			break;
-		//printk(KERN_INFO "ges: not ready, %d\n", retry);
-		retry--;
-		usleep_range(350, 1000);
-	} while(retry > 0);
-	err = stk3x1x_i2c_read_data(ps_data->client, STK_DATA1_PS_REG, 2, &value[0]);
-	
-	err = stk3x1x_i2c_read_data(ps_data->client, 0x24, 4, &value[0]);
-	if(err < 0)
-	{
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, err);
-		return err;
-	}
-	*ges0 = (value[0]<<8) | value[1];	
-	*ges1 = (value[2]<<8) | value[3];	
-	//printk(KERN_INFO "%s: ges=%d,%d\n",__func__, *ges0, *ges1);	
-	return 0;
-}
-#endif
-
-static int32_t stk3x1x_enable_ges(struct stk3x1x_data *ps_data, uint8_t enable, uint8_t mode)
-{
     int32_t ret;
-	uint8_t w_state_reg, gsctrl_reg;
-	uint8_t org_mode = 0;
-	
-	if(ps_data->ps_enabled)
-	{
-		printk(KERN_INFO "%s: since PS is enabled, ges is disabled\n", __func__);
-		ps_data->re_enable_ges = enable;
-		return 0;
-	}	
-		
-	if(enable == ps_data->ges_enabled)
-		return 0;	
-		
-	if(enable)
-	{
-#ifdef STK_QUALCOMM_POWER_CTRL	
-		ret = stk3x1x_device_ctl(ps_data, enable);
-		if (ret)
-			return ret;
-#endif	
-		if(ps_data->als_enabled) 
-		{
-			printk(KERN_INFO "%s: force disable ALS\n", __func__);			
-			stk3x1x_enable_als(ps_data, 0);
-			ps_data->re_enable_als = true;
-		}		
-		
-		ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_WAIT_REG, 0);
-		if (ret < 0)
-		{
-			printk(KERN_ERR "%s: write i2c error\n", __func__);
-			return ret;
-		}			
-		
-		ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_INT_REG, 0);
-		if (ret < 0)
-		{
-			printk(KERN_ERR "%s: write i2c error\n", __func__);
-			return ret;
-		}				
-			
-		w_state_reg = STK_STATE_EN_WAIT_MASK | STK_STATE_EN_PS_MASK; 
-		ret = stk3x1x_set_state(ps_data, w_state_reg);
-		if(ret < 0)
-			return ret;
-		
-		if(mode == 2)
-		{
-			ret = stk3x1x_get_gsctrl(ps_data);
-			if(ret < 0)
-				return ret;		
-			gsctrl_reg = ret & 0xF3;
-#ifdef STK_POLL_PS
-			gsctrl_reg |= 0x04;
-#else
-			gsctrl_reg |= 0x0C;
-#endif			
-			ret = stk3x1x_set_gsctrl(ps_data, gsctrl_reg);
-			if(ret < 0)
-				return ret;			
-#ifdef STK_POLL_PS
-			hrtimer_start(&ps_data->ps_timer, ps_data->ps_poll_delay, HRTIMER_MODE_REL);	
-#else
-			enable_irq(ps_data->irq);
-#endif		
-		}
-		ps_data->ges_enabled = mode;
-	}
-	else
-	{	
-		org_mode = ps_data->ges_enabled;
-		if(org_mode == 2)
-		{	
-#ifdef STK_POLL_PS
-			hrtimer_cancel(&ps_data->ps_timer);
-			cancel_work_sync(&ps_data->stk_ps_work);
-#else	
-			disable_irq(ps_data->irq);
-#endif		
-		}
-	
-		ret = stk3x1x_set_state(ps_data, 0);
-		if(ret < 0)
-			return ret;		
-		
-		ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_WAIT_REG, ps_data->wait_reg);
-		if (ret < 0)
-		{
-			printk(KERN_ERR "%s: write i2c error\n", __func__);
-			return ret;
-		}	
-		
-		ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_INT_REG, ps_data->int_reg);
-		if (ret < 0)
-		{
-			printk(KERN_ERR "%s: write i2c error\n", __func__);
-			return ret;
-		}				
-		if(org_mode == 2)
-		{			
-			ret = stk3x1x_get_gsctrl(ps_data);
-			if(ret < 0)
-				return ret;		
-			gsctrl_reg = ret & (~0x0C);
-			ret = stk3x1x_set_gsctrl(ps_data, gsctrl_reg);		
-			if(ret < 0)
-				return ret;		
-		}
-		ps_data->ges_enabled = 0;
-		if(ps_data->re_enable_als) 
-		{
-			printk(KERN_INFO "%s: re-enable ALS\n", __func__);
-			stk3x1x_enable_als(ps_data, 1);
-			ps_data->re_enable_als = false;
-		}
-#ifdef STK_QUALCOMM_POWER_CTRL	
-		ret = stk3x1x_device_ctl(ps_data, enable);
-		if (ret)
-			return ret;
-#endif			
-	}	
+    int err;
+    uint8_t w_state_reg;
+    uint8_t curr_ps_enable;
 
-	return 0;
-}
-#endif /* #ifdef STK_GES */
+    err=stk3x1x_init_all_setting(this_client,ps_data->pdata);//xiexie  weishenme zai zheli 
+     if( err < 0)
+     {
+        PRINT_ERR(" stk3x1x_init err");
+         return err;
+    }
 
-static int32_t stk3x1x_enable_ps(struct stk3x1x_data *ps_data, uint8_t enable, uint8_t validate_reg)
-{
-    int32_t ret;
-	uint8_t w_state_reg;
-	uint8_t curr_ps_enable;	
-	uint32_t reading;
-	int32_t near_far_state;		
+    curr_ps_enable = ps_data->ps_enabled?1:0;
+    PRINT_WARN("%s curr_ps_enable :%d  enable:%d \r\n",__func__,curr_ps_enable, enable);
+    if (curr_ps_enable == enable)
+            return 0;
 
-#ifdef STK_QUALCOMM_POWER_CTRL		
-	if (enable) {
-		ret = stk3x1x_device_ctl(ps_data, enable);
-		if (ret)
-			return ret;
-	}	
-#endif
-	
-#ifdef STK_CHK_REG
-	if(validate_reg)
-	{
-		ret = stk3x1x_validate_n_handle(ps_data->client);
-		if(ret < 0)	
-			printk(KERN_ERR "stk3x1x_validate_n_handle fail: %d\n", ret); 
-	}			
-#endif /* #ifdef STK_CHK_REG */	
-
-#ifdef STK_GES		
-	if(ps_data->ges_enabled && enable)
-	{
-		printk(KERN_INFO "%s: force disable ges\n", __func__);
-		stk3x1x_enable_ges(ps_data, 0, 1);
-		ps_data->re_enable_ges = 1;
-	}
-#endif
-	curr_ps_enable = ps_data->ps_enabled?1:0;	
-	if(curr_ps_enable == enable)
-		return 0;
-	
-#ifdef STK_TUNE0
-	if (!(ps_data->psi_set) && !enable)
-	{
-		hrtimer_cancel(&ps_data->ps_tune0_timer);					
-		cancel_work_sync(&ps_data->stk_ps_tune0_work);
-	}
-#endif		
-	if(ps_data->first_boot == true)
-	{		
-		ps_data->first_boot = false;
-	}
-
-	ret = stk3x1x_get_state(ps_data);
-	if(ret < 0)
-		return ret;
-	w_state_reg = ret;
-	
-	
-	w_state_reg &= ~(STK_STATE_EN_PS_MASK | STK_STATE_EN_WAIT_MASK | STK_STATE_EN_AK_MASK); 
-	if(enable)	
-	{
-		w_state_reg |= STK_STATE_EN_PS_MASK;	
-		if(!(ps_data->als_enabled))
-			w_state_reg |= STK_STATE_EN_WAIT_MASK;			
-	}	
-	ret = stk3x1x_set_state(ps_data, w_state_reg);
-	if(ret < 0)
-		return ret;	
-
-    if(enable)
-	{
-	
+    ret = stk3x1x_get_state(ps_data);
+    if (ret < 0)
+            return ret;
+    w_state_reg = ret;
+     PRINT_WARN("%s w_state_reg before :%d \r\n",__func__,w_state_reg);
+    w_state_reg &= ~(STK_STATE_EN_PS_MASK | STK_STATE_EN_WAIT_MASK | STK_STATE_EN_AK_MASK);
+    if (enable) {
+            w_state_reg |= STK_STATE_EN_PS_MASK;
+            if (!(ps_data->als_enabled))
+                    w_state_reg |= STK_STATE_EN_WAIT_MASK;
+    }
+     PRINT_WARN("%s w_state_reg after :%d \r\n",__func__,w_state_reg);
+    ret = stk3x1x_set_state(ps_data, w_state_reg);
+    if(enable){
+        ps_data->ps_enabled = 1;
 #if STK_WRITE_CALI
 		if(cal_finished == 0)
 		{
@@ -1321,511 +749,256 @@
 			cal_finished = 1;
 		}
 #endif
-	
-#ifdef STK_TUNE0
-	#ifdef CALI_PS_EVERY_TIME
-		ps_data->psi_set = 0;
-		ps_data->psa = 0;
-		ps_data->psi = 0xFFFF;
-		#ifndef QUALCOMM_PLATFORM		
-		ps_data->ps_thd_h = ps_data->ps_high_thd_boot;
-		ps_data->ps_thd_l = ps_data->ps_low_thd_boot;
-		#endif
-		hrtimer_start(&ps_data->ps_tune0_timer, ps_data->ps_tune0_delay, HRTIMER_MODE_REL);					
-	#else
 
-		if (!(ps_data->psi_set))
-			hrtimer_start(&ps_data->ps_tune0_timer, ps_data->ps_tune0_delay, HRTIMER_MODE_REL);			
-	#endif	/* #ifdef CALI_PS_EVERY_TIME */
-		stk3x1x_set_ps_thd_h(ps_data, ps_data->ps_thd_h);
-		stk3x1x_set_ps_thd_l(ps_data, ps_data->ps_thd_l);			
-#endif			
-		printk(KERN_INFO "%s: HT=%d,LT=%d\n", __func__, ps_data->ps_thd_h,  ps_data->ps_thd_l);				
-#ifdef STK_POLL_PS		
-		hrtimer_start(&ps_data->ps_timer, ps_data->ps_poll_delay, HRTIMER_MODE_REL);	
-		ps_data->ps_distance_last = -1;	
-#endif		
-#ifndef STK_POLL_PS
-	#ifndef STK_POLL_ALS		
-		if(!(ps_data->als_enabled))
-	#endif	/* #ifndef STK_POLL_ALS	*/
-			enable_irq(ps_data->irq);
-#endif	/* #ifndef STK_POLL_PS */						
-		ps_data->ps_enabled = true;
-#ifdef STK_CHK_REG		
-		if(!validate_reg)		
-		{
-			ps_data->ps_distance_last = 1;
-			input_report_abs(ps_data->ps_input_dev, ABS_DISTANCE, 1);
-			input_sync(ps_data->ps_input_dev);
-			wake_lock_timeout(&ps_data->ps_wakelock, 3*HZ);
-			reading = stk3x1x_get_ps_reading(ps_data);
-			printk(KERN_INFO "%s: force report ps input event=1, ps code = %d\n",__func__, reading);				
-		}
-		else
-#endif /* #ifdef STK_CHK_REG */
-		{
-			usleep_range(4000, 5000);
-			ret = stk3x1x_get_flag(ps_data);
-			if (ret < 0)
-				return ret;
-			near_far_state = ret & STK_FLG_NF_MASK;					
-			ps_data->ps_distance_last = near_far_state;
-			input_report_abs(ps_data->ps_input_dev, ABS_DISTANCE, near_far_state);
-			input_sync(ps_data->ps_input_dev);
-			wake_lock_timeout(&ps_data->ps_wakelock, 3*HZ);
-			reading = stk3x1x_get_ps_reading(ps_data);
-			printk(KERN_INFO "%s: ps input event=%d, ps code = %d\n",__func__, near_far_state, reading);	
-		}
-	}
-	else
-	{		
-#ifdef STK_POLL_PS
-		hrtimer_cancel(&ps_data->ps_timer);
-		cancel_work_sync(&ps_data->stk_ps_work);
-#else		
-#ifndef STK_POLL_ALS
-		if(!(ps_data->als_enabled))	
-#endif				
-			disable_irq(ps_data->irq);
+    }
+    else{
+        ps_data->ps_enabled = 0;
+    }
+    if (ret < 0)
+            return ret;
+    ps_data->state_reg = w_state_reg;
+#ifdef HQ_PSENSOR_CALIBRATION
+    if (enable)
+    {
+        stk3x1x_psensor_calibrate();
+    }
 #endif
-		ps_data->ps_enabled = false;	
-#ifdef STK_GES		
-		if(ps_data->re_enable_ges)
-		{
-			printk(KERN_INFO "%s: re-enable ges\n", __func__);		
-			stk3x1x_enable_ges(ps_data, 1, 1);
-			ps_data->re_enable_ges = 0;
-		}
-#endif		
-#ifdef STK_QUALCOMM_POWER_CTRL			
-		ret = stk3x1x_device_ctl(ps_data, enable);
-		if (ret)
-			return ret;		
-#endif			
-	}
-	return ret;
+
+    return ret;
 }
 
 static int32_t stk3x1x_enable_als(struct stk3x1x_data *ps_data, uint8_t enable)
 {
     int32_t ret;
-	uint8_t w_state_reg;
-	uint8_t curr_als_enable = (ps_data->als_enabled)?1:0;
+    uint8_t w_state_reg;
+    uint8_t curr_als_enable = (ps_data->als_enabled)?1:0;
 
-#ifdef STK_GES			
-	if(ps_data->ges_enabled)
-	{
-		printk(KERN_INFO "%s: since ges is enabled, ALS is disabled\n", __func__);
-		ps_data->re_enable_als = enable ? true : false;
-		return 0;
-	}	
-#endif	/* #ifdef STK_GES */	
-	if(curr_als_enable == enable)
-		return 0;
-#ifdef STK_QUALCOMM_POWER_CTRL		
-	if (enable) {
-		ret = stk3x1x_device_ctl(ps_data, enable);
-		if (ret)
-			return ret;
-	}	
-#endif	
-#ifndef STK_POLL_ALS			
-	#ifdef STK_IRS
-	if(enable && !(ps_data->ps_enabled))
-	{		
-		ret = stk3x1x_get_ir_reading(ps_data);
-		if(ret > 0)
-			ps_data->ir_code = ret;
-	}		
-	#endif
-	
-    if (enable)
-	{				
-        stk3x1x_set_als_thd_h(ps_data, 0x0000);
-        stk3x1x_set_als_thd_l(ps_data, 0xFFFF);		
-	}
-#endif	
+    PRINT_WARN( " stk3x1x_enable_als curr_als_enable :%d  enable:%d \r\n",curr_als_enable, enable);
+    if(curr_als_enable == enable)
+        return 0;
 
-	ret = stk3x1x_get_state(ps_data);
-	if(ret < 0)
-		return ret;
-	
-	w_state_reg = (uint8_t)(ret & (~(STK_STATE_EN_ALS_MASK | STK_STATE_EN_WAIT_MASK))); 
-	if(enable)	
-		w_state_reg |= STK_STATE_EN_ALS_MASK;	
-	else if (ps_data->ps_enabled)		
-		w_state_reg |= STK_STATE_EN_WAIT_MASK;	
+    ret = stk3x1x_get_state(ps_data);
+    if(ret < 0)
+        return ret;
+    w_state_reg = (uint8_t)(ret & (~(STK_STATE_EN_ALS_MASK | STK_STATE_EN_WAIT_MASK)));
+    if(enable)
+        w_state_reg |= STK_STATE_EN_ALS_MASK;
+    else if (ps_data->ps_enabled)
+        w_state_reg |= STK_STATE_EN_WAIT_MASK;
 
-	ret = stk3x1x_set_state(ps_data, w_state_reg);
-	if(ret < 0)
-		return ret;	
+    ret = stk3x1x_set_state(ps_data, w_state_reg);
+    if(ret < 0)
+        return ret;
+    ps_data->state_reg = w_state_reg;
 
-    if (enable)
-    {	
-		ps_data->als_enabled = true;
-#ifdef STK_POLL_ALS			
-		hrtimer_start(&ps_data->als_timer, ps_data->als_poll_delay, HRTIMER_MODE_REL);		
-#else
-#ifndef STK_POLL_PS
-		if(!(ps_data->ps_enabled))
-#endif		
-			enable_irq(ps_data->irq);
-#endif		
-#ifdef STK_IRS
-		ps_data->als_data_index = 0;
-#endif
+    if (enable) {
+        ps_data->als_enabled = true;
+        hrtimer_start(&ps_data->als_timer, ps_data->als_poll_delay, HRTIMER_MODE_REL);
+
     }
-	else
-	{
-		ps_data->als_enabled = false;
-#ifdef STK_POLL_ALS			
-		hrtimer_cancel(&ps_data->als_timer);
-		cancel_work_sync(&ps_data->stk_als_work);
-#else
-#ifndef STK_POLL_PS
-		if(!(ps_data->ps_enabled))	
-#endif		
-			disable_irq(ps_data->irq);		
-#endif	
-#ifdef STK_QUALCOMM_POWER_CTRL		
-		ret = stk3x1x_device_ctl(ps_data, enable);
-		if (ret)
-			return ret;
-#endif			
-	}
+    else {
+        ps_data->als_enabled = false;
+        hrtimer_cancel(&ps_data->als_timer);
+        cancel_work_sync(&ps_data->stk_als_work);
+    }
     return ret;
 }
 
 static int32_t stk3x1x_get_als_reading(struct stk3x1x_data *ps_data)
 {
-    int32_t word_data;
+    int32_t als_data;
+    int32_t ir_data = 0;
 #ifdef STK_ALS_FIR
-	int index;   
-	int firlen = atomic_read(&ps_data->firlength);   
-#endif	
-	unsigned char value[2];
-	int ret;
-	
-	ret = stk3x1x_i2c_read_data(ps_data->client, STK_DATA1_ALS_REG, 2, &value[0]);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s fail, ret=0x%x", __func__, ret);
-		return ret;
-	}
-	word_data = (value[0]<<8) | value[1];	
-	
+    int index;
+    int firlen = atomic_read(&ps_data->firlength);
+#endif
+    unsigned char value[2];
+    int ret;
+//    const int ir_enlarge = 1 << (STK_ALS_READ_IRS_IT_REDUCE - STK_IRS_IT_REDUCE);
+
+    ret = stk3x1x_i2c_read_data(ps_data->client, STK_DATA1_ALS_REG, 2, &value[0]);
+    if(ret < 0) {
+        PRINT_ERR( "%s fail, ret=0x%x", __func__, ret);
+        return ret;
+    }
+    als_data = (value[0]<<8) | value[1];
+    // printk("%s: raw als_data=%d\n", __func__, als_data);
+    if(ps_data->p_wv_r_bd_with_co & 0b010) {
+        if(als_data < STK_ALS_THRESHOLD && ps_data->als_code_last > 10000) {
+            ir_data = stk3x1x_get_ir_reading(ps_data, STK_ALS_READ_IRS_IT_REDUCE);
+            // PRINT_WARN( "%s: als_data=%d, als_code_last=%d,ir_data=%d\n",
+                    // __func__, als_data, ps_data->als_code_last, ir_data);
+            if(ir_data > (STK_ALS_THRESHOLD*3)) {
+                als_data = ps_data->als_code_last;
+            }
+        }
+    }
+
+    ps_data->als_code_last = als_data;
+
 #ifdef STK_ALS_FIR
-	if(ps_data->fir.number < firlen)
-	{                
-		ps_data->fir.raw[ps_data->fir.number] = word_data;
-		ps_data->fir.sum += word_data;
-		ps_data->fir.number++;
-		ps_data->fir.idx++;
-	}
-	else
-	{
-		index = ps_data->fir.idx % firlen;
-		ps_data->fir.sum -= ps_data->fir.raw[index];
-		ps_data->fir.raw[index] = word_data;
-		ps_data->fir.sum += word_data;
-		ps_data->fir.idx++;
-		word_data = ps_data->fir.sum/firlen;
-	}	
-#endif	
-	
-	return word_data;
+    if(ps_data->fir.number < firlen) {
+        ps_data->fir.raw[ps_data->fir.number] = als_data;
+        ps_data->fir.sum += als_data;
+        ps_data->fir.number++;
+        ps_data->fir.idx++;
+    }
+    else {
+        index = ps_data->fir.idx % firlen;
+        ps_data->fir.sum -= ps_data->fir.raw[index];
+        ps_data->fir.raw[index] = als_data;
+        ps_data->fir.sum += als_data;
+        ps_data->fir.idx++;
+        als_data = ps_data->fir.sum/firlen;
+    }
+#endif
+
+    return als_data;
 }
 
-static int32_t stk3x1x_set_irs_it_slp(struct stk3x1x_data *ps_data, uint16_t *slp_time)
+static int32_t stk3x1x_set_irs_it_slp(struct stk3x1x_data *ps_data, uint16_t *slp_time, int32_t ials_it_reduce)
 {
-	uint8_t irs_alsctrl;
-	int32_t ret;
-		
-	irs_alsctrl = (ps_data->alsctrl_reg & 0x0F) - 2;		
-	switch(irs_alsctrl)
-	{
-		case 6:
-			*slp_time = 12;
-			break;
-		case 7:
-			*slp_time = 24;			
-			break;
-		case 8:
-			*slp_time = 48;			
-			break;
-		case 9:
-			*slp_time = 96;			
-			break;				
-		default:
-			printk(KERN_ERR "%s: unknown ALS IT=0x%x\n", __func__, irs_alsctrl);
-			ret = -EINVAL;	
-			return ret;
-	}
-	irs_alsctrl |= (ps_data->alsctrl_reg & 0xF0);
-	ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_ALSCTRL_REG, irs_alsctrl);
-	if (ret < 0)
-	{
-		printk(KERN_ERR "%s: write i2c error\n", __func__);
-		return ret;		
-	}		
-	return 0;
+    uint8_t irs_alsctrl;
+    int32_t ret;
+
+    irs_alsctrl = (ps_data->alsctrl_reg & 0x0F) - ials_it_reduce;
+    switch(irs_alsctrl) {
+        case 2:
+            *slp_time = 1;
+            break;
+        case 3:
+            *slp_time = 2;
+            break;
+        case 4:
+            *slp_time = 3;
+            break;
+        case 5:
+            *slp_time = 6;
+            break;
+        case 6:
+            *slp_time = 12;
+            break;
+        case 7:
+            *slp_time = 24;
+            break;
+        case 8:
+            *slp_time = 48;
+            break;
+        case 9:
+            *slp_time = 96;
+            break;
+        case 10:
+            *slp_time = 192;
+            break;
+        default:
+            PRINT_ERR( "%s: unknown ALS IT=0x%x\n", __func__, irs_alsctrl);
+            ret = -EINVAL;
+            return ret;
+    }
+    irs_alsctrl |= (ps_data->alsctrl_reg & 0xF0);
+    ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_ALSCTRL_REG, irs_alsctrl);
+    if (ret < 0) {
+        PRINT_ERR( "%s: write i2c error\n", __func__);
+        return ret;
+    }
+    return 0;
 }
 
-static int32_t stk3x1x_get_ir_reading(struct stk3x1x_data *ps_data)
+static int32_t stk3x1x_get_ir_reading(struct stk3x1x_data *ps_data, int32_t als_it_reduce)
 {
     int32_t word_data, ret;
-	uint8_t w_reg, retry = 0;	
-	uint16_t irs_slp_time = 100;
-	//bool re_enable_ps = false;
-	//bool re_enable_tune0 = false;
-	unsigned char value[2];
-	
-	// if(ps_data->ps_enabled)
-	// {
-// #ifdef STK_TUNE0		
-		// if (!(ps_data->psi_set))
-		// {
-			// hrtimer_cancel(&ps_data->ps_tune0_timer);					
-			// cancel_work_sync(&ps_data->stk_ps_tune0_work);
-			// re_enable_tune0 = true;
-		// }	
-// #endif		
-		//stk3x1x_enable_ps(ps_data, 0, 1);
-		//re_enable_ps = true;
-	// }
-	
-	ret = stk3x1x_set_irs_it_slp(ps_data, &irs_slp_time);
-	if(ret < 0)
-		goto irs_err_i2c_rw;
-	
-	ret = stk3x1x_get_state(ps_data);
-	if(ret < 0)
-		goto irs_err_i2c_rw;
-	
-	w_reg = ret | STK_STATE_EN_IRS_MASK;		
-	ret = stk3x1x_set_state(ps_data, w_reg);
-	if(ret < 0)
-		goto irs_err_i2c_rw;
-	msleep(irs_slp_time);	
-	
-	do
-	{
-		usleep_range(3000, 4000);
-		//msleep(3);
-		ret = stk3x1x_get_flag(ps_data);
-		if (ret < 0)
-			goto irs_err_i2c_rw;
-		retry++;
-	}while(retry < 10 && ((ret&STK_FLG_IR_RDY_MASK) == 0));
-	
-	if(retry == 10)
-	{
-		printk(KERN_ERR "%s: ir data is not ready for 300ms\n", __func__);
-		ret = -EINVAL;
-		goto irs_err_i2c_rw;
-	}
+    uint8_t w_reg, retry = 0;
+    uint16_t irs_slp_time = 100;
+    unsigned char value[2];
 
-	ret = stk3x1x_set_flag(ps_data, ret, STK_FLG_IR_RDY_MASK);
+    ret = stk3x1x_set_irs_it_slp(ps_data, &irs_slp_time, als_it_reduce);
+    if(ret < 0)
+        goto irs_err_i2c_rw;
+
+    ret = stk3x1x_get_state(ps_data);
+    if(ret < 0)
+        goto irs_err_i2c_rw;
+
+    w_reg = ret | STK_STATE_EN_IRS_MASK;
+    ret = stk3x1x_set_state(ps_data, w_reg);
+    if(ret < 0)
+        goto irs_err_i2c_rw;
+    msleep(irs_slp_time);
+
+    do {
+        usleep_range(3000, 4000);
+        ret = stk3x1x_get_flag(ps_data);
+        if (ret < 0)
+            goto irs_err_i2c_rw;
+        retry++;
+    }while(retry < 10 && ((ret&STK_FLG_IR_RDY_MASK) == 0));
+
+    if(retry == 10) {
+        PRINT_ERR( "%s: ir data is not ready for a long time\n", __func__);
+        ret = -EINVAL;
+        goto irs_err_i2c_rw;
+    }
+
+    ret = stk3x1x_set_flag(ps_data, ret, STK_FLG_IR_RDY_MASK);
     if (ret < 0)
-		goto irs_err_i2c_rw;
-	
-	ret = stk3x1x_i2c_read_data(ps_data->client, STK_DATA1_IR_REG, 2, &value[0]);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s fail, ret=0x%x", __func__, ret);
-		goto irs_err_i2c_rw;
-	}
-	word_data = ((value[0]<<8) | value[1]);	
-	//printk(KERN_INFO "%s: ir=%d\n", __func__, word_data);
-	
-	ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_ALSCTRL_REG, ps_data->alsctrl_reg );
-	if (ret < 0)
-	{
-		printk(KERN_ERR "%s: write i2c error\n", __func__);
-		goto irs_err_i2c_rw;
-	}
-	
-// #ifdef STK_TUNE0		
-	// if (re_enable_tune0 == true)
-	// {
-		// hrtimer_start(&ps_data->ps_tune0_timer, ps_data->ps_tune0_delay, HRTIMER_MODE_REL);				
-	// }	
-// #endif		
-	
-	// if(re_enable_ps)
-		// stk3x1x_enable_ps(ps_data, 1, 1);			
-	return word_data;
+        goto irs_err_i2c_rw;
 
-irs_err_i2c_rw:	
-	// if(re_enable_ps)
-		// stk3x1x_enable_ps(ps_data, 1, 1);		
-	return ret;
-}
+    ret = stk3x1x_i2c_read_data(ps_data->client, STK_DATA1_IR_REG, 2, &value[0]);
+    if(ret < 0) {
+        PRINT_ERR( "%s fail, ret=0x%x", __func__, ret);
+        goto irs_err_i2c_rw;
+    }
+    word_data = ((value[0]<<8) | value[1]);
+    //PRINT_WARN( "%s: ir=%d\n", __func__, word_data);
 
-#ifdef STK_CHK_REG
-static int stk3x1x_chk_reg_valid(struct stk3x1x_data *ps_data) 
-{
-	unsigned char value[9];
-	int err;
-	/*
-	uint8_t cnt;
-		
-	for(cnt=0;cnt<9;cnt++)
-	{
-		value[cnt] = stk3x1x_i2c_smbus_read_byte_data(ps_data->client, (cnt+1));
-		if(value[cnt] < 0)
-		{
-			printk(KERN_ERR "%s fail, ret=%d", __func__, value[cnt]);	
-			return value[cnt];
-		}
-	}	
-	*/
-	err = stk3x1x_i2c_read_data(ps_data->client, STK_PSCTRL_REG, 9, &value[0]);
-	if(err < 0)
-	{
-		printk(KERN_ERR "%s: fail, ret=%d\n", __func__, err);
-		return err;
-	}	
+    ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_ALSCTRL_REG, ps_data->alsctrl_reg );
+    if (ret < 0) {
+        PRINT_ERR( "%s: write i2c error\n", __func__);
+        goto irs_err_i2c_rw;
+    }
 
-	if(value[0] != ps_data->psctrl_reg)
-	{
-		printk(KERN_ERR "%s: invalid reg 0x01=0x%2x\n", __func__, value[0]);
-		return 0xFF;
-	}	
-	if(value[1] != ps_data->alsctrl_reg)
-	{
-		printk(KERN_ERR "%s: invalid reg 0x02=0x%2x\n", __func__, value[1]);
-		return 0xFF;
-	}
-	if(value[2] != ps_data->ledctrl_reg)
-	{
-		printk(KERN_ERR "%s: invalid reg 0x03=0x%2x\n", __func__, value[2]);
-		return 0xFF;
-	}	
-	if(value[3] != ps_data->int_reg)
-	{
-		printk(KERN_ERR "%s: invalid reg 0x04=0x%2x\n", __func__, value[3]);
-		return 0xFF;
-	}
-	if(value[4] != ps_data->wait_reg)
-	{
-		printk(KERN_ERR "%s: invalid reg 0x05=0x%2x\n", __func__, value[4]);
-		return 0xFF;
-	}		
-	if(value[5] != ((ps_data->ps_thd_h & 0xFF00) >> 8))
-	{
-		printk(KERN_ERR "%s: invalid reg 0x06=0x%2x\n", __func__, value[5]);
-		return 0xFF;
-	}		
-	if(value[6] != (ps_data->ps_thd_h & 0x00FF))
-	{
-		printk(KERN_ERR "%s: invalid reg 0x07=0x%2x\n", __func__, value[6]);
-		return 0xFF;
-	}		
-	if(value[7] != ((ps_data->ps_thd_l & 0xFF00) >> 8))
-	{
-		printk(KERN_ERR "%s: invalid reg 0x08=0x%2x\n", __func__, value[7]);
-		return 0xFF;
-	}		
-	if(value[8] != (ps_data->ps_thd_l & 0x00FF))
-	{
-		printk(KERN_ERR "%s: invalid reg 0x09=0x%2x\n", __func__, value[8]);
-		return 0xFF;
-	}		
-	
-	return 0;
-}
+    return word_data;
 
-static int stk3x1x_validate_n_handle(struct i2c_client *client) 
-{
-	struct stk3x1x_data *ps_data = i2c_get_clientdata(client);
-	int err;
-	
-	err = stk3x1x_chk_reg_valid(ps_data);
-	if(err < 0)
-	{
-		printk(KERN_ERR "stk3x1x_chk_reg_valid fail: %d\n", err);        
-		return err;
-	}
-	
-	if(err == 0xFF)
-	{		
-		printk(KERN_ERR "%s: Re-init chip\n", __func__);				
-		err = stk3x1x_software_reset(ps_data); 
-		if(err < 0)
-			return err;			
-		err = stk3x1x_init_all_reg(ps_data);
-		if(err < 0)
-			return err;			
-		
-		//ps_data->psa = 0;
-		//ps_data->psi = 0xFFFF;		
-		stk3x1x_set_ps_thd_h(ps_data, ps_data->ps_thd_h);
-		stk3x1x_set_ps_thd_l(ps_data, ps_data->ps_thd_l);		
-#ifdef STK_ALS_FIR
-		memset(&ps_data->fir, 0x00, sizeof(ps_data->fir));  
-#endif		
-		return 0xFF;
-	}
-	return 0;
+irs_err_i2c_rw:
+    return ret;
 }
-#endif /* #ifdef STK_CHK_REG */
 
+/*
 static ssize_t stk_als_code_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);		
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
     int32_t reading;
-	
-    reading = stk3x1x_get_als_reading(ps_data);
+    reading = ps_data->als_code_last;
+
     return scnprintf(buf, PAGE_SIZE, "%d\n", reading);
 }
 
-#ifdef QUALCOMM_PLATFORM
-static ssize_t stk_als_enable_set(struct sensors_classdev *sensors_cdev,
-						unsigned int enabled)
-{
-	struct stk3x1x_data *als_data = container_of(sensors_cdev,
-						struct stk3x1x_data, als_cdev);
-	int err;
-
-	mutex_lock(&als_data->io_lock);
-	err = stk3x1x_enable_als(als_data, enabled);
-	mutex_unlock(&als_data->io_lock);
-
-	if (err < 0)
-		return err;
-	return 0;
-}
-#endif
-
 static ssize_t stk_als_enable_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
     int32_t ret;
-	
-	ret = stk3x1x_get_state(ps_data);
-	if(ret < 0)
-		return ret;		
+
+    ret = stk3x1x_get_state(ps_data);
+    if(ret < 0)
+            return ret;
     ret = (ret & STK_STATE_EN_ALS_MASK)?1:0;
-	
-	return scnprintf(buf, PAGE_SIZE, "%d\n", ret);	
+
+    return scnprintf(buf, PAGE_SIZE, "%d\n", ret);
 }
 
 static ssize_t stk_als_enable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
-	struct stk3x1x_data *ps_data = dev_get_drvdata(dev);
-	uint8_t en;
-	if (sysfs_streq(buf, "1"))
-		en = 1;
-	else if (sysfs_streq(buf, "0"))
-		en = 0;
-	else 
-	{
-		printk(KERN_ERR "%s, invalid value %d\n", __func__, *buf);
-		return -EINVAL;
-	}	
-    printk(KERN_INFO "%s: Enable ALS : %d\n", __func__, en);
+    struct stk3x1x_data *ps_data = dev_get_drvdata(dev);
+    uint8_t en;
+    if (sysfs_streq(buf, "1"))
+            en = 1;
+    else if (sysfs_streq(buf, "0"))
+            en = 0;
+    else {
+            PRINT_ERR( "%s, invalid value %d\n", __func__, *buf);
+            return -EINVAL;
+    }
+    PRINT_WARN( "%s: Enable ALS : %d\n", __func__, en);
     mutex_lock(&ps_data->io_lock);
     stk3x1x_enable_als(ps_data, en);
     mutex_unlock(&ps_data->io_lock);
@@ -1834,37 +1007,35 @@
 
 static ssize_t stk_als_lux_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct stk3x1x_data *ps_data = dev_get_drvdata(dev);
+    struct stk3x1x_data *ps_data = dev_get_drvdata(dev);
     int32_t als_reading;
-	uint32_t als_lux;
-    als_reading = stk3x1x_get_als_reading(ps_data);    
-	als_lux = stk_alscode2lux(ps_data, als_reading);
+    uint32_t als_lux;
+    als_reading = stk3x1x_get_als_reading(ps_data);
+    als_lux = stk_alscode2lux(ps_data, als_reading);
     return scnprintf(buf, PAGE_SIZE, "%d lux\n", als_lux);
 }
 
 static ssize_t stk_als_lux_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-	unsigned long value = 0;
-	int ret;
-	ret = kstrtoul(buf, 16, &value);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);	
-		return ret;	
-	}
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    unsigned long value = 0;
+    int ret;
+    ret = kstrtoul(buf, 16, &value);
+    if(ret < 0) {
+        PRINT_ERR( "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
+        return ret;
+    }
     ps_data->als_lux_last = value;
-	input_report_abs(ps_data->als_input_dev, ABS_MISC, value);
-	input_sync(ps_data->als_input_dev);
-	printk(KERN_INFO "%s: als input event %ld lux\n",__func__, value);	
+    input_report_abs(ps_data->ps_input_dev, ABS_MISC, value);
+    input_sync(ps_data->ps_input_dev);
+    PRINT_WARN( "%s: als input event %ld lux\n",__func__, value);
 
     return size;
 }
 
-
 static ssize_t stk_als_transmittance_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
     int32_t transmittance;
     transmittance = ps_data->als_transmittance;
     return scnprintf(buf, PAGE_SIZE, "%d\n", transmittance);
@@ -1873,15 +1044,14 @@
 
 static ssize_t stk_als_transmittance_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-	unsigned long value = 0;
-	int ret;
-	ret = kstrtoul(buf, 10, &value);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
-		return ret;	    
-	}
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    unsigned long value = 0;
+    int ret;
+    ret = kstrtoul(buf, 10, &value);
+    if(ret < 0) {
+        PRINT_ERR( "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
+        return ret;
+    }
     ps_data->als_transmittance = value;
     return size;
 }
@@ -1888,12 +1058,12 @@
 
 static ssize_t stk_als_delay_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
-	int64_t delay;
-	mutex_lock(&ps_data->io_lock);
-	delay = ktime_to_ns(ps_data->als_poll_delay);
-	mutex_unlock(&ps_data->io_lock);
-	return scnprintf(buf, PAGE_SIZE, "%lld\n", delay);
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    int64_t delay;
+    mutex_lock(&ps_data->io_lock);
+    delay = ktime_to_ns(ps_data->als_poll_delay);
+    mutex_unlock(&ps_data->io_lock);
+    return scnprintf(buf, PAGE_SIZE, "%lld\n", delay);
 }
 
 
@@ -1900,491 +1070,276 @@
 static ssize_t stk_als_delay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
     uint64_t value = 0;
-	int ret;	
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-	ret = kstrtoull(buf, 10, &value);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoull failed, ret=0x%x\n", __func__, ret);
-		return ret;	
-	}	
-#ifdef STK_DEBUG_PRINTF		
-	printk(KERN_INFO "%s: set als poll delay=%lld\n", __func__, value);
-#endif	
-	if(value < MIN_ALS_POLL_DELAY_NS)	
-	{
-		printk(KERN_ERR "%s: delay is too small\n", __func__);
-		value = MIN_ALS_POLL_DELAY_NS;
-	}
-	mutex_lock(&ps_data->io_lock);
-	if(value != ktime_to_ns(ps_data->als_poll_delay))
-		ps_data->als_poll_delay = ns_to_ktime(value);	
-#ifdef STK_ALS_FIR		
-	ps_data->fir.number = 0;
-	ps_data->fir.idx = 0;
-	ps_data->fir.sum = 0;
-#endif	
-	mutex_unlock(&ps_data->io_lock);
-	return size;
+    int ret;
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    ret = kstrtoull(buf, 10, &value);
+    if(ret < 0){
+            PRINT_ERR( "%s:kstrtoull failed, ret=0x%x\n", __func__, ret);
+            return ret;
+    }
+#ifdef STK_DEBUG_PRINTF
+    PRINT_WARN( "%s: set als poll delay=%lld\n", __func__, value);
+#endif
+    if(value < MIN_ALS_POLL_DELAY_NS) {
+        PRINT_ERR( "%s: delay is too small\n", __func__);
+        value = MIN_ALS_POLL_DELAY_NS;
+    }
+    mutex_lock(&ps_data->io_lock);
+    if(value != ktime_to_ns(ps_data->als_poll_delay))
+        ps_data->als_poll_delay = ns_to_ktime(value);
+#ifdef STK_ALS_FIR
+    ps_data->fir.number = 0;
+    ps_data->fir.idx = 0;
+    ps_data->fir.sum = 0;
+#endif
+        mutex_unlock(&ps_data->io_lock);
+        return size;
 }
 
 static ssize_t stk_als_ir_code_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);		
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
     int32_t reading;
-    reading = stk3x1x_get_ir_reading(ps_data);
-    return scnprintf(buf, PAGE_SIZE, "%d\n", reading);	
+    reading = stk3x1x_get_ir_reading(ps_data, STK_IRS_IT_REDUCE);
+    return scnprintf(buf, PAGE_SIZE, "%d\n", reading);
 }
 
 #ifdef STK_ALS_FIR
 static ssize_t stk_als_firlen_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
-	int len = atomic_read(&ps_data->firlength);
-	
-	printk(KERN_INFO "%s: len = %2d, idx = %2d\n", __func__, len, ps_data->fir.idx);			
-	printk(KERN_INFO "%s: sum = %5d, ave = %5d\n", __func__, ps_data->fir.sum, ps_data->fir.sum/len);
-	
-	return scnprintf(buf, PAGE_SIZE, "%d\n", len);		
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    int len = atomic_read(&ps_data->firlength);
+
+    PRINT_WARN( "%s: len = %2d, idx = %2d\n", __func__, len, ps_data->fir.idx);
+    PRINT_WARN( "%s: sum = %5d, ave = %5d\n", __func__, ps_data->fir.sum, ps_data->fir.sum/len);
+
+    return scnprintf(buf, PAGE_SIZE, "%d\n", len);
 }
 
 
 static ssize_t stk_als_firlen_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
-    uint64_t value = 0;	
-	int ret;	
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-	ret = kstrtoull(buf, 10, &value);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoull failed, ret=0x%x\n", __func__, ret);
-		return ret;	
-	}	
-	
-	if(value > MAX_FIR_LEN)
-	{
-		printk(KERN_ERR "%s: firlen exceed maximum filter length\n", __func__);
-	}
-	else if (value < 1)
-	{
-		atomic_set(&ps_data->firlength, 1);
-		memset(&ps_data->fir, 0x00, sizeof(ps_data->fir));
-	}
-	else
-	{ 
-		atomic_set(&ps_data->firlength, value);
-		memset(&ps_data->fir, 0x00, sizeof(ps_data->fir));
-	}	
-	return size;	
-}
-#endif  /* #ifdef STK_ALS_FIR */
-
-#ifdef STK_GES		
-static ssize_t stk_ges_code_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
+    uint64_t value = 0;
     int ret;
-	unsigned int gest0 = 0, gest1 = 0, gest2 = 0;
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    ret = kstrtoull(buf, 10, &value);
+    if(ret < 0) {
+        PRINT_ERR( "%s:kstrtoull failed, ret=0x%x\n", __func__, ret);
+        return ret;
+    }
 
-	if(!ps_data->ges_enabled)
-		return 0;
-	
-    ret = stk3x1x_get_ges_reading(ps_data, &gest0, &gest1, &gest2);
-	if(ret < 0)
-		return ret;
-	else if(ret == 0xFFFF)
-		atomic_set(&ps_data->gesture2, 0);
-		
-    return scnprintf(buf, PAGE_SIZE, "%5d,%5d,%5d\n", gest0, gest1, atomic_read(&ps_data->gesture2));
-}
-
-static ssize_t stk_ges_code_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
-	uint8_t ges;
-	unsigned long value = 0;
-	int ret;
-	
-	ret = kstrtoul(buf, 16, &value);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoul failed, ret=%d\n", __func__, ret);	
-		return ret;	
-	}	
-	
-	switch(value)
-	{
-	case 3:
-		//printk(KERN_INFO "%s: ges input event, not detected\n",__func__);			
-	case 0:
-		return size;
-	case 1:
-		ges = KEY_PAGEUP;	
-		atomic_set(&ps_data->gesture2, 0);
-		printk(KERN_INFO "%s: ges input event >>>\n",__func__);		
-		break;
-	case 2:
-		ges = KEY_PAGEDOWN;	
-		atomic_set(&ps_data->gesture2, 0);
-		printk(KERN_INFO "%s: ges input event <<<\n",__func__);		
-		break;
-	case 32:
-		ges = KEY_VOLUMEDOWN;
-		printk(KERN_INFO "%s: ges input event near\n",__func__);		
-		break;
-	case 48:
-		ges = KEY_VOLUMEUP;
-		printk(KERN_INFO "%s: ges input event far\n",__func__);		
-		break;
-	default:
-		printk(KERN_ERR "%s, invalid value %d\n", __func__, (int)value);
-		return -EINVAL;
-	}
-	
-	input_report_key(ps_data->ges_input_dev, ges, 1);
-	input_report_key(ps_data->ges_input_dev, ges, 0);
-	input_sync(ps_data->ges_input_dev);
+    if(value > MAX_FIR_LEN) {
+        PRINT_ERR( "%s: firlen exceed maximum filter length\n", __func__);
+    }
+    else if (value < 1) {
+        atomic_set(&ps_data->firlength, 1);
+        memset(&ps_data->fir, 0x00, sizeof(ps_data->fir));
+    }
+    else {
+        atomic_set(&ps_data->firlength, value);
+        memset(&ps_data->fir, 0x00, sizeof(ps_data->fir));
+    }
     return size;
 }
+#endif   #ifdef STK_ALS_FIR 
+*/
 
-static ssize_t stk_ges_poll_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	int len = 0, ii = 0, jj = 0;
-	
-	while(stk_ges_op[ii].ops[0] != 0)
-	{
-		len += scnprintf(buf + len, PAGE_SIZE - len, "%x ", ii);
-		for(jj=0;jj<4;jj++)
-			len += scnprintf(buf + len, PAGE_SIZE - len, "%x ", stk_ges_op[ii].ops[jj]);
-		len += scnprintf(buf + len, PAGE_SIZE - len, "\n");
-		ii++;
-	}
-	return len;
-}
-
-
-static ssize_t stk_ges_poll_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
-{
-	int32_t ret, i = 0, index = 0;	
-	char *token;
-	unsigned long value = 0;
-		
-	while(buf != '\0')
-	{
-		token = strsep((char **)&buf, " ");
-		if((ret = kstrtoul(token, 16, &value)) < 0)
-		{
-			printk(KERN_ERR "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
-			return ret;	
-		}
-		
-		if(i == 0)
-		{
-			if(value >= 10)
-			{
-				memset(stk_ges_op, 0, sizeof(stk_ges_op));				
-				break;
-			}
-			else
-				index = value;
-		}
-		else
-		{
-			stk_ges_op[index].ops[i-1] = value;
-		}
-		i++;
-		if(i == 5)
-			break;
-	}
-	if(i != 5)
-	{
-		printk(KERN_ERR "%s: invalid length(%d)\n", __func__, i);
-		memset(&(stk_ges_op[index]), 0, sizeof(union stk_ges_operation));				
-	}
-	return size;
-}
-		
-static ssize_t stk_ges_enable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
-	unsigned long value = 0;
-	int ret;
-		
-	ret = kstrtoul(buf, 10, &value);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoul failed, ret=%d\n", __func__, ret);	
-		return ret;	
-	}	
-    printk(KERN_INFO "%s: Enable GES : %d\n", __func__, (int)value);	
-	
-	switch(value)
-	{
-	case 0:
-		mutex_lock(&ps_data->io_lock);
-		if(ps_data->ges_enabled == 1)
-			stk3x1x_enable_ges(ps_data, 0, 1);
-		else
-			stk3x1x_enable_ges(ps_data, 0, 2);	
-		mutex_unlock(&ps_data->io_lock);		
-		break;
-	case 1:
-		mutex_lock(&ps_data->io_lock);
-		stk3x1x_enable_ges(ps_data, 1, 1);
-		mutex_unlock(&ps_data->io_lock);		
-		break;
-	case 2:
-		mutex_lock(&ps_data->io_lock);
-		stk3x1x_enable_ges(ps_data, 1, 2);
-		mutex_unlock(&ps_data->io_lock);		
-		break;
-	default:
-		printk(KERN_ERR "%s, invalid value %d\n", __func__, *buf);
-		return -EINVAL;	
-		break;
-	}
-
-    return size;
-}
-
-static ssize_t stk_ges_enable_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
-	return scnprintf(buf, PAGE_SIZE, "%d\n", ps_data->ges_enabled);		
-}
-
-#endif	/* #ifdef STK_GES */
-
 static ssize_t stk_ps_code_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
     uint32_t reading;
+
     reading = stk3x1x_get_ps_reading(ps_data);
-    return scnprintf(buf, PAGE_SIZE, "%d\n", reading);
-}
 
-#ifdef QUALCOMM_PLATFORM
-static ssize_t stk_ps_enable_set(struct sensors_classdev *sensors_cdev,
-						unsigned int enabled)
-{
-	struct stk3x1x_data *ps_data = container_of(sensors_cdev,
-						struct stk3x1x_data, ps_cdev);
-	int err;
-
-	mutex_lock(&ps_data->io_lock);
-	err = stk3x1x_enable_ps(ps_data, enabled);
-	mutex_unlock(&ps_data->io_lock);
-
-	if (err < 0)
-		return err;
-	return 0;
+    return sprintf(buf,"stk3x1x PS val=%d\n", reading);
 }
-#endif
 
 static ssize_t stk_ps_enable_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     int32_t ret;
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
 
-	ret = stk3x1x_get_state(ps_data);
-	if(ret < 0)
-		return ret;	
+    ret = stk3x1x_get_state(ps_data);
+    if(ret < 0)
+        return ret;
     ret = (ret & STK_STATE_EN_PS_MASK)?1:0;
 
-	return scnprintf(buf, PAGE_SIZE, "%d\n", ret);	
+    return scnprintf(buf, PAGE_SIZE, "%d\n", ret);
 }
 
 static ssize_t stk_ps_enable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
-	uint8_t en;
-	if (sysfs_streq(buf, "1"))
-		en = 1;
-	else if (sysfs_streq(buf, "0"))
-		en = 0;
-	else 
-	{
-		printk(KERN_ERR "%s, invalid value %d\n", __func__, *buf);
-		return -EINVAL;
-	}
-    printk(KERN_INFO "%s: Enable PS : %d\n", __func__, en);
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    uint8_t en;
+    if (sysfs_streq(buf, "1"))
+            en = 1;
+    else if (sysfs_streq(buf, "0"))
+            en = 0;
+    else {
+            PRINT_ERR( "%s, invalid value %d\n", __func__, *buf);
+            return -EINVAL;
+    }
+    PRINT_WARN( "%s: Enable PS : %d\n", __func__, en);
     mutex_lock(&ps_data->io_lock);
-    stk3x1x_enable_ps(ps_data, en, 1);
+    stk3x1x_enable_ps(ps_data, en);
     mutex_unlock(&ps_data->io_lock);
     return size;
 }
 
+/*
 static ssize_t stk_ps_enable_aso_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     int32_t ret;
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
-	
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+
     ret = stk3x1x_i2c_smbus_read_byte_data(ps_data->client,STK_STATE_REG);
     ret = (ret & STK_STATE_EN_ASO_MASK)?1:0;
-	
-	return scnprintf(buf, PAGE_SIZE, "%d\n", ret);		
+
+    return scnprintf(buf, PAGE_SIZE, "%d\n", ret);
 }
 
 static ssize_t stk_ps_enable_aso_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
-	uint8_t en;
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    uint8_t en;
     int32_t ret;
-	uint8_t w_state_reg;
-	
-	if (sysfs_streq(buf, "1"))
-		en = 1;
-	else if (sysfs_streq(buf, "0"))
-		en = 0;
-	else 
-	{
-		printk(KERN_ERR "%s, invalid value %d\n", __func__, *buf);
-		return -EINVAL;
-	}
-    printk(KERN_INFO "%s: Enable PS ASO : %d\n", __func__, en);
-    
+    uint8_t w_state_reg;
+
+    if (sysfs_streq(buf, "1"))
+        en = 1;
+    else if (sysfs_streq(buf, "0"))
+        en = 0;
+    else {
+        PRINT_ERR( "%s, invalid value %d\n", __func__, *buf);
+        return -EINVAL;
+    }
+    PRINT_WARN( "%s: Enable PS ASO : %d\n", __func__, en);
+
     ret = stk3x1x_i2c_smbus_read_byte_data(ps_data->client, STK_STATE_REG);
-    if (ret < 0)
-    {
-        printk(KERN_ERR "%s: write i2c error\n", __func__);
-		return ret;
-    }		
-	w_state_reg = (uint8_t)(ret & (~STK_STATE_EN_ASO_MASK)); 
-	if(en)	
-		w_state_reg |= STK_STATE_EN_ASO_MASK;	
-	
+    if (ret < 0) {
+    PRINT_ERR( "%s: write i2c error\n", __func__);
+        return ret;
+    }
+    w_state_reg = (uint8_t)(ret & (~STK_STATE_EN_ASO_MASK));
+    if(en)
+        w_state_reg |= STK_STATE_EN_ASO_MASK;
+
     ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_STATE_REG, w_state_reg);
-    if (ret < 0)
-	{
-		printk(KERN_ERR "%s: write i2c error\n", __func__);
-		return ret;
-	}	
-	
-	return size;	
+    if (ret < 0) {
+        PRINT_ERR( "%s: write i2c error\n", __func__);
+        return ret;
+    }
+
+    return size;
 }
 
-
 static ssize_t stk_ps_offset_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
-    int32_t word_data;		
-	unsigned char value[2];
-	int ret;
-	
-	ret = stk3x1x_i2c_read_data(ps_data->client, STK_DATA1_OFFSET_REG, 2, &value[0]);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s fail, ret=0x%x", __func__, ret);
-		return ret;
-	}
-	word_data = (value[0]<<8) | value[1];					
-		
-	return scnprintf(buf, PAGE_SIZE, "%d\n", word_data);
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    int32_t word_data;
+    unsigned char value[2];
+    int ret;
+
+    ret = stk3x1x_i2c_read_data(ps_data->client, STK_DATA1_OFFSET_REG, 2, &value[0]);
+    if(ret < 0) {
+        PRINT_ERR( "%s fail, ret=0x%x", __func__, ret);
+        return ret;
+    }
+    word_data = (value[0]<<8) | value[1];
+
+    return scnprintf(buf, PAGE_SIZE, "%d\n", word_data);
 }
- 
+
 static ssize_t stk_ps_offset_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-	unsigned long offset = 0;
-	int ret;
-	unsigned char val[2];
-	
-	ret = kstrtoul(buf, 10, &offset);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);	
-		return ret;	
-	}
-	if(offset > 65535)
-	{
-		printk(KERN_ERR "%s: invalid value, offset=%ld\n", __func__, offset);
-		return -EINVAL;
-	}
-	
-	val[0] = (offset & 0xFF00) >> 8;
-	val[1] = offset & 0x00FF;
-	ret = stk3x1x_i2c_write_data(ps_data->client, STK_DATA1_OFFSET_REG, 2, val);	
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s: write i2c error\n", __func__);
-		return ret;
-	}
-	
-	return size;
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    unsigned long offset = 0;
+    int ret;
+    unsigned char val[2];
+
+    ret = kstrtoul(buf, 10, &offset);
+    if(ret < 0) {
+        PRINT_ERR( "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
+        return ret;
+    }
+    if(offset > 65535) {
+        PRINT_ERR( "%s: invalid value, offset=%ld\n", __func__, offset);
+        return -EINVAL;
+    }
+
+    val[0] = (offset & 0xFF00) >> 8;
+    val[1] = offset & 0x00FF;
+    ret = stk3x1x_i2c_write_data(ps_data->client, STK_DATA1_OFFSET_REG, 2, val);
+    if(ret < 0) {
+        PRINT_ERR( "%s: write i2c error\n", __func__);
+        return ret;
+    }
+
+    return size;
 }
+*/
 
-
 static ssize_t stk_ps_distance_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
     int32_t dist=1, ret;
 
     ret = stk3x1x_get_flag(ps_data);
-	if(ret < 0)
-		return ret;
-    dist = (ret & STK_FLG_NF_MASK)?1:0;	
-	
-    ps_data->ps_distance_last = dist;
-	input_report_abs(ps_data->ps_input_dev, ABS_DISTANCE, dist);
-	input_sync(ps_data->ps_input_dev);
-	wake_lock_timeout(&ps_data->ps_wakelock, 3*HZ);
-	printk(KERN_INFO "%s: ps input event %d cm\n",__func__, dist);		
+    if(ret < 0)
+        return ret;
+    dist = (ret & STK_FLG_NF_MASK)?1:0;
+
+    PRINT_WARN( "%s: ps input event %d cm\n",__func__, dist);
     return scnprintf(buf, PAGE_SIZE, "%d\n", dist);
 }
 
-
+/*
 static ssize_t stk_ps_distance_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-	unsigned long value = 0;
-	int ret;
-	ret = kstrtoul(buf, 10, &value);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);	
-		return ret;	
-	}
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    unsigned long value = 0;
+    int ret;
+
+    ret = kstrtoul(buf, 10, &value);
+    if(ret < 0){
+        PRINT_ERR( "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
+        return ret;
+    }
     ps_data->ps_distance_last = value;
-	input_report_abs(ps_data->ps_input_dev, ABS_DISTANCE, value);
-	input_sync(ps_data->ps_input_dev);
-	wake_lock_timeout(&ps_data->ps_wakelock, 3*HZ);	
-	printk(KERN_INFO "%s: ps input event %ld cm\n",__func__, value);	
+    PRINT_WARN( "%s: ps input event %ld cm\n",__func__, value);
+
     return size;
 }
+*/
 
-
 static ssize_t stk_ps_code_thd_l_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     int32_t ps_thd_l1_reg, ps_thd_l2_reg;
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
     ps_thd_l1_reg = stk3x1x_i2c_smbus_read_byte_data(ps_data->client,STK_THDL1_PS_REG);
-    if(ps_thd_l1_reg < 0)
-	{
-		printk(KERN_ERR "%s fail, err=0x%x", __func__, ps_thd_l1_reg);		
-		return -EINVAL;		
-	}
+    if(ps_thd_l1_reg < 0) {
+        PRINT_ERR( "%s fail, err=0x%x", __func__, ps_thd_l1_reg);
+        return -EINVAL;
+    }
     ps_thd_l2_reg = stk3x1x_i2c_smbus_read_byte_data(ps_data->client,STK_THDL2_PS_REG);
-    if(ps_thd_l2_reg < 0)
-	{
-		printk(KERN_ERR "%s fail, err=0x%x", __func__, ps_thd_l2_reg);		
-		return -EINVAL;		
-	}
-	ps_thd_l1_reg = ps_thd_l1_reg<<8 | ps_thd_l2_reg;
+    if(ps_thd_l2_reg < 0) {
+        PRINT_ERR( "%s fail, err=0x%x", __func__, ps_thd_l2_reg);
+        return -EINVAL;
+    }
+    ps_thd_l1_reg = ps_thd_l1_reg<<8 | ps_thd_l2_reg;
     return scnprintf(buf, PAGE_SIZE, "%d\n", ps_thd_l1_reg);
 }
 
-
 static ssize_t stk_ps_code_thd_l_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);		
-	unsigned long value = 0;
-	int ret;
-	ret = kstrtoul(buf, 10, &value);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
-		return ret;	    
-	}
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    unsigned long value = 0;
+    int ret;
+    ret = kstrtoul(buf, 10, &value);
+    if(ret < 0) {
+        PRINT_ERR( "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
+        return ret;
+    }
     stk3x1x_set_ps_thd_l(ps_data, value);
     return size;
 }
@@ -2392,1600 +1347,782 @@
 static ssize_t stk_ps_code_thd_h_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     int32_t ps_thd_h1_reg, ps_thd_h2_reg;
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
     ps_thd_h1_reg = stk3x1x_i2c_smbus_read_byte_data(ps_data->client,STK_THDH1_PS_REG);
     if(ps_thd_h1_reg < 0)
-	{
-		printk(KERN_ERR "%s fail, err=0x%x", __func__, ps_thd_h1_reg);		
-		return -EINVAL;		
-	}
+    {
+        PRINT_ERR( "%s fail, err=0x%x", __func__, ps_thd_h1_reg);
+        return -EINVAL;
+    }
     ps_thd_h2_reg = stk3x1x_i2c_smbus_read_byte_data(ps_data->client,STK_THDH2_PS_REG);
     if(ps_thd_h2_reg < 0)
-	{
-		printk(KERN_ERR "%s fail, err=0x%x", __func__, ps_thd_h2_reg);		
-		return -EINVAL;		
-	}
-	ps_thd_h1_reg = ps_thd_h1_reg<<8 | ps_thd_h2_reg;
+    {
+        PRINT_ERR( "%s fail, err=0x%x", __func__, ps_thd_h2_reg);
+        return -EINVAL;
+    }
+    ps_thd_h1_reg = ps_thd_h1_reg<<8 | ps_thd_h2_reg;
     return scnprintf(buf, PAGE_SIZE, "%d\n", ps_thd_h1_reg);
 }
 
-
 static ssize_t stk_ps_code_thd_h_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);		
-	unsigned long value = 0;
-	int ret;
-	ret = kstrtoul(buf, 10, &value);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
-		return ret;	    
-	}
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    unsigned long value = 0;
+    int ret;
+    ret = kstrtoul(buf, 10, &value);
+    if(ret < 0)
+    {
+        PRINT_ERR( "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
+        return ret;
+    }
     stk3x1x_set_ps_thd_h(ps_data, value);
     return size;
 }
 
-
 static ssize_t stk_all_reg_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     int32_t ps_reg[0x22];
-	uint8_t cnt;
-	int len = 0;
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-	
-	for(cnt=0;cnt<0x20;cnt++)
-	{
-		ps_reg[cnt] = stk3x1x_i2c_smbus_read_byte_data(ps_data->client, (cnt));
-		if(ps_reg[cnt] < 0)
-		{
-			printk(KERN_ERR "%s fail, ret=%d", __func__, ps_reg[cnt]);	
-			return -EINVAL;
-		}
-		else
-		{
-			printk(KERN_INFO "reg[0x%2X]=0x%2X\n", cnt, ps_reg[cnt]);
-			len += scnprintf(buf+len, PAGE_SIZE-len, "[%2X]%2X,", cnt, ps_reg[cnt]);
-		}
-	}
-	ps_reg[cnt] = stk3x1x_i2c_smbus_read_byte_data(ps_data->client, STK_PDT_ID_REG);
-	if(ps_reg[cnt] < 0)
-	{
-		printk( KERN_ERR "%s fail, ret=%d", __func__, ps_reg[cnt]);	
-		return -EINVAL;
-	}
-	printk( KERN_INFO "reg[0x%x]=0x%2X\n", STK_PDT_ID_REG, ps_reg[cnt]);	
-	cnt++;
-	ps_reg[cnt] = stk3x1x_i2c_smbus_read_byte_data(ps_data->client, STK_RSRVD_REG);
-	if(ps_reg[cnt] < 0)
-	{
-		printk( KERN_ERR "%s fail, ret=%d", __func__, ps_reg[cnt]);	
-		return -EINVAL;
-	}
-	printk( KERN_INFO "reg[0x%x]=0x%2X\n", STK_RSRVD_REG, ps_reg[cnt]);		
-	len += scnprintf(buf+len, PAGE_SIZE-len, "[%2X]%2X,[%2X]%2X\n", cnt-1, ps_reg[cnt-1], cnt, ps_reg[cnt]);
-	return len;
+    uint8_t cnt;
+    int len = 0;
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+
+    for(cnt=0;cnt<0x20;cnt++) {
+        ps_reg[cnt] = stk3x1x_i2c_smbus_read_byte_data(ps_data->client, (cnt));
+        if(ps_reg[cnt] < 0) {
+            PRINT_ERR( "%s fail, ret=%d", __func__, ps_reg[cnt]);
+            return -EINVAL;
+        }
+        else {
+                PRINT_WARN( "reg[0x%2X]=0x%2X\n", cnt, ps_reg[cnt]);
+                len += scnprintf(buf+len, PAGE_SIZE-len, "[%2X]%2X,", cnt, ps_reg[cnt]);
+        }
+    }
+    ps_reg[cnt] = stk3x1x_i2c_smbus_read_byte_data(ps_data->client, STK_PDT_ID_REG);
+    if(ps_reg[cnt] < 0) {
+        printk( KERN_ERR "%s fail, ret=%d", __func__, ps_reg[cnt]);
+        return -EINVAL;
+    }
+    printk( KERN_INFO "reg[0x%x]=0x%2X\n", STK_PDT_ID_REG, ps_reg[cnt]);
+    cnt++;
+    ps_reg[cnt] = stk3x1x_i2c_smbus_read_byte_data(ps_data->client, STK_RSRVD_REG);
+    if(ps_reg[cnt] < 0) {
+        printk( KERN_ERR "%s fail, ret=%d", __func__, ps_reg[cnt]);
+        return -EINVAL;
+    }
+    printk( KERN_INFO "reg[0x%x]=0x%2X\n", STK_RSRVD_REG, ps_reg[cnt]);
+    len += scnprintf(buf+len, PAGE_SIZE-len, "[%2X]%2X,[%2X]%2X\n", cnt-1, ps_reg[cnt-1], cnt, ps_reg[cnt]);
+    return len;
 /*
-    return scnprintf(buf, PAGE_SIZE, "[0]%2X [1]%2X [2]%2X [3]%2X [4]%2X [5]%2X [6/7 HTHD]%2X,%2X [8/9 LTHD]%2X, %2X [A]%2X [B]%2X [C]%2X [D]%2X [E/F Aoff]%2X,%2X,[10]%2X [11/12 PS]%2X,%2X [13]%2X [14]%2X [15/16 Foff]%2X,%2X [17]%2X [18]%2X [3E]%2X [3F]%2X\n", 	
-		ps_reg[0], ps_reg[1], ps_reg[2], ps_reg[3], ps_reg[4], ps_reg[5], ps_reg[6], ps_reg[7], ps_reg[8], 
-		ps_reg[9], ps_reg[10], ps_reg[11], ps_reg[12], ps_reg[13], ps_reg[14], ps_reg[15], ps_reg[16], ps_reg[17], 
-		ps_reg[18], ps_reg[19], ps_reg[20], ps_reg[21], ps_reg[22], ps_reg[23], ps_reg[24], ps_reg[25], ps_reg[26]);
-		*/
+    return scnprintf(buf, PAGE_SIZE, "[0]%2X [1]%2X [2]%2X [3]%2X [4]%2X [5]%2X [6/7 HTHD]%2X,%2X [8/9 LTHD]%2X, %2X [A]%2X [B]%2X [C]%2X [D]%2X [E/F Aoff]%2X,%2X,[10]%2X [11/12 PS]%2X,%2X [13]%2X [14]%2X [15/16 Foff]%2X,%2X [17]%2X [18]%2X [3E]%2X [3F]%2X\n",
+                ps_reg[0], ps_reg[1], ps_reg[2], ps_reg[3], ps_reg[4], ps_reg[5], ps_reg[6], ps_reg[7], ps_reg[8],
+                ps_reg[9], ps_reg[10], ps_reg[11], ps_reg[12], ps_reg[13], ps_reg[14], ps_reg[15], ps_reg[16], ps_reg[17],
+                ps_reg[18], ps_reg[19], ps_reg[20], ps_reg[21], ps_reg[22], ps_reg[23], ps_reg[24], ps_reg[25], ps_reg[26]);
+                */
 }
 
+/*
 static ssize_t stk_status_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
     int32_t ps_reg[27];
-	uint8_t cnt;
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-	for(cnt=0;cnt<25;cnt++)
-	{
-		ps_reg[cnt] = stk3x1x_i2c_smbus_read_byte_data(ps_data->client, (cnt));
-		if(ps_reg[cnt] < 0)
-		{
-			printk(KERN_ERR "%s fail, ret=%d", __func__, ps_reg[cnt]);	
-			return -EINVAL;
-		}
-		else
-		{
-			printk(KERN_INFO "reg[0x%2X]=0x%2X\n", cnt, ps_reg[cnt]);
-		}
-	}
-	ps_reg[cnt] = stk3x1x_i2c_smbus_read_byte_data(ps_data->client, STK_PDT_ID_REG);
-	if(ps_reg[cnt] < 0)
-	{
-		printk( KERN_ERR "%s fail, ret=%d", __func__, ps_reg[cnt]);	
-		return -EINVAL;
-	}
-	printk( KERN_INFO "reg[0x%x]=0x%2X\n", STK_PDT_ID_REG, ps_reg[cnt]);	
-	cnt++;
-	ps_reg[cnt] = stk3x1x_i2c_smbus_read_byte_data(ps_data->client, STK_RSRVD_REG);
-	if(ps_reg[cnt] < 0)
-	{
-		printk( KERN_ERR "%s fail, ret=%d", __func__, ps_reg[cnt]);	
-		return -EINVAL;
-	}
-	printk( KERN_INFO "reg[0x%x]=0x%2X\n", STK_RSRVD_REG, ps_reg[cnt]);		
+    uint8_t cnt;
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    for(cnt=0;cnt<25;cnt++) {
+        ps_reg[cnt] = stk3x1x_i2c_smbus_read_byte_data(ps_data->client, (cnt));
+        if(ps_reg[cnt] < 0) {
+                PRINT_ERR( "%s fail, ret=%d", __func__, ps_reg[cnt]);
+                return -EINVAL;
+        }
+        else {
+                PRINT_WARN( "reg[0x%2X]=0x%2X\n", cnt, ps_reg[cnt]);
+        }
+    }
+    ps_reg[cnt] = stk3x1x_i2c_smbus_read_byte_data(ps_data->client, STK_PDT_ID_REG);
+     if(ps_reg[cnt] < 0) {
+        printk( KERN_ERR "%s fail, ret=%d", __func__, ps_reg[cnt]);
+        return -EINVAL;
+    }
+    printk( KERN_INFO "reg[0x%x]=0x%2X\n", STK_PDT_ID_REG, ps_reg[cnt]);
+    cnt++;
+    ps_reg[cnt] = stk3x1x_i2c_smbus_read_byte_data(ps_data->client, STK_RSRVD_REG);
+    if(ps_reg[cnt] < 0) {
+        printk( KERN_ERR "%s fail, ret=%d", __func__, ps_reg[cnt]);
+        return -EINVAL;
+    }
+    printk( KERN_INFO "reg[0x%x]=0x%2X\n", STK_RSRVD_REG, ps_reg[cnt]);
 
-    return scnprintf(buf, PAGE_SIZE, "[PS=%2X] [ALS=%2X] [WAIT=0x%4Xms] [EN_ASO=%2X] [EN_AK=%2X] [NEAR/FAR=%2X] [FLAG_OUI=%2X] [FLAG_PSINT=%2X] [FLAG_ALSINT=%2X]\n", 
-		ps_reg[0]&0x01,(ps_reg[0]&0x02)>>1,((ps_reg[0]&0x04)>>2)*ps_reg[5]*6,(ps_reg[0]&0x20)>>5,
-		(ps_reg[0]&0x40)>>6,ps_reg[16]&0x01,(ps_reg[16]&0x04)>>2,(ps_reg[16]&0x10)>>4,(ps_reg[16]&0x20)>>5);		
+    return scnprintf(buf, PAGE_SIZE, "[PS=%2X] [ALS=%2X] [WAIT=0x%4Xms] [EN_ASO=%2X] [EN_AK=%2X] [NEAR/FAR=%2X] [FLAG_OUI=%2X] [FLAG_PSINT=%2X] [FLAG_ALSINT=%2X]\n",
+        ps_reg[0]&0x01,(ps_reg[0]&0x02)>>1,((ps_reg[0]&0x04)>>2)*ps_reg[5]*6,(ps_reg[0]&0x20)>>5,
+        (ps_reg[0]&0x40)>>6,ps_reg[16]&0x01,(ps_reg[16]&0x04)>>2,(ps_reg[16]&0x10)>>4,(ps_reg[16]&0x20)>>5);
 }
 
 static ssize_t stk_recv_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-	return scnprintf(buf, PAGE_SIZE, "0x%04X\n", atomic_read(&ps_data->recv_reg));     		
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    return scnprintf(buf, PAGE_SIZE, "0x%04X\n", atomic_read(&ps_data->recv_reg));
 }
 
-
 static ssize_t stk_recv_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
     unsigned long value = 0;
-	int ret;
-	int32_t recv_data;	
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-	
-	if((ret = kstrtoul(buf, 16, &value)) < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
-		return ret;	
-	}
-	recv_data = stk3x1x_i2c_smbus_read_byte_data(ps_data->client,value);
-//	printk("%s: reg 0x%x=0x%x\n", __func__, (int)value, recv_data);
-	atomic_set(&ps_data->recv_reg, recv_data);
-	return size;
+    int ret;
+    int32_t recv_data;
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+
+    if((ret = kstrtoul(buf, 16, &value)) < 0)
+    {
+        PRINT_ERR( "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
+        return ret;
+    }
+    recv_data = stk3x1x_i2c_smbus_read_byte_data(ps_data->client,value);
+    //      printk("%s: reg 0x%x=0x%x\n", __func__, (int)value, recv_data);
+    atomic_set(&ps_data->recv_reg, recv_data);
+    return size;
 }
 
-
 static ssize_t stk_send_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	return 0;
+        return 0;
 }
+*/
 
-
 static ssize_t stk_send_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
-	int addr, cmd;
-	int32_t ret, i;
-	char *token[10];
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-	
-	for (i = 0; i < 2; i++)
-		token[i] = strsep((char **)&buf, " ");
-	if((ret = kstrtoul(token[0], 16, (unsigned long *)&(addr))) < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
-		return ret;	
-	}
-	if((ret = kstrtoul(token[1], 16, (unsigned long *)&(cmd))) < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
-		return ret;	
-	}
-	printk(KERN_INFO "%s: write reg 0x%x=0x%x\n", __func__, addr, cmd);		
+    int addr, cmd;
+    int32_t ret, i;
+    char *token[10];
+    struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
 
-	ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, (unsigned char)addr, (unsigned char)cmd);
-	if (0 != ret)
-	{	
-		printk(KERN_ERR "%s: stk3x1x_i2c_smbus_write_byte_data fail\n", __func__);
-		return ret;
-	}
-	
-	return size;
-}
+    for (i = 0; i < 2; i++)
+        token[i] = strsep((char **)&buf, " ");
+    if((ret = kstrtoul(token[0], 16, (unsigned long *)&(addr))) < 0) {
+        PRINT_ERR( "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
+        return ret;
+    }
+    if((ret = kstrtoul(token[1], 16, (unsigned long *)&(cmd))) < 0) {
+        PRINT_ERR( "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
+        return ret;
+    }
+    PRINT_WARN( "%s: write reg 0x%x=0x%x\n", __func__, addr, cmd);
 
-#ifdef STK_TUNE0
+    ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, (unsigned char)addr, (unsigned char)cmd);
+    if (0 != ret) {
+        PRINT_ERR( "%s: stk3x1x_i2c_smbus_write_byte_data fail\n", __func__);
+        return ret;
+    }
 
-static ssize_t stk_ps_cali_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-	int32_t word_data;	
-	unsigned char value[2];
-	int ret;
-	
-	ret = stk3x1x_i2c_read_data(ps_data->client, 0x20, 2, &value[0]);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s fail, ret=0x%x", __func__, ret);
-		return ret;
-	}
-	word_data = (value[0]<<8) | value[1];	
-	
-	ret = stk3x1x_i2c_read_data(ps_data->client, 0x22, 2, &value[0]);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s fail, ret=0x%x", __func__, ret);
-		return ret;
-	}
-	word_data += ((value[0]<<8) | value[1]);		
-
-	printk("%s: psi_set=%d, psa=%d,psi=%d, word_data=%d\n", __func__, 
-		ps_data->psi_set, ps_data->psa, ps_data->psi, word_data);	
-#ifdef CALI_PS_EVERY_TIME
-	printk("%s: boot HT=%d, LT=%d\n", __func__, ps_data->ps_high_thd_boot, ps_data->ps_low_thd_boot);
-#endif	
-	return 0;
+    return size;
 }
 
-static ssize_t stk_ps_maxdiff_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+static DEVICE_ATTR(regw, 0220, NULL, stk_send_store);
+static DEVICE_ATTR(distance, 0440, stk_ps_distance_show, NULL);
+static DEVICE_ATTR(thdl, 0660, stk_ps_code_thd_l_show, stk_ps_code_thd_l_store);
+static DEVICE_ATTR(thdh, 0660, stk_ps_code_thd_h_show, stk_ps_code_thd_h_store);
+static DEVICE_ATTR(enable, 0660, stk_ps_enable_show, stk_ps_enable_store);
+static DEVICE_ATTR(dumpreg, 0440,    stk_all_reg_show,              NULL);
+static DEVICE_ATTR(Huaqin_show_val, 0444,    stk_ps_code_show,  NULL);
+
+static int stk_pls_create_sysfs(struct i2c_client *client)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-    unsigned long value = 0;
-	int ret;
-	
-	if((ret = kstrtoul(buf, 10, &value)) < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
-		return ret;	
-	}
-	ps_data->stk_max_min_diff = (int) value;
-	return size;
-}
+    int err = -1;
+    struct device *dev = &(client->dev);
 
+    printk("%s \n", __func__);
+    err = device_create_file(dev, &dev_attr_distance);
+    err |= device_create_file(dev, &dev_attr_dumpreg);
+    err |= device_create_file(dev, &dev_attr_enable);
+    err |= device_create_file(dev, &dev_attr_thdl);
+    err |= device_create_file(dev, &dev_attr_thdh);
+    err |= device_create_file(dev, &dev_attr_regw);
+    err |= device_create_file(dev, &dev_attr_Huaqin_show_val);
 
-static ssize_t stk_ps_maxdiff_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-	return scnprintf(buf, PAGE_SIZE, "%d\n", ps_data->stk_max_min_diff);     		
+    return err;
 }
-
-static ssize_t stk_ps_ltnct_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+static ssize_t huaqin_ps_noise_show(struct kobject *kobj, struct kobj_attribute *attr, char *buff)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-    unsigned long value = 0;
-	int ret;
-	
-	if((ret = kstrtoul(buf, 10, &value)) < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
-		return ret;	
-	}
-	ps_data->stk_lt_n_ct = (int) value;
-	return size;
+    // struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);
+    struct stk3x1x_data *ps_data =  i2c_get_clientdata(this_client);
+    uint32_t reading;
+    //unsigned int count=0;
+    reading = stk3x1x_get_ps_reading(ps_data);
+    printk("stk3x1x ps_nosie= %d\n", reading);
+    if( reading > MAX_PS_NOISE)
+        return sprintf(buff,"device_name:STK3X1X @FAIL@PS_noise=%d\n", reading);
+    else
+        return sprintf(buff,"device_name:STK3X1X @PASS@PS_noise=%d\n", reading);
 }
 
-static ssize_t stk_ps_ltnct_show(struct device *dev, struct device_attribute *attr, char *buf)
+static struct kobj_attribute psensor_noise = \
+            __ATTR(psensor_noise, 0444, huaqin_ps_noise_show, NULL);
+/*---------------------------------------------------------------------------*/
+static int huaqin_psensor_noise_attr(void)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-	return scnprintf(buf, PAGE_SIZE, "%d\n", ps_data->stk_lt_n_ct);     		
-}
+    int ret = -1;
+    struct kobject *psensor_kobj = NULL;
 
-static ssize_t stk_ps_htnct_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-    unsigned long value = 0;
-	int ret;
-	
-	if((ret = kstrtoul(buf, 10, &value)) < 0)
-	{
-		printk(KERN_ERR "%s:kstrtoul failed, ret=0x%x\n", __func__, ret);
-		return ret;	
-	}
-	ps_data->stk_ht_n_ct = (int) value;
-	return size;
+    psensor_kobj = kobject_create_and_add("psensor", kernel_kobj);
+    if (psensor_kobj == NULL) {
+        ret = -ENOMEM;
+        printk("register sysfs failed. ret = %d\n", ret);
+        return ret;
+    }
+
+    ret = sysfs_create_file(psensor_kobj, &psensor_noise.attr);
+    if (ret) {
+        printk("create sysfs failed. ret = %d\n", ret);
+        return ret;
+    }
+    return 0;
 }
 
-static ssize_t stk_ps_htnct_show(struct device *dev, struct device_attribute *attr, char *buf)
+static enum hrtimer_restart stk_als_timer_func(struct hrtimer *timer)
 {
-	struct stk3x1x_data *ps_data =  dev_get_drvdata(dev);	
-	return scnprintf(buf, PAGE_SIZE, "%d\n", ps_data->stk_ht_n_ct);     		
+    struct stk3x1x_data *ps_data = container_of(timer, struct stk3x1x_data, als_timer);
+    queue_work(ps_data->stk_als_wq, &ps_data->stk_als_work);
+    hrtimer_forward_now(&ps_data->als_timer, ps_data->als_poll_delay);
+    return HRTIMER_RESTART;
 }
-#endif	/* #ifdef STK_TUNE0 */
 
-static struct device_attribute als_enable_attribute = __ATTR(enable,0660,stk_als_enable_show,stk_als_enable_store);
-static struct device_attribute als_lux_attribute = __ATTR(lux,0664,stk_als_lux_show,stk_als_lux_store);
-static struct device_attribute als_code_attribute = __ATTR(code, 0444, stk_als_code_show, NULL);
-static struct device_attribute als_transmittance_attribute = __ATTR(transmittance,0664,stk_als_transmittance_show,stk_als_transmittance_store);
-static struct device_attribute als_poll_delay_attribute = __ATTR(delay,0664,stk_als_delay_show,stk_als_delay_store);
-static struct device_attribute als_ir_code_attribute = __ATTR(ircode,0444,stk_als_ir_code_show,NULL);
-#ifdef STK_ALS_FIR
-static struct device_attribute als_firlen_attribute = __ATTR(firlen,0664,stk_als_firlen_show,stk_als_firlen_store);
-#endif
-
-static struct attribute *stk_als_attrs [] =
+static void stk_als_poll_work_func(struct work_struct *work)
 {
-	&als_enable_attribute.attr,
-    &als_lux_attribute.attr,
-    &als_code_attribute.attr,
-    &als_transmittance_attribute.attr,
-	&als_poll_delay_attribute.attr,
-	&als_ir_code_attribute.attr,
-#ifdef STK_ALS_FIR
-	&als_firlen_attribute.attr,
-#endif	
-    NULL
-};
+    struct stk3x1x_data *ps_data = container_of(work, struct stk3x1x_data, stk_als_work);
+    int32_t reading = 0, reading_lux, flag_reg;
 
-static struct attribute_group stk_als_attribute_group = {
-#ifndef QUALCOMM_PLATFORM
-	.name = "driver",
-#endif	
-	.attrs = stk_als_attrs,
-};
+    flag_reg = stk3x1x_get_flag(ps_data);
+    if(flag_reg < 0)
+        return;
+    if(!(flag_reg&STK_FLG_ALSDR_MASK))
+    {
+        //PRINT_WARN( "%s: als is not ready\n", __func__);
+        return;
+    }
 
-#ifdef STK_GES		
-static struct device_attribute ges_enable_attribute = __ATTR(enable,0660,stk_ges_enable_show,stk_ges_enable_store);
-static struct device_attribute ges_code_attribute = __ATTR(code, 0664, stk_ges_code_show, stk_ges_code_store);
-static struct device_attribute ges_poll_attribute = __ATTR(poll, 0664, stk_ges_poll_show, stk_ges_poll_store);
-static struct device_attribute ges_recv_attribute = __ATTR(recv,0664,stk_recv_show,stk_recv_store);
-static struct device_attribute ges_send_attribute = __ATTR(send,0664,stk_send_show, stk_send_store);
+    reading = stk3x1x_get_als_reading(ps_data);
+    if(reading < 0)
+        return;
 
-static struct attribute *stk_ges_attrs [] =
-{
-    &ges_enable_attribute.attr,	
-    &ges_code_attribute.attr,
-    &ges_poll_attribute.attr,
-	&ges_recv_attribute.attr,
-	&ges_send_attribute.attr,
-    NULL
-};
+#ifdef STK_DEBUG_PRINTF
+     printk("%s:  als_data=%d\n", __func__, reading);
+#endif
 
-static struct attribute_group stk_ges_attribute_group = 
-{
-	.name = "driver",	
-	.attrs = stk_ges_attrs,
-};
-#endif	/* #ifdef STK_GES */
-
-static struct device_attribute ps_enable_attribute = __ATTR(enable,0660,stk_ps_enable_show,stk_ps_enable_store);
-static struct device_attribute ps_enable_aso_attribute = __ATTR(enableaso,0664,stk_ps_enable_aso_show,stk_ps_enable_aso_store);
-static struct device_attribute ps_distance_attribute = __ATTR(distance,0664,stk_ps_distance_show, stk_ps_distance_store);
-static struct device_attribute ps_offset_attribute = __ATTR(offset,0664,stk_ps_offset_show, stk_ps_offset_store);
-static struct device_attribute ps_code_attribute = __ATTR(code, 0444, stk_ps_code_show, NULL);
-static struct device_attribute ps_code_thd_l_attribute = __ATTR(codethdl,0664,stk_ps_code_thd_l_show,stk_ps_code_thd_l_store);
-static struct device_attribute ps_code_thd_h_attribute = __ATTR(codethdh,0664,stk_ps_code_thd_h_show,stk_ps_code_thd_h_store);
-static struct device_attribute ps_recv_attribute = __ATTR(recv,0664,stk_recv_show,stk_recv_store);
-static struct device_attribute ps_send_attribute = __ATTR(send,0664,stk_send_show, stk_send_store);
-static struct device_attribute all_reg_attribute = __ATTR(allreg, 0444, stk_all_reg_show, NULL);
-static struct device_attribute status_attribute = __ATTR(status, 0444, stk_status_show, NULL);
-#ifdef STK_TUNE0
-static struct device_attribute ps_cali_attribute = __ATTR(cali,0444,stk_ps_cali_show, NULL);
-static struct device_attribute ps_maxdiff_attribute = __ATTR(maxdiff,0664,stk_ps_maxdiff_show, stk_ps_maxdiff_store);
-static struct device_attribute ps_ltnct_attribute = __ATTR(ltnct,0664,stk_ps_ltnct_show, stk_ps_ltnct_store);
-static struct device_attribute ps_htnct_attribute = __ATTR(htnct,0664,stk_ps_htnct_show, stk_ps_htnct_store);
+    reading_lux = stk_alscode2lux(ps_data, reading);
+    //if(abs(ps_data->als_lux_last - reading_lux) >= STK_ALS_CHANGE_THD)
+//    {
+        ps_data->als_lux_last = reading_lux;
+        input_report_abs(ps_data->ps_input_dev, ABS_MISC, reading_lux);
+        input_sync(ps_data->ps_input_dev);
+#ifdef STK_DEBUG_PRINTF
+        PRINT_WARN( "%s: als input event %d lux\n",__func__, reading_lux);
 #endif
+//    }
+    return;
+}
 
-static struct attribute *stk_ps_attrs [] =
+static void stk_irq_work_func(struct work_struct *work)
 {
-    &ps_enable_attribute.attr,
-    &ps_enable_aso_attribute.attr,
-    &ps_distance_attribute.attr,
-	&ps_offset_attribute.attr,
-    &ps_code_attribute.attr,
-	&ps_code_thd_l_attribute.attr,
-	&ps_code_thd_h_attribute.attr,	
-	&ps_recv_attribute.attr,
-	&ps_send_attribute.attr,	
-	&all_reg_attribute.attr,
-	&status_attribute.attr,
-#ifdef STK_TUNE0
-	&ps_cali_attribute.attr,
-	&ps_maxdiff_attribute.attr,
-	&ps_ltnct_attribute.attr,
-	&ps_htnct_attribute.attr,
-#endif	
-    NULL
-};
-
-static struct attribute_group stk_ps_attribute_group = {
-#ifndef QUALCOMM_PLATFORM
-	.name = "driver",	
-#endif	
-	.attrs = stk_ps_attrs,
-};
-
-static int stk_ps_val(struct stk3x1x_data *ps_data)
-{
-	int mode;
-	int32_t word_data, lii;	
-	unsigned char value[4];
-	int ret;
+    struct stk3x1x_data *ps_data = container_of(work, struct stk3x1x_data, stk_work);
+    int32_t near_far_state;
+    int32_t als_comperator;	
+    uint32_t reading;
 	
-	ret = stk3x1x_i2c_read_data(ps_data->client, 0x20, 4, value);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "%s fail, ret=0x%x", __func__, ret);
-		return ret;
-	}
-	word_data = (value[0]<<8) | value[1];	
-	word_data += ((value[2]<<8) | value[3]);	
-	
-	mode = (ps_data->psctrl_reg) & 0x3F;
-	if(mode == 0x30)	
-		lii = 100;	
-	else if (mode == 0x31)
-		lii = 200;		
-	else if (mode == 0x32)
-		lii = 400;		
-	else if (mode == 0x33)
-		lii = 800;	
-	else
-	{
-		printk(KERN_ERR "%s: unsupported PS_IT(0x%x)\n", __func__, mode);
-		return -1;
-	}
-	
-	if(word_data > lii)	
-	{
-		printk(KERN_INFO "%s: word_data=%d, lii=%d\n", __func__, word_data, lii);	
-		return 0xFFFF;	
-	}
-	return 0;
-}	
+#if ((STK_INT_PS_MODE != 0x03) && (STK_INT_PS_MODE != 0x02))
+    int32_t ret;
+    uint8_t disable_flag = 0;
+    int32_t org_flag_reg;
+#endif
 
-#ifdef STK_TUNE0	
+#if (STK_INT_PS_MODE    == 0x03)
+    near_far_state = gpio_get_value(ps_data->int_pin);
+#elif   (STK_INT_PS_MODE   == 0x02)
+    near_far_state = !(gpio_get_value(ps_data->int_pin));
+#endif
 
-static int stk_ps_tune_zero_final(struct stk3x1x_data *ps_data)
-{
-	int ret;
-	
-	ps_data->tune_zero_init_proc = false;
-	ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_INT_REG, ps_data->int_reg);
-	if (ret < 0)
-	{
-		printk(KERN_ERR "%s: write i2c error\n", __func__);
-		return ret;
-	}	
-	
-	ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_STATE_REG, 0);
-	if (ret < 0)
-	{
-		printk(KERN_ERR "%s: write i2c error\n", __func__);
-		return ret;
-	}		
-	
-	if(ps_data->data_count == -1)
-	{
-		printk(KERN_INFO "%s: exceed limit\n", __func__);
-		hrtimer_cancel(&ps_data->ps_tune0_timer);	
-		return 0;
-	}
-	
-	ps_data->psa = ps_data->ps_stat_data[0];
-	ps_data->psi = ps_data->ps_stat_data[2];	
+#if ((STK_INT_PS_MODE == 0x03) || (STK_INT_PS_MODE      == 0x02))
+    ps_data->ps_distance_last = near_far_state;
+    input_report_abs(ps_data->ps_input_dev, ABS_DISTANCE, near_far_state);
+    input_sync(ps_data->ps_input_dev);
+    wake_lock_timeout(&ps_data->ps_wakelock, 3*HZ);
+    reading = stk3x1x_get_ps_reading(ps_data);
+#ifdef STK_DEBUG_PRINTF
+    PRINT_WARN( "%s: ps input event %d cm, ps code = %d\n",__func__, near_far_state, reading);
+#endif
 
-#ifdef CALI_PS_EVERY_TIME
-	ps_data->ps_high_thd_boot = ps_data->ps_stat_data[1] + ps_data->stk_ht_n_ct*3;
-	ps_data->ps_low_thd_boot = ps_data->ps_stat_data[1] + ps_data->stk_lt_n_ct*3;
-	ps_data->ps_thd_h = ps_data->ps_high_thd_boot ;
-	ps_data->ps_thd_l = ps_data->ps_low_thd_boot ;		
-#else						
-	ps_data->ps_thd_h = ps_data->ps_stat_data[1] + ps_data->stk_ht_n_ct;
-	ps_data->ps_thd_l = ps_data->ps_stat_data[1] + ps_data->stk_lt_n_ct;			
+#else //#if ((STK_INT_PS_MODE == 0x03) || (STK_INT_PS_MODE      == 0x02)) 
+    /* mode 0x01 or 0x04 */
+     org_flag_reg = stk3x1x_get_flag(ps_data);
+    PRINT_ERR( " stk_irq_work_func  org_flag_reg:%x\n",  org_flag_reg);
+#ifdef HQ_PSENSOR_CALIBRATION
+    printk("zqq int:init=%d,noise=%d,low=%d,high=%d\n",ps_data->init_noise,\
+     ps_data->current_xtalk,ps_data->ps_thd_l,ps_data->ps_thd_h);
 #endif
-	stk3x1x_set_ps_thd_h(ps_data, ps_data->ps_thd_h);
-	stk3x1x_set_ps_thd_l(ps_data, ps_data->ps_thd_l);				
-	printk(KERN_INFO "%s: set HT=%d,LT=%d\n", __func__, ps_data->ps_thd_h,  ps_data->ps_thd_l);		
-	hrtimer_cancel(&ps_data->ps_tune0_timer);					
-	return 0;
-}
-	
-static int32_t stk_tune_zero_get_ps_data(struct stk3x1x_data *ps_data)
-{
-	uint32_t ps_adc;
-	int ret;
-	
-	ret = stk_ps_val(ps_data);	
-	if(ret == 0xFFFF)
-	{		
-		ps_data->data_count = -1;
-		stk_ps_tune_zero_final(ps_data);
-		return 0;
-	}	
-	
-	ps_adc = stk3x1x_get_ps_reading(ps_data);
-	printk(KERN_INFO "%s: ps_adc #%d=%d\n", __func__, ps_data->data_count, ps_adc);
-	if(ps_adc < 0)		
-		return ps_adc;		
-	
-	ps_data->ps_stat_data[1]  +=  ps_adc;			
-	if(ps_adc > ps_data->ps_stat_data[0])
-		ps_data->ps_stat_data[0] = ps_adc;
-	if(ps_adc < ps_data->ps_stat_data[2])
-		ps_data->ps_stat_data[2] = ps_adc;						
-	ps_data->data_count++;	
-	
-	if(ps_data->data_count == 5)
-	{
-		ps_data->ps_stat_data[1]  /= ps_data->data_count;			
-		stk_ps_tune_zero_final(ps_data);
-	}		
-	
-	return 0;
-}
 
-static int stk_ps_tune_zero_init(struct stk3x1x_data *ps_data)
-{
-	int32_t ret = 0;
-	uint8_t w_state_reg;	
-	
-	ps_data->psi_set = 0;	
-	ps_data->ps_stat_data[0] = 0;
-	ps_data->ps_stat_data[2] = 9999;
-	ps_data->ps_stat_data[1] = 0;
-	ps_data->data_count = 0;
-	
-	ps_data->tune_zero_init_proc = true;		
-	ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_INT_REG, 0);
-	if (ret < 0)
-	{
-		printk(KERN_ERR "%s: write i2c error\n", __func__);
-		return ret;
-	}			
-	
-	w_state_reg = (STK_STATE_EN_PS_MASK | STK_STATE_EN_WAIT_MASK);			
-	ret = stk3x1x_i2c_smbus_write_byte_data(ps_data->client, STK_STATE_REG, w_state_reg);
-	if (ret < 0)
-	{
-		printk(KERN_ERR "%s: write i2c error\n", __func__);
-		return ret;
-	}		
-	hrtimer_start(&ps_data->ps_tune0_timer, ps_data->ps_tune0_delay, HRTIMER_MODE_REL);		
+    if(org_flag_reg < 0)
+    goto err_i2c_rw;
 
-	return 0;	
-}
+    if (org_flag_reg & STK_FLG_ALSINT_MASK) {
+        disable_flag |= STK_FLG_ALSINT_MASK;
+        reading = stk3x1x_get_als_reading(ps_data);
+        if(reading < 0) {
+            PRINT_ERR( "%s: stk3x1x_get_als_reading fail, ret=%d", __func__, reading);
+            goto err_i2c_rw;
+        }
 
-static int stk_ps_tune_zero_func_fae(struct stk3x1x_data *ps_data)
-{
-	int32_t word_data;
-	int ret, diff;
-	unsigned char value[2];
-			
-#ifdef CALI_PS_EVERY_TIME
-	if(!(ps_data->ps_enabled))
+#ifndef CONFIG_STK_PS_ALS_USE_CHANGE_THRESHOLD
+   uint32_t nLuxIndex = stk_get_lux_interval_index(reading);
+    stk3x1x_set_als_thd_h(ps_data, code_threshold_table[nLuxIndex]);
+    stk3x1x_set_als_thd_l(ps_data, code_threshold_table[nLuxIndex-1]);
 #else
-	if(ps_data->psi_set || !(ps_data->ps_enabled))
+    stk_als_set_new_thd(ps_data, reading);
+#endif //CONFIG_STK_PS_ALS_USE_CHANGE_THRESHOLD
+
+        if(ps_data->ir_code) {
+            if(reading < STK_IRC_MAX_ALS_CODE && reading > STK_IRC_MIN_ALS_CODE &&
+            ps_data->ir_code > STK_IRC_MIN_IR_CODE) {
+                als_comperator = reading * STK_IRC_ALS_NUMERA / STK_IRC_ALS_DENOMI;
+                if(ps_data->ir_code > als_comperator)
+                        ps_data->als_correct_factor = STK_IRC_ALS_CORREC;
+                else
+                        ps_data->als_correct_factor = 1000;
+            }
+            // PRINT_WARN( "%s: als=%d, ir=%d, als_correct_factor=%d", __func__, reading, ps_data->ir_code, ps_data->als_correct_factor);
+            ps_data->ir_code = 0;
+        }
+        reading = reading * ps_data->als_correct_factor / 1000;
+
+        ps_data->als_lux_last = stk_alscode2lux(ps_data, reading);
+        input_report_abs(ps_data->ps_input_dev, ABS_MISC, ps_data->als_lux_last);
+        input_sync(ps_data->ps_input_dev);
+#ifdef STK_DEBUG_PRINTF
+        PRINT_WARN( "%s: als input event %d lux\n",__func__, ps_data->als_lux_last);
 #endif
-	{
-		return 0;
-	}	
 
-	ret = stk3x1x_get_flag(ps_data);
-	if(ret < 0)
-		return ret;
-	if(!(ret&STK_FLG_PSDR_MASK))
-	{
-		//printk(KERN_INFO "%s: ps data is not ready yet\n", __func__);
-		return 0;
-	}
-	
-	ret = stk_ps_val(ps_data);	
-	if(ret == 0)
-	{				
-		ret = stk3x1x_i2c_read_data(ps_data->client, 0x11, 2, &value[0]);
-		if(ret < 0)
-		{
-			printk(KERN_ERR "%s fail, ret=0x%x", __func__, ret);
-			return ret;
-		}
-		word_data = (value[0]<<8) | value[1];						
-		//printk(KERN_INFO "%s: word_data=%d\n", __func__, word_data);
-		
-		if(word_data == 0)
-		{
-			//printk(KERN_ERR "%s: incorrect word data (0)\n", __func__);
-			return 0xFFFF;
-		}
-		
-		if(word_data > ps_data->psa)
-		{
-			ps_data->psa = word_data;
-			printk(KERN_INFO "%s: update psa: psa=%d,psi=%d\n", __func__, ps_data->psa, ps_data->psi);
-		}
-		if(word_data < ps_data->psi)
-		{
-			ps_data->psi = word_data;	
-			printk(KERN_INFO "%s: update psi: psa=%d,psi=%d\n", __func__, ps_data->psa, ps_data->psi);	
-		}	
-	}	
-	diff = ps_data->psa - ps_data->psi;
-	if(diff > ps_data->stk_max_min_diff)
-	{
-		ps_data->psi_set = ps_data->psi;
-		ps_data->ps_thd_h = ps_data->psi + ps_data->stk_ht_n_ct;
-		ps_data->ps_thd_l = ps_data->psi + ps_data->stk_lt_n_ct;
-		
-		
-#ifdef CALI_PS_EVERY_TIME
-		if(ps_data->ps_thd_h > ps_data->ps_high_thd_boot)
-		{
-			ps_data->ps_high_thd_boot = ps_data->ps_thd_h;
-			ps_data->ps_low_thd_boot = ps_data->ps_thd_l;
-			printk(KERN_INFO "%s: update boot HT=%d, LT=%d\n", __func__, ps_data->ps_high_thd_boot, ps_data->ps_low_thd_boot);
-		}
-#endif		
-		
-		stk3x1x_set_ps_thd_h(ps_data, ps_data->ps_thd_h);
-		stk3x1x_set_ps_thd_l(ps_data, ps_data->ps_thd_l);
-#ifdef STK_DEBUG_PRINTF				
-		printk(KERN_INFO "%s: FAE tune0 psa-psi(%d) > STK_DIFF found\n", __func__, diff);
-#endif					
-		hrtimer_cancel(&ps_data->ps_tune0_timer);
-	}
-	
-	return 0;
-}
+    }//if (org_flag_reg & STK_FLG_ALSINT_MASK) 
 
-static void stk_ps_tune0_work_func(struct work_struct *work)
-{
-	struct stk3x1x_data *ps_data = container_of(work, struct stk3x1x_data, stk_ps_tune0_work);		
-	if(ps_data->tune_zero_init_proc)
-		stk_tune_zero_get_ps_data(ps_data);
-	else
-		stk_ps_tune_zero_func_fae(ps_data);
-	return;
-}	
+    if (org_flag_reg & STK_FLG_PSINT_MASK) {
+        disable_flag |= STK_FLG_PSINT_MASK;
+        near_far_state = (org_flag_reg & STK_FLG_NF_MASK)?1:0;
 
-
-static enum hrtimer_restart stk_ps_tune0_timer_func(struct hrtimer *timer)
-{
-	struct stk3x1x_data *ps_data = container_of(timer, struct stk3x1x_data, ps_tune0_timer);
-	queue_work(ps_data->stk_ps_tune0_wq, &ps_data->stk_ps_tune0_work);	
-	hrtimer_forward_now(&ps_data->ps_tune0_timer, ps_data->ps_tune0_delay);
-	return HRTIMER_RESTART;	
-}
+        ps_data->ps_distance_last = near_far_state;
+        input_report_abs(ps_data->ps_input_dev, ABS_DISTANCE, near_far_state);
+        input_sync(ps_data->ps_input_dev);
+        wake_lock_timeout(&ps_data->ps_wakelock, 3*HZ);
+        reading = stk3x1x_get_ps_reading(ps_data);
+#ifdef STK_DEBUG_PRINTF
+        PRINT_WARN( "%s: ps input event=%d, ps code = %d\n",__func__, near_far_state, reading);
 #endif
+    }//if (org_flag_reg & STK_FLG_PSINT_MASK)
 
-#ifdef STK_POLL_ALS
-static enum hrtimer_restart stk_als_timer_func(struct hrtimer *timer)
-{
-	struct stk3x1x_data *ps_data = container_of(timer, struct stk3x1x_data, als_timer);
-	queue_work(ps_data->stk_als_wq, &ps_data->stk_als_work);	
-	hrtimer_forward_now(&ps_data->als_timer, ps_data->als_poll_delay);
-	return HRTIMER_RESTART;	
-	
-}
+    if(disable_flag) {
+        ret = stk3x1x_set_flag(ps_data, org_flag_reg, disable_flag);
+        if(ret < 0)
+            goto err_i2c_rw;
+    }
+#endif //#if ((STK_INT_PS_MODE == 0x03) || (STK_INT_PS_MODE      == 0x02)) 
+    usleep_range(1000, 2000);
+    //msleep(1);
+    enable_irq(ps_data->irq);
+    return;
 
-static void stk_als_poll_work_func(struct work_struct *work)
-{
-	struct stk3x1x_data *ps_data = container_of(work, struct stk3x1x_data, stk_als_work);	
-	int32_t reading, reading_lux, als_comperator, flag_reg;
-	#ifdef STK_IRS	
-	int ret;
-	#endif
-#ifdef STK_GES			
-	if(ps_data->ges_enabled)
-	{
-		input_report_abs(ps_data->als_input_dev, ABS_MISC, ps_data->als_lux_last);
-		input_sync(ps_data->als_input_dev);
-#ifdef STK_DEBUG_PRINTF				
-		printk(KERN_INFO "%s: ges_enabled=1, als input event %d lux\n",__func__, ps_data->als_lux_last);		
-#endif
-	}
-#endif
-	
-	flag_reg = stk3x1x_get_flag(ps_data);
-	if(flag_reg < 0)
-		return;		
-	
-	#ifdef STK_IRS
-	if(ps_data->als_data_index < 60000)
-		ps_data->als_data_index++;
-	else
-		ps_data->als_data_index = 0;
-		
-	if(	ps_data->als_data_index % 10 == 0)
-	{
-		if(ps_data->ps_distance_last != 0)
-		{		
-			ret = stk3x1x_get_ir_reading(ps_data);
-			if(ret > 0)
-				ps_data->ir_code = ret;
-		}		
-		return;
-	}
-	#endif
-	
-	if(!(flag_reg&STK_FLG_ALSDR_MASK))
-	{
-		//printk(KERN_INFO "%s: als is not ready\n", __func__);
-		return;
-	}
-	
-	reading = stk3x1x_get_als_reading(ps_data);
-	if(reading < 0)		
-	{
-		return;
-	}
-	
-	if(ps_data->ir_code)
-	{
-		ps_data->als_correct_factor = 1000;
-		if(reading < STK_IRC_MAX_ALS_CODE && reading > STK_IRC_MIN_ALS_CODE && 
-			ps_data->ir_code > STK_IRC_MIN_IR_CODE)
-		{
-			als_comperator = reading * STK_IRC_ALS_NUMERA / STK_IRC_ALS_DENOMI;
-			if(ps_data->ir_code > als_comperator)
-				ps_data->als_correct_factor = STK_IRC_ALS_CORREC;
-		}
-#ifdef STK_DEBUG_PRINTF				
-		printk(KERN_INFO "%s: als=%d, ir=%d, als_correct_factor=%d", __func__, 
-						reading, ps_data->ir_code, ps_data->als_correct_factor);
-#endif		
-		ps_data->ir_code = 0;
-	}	
-	reading = reading * ps_data->als_correct_factor / 1000;
-	
-	reading_lux = stk_alscode2lux(ps_data, reading);
-	if(abs(ps_data->als_lux_last - reading_lux) >= STK_ALS_CHANGE_THD)
-	{
-		ps_data->als_lux_last = reading_lux;
-		input_report_abs(ps_data->als_input_dev, ABS_MISC, reading_lux);
-		input_sync(ps_data->als_input_dev);
-#ifdef STK_DEBUG_PRINTF				
-		printk(KERN_INFO "%s: als input event %d lux\n",__func__, reading_lux);		
-#endif		
-	}
-	return;
+    err_i2c_rw:
+    msleep(30);
+    enable_irq(ps_data->irq);
+    return;
 }
-#endif /* #ifdef STK_POLL_ALS */
 
-
-#ifdef STK_POLL_PS	
-static enum hrtimer_restart stk_ps_timer_func(struct hrtimer *timer)
+static irqreturn_t stk_oss_irq_handler(int irq, void *data)
 {
-	struct stk3x1x_data *ps_data = container_of(timer, struct stk3x1x_data, ps_timer);
-	queue_work(ps_data->stk_ps_wq, &ps_data->stk_ps_work);
-	hrtimer_forward_now(&ps_data->ps_timer, ps_data->ps_poll_delay);
-	return HRTIMER_RESTART;		
+    struct stk3x1x_data *pData = data;
+    disable_irq_nosync(irq);
+    //printk("%s   %d\n",__func__,__LINE__);
+    printk("%s \n",__func__);
+    queue_work(pData->stk_wq,&pData->stk_work);
+    return IRQ_HANDLED;
 }
 
-static void stk_ps_poll_work_func(struct work_struct *work)
+static void stk3x1x_als_set_poll_delay(struct stk3x1x_data *ps_data)
 {
-	struct stk3x1x_data *ps_data = container_of(work, struct stk3x1x_data, stk_ps_work);	
-	uint32_t reading;
-	int32_t near_far_state;
-    uint8_t org_flag_reg;	
-#ifdef STK_GES			
-	int32_t ret;
-    //uint8_t disable_flag = 0;
-	uint8_t disable_flag2 = 0, org_flag2_reg;
-	if(ps_data->ges_enabled == 2)
-	{
-		ret = stk3x1x_get_flag2(ps_data);
-		if(ret < 0)
-			goto err_i2c_rw;	
-		org_flag2_reg = ret;
-		
-		disable_flag2 = org_flag2_reg & (STK_FLG2_INT_GS_MASK | 
-			STK_FLG2_GS10_MASK | STK_FLG2_GS01_MASK);
-		if(org_flag2_reg & STK_FLG2_GS10_MASK)
-		{
-			printk(KERN_INFO "%s: >>>>>>>>>>>>\n", __func__);
-		}
-		if(org_flag2_reg & STK_FLG2_GS01_MASK)
-		{
-			printk(KERN_INFO "%s: <<<<<<<<<<<<\n", __func__);
-		}
-		atomic_set(&ps_data->gesture2, (disable_flag2 & 
-				(STK_FLG2_GS10_MASK | STK_FLG2_GS01_MASK)));  		
+    uint8_t als_it = ps_data->alsctrl_reg & 0x0F;
 
-		if(disable_flag2)
-		{
-			ret = stk3x1x_set_flag2(ps_data, org_flag2_reg, disable_flag2);		
-			if(ret < 0)
-				goto err_i2c_rw;
-		}			
-	}	
-#endif
-	
-	if(ps_data->ps_enabled)
-	{
-#ifdef STK_TUNE0
-		// if(!(ps_data->psi_set))
-			// return;	
-#endif	
-		org_flag_reg = stk3x1x_get_flag(ps_data);
-		if(org_flag_reg < 0)
-			goto err_i2c_rw;		
-
-		if(!(org_flag_reg&STK_FLG_PSDR_MASK))
-		{
-			//printk(KERN_INFO "%s: ps is not ready\n", __func__);
-			return;
-		}	
-				
-		near_far_state = (org_flag_reg & STK_FLG_NF_MASK)?1:0;	
-		reading = stk3x1x_get_ps_reading(ps_data);
-		if(ps_data->ps_distance_last != near_far_state)
-		{
-			ps_data->ps_distance_last = near_far_state;
-			input_report_abs(ps_data->ps_input_dev, ABS_DISTANCE, near_far_state);
-			input_sync(ps_data->ps_input_dev);
-			wake_lock_timeout(&ps_data->ps_wakelock, 3*HZ);		
-#ifdef STK_DEBUG_PRINTF		
-			printk(KERN_INFO "%s: ps input event %d cm, ps code = %d\n",__func__, near_far_state, reading);		
-#endif		
-		}
-		// ret = stk3x1x_set_flag(ps_data, org_flag_reg, disable_flag);		
-		// if(ret < 0)
-			// goto err_i2c_rw;
-		return;
-	}
-	
-err_i2c_rw:
-	msleep(30);	
-	return;
+    if(als_it == 0x8) {
+        ps_data->als_poll_delay = ns_to_ktime(60 * NSEC_PER_MSEC);
+    }
+    else if(als_it == 0x9) {
+        ps_data->als_poll_delay = ns_to_ktime(110 * NSEC_PER_MSEC);
+    }
+    else if(als_it == 0xA) {
+        ps_data->als_poll_delay = ns_to_ktime(220 * NSEC_PER_MSEC);
+    }
+    else if(als_it == 0xB) {
+        ps_data->als_poll_delay = ns_to_ktime(440 * NSEC_PER_MSEC);
+    }
+    else if(als_it == 0xC) {
+        ps_data->als_poll_delay = ns_to_ktime(880 * NSEC_PER_MSEC);
+    }
+    else {
+        ps_data->als_poll_delay = ns_to_ktime(110 * NSEC_PER_MSEC);
+        PRINT_WARN( "%s: unknown ALS_IT=%d, set als_poll_delay=110ms\n", __func__, als_it);
+    }
 }
-#endif
 
-#if (!defined(STK_POLL_PS) || !defined(STK_POLL_ALS))
-static void stk_work_func(struct work_struct *work)
+static int32_t stk3x1x_init_all_setting(struct i2c_client *client, struct stk3x1x_platform_data *plat_data)
 {
-	uint32_t reading;
-#if ((STK_INT_PS_MODE != 0x03) && (STK_INT_PS_MODE != 0x02))
     int32_t ret;
-    uint8_t disable_flag = 0;
-    uint8_t org_flag_reg;
-#endif	/* #if ((STK_INT_PS_MODE != 0x03) && (STK_INT_PS_MODE != 0x02)) */
+    struct stk3x1x_data *ps_data = i2c_get_clientdata(client);
 
-#ifndef CONFIG_STK_PS_ALS_USE_CHANGE_THRESHOLD	
-	uint32_t nLuxIndex;	
-#endif
-	struct stk3x1x_data *ps_data = container_of(work, struct stk3x1x_data, stk_work);	
-	int32_t near_far_state;
-	int32_t als_comperator;
-#ifdef STK_GES				
-	uint8_t disable_flag2 = 0, org_flag2_reg;
-#endif	
-	
-#if (STK_INT_PS_MODE	== 0x03)
-	near_far_state = gpio_get_value(ps_data->int_pin);
-#elif	(STK_INT_PS_MODE	== 0x02)
-	near_far_state = !(gpio_get_value(ps_data->int_pin));
-#endif	
+    ret = stk3x1x_software_reset(ps_data);
+    if(ret < 0)
+        return ret;
 
-#if ((STK_INT_PS_MODE == 0x03) || (STK_INT_PS_MODE	== 0x02))
-	ps_data->ps_distance_last = near_far_state;
-	input_report_abs(ps_data->ps_input_dev, ABS_DISTANCE, near_far_state);
-	input_sync(ps_data->ps_input_dev);
-	wake_lock_timeout(&ps_data->ps_wakelock, 3*HZ);
-	reading = stk3x1x_get_ps_reading(ps_data);
-#ifdef STK_DEBUG_PRINTF	
-	printk(KERN_INFO "%s: ps input event %d cm, ps code = %d\n",__func__, near_far_state, reading);			
-#endif	
-#else
-	/* mode 0x01 or 0x04 */	
-	org_flag_reg = stk3x1x_get_flag(ps_data);
-	if(org_flag_reg < 0)
-		goto err_i2c_rw;	
-	
-    if (org_flag_reg & STK_FLG_ALSINT_MASK)
-    {
-		disable_flag |= STK_FLG_ALSINT_MASK;
-        reading = stk3x1x_get_als_reading(ps_data);
-		if(reading < 0)		
-		{
-			printk(KERN_ERR "%s: stk3x1x_get_als_reading fail, ret=%d", __func__, reading);
-			goto err_i2c_rw;
-		}			
-#ifndef CONFIG_STK_PS_ALS_USE_CHANGE_THRESHOLD
-        nLuxIndex = stk_get_lux_interval_index(reading);
-        stk3x1x_set_als_thd_h(ps_data, code_threshold_table[nLuxIndex]);
-        stk3x1x_set_als_thd_l(ps_data, code_threshold_table[nLuxIndex-1]);
-#else
-        stk_als_set_new_thd(ps_data, reading);
-#endif //CONFIG_STK_PS_ALS_USE_CHANGE_THRESHOLD
+    ret = stk3x1x_check_pid(ps_data);
+    if(ret < 0)
+        return ret;
+    stk3x1x_proc_plat_data(ps_data, plat_data);
+    ret = stk3x1x_init_all_reg(ps_data);
+    if(ret < 0)
+        return ret;
 
-		if(ps_data->ir_code)
-		{
-			if(reading < STK_IRC_MAX_ALS_CODE && reading > STK_IRC_MIN_ALS_CODE && 
-			ps_data->ir_code > STK_IRC_MIN_IR_CODE)
-			{
-				als_comperator = reading * STK_IRC_ALS_NUMERA / STK_IRC_ALS_DENOMI;
-				if(ps_data->ir_code > als_comperator)
-					ps_data->als_correct_factor = STK_IRC_ALS_CORREC;
-				else
-					ps_data->als_correct_factor = 1000;
-			}
-			printk(KERN_INFO "%s: als=%d, ir=%d, als_correct_factor=%d", __func__, reading, ps_data->ir_code, ps_data->als_correct_factor);
-			ps_data->ir_code = 0;
-		}	
-
-		reading = reading * ps_data->als_correct_factor / 1000;
-
-		ps_data->als_lux_last = stk_alscode2lux(ps_data, reading);
-		input_report_abs(ps_data->als_input_dev, ABS_MISC, ps_data->als_lux_last);
-		input_sync(ps_data->als_input_dev);
-#ifdef STK_DEBUG_PRINTF		
-		printk(KERN_INFO "%s: als input event %d lux\n",__func__, ps_data->als_lux_last);			
-#endif		
-    }
-    if (org_flag_reg & STK_FLG_PSINT_MASK)
-    {
-		disable_flag |= STK_FLG_PSINT_MASK;
-		near_far_state = (org_flag_reg & STK_FLG_NF_MASK)?1:0;
-		
-		ps_data->ps_distance_last = near_far_state;
-		input_report_abs(ps_data->ps_input_dev, ABS_DISTANCE, near_far_state);
-		input_sync(ps_data->ps_input_dev);
-		wake_lock_timeout(&ps_data->ps_wakelock, 3*HZ);			
-		reading = stk3x1x_get_ps_reading(ps_data);
-#ifdef STK_DEBUG_PRINTF		
-		printk(KERN_INFO "%s: ps input event=%d, ps code = %d\n",__func__, near_far_state, reading);
-#endif			
-	}
-	
-	if(disable_flag)	
-	{	
-		ret = stk3x1x_set_flag(ps_data, org_flag_reg, disable_flag);		
-		if(ret < 0)
-			goto err_i2c_rw;
-	}
-#endif	
-	usleep_range(1000, 2000);
-	//msleep(1);
-    enable_irq(ps_data->irq);
-	return;
-
-err_i2c_rw:
-	msleep(30);
-	enable_irq(ps_data->irq);
-	return;	
-}
-
-static irqreturn_t stk_oss_irq_handler(int irq, void *data)
-{
-	struct stk3x1x_data *pData = data;
-	disable_irq_nosync(irq);
-	queue_work(pData->stk_wq,&pData->stk_work);
-	return IRQ_HANDLED;
-}
-#endif	/*	#if (!defined(STK_POLL_PS) || !defined(STK_POLL_ALS))	*/
-static int32_t stk3x1x_init_all_setting(struct i2c_client *client, struct stk3x1x_platform_data *plat_data)
-{
-	int32_t ret;
-	struct stk3x1x_data *ps_data = i2c_get_clientdata(client);		
-	
-	stk3x1x_proc_plat_data(ps_data, plat_data);
-	ret = stk3x1x_software_reset(ps_data); 
-	if(ret < 0)
-		return ret;
-	
-	ret = stk3x1x_check_pid(ps_data);
-	if(ret < 0)
-		return ret;
-	ret = stk3x1x_init_all_reg(ps_data);
-	if(ret < 0)
-		return ret;	
-		
-	ps_data->als_enabled = false;
-	ps_data->ps_enabled = false;		
-	ps_data->re_enable_als = false;
-	ps_data->re_enable_ps = false;
-	ps_data->ir_code = 0;
-	ps_data->als_correct_factor = 1000;
-	ps_data->first_boot = true;	
+    stk3x1x_als_set_poll_delay(ps_data);
+    ps_data->als_enabled = false;
+    ps_data->ps_enabled = false;
+    ps_data->re_enable_als = false;
+    ps_data->re_enable_ps = false;
+    ps_data->ir_code = 0;
+    ps_data->als_correct_factor = 1000;
 #ifndef CONFIG_STK_PS_ALS_USE_CHANGE_THRESHOLD
-	stk_init_code_threshold_table(ps_data);
-#endif			
-#ifdef STK_TUNE0
-	#ifdef QUALCOMM_PLATFORM		
-	ps_data->tune_zero_init_proc = false;	
-	ps_data->psi_set = 0;		
-	#else
-	stk_ps_tune_zero_init(ps_data);
-	#endif	
-#endif	
+    stk_init_code_threshold_table(ps_data);
+#endif
 #ifdef STK_ALS_FIR
-	memset(&ps_data->fir, 0x00, sizeof(ps_data->fir));  
-	atomic_set(&ps_data->firlength, STK_FIR_LEN);	
+    memset(&ps_data->fir, 0x00, sizeof(ps_data->fir));
+    atomic_set(&ps_data->firlength, STK_FIR_LEN);
 #endif
-	atomic_set(&ps_data->recv_reg, 0);  
-#ifdef STK_GES	
-	ps_data->re_enable_ges = 0;	
-	atomic_set(&ps_data->gesture2, 0);  
-	//memset(stk_ges_op, 0, sizeof(stk_ges_op));
-#endif	
-#ifdef STK_IRS
-	ps_data->als_data_index = 0;
-#endif	
-	ps_data->ps_distance_last = 1;
+    atomic_set(&ps_data->recv_reg, 0);
+    ps_data->ps_distance_last = 1;
+    ps_data->als_code_last = 0;
     return 0;
 }
 
-#if (!defined(STK_POLL_PS) || !defined(STK_POLL_ALS))
 static int stk3x1x_setup_irq(struct i2c_client *client)
-{		
-	int irq, err = -EIO;
-	struct stk3x1x_data *ps_data = i2c_get_clientdata(client);
+{
+    int irq, err = -EIO;
+    struct stk3x1x_data *ps_data = i2c_get_clientdata(client);
 
-#ifdef SPREADTRUM_PLATFORM	
-	irq = sprd_alloc_gpio_irq(ps_data->int_pin);	
-#else	
-	irq = gpio_to_irq(ps_data->int_pin);
-#endif	
-#ifdef STK_DEBUG_PRINTF	
-	printk(KERN_INFO "%s: int pin #=%d, irq=%d\n",__func__, ps_data->int_pin, irq);	
-#endif	
-	if (irq <= 0)
-	{
-		printk(KERN_ERR "irq number is not specified, irq # = %d, int pin=%d\n",irq, ps_data->int_pin);
-		return irq;
-	}
-	ps_data->irq = irq;	
-	err = gpio_request(ps_data->int_pin,"stk-int");        
-	if(err < 0)
-	{
-		printk(KERN_ERR "%s: gpio_request, err=%d", __func__, err);
-		return err;
-	}
-	err = gpio_direction_input(ps_data->int_pin);
-	if(err < 0)
-	{
-		printk(KERN_ERR "%s: gpio_direction_input, err=%d", __func__, err);
-		return err;
-	}		
-#if ((STK_INT_PS_MODE == 0x03) || (STK_INT_PS_MODE	== 0x02))	
-	err = request_any_context_irq(irq, stk_oss_irq_handler, IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING, DEVICE_NAME, ps_data);
-#else	
-	err = request_any_context_irq(irq, stk_oss_irq_handler, IRQF_TRIGGER_LOW | IRQF_NO_SUSPEND, DEVICE_NAME, ps_data);
-#endif	
-	if (err < 0) 
-	{
-		printk(KERN_WARNING "%s: request_any_context_irq(%d) failed for (%d)\n", __func__, irq, err);		
-		goto err_request_any_context_irq;
-	}
-	disable_irq(irq);
-	
-	return 0;
-err_request_any_context_irq:	
-#ifdef SPREADTRUM_PLATFORM
-	sprd_free_gpio_irq(ps_data->int_pin);	
-#else	
-	gpio_free(ps_data->int_pin);		
-#endif	
-	return err;
-}
+#ifdef STK_DEBUG_PRINTF
+    //    PRINT_WARN( "%s: int pin #=%d, irq=%d\n",__func__, ps_data->int_pin, irq);
 #endif
 
+    err = gpio_request(ps_data->int_pin,"stk-int");
+    if(err < 0) {
+        PRINT_ERR( "%s: gpio_request, err=%d", __func__, err);
+        return err;
+    }
 
-static int stk3x1x_suspend(struct device *dev)
-{
+    err = gpio_direction_input(ps_data->int_pin);
+    if(err < 0) {
+        PRINT_ERR( "%s: gpio_direction_input, err=%d", __func__, err);
+        return err;
+    }
 
-	return 0;
-	struct stk3x1x_data *ps_data = dev_get_drvdata(dev);
-#if (defined(STK_CHK_REG) || !defined(STK_POLL_PS))
-	int err;
+    irq = gpio_to_irq(ps_data->int_pin);
+    PRINT_WARN( "%s: int pin #=%d, irq=%d\n",__func__, ps_data->int_pin, irq);
+    if (irq <= 0) {
+    PRINT_ERR( "irq number is not specified, irq # = %d, int pin=%d\n",irq, ps_data->int_pin);
+    return irq;
+    }
+
+    ps_data->irq = irq;
+#if ((STK_INT_PS_MODE == 0x03) || (STK_INT_PS_MODE      == 0x02))
+    err = request_any_context_irq(irq, stk_oss_irq_handler, IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING, STK3X1X_DEV_NAME, ps_data);
+#else
+    err = request_any_context_irq(irq, stk_oss_irq_handler, IRQF_TRIGGER_FALLING|IRQF_NO_SUSPEND|IRQF_ONESHOT, STK3X1X_DEV_NAME, ps_data);
 #endif
-	
-#ifndef STK_POLL_PS	
-    struct i2c_client *client = to_i2c_client(dev);	
-#endif
+    if (err < 0) {
+        printk(KERN_WARNING "%s: request_any_context_irq(%d) failed for (%d)\n", __func__, irq, err);
+        goto err_request_any_context_irq;
+    }
+ //   enable_irq(irq);//xiexie
+    return 0;
 
-	printk(KERN_INFO "%s", __func__);	
-#ifndef SPREADTRUM_PLATFORM	
-	mutex_lock(&ps_data->io_lock);  	
-#endif	
-#ifdef STK_CHK_REG
-	err = stk3x1x_validate_n_handle(ps_data->client);
-	if(err < 0)	
-	{
-		printk(KERN_ERR "stk3x1x_validate_n_handle fail: %d\n", err); 
-	}
-	else if (err == 0xFF)
-	{
-		if(ps_data->ps_enabled)
-			stk3x1x_enable_ps(ps_data, 1, 0);
-	}
-#endif /* #ifdef STK_CHK_REG */
-#ifdef STK_GES	
-	if(ps_data->ges_enabled == 1)
-	{
-		ps_data->re_enable_ges = ps_data->ges_enabled;		
-		stk3x1x_enable_ges(ps_data, 0, 1);		
-	}
-	else if(ps_data->ges_enabled == 2)
-	{
-		ps_data->re_enable_ges = ps_data->ges_enabled;	
-		stk3x1x_enable_ges(ps_data, 0, 2);
-	}
-#endif	
-#ifndef SPREADTRUM_PLATFORM	
-	if(ps_data->als_enabled)
-	{	
-		printk(KERN_INFO "%s: Enable ALS : 0\n", __func__);
-		stk3x1x_enable_als(ps_data, 0);		
-		ps_data->re_enable_als = true;
-	}  	
-#endif	
-	if(ps_data->ps_enabled)
-	{
-#ifdef STK_POLL_PS		
-		wake_lock(&ps_data->ps_nosuspend_wl);
-#else		
-		if(device_may_wakeup(&client->dev))
-		{
-			err = enable_irq_wake(ps_data->irq);	
-			if (err)
-				printk(KERN_WARNING "%s: set_irq_wake(%d) failed, err=(%d)\n", __func__, ps_data->irq, err);				
-		}
-		else
-		{
-			printk(KERN_ERR "%s: not support wakeup source", __func__);
-		}		
-#endif	
-	}
-#ifndef SPREADTRUM_PLATFORM		
-	mutex_unlock(&ps_data->io_lock);		
-#endif	
-	return 0;	
+    err_request_any_context_irq:
+    gpio_free(ps_data->int_pin);
+    return err;
 }
 
-static int stk3x1x_resume(struct device *dev)
+#ifdef CONFIG_OF
+static int stk3x1x_parse_dt(struct device *dev,
+                        struct stk3x1x_platform_data *pdata)
 {
-	return 0;
-	struct stk3x1x_data *ps_data = dev_get_drvdata(dev);	
-#if (defined(STK_CHK_REG) || !defined(STK_POLL_PS))	
-	int err;
-#endif
-	
-#ifndef STK_POLL_PS	    
-    struct i2c_client *client = to_i2c_client(dev);	
-#endif
-	
-	printk(KERN_INFO "%s", __func__);	
-#ifndef SPREADTRUM_PLATFORM		
-	mutex_lock(&ps_data->io_lock); 		
-#endif	
-#ifdef STK_CHK_REG
-	err = stk3x1x_validate_n_handle(ps_data->client);
-	if(err < 0)	
-	{
-		printk(KERN_ERR "stk3x1x_validate_n_handle fail: %d\n", err); 
-	}
-	else if (err == 0xFF)
-	{
-		if(ps_data->ps_enabled)
-			stk3x1x_enable_ps(ps_data, 1, 0);
-	}	
-#endif /* #ifdef STK_CHK_REG */
-#ifdef STK_GES	
-	if(ps_data->re_enable_ges == 1)
-	{
-		stk3x1x_enable_ges(ps_data, 1, 1);
-		ps_data->re_enable_ges = 0;		
-	}
-	else if(ps_data->re_enable_ges == 2)
-	{
-		stk3x1x_enable_ges(ps_data, 1, 2);		
-		ps_data->re_enable_ges = 0;				
-	}
-#endif	
-#ifndef SPREADTRUM_PLATFORM		
-	if(ps_data->re_enable_als)
-	{
-		printk(KERN_INFO "%s: Enable ALS : 1\n", __func__);		
-		stk3x1x_enable_als(ps_data, 1);		
-		ps_data->re_enable_als = false;		
-	}
-#endif
-	if(ps_data->ps_enabled)
-	{
-#ifdef STK_POLL_PS		
-		wake_unlock(&ps_data->ps_nosuspend_wl);		
-#else		
-		if(device_may_wakeup(&client->dev))
-		{	
-			err = disable_irq_wake(ps_data->irq);	
-			if (err)		
-				printk(KERN_WARNING "%s: disable_irq_wake(%d) failed, err=(%d)\n", __func__, ps_data->irq, err);		
-		}		
-#endif	
-	}
-#ifndef SPREADTRUM_PLATFORM			
-	mutex_unlock(&ps_data->io_lock);
-#endif	
-	return 0;	
+        return 0;
 }
-
-static const struct dev_pm_ops stk3x1x_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(stk3x1x_suspend, stk3x1x_resume)
-};
-
-//#ifdef CONFIG_HAS_EARLYSUSPEND
-#if 0
-static void stk3x1x_early_suspend(struct early_suspend *h)
+#else
+static int stk3x1x_parse_dt(struct device *dev,
+                        struct stk3x1x_platform_data *pdata)
 {
-	
+        return -ENODEV;
 }
+#endif /* !CONFIG_OF */
 
-static void stk3x1x_late_resume(struct early_suspend *h)
+static int stk3x1x_set_wq(struct stk3x1x_data *ps_data)
 {
+    ps_data->stk_als_wq = create_singlethread_workqueue("stk_als_wq");
+    INIT_WORK(&ps_data->stk_als_work, stk_als_poll_work_func);
+    hrtimer_init(&ps_data->als_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
 
+    ps_data->als_poll_delay = ns_to_ktime(110 * NSEC_PER_MSEC);
+    ps_data->als_timer.function = stk_als_timer_func;
+
+    ps_data->stk_wq = create_singlethread_workqueue("stk_wq");
+    INIT_WORK(&ps_data->stk_work, stk_irq_work_func);
+    return 0;
 }
-#endif	//#ifdef CONFIG_HAS_EARLYSUSPEND
 
 
-#ifdef STK_QUALCOMM_POWER_CTRL
-static int stk3x1x_power_ctl(struct stk3x1x_data *data, bool on)
+static int stk3x1x_set_input_devices(struct stk3x1x_data *ps_data)
 {
-	int ret = 0;
+    int err;
+    ps_data->ps_input_dev = input_allocate_device();
+    if (ps_data->ps_input_dev==NULL) {
+        PRINT_ERR( "%s: could not allocate als device\n", __func__);
+        err = -ENOMEM;
+        return err;
+    }
 
-	if (!on && data->power_enabled) {
-		ret = regulator_disable(data->vdd);
-		if (ret) {
-			dev_err(&data->client->dev,
-				"Regulator vdd disable failed ret=%d\n", ret);
-			return ret;
-		}
+    ps_data->ps_input_dev->name = STK3X1X_INPUT_DEV;
+    set_bit(EV_ABS, ps_data->ps_input_dev->evbit);
+    input_set_abs_params(ps_data->ps_input_dev, ABS_MISC, 0, stk_alscode2lux(ps_data, (1<<16)-1), 0, 0);
+    input_set_abs_params(ps_data->ps_input_dev, ABS_DISTANCE, 0,1, 0, 0);
 
-		ret = regulator_disable(data->vio);
-		if (ret) {
-			dev_err(&data->client->dev,
-				"Regulator vio disable failed ret=%d\n", ret);
-			ret = regulator_enable(data->vdd);
-			if (ret) {
-				dev_err(&data->client->dev,
-					"Regulator vdd enable failed ret=%d\n",
-					ret);
-			}			
-			return ret;
-		}
-		data->power_enabled = on;
-		printk(KERN_INFO "%s: disable stk3x1x power", __func__);
-		dev_dbg(&data->client->dev, "stk3x1x_power_ctl on=%d\n",
-				on);
-	} else if (on && !data->power_enabled) {
-		ret = regulator_enable(data->vdd);
-		if (ret) {
-			dev_err(&data->client->dev,
-				"Regulator vdd enable failed ret=%d\n", ret);
-			return ret;
-		}
+    err = input_register_device(ps_data->ps_input_dev);
+    if (err<0) {
+        PRINT_ERR( "%s: can not register ps input device\n", __func__);
+        return err;
+    }
 
-		ret = regulator_enable(data->vio);
-		if (ret) {
-			dev_err(&data->client->dev,
-				"Regulator vio enable failed ret=%d\n", ret);
-			regulator_disable(data->vdd);
-			return ret;
-		}
-		data->power_enabled = on;
-		printk(KERN_INFO "%s: enable stk3x1x power", __func__);
-		dev_dbg(&data->client->dev, "stk3x1x_power_ctl on=%d\n",
-				on);
-	} else {
-		dev_warn(&data->client->dev,
-				"Power on=%d. enabled=%d\n",
-				on, data->power_enabled);
-	}
+    input_set_drvdata(ps_data->ps_input_dev, ps_data);
+    input_report_abs(ps_data->ps_input_dev, ABS_DISTANCE, 1); //report far
+    input_sync(ps_data->ps_input_dev);
 
-	return ret;
+    return 0;
 }
 
-static int stk3x1x_power_init(struct stk3x1x_data *data, bool on)
+static int stk3x1x_open(struct inode *inode, struct file *file)
 {
-	int ret;
+    PRINT_WARN( "stk3x1x_open\n");
+    return 0;
+}
 
-	if (!on) {
-		if (regulator_count_voltages(data->vdd) > 0)
-			regulator_set_voltage(data->vdd,
-					0, STK3X1X_VDD_MAX_UV);
+static int stk3x1x_release(struct inode *inode, struct file *file)
+{
+    PRINT_WARN( "stk3x1x_release\n");
+    return 0;
+}
 
-		regulator_put(data->vdd);
+static int stk3x1x_read_chip_info(struct i2c_client *client, char *buf)
+{
+        if(NULL == buf) {
+                return -1;
+        }
+        if(NULL == client) {
+                *buf = 0;
+                return -2;
+        }
 
-		if (regulator_count_voltages(data->vio) > 0)
-			regulator_set_voltage(data->vio,
-					0, STK3X1X_VIO_MAX_UV);
+	sprintf(buf, "STK3X1X");
+       printk("[stk3x1x] stk3x1x_read_chip_info %s\n",buf);
+        return 0;
+}
 
-		regulator_put(data->vio);
-	} else {
-		data->vdd = regulator_get(&data->client->dev, "vdd");
-		if (IS_ERR(data->vdd)) {
-			ret = PTR_ERR(data->vdd);
-			dev_err(&data->client->dev,
-				"Regulator get failed vdd ret=%d\n", ret);
-			return ret;
-		}
+static long stk3x1x_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+    void __user *argp = (void __user *)arg;
+    int flag, err;
+    char strbuf[256];
+    struct stk3x1x_data *ps_data =  i2c_get_clientdata(this_client);
 
-		if (regulator_count_voltages(data->vdd) > 0) {
-			ret = regulator_set_voltage(data->vdd,
-					STK3X1X_VDD_MIN_UV,
-					STK3X1X_VDD_MAX_UV);
-			if (ret) {
-				dev_err(&data->client->dev,
-					"Regulator set failed vdd ret=%d\n",
-					ret);
-				goto reg_vdd_put;
-			}
-		}
+    printk("stk3x1x_ioctl cmd = %d, %d\n", _IOC_NR(cmd), cmd);
+    switch (cmd) {
+    case STK_IOCTL_SET_PFLAG: //enable/disable ps
+        {
+            if (copy_from_user(&flag, argp, sizeof(flag)))
+                return -EFAULT;
 
-		data->vio = regulator_get(&data->client->dev, "vio");
-		if (IS_ERR(data->vio)) {
-			ret = PTR_ERR(data->vio);
-			dev_err(&data->client->dev,
-				"Regulator get failed vio ret=%d\n", ret);
-			goto reg_vdd_set;
-		}
+            PRINT_WARN( "LTR_IOCTL_SET_PFLAG = %d\n", flag);
 
-		if (regulator_count_voltages(data->vio) > 0) {
-			ret = regulator_set_voltage(data->vio,
-					STK3X1X_VIO_MIN_UV,
-					STK3X1X_VIO_MAX_UV);
-			if (ret) {
-				dev_err(&data->client->dev,
-				"Regulator set failed vio ret=%d\n", ret);
-				goto reg_vio_put;
-			}
-		}
-	}
+            if (1 == flag) {
+                msleep(20);
+                if (stk3x1x_enable_ps(ps_data, 1))
+                return -EIO;
 
-	return 0;
+            }
+            else if (0 == flag) {
+                if (stk3x1x_enable_ps(ps_data, 0))
+                return -EIO;
+            }
+            else {
+                return -EINVAL;
+            }
+        }
+    break;
+    case STK_IOCTL_SET_LFLAG:// enable/disable als
+        {
+            if (copy_from_user(&flag, argp, sizeof(flag)))
+                return -EFAULT;
+            PRINT_WARN( "LTR_IOCTL_SET_LFLAG = %d\n", flag);
 
-reg_vio_put:
-	regulator_put(data->vio);
-reg_vdd_set:
-	if (regulator_count_voltages(data->vdd) > 0)
-		regulator_set_voltage(data->vdd, 0, STK3X1X_VDD_MAX_UV);
-reg_vdd_put:
-	regulator_put(data->vdd);
-	return ret;
+            if (1 == flag) {
+                if (stk3x1x_enable_als(ps_data, 1))
+                    return -EIO;
+            }
+            else if (0 == flag) {
+                if (stk3x1x_enable_als(ps_data, 0))
+                    return -EIO;
+            }
+            else {
+                return -EINVAL;
+            }
+        }
+    break;
+    case STK_IOCTL_GET_CHIPINFO:
+            err = stk3x1x_read_chip_info(this_client, strbuf);
+            if(err < 0)
+                    return -EFAULT;
+            if(copy_to_user(argp, strbuf, strlen(strbuf)+1))
+                    return -EFAULT;
+            break;
+    default:
+    PRINT_ERR( "unknown command: 0x%08X  (%d)\n", cmd, cmd);
+    break;
+    }
+    return 0;
 }
 
-static int stk3x1x_device_ctl(struct stk3x1x_data *ps_data, bool enable)
-{
-	int ret;
-	struct device *dev = &ps_data->client->dev;
+static struct file_operations stk3x1x_fops = {
+    .owner = THIS_MODULE,
+    .open = stk3x1x_open,
+    .release = stk3x1x_release,
+    .unlocked_ioctl = stk3x1x_ioctl,
+};
 
-	if (enable && !ps_data->power_enabled) {
-		ret = stk3x1x_power_ctl(ps_data, true);
-		if (ret) {
-			dev_err(dev, "Failed to enable device power\n");
-			goto err_exit;
-		}
-		ret = stk3x1x_init_all_setting(ps_data->client, ps_data->pdata);
-		if (ret < 0) {
-			stk3x1x_power_ctl(ps_data, false);
-			dev_err(dev, "Failed to re-init device setting\n");
-			goto err_exit;
-		}
-	} else if (!enable && ps_data->power_enabled) {
-	#ifdef STK_GES		
-		if (!ps_data->als_enabled && !ps_data->ps_enabled && !ps_data->ges_enabled) {
-	#else
-		if (!ps_data->als_enabled && !ps_data->ps_enabled) {
-	#endif
-			ret = stk3x1x_power_ctl(ps_data, false);
-			if (ret) {
-				dev_err(dev, "Failed to disable device power\n");
-				goto err_exit;
-			}
-		} else {
-			dev_dbg(dev, "device control: als_enabled=%d, ps_enabled=%d\n",
-				ps_data->als_enabled, ps_data->ps_enabled);
-		}
-	} else {
-		dev_dbg(dev, "device control: enable=%d, power_enabled=%d\n",
-			enable, ps_data->power_enabled);
-	}
-	return 0;
-
-err_exit:
-	return ret;
-}
-#endif	/* #ifdef STK_QUALCOMM_POWER_CTRL */
-
-#ifdef CONFIG_OF
-static int stk3x1x_parse_dt(struct device *dev,
-			struct stk3x1x_platform_data *pdata)
+static struct miscdevice stk3x1x_device = {
+    .minor = MISC_DYNAMIC_MINOR,
+    .name = STK3X1X_DEV_NAME,
+    .fops = &stk3x1x_fops,
+};
+#ifdef HQ_PSENSOR_CALIBRATION
+static int stk3x1x_psensor_calibrate(void)
 {
-	int rc;
-	struct device_node *np = dev->of_node;
-	u32 temp_val;
+    int i = 0;
+    int j = 0;
+    uint32_t data = 0;
+    unsigned long sum = 0;
+    struct stk3x1x_data *ps_data =  i2c_get_clientdata(this_client);
 
-	pdata->int_pin = of_get_named_gpio_flags(np, "stk,irq-gpio",
-				0, &pdata->int_flags);
-	if (pdata->int_pin < 0) {
-		dev_err(dev, "Unable to read irq-gpio\n");
-		return pdata->int_pin;
-	}
+    if (!ps_data)
+        goto err;
+    for (i = 0; i < 5; i++) {
+        msleep(30);
+        data = stk3x1x_get_ps_reading(ps_data);
+        if(data != 0) {
+            j++;
+        }
+        sum += data;
+    }
 
-	rc = of_property_read_u32(np, "stk,transmittance", &temp_val);
-	if (!rc)
-		pdata->transmittance = temp_val;
-	else {
-		dev_err(dev, "Unable to read transmittance\n");
-		return rc;
-	}
+    if(j>0)
+        sum = sum/j;
+    else
+        sum = 0;
 
-	rc = of_property_read_u32(np, "stk,state-reg", &temp_val);
-	if (!rc)
-		pdata->state_reg = temp_val;
-	else {
-		dev_err(dev, "Unable to read state-reg\n");
-		return rc;
-	}
+    if(sum < MAX_PS_NOISE) {
+        if(ps_data->init_noise == 0)
+           ps_data->init_noise = sum;
 
-	rc = of_property_read_u32(np, "stk,psctrl-reg", &temp_val);
-	if (!rc)
-		pdata->psctrl_reg = (u8)temp_val;
-	else {
-		dev_err(dev, "Unable to read psctrl-reg\n");
-		return rc;
-	}
+        ps_data->current_xtalk = sum;
+    }else{
+        ps_data->current_xtalk = ps_data->init_noise;
+    }
 
-	rc = of_property_read_u32(np, "stk,alsctrl-reg", &temp_val);
-	if (!rc)
-		pdata->alsctrl_reg = (u8)temp_val;
-	else {
-		dev_err(dev, "Unable to read alsctrl-reg\n");
-		return rc;
-	}
+    ps_data->ps_thd_h = stk3x1x_pfdata.ps_thd_h + ps_data->current_xtalk;
+    ps_data->ps_thd_l = stk3x1x_pfdata.ps_thd_l + ps_data->current_xtalk;
 
-	rc = of_property_read_u32(np, "stk,ledctrl-reg", &temp_val);
-	if (!rc)
-		pdata->ledctrl_reg = (u8)temp_val;
-	else {
-		dev_err(dev, "Unable to read ledctrl-reg\n");
-		return rc;
-	}
+    printk("zqq calibrate:noise=%ld,low=%d ,high=%d\n",\
+        sum,ps_data->ps_thd_l,ps_data->ps_thd_h);
 
-	rc = of_property_read_u32(np, "stk,wait-reg", &temp_val);
-	if (!rc)
-		pdata->wait_reg = (u8)temp_val;
-	else {
-		dev_err(dev, "Unable to read wait-reg\n");
-		return rc;
-	}
+    stk3x1x_set_ps_thd_h(ps_data, ps_data->ps_thd_h);
+    stk3x1x_set_ps_thd_l(ps_data, ps_data->ps_thd_l);
 
-	rc = of_property_read_u32(np, "stk,ps-thdh", &temp_val);
-	if (!rc)
-		pdata->ps_thd_h = (u16)temp_val;
-	else {
-		dev_err(dev, "Unable to read ps-thdh\n");
-		return rc;
-	}
+    return 0;
+    err:
+    printk("zqq stk3x1x_psensor_calibrate fail!!!\n");
+    return -1;
+}
 
-	rc = of_property_read_u32(np, "stk,ps-thdl", &temp_val);
-	if (!rc)
-		pdata->ps_thd_l = (u16)temp_val;
-	else {
-		dev_err(dev, "Unable to read ps-thdl\n");
-		return rc;
-	}
+static int stk3x1x_get_init_noise(void)
+{
+    int i = 0;
+    int j = 0;
+    u8 rev = 0;
+    uint8_t w_state_reg;
+    uint32_t data = 0;
+    unsigned long sum = 0;
+    struct stk3x1x_data *ps_data =  i2c_get_clientdata(this_client);
 
-	//pdata->use_fir = of_property_read_bool(np, "stk,use-fir");
+    if (!ps_data)
+        return -1;
 
-	return 0;
-}
-#else
-static int stk3x1x_parse_dt(struct device *dev,
-			struct stk3x1x_platform_data *pdata)
-{
-	return -ENODEV;
-}
-#endif /* !CONFIG_OF */
+    disable_irq_nosync(ps_data->irq);
+    //enable
+    rev = stk3x1x_get_state(ps_data);
+    if(rev < 0)
+            return rev;
+    w_state_reg = rev;
+    w_state_reg &= ~(STK_STATE_EN_PS_MASK | STK_STATE_EN_WAIT_MASK | STK_STATE_EN_AK_MASK);
+    w_state_reg |= STK_STATE_EN_PS_MASK;
+    rev = stk3x1x_set_state(ps_data, w_state_reg);
+    if(rev < 0)
+        goto err;
 
-static int stk3x1x_set_wq(struct stk3x1x_data *ps_data)
-{
-#ifdef STK_POLL_ALS	
-	ps_data->stk_als_wq = create_singlethread_workqueue("stk_als_wq");
-	INIT_WORK(&ps_data->stk_als_work, stk_als_poll_work_func);
-	hrtimer_init(&ps_data->als_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	ps_data->als_poll_delay = ns_to_ktime(110 * NSEC_PER_MSEC);
-	ps_data->als_timer.function = stk_als_timer_func;
-#endif	
+    for (i = 0; i < 5; i++) {
+        msleep(30);
+        data = stk3x1x_get_ps_reading(ps_data);
+        if(data != 0) {
+            j++;
+        }
+        sum += data;
+    }
+    if(j>0)
+        sum = sum/j;
+    else
+        sum = 0;
+    if(sum < MAX_PS_NOISE) {
+        ps_data->init_noise = sum;
+    }
 
-#ifdef STK_POLL_PS	
-	ps_data->stk_ps_wq = create_singlethread_workqueue("stk_ps_wq");
-	INIT_WORK(&ps_data->stk_ps_work, stk_ps_poll_work_func);
-	hrtimer_init(&ps_data->ps_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	ps_data->ps_poll_delay = ns_to_ktime(60 * NSEC_PER_MSEC);
-	ps_data->ps_timer.function = stk_ps_timer_func;
-#endif	
+    //disable
+    rev = stk3x1x_get_state(ps_data);
+    if(rev < 0)
+        return rev;
+    w_state_reg = rev;
+    w_state_reg &= ~(STK_STATE_EN_PS_MASK | STK_STATE_EN_WAIT_MASK | STK_STATE_EN_AK_MASK);
+    rev = stk3x1x_set_state(ps_data, w_state_reg);
+    if(rev < 0)
+        goto err;
 
-#ifdef STK_TUNE0
-	ps_data->stk_ps_tune0_wq = create_singlethread_workqueue("stk_ps_tune0_wq");
-	INIT_WORK(&ps_data->stk_ps_tune0_work, stk_ps_tune0_work_func);
-	hrtimer_init(&ps_data->ps_tune0_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	ps_data->ps_tune0_delay = ns_to_ktime(60 * NSEC_PER_MSEC);
-	ps_data->ps_tune0_timer.function = stk_ps_tune0_timer_func;
-#endif
+    enable_irq(ps_data->irq);
+    printk("zqq init_noise %d\n",ps_data->init_noise);
 
-#if (!defined(STK_POLL_ALS) || !defined(STK_POLL_PS))
-	ps_data->stk_wq = create_singlethread_workqueue("stk_wq");
-	INIT_WORK(&ps_data->stk_work, stk_work_func);
+    return 0;
+    err:
+    printk("zqq stk3x1x_get_init_noise fail!!!\n");
+    enable_irq(ps_data->irq);
+    return -1;
+}
 #endif
-	return 0;
-}
 
 
-static int stk3x1x_set_input_devices(struct stk3x1x_data *ps_data)
-{
-	int err;
-	
-	ps_data->als_input_dev = input_allocate_device();
-	if (ps_data->als_input_dev==NULL)
-	{
-		printk(KERN_ERR "%s: could not allocate als device\n", __func__);
-		err = -ENOMEM;
-		return err;
-	}
-	ps_data->ps_input_dev = input_allocate_device();
-	if (ps_data->ps_input_dev==NULL)
-	{
-		printk(KERN_ERR "%s: could not allocate ps device\n", __func__);		
-		err = -ENOMEM;
-		return err;
-	}
-	ps_data->als_input_dev->name = ALS_NAME;
-	ps_data->ps_input_dev->name = PS_NAME;
-	set_bit(EV_ABS, ps_data->als_input_dev->evbit);
-	set_bit(EV_ABS, ps_data->ps_input_dev->evbit);
-	input_set_abs_params(ps_data->als_input_dev, ABS_MISC, 0, stk_alscode2lux(ps_data, (1<<16)-1), 0, 0);
-	input_set_abs_params(ps_data->ps_input_dev, ABS_DISTANCE, 0,1, 0, 0);
-	err = input_register_device(ps_data->als_input_dev);
-	if (err<0)
-	{
-		printk(KERN_ERR "%s: can not register als input device\n", __func__);		
-		return err;
-	}
-	err = input_register_device(ps_data->ps_input_dev);	
-	if (err<0)
-	{
-		printk(KERN_ERR "%s: can not register ps input device\n", __func__);	
-		return err;
-	}
-	
-	err = sysfs_create_group(&ps_data->als_input_dev->dev.kobj, &stk_als_attribute_group);
-	if (err < 0) 
-	{
-		printk(KERN_ERR "%s:could not create sysfs group for als\n", __func__);
-		return err;
-	}
-	err = sysfs_create_group(&ps_data->ps_input_dev->dev.kobj, &stk_ps_attribute_group);
-	if (err < 0) 
-	{
-		printk(KERN_ERR "%s:could not create sysfs group for ps\n", __func__);
-		return err;
-	}
-	input_set_drvdata(ps_data->als_input_dev, ps_data);
-	input_set_drvdata(ps_data->ps_input_dev, ps_data);		
-	
-#ifdef STK_GES
-	ps_data->ges_input_dev = input_allocate_device();
-	if (ps_data->ges_input_dev==NULL)
-	{
-		printk(KERN_ERR "%s: could not allocate ps device\n", __func__);		
-		err = -ENOMEM;
-		return err;		
-	}
-	ps_data->ges_input_dev->name = "stk_ges";
-	ps_data->ges_input_dev->evbit[0] = BIT_MASK(EV_KEY);
-	set_bit(KEY_PAGEUP, ps_data->ges_input_dev->keybit);
-	set_bit(KEY_PAGEDOWN, ps_data->ges_input_dev->keybit);
-	set_bit(KEY_VOLUMEUP, ps_data->ges_input_dev->keybit);
-	set_bit(KEY_VOLUMEDOWN, ps_data->ges_input_dev->keybit);
-	/*
-	set_bit(KEY_LEFT, ps_data->ges_input_dev->keybit);
-	set_bit(KEY_RIGHT, ps_data->ges_input_dev->keybit);
-	set_bit(KEY_UP, ps_data->ges_input_dev->keybit);
-	set_bit(KEY_DOWN, ps_data->ges_input_dev->keybit);
-	*/	
-	err = input_register_device(ps_data->ges_input_dev);	
-	if (err<0)
-	{
-		printk(KERN_ERR "%s: can not register ps input device\n", __func__);	
-		return err;
-	}
-	
-	err = sysfs_create_group(&ps_data->ges_input_dev->dev.kobj, &stk_ges_attribute_group);
-	if (err < 0) 
-	{
-		printk(KERN_ERR "%s:could not create sysfs group for ps\n", __func__);
-		return err;
-	}	
-	input_set_drvdata(ps_data->ges_input_dev, ps_data);	
-#endif	
-	
-	return 0;
-}
+#if STK_WRITE_CALI
 
-#if STK_WRITE_CALI
 static int stk_run_calibration(struct stk3x1x_data *data)
 {
-	struct stk3x1x_data *obj = data;	
+	struct stk3x1x_data *obj = i2c_get_clientdata(this_client);	
 	uint8_t reg;	
 	int ret = 0;
 	int rst = -1;
@@ -4000,16 +2137,7 @@
  
 	printk("%s: start...\r\n", __func__);
 
-#ifdef STK_GES
-	int re_en_ges = 0;
 
-	if(obj->ges_enabled)
-	{
-		stk3x1x_enable_ges(obj, 0, 1);
-		re_en_ges = 1;
-	}
-#endif
-
 	ret = stk3x1x_get_state(obj);
 	if(ret < 0)
 	{
@@ -4019,7 +2147,7 @@
 	if(ret & STK_STATE_EN_PS_MASK)
 	{
 		printk( "%s: force disable PS\n", __func__);
-		stk3x1x_enable_ps(obj, 0, 0);
+		stk3x1x_enable_ps(obj, 0);
 		re_en_ps = 1;
 	}
 
@@ -4056,12 +2184,13 @@
 		goto err_out;
 	}
 
-	ps_hthr = rst +  obj->stk_ht_n_ct;
-	ps_lthr = rst +  obj->stk_lt_n_ct;
+	ps_hthr = rst +  stk3x1x_pfdata.ps_thd_h;
+	ps_lthr = rst +  stk3x1x_pfdata.ps_thd_l;
 
 	ps_len = sprintf(ps_calibration, "%d,%d", ps_hthr, ps_lthr);
 
-	if(ret = write_factory_calibration(ps_calibration, ps_len))
+	ret = write_factory_calibration(ps_calibration, ps_len);
+	if(ret)
 	{
 		printk("[%s] create file error \n", __func__);
 		goto err_out;
@@ -4093,13 +2222,9 @@
 	if(re_en_ps)
 	{
 		printk( "%s: re-enable PS\n", __func__);
-		stk3x1x_enable_ps(obj, 1, 0);
+		stk3x1x_enable_ps(obj, 1);
 	}
 
-#ifdef STK_GES
-	if(re_en_ges)
-		stk3x1x_enable_ges(obj, 1, 1);
-#endif
 
 	printk("%s: end\r\n", __func__);
 
@@ -4108,12 +2233,13 @@
 	else
 		return rst;
 }
+//ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
 
-static ssize_t alsps_calibration_write(struct file *f, char __user *buf, size_t count, loff_t *pos)
+static ssize_t alsps_calibration_write(struct file *f, const char __user *buf, size_t count, loff_t *pos)
 {
 	int ret;
 
-	if((ret=stk_run_calibration(stk3x1x_i2c_data)) < 0)
+	if((ret=stk_run_calibration(i2c_get_clientdata(this_client))) < 0)
 	{
 		printk("%s: stk_run_calibration fail! ret = %d\r\n", __func__, ret);
 		return -EFAULT;
@@ -4126,6 +2252,8 @@
 	}
 }
 
+//ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
+
 static ssize_t alsps_calibration_read(struct file *f, char __user *buf, size_t count, loff_t *ppos)
 {
 	int data_buf[3];
@@ -4132,7 +2260,7 @@
 	int ps_value;
 	
 
-	ps_value = stk3x1x_get_ps_reading(stk3x1x_i2c_data);
+	ps_value = stk3x1x_get_ps_reading(i2c_get_clientdata(this_client));
 	if(!ps_value)
 	{
 		printk("%s: stk3x1x_get_ps_reading fail! ret = %d\r\n", __func__, ps_value);
@@ -4139,8 +2267,8 @@
 		return -EFAULT;
 	}
 	data_buf[0] = ps_value;
-	data_buf[1] = ps_value + PS_h_offset;//stk3x1x_i2c_data->ps_thd_h;
-	data_buf[2] = ps_value + PS_l_offset;//stk3x1x_i2c_data->ps_thd_l;
+	data_buf[1] = ps_value + stk3x1x_pfdata.ps_thd_h;//stk3x1x_i2c_data->ps_thd_h;
+	data_buf[2] = ps_value + stk3x1x_pfdata.ps_thd_l;//stk3x1x_i2c_data->ps_thd_l;
 	printk("%s: data_buf = %d, %d, %d\r\n", __func__, data_buf[0], data_buf[1], data_buf[2]);
 	if(copy_to_user(buf, data_buf, sizeof(data_buf)))
 	{
@@ -4175,236 +2303,135 @@
 };
 #endif
 
-static int stk3x1x_probe(struct i2c_client *client,
-                        const struct i2c_device_id *id)
+
+static int stk3x1x_probe(struct i2c_client *client,const struct i2c_device_id *id)
 {
     int err = -ENODEV;
     struct stk3x1x_data *ps_data;
     struct stk3x1x_platform_data *plat_data;
-    struct device_node *np = client->dev.of_node;
-    printk(KERN_INFO "%s: driver version = %s\n", __func__, DRIVER_VERSION);
-	
-    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
-    {
-        printk(KERN_ERR "%s: No Support for I2C_FUNC_I2C\n", __func__);
+
+    printk("%s: driver version = %s\n", __func__, DRIVER_VERSION);
+
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+        PRINT_ERR( "%s: No Support for I2C_FUNC_I2C\n", __func__);
         return -ENODEV;
     }
 
-	ps_data = kzalloc(sizeof(struct stk3x1x_data),GFP_KERNEL);
-	if(!ps_data)
-	{
-		printk(KERN_ERR "%s: failed to allocate stk3x1x_data\n", __func__);
-		return -ENOMEM;
-	}
-	ps_data->client = client;
-	i2c_set_clientdata(client,ps_data);
-	mutex_init(&ps_data->io_lock);
-	wake_lock_init(&ps_data->ps_wakelock,WAKE_LOCK_SUSPEND, "stk_input_wakelock");
-	
-	stk3x1x_i2c_data = ps_data;
-	
-#ifdef STK_POLL_PS			
-	wake_lock_init(&ps_data->ps_nosuspend_wl,WAKE_LOCK_SUSPEND, "stk_nosuspend_wakelock");
-#endif	
-#if 0
-	if (client->dev.of_node) {
-		printk(KERN_INFO "%s: probe with device tree\n", __func__);
-		plat_data = devm_kzalloc(&client->dev,
-			sizeof(struct stk3x1x_platform_data), GFP_KERNEL);
-		if (!plat_data) {
-			dev_err(&client->dev, "Failed to allocate memory\n");
-			return -ENOMEM;
-		}
+    ps_data = kzalloc(sizeof(struct stk3x1x_data),GFP_KERNEL);
+    if(!ps_data) {
+        PRINT_ERR( "%s: failed to allocate stk3x1x_data\n", __func__);
+        return -ENOMEM;
+    }
 
-		err = stk3x1x_parse_dt(&client->dev, plat_data);
-		dev_err(&client->dev,
-			"%s: stk3x1x_parse_dt ret=%d\n", __func__, err);
-		if (err)
-			return err;
-	} else {
-		printk(KERN_INFO "%s: probe with platform data\n", __func__);	
-#if 1//def SPREADTRUM_PLATFORM		
-		plat_data = &stk3x1x_pfdata;	
-#else
-		plat_data = client->dev.platform_data;	
-#endif		
-	}
-	#endif
-	plat_data = &stk3x1x_pfdata;	
-	if (!plat_data) {
-		dev_err(&client->dev,
-			"%s: no stk3x1x platform data!\n", __func__);
-		goto err_als_input_allocate;
-	}
-	if (np){
-		
-		plat_data->int_pin = of_get_gpio(np, 0);
-		if(plat_data->int_pin < 0){
-			dev_err(&client->dev, "fail to get irq_gpio_number\n");
-			goto err_als_input_allocate;
-		}
-	}
-	ps_data->als_transmittance = plat_data->transmittance;
-	ps_data->int_pin = plat_data->int_pin;
-	ps_data->pdata = plat_data;
+    ps_data->client = client;
+    this_client = client;
+    i2c_set_clientdata(client,ps_data);
+    mutex_init(&ps_data->io_lock);
+    wake_lock_init(&ps_data->ps_wakelock,WAKE_LOCK_SUSPEND, "stk_input_wakelock");
 
-	if (ps_data->als_transmittance == 0) {
-		dev_err(&client->dev,
-			"%s: Please set als_transmittance\n", __func__);
-		goto err_als_input_allocate;
-	}	
-	
-	stk3x1x_set_wq(ps_data);
-#ifdef QUALCOMM_PLATFORM
-	ps_data->ps_thd_h = 0;
-	ps_data->ps_thd_l = 0;	
-#endif	
+    if (client->dev.of_node) {
+        PRINT_WARN( "%s: probe with device tree\n", __func__);
+        plat_data = devm_kzalloc(&client->dev,
+                sizeof(struct stk3x1x_platform_data), GFP_KERNEL);
+        if (!plat_data) {
+                dev_err(&client->dev, "Failed to allocate memory\n");
+                return -ENOMEM;
+        }
 
-#ifdef STK_TUNE0
-	ps_data->stk_max_min_diff = STK_MAX_MIN_DIFF;
-	ps_data->stk_lt_n_ct = STK_LT_N_CT;
-	ps_data->stk_ht_n_ct = STK_HT_N_CT;
-#else
-    ps_data->stk_lt_n_ct = PS_l_offset;
-	ps_data->stk_ht_n_ct = PS_h_offset;
-#endif
-	
+        err = stk3x1x_parse_dt(&client->dev, plat_data);
 
-#ifdef STK_QUALCOMM_POWER_CTRL	
-		
-	err = stk3x1x_power_init(ps_data, true);
-	if (err)
-		goto err_power_on;
+        plat_data->state_reg = stk3x1x_pfdata.state_reg;
+        plat_data->psctrl_reg = stk3x1x_pfdata.psctrl_reg;
+        plat_data->alsctrl_reg = stk3x1x_pfdata.alsctrl_reg;
+        plat_data->ledctrl_reg = stk3x1x_pfdata.ledctrl_reg;
+        plat_data->wait_reg = stk3x1x_pfdata.wait_reg;
+        plat_data->ps_thd_h = stk3x1x_pfdata.ps_thd_h;
+        plat_data->ps_thd_l = stk3x1x_pfdata.ps_thd_l;
+        plat_data->int_pin = stk3x1x_pfdata.int_pin;
+        plat_data->transmittance = stk3x1x_pfdata.transmittance;
 
-	err = stk3x1x_power_ctl(ps_data, true);
-	if (err)
-		goto err_power_on;
+        dev_err(&client->dev,
+                "%s: stk3x1x_parse_dt ret=%d\n", __func__, err);
+        if (err)
+            return err;
+    }
+    else {
+        PRINT_WARN( "%s: probe with platform data\n", __func__);
+        plat_data = &stk3x1x_pfdata;
 
-	err = stk3x1x_check_pid(ps_data);
-	if(err < 0)
-		goto err_init_all_setting;
+    }
+    if (!plat_data) {
+        dev_err(&client->dev,
+            "%s: no stk3x1x platform data!\n", __func__);
+        goto err_als_input_allocate;
+    }
+    ps_data->als_transmittance = plat_data->transmittance;
+    ps_data->int_pin = plat_data->int_pin;
+    ps_data->pdata = plat_data;
+
+    if (ps_data->als_transmittance == 0) {
+            dev_err(&client->dev,
+                    "%s: Please set als_transmittance\n", __func__);
+            goto err_als_input_allocate;
+    }
+
+    stk3x1x_set_wq(ps_data);
+
+    err = stk3x1x_init_all_setting(client, plat_data);
+    if(err < 0)
+            goto err_init_all_setting;
+
+    err = stk3x1x_set_input_devices(ps_data);
+    if(err < 0)
+            goto err_setup_input_device;
+
+    err = stk3x1x_setup_irq(client);
+    if(err < 0)
+            goto err_stk3x1x_setup_irq;
+    device_init_wakeup(&client->dev, true);
+
+    err = misc_register(&stk3x1x_device);
+    if (err) {
+        printk("misc_register failed!\n");
+    }
 		
-	ps_data->als_enabled = false;
-	ps_data->ps_enabled = false;
-#else
-	err = stk3x1x_init_all_setting(client, plat_data);
-	if(err < 0)
-		goto err_init_all_setting;	
-#endif	
-	
-	err = stk3x1x_set_input_devices(ps_data);
-	if(err < 0)
-		goto err_setup_input_device;	
-	
-#if (!defined(STK_POLL_ALS) || !defined(STK_POLL_PS))
-	err = stk3x1x_setup_irq(client);
-	if(err < 0)
-		goto err_stk3x1x_setup_irq;
-#endif		
-	device_init_wakeup(&client->dev, true);
-	
-//#ifdef CONFIG_HAS_EARLYSUSPEND
-#if 0
-	ps_data->stk_early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
-	ps_data->stk_early_suspend.suspend = stk3x1x_early_suspend;
-	ps_data->stk_early_suspend.resume = stk3x1x_late_resume;
-	register_early_suspend(&ps_data->stk_early_suspend);
+#if STK_WRITE_CALI
+		
+		if (misc_register(&alsps_calibration_struct) < 0)
+		{
+			printk("%s: Creat alsps_calibration_struct device file error!!\n", __func__);
+		}
 #endif
 
-#ifdef QUALCOMM_PLATFORM
-	/* make sure everything is ok before registering the class device */
-	ps_data->als_cdev = sensors_light_cdev;
-	ps_data->als_cdev.sensors_enable = stk_als_enable_set;
-	ps_data->als_cdev.sensors_poll_delay = stk_als_poll_delay_set;
-	err = sensors_classdev_register(&client->dev, &ps_data->als_cdev);
-	if (err)
-		goto err_stk3x1x_setup_irq;
 
-	ps_data->ps_cdev = sensors_proximity_cdev;
-	ps_data->ps_cdev.sensors_enable = stk_ps_enable_set;
-	err = sensors_classdev_register(&client->dev, &ps_data->ps_cdev);
-	if (err)
-		goto err_class_sysfs;
+#ifdef HQ_PSENSOR_CALIBRATION
+    stk3x1x_get_init_noise();
 #endif
 
-#ifdef STK_QUALCOMM_POWER_CTRL	
-	/* enable device power only when it is enabled */
-	err = stk3x1x_power_ctl(ps_data, false);
-	if (err)
-		goto err_power_ctl;
-#endif		
+    stk_pls_create_sysfs(client);
+    huaqin_psensor_noise_attr();
 
-#if STK_WRITE_CALI
+//    stk3x1x_enable_ps(ps_data, 1);
+//    stk3x1x_enable_als(ps_data, 1);
+    printk("%s: probe successfully\n", __func__);
+    return 0;
 
-	if (misc_register(&alsps_calibration_struct) < 0)
-	{
-		printk("%s: Creat alsps_calibration_struct device file error!!\n", __func__);
-	}
-#endif
+    err_stk3x1x_setup_irq:
+    free_irq(ps_data->irq, ps_data);
+    gpio_free(ps_data->int_pin);
+    err_setup_input_device:
 
-	printk(KERN_INFO "%s: probe successfully\n", __func__);
-	//stk3x1x_enable_ps(ps_data, 1, 0);
-	//stk3x1x_enable_als(ps_data, 1);
-	return 0;
 
-	//device_init_wakeup(&client->dev, false);
-#ifdef STK_QUALCOMM_POWER_CTRL	
-err_power_ctl:
-#endif	
-#ifdef QUALCOMM_PLATFORM
-	sensors_classdev_unregister(&ps_data->ps_cdev);
-err_class_sysfs:
-	sensors_classdev_unregister(&ps_data->als_cdev);
-#endif	
-
-#if (!defined(STK_POLL_ALS) || !defined(STK_POLL_PS))
-err_stk3x1x_setup_irq:
-	free_irq(ps_data->irq, ps_data);
-	#ifdef SPREADTRUM_PLATFORM	
-		sprd_free_gpio_irq(ps_data->int_pin);		
-	#else	
-		gpio_free(ps_data->int_pin);	
-	#endif	
-#endif
-err_setup_input_device:
-#ifdef STK_GES
-	sysfs_remove_group(&ps_data->ges_input_dev->dev.kobj, &stk_ges_attribute_group);	
-	input_unregister_device(ps_data->ges_input_dev);	
-	input_free_device(ps_data->ges_input_dev);	
-#endif	
-	sysfs_remove_group(&ps_data->ps_input_dev->dev.kobj, &stk_ps_attribute_group);	
-	sysfs_remove_group(&ps_data->als_input_dev->dev.kobj, &stk_als_attribute_group);	
-	input_unregister_device(ps_data->ps_input_dev);		
-	input_unregister_device(ps_data->als_input_dev);	
-	input_free_device(ps_data->ps_input_dev);	
-	input_free_device(ps_data->als_input_dev);
-err_init_all_setting:
-#ifdef STK_QUALCOMM_POWER_CTRL	
-	stk3x1x_power_ctl(ps_data, false);
-err_power_on:	
-	stk3x1x_power_init(ps_data, false);
-#endif	
-#ifdef STK_POLL_ALS		
-	hrtimer_try_to_cancel(&ps_data->als_timer);
-	destroy_workqueue(ps_data->stk_als_wq);	
-#endif	
-#ifdef STK_TUNE0
-	destroy_workqueue(ps_data->stk_ps_tune0_wq);	
-#endif	
-#ifdef STK_POLL_PS	
-	hrtimer_try_to_cancel(&ps_data->ps_timer);	
-	destroy_workqueue(ps_data->stk_ps_wq);	
-#endif		
-#if (!defined(STK_POLL_ALS) || !defined(STK_POLL_PS))
-	destroy_workqueue(ps_data->stk_wq);	
-#endif		
-err_als_input_allocate:
-#ifdef STK_POLL_PS
-    wake_lock_destroy(&ps_data->ps_nosuspend_wl);	
-#endif	
-    wake_lock_destroy(&ps_data->ps_wakelock);	
+    input_unregister_device(ps_data->ps_input_dev);
+    input_free_device(ps_data->ps_input_dev);
+    err_init_all_setting:
+    hrtimer_try_to_cancel(&ps_data->als_timer);
+    destroy_workqueue(ps_data->stk_als_wq);
+    destroy_workqueue(ps_data->stk_wq);
+    err_als_input_allocate:
+    wake_lock_destroy(&ps_data->ps_wakelock);
     mutex_destroy(&ps_data->io_lock);
-	kfree(ps_data);
+    kfree(ps_data);
     return err;
 }
 
@@ -4411,85 +2438,43 @@
 
 static int stk3x1x_remove(struct i2c_client *client)
 {
-	struct stk3x1x_data *ps_data = i2c_get_clientdata(client);
-	
-	device_init_wakeup(&client->dev, false);
-#ifdef STK_QUALCOMM_POWER_CTRL	
-	stk3x1x_power_ctl(ps_data, false);
-#endif	
-#ifdef QUALCOMM_PLATFORM
-	sensors_classdev_unregister(&ps_data->ps_cdev);
-	sensors_classdev_unregister(&ps_data->als_cdev);
-#endif	
-#ifdef STK_QUALCOMM_POWER_CTRL		
-	stk3x1x_power_init(ps_data, false);
-#endif	
-#if (!defined(STK_POLL_ALS) || !defined(STK_POLL_PS))
-	free_irq(ps_data->irq, ps_data);
-	#ifdef SPREADTRUM_PLATFORM	
-		sprd_free_gpio_irq(ps_data->int_pin);		
-	#else	
-		gpio_free(ps_data->int_pin);	
-	#endif	
-#endif	/* #if (!defined(STK_POLL_ALS) || !defined(STK_POLL_PS)) */	
+    struct stk3x1x_data *ps_data = i2c_get_clientdata(client);
+    device_init_wakeup(&client->dev, false);
+    free_irq(ps_data->irq, ps_data);
+    gpio_free(ps_data->int_pin);
 
+    destroy_workqueue(ps_data->stk_wq);
+    input_unregister_device(ps_data->ps_input_dev);
+    input_free_device(ps_data->ps_input_dev);
+    hrtimer_try_to_cancel(&ps_data->als_timer);
+    destroy_workqueue(ps_data->stk_als_wq);
+    wake_lock_destroy(&ps_data->ps_wakelock);
+    mutex_destroy(&ps_data->io_lock);
+    kfree(ps_data);
 
-#ifdef STK_GES	
-	sysfs_remove_group(&ps_data->ges_input_dev->dev.kobj, &stk_ges_attribute_group);	
-	input_unregister_device(ps_data->ges_input_dev);
-	input_free_device(ps_data->ges_input_dev);		
-#endif	
-
-	sysfs_remove_group(&ps_data->ps_input_dev->dev.kobj, &stk_ps_attribute_group);	
-	sysfs_remove_group(&ps_data->als_input_dev->dev.kobj, &stk_als_attribute_group);	
-	input_unregister_device(ps_data->ps_input_dev);		
-	input_unregister_device(ps_data->als_input_dev);	
-	input_free_device(ps_data->ps_input_dev);	
-	input_free_device(ps_data->als_input_dev);	
-
-#ifdef STK_POLL_ALS		
-	hrtimer_try_to_cancel(&ps_data->als_timer);	
-	destroy_workqueue(ps_data->stk_als_wq);	
-#endif	
-#ifdef STK_TUNE0
-	destroy_workqueue(ps_data->stk_ps_tune0_wq);	
-#endif	
-#ifdef STK_POLL_PS
-	hrtimer_try_to_cancel(&ps_data->ps_timer);	
-	destroy_workqueue(ps_data->stk_ps_wq);		
-#if (!defined(STK_POLL_ALS) || !defined(STK_POLL_PS))
-	destroy_workqueue(ps_data->stk_wq);	
-#endif	
-	wake_lock_destroy(&ps_data->ps_nosuspend_wl);	
-#endif	
-	wake_lock_destroy(&ps_data->ps_wakelock);	
-    mutex_destroy(&ps_data->io_lock);
-	kfree(ps_data);
-	stk3x1x_i2c_data = NULL;
     return 0;
 }
 
 static const struct i2c_device_id stk_ps_id[] =
 {
-    { "stk_ps", 0},
+    { STK3X1X_DEV_NAME, 2},
     {}
 };
 MODULE_DEVICE_TABLE(i2c, stk_ps_id);
 
 static struct of_device_id stk_match_table[] = {
-	{ .compatible = "stk,stk3x1x", },
-	{ },
+        { .compatible = "Sensortek,stk3x1x_pls", },
+        { },
 };
 
 static struct i2c_driver stk_ps_driver =
 {
     .driver = {
-        .name = DEVICE_NAME,
-		.owner = THIS_MODULE,	
-#ifdef CONFIG_OF		
-		.of_match_table = stk_match_table,		
-#endif		
-		.pm = &stk3x1x_pm_ops,		
+    .name = STK3X1X_DEV_NAME,
+        .owner = THIS_MODULE,
+#ifdef CONFIG_OF
+        .of_match_table = stk_match_table,
+#endif
     },
     .probe = stk3x1x_probe,
     .remove = stk3x1x_remove,
@@ -4496,22 +2481,21 @@
     .id_table = stk_ps_id,
 };
 
-
 static int __init stk3x1x_init(void)
 {
-	int ret;
+    int ret;
+    PRINT_WARN("stk3x1x_init\n");
     ret = i2c_add_driver(&stk_ps_driver);
-    if (ret)
-	{
-		i2c_del_driver(&stk_ps_driver);
+    if (ret) {
+        i2c_del_driver(&stk_ps_driver);
         return ret;
-	}
+    }
     return 0;
 }
 
 static void __exit stk3x1x_exit(void)
 {
-    i2c_del_driver(&stk_ps_driver);	
+    i2c_del_driver(&stk_ps_driver);
 }
 
 module_init(stk3x1x_init);
Index: kernel/drivers/input/misc/stk3x1x.h
===================================================================
--- kernel/drivers/input/misc/stk3x1x.h	(revision 0)
+++ kernel/drivers/input/misc/stk3x1x.h	(revision 166559)
@@ -0,0 +1,140 @@
+#ifndef __STK3X1X_H__
+#define __STK3X1X_H__
+
+/* platform data */
+struct stk3x1x_platform_data
+{
+	uint8_t state_reg;
+	uint8_t psctrl_reg;
+	uint8_t alsctrl_reg;
+	uint8_t ledctrl_reg;
+	uint8_t	wait_reg;	
+	uint16_t ps_thd_h;
+	uint16_t ps_thd_l;
+	int int_pin;
+	uint32_t transmittance;
+	uint32_t int_flags;	
+};
+
+#define STK_IOCTL_MAGIC         0x1C
+#define STK_IOCTL_GET_PFLAG     _IOR(STK_IOCTL_MAGIC, 1, int)
+#define STK_IOCTL_GET_LFLAG     _IOR(STK_IOCTL_MAGIC, 2, int)
+#define STK_IOCTL_SET_PFLAG     _IOW(STK_IOCTL_MAGIC, 3, int)
+#define STK_IOCTL_SET_LFLAG     _IOW(STK_IOCTL_MAGIC, 4, int)
+#define STK_IOCTL_GET_DATA      _IOW(STK_IOCTL_MAGIC, 5, unsigned char)
+#define STK_IOCTL_GET_CHIPINFO  _IOR(STK_IOCTL_MAGIC, 6, char)
+
+
+/* Define Register Map */
+#define STK_STATE_REG 			0x00
+#define STK_PSCTRL_REG 			0x01
+#define STK_ALSCTRL_REG 			0x02
+#define STK_LEDCTRL_REG 			0x03
+#define STK_INT_REG 				0x04
+#define STK_WAIT_REG 			0x05
+#define STK_THDH1_PS_REG 		0x06
+#define STK_THDH2_PS_REG 		0x07
+#define STK_THDL1_PS_REG 		0x08
+#define STK_THDL2_PS_REG 		0x09
+#define STK_THDH1_ALS_REG 		0x0A
+#define STK_THDH2_ALS_REG 		0x0B
+#define STK_THDL1_ALS_REG 		0x0C
+#define STK_THDL2_ALS_REG 		0x0D
+#define STK_FLAG_REG 			0x10
+#define STK_DATA1_PS_REG	 	0x11
+#define STK_DATA2_PS_REG 		0x12
+#define STK_DATA1_ALS_REG 		0x13
+#define STK_DATA2_ALS_REG 		0x14
+#define STK_DATA1_OFFSET_REG 	0x15
+#define STK_DATA2_OFFSET_REG 	0x16
+#define STK_DATA1_IR_REG 		0x17
+#define STK_DATA2_IR_REG 		0x18
+#define STK_PDT_ID_REG 			0x3E
+#define STK_RSRVD_REG 			0x3F
+#define STK_SW_RESET_REG		0x80
+
+#define STK_GSCTRL_REG			0x1A
+#define STK_FLAG2_REG			0x1C
+
+/* Define state reg */
+#define STK_STATE_EN_IRS_SHIFT  	7
+#define STK_STATE_EN_AK_SHIFT  		6
+#define STK_STATE_EN_ASO_SHIFT  	5
+#define STK_STATE_EN_IRO_SHIFT  	4
+#define STK_STATE_EN_WAIT_SHIFT  	2
+#define STK_STATE_EN_ALS_SHIFT  	1
+#define STK_STATE_EN_PS_SHIFT  		0
+
+#define STK_STATE_EN_IRS_MASK	0x80
+#define STK_STATE_EN_AK_MASK	0x40
+#define STK_STATE_EN_ASO_MASK	0x20
+#define STK_STATE_EN_IRO_MASK	0x10
+#define STK_STATE_EN_WAIT_MASK	0x04
+#define STK_STATE_EN_ALS_MASK	0x02
+#define STK_STATE_EN_PS_MASK	0x01
+
+/* Define PS ctrl reg */
+#define STK_PS_PRS_SHIFT  		6
+#define STK_PS_GAIN_SHIFT  		4
+#define STK_PS_IT_SHIFT  		0
+
+#define STK_PS_PRS_MASK			0xC0
+#define STK_PS_GAIN_MASK		0x30
+#define STK_PS_IT_MASK			0x0F
+
+/* Define ALS ctrl reg */
+#define STK_ALS_PRS_SHIFT  		6
+#define STK_ALS_GAIN_SHIFT  	4
+#define STK_ALS_IT_SHIFT  		0
+
+#define STK_ALS_PRS_MASK		0xC0
+#define STK_ALS_GAIN_MASK		0x30
+#define STK_ALS_IT_MASK			0x0F
+	
+/* Define LED ctrl reg */
+#define STK_LED_IRDR_SHIFT      6
+#define STK_LED_DT_SHIFT  		0
+
+#define STK_LED_IRDR_MASK		0xC0
+#define STK_LED_DT_MASK			0x3F
+	
+/* Define interrupt reg */
+#define STK_INT_CTRL_SHIFT  	7
+#define STK_INT_OUI_SHIFT  		4
+#define STK_INT_ALS_SHIFT  		3
+#define STK_INT_PS_SHIFT  		0
+
+#define STK_INT_CTRL_MASK		0x80
+#define STK_INT_OUI_MASK		0x10
+#define STK_INT_ALS_MASK		0x08
+#define STK_INT_PS_MASK			0x07
+
+#define STK_INT_ALS				0x08
+
+/* Define flag reg */
+#define STK_FLG_ALSDR_SHIFT  		7
+#define STK_FLG_PSDR_SHIFT  		6
+#define STK_FLG_ALSINT_SHIFT  		5
+#define STK_FLG_PSINT_SHIFT  		4
+#define STK_FLG_OUI_SHIFT  		    2
+#define STK_FLG_IR_RDY_SHIFT  		1
+#define STK_FLG_NF_SHIFT  		    0
+
+#define STK_FLG_ALSDR_MASK		0x80
+#define STK_FLG_PSDR_MASK		0x40
+#define STK_FLG_ALSINT_MASK		0x20
+#define STK_FLG_PSINT_MASK		0x10
+#define STK_FLG_OUI_MASK		0x04
+#define STK_FLG_IR_RDY_MASK		0x02
+#define STK_FLG_NF_MASK			0x01
+	
+/* Define flag2 reg */
+#define STK_FLG2_INT_GS_SHIFT	6
+#define STK_FLG2_GS10_SHIFT		5
+#define STK_FLG2_GS01_SHIFT		4
+
+#define STK_FLG2_INT_GS_MASK	0x40
+#define STK_FLG2_GS10_MASK		0x20
+#define STK_FLG2_GS01_MASK		0x10
+
+#endif // __STK3X1X_H__
Index: kernel/drivers/input/misc/Makefile
===================================================================
--- kernel/drivers/input/misc/Makefile	(revision 166558)
+++ kernel/drivers/input/misc/Makefile	(revision 166559)
@@ -34,7 +34,7 @@
 obj-$(CONFIG_INPUT_IXP4XX_BEEPER)	+= ixp4xx-beeper.o
 obj-$(CONFIG_INPUT_KEYCHORD)		+= keychord.o
 obj-$(CONFIG_INPUT_KEYSPAN_REMOTE)	+= keyspan_remote.o
-obj-$(CONFIG_INPUT_KXTJ9)		+= kxtj9.o
+obj-$(CONFIG_INPUT_KXTJ9)		+= kxtj-lis3dh.o
 obj-$(CONFIG_INPUT_M68K_BEEP)		+= m68kspkr.o
 obj-$(CONFIG_INPUT_MAX8925_ONKEY)	+= max8925_onkey.o
 obj-$(CONFIG_INPUT_MAX8997_HAPTIC)	+= max8997_haptic.o
Index: kernel/drivers/input/misc/Kconfig
===================================================================
--- kernel/drivers/input/misc/Kconfig	(revision 166558)
+++ kernel/drivers/input/misc/Kconfig	(revision 166559)
@@ -669,6 +669,11 @@
 
        To compile this driver as a module, choose M here: the
        module will be called headset.
+       
+config INPUT_HEADSET_AVOID_INVALID_BUTTON
+     tristate "SPRD platform avoid button irq when headset plug in/out"
+     help
+       Say Y here if you avoid button irq when headset plug in/out.       
  
 config INPUT_SPRD_HALL
      tristate "SPRD platform builtin hall detect driver"
@@ -731,7 +736,17 @@
 	  communication, else say N.
 
 	  To compile this driver as a module, choose M here.
+	  
+config INPUT_KXTJ9_I2C
+	tristate "ST KXTJ9 3-Axid accelerometer device with I2C bus"
+	depends on I2C
+	default n
+	help
+	  Say Y here if you have a KXTJ9 device on the board and use I2C
+	  communication, else say N.
 
+	  To compile this driver as a module, choose M here.
+	  
 config INPUT_MEM3524X_I2C
 	tristate "MEM mem3524x 3-Axid mag device with I2C bus"
 	depends on I2C
Index: kernel/drivers/input/misc/headset_sprd_sc2723.c
===================================================================
--- kernel/drivers/input/misc/headset_sprd_sc2723.c	(revision 166558)
+++ kernel/drivers/input/misc/headset_sprd_sc2723.c	(revision 166559)
@@ -262,7 +262,12 @@
         struct regulator *vbo;
 } sprd_hts_power;
 
-
+#ifdef CONFIG_INPUT_HEADSET_AVOID_INVALID_BUTTON
+unsigned long g_headset_irq_enable_delay = 1000;
+unsigned long g_button_invalid_num = 0;
+unsigned long g_adc_left_threshold = 2500;
+extern void sprd_gpio_eic_irq_ack(unsigned int irq);
+#endif
 int vbc_close_fm_dggain(void)
     __attribute__ ((weak, alias("__vbc_close_fm_dggain")));
 static int __vbc_close_fm_dggain(void)
@@ -490,13 +495,23 @@
 {
         unsigned long spin_lock_flags;
         static int current_irq_state = 1;//irq is enabled after request_irq()
+#ifdef CONFIG_INPUT_HEADSET_AVOID_INVALID_BUTTON
+        struct sprd_headset *ht = &headset;
+#endif
+
         spin_lock_irqsave(&irq_button_lock, spin_lock_flags);
         if (1 == enable) {
+#ifdef CONFIG_INPUT_HEADSET_AVOID_INVALID_BUTTON
+                sprd_gpio_eic_irq_ack(irq);
+#endif
                 if (0 == current_irq_state) {
                         enable_irq(irq);
                         current_irq_state = 1;
                 }
         } else {
+#ifdef CONFIG_INPUT_HEADSET_AVOID_INVALID_BUTTON
+                hrtimer_cancel(&ht->timer);
+#endif
                 if (1 == current_irq_state) {
                         disable_irq_nosync(irq);
                         current_irq_state = 0;
@@ -526,6 +541,20 @@
         return;
 }
 
+#ifdef CONFIG_INPUT_HEADSET_AVOID_INVALID_BUTTON
+static enum hrtimer_restart headset_irq_enable_timer_func(struct hrtimer *timer)
+{
+    enum hrtimer_restart restart = HRTIMER_NORESTART;
+//    struct sprd_headset *ht = container_of(timer, struct sprd_headset, timer);
+    struct sprd_headset *ht = &headset;
+
+    //sprd_gpio_eic_irq_ack(ht->irq_button);
+    headset_irq_button_enable(1, ht->irq_button);
+    PRINT_DBG("delay enable button irq[%d]\n",ht->irq_button);
+    return restart;
+}
+#endif
+
 void headset_irq_detect_enable_ext(int enable)
 {
 	struct sprd_headset *ht = &headset;
@@ -942,6 +971,7 @@
         int i = 0;
         int adc_ideal = 0;
 
+        int adc_left_average = 0;
         down(&headset_sem);
         set_adc_to_headmic(1);
 
@@ -984,6 +1014,25 @@
                 }
 
                 if(0 == button_state_last) {
+#ifdef CONFIG_INPUT_HEADSET_AVOID_INVALID_BUTTON
+                        if (BIT_HEADSET_MIC == ht->type) {
+                        if (0 == headset_button_valid(gpio_get_value(ht->platform_data->gpio_detect))) {
+                             PRINT_DBG("headset_button_work_func: button is unvalid!!!\n");
+                             goto out;
+                         } else {
+                            set_adc_to_headmic(0);
+                            msleep(50);
+                            adc_left_average = adc_get_average(pdata->gpio_button, gpio_button_value_last);
+                            PRINT_DBG("headset_button_work_func: adc_mic_average = %d, adc_left_average = %d\n",
+                                    adc_mic_average, adc_left_average);
+                            if (adc_left_average > g_adc_left_threshold) {
+                                g_button_invalid_num++;
+                                PRINT_DBG("headset_button_work_func: button is unvalid for adc left!!!\n");
+                                goto out;
+                            }
+                         }
+						 } // BIT_HEADSET_MIC == ht->type
+#endif
                         input_event(ht->input_dev, EV_KEY, current_key_code, 1);
                         input_sync(ht->input_dev);
                         button_state_last = 1;
@@ -1130,7 +1179,15 @@
                                 else
                                         headset_irq_set_irq_type(ht->irq_button, IRQF_TRIGGER_LOW);
 
+#ifdef CONFIG_INPUT_HEADSET_AVOID_INVALID_BUTTON
+                                hrtimer_cancel(&ht->timer);
+
+                                hrtimer_start(&ht->timer,
+                                    ktime_set(g_headset_irq_enable_delay / 1000,(g_headset_irq_enable_delay % 1000) * 1000000),
+                                         HRTIMER_MODE_REL);
+#else
                                 headset_irq_button_enable(1, ht->irq_button);
+#endif
                         }
 
                         ht->type = BIT_HEADSET_MIC;
@@ -1750,6 +1807,10 @@
 
         wake_lock_init(&headset_detect_wakelock, WAKE_LOCK_SUSPEND, "headset_detect_wakelock");
         wake_lock_init(&headset_button_wakelock, WAKE_LOCK_SUSPEND, "headset_button_wakelock");
+#ifdef CONFIG_INPUT_HEADSET_AVOID_INVALID_BUTTON
+        hrtimer_init(&ht->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+        ht->timer.function = headset_irq_enable_timer_func;
+#endif
 
         //set EIC3 de-bounce time for button irq
         headset_reg_set_val((ANA_EIC_BASE+EIC3_DBNC_CTRL), DBNC_CNT3_VALUE, DBNC_CNT3_MASK, DBNC_CNT3_SHIFT);
@@ -1958,6 +2019,16 @@
 late_initcall(headset_init);
 module_exit(headset_exit);
 
+#ifdef CONFIG_INPUT_HEADSET_AVOID_INVALID_BUTTON
+module_param_named(enable_delay, g_headset_irq_enable_delay, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(enable_delay, "delay to enable button irq");
+
+module_param_named(invalid_num, g_button_invalid_num, uint, S_IRUGO);
+MODULE_PARM_DESC(invalid_num, "the num of invalid bottun");
+
+module_param_named(adc_threshold, g_adc_left_threshold, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(adc_threshold, "the threshold of left adc");
+#endif
 MODULE_DESCRIPTION("headset & button detect driver v2");
 MODULE_AUTHOR("Yaochuan Li <yaochuan.li@spreadtrum.com>");
 MODULE_LICENSE("GPL");
