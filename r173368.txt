Index: packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperPickerActivity.java
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperPickerActivity.java	(revision 173367)
+++ packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperPickerActivity.java	(revision 173368)
@@ -26,7 +26,6 @@
 import android.content.Intent;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
-import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.database.Cursor;
 import android.database.DataSetObserver;
@@ -47,7 +46,6 @@
 import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
-import android.os.Looper;
 import android.os.Process;
 import android.provider.MediaStore;
 import android.support.annotation.NonNull;
@@ -84,11 +82,11 @@
 import com.android.launcher3.util.Thunk;
 import com.android.photos.BitmapRegionTileSource;
 import com.android.photos.BitmapRegionTileSource.BitmapSource;
+import com.sprd.ext.LogUtils;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
-import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -106,6 +104,7 @@
     private static final String TEMP_WALLPAPER_TILES = "TEMP_WALLPAPER_TILES";
     private static final String SELECTED_INDEX = "SELECTED_INDEX";
     private static final int FLAG_POST_DELAY_MILLIS = 200;
+    private static final String FLAG_PICK_IMAGE_FOR_WALLPAPER = "applyForWallpaper";
 
     private final static int PERMISSION_REQUEST_READ_EXTERNAL_STORAGE = 0;
 
@@ -167,6 +166,10 @@
 
                 @Override
                 public void run() {
+                    if (LogUtils.DEBUG) {
+                        LogUtils.d(TAG, "UriWallpaperInfo loaded, State:"
+                                + bitmapSource.getLoadingState() + "Uri:" + mUri);
+                    }
                     if (bitmapSource.getLoadingState() == BitmapSource.State.LOADED) {
                         a.selectTile(mView);
                         a.setWallpaperButtonEnabled(true);
@@ -173,6 +176,9 @@
                     } else {
                         ViewGroup parent = (ViewGroup) mView.getParent();
                         if (parent != null) {
+                            // Need remove the specific uri when it loads failed.
+                            a.removeUriFromTmpWallpapers(mUri);
+
                             parent.removeView(mView);
                             Toast.makeText(a.getContext(), R.string.image_load_fail,
                                     Toast.LENGTH_SHORT).show();
@@ -215,17 +221,7 @@
                                 thumb = Bitmap.createScaledBitmap(thumb, size.x, size.y, true);
                             }
                         } catch (IOException e) {
-                            /* SPRD: add for bug601343 add the selection .{ */
-                            new Thread(new Runnable() {
-                                @Override
-                                public void run() {
-                                    Looper.prepare();
-                                    Toast.makeText(a, R.string.wallpaper_load_fail, Toast.LENGTH_SHORT).show();
-                                    Looper.loop();
-                                }
-                            }).start();
-                            return;
-                            /* @} */
+                            // do nothing
                         } catch (SecurityException e) {
                             Log.e(TAG, e.toString());
                             return;
@@ -279,6 +275,10 @@
 
                 @Override
                 public void run() {
+                    if (LogUtils.DEBUG) {
+                        LogUtils.d(TAG, "FileWallpaperInfo loaded, State:"
+                                + bitmapSource.getLoadingState() + "File:" + mFile.getAbsolutePath());
+                    }
                     if (bitmapSource.getLoadingState() == BitmapSource.State.LOADED) {
                         a.setWallpaperButtonEnabled(true);
                     }
@@ -334,6 +334,11 @@
 
                 @Override
                 public void run() {
+                    if (LogUtils.DEBUG) {
+                        LogUtils.d(TAG, "ResourceWallpaperInfo loaded, State:"
+                                + bitmapSource.getLoadingState()
+                                + "res:" + mResources.getResourceName(mResId));
+                    }
                     if (bitmapSource.getLoadingState() == BitmapSource.State.LOADED) {
                         a.setWallpaperButtonEnabled(true);
                     }
@@ -366,7 +371,7 @@
         public void onClick(WallpaperPickerActivity a) {
             CropView c = a.getCropView();
             Drawable defaultWallpaper = WallpaperManager.getInstance(a.getContext())
-                    .getBuiltInDrawable(c.getWidth(), c.getHeight(), false, 0.5f, 0.5f);
+                    .getBuiltInDrawable();
             if (defaultWallpaper == null) {
                 Log.w(TAG, "Null default wallpaper encountered.");
                 c.setTileSource(null, null);
@@ -380,12 +385,7 @@
 
                 @Override
                 public float getScale(Point wallpaperSize, RectF crop) {
-                    int orientation = a.getResources().getConfiguration().orientation;
-                    if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
-                        return wallpaperSize.x /crop.width();
-                    } else {
-                        return super.getScale(wallpaperSize, crop);
-                    }
+                    return wallpaperSize.x /crop.width();
                 }
             };
             req.result = new DrawableTileSource(a.getContext(),
@@ -606,7 +606,11 @@
             }
         };
 
-        mWallpaperParallaxOffset = getIntent().getFloatExtra(EXTRA_WALLPAPER_OFFSET, 0);
+        try {
+            mWallpaperParallaxOffset = getIntent().getFloatExtra(EXTRA_WALLPAPER_OFFSET, 0);
+        }catch (Exception e){
+            Log.d(TAG,"get mWallpaperParallaxOffset fail " + e);
+        }
 
         // Populate the built-in wallpapers
         ArrayList<WallpaperTileInfo> wallpapers = findBundledWallpapers();
@@ -772,6 +776,7 @@
                     int childCount = mWallpapersView.getChildCount();
                     ArrayList<View> viewsToRemove = new ArrayList<View>();
                     boolean selectedTileRemoved = false;
+                    int offset = 0;
                     for (int i = 0; i < childCount; i++) {
                         CheckableFrameLayout c =
                                 (CheckableFrameLayout) mWallpapersView.getChildAt(i);
@@ -778,9 +783,14 @@
                         if (c.isChecked()) {
                             WallpaperTileInfo info = (WallpaperTileInfo) c.getTag();
                             info.onDelete(WallpaperPickerActivity.this);
+                            if (info instanceof UriWallpaperInfo) {
+                                removeUriFromTmpWallpapers(((UriWallpaperInfo) info).mUri);
+                            }
                             viewsToRemove.add(c);
                             if (i == mSelectedIndex) {
                                 selectedTileRemoved = true;
+                            } else if (i < mSelectedIndex) {
+                                offset++;
                             }
                         }
                     }
@@ -790,7 +800,10 @@
                     if (selectedTileRemoved) {
                         mSelectedIndex = -1;
                         mSelectedTile = null;
+                        setWallpaperButtonEnabled(false);
                         setSystemWallpaperVisiblity(true);
+                    } else {
+                        mSelectedIndex = mSelectedIndex - offset;
                     }
                     updateTileIndices();
                     mode.finish(); // Action picked, so close the CAB
@@ -852,11 +865,15 @@
 
     private void startNewActivity() {
         Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
-        SprdLauncherDrmUtils.getInstance().addIntentExtra(intent);
+        intent.putExtra(FLAG_PICK_IMAGE_FOR_WALLPAPER, true);
         intent.setType("image/*");
         startActivityForResultSafely(intent, IMAGE_PICK);
     }
 
+    private final void removeUriFromTmpWallpapers(final Uri uri) {
+        mTempWallpaperTiles.remove(uri);
+    }
+
     public void setWallpaperButtonEnabled(boolean enabled) {
         mSetWallpaperButton.setEnabled(enabled);
     }
@@ -1048,14 +1065,6 @@
 
     private void addTemporaryWallpaperTile(final Uri uri, boolean fromRestore) {
         // Add a tile for the image picked from Gallery, reusing the existing tile if there is one.
-        /* SPRD: add for bug599602 add the selection .
-        when close the permission,the activity is killed.
-        and the view is lost.
-        so add null pointer protect for mWallpaperView@{ */
-        if(mWallpapersView == null){
-            return;
-        }
-        /* @} */
 
         FrameLayout existingImageThumbnail = null;
         int indexOfExistingTile = 0;
@@ -1093,6 +1102,7 @@
                     return createThumbnail(defaultSize, context, uri, null, null, 0, rotation,
                             false);
                 } catch (SecurityException securityException) {
+                    LogUtils.e(TAG, "Failed to load thumbnail, uri:" + uri, securityException);
                     if (isActivityDestroyed()) {
                         // Temporarily granted permissions are revoked when the activity
                         // finishes, potentially resulting in a SecurityException here.
@@ -1100,16 +1110,6 @@
                         // situations where the configuration changes, we are fine with
                         // catching these cases here as well.
                         cancel(false);
-                    } else {
-                        // otherwise it had a different cause and we throw it further
-                        // otherwise it had a different cause and we throw it further
-                        /* Sprd: bug 597347,Launcher crash @{ */
-                        //throw securityException;
-                        Log.e(TAG, securityException.toString());
-                        if (isResumed()) {
-                            finish();
-                        }
-                        /* @} */
                     }
                     return null;
                 }
Index: packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperCropActivity.java
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperCropActivity.java	(revision 173367)
+++ packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperCropActivity.java	(revision 173368)
@@ -16,7 +16,6 @@
 
 package com.android.launcher3;
 
-import android.*;
 import android.annotation.TargetApi;
 import android.app.ActionBar;
 import android.app.Activity;
@@ -25,11 +24,10 @@
 import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.SharedPreferences;
-import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
-import android.graphics.BitmapRegionDecoder;
+
 import android.graphics.Matrix;
 import android.graphics.Point;
 import android.graphics.PointF;
@@ -39,7 +37,6 @@
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.HandlerThread;
-import android.os.Looper;
 import android.os.Message;
 import android.util.Log;
 import android.view.Display;
@@ -57,10 +54,8 @@
 import com.android.photos.BitmapRegionTileSource.BitmapSource;
 import com.android.photos.BitmapRegionTileSource.BitmapSource.InBitmapProvider;
 import com.android.photos.views.TiledImageRenderer.TileSource;
+import com.sprd.ext.LogUtils;
 
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
 import java.util.Collections;
 import java.util.Set;
 import java.util.WeakHashMap;
@@ -146,22 +141,6 @@
             return;
         }
 
-        /* SPRD: add for bug601343 add the selection .{ */
-        try {
-            InputStream in = getContentResolver().openInputStream(imageUri);
-            BitmapRegionDecoder decoder = null;
-            try {
-                decoder = BitmapRegionDecoder.newInstance(in, true);
-            } catch (IOException e) {
-                Toast.makeText(WallpaperCropActivity.this, R.string.do_not_support_format_wallpaper, Toast.LENGTH_SHORT).show();
-                e.printStackTrace();
-                finish();
-            }
-        } catch (FileNotFoundException e) {
-            e.printStackTrace();
-        }
-        /* @} */
-
         // Action bar
         // Show the custom action bar view
         final ActionBar actionBar = getActionBar();
@@ -242,6 +221,7 @@
                     }
                 });
             } catch (SecurityException securityException) {
+                LogUtils.e(LOGTAG, "Failed to load image:", securityException);
                 if (isActivityDestroyed()) {
                     // Temporarily granted permissions are revoked when the activity
                     // finishes, potentially resulting in a SecurityException here.
@@ -249,15 +229,6 @@
                     // situations where the configuration changes, we are fine with
                     // catching these cases here as well.
                     return true;
-                } else {
-                    // otherwise it had a different cause and we throw it further
-                    /* Sprd: bug 597347,Launcher crash @{ */
-                    //throw securityException;
-                    Log.e(LOGTAG, securityException.toString());
-                    if (isResumed()) {
-                        finish();
-                    }
-                    /* @} */
                 }
             }
 
@@ -514,7 +485,7 @@
         String spKey = LauncherFiles.WALLPAPER_CROP_PREFERENCES_KEY;
         SharedPreferences sp = getContext().getSharedPreferences(spKey, Context.MODE_MULTI_PROCESS);
         SharedPreferences.Editor editor = sp.edit();
-        if (width != 0 && height != 0) {
+        if (width > 0 && height > 0) {
             editor.putInt(WALLPAPER_WIDTH_KEY, width);
             editor.putInt(WALLPAPER_HEIGHT_KEY, height);
         } else {
Index: packages/apps/Launcher3/WallpaperPicker/src/com/android/gallery3d/common/BitmapCropTask.java
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/src/com/android/gallery3d/common/BitmapCropTask.java	(revision 173367)
+++ packages/apps/Launcher3/WallpaperPicker/src/com/android/gallery3d/common/BitmapCropTask.java	(revision 173368)
@@ -199,6 +199,18 @@
                     failure = true;
                     return false;
                 }
+                BitmapRegionDecoder decoder = BitmapRegionDecoder.newInstance(is, true);
+            } catch (IOException e) {
+                Log.w(LOGTAG, "cannot open region decoder for file: " + mInUri.toString(), e);
+                failure = true;
+                return false;
+            } finally {
+                Utils.closeSilently(is);
+            }
+
+            try {
+                is = regenerateInputStream();
+                if (is != null) {
                 WallpaperManager.getInstance(mContext).suggestDesiredDimensions(mOutWidth, mOutHeight);
                 setWallpaper(is, hint, whichWallpaper);
 
@@ -207,8 +219,9 @@
                 }
 
                 failure = false;
+                }
             } catch (IOException e) {
-                Log.w(LOGTAG, "cannot open region decoder for file: " + mInUri.toString(), e);
+                Log.w(LOGTAG, "cannot set wallpaper for file: " + mInUri.toString(), e);
             } finally {
                 Utils.closeSilently(is);
             }
Index: packages/apps/Launcher3/WallpaperPicker/src/com/android/photos/BitmapRegionTileSource.java
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/src/com/android/photos/BitmapRegionTileSource.java	(revision 173367)
+++ packages/apps/Launcher3/WallpaperPicker/src/com/android/photos/BitmapRegionTileSource.java	(revision 173368)
@@ -94,13 +94,17 @@
     Bitmap mBuffer;
     Canvas mTempCanvas;
     Paint mTempPaint;
-    private DumbBitmapRegionDecoder(Bitmap b) {
+    String mPathName;
+    InputStream mInputStream;
+    private DumbBitmapRegionDecoder(Bitmap b, String pathName, InputStream is) {
         mBuffer = b;
+        mPathName = pathName;
+        mInputStream = is;
     }
     public static DumbBitmapRegionDecoder newInstance(String pathName) {
         Bitmap b = BitmapFactory.decodeFile(pathName);
         if (b != null) {
-            return new DumbBitmapRegionDecoder(b);
+            return new DumbBitmapRegionDecoder(b, pathName, null);
         }
         return null;
     }
@@ -114,16 +118,16 @@
         }
 
         if (b != null) {
-            return new DumbBitmapRegionDecoder(b);
+            return new DumbBitmapRegionDecoder(b, null, is);
         }
         /* @} */
         return null;
     }
     public int getWidth() {
-        return mBuffer.getWidth();
+        return getBitMap().getWidth();
     }
     public int getHeight() {
-        return mBuffer.getHeight();
+        return getBitMap().getHeight();
     }
     public Bitmap decodeRegion(Rect wantRegion, BitmapFactory.Options options) {
         if (mTempCanvas == null) {
@@ -139,11 +143,23 @@
         mTempCanvas.setBitmap(newBitmap);
         mTempCanvas.save();
         mTempCanvas.scale(1f / sampleSize, 1f / sampleSize);
-        mTempCanvas.drawBitmap(mBuffer, -wantRegion.left, -wantRegion.top, mTempPaint);
+        mTempCanvas.drawBitmap(getBitMap(), -wantRegion.left, -wantRegion.top, mTempPaint);
         mTempCanvas.restore();
         mTempCanvas.setBitmap(null);
+        mBuffer.recycle();
         return newBitmap;
     }
+
+      private Bitmap getBitMap() {
+        if (mBuffer.isRecycled()) {
+            if (mInputStream != null) {
+                mBuffer = BitmapFactory.decodeStream(mInputStream);
+            } else if (mPathName != null) {
+                mBuffer = BitmapFactory.decodeFile(mPathName);
+            }
+        }
+        return mBuffer;
+    }
 }
 
 /**
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00_small.png	(revision 173368)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01_small.png	(revision 173368)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_02_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_02_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_02_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_02_small.png	(revision 173368)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_02_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03_small.png	(revision 173368)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04_small.png	(revision 173368)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05_small.png	(revision 173368)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06_small.png	(revision 173368)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00.png	(revision 173368)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01.png	(revision 173368)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_02.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_02.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_02.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_02.png	(revision 173368)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_02.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03.png	(revision 173368)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04.png	(revision 173368)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05.png	(revision 173368)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06.png	(revision 173368)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/values-zh-rCN/strings.xml
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/values-zh-rCN/strings.xml	(revision 173367)
+++ packages/apps/Launcher3/WallpaperPicker/res/values-zh-rCN/strings.xml	(revision 173368)
@@ -38,6 +38,4 @@
     <string name="which_wallpaper_option_home_screen_and_lock_screen" msgid="7652312651094808607">"主屏幕和锁定屏幕"</string>
     <!-- SPRD: 597949 Bugfix Security exception cause set wallpaper fail. -->
     <string name="error_permissions">"此应用缺少运行所需的必要权限。请检查您的权限设置。"</string>
-    <!-- SPRD: bug 599661 Bugfix exception cause set wallpaper fail. -->
-    <string name="do_not_support_format_wallpaper">不支持此格式的图片设置为壁纸。</string>
 </resources>
Index: packages/apps/Launcher3/WallpaperPicker/res/values/strings.xml
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/values/strings.xml	(revision 173367)
+++ packages/apps/Launcher3/WallpaperPicker/res/values/strings.xml	(revision 173368)
@@ -63,6 +63,4 @@
 
     <!-- SPRD: bug 597949 Bugfix Security exception cause set wallpaper fail. -->
     <string name="error_permissions">The app does not have critical permissions needed to run. Please check your permissions settings.</string>
-    <!-- SPRD: bug 599661 Bugfix exception cause set wallpaper fail. -->
-    <string name="do_not_support_format_wallpaper">Do not support the format of the image.</string>
 </resources>
Index: packages/apps/Launcher3/WallpaperPicker/res/values-nodpi/wallpapers.xml
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/values-nodpi/wallpapers.xml	(revision 173367)
+++ packages/apps/Launcher3/WallpaperPicker/res/values-nodpi/wallpapers.xml	(revision 173368)
@@ -17,14 +17,12 @@
 
 <resources>
     <string-array name="wallpapers" translatable="false">
-        /*  SPRD: add for bug515804 add the selection .@{*/
-        <item>wallpaper_00</item>
-        <item>wallpaper_01</item>
-        <item>wallpaper_02</item>
-        <item>wallpaper_03</item>
-        <item>wallpaper_04</item>
-        <item>wallpaper_05</item>
-        <item>wallpaper_06</item>
-        /* @} */
-    </string-array>
+    <item>wallpaper_00</item>
+    <item>wallpaper_01</item>
+    <item>wallpaper_02</item>
+    <item>wallpaper_03</item>
+    <item>wallpaper_04</item>
+    <item>wallpaper_05</item>
+    <item>wallpaper_06</item>
+</string-array>
 </resources>
Index: packages/apps/Launcher3/WallpaperPicker/res/values-zh-rTW/strings.xml
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/values-zh-rTW/strings.xml	(revision 173367)
+++ packages/apps/Launcher3/WallpaperPicker/res/values-zh-rTW/strings.xml	(revision 173368)
@@ -37,6 +37,4 @@
     <string name="which_wallpaper_option_lock_screen" msgid="5474588303389139825">"螢幕鎖定"</string>
     <string name="which_wallpaper_option_home_screen_and_lock_screen" msgid="7652312651094808607">"主畫面和螢幕鎖定"</string>
     <string name="error_permissions">"這個應用程式缺乏必要的關鍵權限，因此無法執行。請檢查您的權限設定。"</string>
-    <!-- SPRD: bug 605557 .-->
-    <string name="do_not_support_format_wallpaper">不支持此格式的圖片設定為壁紙。</string>
 </resources>
Index: packages/apps/Launcher3/Android.mk
===================================================================
--- packages/apps/Launcher3/Android.mk	(revision 173367)
+++ packages/apps/Launcher3/Android.mk	(revision 173368)
@@ -29,10 +29,13 @@
 
 LOCAL_SRC_FILES := $(call all-java-files-under, src) \
     $(call all-java-files-under, WallpaperPicker/src) \
+    $(call all-java-files-under, ext/src) \
+    $(call all-java-files-under, ext/platform/target/src) \
     $(call all-proto-files-under, protos)
 
 LOCAL_RESOURCE_DIR := $(LOCAL_PATH)/WallpaperPicker/res \
     $(LOCAL_PATH)/res \
+    $(LOCAL_PATH)/ext/res \
     frameworks/support/v7/recyclerview/res
 
 LOCAL_PROGUARD_FLAG_FILES := proguard.flags
@@ -43,7 +46,6 @@
     --auto-add-overlay \
     --extra-packages android.support.v7.recyclerview
 
-LOCAL_JAVA_LIBRARIES := sprd-support-addon
 
 #LOCAL_SDK_VERSION := current
 LOCAL_PACKAGE_NAME := Launcher3
Index: packages/apps/Launcher3/src/com/android/launcher3/allapps/AllAppsGridAdapter.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/allapps/AllAppsGridAdapter.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/allapps/AllAppsGridAdapter.java	(revision 173368)
@@ -24,16 +24,14 @@
 import android.graphics.Paint;
 import android.graphics.PointF;
 import android.graphics.Rect;
+import android.support.v4.view.accessibility.AccessibilityEventCompat;
 import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
 import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat.CollectionItemInfoCompat;
 import android.support.v4.view.accessibility.AccessibilityRecordCompat;
-import android.support.v4.view.accessibility.AccessibilityEventCompat;
-import android.net.Uri;
 import android.support.v7.widget.GridLayoutManager;
 import android.support.v7.widget.RecyclerView;
 import android.support.v7.widget.RecyclerView.Recycler;
 import android.support.v7.widget.RecyclerView.State;
-import android.util.Log;
 import android.view.Gravity;
 import android.view.LayoutInflater;
 import android.view.View;
@@ -48,8 +46,8 @@
 import com.android.launcher3.LauncherAppState;
 import com.android.launcher3.R;
 import com.android.launcher3.Utilities;
-import com.sprd.launcher3.utils.DynamicCalendarUtil;
-import com.sprd.launcher3.utils.DynamicDeskClockUtil;
+import com.sprd.ext.FeatureOption;
+
 import java.util.HashMap;
 import java.util.List;
 
@@ -75,10 +73,6 @@
     // The message to continue to a market search when there are no filtered results
     public static final int SEARCH_MARKET_VIEW_TYPE = 5;
 
-    // A Dynamic icon
-    public static final int DYNAMIC_ICON_CALENDAR_TYPE = 7;
-    public static final int DYNAMIC_ICON_CLOCK_TYPE = 8;
-
     public interface BindViewCallback {
         public void onBindView(ViewHolder holder);
     }
@@ -419,14 +413,11 @@
     // The intent to send off to the market app, updated each time the search query changes.
     private Intent mMarketSearchIntent;
 
-    private Context mContext;
-
     public AllAppsGridAdapter(Launcher launcher, AlphabeticalAppsList apps,
             View.OnTouchListener touchListener, View.OnClickListener iconClickListener,
             View.OnLongClickListener iconLongClickListener) {
         Resources res = launcher.getResources();
         mLauncher = launcher;
-        mContext = (Context)launcher;
         mApps = apps;
         mEmptySearchMessage = res.getString(R.string.all_apps_loading_message);
         mGridSizer = new GridSpanSizer();
@@ -524,18 +515,9 @@
         switch (viewType) {
             case SECTION_BREAK_VIEW_TYPE:
                 return new ViewHolder(new View(parent.getContext()));
-            case ICON_VIEW_TYPE:
-            case DYNAMIC_ICON_CALENDAR_TYPE:
-            case DYNAMIC_ICON_CLOCK_TYPE:{
-                int resId = R.layout.all_apps_icon;
-                if (viewType == DYNAMIC_ICON_CALENDAR_TYPE) {
-                    resId = R.layout.apps_customize_application_calendar;
-                }else if (viewType == DYNAMIC_ICON_CLOCK_TYPE){
-                    resId = R.layout.apps_customize_application_clock;
-                }
-
+            case ICON_VIEW_TYPE:{
                 BubbleTextView icon = (BubbleTextView) mLayoutInflater.inflate(
-                        resId, parent, false);
+                        R.layout.all_apps_icon, parent, false);
                 icon.setOnTouchListener(mTouchListener);
                 icon.setOnClickListener(mIconClickListener);
                 icon.setOnLongClickListener(mIconLongClickListener);
@@ -542,6 +524,11 @@
                 icon.setLongPressTimeout(ViewConfiguration.get(parent.getContext())
                         .getLongPressTimeout());
                 icon.setFocusable(true);
+                icon.setTextVisibility(true);
+                if (FeatureOption.SPRD_BGTRANSPARENT_SUPPORT) {
+                    icon.setTextColor(parent.getContext()
+                            .getResources().getColor(R.color.quantum_panel_transparent_text_color));
+                }
                 return new ViewHolder(icon);
             }
             case PREDICTION_ICON_VIEW_TYPE: {
@@ -553,6 +540,10 @@
                 icon.setLongPressTimeout(ViewConfiguration.get(parent.getContext())
                         .getLongPressTimeout());
                 icon.setFocusable(true);
+                if (FeatureOption.SPRD_BGTRANSPARENT_SUPPORT) {
+                    icon.setTextColor(parent.getContext()
+                            .getResources().getColor(R.color.quantum_panel_transparent_text_color));
+                }
                 return new ViewHolder(icon);
             }
             case EMPTY_SEARCH_VIEW_TYPE:
@@ -579,9 +570,7 @@
     @Override
     public void onBindViewHolder(ViewHolder holder, int position) {
         switch (holder.getItemViewType()) {
-            case ICON_VIEW_TYPE:
-            case DYNAMIC_ICON_CALENDAR_TYPE:
-            case DYNAMIC_ICON_CLOCK_TYPE:{
+            case ICON_VIEW_TYPE:{
                 AppInfo info = mApps.getAdapterItems().get(position).appInfo;
                 BubbleTextView icon = (BubbleTextView) holder.mContent;
                 icon.applyFromApplicationInfo(info);
@@ -635,24 +624,6 @@
     @Override
     public int getItemViewType(int position) {
         AlphabeticalAppsList.AdapterItem item = mApps.getAdapterItems().get(position);
-
-        AppInfo info = (AppInfo)item.appInfo;
-        if (info != null
-                && info.getIntent() != null
-                && info.getIntent().getComponent() != null
-                && info.getIntent().getComponent()
-                .equals(Utilities.sCalendarComponentName)
-                && DynamicCalendarUtil.getInstance(mContext).isDynamicCalendar()) {
-            return DYNAMIC_ICON_CALENDAR_TYPE;
-        } else if (info != null
-                && info.getIntent() != null
-                && info.getIntent().getComponent() != null
-                && info.getIntent().getComponent()
-                .equals(Utilities.sDeskClockComponentName)
-                && DynamicDeskClockUtil.getInstance(mContext).isDynamicDeskClock()){
-            return DYNAMIC_ICON_CLOCK_TYPE;
-        }
-
         return item.viewType;
     }
 }
Index: packages/apps/Launcher3/src/com/android/launcher3/allapps/AllAppsFastScrollHelper.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/allapps/AllAppsFastScrollHelper.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/allapps/AllAppsFastScrollHelper.java	(revision 173368)
@@ -225,6 +225,10 @@
                     FastBitmapDrawable.State.FAST_SCROLL_HIGHLIGHTED :
                     FastBitmapDrawable.State.FAST_SCROLL_UNHIGHLIGHTED;
         }
+
+        if (v.isDisabled()) {
+            newState = FastBitmapDrawable.State.DISABLED;
+        }
         v.setFastScrollFocusState(newState, animated);
     }
 }
Index: packages/apps/Launcher3/src/com/android/launcher3/allapps/AlphabeticalAppsList.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/allapps/AlphabeticalAppsList.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/allapps/AlphabeticalAppsList.java	(revision 173368)
@@ -21,12 +21,16 @@
 import com.android.launcher3.AppInfo;
 import com.android.launcher3.Launcher;
 import com.android.launcher3.LauncherAppState;
-import com.android.launcher3.SprdAppSortAddonStub;
 import com.android.launcher3.compat.AlphabeticIndexCompat;
 import com.android.launcher3.compat.UserHandleCompat;
 import com.android.launcher3.model.AppNameComparator;
 import com.android.launcher3.util.ComponentKey;
 
+import com.sprd.ext.customizeappsort.CustomizeAppSort;
+import com.sprd.ext.FeatureOption;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.unreadnotifier.UnreadLoaderUtils;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -323,6 +327,14 @@
      */
     public void updateApps(List<AppInfo> apps) {
         for (AppInfo app : apps) {
+            if (FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
+                app.unreadNum = UnreadLoaderUtils.getUnreadNumberOfComponent(app.componentName);
+                if (LogUtils.DEBUG_UNREAD) {
+                    LogUtils.d(TAG, "updateApps: app.componentName = " + app.componentName
+                            + ",app.unreadNum = " + app.unreadNum);
+                }
+            }
+
             mComponentToAppMap.put(app.toComponentKey(), app);
         }
         onAppsUpdated();
@@ -377,10 +389,10 @@
 
             mApps.clear();
             mApps.addAll(allApps);
-            SprdAppSortAddonStub.getInstance().sortApps(mApps);
+            CustomizeAppSort.getInstance(mLauncher).sortApps(mApps);
         } else {
             // Just compute the section headers for use below
-            SprdAppSortAddonStub.getInstance().sortApps(mApps);
+            CustomizeAppSort.getInstance(mLauncher).sortApps(mApps);
             for (AppInfo info : mApps) {
                 // Add the section to the cache
                 getAndUpdateCachedSectionName(info.title);
Index: packages/apps/Launcher3/src/com/android/launcher3/allapps/AllAppsContainerView.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/allapps/AllAppsContainerView.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/allapps/AllAppsContainerView.java	(revision 173368)
@@ -16,6 +16,7 @@
 package com.android.launcher3.allapps;
 
 import android.annotation.SuppressLint;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Point;
@@ -48,13 +49,12 @@
 import com.android.launcher3.Utilities;
 import com.android.launcher3.Workspace;
 import com.android.launcher3.util.ComponentKey;
+import com.sprd.ext.FeatureOption;
 
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
 import java.util.ArrayList;
 import java.util.List;
-import com.android.launcher3.LauncherAppState;
-import com.android.launcher3.SprdUnreadInfoManager;
 
 
 /**
@@ -445,6 +445,10 @@
         // Return if global dragging is not enabled
         if (!mLauncher.isDraggingEnabled()) return false;
 
+        if (FeatureOption.SPRD_BGTRANSPARENT_SUPPORT) {
+            mLauncher.showWorkspaceSearchAndHotseat();
+        }
+
         // Start the drag
         mLauncher.getWorkspace().beginDragShared(v, mIconLastTouchPos, this, false);
         // Enter spring loaded mode
@@ -609,24 +613,61 @@
         Selection.setSelection(mSearchQueryBuilder, 0);
     }
 
-    public void updateUnreadInfo() {
-        SprdUnreadInfoManager.getInstance().updateUnreadInfo(mLauncher, mApps, this);
+    public void updateAppsUnreadChanged(ComponentName componentName, int unreadNum) {
+        List<AlphabeticalAppsList.AdapterItem> mAdapterItems = mApps.getAdapterItems();
+        final int size = mAdapterItems.size();
+        AlphabeticalAppsList.AdapterItem adapterItem = null;
+        for (int i = 0; i < size; i++) {
+            adapterItem = mAdapterItems.get(i);
+            if (adapterItem.appInfo != null && adapterItem.appInfo.intent != null
+                    && adapterItem.appInfo.intent.getComponent().equals(componentName)) {
+                adapterItem.appInfo.unreadNum = unreadNum;
+            }
+        }
+        // Refresh the recycler view
+        if (mAdapter != null) {
+            mAdapter.notifyDataSetChanged();
+        }
     }
 
+    public void updateAppsDynamicIconChanged(ComponentName componentName) {
+        List<AlphabeticalAppsList.AdapterItem> mAdapterItems = mApps.getAdapterItems();
+        final int size = mAdapterItems.size();
+        AlphabeticalAppsList.AdapterItem adapterItem = null;
+        for (int i = 0; i < size; i++) {
+            adapterItem = mAdapterItems.get(i);
+            if (adapterItem.appInfo != null && adapterItem.appInfo.intent != null
+                    && adapterItem.appInfo.intent.getComponent().equals(componentName)) {
+
+                // Refresh the recycler view
+                if (mAdapter != null) {
+                    mAdapter.notifyItemChanged(i);
+                }
+                break;
+            }
+        }
+    }
+
+    @Override
     protected void onUpdateBackgroundAndPaddings(Rect padding) {
-        // Apply the top-bottom padding to itself so that the launcher transition is
-        // clipped correctly
-        setPadding(0, padding.top, 0, padding.bottom);
+        if (FeatureOption.SPRD_BGTRANSPARENT_SUPPORT) {
+            // Apply the top-bottom padding to itself so that the launcher transition is
+            // clipped correctly
+            setPadding(0, padding.top, 0, padding.bottom);
 
-        mContent.setBackground(null);
-        mRevealView.setBackground(null);
+            mContent.setBackground(null);
+            mRevealView.setBackground(null);
 
-        // We let the content have a intent background, but still have full width.
-        // This allows the scroll bar to be used responsive outside the background bounds as well.
-        mContent.setPadding(0, 0, 0, 0);
+            // We let the content have a intent background, but still have full width.
+            // This allows the scroll bar to be used responsive outside the background bounds as well.
+            mContent.setPadding(0, 0, 0, 0);
 
-        Rect bgPadding = new Rect();
+            Rect bgPadding = new Rect();
 
-        onUpdateBgPadding(padding, bgPadding);
+            onUpdateBgPadding(padding, bgPadding);
+        } else {
+            super.onUpdateBackgroundAndPaddings( padding );
+        }
+
     }
 }
Index: packages/apps/Launcher3/src/com/android/launcher3/LauncherStateTransitionAnimation.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/LauncherStateTransitionAnimation.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/LauncherStateTransitionAnimation.java	(revision 173368)
@@ -34,6 +34,7 @@
 import com.android.launcher3.util.UiThreadCircularReveal;
 import com.android.launcher3.util.Thunk;
 import com.android.launcher3.widget.WidgetsContainerView;
+import com.sprd.ext.FeatureOption;
 
 import java.util.HashMap;
 
@@ -433,7 +434,7 @@
                         // We set the alpha instead of visibility to ensure that the focus does not
                         // get taken from the all apps view
                         allAppsButtonView.setVisibility(View.VISIBLE);
-                        allAppsButtonView.setAlpha(1f);
+                        allAppsButtonView.setAlpha( FeatureOption.SPRD_BGTRANSPARENT_SUPPORT ? 1f : 0f);
                     }
                     public void onAnimationEnd(Animator animation) {
                         // Hide the reveal view
Index: packages/apps/Launcher3/src/com/android/launcher3/Launcher.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/Launcher.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/Launcher.java	(revision 173368)
@@ -16,7 +16,7 @@
 
 package com.android.launcher3;
 
-import android.Manifest.permission;
+import android.Manifest;
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
 import android.animation.AnimatorSet;
@@ -57,6 +57,12 @@
 import android.graphics.Rect;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+import android.media.AudioManager;
+import android.media.MediaPlayer;
 import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.Build;
@@ -67,6 +73,7 @@
 import android.os.StrictMode;
 import android.os.SystemClock;
 import android.os.UserHandle;
+import android.provider.Settings;
 import android.text.Selection;
 import android.text.SpannableStringBuilder;
 import android.text.TextUtils;
@@ -83,9 +90,8 @@
 import android.view.View.OnClickListener;
 import android.view.View.OnLongClickListener;
 import android.view.ViewGroup;
-import android.view.ViewStub;
+import android.view.ViewParent;
 import android.view.ViewTreeObserver;
-import android.view.Window;
 import android.view.WindowManager;
 import android.view.accessibility.AccessibilityEvent;
 import android.view.animation.OvershootInterpolator;
@@ -113,6 +119,17 @@
 import com.android.launcher3.widget.PendingAddWidgetInfo;
 import com.android.launcher3.widget.WidgetHostViewLoader;
 import com.android.launcher3.widget.WidgetsContainerView;
+import com.sprd.PlatformHelper;
+import com.sprd.ext.FeatureOption;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.ShakeSensorDetector;
+import com.sprd.ext.SprdSettingsActivity;
+import com.sprd.ext.circleslide.CircleSlideUtils;
+import com.sprd.ext.dynamicIcon.DynamicIconUtils;
+import com.sprd.ext.predictedapp.PredictedAppController;
+import com.sprd.ext.shakewallpaper.WallpaperChangeController;
+import com.sprd.ext.unreadnotifier.UnreadInfoManager;
+import com.sprd.ext.unreadnotifier.UnreadLoaderUtils;
 
 import java.io.File;
 import java.io.FileDescriptor;
@@ -128,34 +145,24 @@
 import java.util.HashSet;
 import java.util.List;
 
-import com.sprd.launcher3.utils.DynamicCalendarUtil;
-import com.sprd.launcher3.utils.DynamicDeskClockUtil;
-
-import android.app.WallpaperManager;
-import com.sprd.launcher3.utils.SPRDShakeDetector;
-import android.provider.Settings;
-
-import android.hardware.Sensor;
-import android.hardware.SensorEvent;
-import android.hardware.SensorEventListener;
-import android.hardware.SensorManager;
-import android.media.MediaPlayer;
-import android.media.AudioManager; 
 /**
  * Default launcher application.
  */
 public class Launcher extends Activity
         implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,
-                   View.OnTouchListener, PageSwitchListener, LauncherProviderChangeListener, SensorEventListener {
+                   View.OnTouchListener, PageSwitchListener, LauncherProviderChangeListener,
+                   SensorEventListener,
+                   UnreadLoaderUtils.UnreadCallbacks, DynamicIconUtils.DynamicAppChangedCallbacks  {
     static final String TAG = "Launcher";
-    static final boolean LOGD = false;
+    static final boolean LOGD = LogUtils.DEBUG;
 
     static final boolean PROFILE_STARTUP = false;
-    static final boolean DEBUG_WIDGETS = false;
+    static final boolean DEBUG_WIDGETS = LogUtils.DEBUG_WIDGET;
     static final boolean DEBUG_STRICT_MODE = false;
-    static final boolean DEBUG_RESUME_TIME = false;
-    static final boolean DEBUG_DUMP_LOG = false;
+    static final boolean DEBUG_RESUME_TIME = LogUtils.DEBUG_RESUME_TIME;
+    static final boolean DEBUG_DUMP_LOG = LogUtils.DEBUG_DUMP_LOG;
 
+
     static final boolean ENABLE_DEBUG_INTENTS = false; // allow DebugIntents to run
 
     private static final int REQUEST_CREATE_SHORTCUT = 1;
@@ -174,26 +181,7 @@
 
     private static final float BOUNCE_ANIMATION_TENSION = 1.3f;
 
-    private static final int PERMISSION_REQUEST_CODE_CALL_LOG_AND_SMS = 2;
-    private static final int PERMISSION_ALL_ALLOWED = 16;
-    private static final int PERMISSION_ALL_DENYED = 17;
-    public static boolean permissionFlag = false;
 
-	
-	private static final int SPEED_SHRESHOLD = 2;
-    private static final int UPTATE_INTERVAL_TIME = 70;
-    private SensorManager mSensorManager;
-    private Sensor aSensor;
-	private float lastX;
-    private float lastY;
-    private float lastZ;
-	MediaPlayer motionSound;
-	private long lastUpdateTime;
-	private Context yyContext;
-	private boolean noFrist;
-    AudioManager audioManager;
-	
-	
     /**
      * IntentStarter uses request codes starting with this. This must be greater than all activity
      * request codes used internally.
@@ -244,7 +232,22 @@
     private static final String QSB_WIDGET_PROVIDER = "qsb_widget_provider";
 
     public static final String USER_HAS_MIGRATED = "launcher.user_migrated_from_old_data";
+    private static final long UPTATE_INTERVAL_TIME = 70L;
+    private static final int SPEED_SHRESHOLD = 2;
 
+    // don't modify!!!, this value need flow AudioManager.RINGER_MODE_OUTDOOR
+    private static final int RINGER_MODE_OUTDOOR = 3;
+
+    private PredictedAppController mPredictedAppController;
+    private MediaPlayer mMotionSound;
+    private SensorManager mSensorManager;
+    private AudioManager mAudioManager;
+    private long mSensorLastUpdateTime;
+    private boolean mIsFrist;
+    private float lastX;
+    private float lastY;
+    private float lastZ;
+
     /** The different states that Launcher can be in. */
     enum State { NONE, WORKSPACE, APPS, APPS_SPRING_LOADED, WIDGETS, WIDGETS_SPRING_LOADED }
 
@@ -317,7 +320,7 @@
     private boolean mRestoring;
     private boolean mWaitingForResult;
     private boolean mOnResumeNeedsLoad;
-    public final static boolean SUPPORT_PIFLOW = true;//piflow 
+
     // SPRD: bug608160
     private static boolean mWaitingConfigForWidget = false;
 
@@ -356,6 +359,7 @@
 
     private final ArrayList<Integer> mSynchronouslyBoundPages = new ArrayList<Integer>();
     private static final boolean DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE = false;
+    private static final boolean FAST_LOADER = true;
 
     static final ArrayList<String> sDumpLogs = new ArrayList<String>();
     static Date sDateStamp = new Date();
@@ -377,13 +381,6 @@
 
     private DeviceProfile mDeviceProfile;
 
-    /*  SPRD: add for bug515804 add the selection .@{*/
-    private SPRDShakeDetector mDetector;
-    private SPRDShakeDetector.OnShakeListener mListener = null;
-    private int mDefaultWallpaperResId[];
-    private int mDefaultWallpaperNumber;
-    private boolean mWallpaperSwitchEnabledSetting = false;
-    /* @} */
 
     private boolean mMoveToDefaultScreenFromNewIntent;
 
@@ -392,8 +389,6 @@
     // the press state and keep this reference to reset the press state when we return to launcher.
     private BubbleTextView mWaitingForResume;
 
-    private SprdUnreadInfoManager mUnreadInfoManager;
-
     // SPRD:598450 There is a empty screen when roating the screen
     private boolean mHasConfigWidget = false;
     private static final String HASCONFIGWIDGET = "launcher.hasConfigWidget";
@@ -446,7 +441,19 @@
         }
     };
 
-    private PredictedAppController mPredictedAppController;
+    private ShakeSensorDetector mShakeSensorDetector;
+    private WallpaperChangeController mWallpaperChangeController;
+
+    private UnreadLoaderUtils mUnreadLoaderUtils = null;
+    public boolean mUnreadLoadCompleted = false;
+    private boolean mBindingWorkspaceFinished = false;
+    public boolean mBindingAppsFinished = false;
+
+    private DynamicIconUtils mDynamicIconUtils = null;
+    private boolean mDynamicIconLoadCompleted = false;
+    private boolean mBindingWorkspaceCompleted = false;
+    private boolean mBindingAppsCompleted = false;
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         if (DEBUG_STRICT_MODE) {
@@ -463,7 +470,23 @@
                     .penaltyDeath()
                     .build());
         }
-        yyContext = Launcher.this;
+
+        LauncherAppState app = LauncherAppState.getInstance();
+        mModel = app.setLauncher(this);
+        mSharedPrefs = Utilities.getPrefs(this);
+        if (FAST_LOADER) {
+            if (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE) {
+                // If the user leaves launcher, then we should just load items asynchronously when
+                // they return.
+                mModel.startLoader(PagedView.INVALID_RESTORE_PAGE);
+            } else {
+                // We only load the page synchronously if the user rotates (or triggers a
+                // configuration change) while launcher is in the foreground
+                int currentScreen = mSharedPrefs.getInt(RUNTIME_STATE_CURRENT_SCREEN, 0);
+                mModel.startLoader(currentScreen);
+            }
+        }
+
         if (mLauncherCallbacks != null) {
             mLauncherCallbacks.preOnCreate();
         }
@@ -470,13 +493,8 @@
 
         super.onCreate(savedInstanceState);
 
-        LauncherAppState app = LauncherAppState.getInstance();
 
-        if(SprdUnreadInfoManager.sInstance == null ) {
-            Log.d(TAG, "SprdUnreadInfoManager: create and init.");
-            mUnreadInfoManager = new SprdUnreadInfoManager(app);
-            SprdUnreadInfoManager.getInstance().init(app);
-        }
+
         // Load configuration-specific DeviceProfile
         mDeviceProfile = getResources().getConfiguration().orientation
                 == Configuration.ORIENTATION_LANDSCAPE ?
@@ -483,9 +501,7 @@
                 app.getInvariantDeviceProfile().landscapeProfile
                 : app.getInvariantDeviceProfile().portraitProfile;
 
-        mSharedPrefs = Utilities.getPrefs(this);
         mIsSafeModeEnabled = getPackageManager().isSafeMode();
-        mModel = app.setLauncher(this);
         mIconCache = app.getIconCache();
 
         mDragController = new DragController(this);
@@ -492,6 +508,11 @@
         mInflater = getLayoutInflater();
         mStateTransitionAnimation = new LauncherStateTransitionAnimation(this);
 
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "(Launcher)onCreate: savedInstanceState = " + savedInstanceState
+                    + ", mModel = " + mModel + ", mIconCache = " + mIconCache);
+        }
+
         mStats = new Stats(this);
 
         mAppWidgetManager = AppWidgetManagerCompat.getInstance(this);
@@ -516,6 +537,34 @@
         setupViews();
         mDeviceProfile.layout(this);
 
+       if (LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "launcher unread support:" + FeatureOption.SPRD_UNREAD_INFO_SUPPORT);
+        }
+
+        if (FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
+            mUnreadLoaderUtils = UnreadLoaderUtils.getInstance(this);
+
+            // Register unread change broadcast.
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(UnreadLoaderUtils.ACTION_UNREAD_CHANGED);
+            registerReceiver(mUnreadLoaderUtils, filter);
+
+            // initialize unread loader
+            mUnreadLoaderUtils.initialize(this);
+        }
+
+        if (LogUtils.DEBUG_DYNAMIC_ICON) {
+            LogUtils.d(TAG, "launcher dynamic icon support:" + FeatureOption.SPRD_DYNAMIC_ICON_SUPPORT);
+        }
+        if (FeatureOption.SPRD_DYNAMIC_ICON_SUPPORT) {
+            mDynamicIconUtils = DynamicIconUtils.getInstance(getApplicationContext());
+            mDynamicIconUtils.initialize(this);
+        }
+
+        if (FeatureOption.SPRD_PREDICTEDAPP_SUPPORT) {
+            mPredictedAppController = new PredictedAppController(this);
+        }
+
         lockAllApps();
 
         mSavedState = savedInstanceState;
@@ -525,7 +574,7 @@
             android.os.Debug.stopMethodTracing();
         }
 
-        if (!mRestoring) {
+        if (!FAST_LOADER && !mRestoring) {
             if (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE) {
                 // If the user leaves launcher, then we should just load items asynchronously when
                 // they return.
@@ -566,25 +615,36 @@
             showFirstRunClings();
         }
 
-         /*  SPRD: add for bug515804 add the selection .@{*/
-        initDefaultWallpaperResourceId();
-        /* @} */
-		
-		mPredictedAppController = new PredictedAppController(this);
-		mPredictedAppController.initPredictedList();
-		motionSound = MediaPlayer.create(yyContext, R.raw.collision);
-		mSensorManager = (SensorManager) yyContext.getSystemService(Context.SENSOR_SERVICE);
-		audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);   
+        if(FeatureOption.SPRD_SHAKE_CHANGEWALLPAPER_SUPPORT) {
+            mShakeSensorDetector = new ShakeSensorDetector(this);
+            mWallpaperChangeController = new WallpaperChangeController(this);
+        }
+
+        if (FeatureOption.SPRD_MOTION_SOUND_SUPPORT) {
+            mMotionSound = MediaPlayer.create(this, R.raw.collision);
+            mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
+            mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
+            mIsFrist = true;
+        }
     }
 
     @Override
-    public void onSettingsChanged(String settings, boolean value) {
+    public void onSettingsChanged(String settings, Object value) {
         if (Utilities.ALLOW_ROTATION_PREFERENCE_KEY.equals(settings)) {
-            mRotationEnabled = value;
+            mRotationEnabled = (boolean) value;
             if (!waitUntilResume(mUpdateOrientationRunnable, true)) {
                 mUpdateOrientationRunnable.run();
             }
         }
+        //SPRD add for SPRD_CIRCLE_SLIDE_SUPPORT start {
+        if (CircleSlideUtils.PREF_CIRCLE_SLIDE_KEY.equals(settings)) {
+            mWorkspace.setCircleSlideEnabled((boolean)value);
+        }
+        //SPRD: SPRD_CIRCLE_SLIDE_SUPPORT end }
+
+        if(WallpaperChangeController.ALLOW_SHAKE_CHANGE_WALLPAPER_KEY.equals(settings)){
+            mWallpaperChangeController.setShakeWallpaperEnabled((boolean)value);
+        }
     }
 
     private LauncherCallbacks mLauncherCallbacks;
@@ -671,28 +731,8 @@
         if (mLauncherCallbacks != null) {
             return mLauncherCallbacks.hasCustomContentToLeft();
         }
-        //piflow 
-        if(!SUPPORT_PIFLOW){
-            return false;
-        }else{
-            return true;
-        }
+        return FeatureOption.SPRD_PIFLOW_SUPPORT;
     }
-    void showStatusBar(boolean bShow){
-        Window window = getWindow();
-        WindowManager.LayoutParams lp = window.getAttributes();
-        int flag;
-        if(bShow){
-            flag = lp.flags & ~WindowManager.LayoutParams.FLAG_FULLSCREEN;
-        }else{
-            flag = lp.flags | ~WindowManager.LayoutParams.FLAG_FULLSCREEN;
-        }
-        lp.flags = flag;
-        window.setAttributes(lp);
-    }
-    /**
-     * end piflow
-     */
 
     /**
      * To be overridden by subclasses to populate the custom content container and call
@@ -944,6 +984,9 @@
     /** @Override for MNC */
     public void onRequestPermissionsResult(int requestCode, String[] permissions,
             int[] grantResults) {
+        UnreadInfoManager.getInstance(this).handleRequestPermissionResult(
+                permissions, grantResults);
+
         if (requestCode == REQUEST_PERMISSION_CALL_PHONE && sPendingAddItem != null
                 && sPendingAddItem.requestCode == REQUEST_PERMISSION_CALL_PHONE) {
             View v = null;
@@ -962,37 +1005,7 @@
                         getString(R.string.app_name)), Toast.LENGTH_SHORT).show();
             }
         }
-        
-        switch(requestCode) {
-            case PERMISSION_REQUEST_CODE_CALL_LOG_AND_SMS:{
-                for(int i = 0; i < grantResults.length; i++){
-                    if (grantResults.length > 0) {
-                        if( grantResults[i] != PackageManager.PERMISSION_GRANTED){
-                            Log.d(TAG, "1111set permissionFlag is false");
-                            permissionFlag = false;
-                            Toast.makeText(Launcher.this, R.string.unread_misscall_hint, Toast.LENGTH_SHORT).show();
-                            break;
-                        } else {
-                            Log.d(TAG, "1111set permissionFlag is true");
-                            SprdUnreadInfoManager.getInstance().registerContentObservers();
-                            permissionFlag = true;
-                            LauncherAppState.getInstance();
-                            SprdUnreadInfoManager.getInstance().updateUnreadInfoIfNeeded();
-                            mHandler.postDelayed(new Runnable() {
-                                public void run() {
-                                    Log.d(TAG, "delay 200ms");
-                                    updateUnreadInfo();
-                                }
-                            }, 200);
-                        }
-                    }
-                }
-                break;
-            }
 
-            default:
-                break;
-        }
         if (mLauncherCallbacks != null) {
             mLauncherCallbacks.onRequestPermissionsResult(requestCode, permissions,
                     grantResults);
@@ -1072,6 +1085,9 @@
     @Override
     protected void onStop() {
         super.onStop();
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "(Launcher)onStop: this = " + this);
+        }
         FirstFrameAnimatorHelper.setIsVisible(false);
 
         if (mLauncherCallbacks != null) {
@@ -1082,6 +1098,9 @@
     @Override
     protected void onStart() {
         super.onStart();
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "(Launcher)onStart: this = " + this);
+        }
         FirstFrameAnimatorHelper.setIsVisible(true);
 
         if (mLauncherCallbacks != null) {
@@ -1088,101 +1107,10 @@
             mLauncherCallbacks.onStart();
         }
 
-        switch (checkPermission(this)) {
-            case Launcher.PERMISSION_ALL_ALLOWED:
-                Log.d(TAG, "2222 permissionFlag is true");
-                SprdUnreadInfoManager.getInstance().registerContentObservers();
-                permissionFlag = true;
-                break;
-            case Launcher.PERMISSION_ALL_DENYED:
-                permissionFlag = false;
-                if (SprdUnreadInfoManager.getInstance().isUnreadinfoOn()) {
-                    requestPermissions(new String[] { permission.READ_CALL_LOG,
-                            permission.READ_SMS },
-                            PERMISSION_REQUEST_CODE_CALL_LOG_AND_SMS);
-                }
-
-                break;
-            default:
-                break;
-        }
-        if (SprdUnreadInfoManager.getInstance().isUnreadinfoOn() && permissionFlag) {
-            //LauncherAppState.getInstance().getUnreadInfoManager().updateUnreadInfoIfNeeded();
-            SprdUnreadInfoManager.getInstance().updateUnreadInfoIfNeeded();
-        } else {
-            //permission denied
-        }
     }
 
-    /*  SPRD: add for bug515804 add the selection .@{*/
-    private void initDefaultWallpaperResourceId() {
-        String[] extras = Launcher.this.getResources().getStringArray(R.array.wallpapers);
-        mDefaultWallpaperNumber = extras.length;
-        String packageName = getResources().getResourcePackageName(R.array.wallpapers);
-        mDefaultWallpaperResId = new int[mDefaultWallpaperNumber];
-        int j = 0;
-        for (String extra : extras) {
-            mDefaultWallpaperResId[j] = Launcher.this.getResources().getIdentifier(extra, "drawable", packageName);
-            j++;
-        }
-    }
-    /* @} */
-    public void onResumeAppsState(){
-        if(mOnResumeState == State.APPS) {
-            // Restore the previous launcher state
-            boolean launchedFromApp = (mWaitingForResume != null);
-            // Don't update the predicted apps if the user is returning to launcher in the apps
-            // view after launching an app, as they may be depending on the UI to be static to
-            // switch to another app, otherwise, if it was
-            showAppsView(false /* animated */, false /* resetListToTop */,
-                    !launchedFromApp /* updatePredictedApps */, false /* focusSearchBar */);
-            mOnResumeState = State.NONE;
-        }
-    }
-
     @Override
     protected void onResume() {
-        /*  SPRD: add for bug515804 add the selection .@{*/
-        mWallpaperSwitchEnabledSetting = Settings.Global.getInt(getContentResolver(),
-                Settings.Global.SHAKE_TO_SWITCH, 0) != 0;
-        if (mWallpaperSwitchEnabledSetting) {
-            final WallpaperManager wallpaperManager = WallpaperManager.getInstance(Launcher.this);
-            mDetector = new SPRDShakeDetector(this);
-            try {
-                mDetector.start();
-            }catch (Exception e){
-            }
-
-            mListener = new SPRDShakeDetector.OnShakeListener() {
-                int i = 0;
-
-                @Override
-                public void onShake(int direction) {
-                    /*  SPRD: add for bug543554 add the selection .@{*/
-                    if ( mState == State.WORKSPACE) {
-                        if (direction == SPRDShakeDetector.SENSOR_RIGHT_SHAKE) {
-                            i = (i + 1) % mDefaultWallpaperNumber;
-                        } else if (direction == SPRDShakeDetector.SENSOR_LEFT_SHAKE) {
-                            i = (i - 1) % mDefaultWallpaperNumber;
-                            if (i < 0) {
-                                i = mDefaultWallpaperNumber - 1;
-                            }
-                        }
-                        int loadResId;
-                        loadResId = mDefaultWallpaperResId[i];
-                        try {
-                            wallpaperManager.setResource(loadResId);
-                        } catch (IOException e) {
-                            e.printStackTrace();
-                        }
-                    }
-                    /* @} */
-                }
-            };
-            mDetector.registerOnShakeListener(mListener);
-        }
-        /* @} */
-
         long startTime = 0;
         if (DEBUG_RESUME_TIME) {
             startTime = System.currentTimeMillis();
@@ -1189,26 +1117,45 @@
             Log.v(TAG, "Launcher.onResume()");
         }
 
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "(Launcher)onResume: mRestoring = " + mRestoring
+                    + ", mOnResumeNeedsLoad = " + mOnResumeNeedsLoad + ",mOnResumeState = "
+                    + mOnResumeState + ", mState = " + mState);
+        }
+
         if (mLauncherCallbacks != null) {
             mLauncherCallbacks.preOnResume();
         }
 
+        if(mShakeSensorDetector != null
+                && mWallpaperChangeController != null
+                && mWallpaperChangeController.getShakeWallpaperEnabled()) {
+            mShakeSensorDetector.start();
+            mWallpaperChangeController.registerShakeWallpaperListener(mShakeSensorDetector);
+        }
         super.onResume();
 
+        if (mDynamicIconUtils != null) {
+            mDynamicIconUtils.syncResumeState(true);
+        }
+
         // Restore the previous launcher state
-        if(mOnResumeState == State.APPS){
-//            onResumeAppsState();
-        }else {
-            if (mOnResumeState == State.WORKSPACE) {
-                showWorkspace(false);
-            } else if (mOnResumeState == State.WIDGETS) {
-                showWidgetsView(false, false);
-            }
-            mOnResumeState = State.NONE;
+        if (mOnResumeState == State.WORKSPACE) {
+            showWorkspace(false);
+        } else if (mOnResumeState == State.APPS) {
+            boolean launchedFromApp = (mWaitingForResume != null);
+            // Don't update the predicted apps if the user is returning to launcher in the apps
+            // view after launching an app, as they may be depending on the UI to be static to
+            // switch to another app, otherwise, if it was
+            showAppsView(false /* animated */, false /* resetListToTop */,
+                    !launchedFromApp /* updatePredictedApps */, false /* focusSearchBar */);
+        } else if (mOnResumeState == State.WIDGETS) {
+            showWidgetsView(false, false);
         }
+        mOnResumeState = State.NONE;
 
         // Background was set to gradient in onPause(), restore to transparent if in all apps.
-        setWorkspaceBackground(mState == State.WORKSPACE ? WORKSPACE_BACKGROUND_GRADIENT
+        setWorkspaceBackground((mState == State.WORKSPACE || mState == State.WIDGETS_SPRING_LOADED) ? WORKSPACE_BACKGROUND_GRADIENT
                 : WORKSPACE_BACKGROUND_TRANSPARENT);
 
         mPaused = false;
@@ -1222,6 +1169,7 @@
 
             mModel.startLoader(PagedView.INVALID_RESTORE_PAGE);
             mRestoring = false;
+            setWaitingForResult(false);
             mOnResumeNeedsLoad = false;
         }
         if (mBindOnResumeCallbacks.size() > 0) {
@@ -1294,53 +1242,43 @@
         if (mLauncherCallbacks != null) {
             mLauncherCallbacks.onResume();
         }
-        if (mHotseat.getVisibility() == View.INVISIBLE){
+
+        if (!isWorkspaceVisible()){
             mPageIndicators.setVisibility(View.INVISIBLE);
         }
 
-        Log.d(TAG, "isUnreadinfoOn = "
-                + SprdUnreadInfoManager.getInstance().isUnreadinfoOn()
-                + "    permissionFlag = " + permissionFlag);
-        if (SprdUnreadInfoManager.getInstance().isUnreadinfoOn() && permissionFlag) {
-           // LauncherAppState.getInstance().getUnreadInfoManager().prepareUnreadInfo();
-            SprdUnreadInfoManager.getInstance().prepareUnreadInfo();
+        if (FeatureOption.SPRD_BGTRANSPARENT_SUPPORT) {
+            if (isAllAppsVisible()) {
+                hideWorkspaceSearchAndHotseat();
+            } else {
+                showWorkspaceSearchAndHotseat();
+            }
         }
     }
 
-    public static boolean getPermissionFlag(){
-         return permissionFlag;
-    }
-
-    private int checkPermission(Context context) {
-        boolean canReadCallLog = context
-                .checkSelfPermission(permission.READ_CALL_LOG) == PackageManager.PERMISSION_GRANTED;
-        boolean canReadSMS = context
-                .checkSelfPermission(permission.READ_SMS) == PackageManager.PERMISSION_GRANTED;
-        Log.d(TAG, "canReadCallLog = " + canReadCallLog + "   canReadSMS =  " + canReadSMS);
-        if (canReadCallLog && canReadSMS) {
-            return PERMISSION_ALL_ALLOWED;
-        } else {
-            return PERMISSION_ALL_DENYED;
-        }
-    }
-
     @Override
     protected void onPause() {
         // Ensure that items added to Launcher are queued until Launcher returns
         InstallShortcutReceiver.enableInstallQueue();
 
-         /*  SPRD: add for bug515804 add the selection .@{*/
-        if (mDetector != null) {
-            mDetector.unregisterOnShakeListener(mListener);
-            mDetector.stop();
+        super.onPause();
+
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "(Launcher)onPause: this = " + this);
         }
-        /* @} */
-
-        super.onPause();
         mPaused = true;
         mDragController.cancelDrag();
         mDragController.resetLastGestureUpTime();
 
+        if (mDynamicIconUtils != null) {
+            mDynamicIconUtils.syncResumeState(false);
+        }
+
+        if(mShakeSensorDetector != null && mWallpaperChangeController != null) {
+            mWallpaperChangeController.unregisterShakeWallpaperLisener(mShakeSensorDetector);
+            mShakeSensorDetector.stop();
+        }
+
         // We call onHide() aggressively. The custom content callbacks should be able to
         // debounce excess onHide calls.
         if (mWorkspace.getCustomContentCallbacks() != null) {
@@ -1421,9 +1359,7 @@
         if (mLauncherCallbacks != null) {
             return mLauncherCallbacks.hasSettings();
         } else {
-            // On devices with a locked orientation, we will at least have the allow rotation
-            // setting.
-            return !getResources().getBoolean(R.bool.allow_rotation);
+            return true;
         }
     }
 
@@ -1457,13 +1393,17 @@
         if (mLauncherCallbacks != null) {
             mLauncherCallbacks.onWindowFocusChanged(hasFocus);
         }
-		int ringerMode = audioManager.getRingerMode();
-		if(hasFocus && (ringerMode == AudioManager.RINGER_MODE_NORMAL || ringerMode == AudioManager.RINGER_MODE_MAX)){
-            int motion_sound = Settings.System.getInt(getContentResolver(), Settings.System.MOTION_SOUND_EFFECT_ENABLED, 1);
-			if(motion_sound == 1){
-				registerListener();
-			}
-        }else {
+
+        if (mHasFocus) {
+            if (PlatformHelper.isMotionSoundEnable(this)) {
+                if (mAudioManager != null) {
+                    int ringerMode = mAudioManager.getRingerMode();
+                    if (ringerMode == AudioManager.RINGER_MODE_NORMAL || ringerMode == RINGER_MODE_OUTDOOR) {
+                        registerListener();
+                    }
+                }
+            }
+        } else {
             unRegisterListener();
         }
     }
@@ -1479,6 +1419,11 @@
         final int uniChar = event.getUnicodeChar();
         final boolean handled = super.onKeyDown(keyCode, event);
         final boolean isKeyNotWhitespace = uniChar > 0 && !Character.isWhitespace(uniChar);
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, " onKeyDown: KeyCode = " + keyCode + ", KeyEvent = " + event
+                    + ", uniChar = " + uniChar + ", handled = " + handled + ", isKeyNotWhitespace = "
+                    + isKeyNotWhitespace);
+        }
         if (!handled && acceptFilter() && isKeyNotWhitespace) {
             boolean gotKey = TextKeyListener.getInstance().onKeyDown(mWorkspace, mDefaultKeySsb,
                     keyCode, event);
@@ -1516,7 +1461,6 @@
                 if (mState == State.WORKSPACE && !mWorkspace.isInOverviewMode() &&
                         !mWorkspace.isSwitchingState()) {
                     mOverviewPanel.requestFocus();
-					//fix bug for 89803
                     showOverviewMode(true, false /* requestButtonFocus */);
                 } else {
                     showWorkspace(true);
@@ -1571,7 +1515,7 @@
             mOnResumeState = state;
         }
 
-        int currentScreen = savedState.getInt(RUNTIME_STATE_CURRENT_SCREEN,
+        int currentScreen = mSharedPrefs.getInt(RUNTIME_STATE_CURRENT_SCREEN,
                 PagedView.INVALID_RESTORE_PAGE);
         if (currentScreen != PagedView.INVALID_RESTORE_PAGE) {
             mWorkspace.setRestorePage(currentScreen);
@@ -1743,7 +1687,7 @@
      * @param info The data structure describing the shortcut.
      */
     View createShortcut(ShortcutInfo info) {
-        return createShortcut(R.layout.application, (ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentPage()), info);
+        return createShortcut((ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentPage()), info);
     }
 
     /**
@@ -1754,20 +1698,21 @@
      *
      * @return A View inflated from layoutResId.
      */
-    public View createShortcut(int layoutResId, ViewGroup parent, ShortcutInfo info) {
-        if (info.getIntent() != null
-                && info.getIntent().getComponent() != null
-                && info.getIntent().getComponent().equals(Utilities.sCalendarComponentName)
-                && DynamicCalendarUtil.getInstance(Launcher.this).isDynamicCalendar()) {
-            layoutResId = R.layout.application_calendar;
-        } else if (info.getIntent() != null
-                && info.getIntent().getComponent() != null
-                && info.getIntent().getComponent()
-                .equals(Utilities.sDeskClockComponentName)
-                && DynamicDeskClockUtil.getInstance(Launcher.this).isDynamicDeskClock()) {
-            layoutResId = R.layout.application_clock;
+    public View createShortcut(ViewGroup parent, ShortcutInfo info) {
+        BubbleTextView favorite = (BubbleTextView) mInflater.inflate(R.layout.app_icon,
+            parent, false);
+
+        if (mDynamicIconUtils != null && info != null && info.intent != null) {
+            ComponentName cn = info.intent.getComponent();
+            Drawable d = mDynamicIconUtils.getStableBGForComponent(cn);
+            if (d != null) {
+                info.setIcon(Utilities.createIconBitmap(d, Launcher.this));
+                info.dynamicIconDrawCallback = mDynamicIconUtils.getDIDCForComponent(cn);
+                info.customIcon = true;
+                LogUtils.d(TAG, "createShortcut: dynamic icon, intent = " + info.intent);
+            }
         }
-        BubbleTextView favorite = (BubbleTextView) mInflater.inflate(layoutResId, parent, false);
+
         favorite.applyFromShortcutInfo(info, mIconCache);
         favorite.setCompoundDrawablePadding(mDeviceProfile.iconDrawablePaddingPx);
         favorite.setOnClickListener(this);
@@ -1844,6 +1789,10 @@
      */
     @Thunk void completeAddAppWidget(int appWidgetId, long container, long screenId,
             AppWidgetHostView hostView, LauncherAppWidgetProviderInfo appWidgetInfo) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "completeAddAppWidget: appWidgetId = " + appWidgetId
+                    + ", container = " + container + ", screenId = " + screenId);
+        }
 
         ItemInfo info = mPendingAddInfo;
         if (appWidgetInfo == null) {
@@ -2140,6 +2089,10 @@
         }
         super.onNewIntent(intent);
 
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "onNewIntent: intent = " + intent);
+        }
+
         // Close the menu
         Folder openFolder = mWorkspace.getOpenFolder();
         boolean alreadyOnHome = mHasFocus && ((intent.getFlags() &
@@ -2225,6 +2178,10 @@
     @Override
     public void onRestoreInstanceState(Bundle state) {
         super.onRestoreInstanceState(state);
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "onRestoreInstanceState: state = " + state
+                    + ", mSavedInstanceState = " + mSavedInstanceState);
+        }
         for (int page: mSynchronouslyBoundPages) {
             mWorkspace.restoreInstanceStateForChild(page);
         }
@@ -2242,8 +2199,8 @@
         }
 
         if (mWorkspace.getChildCount() > 0) {
-            outState.putInt(RUNTIME_STATE_CURRENT_SCREEN,
-                    mWorkspace.getCurrentPageOffsetFromCustomContent());
+            mSharedPrefs.edit().putInt(RUNTIME_STATE_CURRENT_SCREEN,
+                            mWorkspace.getCurrentPageOffsetFromCustomContent()).apply();
         }
         super.onSaveInstanceState(outState);
 
@@ -2274,8 +2231,10 @@
         if (mLauncherCallbacks != null) {
             mLauncherCallbacks.onSaveInstanceState(outState);
         }
-		
-        mPredictedAppController.savePredictedList();
+
+        if (mPredictedAppController != null) {
+            mPredictedAppController.savePredictedList();
+        }
     }
 
     @Override
@@ -2282,6 +2241,14 @@
     public void onDestroy() {
         super.onDestroy();
 
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "(Launcher)onDestroy: this = " + this);
+        }
+
+        if (mPredictedAppController != null) {
+            mPredictedAppController.savePredictedList();
+        }
+
         // Remove all pending runnables
         mHandler.removeMessages(ADVANCE_MSG);
         mHandler.removeMessages(0);
@@ -2290,6 +2257,11 @@
         // Stop callbacks from LauncherModel
         LauncherAppState app = (LauncherAppState.getInstance());
 
+        if (mDynamicIconUtils != null) {
+            mDynamicIconUtils.destroy();
+            mDynamicIconUtils = null;
+        }
+
         // It's possible to receive onDestroy after a new Launcher activity has
         // been created. In this case, don't interfere with the new Launcher.
         if (mModel.isCurrentCallbacks(this)) {
@@ -2308,6 +2280,9 @@
 
         TextKeyListener.getInstance().release();
 
+        if (mUnreadLoaderUtils != null) {
+            unregisterReceiver( mUnreadLoaderUtils);
+        }
         unregisterReceiver(mCloseSystemDialogsReceiver);
 
         mDragLayer.clearAllResizeFrames();
@@ -2323,15 +2298,18 @@
         mDragController = null;
 
         LauncherAnimUtils.onDestroyActivity();
-        mPredictedAppController.savePredictedList();
 
         if (mLauncherCallbacks != null) {
             mLauncherCallbacks.onDestroy();
         }
-		
-		unRegisterListener();
-		motionSound.stop();
-        motionSound.release();
+
+
+        unRegisterListener();
+        if (mMotionSound != null) {
+            mMotionSound.stop();
+            mMotionSound.release();
+            mMotionSound = null;
+        }
     }
 
     public DragController getDragController() {
@@ -2523,6 +2501,11 @@
     void addAppWidgetImpl(final int appWidgetId, final ItemInfo info,
             final AppWidgetHostView boundWidget, final LauncherAppWidgetProviderInfo appWidgetInfo,
             int delay) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "addAppWidgetImpl: appWidgetId = " + appWidgetId
+                    + ", info = " + info + ", boundWidget = " + boundWidget
+                    + ", appWidgetInfo = " + appWidgetInfo + ", delay = " + delay);
+        }
         if (appWidgetInfo.configure != null) {
             mPendingAddWidgetInfo = appWidgetInfo;
             mPendingAddWidgetId = appWidgetId;
@@ -2583,6 +2566,10 @@
      */
     private void processShortcutFromDrop(ComponentName componentName, long container, long screenId,
             int[] cell) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "processShortcutFromDrop componentName = " + componentName + ", container = " + container
+                    + ", screenId = " + screenId);
+        }
         resetAddInfo();
         mPendingAddInfo.container = container;
         mPendingAddInfo.screenId = screenId;
@@ -2608,6 +2595,10 @@
      */
     private void addAppWidgetFromDrop(PendingAddWidgetInfo info, long container, long screenId,
             int[] cell, int[] span) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "addAppWidgetFromDrop: info = " + info + ", container = " + container + ", screenId = "
+                    + screenId);
+        }
         resetAddInfo();
         mPendingAddInfo.container = info.container = container;
         mPendingAddInfo.screenId = info.screenId = screenId;
@@ -2665,7 +2656,11 @@
     FolderIcon addFolder(CellLayout layout, long container, final long screenId, int cellX,
             int cellY) {
         final FolderInfo folderInfo = new FolderInfo();
-        folderInfo.title = getText(R.string.folder_name);
+        if(FeatureOption.SPRD_DEFAULT_FOLDER_NAME_SUPPORT){
+            folderInfo.title = "";
+        }else{
+            folderInfo.title = getText(R.string.folder_name);
+        }
 
         // Update the model
         LauncherModel.addItemToDatabase(Launcher.this, folderInfo, container, screenId,
@@ -2774,6 +2769,9 @@
 
     @Override
     public void onBackPressed() {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "Back key pressed, mState = " + mState + ", mOnResumeState = " + mOnResumeState);
+        }
         if (mLauncherCallbacks != null && mLauncherCallbacks.handleBackPressed()) {
             return;
         }
@@ -2785,6 +2783,9 @@
 
         if (isAppsViewVisible()) {
             showWorkspace(true);
+            if (FeatureOption.SPRD_BGTRANSPARENT_SUPPORT) {
+                showWorkspaceSearchAndHotseat();
+            }
         } else if (isWidgetsViewVisible())  {
             showOverviewMode(true);
         } else if (mWorkspace.isInOverviewMode()) {
@@ -3022,6 +3023,7 @@
 
         boolean success = startActivitySafely(v, intent, tag);
         mStats.recordLaunch(v, intent, shortcut);
+        intent.setSourceBounds(null);
 
         if (success && v instanceof BubbleTextView) {
             mWaitingForResume = (BubbleTextView) v;
@@ -3126,11 +3128,11 @@
         if (mLauncherCallbacks != null) {
             mLauncherCallbacks.onClickSettingsButton(v);
         } else {
-		//	fix for bug 91003 by zhangchi start 
-           // startActivity(new Intent(this, SettingsActivity.class));
-		   Intent intent =  new Intent(Settings.ACTION_SETTINGS);  
-           startActivity(intent);
-		//	fix for bug 91003 by zhangchi end 
+            if(FeatureOption.SPRD_SETTINGS_ACTIVITY_SUPPORT){
+                startActivity(new Intent(this, SprdSettingsActivity.class));
+            }else{
+                startActivity(new Intent(Settings.ACTION_SETTINGS));
+            }
         }
     }
 
@@ -3283,9 +3285,15 @@
                             R.anim.task_open_enter, R.anim.no_anim);
                 }
                 optsBundle = opts != null ? opts.toBundle() : null;
+                //Bug 661753 add for animation
+                optsBundle = PlatformHelper.overrideOptsBundle(v, optsBundle, null);
             }
 
-            if (user == null || user.equals(UserHandleCompat.myUserHandle())) {
+            if (user == null) {
+                user = UserHandleCompat.myUserHandle();
+            }
+            if (LOGD) LogUtils.d(TAG, "startActivity:" + intent.toString() + " user:" + user.toString());
+            if (user.equals(UserHandleCompat.myUserHandle())) {
                 StrictMode.VmPolicy oldPolicy = StrictMode.getVmPolicy();
                 try {
                     // Temporarily disable deathPenalty on all default checks. For eg, shortcuts
@@ -3300,8 +3308,18 @@
                 }
             } else {
                 // TODO Component can be null when shortcuts are supported for secondary user
-                launcherApps.startActivityForProfile(intent.getComponent(), user,
-                        intent.getSourceBounds(), optsBundle);
+                try {
+                    if (intent.getComponent() != null && !PlatformHelper.isAppCloneUser(user.getUser())) {
+                        launcherApps.startActivityForProfile(intent.getComponent(), user,
+                                intent.getSourceBounds(), optsBundle);
+                    } else {
+                        PlatformHelper.startActivityAsUser(this, intent, optsBundle, user.getUser());
+                    }
+                } catch (ActivityNotFoundException e) {
+                    LogUtils.w(TAG, "activity not found.intent:" + intent.toString());
+                    Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
+                    return false;
+                }
             }
             return true;
         } catch (SecurityException e) {
@@ -3311,12 +3329,12 @@
                 // is the case.
                 if (intent.getComponent() == null
                         && Intent.ACTION_CALL.equals(intent.getAction())
-                        && checkSelfPermission(permission.CALL_PHONE) !=
+                        && checkSelfPermission(Manifest.permission.CALL_PHONE) !=
                             PackageManager.PERMISSION_GRANTED) {
                     // TODO: Rename sPendingAddItem to a generic name.
                     sPendingAddItem = preparePendingAddArgs(REQUEST_PERMISSION_CALL_PHONE, intent,
                             0, (ItemInfo) tag);
-                    requestPermissions(new String[]{permission.CALL_PHONE},
+                    requestPermissions(new String[]{Manifest.permission.CALL_PHONE},
                             REQUEST_PERMISSION_CALL_PHONE);
                     return false;
                 }
@@ -3338,6 +3356,9 @@
         }
         try {
             success = startActivity(v, intent, tag);
+            if (mPredictedAppController != null && success) {
+                mPredictedAppController.updatePredictedList(intent.getComponent());
+            }
         } catch (ActivityNotFoundException e) {
             if (v instanceof TextView){
                 return success;
@@ -3345,12 +3366,6 @@
             Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
             Log.e(TAG, "Unable to launch. tag=" + tag + " intent=" + intent, e);
         }
-        if(success){
-            ComponentName cn = intent.getComponent();
-            if(cn != null) {
-                mPredictedAppController.updatePredictedList(cn);
-            }
-        }
         return success;
     }
 
@@ -3520,13 +3535,17 @@
     public void closeFolder(Folder folder, boolean animate) {
         folder.getInfo().opened = false;
 
-        ViewGroup parent = (ViewGroup) folder.getParent().getParent();
-        if (parent != null) {
+        ViewParent viewParent = folder.getParent();
+        if(viewParent != null && viewParent.getParent() != null) {
             FolderIcon fi = (FolderIcon) mWorkspace.getViewForTag(folder.mInfo);
             shrinkAndFadeInFolderIcon(fi, animate);
             if (fi != null) {
                 ((CellLayout.LayoutParams) fi.getLayoutParams()).canReorder = true;
             }
+        }else{
+            if(LOGD) {
+                Log.d(TAG, "closeFolder, folder = "+ folder);
+            }
         }
         if (animate) {
             folder.animateClosed();
@@ -3635,6 +3654,10 @@
         return (mState == State.WIDGETS) || (mOnResumeState == State.WIDGETS);
     }
 
+    public boolean isWorkspaceVisible() {
+        return (mState == State.WORKSPACE) || (mOnResumeState == State.WORKSPACE);
+    }
+
     private void setWorkspaceBackground(int background) {
         switch (background) {
             case WORKSPACE_BACKGROUND_TRANSPARENT:
@@ -3700,6 +3723,9 @@
      * @return whether or not the Launcher state changed.
      */
     boolean showWorkspace(int snapToPage, boolean animated, Runnable onCompleteRunnable) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "showWorkspace: animated = " + animated + ", mState = " + mState);
+        }
         boolean changed = mState != State.WORKSPACE ||
                 mWorkspace.getState() != Workspace.State.NORMAL;
         if (changed) {
@@ -3769,6 +3795,9 @@
      */
     void showAppsView(boolean animated, boolean resetListToTop, boolean updatePredictedApps,
             boolean focusSearchBar) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "showAllApps: animated = " + animated + ", mState = " + mState + ", focusSearchBar = "+ focusSearchBar);
+        }
         if (resetListToTop) {
             mAppsView.scrollToTop();
         }
@@ -3864,6 +3893,10 @@
 
     public void exitSpringLoadedDragModeDelayed(final boolean successfulDrop, int delay,
             final Runnable onCompleteRunnable) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "exitSpringLoadedDragModeDelayed successfulDrop = " + successfulDrop + ", delay = "
+                    + delay + ", mState = " + mState);
+        }
         if (mState != State.APPS_SPRING_LOADED && mState != State.WIDGETS_SPRING_LOADED) return;
 
         mHandler.postDelayed(new Runnable() {
@@ -3885,6 +3918,9 @@
     }
 
     void exitSpringLoadedDragMode() {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "exitSpringLoadedDragMode mState = " + mState);
+        }
         if (mState == State.APPS_SPRING_LOADED) {
             showAppsView(true /* animated */, false /* resetListToTop */,
                     false /* updatePredictedApps */, false /* focusSearchBar */);
@@ -3898,15 +3934,15 @@
      * resumed.
      */
     private void tryAndUpdatePredictedApps() {
-        if(mPredictedAppController !=  null){
-            List<ComponentKey> apps = mPredictedAppController.getCurrentPredictedList();
-            if (apps != null && !apps.isEmpty()) {
+        if (mLauncherCallbacks != null) {
+            List<ComponentKey> apps = mLauncherCallbacks.getPredictedApps();
+            if (apps != null) {
                 mAppsView.setPredictedApps(apps);
             }
-        }else{
-            if (mLauncherCallbacks != null) {
-                List<ComponentKey> apps = mLauncherCallbacks.getPredictedApps();
-                if (apps != null) {
+        } else {
+            if (mPredictedAppController !=  null) {
+                List<ComponentKey> apps = mPredictedAppController.getCurrentPredictedList();
+                if (apps != null && !apps.isEmpty()) {
                     mAppsView.setPredictedApps(apps);
                 }
             }
@@ -3926,7 +3962,6 @@
     }
 
     public View getOrCreateQsbBar() {
-        if (true) return null;
         if (launcherCallbacksProvidesSearch()) {
             return mLauncherCallbacks.getQsbBar();
         }
@@ -4125,6 +4160,9 @@
      */
     public void startBinding() {
         setWorkspaceLoading(true);
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "startBinding: this = " + this);
+        }
 
         // If we're starting binding all over again, clear any bind calls we'd postponed in
         // the past (see waitUntilResume) -- we don't need them since we're starting binding
@@ -4170,6 +4208,10 @@
                               final ArrayList<ItemInfo> addNotAnimated,
                               final ArrayList<ItemInfo> addAnimated,
                               final ArrayList<AppInfo> addedApps) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "bindAppsAdded: " + Log.getStackTraceString(new Throwable())
+                    +", addedApps = " + addedApps);
+        }
         Runnable r = new Runnable() {
             public void run() {
                 bindAppsAdded(newScreens, addNotAnimated, addAnimated, addedApps);
@@ -4228,6 +4270,10 @@
         long newShortcutsScreenId = -1;
         for (int i = start; i < end; i++) {
             final ItemInfo item = shortcuts.get(i);
+            if (LogUtils.DEBUG_ALL) {
+                LogUtils.d(TAG, "bindItems: start = " + start + ", end = " + end
+                        + "item = " + item + ", this = " + this);
+            }
 
             // Short circuit if we are loading dock items for a configuration which has no dock
             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT &&
@@ -4316,6 +4362,9 @@
      * Implementation of the method from LauncherModel.Callbacks.
      */
     public void bindFolders(final LongArrayMap<FolderInfo> folders) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "bindFolders: this = " + this);
+        }
         Runnable r = new Runnable() {
             public void run() {
                 bindFolders(folders);
@@ -4497,6 +4546,9 @@
      * Implementation of the method from LauncherModel.Callbacks.
      */
     public void finishBindingItems() {
+        if (LogUtils.DEBUG) {
+            LogUtils.d(TAG, "finishBindingItems: mSavedState = " + mSavedState + ", mSavedInstanceState = " + mSavedInstanceState);
+        }
         Runnable r = new Runnable() {
             public void run() {
                 finishBindingItems();
@@ -4516,6 +4568,7 @@
 
         setWorkspaceLoading(false);
         sendLoadingCompleteBroadcastIfNecessary();
+        if (LogUtils.DEBUG_LOADER)LogUtils.d(TAG, "WorkspaceLoading Complete");
 
         // If we received the result of any pending adds while the loader was running (e.g. the
         // widget configuration forced an orientation change), process them now.
@@ -4542,6 +4595,20 @@
         }
         /* @} */
 
+        if (FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
+            if (mUnreadLoadCompleted) {
+                bindWorkspaceUnreadInfo();
+            }
+            mBindingWorkspaceFinished = true;
+        }
+
+        if (FeatureOption.SPRD_DYNAMIC_ICON_SUPPORT) {
+            if (mDynamicIconLoadCompleted) {
+                bindWorkspaceDynamicInfo();
+            }
+            mBindingWorkspaceCompleted = true;
+        }
+
         if (mLauncherCallbacks != null) {
             mLauncherCallbacks.finishBindingItems(false);
         }
@@ -4628,11 +4695,18 @@
      * Implementation of the method from LauncherModel.Callbacks.
      */
     public void bindAllApplications(final ArrayList<AppInfo> apps) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "bindAllApplications: apps.size = " + apps.size());
+        }
         if (waitUntilResume(mBindAllApplicationsRunnable, true)) {
             mTmpAppsList = apps;
             return;
         }
 
+        if (mDynamicIconUtils != null) {
+            mDynamicIconUtils.updateDIDCInAppInfo(apps);
+        }
+
         if (mAppsView != null) {
             mAppsView.setApps(apps);
         }
@@ -4647,6 +4721,9 @@
      * Implementation of the method from LauncherModel.Callbacks.
      */
     public void bindAppsUpdated(final ArrayList<AppInfo> apps) {
+        if (LogUtils.DEBUG) {
+            LogUtils.d(TAG, "bindAppsUpdated: apps = " + apps);
+        }
         Runnable r = new Runnable() {
             public void run() {
                 bindAppsUpdated(apps);
@@ -4736,6 +4813,10 @@
     public void bindWorkspaceComponentsRemoved(
             final HashSet<String> packageNames, final HashSet<ComponentName> components,
             final UserHandleCompat user) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "bindComponentsRemoved: " + Log.getStackTraceString(new Throwable())+
+                    ", packageNames = " + packageNames);
+        }
         Runnable r = new Runnable() {
             public void run() {
                 bindWorkspaceComponentsRemoved(packageNames, components, user);
@@ -4769,8 +4850,10 @@
         // Update AllApps
         if (mAppsView != null) {
             mAppsView.removeApps(appInfos);
+            if (mPredictedAppController != null) {
+                mPredictedAppController.removeAppsFromPredicteList(appInfos);
+            }
         }
-        mPredictedAppController.removeAppsFromPredicteList(appInfos);
     }
 
     private Runnable mBindWidgetModelRunnable = new Runnable() {
@@ -5013,7 +5096,7 @@
         }
     }
 
-    void showWorkspaceSearchAndHotseat() {
+    public void showWorkspaceSearchAndHotseat() {
         if (mWorkspace != null) mWorkspace.setAlpha(1f);
         if (mHotseat != null) mHotseat.setAlpha(1f);
         if (mPageIndicators != null) mPageIndicators.setAlpha(1f);
@@ -5232,34 +5315,170 @@
             return Collections.EMPTY_LIST;
         }
     }
-    
-    public void updateUnreadInfo() {
 
-        if (mWorkspace != null) {
-            mWorkspace.updateUnreadInfo();
+    /**SPRD: Added for unread badge feature.@{**/
+
+    /**
+     * SPRD: Bind component unread information in workspace and all apps list.
+     *
+     * @param component the component name of the app.
+     * @param unreadNum the number of the unread message.
+     */
+    public void bindComponentUnreadChanged(final ComponentName component, final int unreadNum) {
+        if (LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "bindComponentUnreadChanged: component = " + component
+                    + ", unreadNum = " + unreadNum + ", this = " + this);
         }
+        // Post to message queue to avoid possible ANR.
+        mHandler.post(new Runnable() {
+            public void run() {
+                final long start = System.currentTimeMillis();
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindComponentUnreadChanged begin: component = " + component
+                            + ", unreadNum = " + unreadNum + ", start = " + start);
+                }
 
-        if (mAppsView != null) {
-            mAppsView.updateUnreadInfo();
+                mUnreadLoaderUtils.bindComponentUnreadChanged(component, unreadNum);
+
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindComponentUnreadChanged end: current time = "
+                            + System.currentTimeMillis() + ", time used = "
+                            + (System.currentTimeMillis() - start));
+                }
+            }
+        });
+    }
+
+    /**
+     * SPRD: Bind shortcuts unread number if binding process has finished.
+     */
+    public void bindUnreadInfoIfNeeded() {
+        if (LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "bindUnreadInfoIfNeeded: mBindingWorkspaceFinished = "
+                    + mBindingWorkspaceFinished + ", mBindingAppsFinished: "+mBindingAppsFinished +", thread = " + Thread.currentThread());
         }
+        if (mBindingWorkspaceFinished) {
+            bindWorkspaceUnreadInfo();
+        }
 
-        /*LauncherAppState.getInstance().getUnreadInfoManager()
-                .resetComponentsUnreadInfoChangedValue();*/
-        SprdUnreadInfoManager.getInstance().resetComponentsUnreadInfoChangedValue();
+        if (mBindingAppsFinished) {
+            bindAppsUnreadInfo();
+        }
+        mUnreadLoadCompleted = true;
     }
-	
-	
-	
-	@Override
+
+    /**
+     * SPRD: Bind unread number to shortcuts with data in UnreadLoaderUtils.
+     */
+    private void bindWorkspaceUnreadInfo() {
+        mHandler.post(new Runnable() {
+            public void run() {
+                final long start = System.currentTimeMillis();
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindWorkspaceUnreadInfo begin: start = " + start);
+                }
+                mUnreadLoaderUtils.updateShortcutsAndFoldersUnread();
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindWorkspaceUnreadInfo end: current time = "
+                            + System.currentTimeMillis() + ",time used = "
+                            + (System.currentTimeMillis() - start));
+                }
+            }
+        });
+    }
+
+    /**
+     * SPRD: Bind unread number to shortcuts with data in UnreadLoaderUtils.
+     */
+    private void bindAppsUnreadInfo() {
+        mHandler.post(new Runnable() {
+            public void run() {
+                final long start = System.currentTimeMillis();
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindAppsUnreadInfo begin: start = " + start);
+                }
+              //  mUnreadLoaderUtils.updateAppsUnread(); //Update AllApps Unread if needed.
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindAppsUnreadInfo end: current time = "
+                            + System.currentTimeMillis() + ",time used = "
+                            + (System.currentTimeMillis() - start));
+                }
+            }
+        });
+    }
+    /**@}**/
+
+
+    /**SPRD: Added for dynamic icon feature.@{**/
+
+    /**
+     * SPRD: Bind component draw callback of the dynamic icon in workspace.
+     *
+     * @param component the component name of the app.
+     */
+    public void bindComponentDynamicIconChanged(final ComponentName component) {
+        mHandler.post(new Runnable() {
+            public void run() {
+                final long start = System.currentTimeMillis();
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindComponentDynamicIconChanged begin: component = " + component
+                            + ", start = " + start);
+                }
+
+                mDynamicIconUtils.updateComponentDynamicIconChanged(component);
+
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindComponentDynamicIconChanged end: current time = "
+                            + System.currentTimeMillis() + ", time used = "
+                            + (System.currentTimeMillis() - start));
+                }
+            }
+        });
+    }
+
+    public void bindDynamicIconIfNeeded() {
+        if (LogUtils.DEBUG_DYNAMIC_ICON) {
+            LogUtils.d(TAG, "bindDynamicIconIfNeeded: mBindingWorkspaceCompleted = "
+                    + mBindingWorkspaceCompleted + ", thread = " + Thread.currentThread());
+        }
+        if (mBindingWorkspaceCompleted) {
+            bindWorkspaceDynamicInfo();
+        }
+        if (mBindingAppsCompleted) {
+            // bind dynamic icon info that in the all app container if needed
+        }
+        mDynamicIconLoadCompleted = true;
+    }
+
+    private void bindWorkspaceDynamicInfo() {
+        mHandler.post(new Runnable() {
+            public void run() {
+                final long start = System.currentTimeMillis();
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindWorkspaceDynamicInfo begin: start = " + start);
+                }
+
+                mDynamicIconUtils.updateShortcutsAndFoldersDynamicIcon();
+
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindWorkspaceDynamicInfo end: current time = "
+                            + System.currentTimeMillis() + ",time used = "
+                            + (System.currentTimeMillis() - start));
+                }
+            }
+        });
+    }
+
+    @Override
     public void onSensorChanged(SensorEvent event) {
         int sensorType = event.sensor.getType();
         if (sensorType == Sensor.TYPE_ACCELEROMETER) {
             long currentUpdateTime = System.currentTimeMillis();
-            long timeInterval = currentUpdateTime - lastUpdateTime;
+            long timeInterval = currentUpdateTime - mSensorLastUpdateTime;
             if(timeInterval < UPTATE_INTERVAL_TIME){
                 return;
             }
-            lastUpdateTime = currentUpdateTime;
+            mSensorLastUpdateTime = currentUpdateTime;
             float x = event.values[0];
             float y = event.values[1];
             float z = event.values[2];
@@ -5270,16 +5489,19 @@
             lastX = x;
             lastY = y;
             lastZ = z;
-			
+
             double speed = deltaX + deltaY + deltaZ;
-			if(noFrist && mHotseat != null && mHotseat.getVisibility() == View.VISIBLE && mHotseat.getAlpha()== 1f && speed > SPEED_SHRESHOLD){
-				onSound();
-				
-			}
-			
-			if(!noFrist){
-				noFrist = true;
-			}
+            
+            if (mIsFrist) {
+                mIsFrist = false;
+            } else {
+                if (isWorkspaceVisible() && speed > SPEED_SHRESHOLD) {
+                    if (mMotionSound != null) {
+                        mMotionSound.start();
+                        if (LogUtils.DEBUG) LogUtils.d(TAG, "mMotionSound is started");
+                    }
+                }
+            }
         }
     }
 
@@ -5287,27 +5509,17 @@
     public void onAccuracyChanged(Sensor sensor, int accuracy) {
 
     }
-	
-	
-	private void onSound() {
-        if (motionSound == null){
-            motionSound = MediaPlayer.create(yyContext, R.raw.collision);
-        }
-		motionSound.start();
 
-    }
-	 public void registerListener(){
-
-        mSensorManager = (SensorManager) yyContext.getSystemService(Context.SENSOR_SERVICE);
-        if(mSensorManager!=null){
-            aSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
-            if(aSensor != null){
-                mSensorManager.registerListener(this, aSensor, SensorManager.SENSOR_DELAY_NORMAL);
+    private void registerListener(){
+        if(mSensorManager != null) {
+            Sensor sensor = mSensorManager.getDefaultSensor( Sensor.TYPE_ACCELEROMETER );
+            if(sensor != null){
+                mSensorManager.registerListener(this, sensor, SensorManager.SENSOR_DELAY_NORMAL);
             }
         }
     }
 
-    public void unRegisterListener() {
+    private void unRegisterListener() {
         if (mSensorManager != null)
             mSensorManager.unregisterListener(this);
     }
Index: packages/apps/Launcher3/src/com/android/launcher3/LauncherAppState.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/LauncherAppState.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/LauncherAppState.java	(revision 173368)
@@ -121,7 +121,6 @@
         launcherApps.removeOnAppsChangedCallback(mModel);
         PackageInstallerCompat.getInstance(sContext).onStop();
 
-        SprdUnreadInfoManager.getInstance().terminate();
     }
 
     /**
@@ -137,8 +136,6 @@
         getLauncherProvider().setLauncherProviderChangeListener(launcher);
         mModel.initialize(launcher);
 
-        SprdUnreadInfoManager.getInstance().bindLauncher(launcher);
-
         mAccessibilityDelegate = ((launcher != null) && Utilities.ATLEAST_LOLLIPOP) ?
             new LauncherAccessibilityDelegate(launcher) : null;
         return mModel;
Index: packages/apps/Launcher3/src/com/android/launcher3/FolderPagedView.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/FolderPagedView.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/FolderPagedView.java	(revision 173368)
@@ -36,8 +36,6 @@
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
-import com.sprd.launcher3.utils.DynamicCalendarUtil;
-import com.sprd.launcher3.utils.DynamicDeskClockUtil;
 
 public class FolderPagedView extends PagedView {
 
@@ -55,7 +53,6 @@
 
     // This value approximately overshoots to 1.5 times the original size.
     private static final float PAGE_INDICATOR_OVERSHOOT_TENSION = 4.9f;
-    private Context mContext;
 
     /**
      * Fraction of the width to scroll when showing the next page hint.
@@ -72,8 +69,9 @@
     @Thunk final HashMap<View, Runnable> mPendingAnimations = new HashMap<>();
 
     private final int mMaxCountX;
-    private final int mMaxCountY;
-    private final int mMaxItemsPerPage;
+    private int mMaxCountY;
+    private int mMaxItemsPerPage;
+    private final int mFolderMaxNumRows;
 
     private int mAllocatedContentSize;
     private int mGridCountX;
@@ -88,11 +86,12 @@
     public FolderPagedView(Context context, AttributeSet attrs) {
         super(context, attrs);
         LauncherAppState app = LauncherAppState.getInstance();
-        mContext = context;
         InvariantDeviceProfile profile = app.getInvariantDeviceProfile();
         mMaxCountX = profile.numFolderColumns;
         mMaxCountY = profile.numFolderRows;
 
+        mFolderMaxNumRows = profile.numFolderRows;
+
         mMaxItemsPerPage = mMaxCountX * mMaxCountY;
 
         mInflater = LayoutInflater.from(context);
@@ -111,6 +110,16 @@
         mPageIndicator = (PageIndicator) folder.findViewById(R.id.folder_page_indicator);
     }
 
+    private void updateFolderMaxNumRows(){
+        DeviceProfile grid = mFolder.mLauncher.getDeviceProfile();
+        if(mFolderMaxNumRows * grid.folderCellHeightPx > mFolder.getMaxContentAreaHeight()){
+            mMaxCountY = mFolderMaxNumRows - 1;
+        }else{
+            mMaxCountY = mFolderMaxNumRows;
+        }
+        mMaxItemsPerPage = mMaxCountX * mMaxCountY;
+    }
+
     /**
      * Sets up the grid size such that {@param count} items can fit in the grid.
      * The grid size is calculated such that countY <= countX and countX = ceil(sqrt(count)) while
@@ -117,6 +126,7 @@
      * maintaining the restrictions of {@link #mMaxCountX} &amp; {@link #mMaxCountY}.
      */
     private void setupContentDimensions(int count) {
+        updateFolderMaxNumRows();
         mAllocatedContentSize = count;
         boolean done;
         if (count >= mMaxItemsPerPage) {
@@ -211,21 +221,8 @@
 
     @SuppressLint("InflateParams")
     public View createNewView(ShortcutInfo item) {
-        int layoutResId = R.layout.folder_application;
-        if (item.getIntent() != null
-                && item.getIntent().getComponent() != null
-                && item.getIntent().getComponent().equals(Utilities.sCalendarComponentName)
-                && DynamicCalendarUtil.getInstance(mContext).isDynamicCalendar()){
-            layoutResId = R.layout.folder_application_calendar;
-        }else if (item.getIntent() != null
-                && item.getIntent().getComponent() != null
-                && item.getIntent().getComponent().equals(Utilities.sDeskClockComponentName)
-                && DynamicDeskClockUtil.getInstance(mContext).isDynamicDeskClock()) {
-            layoutResId = R.layout.folder_application_clock;
-        }
-
         final BubbleTextView textView = (BubbleTextView) mInflater.inflate(
-                layoutResId, null, false);
+                R.layout.folder_application, null, false);
         textView.applyFromShortcutInfo(item, mIconCache);
         textView.setOnClickListener(mFolder);
         textView.setOnLongClickListener(mFolder);
Index: packages/apps/Launcher3/src/com/android/launcher3/ItemInfo.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/ItemInfo.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/ItemInfo.java	(revision 173368)
@@ -24,6 +24,8 @@
 import com.android.launcher3.compat.UserHandleCompat;
 import com.android.launcher3.compat.UserManagerCompat;
 
+import com.sprd.ext.dynamicIcon.DynamicIcon.DynamicIconDrawCallback;
+
 import java.util.Arrays;
 
 /**
@@ -121,6 +123,12 @@
 
     public UserHandleCompat user;
 
+    //SPRD:Added for unread feature
+    public int unreadNum = 0;
+
+    //SPRD:Added for dynamic icon feature
+    public DynamicIconDrawCallback dynamicIconDrawCallback;
+
     public ItemInfo() {
         user = UserHandleCompat.myUserHandle();
     }
@@ -142,7 +150,9 @@
         itemType = info.itemType;
         container = info.container;
         user = info.user;
+        dynamicIconDrawCallback = info.dynamicIconDrawCallback;
         contentDescription = info.contentDescription;
+        unreadNum = info.unreadNum;
     }
 
     public Intent getIntent() {
@@ -194,7 +204,8 @@
     public String toString() {
         return "Item(id=" + this.id + " type=" + this.itemType + " container=" + this.container
             + " screen=" + screenId + " cellX=" + cellX + " cellY=" + cellY + " spanX=" + spanX
-            + " spanY=" + spanY + " dropPos=" + Arrays.toString(dropPos)
+            + " spanY=" + spanY + " dropPos=" + Arrays.toString(dropPos) + " unreadNum=" + unreadNum
+            + " dynamicIconDrawCallback=" + dynamicIconDrawCallback
             + " user=" + user + ")";
     }
 
Index: packages/apps/Launcher3/src/com/android/launcher3/LauncherProvider.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/LauncherProvider.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/LauncherProvider.java	(revision 173368)
@@ -57,6 +57,8 @@
 import com.android.launcher3.util.ManagedProfileHeuristic;
 import com.android.launcher3.util.Thunk;
 
+import com.sprd.ext.LogUtils;
+
 import java.net.URISyntaxException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -65,7 +67,7 @@
 
 public class LauncherProvider extends ContentProvider {
     private static final String TAG = "LauncherProvider";
-    private static final boolean LOGD = false;
+    private static final boolean LOGD = LogUtils.DEBUG;
 
     private static final int DATABASE_VERSION = 26;
 
@@ -291,6 +293,26 @@
                 result.putBoolean(LauncherSettings.Settings.EXTRA_VALUE, value);
                 return result;
             }
+            case LauncherSettings.Settings.METHOD_GET_STRING:{
+                Bundle result = new Bundle();
+                result.putString(LauncherSettings.Settings.EXTRA_VALUE,
+                        Utilities.getPrefs(getContext()).getString(arg, extras.getString(
+                                        LauncherSettings.Settings.EXTRA_DEFAULT_VALUE)));
+                return result;
+            }
+            case LauncherSettings.Settings.METHOD_SET_STRING:{
+                String value = extras.getString(LauncherSettings.Settings.EXTRA_VALUE);
+                Utilities.getPrefs(getContext()).edit().putString(arg, value).apply();
+                if (mListener != null) {
+                    mListener.onSettingsChanged(arg, value);
+                }
+                if (extras.getBoolean(LauncherSettings.Settings.NOTIFY_BACKUP)) {
+                    LauncherBackupAgentHelper.dataChanged(getContext());
+                }
+                Bundle result = new Bundle();
+                result.putString(LauncherSettings.Settings.EXTRA_VALUE, value);
+                return result;
+            }
         }
         return null;
     }
Index: packages/apps/Launcher3/src/com/android/launcher3/LauncherModel.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/LauncherModel.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/LauncherModel.java	(revision 173368)
@@ -32,6 +32,7 @@
 import android.content.pm.ResolveInfo;
 import android.database.Cursor;
 import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
 import android.net.Uri;
 import android.os.Handler;
 import android.os.HandlerThread;
@@ -63,6 +64,9 @@
 import com.android.launcher3.util.StringFilter;
 import com.android.launcher3.util.Thunk;
 
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.foldername.FolderNameUtils;
+
 import java.lang.ref.WeakReference;
 import java.net.URISyntaxException;
 import java.security.InvalidParameterException;
@@ -84,8 +88,8 @@
  */
 public class LauncherModel extends BroadcastReceiver
         implements LauncherAppsCompat.OnAppsChangedCallbackCompat {
-    static final boolean DEBUG_LOADERS = false;
-    private static final boolean DEBUG_RECEIVER = false;
+    static final boolean DEBUG_LOADERS = LogUtils.DEBUG_LOADER;
+    private static final boolean DEBUG_RECEIVER = LogUtils.DEBUG_RECEIVER;
     private static final boolean REMOVE_UNRESTORED_ICONS = true;
 
     static final String TAG = "Launcher.Model";
@@ -206,7 +210,6 @@
         public boolean isAllAppsButtonRank(int rank);
         public void onPageBoundSynchronously(int page);
         public void dumpLogsToLocalData();
-        public void onResumeAppsState();
     }
 
     public interface ItemInfoFilter {
@@ -213,6 +216,10 @@
         public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
     }
 
+    public interface ItemInfoFilterForNoCn {
+        public boolean filterItemForNoCn(ItemInfo parent, ItemInfo info);
+    }
+
     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
         Context context = app.getContext();
 
@@ -1268,6 +1275,7 @@
         final String action = intent.getAction();
         if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
             // If we have changed locale we need to clear out the labels in all apps/workspace.
+            UserManagerCompat.getInstance(context).enableAndResetCache();
             forceReload();
         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action)) {
             Callbacks callbacks = getCallback();
@@ -1364,9 +1372,15 @@
                 if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
                         && mAllAppsLoaded && mWorkspaceLoaded && !mIsLoaderTaskRunning) {
                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
+                    if (DEBUG_LOADERS) {
+                        LogUtils.d(TAG, "startLoader, runBindSynchronousPage:" + synchronousBindPage);
+                    }
                 } else {
-                    sWorkerThread.setPriority(Thread.NORM_PRIORITY);
+                    sWorkerThread.setPriority(Thread.MAX_PRIORITY);
                     sWorker.post(mLoaderTask);
+                    if (DEBUG_LOADERS) {
+                        LogUtils.d(TAG, "startLoader, post mLoaderTask");
+                    }
                 }
             }
         }
@@ -1489,7 +1503,8 @@
                     try {
                         // Just in case mFlushingWorkerThread changes but we aren't woken up,
                         // wait no longer than 1sec at a time
-                        this.wait(1000);
+                        if (LogUtils.DEBUG_LOADER)  LogUtils.d(TAG, "waitForIdle,  we aren't woken up");
+                        this.wait(500);
                     } catch (InterruptedException ex) {
                         // Ignore
                     }
@@ -1539,9 +1554,6 @@
         }
 
         public void run() {
-            if (SprdUnreadInfoManager.getInstance().isUnreadinfoOn() && Launcher.permissionFlag) {
-                SprdUnreadInfoManager.getInstance().prepareUnreadInfo();
-            }
             synchronized (mLock) {
                 if (mStopped) {
                     return;
@@ -1578,16 +1590,6 @@
                 mIsLoaderTaskRunning = false;
                 mHasLoaderCompletedOnce = true;
             }
-            // Process onResumeAppsState after workspace loaded
-            final Callbacks callbacks = getCallback();
-            mHandler.post(new Runnable() {
-                public void run() {
-                    Callbacks cb = getCallback();
-                    if (callbacks == cb && cb != null) {
-                        callbacks.onResumeAppsState();
-                    }
-                }
-            });
         }
 
         public void stopLocked() {
@@ -2054,9 +2056,13 @@
                                     info.rank = c.getInt(rankIndex);
                                     info.spanX = 1;
                                     info.spanY = 1;
-                                    info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
+                                    if (!info.intent.hasExtra(ItemInfo.EXTRA_PROFILE)) {
+                                        info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
+                                    }
                                     if (info.promisedIntent != null) {
-                                        info.promisedIntent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
+                                        if (!info.promisedIntent.hasExtra(ItemInfo.EXTRA_PROFILE)) {
+                                            info.promisedIntent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
+                                        }
                                     }
                                     info.isDisabled |= disabledState;
                                     if (isSafeMode && !Utilities.isSystemApp(context, intent)) {
@@ -2113,6 +2119,7 @@
                                 folderInfo.spanX = 1;
                                 folderInfo.spanY = 1;
                                 folderInfo.options = c.getInt(optionsIndex);
+                                FolderNameUtils.updateFolderTitle(mContext,folderInfo);
 
                                 // check & update map of what's occupied
                                 if (!checkItemPlacement(occupied, folderInfo, sBgWorkspaceScreens)) {
@@ -2776,6 +2783,9 @@
                 Log.w(TAG, "LoaderTask running with no launcher (onlyBindAllApps)");
                 return;
             }
+            if (LogUtils.DEBUG_ALL) {
+                LogUtils.d(TAG, "onlyBindAllApps: oldCallbacks =" + oldCallbacks + ", this = " + this);
+            }
 
             // shallow copy
             @SuppressWarnings("unchecked")
@@ -2828,7 +2838,7 @@
                 // Fail if we don't have any apps
                 // TODO: Fix this. Only fail for the current user.
                 if (apps == null || apps.isEmpty()) {
-                    return;
+                    continue;
                 }
                 boolean quietMode = mUserManager.isQuietModeEnabled(user);
                 // Create the ApplicationInfos
@@ -3212,6 +3222,15 @@
                                 if (si.isDisabled != oldDisabledFlags) {
                                     shortcutUpdated = true;
                                 }
+                            } else {
+                                //remove no component itmes, when item is not valid(eg. email app 1*1 widget)
+                                if (!isValidItem(context,si, mUser)) {
+                                    if (DEBUG_LOADERS) {
+                                        Log.d(TAG, "invalid item, removed:" + si.toString());
+                                    }
+                                    removedShortcuts.add(si);
+                                    continue;
+                                }
                             }
 
                             if (infoUpdated || shortcutUpdated) {
@@ -3466,13 +3485,13 @@
             UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,
             boolean allowMissingTarget, boolean useLowResIcon) {
         if (user == null) {
-            Log.d(TAG, "Null user found in getShortcutInfo");
+            Log.d(TAG, "Null user found in getAppShortcutInfo");
             return null;
         }
 
         ComponentName componentName = intent.getComponent();
         if (componentName == null) {
-            Log.d(TAG, "Missing component found in getShortcutInfo");
+            Log.d(TAG, "Missing component found in getAppShortcutInfo");
             return null;
         }
 
@@ -3481,7 +3500,7 @@
         newIntent.setComponent(componentName);
         LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
         if ((lai == null) && !allowMissingTarget) {
-            Log.d(TAG, "Missing activity found in getShortcutInfo: " + componentName);
+            Log.d(TAG, "Missing activity found in getAppShortcutInfo: " + componentName);
             return null;
         }
 
@@ -3544,6 +3563,55 @@
         return new ArrayList<ItemInfo>(filtered);
     }
 
+    static boolean isValidItem(Context context,ItemInfo item, UserHandleCompat user) {
+        if (item != null) {
+            ComponentName cn = null;
+            if (item instanceof ShortcutInfo) {
+                cn = ((ShortcutInfo)item).getTargetComponent();
+            } else if (item instanceof LauncherAppWidgetInfo) {
+                cn = ((LauncherAppWidgetInfo)item).providerName;
+            }
+            if (cn != null) {
+                return isValidPackageActivity(context, cn, user);
+            } else {
+                PackageManager manager = context.getPackageManager();
+                final List<ResolveInfo> activities = manager.queryIntentActivities(item.getIntent(),
+                    PackageManager.MATCH_DEFAULT_ONLY);
+                return activities.size() > 0;
+            }
+        }
+        return false;
+    }
+
+    static ArrayList<ItemInfo> filterItemInfosForNoCn(Iterable<ItemInfo> infos,
+                                               ItemInfoFilterForNoCn f) {
+        HashSet<ItemInfo> filtered = new HashSet<ItemInfo>();
+        for (ItemInfo i : infos) {
+            if (i instanceof ShortcutInfo) {
+                ShortcutInfo info = (ShortcutInfo) i;
+                ComponentName cn = info.getTargetComponent();
+                if (cn == null && f.filterItemForNoCn(null, info)) {
+                    filtered.add(info);
+                }
+            } else if (i instanceof FolderInfo) {
+                FolderInfo info = (FolderInfo) i;
+                for (ShortcutInfo s : info.contents) {
+                    ComponentName cn = s.getTargetComponent();
+                    if (cn == null && f.filterItemForNoCn(info, s)) {
+                        filtered.add(s);
+                    }
+                }
+            } else if (i instanceof LauncherAppWidgetInfo) {
+                LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
+                ComponentName cn = info.providerName;
+                if (cn == null && f.filterItemForNoCn(null, info)) {
+                    filtered.add(info);
+                }
+            }
+        }
+        return new ArrayList<ItemInfo>(filtered);
+    }
+
     @Thunk ArrayList<ItemInfo> getItemInfoForComponentName(final ComponentName cname,
             final UserHandleCompat user) {
         ItemInfoFilter filter  = new ItemInfoFilter() {
@@ -3597,9 +3665,17 @@
         Bitmap icon = null;
         boolean customIcon = false;
         ShortcutIconResource iconResource = null;
+        UserHandleCompat launchUser = UserHandleCompat.fromIntent(data);
+        if (launchUser == null) {
+            launchUser = UserHandleCompat.myUserHandle();
+        } else {
+            long userId = UserManagerCompat.getInstance(context).getSerialNumberForUser(launchUser);
+            intent.putExtra(ShortcutInfo.EXTRA_PROFILE, userId);
+        }
 
         if (bitmap instanceof Bitmap) {
-            icon = Utilities.createIconBitmap((Bitmap) bitmap, context);
+            icon = Utilities.createBadgedIconBitmap(
+                    new BitmapDrawable(context.getResources(), (Bitmap) bitmap), launchUser, context);
             customIcon = true;
         } else {
             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
@@ -3606,7 +3682,7 @@
             if (extra instanceof ShortcutIconResource) {
                 iconResource = (ShortcutIconResource) extra;
                 icon = Utilities.createIconBitmap(iconResource.packageName,
-                        iconResource.resourceName, context);
+                        iconResource.resourceName, launchUser, context);
             }
         }
 
@@ -3616,7 +3692,7 @@
         // users wouldn't get here without intent forwarding anyway.
         info.user = UserHandleCompat.myUserHandle();
         if (icon == null) {
-            icon = mIconCache.getDefaultIcon(info.user);
+            icon = mIconCache.getDefaultIcon(launchUser);
             info.usingFallbackIcon = true;
         }
         info.setIcon(icon);
@@ -3683,7 +3759,4 @@
     public static Looper getWorkerLooper() {
         return sWorkerThread.getLooper();
     }
-    public ArrayList<AppInfo> getAllAppsList(){
-        return mBgAllAppsList.data;
-    }
 }
Index: packages/apps/Launcher3/src/com/android/launcher3/LauncherSettings.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/LauncherSettings.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/LauncherSettings.java	(revision 173368)
@@ -322,6 +322,9 @@
         public static final String METHOD_GET_BOOLEAN = "get_boolean_setting";
         public static final String METHOD_SET_BOOLEAN = "set_boolean_setting";
 
+        public static final String METHOD_GET_STRING = "get_string_setting";
+        public static final String METHOD_SET_STRING = "set_string_setting";
+
         public static final String EXTRA_VALUE = "value";
         public static final String EXTRA_DEFAULT_VALUE = "default_value";
 
Index: packages/apps/Launcher3/src/com/android/launcher3/StartupReceiver.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/StartupReceiver.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/StartupReceiver.java	(revision 173368)
@@ -3,8 +3,13 @@
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
+
+import com.sprd.ext.FeatureOption;
+import com.sprd.ext.root.RootBootLoader;
+import com.sprd.ext.root.RootUtil;
 import android.os.SystemProperties;
 
+
 public class StartupReceiver extends BroadcastReceiver {
 
     static final String SYSTEM_READY = "com.android.launcher3.SYSTEM_READY";
@@ -12,9 +17,11 @@
     @Override
     public void onReceive(Context context, Intent intent) {
         context.sendStickyBroadcast(new Intent(SYSTEM_READY));
-        if (RootUtil.isDeviceRooted() || SystemProperties.get("ro.boot.flash.locked").equals("0")) {
-            Intent it = new Intent(context, RootBootLoader.class);
-            context.startActivity(it);
+        if(FeatureOption.SPRD_ROOT_WARINING_SUPPORT){
+            if (RootUtil.isDeviceRooted()|| SystemProperties.get("ro.boot.flash.locked").equals("0")) {
+                Intent it = new Intent(context, RootBootLoader.class);
+                context.startActivity(it);
+            }
         }
     }
 }
Index: packages/apps/Launcher3/src/com/android/launcher3/LauncherProviderChangeListener.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/LauncherProviderChangeListener.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/LauncherProviderChangeListener.java	(revision 173368)
@@ -9,7 +9,7 @@
 
     public void onLauncherProviderChange();
 
-    public void onSettingsChanged(String settings, boolean value);
+    public void onSettingsChanged(String settings, Object value);
 
     public void onAppWidgetHostReset();
 }
Index: packages/apps/Launcher3/src/com/android/launcher3/AppInfo.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/AppInfo.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/AppInfo.java	(revision 173368)
@@ -28,6 +28,8 @@
 import com.android.launcher3.util.ComponentKey;
 import com.android.launcher3.util.PackageManagerHelper;
 
+import com.sprd.ext.dynamicIcon.DynamicIconUtils;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 
@@ -89,6 +91,7 @@
             IconCache iconCache, boolean quietModeEnabled) {
         this.componentName = info.getComponentName();
         this.container = ItemInfo.NO_ID;
+        this.dynamicIconDrawCallback = DynamicIconUtils.getInstance(context).getDIDCForComponent(this.componentName);
         flags = initFlags(info);
         if (PackageManagerHelper.isAppSuspended(info.getApplicationInfo())) {
             isDisabled |= ShortcutInfo.FLAG_DISABLED_SUSPENDED;
@@ -118,6 +121,7 @@
     public AppInfo(AppInfo info) {
         super(info);
         componentName = info.componentName;
+        dynamicIconDrawCallback = info.dynamicIconDrawCallback;
         title = Utilities.trim(info.title);
         intent = new Intent(info.intent);
         flags = info.flags;
@@ -131,6 +135,7 @@
                 + " type=" + this.itemType + " container=" + this.container
                 + " screen=" + screenId + " cellX=" + cellX + " cellY=" + cellY
                 + " spanX=" + spanX + " spanY=" + spanY + " dropPos=" + Arrays.toString(dropPos)
+                + " dynamicIconDrawCallback=" + dynamicIconDrawCallback
                 + " user=" + user + ")";
     }
 
Index: packages/apps/Launcher3/src/com/android/launcher3/util/ManagedProfileHeuristic.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/util/ManagedProfileHeuristic.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/util/ManagedProfileHeuristic.java	(revision 173368)
@@ -19,11 +19,7 @@
 import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.SharedPreferences;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.PackageManager.NameNotFoundException;
 import android.os.Build;
-import android.util.Log;
 
 import com.android.launcher3.FolderInfo;
 import com.android.launcher3.ItemInfo;
@@ -38,6 +34,7 @@
 import com.android.launcher3.compat.LauncherAppsCompat;
 import com.android.launcher3.compat.UserHandleCompat;
 import com.android.launcher3.compat.UserManagerCompat;
+import com.sprd.PlatformHelper;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -163,6 +160,11 @@
      * Adds and binds shortcuts marked to be added to the work folder.
      */
     private void finalizeWorkFolder() {
+        /* Modify for bug628090 */
+        if (PlatformHelper.isAppCloneUser(mUser.getUser())) {
+            return;
+        }
+
         if (mWorkFolderApps.isEmpty()) {
             return;
         }
Index: packages/apps/Launcher3/src/com/android/launcher3/Workspace.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/Workspace.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/Workspace.java	(revision 173368)
@@ -55,15 +55,12 @@
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewGroup;
-import android.webkit.WebView;
-import android.view.Gravity;
-import android.widget.FrameLayout;
 import android.view.accessibility.AccessibilityManager;
-import android.view.animation.AccelerateInterpolator;
 import android.view.animation.DecelerateInterpolator;
 import android.view.animation.Interpolator;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
 import android.widget.TextView;
-import android.webkit.WebViewClient;
 
 import com.android.launcher3.FolderIcon.FolderRingAnimator;
 import com.android.launcher3.Launcher.CustomContentCallbacks;
@@ -81,12 +78,17 @@
 import com.android.launcher3.util.WallpaperUtils;
 import com.android.launcher3.widget.PendingAddShortcutInfo;
 import com.android.launcher3.widget.PendingAddWidgetInfo;
+import com.sprd.ext.FeatureOption;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.UtilitiesExt;
+import com.sprd.ext.circleslide.CircleSlideUtils;
+import com.sprd.ext.dynamicIcon.DynamicIconUtils;
+import com.sprd.ext.unreadnotifier.UnreadLoaderUtils;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.concurrent.atomic.AtomicInteger;
-import android.webkit.WebView;
 
 /**
  * The workspace is a wide area with a wallpaper and a finite number of pages.
@@ -184,6 +186,7 @@
     private SpringLoadedDragController mSpringLoadedDragController;
     private float mSpringLoadedShrinkFactor;
     private float mOverviewModeShrinkFactor;
+    private ViewGroup piflow;
 
     // State variable that indicates whether the pages are small (ie when you're
     // in all apps or customize mode)
@@ -444,12 +447,6 @@
      * Initializes various states for this workspace.
      */
     protected void initWorkspace() {
-        //piflow
-        if(Launcher.SUPPORT_PIFLOW){
-            Context context = getContext();
-            PiflowUntil.saveConfig(context);
-        }
-        //end piflow
         mCurrentPage = mDefaultPage;
         LauncherAppState app = LauncherAppState.getInstance();
         DeviceProfile grid = mLauncher.getDeviceProfile();
@@ -472,76 +469,20 @@
         setWallpaperDimension();
 
         setEdgeGlowColor(getResources().getColor(R.color.workspace_edge_effect_color));
-    }
-    /**
-     * piflow
-     */
-    private ViewGroup piflow = null;
-    public View getPiflow(){
-
-        WebView piflowView = null;
-        try{
-            LayoutInflater inflater = LayoutInflater.from(mLauncher);
-            piflowView = (WebView)inflater.inflate(R.layout.web_view, null);
-            piflowView.loadUrl("https://www.google.com");
-            piflowView.setWebViewClient(new WebViewClient(){
-            @Override
-            public boolean shouldOverrideUrlLoading(WebView view, String url) {
-                view.loadUrl(url);
-                return true;
+        // SPRD add for SPRD_SETTINGS_ACTIVITY_SUPPORT strat {
+        if(FeatureOption.SPRD_CIRCLE_SLIDE_SUPPORT){
+            if(mLauncher.hasCustomContentToLeft()) {
+                CircleSlideUtils.setHasCustomContent(mLauncher,true);
+                mIsEnableCircular = false;
+                LogUtils.d(TAG,"hasCustomContentToLeft is ture disable mIsEnableCircular!");
+            }else{
+                //when has CustomContent, remove Circle slide
+                mIsEnableCircular = CircleSlideUtils.isCircleSlideEnabled(mLauncher);
             }
-        });
-        } catch(Exception e) {
-            e.printStackTrace();
         }
-        return piflowView;
+        //SPRD SPRD_SETTINGS_ACTIVITY_SUPPORT end }
     }
 
-    private void initPiflow(CellLayout cellLayout){
-        Log.d(TAG, "zly --> initPiflow.");
-        try{
-            piflow = (ViewGroup)getPiflow();
-            if(piflow!=null){
-                cellLayout.addPiflowView(piflow);
-                cellLayout.setPiflow(true);
-            }
-        }catch(Exception e){
-            e.printStackTrace();
-        }
-    }
-    private void removePiflow(){
-        try{
-            if(piflow!=null){
-                piflow.removeAllViews();
-            }
-        }catch(Exception e){
-            e.printStackTrace();
-        }
-    }
-    private void changeCurrentPageBottomBar(int whichPage){
-        CellLayout cell = (CellLayout)getChildAt(whichPage);
-        if(cell.isPiflow()){
-            showBotoomBar(false);
-            //mLauncher.showStatusBar(false);
-        }else{
-            showBotoomBar(true);
-            //mLauncher.showStatusBar(true);
-        }
-    }
-    private void showBotoomBar(boolean flag){
-        if(flag){
-            mLauncher.showWorkspaceSearchAndHotseat();
-            mLauncher.getHotseat().setVisibility(View.VISIBLE);
-        }else{
-            mLauncher.hideWorkspaceSearchAndHotseat();
-            mLauncher.getHotseat().setVisibility(View.GONE);
-        }
-    }
-    /**
-     * end piflow
-     */
-
-
     private void setupLayoutTransition() {
         // We want to show layout transitions when pages are deleted, to close the gap.
         mLayoutTransition = new LayoutTransition();
@@ -683,8 +624,8 @@
         } else {
             setCurrentPage(getCurrentPage() + 1);
         }
-        //piflow
-        if(Launcher.SUPPORT_PIFLOW) {
+
+        if (FeatureOption.SPRD_PIFLOW_SUPPORT) {
             initPiflow(customScreen);
         }
     }
@@ -694,10 +635,10 @@
         if (customScreen == null) {
             throw new RuntimeException("Expected custom content screen to exist");
         }
-        //piflow
-        if(Launcher.SUPPORT_PIFLOW) {
+
+        if (FeatureOption.SPRD_PIFLOW_SUPPORT) {
             removePiflow();
-         }
+        }
 
         mWorkspaceScreens.remove(CUSTOM_CONTENT_SCREEN_ID);
         mScreenOrder.remove(CUSTOM_CONTENT_SCREEN_ID);
@@ -1531,12 +1472,10 @@
         }
         mDelayedSnapToPageRunnable = r;
         snapToPage(whichPage, duration);
-        //piflow
-        if(Launcher.SUPPORT_PIFLOW){
+
+        if (FeatureOption.SPRD_PIFLOW_SUPPORT) {
             changeCurrentPageBottomBar(whichPage);
         }
-        //end piflow
-
     }
 
     public void snapToScreenId(long screenId) {
@@ -1646,6 +1585,17 @@
             } else {
                 // Sometimes the left parameter of the pages is animated during a layout transition;
                 // this parameter offsets it to keep the wallpaper from animating as well
+                    // SPRD add for SPRD_SETTINGS_ACTIVITY_SUPPORT strat {
+                    if (mIsEnableCircular) {
+                        if (scroll < 0) {
+                            // here we assume that one page occupied width is equals to view port's width.
+                            scroll = Math.abs(scroll * (lastIndex - firstIndex));
+                        } else if (scroll > scrollRange) {
+                            scroll = scrollRange - (scroll - scrollRange) * Math.abs((lastIndex - firstIndex));
+                        }
+                    }
+                    // SPRD add for SPRD_SETTINGS_ACTIVITY_SUPPORT end }
+
                 int adjustedScroll =
                         scroll - firstPageScrollX - getLayoutTransitionOffsetForPage(0);
                 float offset = Math.min(1, adjustedScroll / (float) scrollRange);
@@ -1850,13 +1800,13 @@
         // We should only update the drag layer background alpha if we are not in all apps or the
         // widgets tray
         if (mState == State.NORMAL) {
-           // mLauncher.getDragLayer().setBackgroundAlpha(progress == 1 ? 0 : progress * 0.8f);//piflow
+            mLauncher.getDragLayer().setBackgroundAlpha(progress == 1 ? 0 : progress * 0.8f);
         }
 
         if (mLauncher.getHotseat() != null) {
             mLauncher.getHotseat().setTranslationX(translationX);
         }
-        //piflow
+
         if (mLauncher.getSearchDropTargetBar() != null) {
             mLauncher.getSearchDropTargetBar().setTranslationX(translationX);
         }
@@ -2343,6 +2293,22 @@
         return null;
     }
 
+    private static boolean isOriginalIconView(View v) {
+        if (v instanceof TextView) {
+            if (v instanceof BubbleTextView) {
+                if (UnreadLoaderUtils.shouldDrawUnreadInfo(v)) {
+                    return false;
+                }
+
+                if (DynamicIconUtils.isDynamicIconView(v)) {
+                    return false;
+                }
+            }
+            return true;
+        }
+        return false;
+    }
+
     /**
      * Draw the View v into the given Canvas.
      *
@@ -2357,7 +2323,7 @@
         boolean textVisible = false;
 
         destCanvas.save();
-        if (v instanceof TextView) {
+        if (isOriginalIconView(v)) {
             Drawable d = getTextViewIcon((TextView) v);
             Rect bounds = getDrawableBounds(d);
             clipRect.set(0, 0, bounds.width() + padding, bounds.height() + padding);
@@ -2372,6 +2338,13 @@
                     textVisible = true;
                 }
             }
+
+            if (v instanceof BubbleTextView) {
+                if (((BubbleTextView) v).isTextVisible()) {
+                    ((BubbleTextView) v).setTextVisibility(false);
+                    textVisible = true;
+                }
+            }
             destCanvas.translate(-v.getScrollX() + padding / 2, -v.getScrollY() + padding / 2);
             destCanvas.clipRect(clipRect, Op.REPLACE);
             v.draw(destCanvas);
@@ -2378,7 +2351,13 @@
 
             // Restore text visibility of FolderIcon if necessary
             if (textVisible) {
-                ((FolderIcon) v).setTextVisible(true);
+                if (v instanceof FolderIcon) {
+                    ((FolderIcon) v).setTextVisible(true);
+                }
+
+                if (v instanceof BubbleTextView) {
+                    ((BubbleTextView) v).setTextVisibility(true);
+                }
             }
         }
         destCanvas.restore();
@@ -2394,7 +2373,7 @@
         Bitmap b;
 
         int padding = expectedPadding.get();
-        if (v instanceof TextView) {
+        if (isOriginalIconView(v)) {
             Drawable d = getTextViewIcon((TextView) v);
             Rect bounds = getDrawableBounds(d);
             b = Bitmap.createBitmap(bounds.width() + padding,
@@ -3761,7 +3740,7 @@
                     // Came from all apps -- make a copy
                     info = ((AppInfo) info).makeShortcut();
                 }
-                view = mLauncher.createShortcut(R.layout.application, cellLayout, (ShortcutInfo) info);
+                view = mLauncher.createShortcut(cellLayout, (ShortcutInfo) info);
                 break;
             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
                 view = FolderIcon.fromXml(R.layout.folder_icon, mLauncher, cellLayout,
@@ -4019,6 +3998,15 @@
                 && mDragInfo.cell != null) {
             mDragInfo.cell.setVisibility(VISIBLE);
         }
+        //Add for in case uninstall all apps in folder when dragging FolderIcon
+        ItemInfo item = (ItemInfo) d.dragInfo;
+        if(item instanceof FolderInfo){
+            FolderInfo info = (FolderInfo) item;
+            if(info.contents.size() < 1){
+                removeWorkspaceItem(mDragInfo.cell);
+            }
+        }
+
         mDragOutline = null;
         mDragInfo = null;
     }
@@ -4463,6 +4451,40 @@
             };
             LauncherModel.filterItemInfos(children.keySet(), filter);
 
+            //filter no component itmes(eg. email app 1*1 widget)
+            LauncherModel.ItemInfoFilterForNoCn filterForNoCn = new LauncherModel.ItemInfoFilterForNoCn() {
+                @Override
+                public boolean filterItemForNoCn(ItemInfo parent, ItemInfo info) {
+                    if (parent instanceof FolderInfo) {
+                        if (!LauncherModel.isValidItem(mLauncher, info, user) && info.user.equals(user)) {
+                            FolderInfo folder = (FolderInfo) parent;
+                            ArrayList<ShortcutInfo> appsToRemove;
+                            if (folderAppsToRemove.containsKey(folder)) {
+                                appsToRemove = folderAppsToRemove.get(folder);
+                            } else {
+                                appsToRemove = new ArrayList<ShortcutInfo>();
+                                folderAppsToRemove.put(folder, appsToRemove);
+                            }
+                            if (LauncherModel.DEBUG_LOADERS) {
+                                Log.d(TAG, "invalid item, appsToRemove:" + info.toString());
+                            }
+                            appsToRemove.add((ShortcutInfo) info);
+                            return true;
+                        }
+                    } else {
+                        if (!LauncherModel.isValidItem(mLauncher, info, user) && info.user.equals(user)) {
+                            if (LauncherModel.DEBUG_LOADERS) {
+                                Log.d(TAG, "invalid item, childrenToRemove:" + info.toString());
+                            }
+                            childrenToRemove.add(children.get(info));
+                            return true;
+                        }
+                    }
+                    return false;
+                }
+            };
+            LauncherModel.filterItemInfosForNoCn(children.keySet(), filterForNoCn);
+
             // Remove all the apps from their folders
             for (FolderInfo folder : folderAppsToRemove.keySet()) {
                 ArrayList<ShortcutInfo> appsToRemove = folderAppsToRemove.get(folder);
@@ -4757,7 +4779,86 @@
         }
     }
 
-    public void updateUnreadInfo() {
-        SprdUnreadInfoManager.getInstance().updateUnreadInfo(this);
+    // SPRD add for SPRD_SETTINGS_ACTIVITY_SUPPORT strat {
+    public void setCircleSlideEnabled(boolean enabled) {
+        if(!mLauncher.hasCustomContentToLeft()) {
+            mIsEnableCircular = enabled;
+        }else{
+            mIsEnableCircular = false;
+            LogUtils.d(TAG,"hasCustomContentToLeft is ture disable mIsEnableCircular!");
+        }
     }
+    // SPRD add for SPRD_SETTINGS_ACTIVITY_SUPPORT end }
+
+    private void initPiflow(CellLayout cellLayout){
+        LogUtils.d(TAG, "initPiflow.");
+        try{
+            piflow = (ViewGroup)getPiflow();
+            if(piflow!=null){
+                cellLayout.addPiflowView(piflow);
+                cellLayout.setPiflow(true);
+            }
+        }catch(Exception e){
+            e.printStackTrace();
+        }
+    }
+
+    private void removePiflow(){
+        try{
+            if(piflow!=null){
+                piflow.removeAllViews();
+            }
+        }catch(Exception e){
+            e.printStackTrace();
+        }
+    }
+
+    private void changeCurrentPageBottomBar(int whichPage){
+        CellLayout cell = (CellLayout)getChildAt(whichPage);
+        if(cell.isPiflow()){
+            showBotoomBar(false);
+            if (!FeatureOption.SPRD_PIFLOW_STATUSBAR_SUPPORT) {
+                UtilitiesExt.enableFullScreenMode(mLauncher, true);
+            }
+        }else{
+            showBotoomBar(true);
+            if (!FeatureOption.SPRD_PIFLOW_STATUSBAR_SUPPORT) {
+                UtilitiesExt.enableFullScreenMode(mLauncher, false);
+            }
+        }
+    }
+
+    private void showBotoomBar(boolean flag){
+        if(flag){
+            mLauncher.showWorkspaceSearchAndHotseat();
+            mLauncher.getHotseat().setVisibility(View.VISIBLE);
+        }else{
+            mLauncher.hideWorkspaceSearchAndHotseat();
+            mLauncher.getHotseat().setVisibility(View.GONE);
+        }
+    }
+
+    public View getPiflow(){
+
+        if (!FeatureOption.SPRD_PIFLOW_SUPPORT) {
+            return null;
+        }
+
+        WebView piflowView = null;
+        try{
+            LayoutInflater inflater = LayoutInflater.from(mLauncher);
+            piflowView = (WebView)inflater.inflate(R.layout.web_view, null);
+            piflowView.loadUrl("https://www.google.com");
+            piflowView.setWebViewClient(new WebViewClient(){
+                @Override
+                public boolean shouldOverrideUrlLoading(WebView view, String url) {
+                    view.loadUrl(url);
+                    return true;
+                }
+            });
+        } catch(Exception e) {
+            e.printStackTrace();
+        }
+        return piflowView;
+    }
 }
Index: packages/apps/Launcher3/src/com/android/launcher3/widget/WidgetCell.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/widget/WidgetCell.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/widget/WidgetCell.java	(revision 173368)
@@ -62,7 +62,7 @@
     private static final float WIDTH_SCALE = 2.6f;
 
     /** Widget preview width is calculated by multiplying this factor to the widget cell width. */
-    private static final float PREVIEW_SCALE = 0.8f;
+    private static final float PREVIEW_SCALE = 0.75f;
 
     private int mPresetPreviewSize;
     int cellSize;
Index: packages/apps/Launcher3/src/com/android/launcher3/widget/WidgetsRecyclerView.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/widget/WidgetsRecyclerView.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/widget/WidgetsRecyclerView.java	(revision 173368)
@@ -162,7 +162,9 @@
         int position = getChildPosition(child);
 
         stateOut.rowIndex = position;
-        stateOut.rowTopOffset = getLayoutManager().getDecoratedTop(child);
+        if(child != null) {
+            stateOut.rowTopOffset = getLayoutManager().getDecoratedTop(child);
+        }
         stateOut.itemPos = position;
     }
 
Index: packages/apps/Launcher3/src/com/android/launcher3/PageIndicator.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/PageIndicator.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/PageIndicator.java	(revision 173368)
@@ -21,8 +21,11 @@
 import android.content.res.TypedArray;
 import android.util.AttributeSet;
 import android.view.LayoutInflater;
+import android.view.View;
 import android.widget.LinearLayout;
-import android.view.View;
+
+import com.sprd.ext.FeatureOption;
+
 import java.util.ArrayList;
 
 public class PageIndicator extends LinearLayout {
@@ -38,9 +41,9 @@
     private ArrayList<PageIndicatorMarker> mMarkers =
             new ArrayList<PageIndicatorMarker>();
     private int mActiveMarkerIndex;
-
-    private static boolean mFlag = true;
-
+    private boolean mIsNeedHideMarker = true;
+	private static boolean mFlag = true;
+	
     public static class PageMarkerResources {
         int activeId;
         int inactiveId;
@@ -168,10 +171,16 @@
             (PageIndicatorMarker) mLayoutInflater.inflate(R.layout.page_indicator_marker,
                     this, false);
         m.setMarkerDrawables(marker.activeId, marker.inactiveId);
-        if (Launcher.SUPPORT_PIFLOW && (0 == index) && mFlag) {
+		if (FeatureOption.SPRD_PIFLOW_SUPPORT && (0 == index) && mFlag) {
             m.setVisibility(View.GONE);
             mFlag = false;
         }
+		
+        if (FeatureOption.SPRD_PIFLOW_SUPPORT && (0 == index) && mIsNeedHideMarker) {
+            m.setVisibility( View.GONE);
+            mIsNeedHideMarker = false;
+        }
+
         mMarkers.add(index, m);
         offsetWindowCenterTo(mActiveMarkerIndex, allowAnimations);
     }
Index: packages/apps/Launcher3/src/com/android/launcher3/Folder.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/Folder.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/Folder.java	(revision 173368)
@@ -62,6 +62,9 @@
 import com.android.launcher3.util.Thunk;
 import com.android.launcher3.util.UiThreadCircularReveal;
 
+import com.sprd.ext.FeatureOption;
+import com.sprd.ext.foldername.FolderNameUtils;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -244,6 +247,8 @@
         int measureSpec = MeasureSpec.UNSPECIFIED;
         mFooter.measure(measureSpec, measureSpec);
         mFooterHeight = mFooter.getMeasuredHeight();
+
+        FolderNameUtils.init(mLauncher, sDefaultFolderName, sHintText);
     }
 
     public void onClick(View v) {
@@ -317,8 +322,10 @@
         // Convert to a string here to ensure that no other state associated with the text field
         // gets saved.
         String newTitle = mFolderName.getText().toString();
-        mInfo.setTitle(newTitle);
-        LauncherModel.updateItemInDatabase(mLauncher, mInfo);
+        if(FolderNameUtils.isFolderNameChanged(newTitle, mInfo, mFolderName)) {
+            mInfo.setTitle(newTitle);
+            LauncherModel.updateItemInDatabase(mLauncher, mInfo);
+        }
 
         if (commit) {
             sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
@@ -402,7 +409,8 @@
         updateTextViewFocus();
         mInfo.addListener(this);
 
-        if (!sDefaultFolderName.contentEquals(mInfo.title)) {
+        if (FeatureOption.SPRD_DEFAULT_FOLDER_NAME_SUPPORT
+                || !sDefaultFolderName.contentEquals(mInfo.title)) {
             mFolderName.setText(mInfo.title);
         } else {
             mFolderName.setText("");
@@ -1066,6 +1074,16 @@
         return Math.max(height, MIN_CONTENT_DIMEN);
     }
 
+    public int getMaxContentAreaHeight(){
+        DeviceProfile grid = mLauncher.getDeviceProfile();
+        Rect workspacePadding = grid.getWorkspacePadding(mContent.mIsRtl);
+        int maxContentAreaHeight = grid.availableHeightPx -
+                mLauncher.getSearchDropTargetBar().getMeasuredHeight() -
+                workspacePadding.top - workspacePadding.bottom -
+                mFooterHeight;
+        return maxContentAreaHeight;
+    }
+
     private int getContentAreaWidth() {
         return Math.max(mContent.getDesiredWidth(), MIN_CONTENT_DIMEN);
     }
@@ -1146,7 +1164,7 @@
                         CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container,
                                 mInfo.screenId);
                         ShortcutInfo finalItem = mInfo.contents.remove(0);
-                        newIcon = mLauncher.createShortcut(R.layout.application, cellLayout, finalItem);
+                        newIcon = mLauncher.createShortcut(cellLayout, finalItem);
                         LauncherModel.addOrMoveItemInDatabase(mLauncher, finalItem, mInfo.container,
                                 mInfo.screenId, mInfo.cellX, mInfo.cellY);
                     }
@@ -1471,4 +1489,20 @@
             }
         }
     };
+
+    /**
+     * We should only use this to search for specific children.  Do not use this method to modify
+     * ShortcutsAndWidgetsContainer directly. Includes ShortcutAndWidgetContainers from
+     * the hotseat and workspace pages
+     */
+    public ArrayList<ShortcutAndWidgetContainer> getAllShortcutContainersInFolder() {
+        ArrayList<ShortcutAndWidgetContainer> childrenLayouts =
+                new ArrayList<ShortcutAndWidgetContainer>();
+        int screenCount = mContent.getChildCount();
+        for (int screen = 0; screen < screenCount; screen++) {
+            childrenLayouts.add(
+                    ((CellLayout) (mContent.getChildAt(screen))).getShortcutsAndWidgets());
+        }
+        return childrenLayouts;
+    }
 }
Index: packages/apps/Launcher3/src/com/android/launcher3/IconCache.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/IconCache.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/IconCache.java	(revision 173368)
@@ -51,6 +51,9 @@
 import com.android.launcher3.util.SQLiteCacheHelper;
 import com.android.launcher3.util.Thunk;
 
+import com.sprd.ext.dynamicIcon.DynamicIconUtils;
+import com.sprd.ext.FeatureOption;
+
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -284,7 +287,7 @@
             c = mIconDb.query(
                     new String[]{IconDB.COLUMN_ROWID, IconDB.COLUMN_COMPONENT,
                             IconDB.COLUMN_LAST_UPDATED, IconDB.COLUMN_VERSION,
-                            IconDB.COLUMN_SYSTEM_STATE},
+                            IconDB.COLUMN_ICON, IconDB.COLUMN_SYSTEM_STATE},
                     IconDB.COLUMN_USER + " = ? ",
                     new String[]{Long.toString(userSerial)});
 
@@ -292,6 +295,7 @@
             final int indexLastUpdate = c.getColumnIndex(IconDB.COLUMN_LAST_UPDATED);
             final int indexVersion = c.getColumnIndex(IconDB.COLUMN_VERSION);
             final int rowIndex = c.getColumnIndex(IconDB.COLUMN_ROWID);
+            final int iconIndex = c.getColumnIndex(IconDB.COLUMN_ICON);
             final int systemStateIndex = c.getColumnIndex(IconDB.COLUMN_SYSTEM_STATE);
 
             while (c.moveToNext()) {
@@ -312,9 +316,12 @@
 
                 long updateTime = c.getLong(indexLastUpdate);
                 int version = c.getInt(indexVersion);
+                boolean needUpdateDynamicIcon = DynamicIconUtils.getInstance(mContext)
+                        .updateDynamicIconBgIfNeeded(c, iconIndex, component);
                 LauncherActivityInfoCompat app = componentMap.remove(component);
                 if (version == info.versionCode && updateTime == info.lastUpdateTime &&
-                        TextUtils.equals(mSystemState, c.getString(systemStateIndex))) {
+                        TextUtils.equals(mSystemState, c.getString(systemStateIndex)) &&
+                        !needUpdateDynamicIcon) {
                     continue;
                 }
                 if (app == null) {
@@ -380,8 +387,7 @@
         }
         if (entry == null) {
             entry = new CacheEntry();
-            entry.icon = Utilities.createBadgedIconBitmap(
-                    app.getIcon(mIconDpi), app.getUser(), mContext);
+            entry.icon = createIconBitmap(app);
         }
         entry.title = app.getLabel();
         entry.contentDescription = mUserManager.getBadgedLabelForUser(entry.title, app.getUser());
@@ -423,6 +429,25 @@
         return new IconLoadRequest(request, mWorkerHandler);
     }
 
+    /**
+     * SPRD: Add for change the stable background of dynamic icon.
+     * Create the bitmap for the stable part if dynamic icon supports.
+     * Otherwise, create the bitmap of the whole drawable.
+     */
+    private Bitmap createIconBitmap(LauncherActivityInfoCompat infoCompat) {
+        Drawable drawable = null;
+        ComponentName cn = infoCompat.getComponentName();
+        if (FeatureOption.SPRD_DYNAMIC_ICON_SUPPORT) {
+            DynamicIconUtils utils = DynamicIconUtils.getInstance(mContext);
+            drawable = utils.getStableBGForComponent(cn);
+        }
+
+        if (drawable == null) {
+            drawable = infoCompat.getIcon(mIconDpi);
+        }
+        return Utilities.createBadgedIconBitmap(drawable, infoCompat.getUser(), mContext);
+    }
+
     private Bitmap getNonNullIcon(CacheEntry entry, UserHandleCompat user) {
         return entry.icon == null ? getDefaultIcon(user) : entry.icon;
     }
@@ -543,8 +568,7 @@
             // Check the DB first.
             if (!getEntryFromDB(cacheKey, entry, useLowResIcon)) {
                 if (info != null) {
-                    entry.icon = Utilities.createBadgedIconBitmap(
-                            info.getIcon(mIconDpi), info.getUser(), mContext);
+                    entry.icon = createIconBitmap(info);
                 } else {
                     if (usePackageIcon) {
                         CacheEntry packageEntry = getEntryForPackageLocked(
@@ -861,7 +885,7 @@
         return values;
     }
 
-    private static Bitmap loadIconNoResize(Cursor c, int iconIndex, BitmapFactory.Options options) {
+    public static Bitmap loadIconNoResize(Cursor c, int iconIndex, BitmapFactory.Options options) {
         byte[] data = c.getBlob(iconIndex);
         try {
             return BitmapFactory.decodeByteArray(data, 0, data.length, options);
Index: packages/apps/Launcher3/src/com/android/launcher3/BaseRecyclerViewFastScrollBar.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/BaseRecyclerViewFastScrollBar.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/BaseRecyclerViewFastScrollBar.java	(revision 173368)
@@ -39,6 +39,7 @@
 
     public interface FastScrollFocusableView {
         void setFastScrollFocusState(final FastBitmapDrawable.State focusState, boolean animated);
+        boolean isDisabled();
     }
 
     private final static int MAX_TRACK_ALPHA = 30;
Index: packages/apps/Launcher3/src/com/android/launcher3/AutoInstallsLayout.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/AutoInstallsLayout.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/AutoInstallsLayout.java	(revision 173368)
@@ -125,6 +125,7 @@
     private static final String ATTR_CLASS_NAME = "className";
     private static final String ATTR_TITLE = "title";
     private static final String ATTR_SCREEN = "screen";
+    private static final String ATTR_ITEMTYPE = "itemType";
 
     // x and y can be specified as negative integers, in which case -1 represents the
     // last row / column, -2 represents the second last, and so on.
@@ -352,6 +353,20 @@
                         cn = new ComponentName(packages[0], className);
                         info = mPackageManager.getActivityInfo(cn, 0);
                     }
+
+                    final String customItemType = getAttributeValue(parser, ATTR_ITEMTYPE);
+                    int itemType = Favorites.ITEM_TYPE_APPLICATION;
+                    if (!TextUtils.isEmpty(customItemType)) {
+                        int tmpType = Integer.parseInt(customItemType);
+                        if (tmpType != itemType) {
+                            itemType = tmpType;
+                        }
+                    }
+                    if (itemType == Favorites.ITEM_TYPE_SHORTCUT) {
+                        Drawable drawable = info.loadIcon(mPackageManager);
+                        ItemInfo.writeBitmap(mValues, Utilities.createIconBitmap(drawable, mContext));
+                    }
+
                     final Intent intent = new Intent(Intent.ACTION_MAIN, null)
                         .addCategory(Intent.CATEGORY_LAUNCHER)
                         .setComponent(cn)
@@ -359,7 +374,7 @@
                                 Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
 
                     return addShortcut(info.loadLabel(mPackageManager).toString(),
-                            intent, Favorites.ITEM_TYPE_APPLICATION);
+                            intent, itemType);
                 } catch (PackageManager.NameNotFoundException e) {
                     Log.e(TAG, "Unable to add favorite: " + packageName + "/" + className, e);
                 }
Index: packages/apps/Launcher3/src/com/android/launcher3/InvariantDeviceProfile.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/InvariantDeviceProfile.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/InvariantDeviceProfile.java	(revision 173368)
@@ -24,6 +24,7 @@
 import android.view.WindowManager;
 
 import com.android.launcher3.util.Thunk;
+import com.sprd.ext.LogUtils;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -130,22 +131,8 @@
         minWidthDps = Utilities.dpiFromPx(Math.min(smallestSize.x, smallestSize.y), dm);
         minHeightDps = Utilities.dpiFromPx(Math.min(largestSize.x, largestSize.y), dm);
 
-        /** SPRD Fix BUG# 517802, Add cmcc plugin addon workspace support {@ **/
-        ArrayList<InvariantDeviceProfile> predefinedDeviceProfiles = getPredefinedDeviceProfiles();
-        if(SprdCmccWorkspaceAddonStub.getInstance().isDefault()){
-            predefinedDeviceProfiles = getCmccPredefinedDeviceProfiles();
-        }
-        /** @} **/
-
-        /** SPRD Fix BUG# 517809, Add cucc plugin addon workspace support {@ **/
-        if(SprdCuccWorkspaceAddonStub.getInstance().isDefault()){
-            predefinedDeviceProfiles = getCuccPredefinedDeviceProfiles();
-        }
-        /** @} **/
-        /** SPRD Fix BUG# 517802,517809 Add cmcc plugin addon workspace parameter {@ **/
         ArrayList<InvariantDeviceProfile> closestProfiles =
-                findClosestDeviceProfiles(minWidthDps, minHeightDps, predefinedDeviceProfiles);
-        /** @} **/
+                findClosestDeviceProfiles(minWidthDps, minHeightDps, getPredefinedDeviceProfiles());
         InvariantDeviceProfile interpolatedDeviceProfileOut =
                 invDistWeightedInterpolate(minWidthDps,  minHeightDps, closestProfiles);
 
@@ -165,6 +152,11 @@
         hotseatIconSize = interpolatedDeviceProfileOut.hotseatIconSize;
         fillResIconDpi = getLauncherIconDensity(iconBitmapSize);
 
+        if(LogUtils.DEBUG) {
+            LogUtils.d(Launcher.TAG, "closestProfile name is "+closestProfile.name
+                    + ", iconSize = "+iconSize + ", hotseatIconSize = "+hotseatIconSize);
+        }
+
         // If the partner customization apk contains any grid overrides, apply them
         // Supported overrides: numRows, numColumns, iconSize
         applyPartnerDeviceProfileOverrides(context, dm);
@@ -199,7 +191,7 @@
         predefinedDeviceProfiles.add(new InvariantDeviceProfile("Nexus 4",
                 359, 567,     4, 4, 4, 4, 4, DEFAULT_ICON_SIZE_DP, 13, 5, 56, R.xml.default_workspace_4x4));
         predefinedDeviceProfiles.add(new InvariantDeviceProfile("Nexus 5",
-                335, 567,     4, 4, 4, 4, 4, DEFAULT_ICON_SIZE_DP, 10, 5, 56, R.xml.default_workspace_4x4));//13
+                335, 567,     4, 4, 4, 4, 4, DEFAULT_ICON_SIZE_DP, 10, 5, 56, R.xml.default_workspace_4x4));
         predefinedDeviceProfiles.add(new InvariantDeviceProfile("Large Phone",
                 406, 694,     5, 5, 4, 4, 4, 64, 14.4f,  5, 56, R.xml.default_workspace_5x5));
         // The tablet profile is odd in that the landscape orientation
@@ -214,74 +206,6 @@
         return predefinedDeviceProfiles;
     }
 
-    /** SPRD Fix BUG# 517802, Add cmcc plugin addon support {@ **/
-    ArrayList<InvariantDeviceProfile> getCmccPredefinedDeviceProfiles() {
-        ArrayList<InvariantDeviceProfile> predefinedDeviceProfiles = new ArrayList<>();
-        // width, height, #rows, #columns, #folder rows, #folder columns,
-        // iconSize, iconTextSize, #hotseat, #hotseatIconSize, defaultLayoutId.
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Super Short Stubby",
-                255, 300,     2, 3, 2, 3, 3, 48, 13, 3, 48, R.xml.default_workspace_cmcc_4x4));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Shorter Stubby",
-                255, 400,     3, 3, 3, 3, 3, 48, 13, 3, 48, R.xml.default_workspace_cmcc_4x4));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Short Stubby",
-                275, 420,     3, 4, 3, 4, 4, 48, 13, 5, 48, R.xml.default_workspace_cmcc_4x4));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Stubby",
-                255, 450,     3, 4, 3, 4, 4, 48, 13, 5, 48, R.xml.default_workspace_cmcc_4x4));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Nexus S",
-                296, 491.33f, 4, 4, 4, 4, 4, 48, 13, 5, 48, R.xml.default_workspace_cmcc_4x4));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Nexus 4",
-                335, 567,     4, 4, 4, 4, 4, DEFAULT_ICON_SIZE_DP, 13, 5, 56, R.xml.default_workspace_cmcc_4x4));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Nexus 5",
-                359, 567,     4, 4, 4, 4, 4, DEFAULT_ICON_SIZE_DP, 13, 5, 56, R.xml.default_workspace_cmcc_4x4));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Large Phone",
-                406, 694,     5, 5, 4, 4, 4, 64, 14.4f,  5, 56, R.xml.default_workspace_cmcc_5x5));
-        // The tablet profile is odd in that the landscape orientation
-        // also includes the nav bar on the side
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Nexus 7",
-                575, 904,     5, 6, 4, 5, 4, 72, 14.4f,  7, 60, R.xml.default_workspace_cmcc_5x6));
-        // Larger tablet profiles always have system bars on the top & bottom
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Nexus 10",
-                727, 1207,    5, 6, 4, 5, 4, 76, 14.4f,  7, 64, R.xml.default_workspace_cmcc_5x6));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("20-inch Tablet",
-                1527, 2527,   7, 7, 6, 6, 4, 100, 20,  7, 72, R.xml.default_workspace_cmcc_4x4));
-        return predefinedDeviceProfiles;
-    }
-    /** @} **/
-
-    /** SPRD Fix BUG# 517809, Add cucc plugin addon support {@ **/
-    ArrayList<InvariantDeviceProfile> getCuccPredefinedDeviceProfiles() {
-        ArrayList<InvariantDeviceProfile> predefinedDeviceProfiles = new ArrayList<>();
-        // width, height, #rows, #columns, #folder rows, #folder columns,
-        // iconSize, iconTextSize, #hotseat, #hotseatIconSize, defaultLayoutId.
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Super Short Stubby",
-                255, 300,     2, 3, 2, 3, 3, 48, 13, 3, 48, R.xml.default_workspace_cucc_4x4));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Shorter Stubby",
-                255, 400,     3, 3, 3, 3, 3, 48, 13, 3, 48, R.xml.default_workspace_cucc_4x4));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Short Stubby",
-                275, 420,     3, 4, 3, 4, 4, 48, 13, 5, 48, R.xml.default_workspace_cucc_4x4));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Stubby",
-                255, 450,     3, 4, 3, 4, 4, 48, 13, 5, 48, R.xml.default_workspace_cucc_4x4));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Nexus S",
-                296, 491.33f, 4, 4, 4, 4, 4, 48, 13, 5, 48, R.xml.default_workspace_cucc_4x4));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Nexus 4",
-                335, 567,     4, 4, 4, 4, 4, DEFAULT_ICON_SIZE_DP, 13, 5, 56, R.xml.default_workspace_cucc_4x4));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Nexus 5",
-                359, 567,     4, 4, 4, 4, 4, DEFAULT_ICON_SIZE_DP, 13, 5, 56, R.xml.default_workspace_cucc_4x4));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Large Phone",
-                406, 694,     5, 5, 4, 4, 4, 64, 14.4f,  5, 56, R.xml.default_workspace_cucc_5x5));
-        // The tablet profile is odd in that the landscape orientation
-        // also includes the nav bar on the side
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Nexus 7",
-                575, 904,     5, 6, 4, 5, 4, 72, 14.4f,  7, 60, R.xml.default_workspace_cucc_5x6));
-        // Larger tablet profiles always have system bars on the top & bottom
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("Nexus 10",
-                727, 1207,    5, 6, 4, 5, 4, 76, 14.4f,  7, 64, R.xml.default_workspace_cucc_5x6));
-        predefinedDeviceProfiles.add(new InvariantDeviceProfile("20-inch Tablet",
-                1527, 2527,   7, 7, 6, 6, 4, 100, 20,  7, 72, R.xml.default_workspace_cucc_4x4));
-        return predefinedDeviceProfiles;
-    }
-    /** @} **/
-
     private int getLauncherIconDensity(int requiredSize) {
         // Densities typically defined by an app.
         int[] densityBuckets = new int[] {
Index: packages/apps/Launcher3/src/com/android/launcher3/BaseRecyclerView.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/BaseRecyclerView.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/BaseRecyclerView.java	(revision 173368)
@@ -20,9 +20,11 @@
 import android.graphics.Canvas;
 import android.graphics.Rect;
 import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.SimpleItemAnimator;
 import android.util.AttributeSet;
 import android.view.MotionEvent;
 import com.android.launcher3.util.Thunk;
+import com.sprd.ext.FeatureOption;
 
 
 /**
@@ -105,6 +107,9 @@
     protected void onFinishInflate() {
         super.onFinishInflate();
         addOnItemTouchListener(this);
+        if (FeatureOption.SPRD_DYNAMIC_ICON_SUPPORT) {
+            ((SimpleItemAnimator)getItemAnimator()).setSupportsChangeAnimations(false);
+        }
     }
 
     /**
@@ -264,7 +269,7 @@
         // Calculate the current scroll position, the scrollY of the recycler view accounts for the
         // view padding, while the scrollBarY is drawn right up to the background padding (ignoring
         // padding)
-        int scrollY = getScrollTop(scrollPosState);
+        int scrollY = Math.max(0, getScrollTop(scrollPosState));
         int scrollBarY = mBackgroundPadding.top +
                 (int) (((float) scrollY / availableScrollHeight) * availableScrollBarHeight);
 
Index: packages/apps/Launcher3/src/com/android/launcher3/DefaultLayoutParser.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/DefaultLayoutParser.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/DefaultLayoutParser.java	(revision 173368)
@@ -134,6 +134,10 @@
             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
                     Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
 
+            if (intent.getComponent() != null && intent.getPackage() != null) {
+                //remove pkg while component is valid by sprd for bug620505
+                intent.setPackage(null);
+            }
             return addShortcut(info.loadLabel(mPackageManager).toString(), intent,
                     Favorites.ITEM_TYPE_APPLICATION);
         }
Index: packages/apps/Launcher3/src/com/android/launcher3/compat/UserManagerCompatV17.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/compat/UserManagerCompatV17.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/compat/UserManagerCompatV17.java	(revision 173368)
@@ -43,7 +43,12 @@
         synchronized (this) {
             if (mUserToSerialMap != null) {
                 Long serial = mUserToSerialMap.get(user);
-                return serial == null ? 0 : serial;
+                /* Modify for bug628090 {@ */
+                //return serial == null ? 0 : serial;
+                if (serial != null) {
+                    return serial;
+                }
+                /* @} */
             }
         }
         return mUserManager.getSerialNumberForUser(user.getUser());
@@ -52,7 +57,13 @@
     public UserHandleCompat getUserForSerialNumber(long serialNumber) {
         synchronized (this) {
             if (mUsers != null) {
-                return mUsers.get(serialNumber);
+                /* Modify for bug628090 {@ */
+                //return mUsers.get(serialNumber);
+                UserHandleCompat user = mUsers.get(serialNumber);
+                if (user != null) {
+                    return user;
+                }
+                /* @} */
             }
         }
         return UserHandleCompat.fromUser(mUserManager.getUserForSerialNumber(serialNumber));
Index: packages/apps/Launcher3/src/com/android/launcher3/PagedView.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/PagedView.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/PagedView.java	(revision 173368)
@@ -51,9 +51,11 @@
 
 import com.android.launcher3.util.LauncherEdgeEffect;
 import com.android.launcher3.util.Thunk;
+import com.android.launcher3.Workspace.State;
+import com.sprd.ext.FeatureOption;
+import com.sprd.ext.LogUtils;
 
 import java.util.ArrayList;
-import com.android.launcher3.Workspace.State;
 
 /**
  * An abstraction of the original Workspace which supports browsing through a
@@ -61,9 +63,20 @@
  */
 public abstract class PagedView extends ViewGroup implements ViewGroup.OnHierarchyChangeListener {
     private static final String TAG = "PagedView";
-    private static final boolean DEBUG = false;
-    protected static final int INVALID_PAGE = -1;
+    private static final boolean DEBUG = LogUtils.DEBUG_ALL;
+    protected static final int INVALID_PAGE = -2;
 
+    //SPRD: add for SPRD_CIRCLE_SLIDE_SUPPORT. start {
+    protected boolean mIsEnableCircular;
+    protected static final int OVER_FIRST_PAGE_INDEX = -1;
+    private static final int OVER_FIRST_INDEX = 0;
+    private static final int OVER_LAST_INDEX = 1;
+    //Left for over first or last page
+    private int[] mOverPageLeft = new int[] { 0, 0 };
+    private int mPageWidth = 0;
+    protected int mOverScrollX;
+    //SPRD: SPRD_CIRCLE_SLIDE_SUPPORT end }
+
     // the min drag distance for a fling to register, to prevent random page shifts
     private static final int MIN_LENGTH_FOR_FLING = 25;
 
@@ -401,7 +414,17 @@
      * Returns the index of page to be shown immediately afterwards.
      */
     int getNextPage() {
-        return (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
+        // SPRD: add for circular sliding. start {
+        int nextPage = mNextPage;
+        if (mIsEnableCircular) {
+            if (mNextPage == OVER_FIRST_PAGE_INDEX) {
+                nextPage = getChildCount() -1;
+            } else if (mNextPage == getChildCount()) {
+                nextPage = 0;
+            }
+        }
+        return (mNextPage != INVALID_PAGE) ? nextPage : mCurrentPage;
+        //SPRD: SPRD_CIRCLE_SLIDE_SUPPORT end }
     }
 
     int getPageCount() {
@@ -448,16 +471,21 @@
         mNextPage = INVALID_PAGE;
     }
 
-    private int validateNewPage(int newPage) {
+    private int validateNewPage(int newPage, boolean isSnapTo) {
         int validatedPage = newPage;
-        // When in free scroll mode, we need to clamp to the free scroll page range.
-        if (mFreeScroll) {
-            getFreeScrollPageRange(mTempVisiblePagesRange);
-            validatedPage = Math.max(mTempVisiblePagesRange[0],
-                    Math.min(newPage, mTempVisiblePagesRange[1]));
+        if (mIsEnableCircular && isSnapTo) {
+            // whichPage can be OVER_FIRST_PAGE_INDEX or [0, count]
+            validatedPage = Math.max(OVER_FIRST_PAGE_INDEX, Math.min(validatedPage, getPageCount()));
+        }else {
+            // When in free scroll mode, we need to clamp to the free scroll page range.
+            if (mFreeScroll) {
+                getFreeScrollPageRange(mTempVisiblePagesRange);
+                validatedPage = Math.max(mTempVisiblePagesRange[0],
+                        Math.min(newPage, mTempVisiblePagesRange[1]));
+            }
+            // Ensure that it is clamped by the actual set of children in all cases
+            validatedPage = Math.max(0, Math.min(validatedPage, getPageCount() - 1));
         }
-        // Ensure that it is clamped by the actual set of children in all cases
-        validatedPage = Math.max(0, Math.min(validatedPage, getPageCount() - 1));
         return validatedPage;
     }
 
@@ -474,7 +502,7 @@
             return;
         }
         mForceScreenScrolled = true;
-        mCurrentPage = validateNewPage(currentPage);
+        mCurrentPage = validateNewPage(currentPage, false);
         updateCurrentPageScroll();
         notifyPageSwitchListener();
         invalidate();
@@ -578,35 +606,43 @@
             x = Math.max(x, mFreeScrollMinScrollX);
         }
 
-        boolean isXBeforeFirstPage = mIsRtl ? (x > mMaxScrollX) : (x < 0);
-        boolean isXAfterLastPage = mIsRtl ? (x < 0) : (x > mMaxScrollX);
-        if (isXBeforeFirstPage) {
-            super.scrollTo(mIsRtl ? mMaxScrollX : 0, y);
-            if (mAllowOverScroll) {
-                mWasInOverscroll = true;
-                if (mIsRtl) {
-                    overScroll(x - mMaxScrollX);
-                } else {
-                    overScroll(x);
+        // SPRD: add for circular sliding. start {
+        if (mIsEnableCircular) {
+            //if mIsEnableCircular ,never Overscroll
+            mOverScrollX = x;
+            super.scrollTo(x, y);
+        } else {
+            boolean isXBeforeFirstPage = mIsRtl ? (x > mMaxScrollX) : (x < 0);
+            boolean isXAfterLastPage = mIsRtl ? (x < 0) : (x > mMaxScrollX);
+            if (isXBeforeFirstPage) {
+                super.scrollTo(mIsRtl ? mMaxScrollX : 0, y);
+                if (mAllowOverScroll) {
+                    mWasInOverscroll = true;
+                    if (mIsRtl) {
+                        overScroll(x - mMaxScrollX);
+                    } else {
+                        overScroll(x);
+                    }
                 }
-            }
-        } else if (isXAfterLastPage) {
-            super.scrollTo(mIsRtl ? 0 : mMaxScrollX, y);
-            if (mAllowOverScroll) {
-                mWasInOverscroll = true;
-                if (mIsRtl) {
-                    overScroll(x);
-                } else {
-                    overScroll(x - mMaxScrollX);
+            } else if (isXAfterLastPage) {
+                super.scrollTo(mIsRtl ? 0 : mMaxScrollX, y);
+                if (mAllowOverScroll) {
+                    mWasInOverscroll = true;
+                    if (mIsRtl) {
+                        overScroll(x);
+                    } else {
+                        overScroll(x - mMaxScrollX);
+                    }
                 }
+            } else {
+                if (mWasInOverscroll) {
+                    overScroll(0);
+                    mWasInOverscroll = false;
+                }
+                super.scrollTo(x, y);
             }
-        } else {
-            if (mWasInOverscroll) {
-                overScroll(0);
-                mWasInOverscroll = false;
-            }
-            super.scrollTo(x, y);
         }
+        //SPRD: SPRD_CIRCLE_SLIDE_SUPPORT end }
 
         mTouchX = x;
         mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
@@ -653,7 +689,22 @@
         } else if (mNextPage != INVALID_PAGE) {
             sendScrollAccessibilityEvent();
 
-            mCurrentPage = validateNewPage(mNextPage);
+            // SPRD: add for circular sliding. start {
+            if (mIsEnableCircular){
+                if (mNextPage == OVER_FIRST_PAGE_INDEX && mPageScrolls != null) {
+                    mCurrentPage = getPageCount() - 1;
+                    scrollTo(mPageScrolls[mCurrentPage], getScrollY());
+                } else if (mNextPage == getPageCount() && mPageScrolls != null) {
+                    mCurrentPage = 0;
+                    scrollTo(mPageScrolls[mCurrentPage], getScrollY());
+                }else{
+                    mCurrentPage = validateNewPage(mNextPage, false);
+                }
+            }else{
+                mCurrentPage = validateNewPage(mNextPage, false);
+            }
+            //SPRD: SPRD_CIRCLE_SLIDE_SUPPORT end }
+
             mNextPage = INVALID_PAGE;
             notifyPageSwitchListener();
 
@@ -811,14 +862,8 @@
                     } else {
                         childHeightMode = MeasureSpec.EXACTLY;
                     }
-                    //piflow 
-                    if(!Launcher.SUPPORT_PIFLOW){
-                        childWidth = getViewportWidth() - horizontalPadding
-                                - mInsets.left - mInsets.right;
-                        childHeight = getViewportHeight() - verticalPadding
-                                - mInsets.top - mInsets.bottom;
-                        mNormalChildHeight = childHeight;
-                    }else{
+
+                    if (FeatureOption.SPRD_PIFLOW_SUPPORT) {
                         int width = widthSize - horizontalPadding;
                         int height = heightSize - verticalPadding - mInsets.top - mInsets.bottom;
                         if(child instanceof CellLayout){
@@ -835,8 +880,13 @@
                             childHeight = height;
                         }
                         mNormalChildHeight = height;
+                    } else {
+                        childWidth = getViewportWidth() - horizontalPadding
+                                - mInsets.left - mInsets.right;
+                        childHeight = getViewportHeight() - verticalPadding
+                                - mInsets.top - mInsets.bottom;
+                        mNormalChildHeight = childHeight;
                     }
-                    //end piflow
                 } else {
                     childWidthMode = MeasureSpec.EXACTLY;
                     childHeightMode = MeasureSpec.EXACTLY;
@@ -893,8 +943,11 @@
                 lp = (LayoutParams) child.getLayoutParams();
                 int childTop;
                 if (lp.isFullScreenPage) {
-                   // childTop = offsetY;
-                   childTop = offsetY + mInsets.top;
+                    if (FeatureOption.SPRD_PIFLOW_STATUSBAR_SUPPORT) {
+                        childTop = offsetY + mInsets.top;
+                    } else {
+                        childTop = offsetY;
+                    }
                 } else {
                     childTop = offsetY + getPaddingTop() + mInsets.top;
                     if (mCenterPagesVertically) {
@@ -932,6 +985,16 @@
             }
         }
 
+        if(mIsEnableCircular && mPageScrolls.length > 1 ) {
+            mPageWidth = mPageScrolls[1];
+            mOverPageLeft[(mIsRtl ? OVER_LAST_INDEX : OVER_FIRST_INDEX)] = -mPageWidth;
+            mOverPageLeft[(mIsRtl ? OVER_FIRST_INDEX : OVER_LAST_INDEX)] = mPageScrolls[mIsRtl ? 0 : (mPageScrolls.length - 1)] + mPageWidth;
+        }else{
+            mPageWidth = 0;
+            mOverPageLeft[OVER_FIRST_INDEX] = 0;
+            mOverPageLeft[OVER_LAST_INDEX] = 0;
+        }
+
         final LayoutTransition transition = getLayoutTransition();
         // If the transition is running defer updating max scroll, as some empty pages could
         // still be present, and a max scroll change could cause sudden jumps in scroll.
@@ -1169,6 +1232,11 @@
 
                 canvas.restore();
             }
+            // SPRD: add for circular sliding. start {
+            if (mIsEnableCircular) {
+                drawCircularPageIfNeed(canvas);
+            }
+            // SPRD: add for circular sliding. end }
         }
     }
 
@@ -1512,11 +1580,35 @@
         }
 
         if (adjacentPage < 0 || adjacentPage > count - 1) {
-            totalDistance = v.getMeasuredWidth() + mPageSpacing;
+            // SPRD: add for circular sliding. start {
+            if(mIsEnableCircular){
+                totalDistance = v.getMeasuredWidth() + getPaddingLeft() + getPaddingRight() + mPageSpacing;
+            }else{
+                totalDistance = v.getMeasuredWidth() + mPageSpacing;
+            }
+            // SPRD: add for circular sliding. end }
         } else {
             totalDistance = Math.abs(getScrollForPage(adjacentPage) - getScrollForPage(page));
         }
 
+        // SPRD: add for circular sliding. start {
+        if (mIsEnableCircular) {
+            if (mIsRtl) {
+                if (mOverScrollX < 0 && page == 0) {
+                    delta = screenCenter + halfScreenSize;
+                } else if (mOverScrollX > mMaxScrollX && page == getChildCount() - 1) {
+                    delta = screenCenter - mMaxScrollX - halfScreenSize - totalDistance;
+                }
+            } else {
+                if (mOverScrollX > mMaxScrollX && page == 0) {
+                    delta = screenCenter - mMaxScrollX - halfScreenSize - totalDistance;
+                } else if (mOverScrollX < 0 && page == count - 1) {
+                    delta = screenCenter + halfScreenSize;
+                }
+            }
+        }
+        // SPRD: add for circular sliding. end }
+
         float scrollProgress = delta / (totalDistance * 1.0f);
         scrollProgress = Math.min(scrollProgress, MAX_SCROLL_PROGRESS);
         scrollProgress = Math.max(scrollProgress, - MAX_SCROLL_PROGRESS);
@@ -1524,6 +1616,16 @@
     }
 
     public int getScrollForPage(int index) {
+        // SPRD: add for circular sliding. start {
+        if (mIsEnableCircular) {
+            if (index == OVER_FIRST_PAGE_INDEX) {
+                return mOverPageLeft[OVER_FIRST_INDEX];
+            } else if (index == getChildCount()){
+                return mOverPageLeft[OVER_LAST_INDEX];
+            }
+        }
+        // SPRD: add for circular sliding. end }
+
         if (mPageScrolls == null || index >= mPageScrolls.length || index < 0) {
             return 0;
         } else {
@@ -1809,18 +1911,21 @@
                     // move to the left and fling to the right will register as a fling to the right.
                     boolean isDeltaXLeft = mIsRtl ? deltaX > 0 : deltaX < 0;
                     boolean isVelocityXLeft = mIsRtl ? velocityX > 0 : velocityX < 0;
+                    // SPRD: add for circular sliding. start {
                     if (((isSignificantMove && !isDeltaXLeft && !isFling) ||
-                            (isFling && !isVelocityXLeft)) && mCurrentPage > 0) {
+                            (isFling && !isVelocityXLeft))
+                            && (mIsEnableCircular ? (mCurrentPage > OVER_FIRST_PAGE_INDEX) : (mCurrentPage > 0))) {
                         finalPage = returnToOriginalPage ? mCurrentPage : mCurrentPage - 1;
                         snapToPageWithVelocity(finalPage, velocityX);
                     } else if (((isSignificantMove && isDeltaXLeft && !isFling) ||
-                            (isFling && isVelocityXLeft)) &&
-                            mCurrentPage < getChildCount() - 1) {
+                            (isFling && isVelocityXLeft))
+                            && (mIsEnableCircular ? (mCurrentPage < getChildCount()) : (mCurrentPage < getChildCount() - 1))) {
                         finalPage = returnToOriginalPage ? mCurrentPage : mCurrentPage + 1;
                         snapToPageWithVelocity(finalPage, velocityX);
                     } else {
                         snapToDestination();
                     }
+                    // SPRD add for SPRD_SETTINGS_ACTIVITY_SUPPORT end }
                 } else {
                     if (!mScroller.isFinished()) {
                         abortScrollerAnimation(true);
@@ -2036,7 +2141,7 @@
     }
 
     protected void snapToPageWithVelocity(int whichPage, int velocity) {
-        whichPage = validateNewPage(whichPage);
+        whichPage = validateNewPage(whichPage, true);
         int halfScreenSize = getViewportWidth() / 2;
 
         final int newX = getScrollForPage(whichPage);
@@ -2087,7 +2192,7 @@
 
     protected void snapToPage(int whichPage, int duration, boolean immediate,
             TimeInterpolator interpolator) {
-        whichPage = validateNewPage(whichPage);
+        whichPage = validateNewPage(whichPage, true);
 
         int newX = getScrollForPage(whichPage);
         final int delta = newX - getUnboundedScrollX();
@@ -2100,7 +2205,7 @@
 
     protected void snapToPage(int whichPage, int delta, int duration, boolean immediate,
             TimeInterpolator interpolator) {
-        whichPage = validateNewPage(whichPage);
+        whichPage = validateNewPage(whichPage, true);
 
         mNextPage = whichPage;
 
@@ -2378,4 +2483,39 @@
     public boolean onHoverEvent(android.view.MotionEvent event) {
         return true;
     }
+
+    // SPRD: add for circular sliding. start {
+    private void drawCircularPageIfNeed(Canvas canvas) {
+        if(mPageWidth == 0){
+            return;
+        }
+        boolean isXBeforeFirstPage = mIsRtl ? (mOverScrollX > mMaxScrollX) : (mOverScrollX < 0);
+        boolean isXAfterLastPage = mIsRtl ? (mOverScrollX < 0) : (mOverScrollX > mMaxScrollX);
+        if (isXBeforeFirstPage || isXAfterLastPage) {
+            long drawingTime = getDrawingTime();
+            int childCount = getChildCount();
+            canvas.save();
+            canvas.clipRect(getScrollX(), getScrollY(), getScrollX() + getRight() - getLeft(),
+                    getScrollY() + getBottom() - getTop());
+            // here we assume that a page's horizontal padding plus it's measured width
+            // equals to ViewPort's width
+            int offset = (mIsRtl ? - childCount : childCount) * (mPageWidth);
+            if (isXBeforeFirstPage) {
+                canvas.translate(- offset, 0);
+                drawChild(canvas, getPageAt(childCount - 1), drawingTime);
+                canvas.translate(+ offset, 0);
+            } else if (isXAfterLastPage) {
+                canvas.translate(+ offset, 0);
+                drawChild(canvas, getPageAt(0), drawingTime);
+                canvas.translate(- offset, 0);
+            }
+            // Always draw the drag view on top (if there is one)
+            if (mDragView != null) {
+                drawChild(canvas, mDragView, drawingTime);
+            }
+            canvas.restore();
+        }
+    }
+    // SPRD: add for circular sliding.end }
+
 }
Index: packages/apps/Launcher3/src/com/android/launcher3/Utilities.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/Utilities.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/Utilities.java	(revision 173368)
@@ -65,6 +65,8 @@
 import com.android.launcher3.config.FeatureFlags;
 import com.android.launcher3.util.IconNormalizer;
 
+import com.sprd.ext.LogUtils;
+
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -134,10 +136,6 @@
             TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
 
     public static final String ALLOW_ROTATION_PREFERENCE_KEY = "pref_allowRotation";
-    public static final ComponentName sCalendarComponentName = new ComponentName("com.android.calendar",
-            "com.android.calendar.AllInOneActivity");
-    public static final ComponentName sDeskClockComponentName = new ComponentName("com.android.deskclock",
-            "com.android.deskclock.DeskClock");
 
     public static boolean isPropertyEnabled(String propertyName) {
         return Log.isLoggable(propertyName, Log.VERBOSE);
@@ -188,6 +186,24 @@
         return null;
     }
 
+    public static Bitmap createIconBitmap(String packageName, String resourceName,
+            UserHandleCompat user, Context context) {
+        PackageManager packageManager = context.getPackageManager();
+        // the resource
+        try {
+            Resources resources = packageManager.getResourcesForApplication(packageName);
+            if (resources != null) {
+                final int id = resources.getIdentifier(resourceName, null, null);
+                Drawable icon = resources.getDrawableForDensity(id, LauncherAppState.getInstance()
+                        .getInvariantDeviceProfile().fillResIconDpi);
+                return createBadgedIconBitmap(icon, user, context);
+            }
+        } catch (Exception e) {
+            // Icon not found.
+        }
+        return null;
+    }
+
     private static int getIconBitmapSize() {
         return LauncherAppState.getInstance().getInvariantDeviceProfile().iconBitmapSize;
     }
@@ -601,6 +617,9 @@
         SearchManager searchManager =
                 (SearchManager) context.getSystemService(Context.SEARCH_SERVICE);
         ComponentName searchComponent = searchManager.getGlobalSearchActivity();
+        if(LogUtils.DEBUG) {
+            LogUtils.d(TAG, "getSearchWidgetProvider searchComponent = " + searchComponent);
+        }
         if (searchComponent == null) return null;
         String providerPkg = searchComponent.getPackageName();
 
Index: packages/apps/Launcher3/src/com/android/launcher3/CellLayout.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/CellLayout.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/CellLayout.java	(revision 173368)
@@ -55,6 +55,7 @@
 import com.android.launcher3.util.ParcelableSparseArray;
 import com.android.launcher3.util.Thunk;
 import com.android.launcher3.Workspace.State;
+import com.sprd.ext.FeatureOption;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -171,30 +172,10 @@
     // Related to accessible drag and drop
     private DragAndDropAccessibilityDelegate mTouchHelper;
     private boolean mUseTouchHelper = false;
-    
-    /**
-     * piflow 
-     */
-    private boolean isPiflow;
+
+    private boolean mIsPiflow;
     private View mPiflowView;
-    public boolean isPiflow(){
-        return isPiflow;
-    }
-    public void setPiflow(boolean isPiflow){
-        this.isPiflow = isPiflow;
-    }
-    public void addPiflowView(View piflowView){
-        this.mPiflowView = piflowView;
-        addView(mPiflowView);
-    }
 
-    public State getState(){
-        return mLauncher.getWorkspace().getState();
-    }
-    /**
-     * end piflow
-     */
-    
     public CellLayout(Context context) {
         this(context, null);
     }
@@ -612,15 +593,12 @@
     public void restoreInstanceState(SparseArray<Parcelable> states) {
         try {
             dispatchRestoreInstanceState(states);
-        } catch (IllegalArgumentException ex) {
+        } catch (Exception ex) {
             if (LauncherAppState.isDogfoodBuild()) {
                 throw ex;
             }
             // Mismatched viewId / viewType preventing restore. Skip restore on production builds.
             Log.e(TAG, "Ignoring an error while restoring a view instance state", ex);
-        //piflow 
-        }catch(Exception e){
-        	Log.e(TAG, "piflow view error", e);
         }
     }
 
@@ -902,10 +880,9 @@
             mWidthGap = mOriginalWidthGap;
             mHeightGap = mOriginalHeightGap;
         }
-        //piflow
-        if(mPiflowView != null){
 
-             mPiflowView.measure(
+        if (mPiflowView != null) {
+            mPiflowView.measure(
                     MeasureSpec.makeMeasureSpec(newWidth, MeasureSpec.EXACTLY),
                     MeasureSpec.makeMeasureSpec(newHeight, MeasureSpec.EXACTLY));
         }
@@ -946,11 +923,8 @@
         mShortcutsAndWidgets.layout(left, top,
                 left + r - l,
                 top + b - t);
-        //piflow
-        if(mPiflowView != null){
-            mPiflowView.layout(left, top,
-                left + r - l,
-                top + b - t);
+        if (FeatureOption.SPRD_PIFLOW_SUPPORT && mPiflowView != null) {
+            mPiflowView.layout(left, top, left + r - l, top + b - t);
         }
     }
 
@@ -3052,4 +3026,23 @@
 
         return true;
     }
+
+    public boolean isPiflow(){
+        return mIsPiflow;
+    }
+
+    public void setPiflow(boolean isPiflow){
+        this.mIsPiflow = isPiflow;
+    }
+
+    public void addPiflowView(View piflowView){
+        if (FeatureOption.SPRD_PIFLOW_SUPPORT) {
+            this.mPiflowView = piflowView;
+            addView(mPiflowView);
+        }
+    }
+
+    public State getState(){
+        return mLauncher.getWorkspace().getState();
+    }
 }
Index: packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java	(revision 173368)
@@ -284,19 +284,8 @@
         if(numAppsCols <= 0){
             numAppsCols = DEFAULT_ALLAPPS_COLUMNS;
         }
-        /*
-		*
-		*int numPredictiveAppCols = Math.max(inv.minAllAppsPredictionColumns, numAppsCols);
-		*add wqq
-		*/
-		int numPredictiveAppCols;
-        if(isLandscape){
-            numPredictiveAppCols = Math.max(inv.minAllAppsPredictionColumns, numAppsCols);
-        }else {
-            numPredictiveAppCols =Math.max(inv.minAllAppsPredictionColumns, numAppsCols);
-        }
-        //allAppsNumCols = numAppsCols;
-        allAppsNumCols = 4;
+        int numPredictiveAppCols = Math.max(inv.minAllAppsPredictionColumns, numAppsCols);
+        allAppsNumCols = inv.numColumns;
         allAppsNumPredictiveCols = numPredictiveAppCols;
     }
 
Index: packages/apps/Launcher3/src/com/android/launcher3/FolderIcon.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/FolderIcon.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/FolderIcon.java	(revision 173368)
@@ -24,6 +24,7 @@
 import android.content.res.Resources;
 import android.graphics.Canvas;
 import android.graphics.Color;
+import android.graphics.Point;
 import android.graphics.PorterDuff;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
@@ -45,6 +46,13 @@
 import com.android.launcher3.FolderInfo.FolderListener;
 import com.android.launcher3.util.Thunk;
 
+import com.sprd.ext.UtilitiesExt;
+import com.sprd.ext.dynamicIcon.DynamicIconUtils;
+import com.sprd.ext.foldername.FolderNameUtils;
+import com.sprd.ext.FeatureOption;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.unreadnotifier.UnreadLoaderUtils;
+
 import java.util.ArrayList;
 
 /**
@@ -156,6 +164,7 @@
         FolderIcon icon = (FolderIcon) LayoutInflater.from(launcher).inflate(resId, group, false);
         icon.setClipToPadding(false);
         icon.mFolderName = (BubbleTextView) icon.findViewById(R.id.folder_icon_name);
+        FolderNameUtils.updateFolderTitle(launcher, folderInfo);
         icon.mFolderName.setText(folderInfo.title);
         icon.mFolderName.setCompoundDrawablePadding(0);
         FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) icon.mFolderName.getLayoutParams();
@@ -320,7 +329,7 @@
         return mFolder;
     }
 
-    FolderInfo getFolderInfo() {
+    public FolderInfo getFolderInfo() {
         return mInfo;
     }
 
@@ -579,7 +588,7 @@
         return params;
     }
 
-    private void drawPreviewItem(Canvas canvas, PreviewItemDrawingParams params) {
+    private void drawPreviewItem(Canvas canvas, PreviewItemDrawingParams params, TextView textView) {
         canvas.save();
         canvas.translate(params.transX + mPreviewOffsetX, params.transY + mPreviewOffsetY);
         canvas.scale(params.scale, params.scale);
@@ -588,26 +597,44 @@
         if (d != null) {
             mOldBounds.set(d.getBounds());
             d.setBounds(0, 0, mIntrinsicIconSize, mIntrinsicIconSize);
-            try {
-                if (d instanceof FastBitmapDrawable) {
-                    FastBitmapDrawable fd = (FastBitmapDrawable) d;
-                    float oldBrightness = fd.getBrightness();
-                    fd.setBrightness(params.overlayAlpha);
-                    d.draw(canvas);
-                    fd.setBrightness(oldBrightness);
-                } else {
-                    d.setColorFilter(Color.argb((int) (params.overlayAlpha * 255), 255, 255, 255),
-                            PorterDuff.Mode.SRC_ATOP);
-                    d.draw(canvas);
-                    d.clearColorFilter();
-                }
-            } catch (RuntimeException e) {
+            if (d instanceof FastBitmapDrawable) {
+                FastBitmapDrawable fd = (FastBitmapDrawable) d;
+                float oldBrightness = fd.getBrightness();
+                fd.setBrightness(params.overlayAlpha);
+                d.draw(canvas);
+                fd.setBrightness(oldBrightness);
+            } else {
+                d.setColorFilter(Color.argb((int) (params.overlayAlpha * 255), 255, 255, 255),
+                        PorterDuff.Mode.SRC_ATOP);
+                d.draw(canvas);
+                d.clearColorFilter();
             }
             d.setBounds(mOldBounds);
         }
         canvas.restore();
+
+        if (FeatureOption.SPRD_DYNAMIC_ICON_SUPPORT) {
+            if (textView != null) {
+                Object tag = textView.getTag();
+                if (tag instanceof ItemInfo) {
+                    ItemInfo info = (ItemInfo) tag;
+                    if (info.dynamicIconDrawCallback != null) {
+                        drawDynamicPartOfIcon(canvas, params, textView);
+                    }
+                }
+            }
+        }
     }
 
+    private void drawDynamicPartOfIcon(Canvas canvas, PreviewItemDrawingParams params, TextView textView) {
+        float offsetX = params.transX + mPreviewOffsetX + (params.scale * mIntrinsicIconSize) / 2;
+        float offsetY = params.transY + mPreviewOffsetY + (params.scale * mIntrinsicIconSize) / 2;
+        canvas.save();
+        Point center = new Point(Math.round(offsetX), Math.round(offsetY));
+        DynamicIconUtils.drawDynamicIconIfNeed(canvas, textView, params.scale, center);
+        canvas.restore();
+    }
+
     @Override
     protected void dispatchDraw(Canvas canvas) {
         super.dispatchDraw(canvas);
@@ -636,12 +663,16 @@
                     d = getTopDrawable(v);
                     mParams = computePreviewItemDrawingParams(i, mParams);
                     mParams.drawable = d;
-                    drawPreviewItem(canvas, mParams);
+                    drawPreviewItem(canvas, mParams, v);
                 }
             }
         } else {
-            drawPreviewItem(canvas, mAnimParams);
+            drawPreviewItem(canvas, mAnimParams, null);
         }
+        UtilitiesExt.drawDebugRect(canvas, getIconRect(), Color.GREEN);
+        if (FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
+            UnreadLoaderUtils.drawUnreadEventIfNeed(canvas, this);
+        }
     }
 
     private Drawable getTopDrawable(TextView v) {
@@ -709,11 +740,23 @@
     }
 
     public void onAdd(ShortcutInfo item) {
+        if (LogUtils.DEBUG) {
+            LogUtils.d(TAG, "onAdd item = " + item);
+        }
+        if (FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
+            UnreadLoaderUtils.updateFolderUnreadNum(this, item.intent.getComponent(), item.unreadNum);
+        }
         invalidate();
         requestLayout();
     }
 
     public void onRemove(ShortcutInfo item) {
+        if (LogUtils.DEBUG) {
+            LogUtils.d(TAG, "onRemove item = " + item);
+        }
+        if (FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
+            UnreadLoaderUtils.updateFolderUnreadNum(this, item.intent.getComponent(), item.unreadNum);
+        }
         invalidate();
         requestLayout();
     }
@@ -765,4 +808,19 @@
 
         mLongPressHelper.cancelLongPress();
     }
+
+    public Rect getIconRect() {
+        DeviceProfile grid = mLauncher.getDeviceProfile();
+        int iconSize = grid.folderIconSizePx;
+
+        Point center = new Point(getScrollX() + (getWidth() >> 1),
+                getScrollY() + getPaddingTop() + (iconSize >> 1));
+        Rect iconRect = new Rect();
+
+        iconRect.left   = center.x - (iconSize >> 1);
+        iconRect.top    = center.y - (iconSize >> 1);
+        iconRect.right  = iconRect.left + iconSize;
+        iconRect.bottom = iconRect.top + iconSize;
+        return iconRect;
+    }
 }
Index: packages/apps/Launcher3/src/com/android/launcher3/InstallShortcutReceiver.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/InstallShortcutReceiver.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/InstallShortcutReceiver.java	(revision 173368)
@@ -22,7 +22,6 @@
 import android.content.SharedPreferences;
 import android.content.pm.ActivityInfo;
 import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.text.TextUtils;
@@ -35,6 +34,7 @@
 import com.android.launcher3.compat.UserManagerCompat;
 import com.android.launcher3.util.PackageManagerHelper;
 import com.android.launcher3.util.Thunk;
+import com.sprd.ext.LogUtils;
 
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -49,7 +49,7 @@
 
 public class InstallShortcutReceiver extends BroadcastReceiver {
     private static final String TAG = "InstallShortcutReceiver";
-    private static final boolean DBG = false;
+    private static final boolean DBG = LogUtils.DEBUG;
 
     private static final String ACTION_INSTALL_SHORTCUT =
             "com.android.launcher.action.INSTALL_SHORTCUT";
@@ -283,6 +283,16 @@
             label = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
             user = UserHandleCompat.myUserHandle();
             activityInfo = null;
+
+            final UserHandleCompat extraUser = UserHandleCompat.fromIntent(data);
+            if (extraUser != null) {
+                long userId = UserManagerCompat.getInstance(mContext).getSerialNumberForUser(extraUser);
+                launchIntent.putExtra(ShortcutInfo.EXTRA_PROFILE, userId);
+                if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo extraUser:" + extraUser.toString());
+            }
+
+            if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo data:" + data.toString());
+            if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo launchIntent:" + launchIntent.toString());
         }
 
         /**
@@ -296,6 +306,9 @@
 
             launchIntent = AppInfo.makeLaunchIntent(context, info, user);
             label = info.getLabel().toString();
+            if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo info:" + info.toString());
+            if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo user:" + user.toString());
+            if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo launchIntent:" + launchIntent.toString());
         }
 
         public String encodeToString() {
@@ -349,6 +362,12 @@
                     json = json.key(ICON_RESOURCE_PACKAGE_NAME_KEY)
                             .value(iconResource.packageName);
                 }
+                final UserHandleCompat extraUser = UserHandleCompat.fromIntent(data);
+                if (extraUser != null) {
+                    long userId = UserManagerCompat.getInstance(mContext).getSerialNumberForUser(extraUser);
+                    json = json.key(USER_HANDLE_KEY).value(userId);
+                    if (DBG) LogUtils.d(TAG, "encodeToString extraUser:" + extraUser.toString());
+                }
                 return json.endObject().toString();
             } catch (JSONException e) {
                 Log.d(TAG, "Exception when adding shortcut: " + e);
@@ -415,6 +434,14 @@
                 data.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, iconResource);
             }
 
+            if (object.has(USER_HANDLE_KEY)) {
+                UserHandleCompat user = UserManagerCompat.getInstance(context)
+                        .getUserForSerialNumber(object.getLong(USER_HANDLE_KEY));
+                if (user != null) {
+                    data.putExtra( Intent.EXTRA_USER, user.getUser());
+                }
+            }
+
             return new PendingInstallShortcutInfo(data, context);
         } catch (JSONException | URISyntaxException e) {
             Log.d(TAG, "Exception reading shortcut to add: " + e);
@@ -431,24 +458,33 @@
             PendingInstallShortcutInfo original) {
         if (original.isLauncherActivity()) {
             // Already an activity target
+            if (DBG) LogUtils.d(TAG, "convertToLauncherActivityIfPossible, isLauncherActivity");
             return original;
         }
-        if (!Utilities.isLauncherAppTarget(original.launchIntent)
-                || !original.user.equals(UserHandleCompat.myUserHandle())) {
+        if (!Utilities.isLauncherAppTarget(original.launchIntent)) {
             // We can only convert shortcuts which point to a main activity in the current user.
+            if (DBG) LogUtils.d(TAG, "convertToLauncherActivityIfPossible, is not LauncherAppTarget");
             return original;
         }
+        if (!original.user.equals(UserHandleCompat.myUserHandle())) {
+            if (DBG) LogUtils.d(TAG, "convertToLauncherActivityIfPossible, is not Current User");
+            return original;
+        }
 
-        PackageManager pm = original.mContext.getPackageManager();
-        ResolveInfo info = pm.resolveActivity(original.launchIntent, 0);
+        UserHandleCompat user = original.user;
+        if (original.launchIntent != null && original.launchIntent.hasExtra(ShortcutInfo.EXTRA_PROFILE)) {
+            long serialNumber = original.launchIntent.getLongExtra(ShortcutInfo.EXTRA_PROFILE, -1);
+            user = UserManagerCompat.getInstance(original.mContext).getUserForSerialNumber(serialNumber);
+        }
+        LauncherActivityInfoCompat info = LauncherAppsCompat.getInstance(original.mContext)
+                .resolveActivity(original.launchIntent, user);
 
         if (info == null) {
+            if (DBG) LogUtils.d(TAG, "convertToLauncherActivityIfPossible, ResolveInfo is null");
             return original;
         }
 
         // Ignore any conflicts in the label name, as that can change based on locale.
-        LauncherActivityInfoCompat launcherInfo = LauncherActivityInfoCompat
-                .fromResolveInfo(info, original.mContext);
-        return new PendingInstallShortcutInfo(launcherInfo, original.mContext);
+        return new PendingInstallShortcutInfo(info, original.mContext);
     }
 }
Index: packages/apps/Launcher3/src/com/android/launcher3/InfoDropTarget.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/InfoDropTarget.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/InfoDropTarget.java	(revision 173368)
@@ -21,6 +21,7 @@
 import android.util.AttributeSet;
 
 import com.android.launcher3.compat.UserHandleCompat;
+import com.sprd.PlatformHelper;
 
 public class InfoDropTarget extends ButtonDropTarget {
 
@@ -64,6 +65,11 @@
 
     @Override
     protected boolean supportsDrop(DragSource source, Object info) {
+        /* Modify for bug628090 */
+        if (PlatformHelper.isCloneApp(getContext(), info)) {
+            return false;
+        }
+
         return source.supportsAppInfoDropTarget() && supportsDrop(getContext(), info);
     }
 
Index: packages/apps/Launcher3/src/com/android/launcher3/FolderInfo.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/FolderInfo.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/FolderInfo.java	(revision 173368)
@@ -20,6 +20,7 @@
 import android.content.Context;
 
 import com.android.launcher3.compat.UserHandleCompat;
+import com.sprd.ext.foldername.FolderNameUtils;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -98,6 +99,10 @@
         }
     }
 
+    public CharSequence getTitle(){
+        return this.title;
+    }
+
     @Override
     void onAddToDatabase(Context context, ContentValues values) {
         super.onAddToDatabase(context, values);
@@ -160,7 +165,14 @@
             options &= ~option;
         }
         if (context != null && oldOptions != options) {
-            LauncherModel.updateItemInDatabase(context, this);
+            if(FolderNameUtils.isDefaultFolderName(context, this)){
+                //Need not update folder name, when the folder name is default.
+                FolderInfo tempFoldInfo = this;
+                tempFoldInfo.title = "";
+                LauncherModel.updateItemInDatabase(context, tempFoldInfo);
+            }else{
+                LauncherModel.updateItemInDatabase(context, this);
+            }
         }
     }
 }
Index: packages/apps/Launcher3/src/com/android/launcher3/ShortcutInfo.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/ShortcutInfo.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/ShortcutInfo.java	(revision 173368)
@@ -27,6 +27,7 @@
 import com.android.launcher3.compat.LauncherActivityInfoCompat;
 import com.android.launcher3.compat.UserHandleCompat;
 import com.android.launcher3.compat.UserManagerCompat;
+import com.android.launcher3.util.FlagOp;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -126,7 +127,7 @@
      * Could be disabled, if the the app is installed but unavailable (eg. in safe mode or when
      * sd-card is not available).
      */
-    public int isDisabled = DEFAULT;
+    int isDisabled = DEFAULT;
 
     int status;
 
@@ -249,7 +250,9 @@
         return "ShortcutInfo(title=" + title + "intent=" + intent + "id=" + this.id
                 + " type=" + this.itemType + " container=" + this.container + " screen=" + screenId
                 + " cellX=" + cellX + " cellY=" + cellY + " spanX=" + spanX + " spanY=" + spanY
-                + " dropPos=" + Arrays.toString(dropPos) + " user=" + user + ")";
+                + " dropPos=" + Arrays.toString(dropPos) + " unreadNum= " + unreadNum
+                + " dynamicIconDrawCallback=" + dynamicIconDrawCallback
+                + " user=" + user + ")";
     }
 
     public static void dumpShortcutInfoList(String tag, String label,
@@ -297,6 +300,10 @@
         shortcut.intent = AppInfo.makeLaunchIntent(context, info, info.getUser());
         shortcut.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
         shortcut.flags = AppInfo.initFlags(info);
+        FlagOp flagOp = UserManagerCompat.getInstance(context).isQuietModeEnabled(info.getUser())
+                ? FlagOp.addFlag(ShortcutInfo.FLAG_DISABLED_QUIET_USER)
+                : FlagOp.removeFlag(ShortcutInfo.FLAG_DISABLED_QUIET_USER);
+        shortcut.isDisabled = flagOp.apply(shortcut.isDisabled);
         return shortcut;
     }
 
Index: packages/apps/Launcher3/src/com/android/launcher3/BubbleTextView.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/BubbleTextView.java	(revision 173367)
+++ packages/apps/Launcher3/src/com/android/launcher3/BubbleTextView.java	(revision 173368)
@@ -24,8 +24,10 @@
 import android.content.res.TypedArray;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Point;
+import android.graphics.Rect;
 import android.graphics.Region;
-import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
@@ -42,6 +44,12 @@
 import com.android.launcher3.IconCache.IconLoadRequest;
 import com.android.launcher3.model.PackageItemInfo;
 
+import com.sprd.ext.UtilitiesExt;
+import com.sprd.ext.dynamicIcon.DynamicIconUtils;
+import com.sprd.ext.FeatureOption;
+import com.sprd.ext.unreadnotifier.UnreadLoaderUtils;
+
+
 import java.text.NumberFormat;
 
 /**
@@ -81,6 +89,7 @@
     private final boolean mLayoutHorizontal;
     protected final int mIconSize;
     private int mTextColor;
+    private boolean mIsTextVisible;
 
     private boolean mStayPressed;
     private boolean mIgnorePressedStateChange;
@@ -149,9 +158,6 @@
             boolean promiseStateChanged) {
         Bitmap b = info.getIcon(iconCache);
 
-        LauncherAppState app = LauncherAppState.getInstance();
-        b = SprdUnreadInfoManager.getInstance().getBitmapWithUnreadInfo((ShortcutInfo)info, b);
-
         FastBitmapDrawable iconDrawable = mLauncher.createIconDrawable(b);
         if (info.isDisabled()) {
             iconDrawable.setState(FastBitmapDrawable.State.DISABLED);
@@ -169,17 +175,11 @@
     }
 
     public void applyFromApplicationInfo(AppInfo info) {
-        LauncherAppState app = LauncherAppState.getInstance();
-        Bitmap b = info.iconBitmap;
-        b = SprdUnreadInfoManager.getInstance().getBitmapWithUnreadInfo(info, b);
-        Drawable topDrawable = mLauncher.createIconDrawable(b);
-        setIcon(topDrawable, mIconSize);
-
-//        FastBitmapDrawable iconDrawable = mLauncher.createIconDrawable(info.iconBitmap);
-//        if (info.isDisabled()) {
-//            iconDrawable.setState(FastBitmapDrawable.State.DISABLED);
-//        }
-//        setIcon(iconDrawable, mIconSize);
+        FastBitmapDrawable iconDrawable = mLauncher.createIconDrawable(info.iconBitmap);
+        if (info.isDisabled()) {
+            iconDrawable.setState(FastBitmapDrawable.State.DISABLED);
+        }
+        setIcon(iconDrawable, mIconSize);
         setText(info.title);
         if (info.contentDescription != null) {
             setContentDescription(info.contentDescription);
@@ -374,6 +374,9 @@
     public void draw(Canvas canvas) {
         if (!mCustomShadowsEnabled) {
             super.draw(canvas);
+            drawDebugLayout(canvas);
+            drawUnreadEvent(canvas);
+            drawDynamicIcon(canvas);
             return;
         }
 
@@ -400,6 +403,9 @@
         if (getCurrentTextColor() == getResources().getColor(android.R.color.transparent)) {
             getPaint().clearShadowLayer();
             super.draw(canvas);
+            drawDebugLayout(canvas);
+            drawUnreadEvent(canvas);
+            drawDynamicIcon(canvas);
             return;
         }
 
@@ -413,6 +419,9 @@
         getPaint().setShadowLayer(SHADOW_SMALL_RADIUS, 0.0f, 0.0f, SHADOW_SMALL_COLOUR);
         super.draw(canvas);
         canvas.restore();
+        drawDebugLayout(canvas);
+        drawUnreadEvent(canvas);
+        drawDynamicIcon(canvas);
     }
 
     @Override
@@ -452,8 +461,13 @@
         } else {
             super.setTextColor(res.getColor(android.R.color.transparent));
         }
+        mIsTextVisible = visible;
     }
 
+    public boolean isTextVisible() {
+        return mIsTextVisible;
+    }
+
     @Override
     public void cancelLongPress() {
         super.cancelLongPress();
@@ -601,6 +615,12 @@
     }
 
     @Override
+    public boolean isDisabled() {
+        return getTag() instanceof ItemInfo
+                && ((ItemInfo) getTag()).isDisabled();
+    }
+
+    @Override
     public void setFastScrollFocusState(final FastBitmapDrawable.State focusState, boolean animated) {
         // We can only set the fast scroll focus state on a FastBitmapDrawable
         if (!(mIcon instanceof FastBitmapDrawable)) {
@@ -649,4 +669,37 @@
     public interface BubbleTextShadowHandler {
         void setPressedIcon(BubbleTextView icon, Bitmap background);
     }
+
+    private void drawUnreadEvent(Canvas canvas) {
+        if (!FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
+            return;
+        }
+        UnreadLoaderUtils.drawUnreadEventIfNeed(canvas, this);
+    }
+
+    private void drawDynamicIcon(Canvas canvas) {
+        if (!FeatureOption.SPRD_DYNAMIC_ICON_SUPPORT) {
+            return;
+        }
+        Point center = new Point(getScrollX() + (getWidth() / 2),
+                getScrollY() + getPaddingTop() + (mIconSize / 2));
+        DynamicIconUtils.drawDynamicIconIfNeed(canvas, this, DynamicIconUtils.STABLE_SCALE, center);
+    }
+
+    private void drawDebugLayout(Canvas canvas) {
+        UtilitiesExt.drawDebugRect(canvas, getIconRect(), Color.GREEN);
+    }
+
+    public Rect getIconRect() {
+        int iconSize = mIconSize;
+        Point center = new Point(getScrollX() + (getWidth() >> 1),
+                getScrollY() + getPaddingTop() + (iconSize >> 1));
+        Rect iconRect = new Rect();
+
+        iconRect.left   = center.x - (iconSize >> 1);
+        iconRect.top    = center.y - (iconSize >> 1);
+        iconRect.right  = iconRect.left + iconSize;
+        iconRect.bottom = iconRect.top + iconSize;
+        return iconRect;
+    }
 }
Index: packages/apps/Launcher3/res/values-zh-rCN/strings.xml
===================================================================
--- packages/apps/Launcher3/res/values-zh-rCN/strings.xml	(revision 173367)
+++ packages/apps/Launcher3/res/values-zh-rCN/strings.xml	(revision 173368)
@@ -104,5 +104,4 @@
     <string name="action_decrease_width" msgid="1374549771083094654">"减小宽度"</string>
     <string name="action_decrease_height" msgid="282377193880900022">"减小高度"</string>
     <string name="widget_resized" msgid="9130327887929620">"小部件尺寸已调整为：宽度 <xliff:g id="NUMBER_0">%1$s</xliff:g>，高度 <xliff:g id="NUMBER_1">%2$s</xliff:g>"</string>
-    <string name="unread_misscall_hint">"缺少电话和短信权限, 请检查您的权限设定"</string>
 </resources>
Index: packages/apps/Launcher3/res/values/colors.xml
===================================================================
--- packages/apps/Launcher3/res/values/colors.xml	(revision 173367)
+++ packages/apps/Launcher3/res/values/colors.xml	(revision 173368)
@@ -32,7 +32,7 @@
     <color name="workspace_edge_effect_color">#FFFFFFFF</color>
     <color name="folder_edge_effect_color">#FF757575</color>
 
-    <color name="quantum_panel_text_color">#FFFFFFFF</color>
+    <color name="quantum_panel_text_color">#FF666666</color>
     <color name="quantum_panel_bg_color">#FFF5F5F5</color>
     <color name="quantum_panel_bg_color_dark">#FF374248</color>
 
Index: packages/apps/Launcher3/res/values/styles.xml
===================================================================
--- packages/apps/Launcher3/res/values/styles.xml	(revision 173367)
+++ packages/apps/Launcher3/res/values/styles.xml	(revision 173368)
@@ -32,8 +32,8 @@
         <item name="android:layout_gravity">center</item>
         <item name="android:gravity">center_horizontal</item>
         <item name="android:singleLine">false</item>
-		<item name="android:maxLines">2</item>
-        <!--<item name="android:ellipsize">marquee</item>-->
+        <item name="android:maxLines">2</item>
+        <item name="android:ellipsize">marquee</item>
         <item name="android:textColor">@color/workspace_icon_text_color</item>
         <item name="android:shadowRadius">2.0</item>
         <item name="android:shadowColor">#B0000000</item>
Index: packages/apps/Launcher3/res/values/config.xml
===================================================================
--- packages/apps/Launcher3/res/values/config.xml	(revision 173367)
+++ packages/apps/Launcher3/res/values/config.xml	(revision 173368)
@@ -92,13 +92,4 @@
     <item type="id" name="action_move_screen_forwards" />
     <item type="id" name="action_resize" />
 
-    <string name="feature_app_sort" translatable="false">addon.sprd.launcher3.appsort.SprdAppSortAddon</string>
-    <string name="feature_launcher_drm" translatable="false">addon.sprd.launcher3.drm.AddonLauncherDrmUtils</string>
-
-    <string name="feature_cmcc_app" translatable="false">addon.sprd.launcher3.cmcc.SprdCmccWorkspaceAddon</string>
-
-    <string name="feature_cucc_app" translatable="false">addon.sprd.launcher3.cucc.SprdCuccWorkspaceAddon</string>
-    <string name="feature_dynamic_calendar" translatable="false">plugins.sprd.dynamic.calendar.CalendarBubbleTextViewAddon</string>
-    <string name="feature_dynamic_deskclock" translatable="false">plugins.sprd.dynamic.deskclock.ClockBubbleTextViewAddon</string>
-    <string name="unread_info_manager" translatable="false">plugins.sprd.unreadinfo.UnreadInfoManagerAddon</string>
 </resources>
Index: packages/apps/Launcher3/res/values/strings.xml
===================================================================
--- packages/apps/Launcher3/res/values/strings.xml	(revision 173367)
+++ packages/apps/Launcher3/res/values/strings.xml	(revision 173368)
@@ -32,7 +32,7 @@
 
     <!-- Application name -->
     <string name="app_name">Launcher3</string>
-    <!-- Default folder name -->
+    <!-- Default folder name, If need display default folder name, use the folder_default_name string on the ext -->
     <string name="folder_name"></string>
     <!-- Work folder name -->
     <string name="work_folder_name">Work</string>
@@ -118,7 +118,7 @@
     <!-- Text to inform the user that they can't uninstall a system application -->
     <string name="uninstall_system_app_text">This is a system app and can\'t be uninstalled.</string>
 
-    <!-- Default folder title -->
+    <!-- Default folder title, If need display default folder hint text, use the folder_default_name string on the ext -->
     <string name="folder_hint_text">Unnamed Folder</string>
 
     <!-- Accessibility -->
@@ -268,13 +268,4 @@
 
     <!-- Accessibility confirmation for widget resize. -->
     <string name="widget_resized">Widget resized to width <xliff:g id="number" example="2">%1$s</xliff:g> height <xliff:g id="number" example="1">%2$s</xliff:g></string>
-    <string name="unread_misscall_hint">"Missing Phone and SMS permissions, Please check your permission settings."</string>
-    <string name="title_text">Warning!</string>
-    <string name="iv_title_summary_text">Peringatan!</string>
-    <string name="tv_content_one_text">Your Andromax has been Rootd or Bootloader has been unlocked,any altering in the software or hardware component through sofware may cause damage to the device and harm the user.\n\nSmartfren disclaim any liability for harm to the user.</string>
-    <string name="tv_content_two_text">Your warranty is VOID!</string>
-    <string name="tv_content_three_text">The device will continue boot-up in  <xliff:g id="time">%1$s</xliff:g> seconds\n</string>
-    <string name="tv_content_four_text">Andromax Anda telah di Root atau dibuka Bootloader-nya,segala jenis perubahan pada software ataupun hardware melalui software dapat menyebabkan kerusakan pada perangkat dan membahayakon pengguna.\n\nSmartfren tidak bertanggung jawab atas resiko yang ditimbulkan.</string>
-    <string name="tv_content_five_text">Garansi Anda sudah tidak beriaku!</string>
-    <string name="tv_content_six_text">Perangkot akan menyala dalam 5 detik.</string>
 </resources>
Index: packages/apps/Launcher3/res/values/attrs.xml
===================================================================
--- packages/apps/Launcher3/res/values/attrs.xml	(revision 173367)
+++ packages/apps/Launcher3/res/values/attrs.xml	(revision 173368)
@@ -103,6 +103,7 @@
         <attr name="icon" format="reference" />
         <attr name="title" format="string" />
         <attr name="uri" format="string" />
+        <attr name="itemType" format="string" />
     </declare-styleable>
 
     <declare-styleable name="Extra">
Index: packages/apps/Launcher3/res/values/dimens.xml
===================================================================
--- packages/apps/Launcher3/res/values/dimens.xml	(revision 173367)
+++ packages/apps/Launcher3/res/values/dimens.xml	(revision 173368)
@@ -32,8 +32,7 @@
     <dimen name="dynamic_grid_search_bar_bottom_negative_padding_short">-6dp</dimen>
     <dimen name="dynamic_grid_search_bar_bottom_padding_tablet">16dp</dimen>
     <dimen name="dynamic_grid_page_indicator_height">20dp</dimen>
-    <!--<dimen name="dynamic_grid_icon_drawable_padding">4dp</dimen>-->
-	<dimen name="dynamic_grid_icon_drawable_padding">0dp</dimen>
+    <dimen name="dynamic_grid_icon_drawable_padding">4dp</dimen>
     <dimen name="dynamic_grid_workspace_page_spacing">8dp</dimen>
     <dimen name="dynamic_grid_overview_min_icon_zone_height">80dp</dimen>
     <dimen name="dynamic_grid_overview_max_icon_zone_height">120dp</dimen>
@@ -166,10 +165,4 @@
     <dimen name="pending_widget_min_padding">8dp</dimen>
     <dimen name="pending_widget_elevation">2dp</dimen>
 
-     <!-- Launcher unread info -->
-    <dimen name="unread_info_large_text_size">14dp</dimen>
-    <dimen name="unread_info_middle_text_size">12dp</dimen>
-    <dimen name="unread_info_small_text_size">10dp</dimen>
-    <dimen name="activity_horizontal_margin">16dp</dimen>
-    <dimen name="activity_vertical_margin">16dp</dimen>
 </resources>
Index: packages/apps/Launcher3/res/layout/all_apps_prediction_bar_icon.xml
===================================================================
--- packages/apps/Launcher3/res/layout/all_apps_prediction_bar_icon.xml	(revision 173367)
+++ packages/apps/Launcher3/res/layout/all_apps_prediction_bar_icon.xml	(revision 173368)
@@ -21,8 +21,8 @@
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
     android:layout_gravity="center"
-    android:paddingTop="@dimen/all_apps_prediction_icon_top_padding"
-    android:paddingBottom="@dimen/all_apps_prediction_icon_bottom_padding"
+    android:paddingTop="@dimen/all_apps_icon_top_bottom_padding"
+    android:paddingBottom="@dimen/all_apps_icon_top_bottom_padding"
     android:focusable="true"
     android:background="@drawable/focusable_view_bg"
     launcher:iconDisplay="all_apps" />
Index: packages/apps/Launcher3/res/values-zh-rTW/strings.xml
===================================================================
--- packages/apps/Launcher3/res/values-zh-rTW/strings.xml	(revision 173367)
+++ packages/apps/Launcher3/res/values-zh-rTW/strings.xml	(revision 173368)
@@ -104,5 +104,4 @@
     <string name="action_decrease_width" msgid="1374549771083094654">"減少寬度"</string>
     <string name="action_decrease_height" msgid="282377193880900022">"減少高度"</string>
     <string name="widget_resized" msgid="9130327887929620">"已將小工具的寬度和高度分別調整為 <xliff:g id="NUMBER_0">%1$s</xliff:g> 和 <xliff:g id="NUMBER_1">%2$s</xliff:g>"</string>
-    <string name="unread_misscall_hint">"缺乏電話和簡訊許可權, 請檢查您的權限設定"</string>
 </resources>
Index: packages/apps/Launcher3/res/xml/dw_phone_hotseat.xml
===================================================================
--- packages/apps/Launcher3/res/xml/dw_phone_hotseat.xml	(revision 173367)
+++ packages/apps/Launcher3/res/xml/dw_phone_hotseat.xml	(revision 173368)
@@ -22,9 +22,9 @@
         launcher:screen="0"
         launcher:x="0"
         launcher:y="0" >
-        <favorite
-            launcher:packageName="com.android.dialer"
-            launcher:className="com.android.dialer.DialtactsActivity" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.DIAL;end" />
+        <favorite launcher:uri="tel:123" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.CALL_BUTTON;end" />
     </resolve>
 
     <resolve
@@ -32,9 +32,11 @@
         launcher:screen="1"
         launcher:x="1"
         launcher:y="0" >
-        <favorite
-            launcher:packageName="com.android.messaging"
-            launcher:className="com.android.messaging.ui.conversationlist.ConversationListActivity" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_MESSAGING;end" />
+        <favorite launcher:uri="sms:" />
+        <favorite launcher:uri="smsto:" />
+        <favorite launcher:uri="mms:" />
+        <favorite launcher:uri="mmsto:" />
     </resolve>
 
     <!-- All Apps -->
@@ -45,8 +47,8 @@
         launcher:x="3"
         launcher:y="0" >
         <favorite
-            launcher:packageName="com.android.chrome"
-            launcher:className="com.google.android.apps.chrome.Main" />
+            launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_BROWSER;end" />
+        <favorite launcher:uri="http://www.example.com/" />
     </resolve>
 
     <resolve
@@ -54,9 +56,8 @@
         launcher:screen="4"
         launcher:x="4"
         launcher:y="0" >
-        <favorite
-            launcher:packageName="com.android.camera2"
-            launcher:className="com.android.camera.CameraLauncher" />
+        <favorite launcher:uri="#Intent;action=android.media.action.STILL_IMAGE_CAMERA;end" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.CAMERA_BUTTON;end" />
     </resolve>
 
 </favorites>
Index: packages/apps/Launcher3/res/xml/dw_tablet_hotseat.xml
===================================================================
--- packages/apps/Launcher3/res/xml/dw_tablet_hotseat.xml	(revision 173367)
+++ packages/apps/Launcher3/res/xml/dw_tablet_hotseat.xml	(revision 173368)
@@ -22,9 +22,11 @@
         launcher:screen="0"
         launcher:x="0"
         launcher:y="0" >
-        <favorite
-            launcher:packageName="com.android.messaging"
-            launcher:className="com.android.messaging.ui.conversationlist.ConversationListActivity" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_MESSAGING;end" />
+        <favorite launcher:uri="sms:" />
+        <favorite launcher:uri="smsto:" />
+        <favorite launcher:uri="mms:" />
+        <favorite launcher:uri="mmsto:" />
     </resolve>
 
     <resolve
@@ -32,9 +34,8 @@
         launcher:screen="1"
         launcher:x="1"
         launcher:y="0" >
-        <favorite
-            launcher:packageName="com.android.email"
-            launcher:className="com.android.email.activity.Welcome" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_EMAIL;end" />
+        <favorite launcher:uri="mailto:" />
     </resolve>
 
     <resolve
@@ -43,8 +44,8 @@
         launcher:x="2"
         launcher:y="0" >
         <favorite
-            launcher:packageName="com.android.browser"
-            launcher:className="com.android.browser.BrowserActivity" />
+            launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_BROWSER;end" />
+        <favorite launcher:uri="http://www.example.com/" />
     </resolve>
 
     <!-- All Apps -->
@@ -54,8 +55,7 @@
         launcher:screen="4"
         launcher:x="4"
         launcher:y="0"
-        launcher:packageName="com.android.music"
-        launcher:className="com.android.music.MusicBrowserActivity"/>
+        launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_MUSIC;end" />
 
     <resolve
         launcher:container="-101"
@@ -62,9 +62,8 @@
         launcher:screen="5"
         launcher:x="5"
         launcher:y="0" >
-        <favorite
-            launcher:packageName="com.android.gallery3d"
-            launcher:className="com.android.gallery3d.app.GalleryActivity" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_GALLERY;end" />
+        <favorite launcher:uri="#Intent;type=images/*;end" />
     </resolve>
 
     <resolve
@@ -72,9 +71,8 @@
         launcher:screen="6"
         launcher:x="6"
         launcher:y="0" >
-        <favorite
-            launcher:packageName="com.android.camera2"
-            launcher:className="com.android.camera.CameraLauncher" />
+        <favorite launcher:uri="#Intent;action=android.media.action.STILL_IMAGE_CAMERA;end" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.CAMERA_BUTTON;end" />
     </resolve>
 
 </favorites>
Index: packages/apps/Launcher3/res/xml/default_workspace_3x3.xml
===================================================================
--- packages/apps/Launcher3/res/xml/default_workspace_3x3.xml	(revision 173367)
+++ packages/apps/Launcher3/res/xml/default_workspace_3x3.xml	(revision 173368)
@@ -24,9 +24,11 @@
         launcher:screen="0"
         launcher:x="0"
         launcher:y="0" >
-        <favorite
-            launcher:packageName="com.android.messaging"
-            launcher:className="com.android.messaging.ui.conversationlist.ConversationListActivity" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_MESSAGING;end" />
+        <favorite launcher:uri="sms:" />
+        <favorite launcher:uri="smsto:" />
+        <favorite launcher:uri="mms:" />
+        <favorite launcher:uri="mmsto:" />
     </resolve>
 
     <!-- All Apps -->
@@ -36,26 +38,18 @@
         launcher:screen="2"
         launcher:x="2"
         launcher:y="0" >
-        <favorite
-            launcher:packageName="com.android.dialer"
-            launcher:className="com.android.dialer.DialtactsActivity" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.DIAL;end" />
+        <favorite launcher:uri="tel:123" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.CALL_BUTTON;end" />
     </resolve>
 
-    <favorite
-        launcher:className="com.android.settings.wifi.WifiSettings"
-        launcher:packageName="com.android.settings"
-        launcher:screen="0"
-        launcher:x="0"
-        launcher:y="2" />
-
     <!-- Bottom row -->
     <resolve
         launcher:screen="0"
         launcher:x="0"
         launcher:y="-1" >
-        <favorite
-            launcher:packageName="com.android.email"
-            launcher:className="com.android.email.activity.Welcome" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_EMAIL;end" />
+        <favorite launcher:uri="mailto:" />
     </resolve>
 
     <resolve
@@ -62,9 +56,8 @@
         launcher:screen="0"
         launcher:x="1"
         launcher:y="-1" >
-        <favorite
-            launcher:packageName="com.android.gallery3d"
-            launcher:className="com.android.gallery3d.app.GalleryActivity" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_GALLERY;end" />
+        <favorite launcher:uri="#Intent;type=images/*;end" />
     </resolve>
 
     <resolve
@@ -80,9 +73,8 @@
         launcher:screen="0"
         launcher:x="0"
         launcher:y="-2" >
-        <favorite
-            launcher:packageName="com.android.browser"
-            launcher:className="com.android.browser.BrowserActivity" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_BROWSER;end" />
+        <favorite launcher:uri="http://www.example.com/" />
     </resolve>
 
     <resolve
@@ -89,9 +81,14 @@
         launcher:screen="0"
         launcher:x="2"
         launcher:y="-2" >
-        <favorite
-            launcher:packageName="com.android.camera2"
-            launcher:className="com.android.camera.CameraLauncher" />
+        <favorite launcher:uri="#Intent;action=android.media.action.STILL_IMAGE_CAMERA;end" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.CAMERA_BUTTON;end" />
     </resolve>
 
+    <!-- base customization -->
+    <include launcher:workspace="@xml/dw_base_customize" />
+
+    <!-- vendor customization -->
+    <include launcher:workspace="@xml/dw_vendor_customize" />
+
 </favorites>
Index: packages/apps/Launcher3/res/xml/default_workspace_4x4.xml
===================================================================
--- packages/apps/Launcher3/res/xml/default_workspace_4x4.xml	(revision 173367)
+++ packages/apps/Launcher3/res/xml/default_workspace_4x4.xml	(revision 173368)
@@ -18,41 +18,20 @@
 
     <!-- Hotseat -->
     <include launcher:workspace="@xml/dw_phone_hotseat" />
-
     <appwidget
-        launcher:packageName="com.google.android.googlequicksearchbox"
-        launcher:className="com.google.android.googlequicksearchbox.SearchWidgetProvider"
-        launcher:screen="0"
-        launcher:x="0"
-        launcher:y="0"
-        launcher:spanX="4"
-        launcher:spanY="1" />
-
-    <appwidget
         launcher:packageName="com.android.deskclock"
         launcher:className="com.android.alarmclock.AnalogAppWidgetProvider"
         launcher:screen="0"
         launcher:x="1"
-        launcher:y="1"
+        launcher:y="0"
         launcher:spanX="2"
         launcher:spanY="2" />
-<!--
-    <favorite
-        launcher:className="com.android.settings.wifi.WifiSettings"
-        launcher:packageName="com.android.settings"
-        launcher:screen="0"
-        launcher:x="0"
-        launcher:y="2" />
--->
     <!-- Bottom row -->
-<!--
     <resolve
         launcher:screen="0"
         launcher:x="0"
         launcher:y="-1" >
-        <favorite
-            launcher:packageName="com.android.email"
-            launcher:className="com.android.email.activity.Welcome" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_EMAIL;end" />
         <favorite launcher:uri="mailto:" />
     </resolve>
 
@@ -60,13 +39,10 @@
         launcher:screen="0"
         launcher:x="1"
         launcher:y="-1" >
-        <favorite
-            launcher:packageName="com.android.gallery3d"
-            launcher:className="com.android.gallery3d.app.GalleryActivity" />
+        <favorite launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_GALLERY;end" />
+        <favorite launcher:uri="#Intent;type=images/*;end" />
     </resolve>
--->
 
-
     <resolve
         launcher:screen="0"
         launcher:x="3"
@@ -75,11 +51,10 @@
         <favorite launcher:uri="market://details?id=com.android.launcher" />
     </resolve>
 
-    <favorite
-        launcher:packageName="com.sprd.appbackup"
-        launcher:className="com.sprd.appbackup.activities.MainActivity"
-        launcher:screen="3"
-        launcher:x="3"
-        launcher:y="3" />
+    <!-- base customization -->
+    <include launcher:workspace="@xml/dw_base_customize" />
 
+    <!-- vendor customization -->
+    <include launcher:workspace="@xml/dw_vendor_customize" />
+
 </favorites>
Index: packages/apps/Launcher3/res/xml/default_workspace_5x5.xml
===================================================================
--- packages/apps/Launcher3/res/xml/default_workspace_5x5.xml	(revision 173367)
+++ packages/apps/Launcher3/res/xml/default_workspace_5x5.xml	(revision 173368)
@@ -19,21 +19,13 @@
     <!-- Hotseat -->
     <include launcher:workspace="@xml/dw_phone_hotseat" />
 
-    <favorite
-        launcher:className="com.android.settings.wifi.WifiSettings"
-        launcher:packageName="com.android.settings"
-        launcher:screen="0"
-        launcher:x="0"
-        launcher:y="2" />
-
     <!-- Bottom row -->
     <resolve
         launcher:screen="0"
         launcher:x="0"
         launcher:y="-1" >
-        <favorite
-	        launcher:packageName="com.android.email"
-	        launcher:className="com.android.email.activity.Welcome" />
+	    <favorite launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_EMAIL;end" />
+	    <favorite launcher:uri="mailto:" />
 
     </resolve>
 
@@ -41,9 +33,8 @@
         launcher:screen="0"
         launcher:x="1"
         launcher:y="-1" >
-        <favorite
-	        launcher:packageName="com.android.gallery3d"
-	        launcher:className="com.android.gallery3d.app.GalleryActivity" />
+	    <favorite launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_GALLERY;end" />
+	    <favorite launcher:uri="#Intent;type=images/*;end" />
 
     </resolve>
 
@@ -55,11 +46,10 @@
         <favorite launcher:uri="market://details?id=com.android.launcher" />
     </resolve>
 
-    <favorite
-        launcher:packageName="com.sprd.appbackup"
-        launcher:className="com.sprd.appbackup.activities.MainActivity"
-        launcher:screen="3"
-        launcher:x="3"
-        launcher:y="3" />
+    <!-- base customization -->
+    <include launcher:workspace="@xml/dw_base_customize" />
 
+    <!-- vendor customization -->
+    <include launcher:workspace="@xml/dw_vendor_customize" />
+
 </favorites>
Index: packages/apps/Launcher3/res/xml/default_workspace_5x6.xml
===================================================================
--- packages/apps/Launcher3/res/xml/default_workspace_5x6.xml	(revision 173367)
+++ packages/apps/Launcher3/res/xml/default_workspace_5x6.xml	(revision 173368)
@@ -19,20 +19,12 @@
     <!-- Hotseat -->
     <include launcher:workspace="@xml/dw_tablet_hotseat" />
 
-    <favorite
-        launcher:className="com.android.settings.wifi.WifiSettings"
-        launcher:packageName="com.android.settings"
-        launcher:screen="0"
-        launcher:x="0"
-        launcher:y="2" />
-
     <!-- Bottom row -->
     <favorite
-        launcher:packageName="com.android.contacts"
-        launcher:className="com.android.contacts.activities.PeopleActivity"
         launcher:screen="0"
         launcher:x="0"
-        launcher:y="-1" />
+        launcher:y="-1"
+        launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_CONTACTS;end" />
 
     <resolve
         launcher:screen="0"
@@ -42,11 +34,10 @@
         <favorite launcher:uri="market://details?id=com.android.launcher" />
     </resolve>
 
-    <favorite
-        launcher:packageName="com.sprd.appbackup"
-        launcher:className="com.sprd.appbackup.activities.MainActivity"
-        launcher:screen="3"
-        launcher:x="3"
-        launcher:y="3" />
+    <!-- base customization -->
+    <include launcher:workspace="@xml/dw_base_customize" />
 
+    <!-- vendor customization -->
+    <include launcher:workspace="@xml/dw_vendor_customize" />
+
 </favorites>
Index: packages/apps/Launcher3/build.gradle
===================================================================
--- packages/apps/Launcher3/build.gradle	(revision 173367)
+++ packages/apps/Launcher3/build.gradle	(revision 173368)
@@ -1,10 +1,11 @@
 buildscript {
     repositories {
-        mavenCentral()
+        // mavenCentral()
+        maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/'}
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.1.0'
-        classpath 'com.google.protobuf:protobuf-gradle-plugin:0.7.0'
+        classpath 'com.android.tools.build:gradle:2.1.3'
+        classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.1'
     }
 }
 
@@ -12,13 +13,13 @@
 apply plugin: 'com.google.protobuf'
 
 android {
-    compileSdkVersion 23
-    buildToolsVersion "22.0.1"
+    compileSdkVersion 24
+    buildToolsVersion "24.0.3"
 
     defaultConfig {
         applicationId "com.android.launcher3"
-        minSdkVersion 16
-        targetSdkVersion 23
+        minSdkVersion 21
+        targetSdkVersion 24
         versionCode 1
         versionName "1.0"
 
@@ -30,10 +31,14 @@
             minifyEnabled false
         }
     }
+    lintOptions {
+        disable 'MissingTranslation'
+        checkReleaseBuilds false
+    }
     sourceSets {
         main {
-            res.srcDirs = ['res', 'WallpaperPicker/res']
-            java.srcDirs = ['src', 'WallpaperPicker/src']
+            res.srcDirs = ['res', 'WallpaperPicker/res', 'ext/res']
+            java.srcDirs = ['src', 'WallpaperPicker/src', 'ext/src', 'ext/platform/sdk/src']
             manifest.srcFile 'AndroidManifest.xml'
             proto.srcDirs 'protos/'
         }
@@ -47,22 +52,56 @@
 }
 
 repositories {
-    mavenCentral()
+    //mavenCentral()
+    maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/'}
 }
 
 dependencies {
-    compile 'com.android.support:support-v4:23.1.1'
-    compile 'com.android.support:recyclerview-v7:23.1.1'
+    compile 'com.android.support:support-v4:24.+'
+    compile 'com.android.support:recyclerview-v7:24.+'
     compile 'com.google.protobuf.nano:protobuf-javanano:3.0.0-alpha-2'
 
     testCompile 'junit:junit:4.12'
     androidTestCompile 'com.android.support.test:runner:0.5'
     androidTestCompile 'com.android.support.test.uiautomator:uiautomator-v18:2.1.2'
+    androidTestCompile 'com.android.support:support-annotations:24.+'
+
+    provided files(getLayoutLibPath())
 }
 
+/** get layoutlib.jar path. android.os.SystemProperties need it. */
+// must called after "android" definition
+def getLayoutLibPath() {
+    def rootDir = project.rootDir
+    def localProperties = new File(rootDir, "local.properties")
+    if (localProperties.exists()) {
+        Properties properties = new Properties()
+        localProperties.withInputStream {
+            instr -> properties.load(instr)
+        }
+        def sdkDir = properties.getProperty('sdk.dir')
+        def compileSdkVersion = android.compileSdkVersion
+        Console.println("app compileSdkVersion : " + compileSdkVersion)
+        def androidJarPath = sdkDir + "/platforms/" + compileSdkVersion + "/data/layoutlib.jar"
+        return androidJarPath
+    }
+    return rootDir
+}
+
 protobuf {
     // Configure the protoc executable
     protoc {
         artifact = 'com.google.protobuf:protoc:3.0.0-alpha-3'
+
+        generateProtoTasks {
+            all().each { task ->
+                task.builtins {
+                    remove java
+                    javanano {
+                        option 'ignore_services=false'
+                    }
+                }
+            }
+        }
     }
 }
Index: packages/apps/Launcher3/ext/platform/sdk/src/com/sprd/PlatformHelper.java
===================================================================
--- packages/apps/Launcher3/ext/platform/sdk/src/com/sprd/PlatformHelper.java	(revision 0)
+++ packages/apps/Launcher3/ext/platform/sdk/src/com/sprd/PlatformHelper.java	(revision 173368)
@@ -0,0 +1,40 @@
+package com.sprd;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.UserHandle;
+import android.view.View;
+import android.view.animation.LayoutAnimationController;
+
+/**
+ * Created by SPRD on 2017/4/7.
+ */
+public class PlatformHelper {
+
+    public static Bundle overrideOptsBundle(View v, Bundle optsBundle,
+                                            LayoutAnimationController.AnimationParameters params) {
+        if (optsBundle == null) {
+            return null;
+        }
+        return optsBundle;
+    }
+
+    public static void startActivityAsUser(Context context, Intent intent,
+                                           Bundle options, UserHandle user) {
+        context.startActivity(intent, options);
+    }
+
+    public static boolean isCloneApp(Context context, Object obj) {
+        return false;
+    }
+
+    public static boolean isAppCloneUser(UserHandle user) {
+        return false;
+    }
+
+    public static boolean isMotionSoundEnable(Context context) {
+        return false;
+    }
+
+}
Index: packages/apps/Launcher3/ext/platform/target/src/com/sprd/PlatformHelper.java
===================================================================
--- packages/apps/Launcher3/ext/platform/target/src/com/sprd/PlatformHelper.java	(revision 0)
+++ packages/apps/Launcher3/ext/platform/target/src/com/sprd/PlatformHelper.java	(revision 173368)
@@ -0,0 +1,43 @@
+package com.sprd;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.view.View;
+import android.view.animation.LayoutAnimationController;
+
+/**
+ * Created by SPRD on 2017/4/7.
+ */
+public class PlatformHelper {
+
+    public static Bundle overrideOptsBundle(View v, Bundle optsBundle,
+                                            LayoutAnimationController.AnimationParameters params) {
+        if (optsBundle == null) {
+            return null;
+        }
+        return optsBundle;
+    }
+
+    public static void startActivityAsUser(Context context, Intent intent,
+                                           Bundle options, UserHandle user) {
+        context.startActivityAsUser(intent, options, user);
+    }
+
+    public static boolean isCloneApp(Context context, Object obj) {
+        return false;
+    }
+
+    public static boolean isAppCloneUser(UserHandle user) {
+        return false;
+    }
+    
+    public static boolean isMotionSoundEnable(Context context) {
+        int motion_sound = Settings.System.getInt(context.getContentResolver(),
+            Settings.System.MOTION_SOUND_EFFECT_ENABLED, 1);
+        return motion_sound == 1;
+    }
+
+}
Index: packages/apps/Launcher3/ext/AndroidManifest.xml
===================================================================
--- packages/apps/Launcher3/ext/AndroidManifest.xml	(revision 0)
+++ packages/apps/Launcher3/ext/AndroidManifest.xml	(revision 173368)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+        package="com.android.launcher3"
+        android:versionCode="1"
+        android:versionName="1.0"
+        >
+
+    <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="21" />
+    <application/>
+</manifest>
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/ShakeSensorDetector.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/ShakeSensorDetector.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/ShakeSensorDetector.java	(revision 173368)
@@ -0,0 +1,100 @@
+package com.sprd.ext;
+
+import android.content.Context;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+import android.os.SystemProperties;
+
+import java.util.ArrayList;
+
+
+public class ShakeSensorDetector implements SensorEventListener {
+    static final String TAG = "ShakeSensorDetector";
+
+    private Context mContext;
+    private SensorManager mSensorManager;
+    private boolean mHasRegisterShakeListener = false;
+    private ArrayList<OnShakeListener> mListeners;
+
+    public static final int SENSOR_RIGHT_SHAKE = 0;
+    public static final int SENSOR_LEFT_SHAKE = 1;
+
+    private long mLastUpdateTime;
+    private static final int TIME_THRESHOLD = 400;
+    private static final int MAX_SPEED_THRESHOLD = 10;
+    private static final int SQRT_SPEED_THRESHOLD = SystemProperties.getInt("ro.config.launcher.shakespeed", 25);
+
+    public ShakeSensorDetector(Context context) {
+        mContext = context;
+        mSensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
+        mListeners = new ArrayList<OnShakeListener>();
+    }
+
+    public interface OnShakeListener {
+        void onShake(int direction);
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent sensorEvent) {
+        float[] values = sensorEvent.values;
+        float x = values[0];
+        float y = values[0];
+
+        float current_speed  = (float) Math.sqrt(x*x + y*y);
+        if(Math.abs(x) < MAX_SPEED_THRESHOLD || current_speed < SQRT_SPEED_THRESHOLD){
+            return;
+        }
+
+        long currentTime = System.currentTimeMillis();
+        long diffTime = currentTime - mLastUpdateTime;
+        if(diffTime < TIME_THRESHOLD){
+           return;
+        }
+        mLastUpdateTime = currentTime;
+        if(LogUtils.DEBUG){
+            LogUtils.d(TAG,"onSensorChanged valid x = "+ x + " current_speed = "+ current_speed);
+        }
+
+        this.notifyListeners(x > 0 ? SENSOR_RIGHT_SHAKE : SENSOR_LEFT_SHAKE);
+    }
+
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int i) {
+    }
+
+    public void registerOnShakeListener(OnShakeListener listener) {
+        if (mListeners.contains(listener)) {
+            return;
+        }
+        mListeners.add(listener);
+    }
+
+    public void unregisterOnShakeListener(OnShakeListener listener) {
+        mListeners.remove(listener);
+    }
+
+    public void start() {
+        Sensor accelerometerSensor  = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
+        if(accelerometerSensor != null) {
+            mSensorManager.registerListener(this, accelerometerSensor, SensorManager.SENSOR_DELAY_UI);
+            mHasRegisterShakeListener = true;
+        }
+    }
+
+    public void stop() {
+        if(mHasRegisterShakeListener) {
+            mSensorManager.unregisterListener(this);
+            mHasRegisterShakeListener = false;
+        }
+    }
+
+    private void notifyListeners(int direction) {
+        for (OnShakeListener listener : mListeners) {
+            if(listener != null) {
+                listener.onShake(direction);
+            }
+        }
+    }
+}
\ No newline at end of file
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/LogUtils.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/LogUtils.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/LogUtils.java	(revision 173368)
@@ -0,0 +1,189 @@
+package com.sprd.ext;
+
+import android.os.Build;
+import android.os.SystemProperties;
+import android.util.Log;
+
+/**
+ * Created by SPRD on 2016/9/18.
+ */
+public final class LogUtils {
+
+    public static final String MODULE_NAME = "Launcher3";
+
+    private static LogUtils INSTANCE;
+
+    public static boolean DEBUG_ALL = false;
+    public static boolean DEBUG = false;
+    public static boolean DEBUG_LOADER = false;
+    public static boolean DEBUG_WIDGET = false;
+    public static boolean DEBUG_RECEIVER = false;
+    public static boolean DEBUG_RESUME_TIME = false;
+    public static boolean DEBUG_DUMP_LOG = false;
+    public static boolean DEBUG_UNREAD = false;
+    public static boolean DEBUG_DYNAMIC_ICON = false;
+    public static boolean DEBUG_DYNAMIC_ICON_ALL = false;
+    public static boolean DEBUG_PERFORMANCE = false;
+
+    /** use android properties to control debug on/off. */
+    // define system properties
+    private static final String PROP_DEBUG_ALL = "persist.sys.launcher.all";
+    private static final String PROP_DEBUG = "persist.sys.launcher.debug";
+    private static final String PROP_DEBUG_LOADER = "persist.sys.launcher.loader";
+    private static final String PROP_DEBUG_WIDGET = "persist.sys.launcher.widget";
+    private static final String PROP_DEBUG_RECEIVER = "persist.sys.launcher.receiver";
+    private static final String PROP_DEBUG_RESUME_TIME = "persist.sys.launcher.resume";
+    private static final String PROP_DEBUG_DUMP_LOG = "persist.sys.launcher.dumplog";
+    private static final String PROP_DEBUG_UNREAD = "persist.sys.launcher.unread";
+    private static final String PROP_DEBUG_DYNAMIC_ICON = "persist.sys.launcher.dyicon";
+    private static final String PROP_DEBUG_DYNAMIC_ICON_ALL = "persist.sys.launcher.dy.all";
+    private static final String PROP_DEBUG_PERFORMANCE = "persist.sys.launcher.perform";
+    /** end */
+
+    static {
+        DEBUG_ALL = SystemProperties.getBoolean(PROP_DEBUG_ALL, false);
+        if (DEBUG_ALL) {
+            DEBUG = true;
+            DEBUG_LOADER = true;
+            DEBUG_WIDGET = true;
+            DEBUG_RECEIVER = true;
+            DEBUG_RESUME_TIME = true;
+            DEBUG_DUMP_LOG = true;
+            DEBUG_UNREAD = true;
+            DEBUG_DYNAMIC_ICON = true;
+            DEBUG_DYNAMIC_ICON_ALL= true;
+            DEBUG_PERFORMANCE = true;
+        } else {
+            DEBUG = SystemProperties.getBoolean(PROP_DEBUG, !Build.TYPE.equals("user"));
+            DEBUG_LOADER = SystemProperties.getBoolean(PROP_DEBUG_LOADER, DEBUG);
+            DEBUG_WIDGET = SystemProperties.getBoolean(PROP_DEBUG_WIDGET, false);
+            DEBUG_RECEIVER = SystemProperties.getBoolean(PROP_DEBUG_RECEIVER, DEBUG);
+            DEBUG_RESUME_TIME = SystemProperties.getBoolean(PROP_DEBUG_RESUME_TIME, false);
+            DEBUG_DUMP_LOG = SystemProperties.getBoolean(PROP_DEBUG_DUMP_LOG, false);
+            DEBUG_UNREAD = SystemProperties.getBoolean(PROP_DEBUG_UNREAD, false);
+            DEBUG_DYNAMIC_ICON = SystemProperties.getBoolean(PROP_DEBUG_DYNAMIC_ICON, false);
+            DEBUG_DYNAMIC_ICON_ALL = DEBUG_DYNAMIC_ICON &&
+                SystemProperties.getBoolean(PROP_DEBUG_DYNAMIC_ICON_ALL, false);
+            DEBUG_PERFORMANCE = SystemProperties.getBoolean(PROP_DEBUG_PERFORMANCE, false);
+        }
+    }
+    /**
+     * private constructor here, It is a singleton class.
+     */
+    private LogUtils() {
+    }
+
+
+    public static LogUtils getInstance() {
+        if (INSTANCE == null) {
+            INSTANCE = new LogUtils();
+        }
+        return INSTANCE;
+    }
+
+    /**
+     * The method prints the log, level error.
+     *
+     * @param tag the tag of the class.
+     * @param msg the message to print.
+     */
+    public static void e(String tag, String msg) {
+        Log.e(MODULE_NAME, tag + ", " + msg);
+    }
+
+    /**
+     * The method prints the log, level error.
+     *
+     * @param tag the tag of the class.
+     * @param msg the message to print.
+     * @param t an exception to log.
+     */
+    public static void e(String tag, String msg, Throwable t) {
+        Log.e(MODULE_NAME, tag + ", " + msg, t);
+    }
+
+    /**
+     * The method prints the log, level warning.
+     *
+     * @param tag the tag of the class.
+     * @param msg the message to print.
+     */
+    public static void w(String tag, String msg) {
+        Log.w(MODULE_NAME, tag + ", " + msg);
+    }
+
+    /**
+     * The method prints the log, level warning.
+     *
+     * @param tag the tag of the class.
+     * @param msg the message to print.
+     * @param t an exception to log.
+     */
+    public static void w(String tag, String msg, Throwable t) {
+        Log.w(MODULE_NAME, tag + ", " + msg, t);
+    }
+
+    /**
+     * The method prints the log, level debug.
+     *
+     * @param tag the tag of the class.
+     * @param msg the message to print.
+     */
+    public static void i(String tag, String msg) {
+        Log.i(MODULE_NAME, tag + ", " + msg);
+    }
+
+    /**
+     * The method prints the log, level debug.
+     *
+     * @param tag the tag of the class.
+     * @param msg the message to print.
+     * @param t an exception to log.
+     */
+    public static void i(String tag, String msg, Throwable t) {
+        Log.i(MODULE_NAME, tag + ", " + msg, t);
+    }
+
+    /**
+     * The method prints the log, level debug.
+     *
+     * @param tag the tag of the class.
+     * @param msg the message to print.
+     */
+    public static void d(String tag, String msg) {
+        Log.d(MODULE_NAME, tag + ", " + msg);
+    }
+
+    /**
+     * The method prints the log, level debug.
+     *
+     * @param tag the tag of the class.
+     * @param msg the message to print.
+     * @param t An exception to log.
+     */
+    public static void d(String tag, String msg, Throwable t) {
+        Log.d(MODULE_NAME, tag + ", " + msg, t);
+    }
+
+    /**
+     * The method prints the log, level debug.
+     *
+     * @param tag the tag of the class.
+     * @param msg the message to print.
+     */
+    public static void v(String tag, String msg) {
+        Log.v(MODULE_NAME, tag + ", " + msg);
+    }
+
+    /**
+     * The method prints the log, level debug.
+     *
+     * @param tag the tag of the class.
+     * @param msg the message to print.
+     * @param t An exception to log.
+     */
+    public static void v(String tag, String msg, Throwable t) {
+        Log.v(MODULE_NAME, tag + ", " + msg, t);
+    }
+
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/circleslide/CircleSlideUtils.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/circleslide/CircleSlideUtils.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/circleslide/CircleSlideUtils.java	(revision 173368)
@@ -0,0 +1,33 @@
+package com.sprd.ext.circleslide;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+
+import com.android.launcher3.R;
+import com.android.launcher3.Utilities;
+import com.sprd.ext.UtilitiesExt;
+/**
+ * Created by SPRD on 2016/9/18.
+ * You can search the key word "circular" to look all modifiy about this.
+ */
+public class CircleSlideUtils {
+    public static final String PREF_CIRCLE_SLIDE_KEY = "pref_allowCircularSliding";
+    public static final String HAS_CUSTOMCONTENT_KEY = "has_customcontent";
+
+    public static boolean isCircleSlideEnabled(Context context) {
+        return UtilitiesExt.getLauncherSettingsBoolean(context, PREF_CIRCLE_SLIDE_KEY, context.getResources().getBoolean(R.bool.allow_circle_slide));
+    }
+
+    public static void setHasCustomContent(Context context,boolean bool){
+        SharedPreferences.Editor editor = Utilities.getPrefs(context).edit();
+
+        editor.putBoolean(HAS_CUSTOMCONTENT_KEY, bool);
+        editor.apply();
+    }
+
+    //return Launcher ishas CustomContent
+    public static boolean hasCustomContent(Context context){
+        return Utilities.getPrefs(context).getBoolean(HAS_CUSTOMCONTENT_KEY,false);
+    }
+
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/BadgeUtils.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/BadgeUtils.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/BadgeUtils.java	(revision 173368)
@@ -0,0 +1,210 @@
+package com.sprd.ext;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.graphics.Typeface;
+import android.text.TextUtils;
+import android.view.View;
+
+import com.android.launcher3.BubbleTextView;
+import com.android.launcher3.FolderIcon;
+import com.android.launcher3.R;
+
+/**
+ * Created by sprd on 2017/5/30.
+ */
+public class BadgeUtils {
+    private static final float ROUNDRECT_ARC_X = 30.0f;
+    private static final float ROUNDRECT_ARC_Y = 30.0f;
+
+    private static final String BLANK_STRING = " ";
+
+    private static Paint sBgPaint;
+    private static Paint sTextPaint;
+
+    public enum BadgeMode {LT_BADGE, RT_BADGE, LB_BADGE, RB_BADGE}
+
+    public static void drawBadge(Canvas canvas, View v, String text) {
+        drawBadge(canvas, v, text, BadgeMode.RT_BADGE);
+    }
+
+    public static Rect drawBadge(Canvas canvas, View v, String text, BadgeMode mode) {
+        if (canvas == null || v == null) {
+            return null;
+        }
+
+        //init text
+        if (TextUtils.isEmpty(text)) {
+            text = BLANK_STRING;
+        }
+
+        //init view rect
+        Rect vRect = new Rect();
+        v.getDrawingRect(vRect);
+
+        //init icon rect
+        Rect iconRect = new Rect(vRect);
+        if (v instanceof BubbleTextView) {
+            iconRect = ((BubbleTextView)v).getIconRect();
+        } else if (v instanceof FolderIcon) {
+            iconRect = ((FolderIcon)v).getIconRect();
+        }
+
+        //init paint
+        Paint textPaint = sTextPaint == null ? createTextPaint(v.getContext()) : sTextPaint;
+        Paint bgPaint = sBgPaint == null ? createBgPaint(v.getContext()) : sBgPaint;
+
+        canvas.save();
+
+        //init text bounds
+        Paint.FontMetrics fm = textPaint.getFontMetrics();
+        Rect textBounds = new Rect();
+        textBounds.left = 0;
+        textBounds.top = 0;
+        textBounds.right = Math.round(textPaint.measureText(text));
+        textBounds.bottom = Math.round(fm.descent - fm.ascent);
+        long minHeight = Math.round(Math.sqrt((textBounds.height() * textBounds.height()) << 1));
+        if (textBounds.width() <= textBounds.height()) {
+            textBounds.right = textBounds.bottom = (int) minHeight;
+        } else {
+            textBounds.right += Math.round(textPaint.measureText(BLANK_STRING));
+            textBounds.bottom = (int) minHeight;
+        }
+
+        //draw badge bg
+        Rect badgeRect = getBadgeRect(vRect, iconRect, textBounds, mode);
+        if (badgeRect.width() == badgeRect.height()) {
+            canvas.drawCircle(badgeRect.centerX(), badgeRect.centerY(), (badgeRect.width() >> 1), bgPaint);
+        } else {
+            canvas.drawRoundRect(new RectF(badgeRect), ROUNDRECT_ARC_X, ROUNDRECT_ARC_Y, bgPaint);
+        }
+
+        //draw badge text
+        Point drawPoint = UtilitiesExt.getTextDrawPoint(badgeRect, fm);
+        canvas.drawText(text, drawPoint.x, drawPoint.y, textPaint);
+
+        UtilitiesExt.drawDebugRect(canvas, badgeRect, Color.YELLOW);
+        canvas.restore();
+
+        return badgeRect;
+    }
+
+    private static Paint createBgPaint(Context context) {
+        Resources res = context.getResources();
+        Paint bgPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        bgPaint.setColor(res.getColor(R.color.badge_bg_color));
+        bgPaint.setStyle(Paint.Style.FILL);
+        bgPaint.setAntiAlias(true);
+        return bgPaint;
+    }
+
+    private static Paint createTextPaint(Context context) {
+        Resources res = context.getResources();
+        Paint textPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        textPaint.setColor(res.getColor(R.color.badge_text_color));
+        textPaint.setTextSize(res.getDimension( R.dimen.badge_text_size));
+        Typeface font = Typeface.create("sans-serif", Typeface.BOLD);
+        textPaint.setTypeface(font);
+        textPaint.setTextAlign(Paint.Align.CENTER);
+        textPaint.setAntiAlias(true);
+        return textPaint;
+    }
+
+    private static Rect getBadgeRect(Rect viewRect, Rect iconRect, Rect textBounds, BadgeMode mode) {
+        Rect badgeRect = new Rect(textBounds);
+        int halfWidth;
+        int halfHeight;
+
+        switch (mode) {
+            case LT_BADGE:
+                textBounds.offsetTo(iconRect.left, iconRect.top);
+                textBounds.right = Math.min(textBounds.right, iconRect.left + (iconRect.width() >> 1));
+                halfWidth = textBounds.width() >> 1;
+                halfHeight = textBounds.height() >> 1;
+
+                badgeRect.left = iconRect.left - halfWidth;
+                badgeRect.top = iconRect.top - halfHeight;
+                badgeRect.right = iconRect.left + halfWidth;
+                badgeRect.bottom = iconRect.top + halfHeight;
+                break;
+            case RT_BADGE:
+                textBounds.offsetTo(iconRect.right - (iconRect.width() >> 1), iconRect.top);
+                textBounds.right = Math.min(textBounds.right, iconRect.right);
+                halfWidth = textBounds.width() >> 1;
+                halfHeight = textBounds.height() >> 1;
+
+                badgeRect.left = iconRect.right - halfWidth;
+                badgeRect.top = iconRect.top - halfHeight;
+                badgeRect.right = iconRect.right + halfWidth;
+                badgeRect.bottom = iconRect.top + halfHeight;
+                break;
+            case LB_BADGE:
+                textBounds.offsetTo(iconRect.left, iconRect.top);
+                textBounds.right = Math.min(textBounds.right, iconRect.left + (iconRect.width() >> 1));
+                halfWidth = textBounds.width() >> 1;
+                halfHeight = textBounds.height() >> 1;
+
+                badgeRect.left = iconRect.left - halfWidth;
+                badgeRect.top = iconRect.bottom - halfHeight;
+                badgeRect.right = iconRect.left + halfWidth;
+                badgeRect.bottom = iconRect.bottom + halfHeight;
+                break;
+            case RB_BADGE:
+                textBounds.offsetTo(iconRect.right - (iconRect.width() >> 1), iconRect.top);
+                textBounds.right = Math.min(textBounds.right, iconRect.right);
+                halfWidth = textBounds.width() >> 1;
+                halfHeight = textBounds.height() >> 1;
+
+                badgeRect.left = iconRect.right - halfWidth;
+                badgeRect.top = iconRect.bottom - halfHeight;
+                badgeRect.right = iconRect.right + halfWidth;
+                badgeRect.bottom = iconRect.bottom + halfHeight;
+                break;
+        }
+
+        badgeRect.right = badgeRect.height() > badgeRect.width() ?
+                badgeRect.left + badgeRect.height() : badgeRect.right;
+        Point offset = calcOffset(badgeRect, viewRect, mode);
+        badgeRect.offset(offset.x, offset.y);
+
+        return badgeRect;
+    }
+
+    private static Point calcOffset(Rect badgeRect, Rect viewRect, BadgeMode mode) {
+        Point p = new Point();
+        switch (mode) {
+            case LT_BADGE:
+                p.x = badgeRect.left < viewRect.left ? viewRect.left - badgeRect.left + 1 : 0;
+                p.y = badgeRect.top < viewRect.top ? viewRect.top - badgeRect.top + 1 : 0;
+                break;
+            case RT_BADGE:
+                p.x = badgeRect.right > viewRect.right ? viewRect.right - badgeRect.right - 1 : 0;
+                p.y = badgeRect.top < viewRect.top ? viewRect.top - badgeRect.top + 1 : 0;
+                break;
+            case LB_BADGE:
+                p.x = badgeRect.left < viewRect.left ? viewRect.left - badgeRect.left + 1 : 0;
+                p.y = badgeRect.bottom > viewRect.bottom ? viewRect.bottom - badgeRect.bottom - 1 : 0;
+                break;
+            case RB_BADGE:
+                p.x = badgeRect.right > viewRect.right ? viewRect.right - badgeRect.right - 1 : 0;
+                p.y = badgeRect.bottom > viewRect.bottom ? viewRect.bottom - badgeRect.bottom - 1 : 0;
+                break;
+        }
+
+        return p;
+    }
+
+    public static void setBgPaint(final Paint paint) {
+        sBgPaint = paint;
+    }
+
+    public static void setTextPaint(final Paint paint) {
+        sTextPaint = paint;
+    }
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/root/RootBootLoader.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/root/RootBootLoader.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/root/RootBootLoader.java	(revision 173368)
@@ -0,0 +1,43 @@
+package com.sprd.ext.root;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.widget.TextView;
+
+import com.android.launcher3.R;
+
+/**
+ * Created by SPRD on 2017/6/24.
+ */
+public class RootBootLoader extends Activity {
+    private static final int FLASH_TIME_MESSAGE = 0;
+    private TextView mTimeTv;
+    private int TIME = 5;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView( R.layout.rootbootloader);
+        mTimeTv = (TextView)findViewById(R.id.tv_content_three);
+        mTimeTv.setText(getString(R.string.tv_content_three_text, 5));
+        mHandler.sendEmptyMessageDelayed(FLASH_TIME_MESSAGE, 2000);
+    }
+
+    private Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            if (msg.what == FLASH_TIME_MESSAGE) {
+                if (TIME > 0) {
+                    String time = getString(R.string.tv_content_three_text, TIME--);
+                    mTimeTv.setText(time);
+                    mHandler.sendEmptyMessageDelayed(FLASH_TIME_MESSAGE, 1000);
+                } else {
+                    finish();
+                }
+            }
+            super.handleMessage(msg);
+        }
+    };
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/root/RootUtil.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/root/RootUtil.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/root/RootUtil.java	(revision 173368)
@@ -0,0 +1,42 @@
+package com.sprd.ext.root;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.InputStreamReader;
+
+/**
+ * Created by SPRD on 2017/6/24.
+ */
+public class RootUtil {
+    public static boolean isDeviceRooted() {
+        return checkRootMethod1() || checkRootMethod2() || checkRootMethod3();
+    }
+
+    private static boolean checkRootMethod1() {
+        String buildTags = android.os.Build.TAGS;
+        return buildTags != null && buildTags.contains("test-keys");
+    }
+
+    private static boolean checkRootMethod2() {
+        String[] paths = { "/system/app/Superuser.apk", "/sbin/su", "/system/bin/su", "/system/xbin/su",
+                "/data/local/xbin/su", "/data/local/bin/su", "/system/sd/xbin/su"};
+        for (String path : paths) {
+            if (new File(path).exists()) return true;
+        }
+        return false;
+    }
+
+    private static boolean checkRootMethod3() {
+        Process process = null;
+        try {
+            process = Runtime.getRuntime().exec(new String[] {"/system/xbin/which", "su"});
+            BufferedReader in = new BufferedReader(new InputStreamReader(process.getInputStream()));
+            if (in.readLine() != null) return true;
+            return false;
+        } catch (Throwable t) {
+            return false;
+        } finally {
+            if (process != null) process.destroy();
+        }
+    }
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/shakewallpaper/WallpaperChangeController.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/shakewallpaper/WallpaperChangeController.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/shakewallpaper/WallpaperChangeController.java	(revision 173368)
@@ -0,0 +1,159 @@
+package com.sprd.ext.shakewallpaper;
+
+import android.app.WallpaperManager;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.Handler;
+import android.os.Message;
+
+import com.android.launcher3.Launcher;
+import com.android.launcher3.Utilities;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.UtilitiesExt;
+import com.sprd.ext.ShakeSensorDetector;
+import com.android.launcher3.R;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+/**
+ * Created by SPRD on 2017/1/2.
+ */
+
+public class WallpaperChangeController {
+    private static final String TAG = "WallpaperChangeController";
+    private Context mContext;
+    private static ArrayList mWallpaperList = new ArrayList();
+    private static int mCurrentWallpaperIndex = 0;
+    private boolean mIsShakeWallpaperEnabled = false;
+
+    public static final String ALLOW_SHAKE_CHANGE_WALLPAPER_KEY = "pref_shake_change_wallpaper";
+
+    private static final int DELAY_SHAKE_CHANGE_WALLPAPER_TIME = 100;
+    private static final int SHAKE_CHANGE_WALLPAPER = 0;
+
+    private static final String WALLPAPERS_COUNT_KEY = "wallpapers_count";
+    private static final int INVALID_VALUE = -1;
+
+    private Handler mHandler = new Handler(){
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what){
+                case SHAKE_CHANGE_WALLPAPER:
+                    int direction = (int) msg.obj;
+                    setWallpaper(direction);
+                    if (LogUtils.DEBUG) {
+                        LogUtils.d(TAG, "shake hange wallpaper,direction  = " + direction);
+                    }
+                    break;
+            }
+        }
+    };
+
+    public WallpaperChangeController(Context context){
+        mContext = context;
+        mWallpaperList = getWallpaperResId(mContext);
+        mIsShakeWallpaperEnabled = isShakeWallapaperEnable(mContext) && (mWallpaperList.size() > 0);
+    }
+
+    private ShakeSensorDetector.OnShakeListener mShakeWallpaperListener =  new ShakeSensorDetector.OnShakeListener() {
+        @Override
+        public void onShake(int direction) {
+            if(mContext instanceof Launcher) {
+                if (((Launcher) mContext).isWorkspaceVisible()) {
+                    Message msg = mHandler.obtainMessage(SHAKE_CHANGE_WALLPAPER, direction);
+                    mHandler.removeMessages(SHAKE_CHANGE_WALLPAPER);
+                    mHandler.sendMessageDelayed(msg, DELAY_SHAKE_CHANGE_WALLPAPER_TIME);
+                }
+            }
+        }
+    };
+
+    public  void registerShakeWallpaperListener(ShakeSensorDetector shakeDetector){
+        shakeDetector.registerOnShakeListener(mShakeWallpaperListener);
+    }
+
+    public  void unregisterShakeWallpaperLisener(ShakeSensorDetector shakeDetector){
+            shakeDetector.unregisterOnShakeListener(mShakeWallpaperListener);
+    }
+
+    private boolean isShakeWallapaperEnable(Context context){
+        return UtilitiesExt.getLauncherSettingsBoolean(context,ALLOW_SHAKE_CHANGE_WALLPAPER_KEY,
+                context.getResources().getBoolean(R.bool.allow_shake_change_wallpaper));
+    }
+
+    public void setShakeWallpaperEnabled(boolean isShakeWallpaperEnabled){
+        mIsShakeWallpaperEnabled = isShakeWallpaperEnabled;
+    }
+    public boolean getShakeWallpaperEnabled(){
+        return mIsShakeWallpaperEnabled;
+    }
+
+    public static int getWallpapersCount(Context context) {
+        SharedPreferences sp = Utilities.getPrefs(context);
+        int count = sp.getInt(WALLPAPERS_COUNT_KEY, INVALID_VALUE);
+        if(count != INVALID_VALUE){
+            return count;
+        }else{
+            count = getWallpaperResId(context).size();
+        }
+        return count;
+    }
+
+    public static ArrayList getWallpaperResId(Context context){
+        ArrayList wallpaperList = new ArrayList();
+
+        String[] tempStr = context.getResources().getStringArray(R.array.wallpapers);
+        String packageName = context.getResources().getResourcePackageName(R.array.wallpapers);
+
+        for (String extra : tempStr) {
+            if (extra.endsWith("_small")) {
+                // it is a thumbnail
+                continue;
+            }
+            int resId = context.getResources().getIdentifier(extra, "drawable", packageName);
+            if (resId != 0) {
+                if(wallpaperList != null){
+                    wallpaperList.add(resId);
+                }
+            }
+        }
+
+        SharedPreferences sp = Utilities.getPrefs(context);
+        sp.edit().putInt(WALLPAPERS_COUNT_KEY, wallpaperList.size()).apply();
+        return wallpaperList;
+    }
+
+
+    private int getNextWallpaperIndex(int direction){
+        if(direction == ShakeSensorDetector.SENSOR_LEFT_SHAKE){
+            mCurrentWallpaperIndex --;
+            if(mCurrentWallpaperIndex < 0){
+                mCurrentWallpaperIndex = mWallpaperList.size() - 1;
+            }
+        }else if(direction == ShakeSensorDetector.SENSOR_RIGHT_SHAKE){
+            mCurrentWallpaperIndex ++;
+            if(mCurrentWallpaperIndex >= mWallpaperList.size()){
+                mCurrentWallpaperIndex = 0;
+            }
+        }
+        return mCurrentWallpaperIndex;
+    }
+
+    public void setWallpaper(int direction){
+        try {
+            final WallpaperManager  wallpaperManager = WallpaperManager.getInstance(mContext);
+            int nextWallpaperIndex = getNextWallpaperIndex(direction);
+            if(LogUtils.DEBUG){
+                LogUtils.d(TAG,"shake change nextWallpaperIndex  = "+ nextWallpaperIndex);
+            }
+            int resId = (int) mWallpaperList.get(nextWallpaperIndex);
+            if (resId != 0) {
+                wallpaperManager.setResource(resId);
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/FeatureOption.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/FeatureOption.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/FeatureOption.java	(revision 173368)
@@ -0,0 +1,56 @@
+package com.sprd.ext;
+
+import android.os.SystemProperties;
+
+/**
+ * Created by SPRD on 2016/9/27.
+ */
+public class FeatureOption {
+    public static final String TAG = "FeatureOption";
+
+    public static final boolean SPRD_SETTINGS_ACTIVITY_SUPPORT = false;
+
+    //SPRD add for SPRD_UNREAD_INFO_SUPPORT
+    public static final boolean SPRD_UNREAD_INFO_SUPPORT = getProp("ro.launcher.unreadinfo", true);
+
+    //SPRD add for SPRD_DYNAMIC_ICON_SUPPORT
+    public static final boolean SPRD_DYNAMIC_ICON_SUPPORT = getProp("ro.launcher.dynamicicon", true);
+    public static final boolean SPRD_DYNAMIC_CLOCK_SUPPORT = getProp("ro.launcher.dynamicclock", true);
+    public static final boolean SPRD_DYNAMIC_CALENDAR_SUPPORT = getProp("ro.launcher.dynamiccalendar", true);
+
+    //SPRD add for SPRD_CIRCLE_SLIDE_SUPPORT start {
+    public static final boolean SPRD_CIRCLE_SLIDE_SUPPORT = getProp("ro.launcher.circleslide", false);
+    //SPRD: SPRD_CIRCLE_SLIDE_SUPPORT end }
+
+    public static final boolean SPRD_SHAKE_CHANGEWALLPAPER_SUPPORT = getProp("ro.launcher.shakewallpaper",false);
+
+    //SPRD Add for customize app feature
+    public static final boolean SPRD_CUSTOMIZEAPPSORT_SUPPORT = getProp("ro.launcher.customizeappsort", true);
+
+    //SPRD add for SPRD_DEFAULT_FOLDER_NAME
+    public static final boolean SPRD_DEFAULT_FOLDER_NAME_SUPPORT = getProp("ro.launcher.defaultfoldername", false);
+
+    //SPRD add for SPRD_PIFLOW_SUPPORT
+    public static final boolean SPRD_PIFLOW_SUPPORT = getProp("ro.launcher.piflow", true);
+    public static final boolean SPRD_PIFLOW_STATUSBAR_SUPPORT = SPRD_PIFLOW_SUPPORT && getProp("ro.launcher.piflowstb", true);
+
+    public static final boolean SPRD_PREDICTEDAPP_SUPPORT = getProp("ro.launcher.predictedapp", true);
+
+    public static final boolean SPRD_MOTION_SOUND_SUPPORT = getProp("ro.launcher.motionsound", true);
+
+    public static final boolean SPRD_ROOT_WARINING_SUPPORT = getProp( "ro.launcher.rootwarning", true);
+
+    public static final boolean SPRD_BGTRANSPARENT_SUPPORT = getProp( "ro.launcher.bgtransparent", true);
+
+    private static boolean getProp(String prop, boolean devalues) {
+        boolean ret = false;
+
+        try {
+            ret = SystemProperties.getBoolean(prop, devalues);
+        } catch (Exception e) {
+            LogUtils.e(TAG, "getProp:" + prop + " error." + e);
+        }
+
+        return ret;
+    }
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/predictedapp/PredictedAppController.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/predictedapp/PredictedAppController.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/predictedapp/PredictedAppController.java	(revision 173368)
@@ -0,0 +1,169 @@
+package com.sprd.ext.predictedapp;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.SharedPreferences;
+
+import com.android.launcher3.AppInfo;
+import com.android.launcher3.R;
+import com.android.launcher3.Utilities;
+import com.android.launcher3.compat.UserHandleCompat;
+import com.android.launcher3.util.ComponentKey;
+import com.sprd.ext.FeatureOption;
+import com.sprd.ext.LogUtils;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Created by sprd on 2017/6/23.
+ */
+public class PredictedAppController {
+    private static final String TAG = "PredictedAppController";
+    Context mContext;
+    private String[] mPredictedCustomApp;
+    private static ConcurrentHashMap<ComponentName, Integer> mPredictedList = new ConcurrentHashMap<>();
+    private SharedPreferences mSp;
+
+    public PredictedAppController(Context context) {
+        if (FeatureOption.SPRD_PREDICTEDAPP_SUPPORT) {
+            mContext = context;
+            mSp = Utilities.getPrefs(mContext);
+            mPredictedCustomApp = mContext.getResources().getStringArray( R.array.predictedapp_list);
+            initPredictedList();
+        }
+    }
+
+    private void initPredictedList(){
+        if(!getSavedPredictedList().isEmpty()){
+            mPredictedList.putAll(getSavedPredictedList());
+        }else {
+            for (String cnStr : mPredictedCustomApp) {
+                ComponentName cn = ComponentName.unflattenFromString(cnStr);
+                mPredictedList.put(cn, 0);
+            }
+        }
+    }
+
+    public void updatePredictedList(ComponentName cn){
+        if (mContext == null) {
+            return;
+        }
+
+        if(cn == null){
+            return;
+        }
+        if(!mPredictedList.isEmpty()) {
+            if (mPredictedList.containsKey(cn)) {
+                int clickCount = mPredictedList.get(cn);
+                mPredictedList.put(cn, clickCount + 1);
+            }else{
+                mPredictedList.put(cn, 1);
+            }
+        }else{
+            initPredictedList();
+        }
+    }
+
+    public void removeAppsFromPredicteList(final ArrayList<AppInfo> appInfos){
+        if (mContext == null) {
+            return;
+        }
+
+        for(int i = 0; i < appInfos.size(); i++){
+            ComponentName cn = appInfos.get(i).componentName;
+            if(cn != null){
+                mPredictedList.remove(cn);
+            }
+        }
+    }
+
+    public List<ComponentKey> getCurrentPredictedList(){
+        if (mContext == null) {
+            return null;
+        }
+
+        synchronized (this) {
+            List<ComponentKey> currentPredictedList = new ArrayList<>();
+
+            List<Map.Entry<ComponentName, Integer>> temp = new ArrayList<>(mPredictedList.entrySet());
+
+            Collections.sort(temp, new Comparator<Map.Entry<ComponentName, Integer>>() {
+                public int compare(Map.Entry<ComponentName, Integer> o1, Map.Entry<ComponentName, Integer> o2) {
+                    return o2.getValue() - o1.getValue();
+                }
+            });
+
+            for (int i = 0; i < temp.size() - 1; i++) {
+                ComponentName cn = temp.get(i).getKey();
+                currentPredictedList.add(new ComponentKey(cn, UserHandleCompat.myUserHandle()));
+            }
+            return currentPredictedList;
+        }
+    }
+
+    private ConcurrentHashMap<ComponentName, Integer> getSavedPredictedList(){
+        ConcurrentHashMap<ComponentName, Integer> savePredictedist = new ConcurrentHashMap<>();
+        int size = mSp.getInt("predicted_app_size", 0);
+        if(size != 0){
+            for(int i = 0; i < size; i++){
+                try {
+                    String ret = mSp.getString("predicted_app" + i, "");
+                    if ("".equals(ret)) {
+                        continue;
+                    }
+                    JSONArray jsonArray = new JSONArray(ret);
+                    int length = jsonArray.length();
+                    String[] data = new String[length];
+                    for (int j = 0; j < length; j++){
+                        String str = jsonArray.getString(j);
+                        data[j] = str;
+                    }
+                    if(data[0] != null && data[1] != null) {
+                        savePredictedist.put(ComponentName.unflattenFromString(data[0]), Integer.valueOf(data[1]));
+                    }
+                } catch (JSONException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+        return  savePredictedist;
+    }
+
+    public void savePredictedList(){
+        if (mContext == null) {
+            return;
+        }
+        synchronized (this) {
+            int size = mPredictedList.size();
+            SharedPreferences.Editor editor = mSp.edit();
+            editor.putInt("predicted_app_size", size);
+            LogUtils.d(TAG, "set predicted_app_size = " + size);
+
+            Set set = mPredictedList.keySet();
+            int i = 0;
+            for (Object obj : set){
+                String[] data = new String[2];
+                data[0] = ((ComponentName) obj).flattenToString();
+                data[1] = mPredictedList.get(obj).toString();
+
+                JSONArray jsonArray = new JSONArray();
+                for (String str : data) {
+                    jsonArray.put(str);
+                }
+
+                editor.putString("predicted_app" + i, jsonArray.toString());
+                i++;
+            }
+            editor.apply();
+        }
+    }
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/SprdSettingsActivity.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/SprdSettingsActivity.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/SprdSettingsActivity.java	(revision 173368)
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * SPRD_SETTINGS_ACTIVITY_SUPPORT
+ */
+
+package com.sprd.ext;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.preference.ListPreference;
+import android.preference.Preference;
+import android.preference.Preference.OnPreferenceChangeListener;
+import android.preference.Preference.OnPreferenceClickListener;
+import android.preference.PreferenceFragment;
+import android.preference.SwitchPreference;
+
+import com.android.launcher3.LauncherSettings;
+import com.android.launcher3.R;
+import com.sprd.ext.dynamicIcon.DynamicIconSettings;
+import com.android.launcher3.Utilities;
+import com.sprd.ext.circleslide.CircleSlideUtils;
+import com.sprd.ext.shakewallpaper.WallpaperChangeController;
+import com.sprd.ext.unreadnotifier.UnreadActivity;
+
+/**
+ * Created by SPRD on 11/8/16.
+ *
+ * SPRD Settings activity for Launcher. Currently implements the following setting: Allow rotation
+ */
+public class SprdSettingsActivity extends Activity {
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        // Display the fragment as the main content.
+        getFragmentManager().beginTransaction()
+                .replace(android.R.id.content, new SprdLauncherSettingsFragment())
+                .commit();
+    }
+
+    /**
+     * This fragment shows the launcher preferences.
+     */
+    public static class SprdLauncherSettingsFragment extends PreferenceFragment
+            implements OnPreferenceChangeListener, OnPreferenceClickListener {
+        private static final String PRE_KEY_UNREAD = "pref_unreadNotifier";
+
+        private static final String PRE_KEY_DYNAMICICON = "pref_dynamicIcon";
+        Context mContext;
+
+        @Override
+        public void onCreate(Bundle savedInstanceState) {
+            super.onCreate(savedInstanceState);
+            addPreferencesFromResource(R.xml.settings_preferences_ext);
+            mContext = getActivity().getApplicationContext();
+
+            SwitchPreference pref = (SwitchPreference) findPreference(
+                    Utilities.ALLOW_ROTATION_PREFERENCE_KEY);
+            pref.setPersistent(false);
+
+            if(!getResources().getBoolean(R.bool.allow_rotation)) {
+                boolean rotation_value = UtilitiesExt.getLauncherSettingsBoolean(mContext,
+                        Utilities.ALLOW_ROTATION_PREFERENCE_KEY,
+                        false);
+                pref.setChecked(rotation_value);
+                pref.setOnPreferenceChangeListener(this);
+            }else{
+                getPreferenceScreen().removePreference(pref);
+            }
+
+            //SPRD: add for unreadNotifier function start
+            Preference unreadPref = findPreference(PRE_KEY_UNREAD);
+            unreadPref.setOnPreferenceClickListener(this);
+            if(!FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
+                getPreferenceScreen().removePreference(unreadPref);
+            }
+            //SPRD: add for unreadNotifier function end
+
+            //SPRD add for SPRD_CIRCLE_SLIDE_SUPPORT start {
+            SwitchPreference cyclePref = (SwitchPreference) findPreference(
+                    CircleSlideUtils.PREF_CIRCLE_SLIDE_KEY);
+
+            if (FeatureOption.SPRD_CIRCLE_SLIDE_SUPPORT && !CircleSlideUtils.hasCustomContent(mContext)) {
+                boolean cycleValue = CircleSlideUtils.isCircleSlideEnabled(mContext);
+                cyclePref.setChecked(cycleValue);
+                cyclePref.setOnPreferenceChangeListener(this);
+            } else {
+                // when CustomContent is enabled, Circle slide Feature need close
+                getPreferenceScreen().removePreference(cyclePref);
+            }
+            // SPRD add for SPRD_SETTINGS_ACTIVITY_SUPPORT end }
+
+            SwitchPreference shakeChangeWallpaperPref = (SwitchPreference) findPreference(
+                    WallpaperChangeController.ALLOW_SHAKE_CHANGE_WALLPAPER_KEY);
+            if (FeatureOption.SPRD_SHAKE_CHANGEWALLPAPER_SUPPORT
+                    && WallpaperChangeController.getWallpapersCount(mContext) > 0) {
+                boolean shakeChangeWallpaper = UtilitiesExt.getLauncherSettingsBoolean(mContext,
+                        WallpaperChangeController.ALLOW_SHAKE_CHANGE_WALLPAPER_KEY,
+                        getResources().getBoolean(R.bool.allow_shake_change_wallpaper));
+                shakeChangeWallpaperPref.setChecked(shakeChangeWallpaper);
+                shakeChangeWallpaperPref.setOnPreferenceChangeListener(this);
+            } else {
+                getPreferenceScreen().removePreference(shakeChangeWallpaperPref);
+            }
+
+            //SPRD: add for dynamic icon feature start
+            Preference dynamicIconPref = findPreference(PRE_KEY_DYNAMICICON);
+            boolean hide = getActivity().getResources().getBoolean(R.bool.config_hide_dynamic_icon_settings);
+            if (FeatureOption.SPRD_DYNAMIC_ICON_SUPPORT) {
+                if (hide || !isAnyDynamicIconFeatureSupport()) {
+                    getPreferenceScreen().removePreference(dynamicIconPref);
+                }
+            } else {
+                getPreferenceScreen().removePreference(dynamicIconPref);
+            }
+
+            if (dynamicIconPref != null) {
+                dynamicIconPref.setOnPreferenceClickListener(this);
+            }
+            //SPRD: add for dynamic icon feature end
+        }
+
+        private boolean isAnyDynamicIconFeatureSupport() {
+            return FeatureOption.SPRD_DYNAMIC_CALENDAR_SUPPORT || FeatureOption.SPRD_DYNAMIC_CLOCK_SUPPORT;
+        }
+
+        @Override
+        public boolean onPreferenceChange(Preference preference, Object newValue) {
+            //You can add CheckboxPreference here if need,I think boolean and String type is enough!
+            if (preference instanceof SwitchPreference) {
+                Bundle extras = new Bundle();
+                extras.putBoolean(LauncherSettings.Settings.EXTRA_VALUE, (Boolean) newValue);
+                getActivity().getContentResolver().call(
+                        LauncherSettings.Settings.CONTENT_URI,
+                        LauncherSettings.Settings.METHOD_SET_BOOLEAN,
+                        preference.getKey(), extras);
+            }else if(preference instanceof ListPreference){
+                Bundle extras = new Bundle();
+                extras.putString(LauncherSettings.Settings.EXTRA_VALUE, (String) newValue);
+                getActivity().getContentResolver().call(
+                        LauncherSettings.Settings.CONTENT_URI,
+                        LauncherSettings.Settings.METHOD_SET_STRING,
+                        preference.getKey(), extras);
+            }
+            return true;
+        }
+
+        @Override
+        public boolean onPreferenceClick(Preference preference) {
+            String key = preference.getKey();
+            if(key.equals(PRE_KEY_UNREAD)) {
+                // start UnreadActivity
+                Intent unreadIntent = new Intent(getActivity(), UnreadActivity.class);
+                startActivity(unreadIntent);
+            } else if (PRE_KEY_DYNAMICICON.equals(key)) {
+                Intent dynamicIconIntent = new Intent(getActivity(), DynamicIconSettings.class);
+                startActivity(dynamicIconIntent);
+            }
+            return false;
+        }
+    }
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/customizeappsort/CustomizeAppSort.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/customizeappsort/CustomizeAppSort.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/customizeappsort/CustomizeAppSort.java	(revision 173368)
@@ -0,0 +1,213 @@
+package com.sprd.ext.customizeappsort;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.content.res.XmlResourceParser;
+import android.util.AttributeSet;
+import android.util.Pair;
+import android.util.SparseArray;
+import android.util.Xml;
+
+import com.android.launcher3.AppInfo;
+import com.android.launcher3.R;
+import com.android.launcher3.compat.UserHandleCompat;
+import com.sprd.ext.FeatureOption;
+import com.sprd.ext.LogUtils;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+
+/**
+ * Created by SPRD on 2017/2/20.
+ */
+public class CustomizeAppSort {
+    private static final String TAG = "CustomizeAppSort";
+    private static final String XML_ITEM_TAG = "App";
+
+    private SparseArray<Pair<String, String>> mCustomizePositions = new SparseArray<>();
+    private boolean mHasCustomizeAppData = false;
+
+    private static CustomizeAppSort INSTANCE;
+
+    /**
+     * private constructor here, It is a singleton class.
+     */
+    private CustomizeAppSort(final Context appContext) {
+        if (FeatureOption.SPRD_CUSTOMIZEAPPSORT_SUPPORT) {
+            mCustomizePositions = loadCustomizeAppPositions(appContext);
+            mHasCustomizeAppData = mCustomizePositions.size() > 0;
+            LogUtils.d(TAG, "load config done:" + mCustomizePositions.toString());
+        }
+    }
+
+    public static CustomizeAppSort getInstance(final Context context) {
+        if (INSTANCE == null) {
+            INSTANCE = new CustomizeAppSort(context.getApplicationContext());
+        }
+        return INSTANCE;
+    }
+
+    public final void sortApps(final List<AppInfo> apps) {
+        if (!FeatureOption.SPRD_CUSTOMIZEAPPSORT_SUPPORT || !mHasCustomizeAppData) {
+            return;
+        }
+        ArrayList<AppInfo> sortApps = new ArrayList<>();
+        sortApps.addAll(apps);
+        onSortApps(sortApps);
+
+        // refresh mApps
+        apps.clear();
+        apps.addAll(sortApps);
+    }
+
+    private void onSortApps(final ArrayList<AppInfo> originalApps) {
+        TreeMap<Integer, AppInfo> sortedMaps = new TreeMap<>();
+        ArrayList<AppInfo> cloneAppList = new ArrayList<>();
+
+        // find the customize component in componentNames
+        Pair<String, String> pair;
+        for (AppInfo app : originalApps) {
+            for (int i = 0; i < mCustomizePositions.size(); i++) {
+                ComponentName cn = app.componentName;
+                pair = mCustomizePositions.valueAt(i);
+                if (pair.first.equals(cn.getPackageName() )) {
+                    if (pair.second == null || pair.second.equals(cn.getClassName())) {
+                        if (app.user.equals(UserHandleCompat.myUserHandle())) {
+                            sortedMaps.put(mCustomizePositions.keyAt(i), app);
+                        } else {
+                            cloneAppList.add(app);
+                        }
+                    }
+                }
+
+            }
+        }
+
+        // insert clone app
+        if (!cloneAppList.isEmpty()) {
+            LogUtils.d(TAG, "onSortApps, cloneAppList.size():" + cloneAppList.size());
+            for (AppInfo app : cloneAppList) {
+                insertCloneApp(app, sortedMaps);
+            }
+        }
+
+        LogUtils.d(TAG, "onSortApps, sortedMaps keys:" + sortedMaps.keySet().toString());
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "onSortApps, sortedMaps:" + maps2String(sortedMaps));
+            LogUtils.d(TAG, "onSortApps, need sort apps:" + apps2String(originalApps));
+        }
+
+        // remove the found component
+        for (Map.Entry<Integer, AppInfo> integerAppInfoEntry : sortedMaps.entrySet()) {
+            originalApps.remove(integerAppInfoEntry.getValue());
+        }
+
+        // insert at the customize position
+        for (Map.Entry<Integer, AppInfo> integerAppInfoEntry : sortedMaps.entrySet()) {
+            if (integerAppInfoEntry.getKey() > originalApps.size()) {
+                // append to last position
+                originalApps.add(integerAppInfoEntry.getValue());
+            } else {
+                // insert at specific position
+                originalApps.add(integerAppInfoEntry.getKey(), integerAppInfoEntry.getValue());
+            }
+        }
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "onSortApps, sorted apps:" + apps2String(originalApps));
+        }
+    }
+
+    private static String maps2String(TreeMap<Integer, AppInfo> maps) {
+        StringBuilder sb = new StringBuilder();
+        for (Map.Entry<Integer, AppInfo> infoEntry : maps.entrySet()) {
+            AppInfo app = infoEntry.getValue();
+            sb.append("\n[ ")
+                    .append(infoEntry.getKey())
+                    .append(" -> ").append(app.toComponentKey().toString())
+                    .append(" ]");
+        }
+        return sb.toString();
+    }
+
+    private static String apps2String(final List<AppInfo> apps) {
+        TreeMap<Integer, AppInfo> maps = new TreeMap<>();
+        for (int i = 0; i < apps.size(); i++) {
+            maps.put(i, apps.get(i));
+        }
+        return maps2String(maps);
+    }
+
+    private static void insertCloneApp(AppInfo cloneApp, TreeMap<Integer, AppInfo> sortedAppMaps) {
+        if (sortedAppMaps.containsValue(cloneApp)) {
+            return;
+        }
+
+        int findKey = -1;
+        for (Map.Entry<Integer, AppInfo> integerAppInfoEntry : sortedAppMaps.entrySet()) {
+            AppInfo me = integerAppInfoEntry.getValue();
+            int key = integerAppInfoEntry.getKey();
+            if (cloneApp.componentName.equals(me.componentName)) {
+                findKey = key;
+                LogUtils.d(TAG, "insertCloneApp, find owner app:[" + findKey + "] " + me.componentName);
+                break;
+            }
+        }
+
+        if (findKey != -1) {
+            int lastKey = sortedAppMaps.lastKey();
+            for (int i = findKey + 1; i <= lastKey + 1; i++) {
+                if (sortedAppMaps.get(i) == null) {
+                    LogUtils.d(TAG, "insertCloneApp, find empty grid:[" + i + "] ");
+                    sortedAppMaps.put(i, cloneApp);
+                    return;
+                }
+            }
+        }
+    }
+
+    /**
+     * Get customize app's position. The result is a map, the key indicate the
+     * customize position, and the value is a pair of package name and class
+     * name.
+     * @param context cTx
+     * @return customize app map
+     */
+    private static SparseArray<Pair<String, String>> loadCustomizeAppPositions(final Context context) {
+        SparseArray<Pair<String, String>> customizePositions = new SparseArray<>();
+        try {
+            XmlResourceParser parser = context.getResources().getXml(R.xml.customize_app_positions);
+            AttributeSet attrs = Xml.asAttributeSet(parser);
+
+            int eventType = parser.getEventType();
+            while (eventType != XmlPullParser.END_DOCUMENT) {
+                if (eventType == XmlPullParser.START_TAG) {
+                    String tagName = parser.getName();
+                    if (XML_ITEM_TAG.equals(tagName)) {
+                        final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SprdAppInfo);
+                        String pkgName = a.getString(R.styleable.SprdAppInfo_pkgName);
+                        String clsName = a.getString(R.styleable.SprdAppInfo_clsName);
+                        int position = a.getInteger(R.styleable.SprdAppInfo_position, 0);
+
+                        // package name must not be null or empty
+                        if (pkgName != null && pkgName.length() != 0) {
+                            customizePositions.put(position, new Pair<>(pkgName, clsName));
+                        }
+                        a.recycle();
+                    }
+                }
+                eventType = parser.next();
+            }
+        } catch (XmlPullParserException | IOException | RuntimeException e) {
+            LogUtils.w(TAG, "parse xml failed", e);
+        }
+        return customizePositions;
+    }
+
+}
\ No newline at end of file
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/UtilitiesExt.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/UtilitiesExt.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/UtilitiesExt.java	(revision 173368)
@@ -0,0 +1,129 @@
+package com.sprd.ext;
+
+import android.app.Activity;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.os.Bundle;
+import android.os.SystemProperties;
+import android.text.TextUtils;
+import android.view.Window;
+import android.view.WindowManager;
+
+import com.android.launcher3.LauncherModel;
+import com.android.launcher3.LauncherSettings;
+import com.android.launcher3.compat.UserHandleCompat;
+
+/**
+ * Created by SPRD on 11/14/16.
+ */
+
+public class UtilitiesExt {
+    private static final String TAG = "UtilitiesExt";
+    /**
+     *
+     * @param context  to getContentResolver
+     * @param key  Preference key
+     *  @param defaultVal if get value is null, return defaultVal
+     */
+    public static boolean getLauncherSettingsBoolean(Context context, String key, boolean defaultVal) {
+        Bundle extras = new Bundle();
+        extras.putBoolean(LauncherSettings.Settings.EXTRA_DEFAULT_VALUE, defaultVal);
+        Bundle bundle = context.getContentResolver().call(
+                LauncherSettings.Settings.CONTENT_URI,
+                LauncherSettings.Settings.METHOD_GET_BOOLEAN,
+                key, extras);
+
+        if(bundle == null){
+            return defaultVal;
+        }
+        return bundle.getBoolean(LauncherSettings.Settings.EXTRA_VALUE);
+    }
+
+    public static String getLauncherSettingsString(Context context, String key, String defaultVal) {
+        Bundle extras = new Bundle();
+        extras.putString(LauncherSettings.Settings.EXTRA_DEFAULT_VALUE, defaultVal);
+        Bundle bundle = context.getContentResolver().call(
+                LauncherSettings.Settings.CONTENT_URI,
+                LauncherSettings.Settings.METHOD_GET_STRING,
+                key, extras);
+
+        if(bundle == null){
+            return defaultVal;
+        }
+        return bundle.getString(LauncherSettings.Settings.EXTRA_VALUE);
+    }
+    //end }
+
+    public static boolean isAppInstalled(Context context, ComponentName component) {
+        UserHandleCompat user = UserHandleCompat.myUserHandle();
+        return LauncherModel.isValidPackageActivity(context, component, user);
+    }
+
+    public static CharSequence getAppLabelByPackageName(Context context, String pkgName) {
+        boolean ret = false;
+        ApplicationInfo info = null;
+        PackageManager pm = context.getPackageManager();
+
+        if (!TextUtils.isEmpty(pkgName)) {
+            try {
+                info = pm.getApplicationInfo(pkgName, 0);
+                ret = info != null;
+            } catch (PackageManager.NameNotFoundException e) {
+                LogUtils.w(TAG, "getAppLabelByPackageName, get app label failed, pkgName:" + pkgName);
+            }
+        }
+
+        return ret ? info.loadLabel(pm) : null;
+    }
+
+    public static void closeCursorSilently(Cursor cursor) {
+        try {
+            if (cursor != null) cursor.close();
+        } catch (Throwable t) {
+            LogUtils.w(TAG, "fail to close", t);
+        }
+    }
+
+    public static Point getTextDrawPoint(Rect targetRect, Paint.FontMetrics fm) {
+        Point p = new Point();
+        int fontHeight = Math.round(fm.descent - fm.ascent);
+        int paddingY = (targetRect.height() - fontHeight) >> 1;
+        p.x = targetRect.centerX();
+        p.y = targetRect.top + paddingY + Math.abs(Math.round(fm.ascent));
+        return p;
+    }
+
+    /**
+     * When set to true, apps will draw debugging information about their layouts.
+     * @see android.view.View
+     */
+    private static boolean enableDebugLayout() {
+        //see View.java:DEBUG_LAYOUT_PROPERTY
+        return SystemProperties.getBoolean("debug.layout", false);
+    }
+
+    public static void drawDebugRect(final Canvas canvas, final Rect rect, final int color) {
+        if (enableDebugLayout()) {
+            Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
+            paint.setColor(color);
+            paint.setStyle(Paint.Style.STROKE);
+            canvas.drawRect(rect, paint);
+        }
+    }
+
+    public static void enableFullScreenMode(Activity activity, boolean enable) {
+        Window win = activity.getWindow();
+        if (enable) {
+            win.addFlags( WindowManager.LayoutParams.FLAG_FULLSCREEN);
+        } else {
+            win.clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
+        }
+    }
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/foldername/FolderNameUtils.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/foldername/FolderNameUtils.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/foldername/FolderNameUtils.java	(revision 173368)
@@ -0,0 +1,53 @@
+package com.sprd.ext.foldername;
+
+import android.content.Context;
+
+import com.android.launcher3.ExtendedEditText;
+import com.android.launcher3.FolderInfo;
+import com.android.launcher3.R;
+import com.sprd.ext.FeatureOption;
+
+/**
+ * Created by SPRD on 2017/02/27.
+ */
+public class FolderNameUtils {
+    private static final String TAG = "FolderNameUtils";
+
+    public static void init(Context context, String defaultfolderName,String hintName){
+        if(FeatureOption.SPRD_DEFAULT_FOLDER_NAME_SUPPORT) {
+            defaultfolderName = hintName = context.getString(R.string.folder_default_name);
+        }
+    }
+
+    public static void updateFolderTitle(Context context, FolderInfo info){
+        if(FeatureOption.SPRD_DEFAULT_FOLDER_NAME_SUPPORT) {
+            CharSequence title = info.getTitle();
+            if(title != null && title.toString().isEmpty()){
+                info.setTitle(context.getText(R.string.folder_default_name));
+            }
+        }
+    }
+
+    public static boolean isFolderNameChanged(String newStr, FolderInfo info, ExtendedEditText folderName){
+        boolean changed = false;
+        if(FeatureOption.SPRD_DEFAULT_FOLDER_NAME_SUPPORT){
+            CharSequence title = info.getTitle();
+            changed = !newStr.trim().isEmpty() && !newStr.equals(title.toString());
+            if(!changed){
+                folderName.setText(title);
+            }
+        } else {
+           changed = true;
+        }
+        return changed;
+    }
+
+    public static boolean isDefaultFolderName(Context context, FolderInfo info){
+        boolean isDefaut = false;
+        if(FeatureOption.SPRD_DEFAULT_FOLDER_NAME_SUPPORT) {
+            CharSequence title = info.getTitle();
+            isDefaut = title != null && title.toString().equals(context.getString(R.string.folder_default_name));
+        }
+        return isDefaut;
+    }
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/DynamicIconSettingsFragment.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/DynamicIconSettingsFragment.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/DynamicIconSettingsFragment.java	(revision 173368)
@@ -0,0 +1,100 @@
+package com.sprd.ext.dynamicIcon;
+
+import android.os.Bundle;
+import android.preference.Preference;
+import android.preference.PreferenceFragment;
+import android.preference.SwitchPreference;
+import android.text.TextUtils;
+
+import com.android.launcher3.LauncherSettings;
+import com.android.launcher3.R;
+import com.sprd.ext.FeatureOption;
+import com.sprd.ext.UtilitiesExt;
+
+/**
+ * This fragment shows the dynamic icon setting preferences.
+ */
+public class DynamicIconSettingsFragment  extends PreferenceFragment
+        implements Preference.OnPreferenceChangeListener {
+
+    public static final String PRE_DYNAMIC_CALENDAR = "pref_calendar";
+    public static final String PRE_DYNAMIC_CLOCK = "pref_clock";
+
+    private DynamicIcon mDynamicCalendar;
+    private DynamicIcon mDynamicDeskclock;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.dynamic_icon_settings);
+
+        DynamicIconUtils utils = DynamicIconUtils.getInstance(getActivity());
+
+        SwitchPreference calendarPre = (SwitchPreference) findPreference(PRE_DYNAMIC_CALENDAR);
+        if (FeatureOption.SPRD_DYNAMIC_CALENDAR_SUPPORT) {
+            mDynamicCalendar = utils.getDynamicIconByType(DynamicIconUtils.DYNAMIC_CALENDAR_TYPE);
+            if (mDynamicCalendar != null) {
+                boolean isValidCal = UtilitiesExt.isAppInstalled(getActivity(), mDynamicCalendar.getComponentName());
+                if (isValidCal) {
+                    calendarPre.setChecked(mDynamicCalendar.isCheckedState());
+                    CharSequence calendarCh = mDynamicCalendar.getAppLabel();
+                    if (!TextUtils.isEmpty(calendarCh)) {
+                        calendarPre.setTitle(calendarCh);
+                    }
+                    calendarPre.setOnPreferenceChangeListener(this);
+                } else {
+                    calendarPre.setEnabled(false);
+                    calendarPre.setSelectable(false);
+                }
+            } else {
+                getPreferenceScreen().removePreference(calendarPre);
+            }
+        } else {
+            getPreferenceScreen().removePreference(calendarPre);
+        }
+
+        SwitchPreference clockPre = (SwitchPreference) findPreference(PRE_DYNAMIC_CLOCK);
+        if (FeatureOption.SPRD_DYNAMIC_CLOCK_SUPPORT) {
+            mDynamicDeskclock = utils.getDynamicIconByType(DynamicIconUtils.DYNAMIC_CLOCK_TYPE);
+            if (mDynamicDeskclock != null) {
+                boolean isValidClock = UtilitiesExt.isAppInstalled(getActivity(), mDynamicDeskclock.getComponentName());
+                if (isValidClock) {
+                    clockPre.setChecked(mDynamicDeskclock.isCheckedState());
+                    CharSequence clockCh = mDynamicDeskclock.getAppLabel();
+                    if (!TextUtils.isEmpty(clockCh)) {
+                        clockPre.setTitle(clockCh);
+                    }
+                clockPre.setOnPreferenceChangeListener(this);
+            } else {
+                clockPre.setEnabled(false);
+                clockPre.setSelectable(false);
+                }
+            } else {
+                getPreferenceScreen().removePreference(clockPre);
+            }
+        } else {
+            getPreferenceScreen().removePreference(clockPre);
+        }
+    }
+
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        final String key = preference.getKey();
+        Bundle extras = new Bundle();
+        extras.putBoolean(LauncherSettings.Settings.EXTRA_VALUE, (Boolean) newValue);
+        getActivity().getContentResolver().call(
+                LauncherSettings.Settings.CONTENT_URI,
+                LauncherSettings.Settings.METHOD_SET_BOOLEAN,
+                preference.getKey(), extras);
+        if (key.equals(PRE_DYNAMIC_CALENDAR)) {
+                if (mDynamicCalendar != null) {
+                    mDynamicCalendar.setCheckedState((Boolean) newValue);
+                }
+            } else if (key.equals(PRE_DYNAMIC_CLOCK)) {
+                if (mDynamicDeskclock != null) {
+                    mDynamicDeskclock.setCheckedState((Boolean) newValue);
+                }
+            }
+        return true;
+    }
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/deskclock/DynamicDeskclock.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/deskclock/DynamicDeskclock.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/deskclock/DynamicDeskclock.java	(revision 173368)
@@ -0,0 +1,256 @@
+package com.sprd.ext.dynamicIcon.deskclock;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.SystemClock;
+import android.os.SystemProperties;
+import android.support.v4.content.ContextCompat;
+import android.view.View;
+
+import com.android.launcher3.BubbleTextView;
+import com.android.launcher3.R;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.UtilitiesExt;
+import com.sprd.ext.dynamicIcon.DynamicIcon;
+import com.sprd.ext.dynamicIcon.DynamicIconSettingsFragment;
+import com.sprd.ext.dynamicIcon.DynamicIconUtils;
+
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+
+/**
+ * Created by SPRD on 10/21/16.
+ */
+public class DynamicDeskclock extends DynamicIcon {
+
+    private static final String TAG = "DynamicDeskclock";
+
+    private static final String DESKCLOCK_CONFIG_KEY = "ro.launcher.defaultclock";
+    private static final boolean IS_SHOW_SECOND = SystemProperties.getBoolean("ro.launcher.dyclock.second", true);
+
+    // Fraction of the length of second hand.
+    private static final float SECOND_LENGTH_FACTOR = 0.4f;
+    // Fraction of the length of minute hand.
+    private static final float MINUTE_LENGTH_FACTOR = 0.32f;
+    // Fraction of the length of hour hand.
+    private static final float HOUR_LENGTH_FACTOR = 0.23f;
+
+    private Paint mSecondPaint;
+    private Paint mMinutePaint;
+    private Paint mHourPaint;
+    private int mSecondWidth;
+    private int mMinuteWidth;
+    private int mHourWidth;
+    private int mCenterRadius;
+
+    private int mLastHour;
+    private int mLastMinute;
+    private int mLastSecond;
+    // The default time should not be changed, because it should be consistent with that in the deskclock app icon.
+    // Unless the default time and the deskclock app icon change together.
+    private static final GregorianCalendar mDefaultTime = new GregorianCalendar(2016, 10, 1, 10, 10, 30);
+
+    private Handler mSecondsHandler;
+    private Drawable mClockBackground;
+
+    HandlerThread mSecondThread;
+
+    private final Runnable mSecondTick =new Runnable() {
+        @Override
+        public void run() {
+            forceUpdateView(true);
+            if (mSecondsHandler != null) {
+                mSecondsHandler.postAtTime(this, SystemClock.uptimeMillis() / 1000 * 1000 + 1000);
+            }
+        }
+    };
+
+    public DynamicDeskclock(Context context, int type) {
+        super(context, type);
+
+        boolean defValue = SystemProperties.getBoolean(DESKCLOCK_CONFIG_KEY,
+                mContext.getResources().getBoolean(R.bool.config_show_dynamic_clock));
+        mIsChecked = UtilitiesExt.getLauncherSettingsBoolean(mContext,
+                DynamicIconSettingsFragment.PRE_DYNAMIC_CLOCK, defValue);
+    }
+
+    @Override
+    protected void init() {
+        Resources res = mContext.getResources();
+
+        mCenterRadius = res.getDimensionPixelSize(R.dimen.dynamic_clock_center_radius);
+
+        mSecondPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mSecondPaint.setColor(res.getColor(R.color.dynamic_clock_second_hand));
+        mSecondWidth = res.getDimensionPixelSize(R.dimen.dynamic_clock_second_width);
+
+        mMinutePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mMinutePaint.setColor(res.getColor(R.color.dynamic_clock_minute_hand));
+        mMinuteWidth = res.getDimensionPixelSize(R.dimen.dynamic_clock_minute_width);
+
+        mHourPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mHourPaint.setColor(res.getColor(R.color.dynamic_clock_hour_hand));
+        mHourWidth = res.getDimensionPixelOffset(R.dimen.dynamic_clock_hour_width);
+
+        mClockBackground = ContextCompat.getDrawable(mContext, R.drawable.ic_dial_plate);
+
+        mSecondThread = new HandlerThread(LogUtils.MODULE_NAME + "sec-thread");
+        mSecondThread.start();
+    }
+
+    @Override
+    protected boolean hasChanged() {
+        Calendar c = Calendar.getInstance();
+        int hour = c.get(Calendar.HOUR_OF_DAY);
+        int minute = c.get(Calendar.MINUTE);
+        int second = c.get(Calendar.SECOND);
+
+        if (mLastSecond != second
+                || mLastMinute != minute
+                || mLastHour != hour) {
+            mLastSecond = second;
+            mLastMinute = minute;
+            mLastHour = hour;
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    protected IntentFilter getReceiverFilter() {
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_TIME_TICK);
+        filter.addAction(Intent.ACTION_TIME_CHANGED);
+        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
+        return filter;
+    }
+
+    @Override
+    public boolean registerReceiver() {
+        if (super.registerReceiver()) {
+            if (LogUtils.DEBUG_DYNAMIC_ICON) {
+                LogUtils.d(TAG, "registerReceiver.");
+            }
+            if (IS_SHOW_SECOND) {
+                startAutoSecondRunnable();
+            }
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean unRegisterReceiver() {
+        if (super.unRegisterReceiver()) {
+            if (LogUtils.DEBUG_DYNAMIC_ICON) {
+                LogUtils.d(TAG, "unRegisterReceiver.");
+            }
+            if (IS_SHOW_SECOND) {
+                stopAutoSecondRunnable();
+            }
+            return true;
+        }
+        return false;
+    }
+
+    public Drawable getStableBackground() {
+        return mClockBackground;
+    }
+
+    public DynamicIconDrawCallback getDynamicIconDrawCallback() {
+        return mDrawCallback;
+    }
+
+    private void startAutoSecondRunnable() {
+        if (IS_SHOW_SECOND) {
+            if (mSecondThread == null) {
+                LogUtils.e(TAG, "The second thread is null!");
+                return;
+            }
+
+            if (mSecondsHandler == null) {
+                mSecondsHandler = new Handler(mSecondThread.getLooper());
+            }
+            mSecondsHandler.removeCallbacks(mSecondTick);
+            mSecondsHandler.postAtTime(mSecondTick,
+                    SystemClock.uptimeMillis() / 1000 * 1000 + 1000);
+        }
+    }
+
+    private void stopAutoSecondRunnable() {
+        if (mSecondsHandler != null) {
+            mSecondsHandler.removeCallbacks(mSecondTick);
+            mSecondsHandler = null;
+        }
+    }
+
+    @Override
+    protected void draw(Canvas canvas, View icon, float scale, Point center) {
+        if (canvas == null || center == null || !(icon instanceof BubbleTextView)) {
+            return;
+        }
+
+        //init icon real rect on the  canvas
+        Rect iconRect = getIconRealRect(icon, scale, center);
+        if (iconRect == null) {
+            return;
+        }
+
+        float secondLength = iconRect.height() * SECOND_LENGTH_FACTOR;
+        float minuteLength = iconRect.height() * MINUTE_LENGTH_FACTOR;
+        float hourLength = iconRect.height() * HOUR_LENGTH_FACTOR;
+
+        scale = Math.abs(scale);
+        mSecondPaint.setStrokeWidth(mSecondWidth * scale);
+        mMinutePaint.setStrokeWidth(mMinuteWidth * scale);
+        mHourPaint.setStrokeWidth(mHourWidth * scale);
+
+        Calendar c = mIsChecked ? Calendar.getInstance() : mDefaultTime;
+        int hour = DynamicIconUtils.getTimeByField(c, Calendar.HOUR);
+        int minute = DynamicIconUtils.getTimeByField(c, Calendar.MINUTE);
+        int second = DynamicIconUtils.getTimeByField(c, Calendar.SECOND);
+
+        mLastSecond = second;
+        mLastMinute = minute;
+        mLastHour = hour;
+
+        float Minutes = minute + second / 60.0f;
+        float Hour = hour + Minutes / 60.0f;
+
+        double radianSecond = ((float) second / 60.0f * 360f)/180f * Math.PI;
+        double radianMinute = (Minutes / 60.0f * 360f)/180f * Math.PI;
+        double radianHour = (Hour / 12.0f * 360f)/180f * Math.PI;
+
+        float secondX = 0f;
+        float secondY = 0f;
+        if (IS_SHOW_SECOND) {
+            secondX = (float) (scale * secondLength * Math.sin(radianSecond));
+            secondY = (float) (scale * secondLength * Math.cos(radianSecond));
+        }
+
+        float minuteX = (float) (scale * minuteLength * Math.sin(radianMinute));
+        float minuteY = (float) (scale * minuteLength * Math.cos(radianMinute));
+
+        float hourX = (float) (scale * hourLength * Math.sin(radianHour));
+        float hourY = (float) (scale * hourLength * Math.cos(radianHour));
+
+        canvas.save();
+        canvas.drawLine(center.x, center.y, center.x + hourX, center.y - hourY, mHourPaint);
+        canvas.drawLine(center.x, center.y, center.x + minuteX, center.y - minuteY, mMinutePaint);
+        if (IS_SHOW_SECOND) {
+            canvas.drawLine(center.x, center.y, center.x + secondX, center.y - secondY, mSecondPaint);
+        }
+        canvas.drawCircle(center.x, center.y, scale * mCenterRadius, mSecondPaint);
+        canvas.restore();
+    }
+}
\ No newline at end of file
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/deskclock/OriginalDynamicDeskclock.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/deskclock/OriginalDynamicDeskclock.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/deskclock/OriginalDynamicDeskclock.java	(revision 173368)
@@ -0,0 +1,268 @@
+package com.sprd.ext.dynamicIcon.deskclock;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.SystemClock;
+import android.os.SystemProperties;
+import android.support.v4.content.ContextCompat;
+import android.view.View;
+
+import com.android.launcher3.BubbleTextView;
+import com.android.launcher3.R;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.UtilitiesExt;
+import com.sprd.ext.dynamicIcon.DynamicIconSettingsFragment;
+import com.sprd.ext.dynamicIcon.DynamicIconUtils;
+
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+
+
+/**
+ * Created by SPRD on 10/21/16.
+ */
+public class OriginalDynamicDeskclock extends DynamicDeskclock {
+
+    private static final String TAG = "OriginalDynamicDeskclock";
+
+    private static final String DESKCLOCK_CONFIG_KEY = "ro.config.dynamicclock";
+    private boolean IS_SHOW_SECOND = false;
+
+    // Fraction of the length of second hand.
+    private static final float SECOND_LENGTH_FACTOR = 0.45f;
+    // Fraction of the length of minute hand.
+    private static final float MINUTE_LENGTH_FACTOR = 0.45f;
+    // Fraction of the length of hour hand.
+    private static final float HOUR_LENGTH_FACTOR = 0.35f;
+
+    private Paint mSecondPaint;
+    private Paint mMinutePaint;
+    private Paint mHourPaint;
+    private int mSecondWidth;
+    private int mMinuteWidth;
+    private int mHourWidth;
+    private int mCenterRadius;
+
+    private int mLastHour;
+    private int mLastMinute;
+    private int mLastSecond;
+    // The default time should not be changed, because it should be consistent with that in the deskclock app icon.
+    // Unless the default time and the deskclock app icon change together.
+    private static final GregorianCalendar mDefaultTime = new GregorianCalendar(2016, 10, 1, 10, 10, 30);
+
+    private Handler mSecondsHandler;
+    private Drawable mClockBackground;
+
+    HandlerThread mSecondThread;
+
+    private final Runnable mSecondTick =new Runnable() {
+        @Override
+        public void run() {
+            forceUpdateView(true);
+            if (mSecondsHandler != null) {
+                mSecondsHandler.postAtTime(this, SystemClock.uptimeMillis() / 1000 * 1000 + 1000);
+            }
+        }
+    };
+
+    public OriginalDynamicDeskclock(Context context, int type) {
+        super(context, type);
+
+        boolean defValue = SystemProperties.getBoolean(DESKCLOCK_CONFIG_KEY,
+                mContext.getResources().getBoolean(R.bool.config_show_dynamic_clock));
+        mIsChecked = UtilitiesExt.getLauncherSettingsBoolean(mContext,
+                DynamicIconSettingsFragment.PRE_DYNAMIC_CLOCK, defValue);
+    }
+
+    @Override
+    protected void init() {
+        Resources res = mContext.getResources();
+
+        mCenterRadius = res.getDimensionPixelSize(R.dimen.dynamic_clock_center_radius_original);
+
+        mSecondPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mSecondPaint.setColor(Color.WHITE);
+        mSecondWidth = res.getDimensionPixelSize(R.dimen.dynamic_clock_second_width_original);
+
+        mMinutePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mMinutePaint.setColor(Color.WHITE);
+        mMinuteWidth = res.getDimensionPixelSize(R.dimen.dynamic_clock_minute_width_original);
+
+        mHourPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mHourPaint.setColor(Color.WHITE);
+        mHourWidth = res.getDimensionPixelOffset(R.dimen.dynamic_clock_hour_width_original);
+
+        mClockBackground = ContextCompat.getDrawable(mContext, R.drawable.ic_dial_plate_original);
+
+        mSecondThread = new HandlerThread("sec-thread");
+        mSecondThread.start();
+    }
+
+    @Override
+    protected boolean hasChanged() {
+        Calendar c = Calendar.getInstance();
+        int hour = c.get(Calendar.HOUR_OF_DAY);
+        int minute = c.get(Calendar.MINUTE);
+        int second = c.get(Calendar.SECOND);
+
+        if (mLastSecond != second
+                || mLastMinute != minute
+                || mLastHour != hour) {
+            mLastSecond = second;
+            mLastMinute = minute;
+            mLastHour = hour;
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    protected IntentFilter getReceiverFilter() {
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_TIME_TICK);
+        filter.addAction(Intent.ACTION_TIME_CHANGED);
+        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
+        return filter;
+    }
+
+    @Override
+    public boolean registerReceiver() {
+        if (super.registerReceiver()) {
+            if (LogUtils.DEBUG_DYNAMIC_ICON) {
+                LogUtils.d(TAG, "registerReceiver.");
+            }
+            if (IS_SHOW_SECOND) {
+                startAutoSecondRunnable();
+            }
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean unRegisterReceiver() {
+        if (super.unRegisterReceiver()) {
+            if (LogUtils.DEBUG_DYNAMIC_ICON) {
+                LogUtils.d(TAG, "unRegisterReceiver.");
+            }
+            if (IS_SHOW_SECOND) {
+                stopAutoSecondRunnable();
+            }
+            return true;
+        }
+        return false;
+    }
+
+    public Drawable getStableBackground() {
+        return mClockBackground;
+    }
+
+    public DynamicIconDrawCallback getDynamicIconDrawCallback() {
+        return mDrawCallback;
+    }
+
+    private void startAutoSecondRunnable() {
+        if (IS_SHOW_SECOND) {
+            if (mSecondThread == null) {
+                LogUtils.e(TAG, "The second thread is null!");
+                return;
+            }
+
+            if (mSecondsHandler == null) {
+                mSecondsHandler = new Handler(mSecondThread.getLooper());
+            }
+            mSecondsHandler.removeCallbacks(mSecondTick);
+            mSecondsHandler.postAtTime(mSecondTick,
+                    SystemClock.uptimeMillis() / 1000 * 1000 + 1000);
+        }
+    }
+
+    private void stopAutoSecondRunnable() {
+        if (mSecondsHandler != null) {
+            mSecondsHandler.removeCallbacks(mSecondTick);
+            mSecondsHandler = null;
+        }
+    }
+
+    @Override
+    public void setComponentName(ComponentName component) {
+        super.setComponentName( component );
+        if (component.getPackageName().equals("com.google.android.deskclock")) {
+            IS_SHOW_SECOND = true;
+        } else {
+            IS_SHOW_SECOND = false;
+        }
+    }
+
+    @Override
+    protected void draw(Canvas canvas, View icon, float scale, Point center) {
+        if (canvas == null || center == null || !(icon instanceof BubbleTextView)) {
+            return;
+        }
+
+        //init icon real rect on the  canvas
+        Rect iconRect = getIconRealRect(icon, scale, center);
+        if (iconRect == null) {
+            return;
+        }
+
+        float secondLength = iconRect.height() * SECOND_LENGTH_FACTOR;
+        float minuteLength = iconRect.height() * MINUTE_LENGTH_FACTOR;
+        float hourLength = iconRect.height() * HOUR_LENGTH_FACTOR;
+
+        scale = Math.abs(scale);
+        mSecondPaint.setStrokeWidth(mSecondWidth * scale);
+        mMinutePaint.setStrokeWidth(mMinuteWidth * scale);
+        mHourPaint.setStrokeWidth(mHourWidth * scale);
+
+        Calendar c = mIsChecked ? Calendar.getInstance() : mDefaultTime;
+        int hour = DynamicIconUtils.getTimeByField(c, Calendar.HOUR);
+        int minute = DynamicIconUtils.getTimeByField(c, Calendar.MINUTE);
+        int second = DynamicIconUtils.getTimeByField(c, Calendar.SECOND);
+
+        mLastSecond = second;
+        mLastMinute = minute;
+        mLastHour = hour;
+
+        float Minutes = minute + second / 60.0f;
+        float Hour = hour + Minutes / 60.0f;
+
+        double radianSecond = ((float) second / 60.0f * 360f)/180f * Math.PI;
+        double radianMinute = (Minutes / 60.0f * 360f)/180f * Math.PI;
+        double radianHour = (Hour / 12.0f * 360f)/180f * Math.PI;
+
+        float secondX = 0f;
+        float secondY = 0f;
+        if (IS_SHOW_SECOND) {
+            secondX = (float) (scale * secondLength * Math.sin(radianSecond));
+            secondY = (float) (scale * secondLength * Math.cos(radianSecond));
+        }
+
+        float minuteX = (float) (scale * minuteLength * Math.sin(radianMinute));
+        float minuteY = (float) (scale * minuteLength * Math.cos(radianMinute));
+
+        float hourX = (float) (scale * hourLength * Math.sin(radianHour));
+        float hourY = (float) (scale * hourLength * Math.cos(radianHour));
+
+        canvas.save();
+        canvas.drawLine(center.x, center.y, center.x + hourX, center.y - hourY, mHourPaint);
+        canvas.drawLine(center.x, center.y, center.x + minuteX, center.y - minuteY, mMinutePaint);
+        if (IS_SHOW_SECOND) {
+            canvas.drawLine(center.x, center.y, center.x + secondX, center.y - secondY, mSecondPaint);
+        }
+        canvas.drawCircle(center.x, center.y, scale * mCenterRadius, mSecondPaint);
+        canvas.restore();
+    }
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/calendar/DynamicCalendar.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/calendar/DynamicCalendar.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/calendar/DynamicCalendar.java	(revision 173368)
@@ -0,0 +1,166 @@
+package com.sprd.ext.dynamicIcon.calendar;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.graphics.Typeface;
+import android.graphics.drawable.Drawable;
+import android.os.SystemProperties;
+import android.support.v4.content.ContextCompat;
+import android.util.DisplayMetrics;
+import android.view.View;
+
+import com.android.launcher3.BubbleTextView;
+import com.android.launcher3.R;
+import com.android.launcher3.Utilities;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.UtilitiesExt;
+import com.sprd.ext.dynamicIcon.DynamicIcon;
+import com.sprd.ext.dynamicIcon.DynamicIconSettingsFragment;
+import com.sprd.ext.dynamicIcon.DynamicIconUtils;
+
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+import java.util.Locale;
+
+/**
+ * Created by SPRD on 10/21/16.
+ */
+public class DynamicCalendar extends DynamicIcon {
+
+    private static final String CALENDAR_CONFIG_KEY = "ro.launcher.defaultcalendar";
+
+    // The proportion of the date font occupied in the dynamic calendar icon.
+    private static final float WEEK_SIZE_FACTOR = 0.135f;
+
+    // The proportion of the week font occupied in the dynamic calendar icon.
+    private static final float WEEK_RECT_TOP = 9.00f;
+    private static final float WEEK_RECT_BOTTOM = 26.00f;
+    private static final float DATE_RECT_BOTTOM = 86.00f;
+    private static final float BASE_ICON_HEIGHT = 96.00f;
+
+    private String mLastDate = "";
+    // The default date should not be changed, because it should be consistent with that in the calendar app icon.
+    // Unless the default date and the calendar app icon change together.
+    // Month value is 0-based. e.g., 0 for January.
+    private static final GregorianCalendar mDefaultDate = new GregorianCalendar(2016, 10, 1);
+    private Paint mDatePaint;
+    private Paint mWeekPaint;
+    private Drawable mCalendarBackground;
+
+    public DynamicCalendar(Context context, int type) {
+        super(context, type);
+
+        boolean defValue = SystemProperties.getBoolean(CALENDAR_CONFIG_KEY,
+                mContext.getResources().getBoolean(R.bool.config_show_dynamic_calendar));
+        mIsChecked = UtilitiesExt.getLauncherSettingsBoolean(mContext,
+                DynamicIconSettingsFragment.PRE_DYNAMIC_CALENDAR, defValue);
+    }
+
+    @Override
+    protected void init() {
+        Typeface font = Typeface.create("sans-serif", Typeface.NORMAL);
+        Resources resources = mContext.getResources();
+
+        mDatePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mDatePaint.setTypeface(font);
+        mDatePaint.setTextAlign(Paint.Align.CENTER);
+        mDatePaint.setColor(resources.getColor(R.color.dynamic_calendar_date, null));
+        mDatePaint.setAntiAlias(true);
+
+        mWeekPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mWeekPaint.setTextAlign(Paint.Align.CENTER);
+        mWeekPaint.setTypeface(font);
+        mWeekPaint.setColor(resources.getColor(R.color.dynamic_calendar_week, null));
+        mWeekPaint.setAntiAlias(true);
+
+        mCalendarBackground = ContextCompat.getDrawable(mContext, R.drawable.ic_calendar_plate);
+    }
+
+    @Override
+    protected boolean hasChanged() {
+        String currentDate = DynamicIconUtils.getDateOfMonth(Calendar.getInstance());
+        if (mLastDate.equals(currentDate)) {
+            return false;
+        } else {
+            mLastDate = currentDate;
+            return true;
+        }
+    }
+
+    @Override
+    protected IntentFilter getReceiverFilter() {
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_TIME_TICK);
+        filter.addAction(Intent.ACTION_DATE_CHANGED);
+        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
+        return filter;
+    }
+
+    public Drawable getStableBackground() {
+        return mCalendarBackground;
+    }
+
+    public DynamicIconDrawCallback getDynamicIconDrawCallback() {
+        return mDrawCallback;
+    }
+
+    @Override
+    protected void draw(Canvas canvas, View icon, float scale, Point center) {
+        if (canvas == null || !(icon instanceof BubbleTextView)) {
+            return;
+        }
+
+        String day;
+        String dayOfWeek;
+
+        //init the date and week strings
+        if (mIsChecked) {
+            day = DynamicIconUtils.getDateOfMonth(Calendar.getInstance());
+            dayOfWeek = DynamicIconUtils.getDayOfWeek(Calendar.getInstance(), Locale.getDefault());
+        } else  {
+            day = DynamicIconUtils.getDateOfMonth(mDefaultDate);
+            dayOfWeek = DynamicIconUtils.getDayOfWeek(mDefaultDate, Locale.ENGLISH);
+        }
+
+        //init icon real rect on the  canvas
+        Rect iconRect = getIconRealRect(icon, scale, center);
+        if (iconRect == null) {
+            return;
+        }
+
+        //update text size
+        mWeekPaint.setTextSize(iconRect.height() * WEEK_SIZE_FACTOR);
+        // The date size is three times of the week size.
+        mDatePaint.setTextSize(iconRect.height() * WEEK_SIZE_FACTOR * 3);
+
+        canvas.save();
+
+        //draw week strings
+        Rect drawRect = new Rect(iconRect);
+        drawRect.top += (int) (iconRect.height() * (WEEK_RECT_TOP / BASE_ICON_HEIGHT));
+        drawRect.bottom = (int) (iconRect.top + iconRect.height() * (WEEK_RECT_BOTTOM / BASE_ICON_HEIGHT));
+
+        UtilitiesExt.drawDebugRect(canvas, drawRect, Color.BLUE);
+        Paint.FontMetrics fm = mWeekPaint.getFontMetrics();
+        Point drawPoint = UtilitiesExt.getTextDrawPoint(drawRect, fm);
+        canvas.drawText(dayOfWeek, drawPoint.x, drawPoint.y, mWeekPaint);
+
+        //draw date strings
+        drawRect.top = drawRect.bottom;
+        drawRect.bottom = (int) (iconRect.top + iconRect.height() * (DATE_RECT_BOTTOM / BASE_ICON_HEIGHT));
+
+        UtilitiesExt.drawDebugRect(canvas, drawRect, Color.CYAN);
+        fm = mDatePaint.getFontMetrics();
+        drawPoint = UtilitiesExt.getTextDrawPoint(drawRect, fm);
+        canvas.drawText(day, drawPoint.x, drawPoint.y, mDatePaint);
+
+        canvas.restore();
+    }
+}
\ No newline at end of file
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/calendar/OriginalDynamicCalendar.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/calendar/OriginalDynamicCalendar.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/calendar/OriginalDynamicCalendar.java	(revision 173368)
@@ -0,0 +1,119 @@
+package com.sprd.ext.dynamicIcon.calendar;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.graphics.Typeface;
+import android.graphics.drawable.Drawable;
+import android.os.SystemProperties;
+import android.support.v4.content.ContextCompat;
+import android.view.View;
+
+import com.android.launcher3.BubbleTextView;
+import com.android.launcher3.R;
+import com.sprd.ext.UtilitiesExt;
+import com.sprd.ext.dynamicIcon.DynamicIcon;
+import com.sprd.ext.dynamicIcon.DynamicIconSettingsFragment;
+import com.sprd.ext.dynamicIcon.DynamicIconUtils;
+
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+
+/**
+ * Created by SPRD on 10/21/16.
+ */
+public class OriginalDynamicCalendar extends DynamicIcon {
+
+    private static final String CALENDAR_CONFIG_KEY = "ro.config.dynamiccalendar";
+    // The proportion of the date font occupied in the dynamic calendar icon.
+    private static final float DATE_SIZE_FACTOR = 0.5f;
+
+    private String mLastDate = "";
+    // The default date should not be changed, because it should be consistent with that in the calendar app icon.
+    // Unless the default date and the calendar app icon change together.
+    // Month value is 0-based. e.g., 0 for January.
+    private static final GregorianCalendar mDefaultDate = new GregorianCalendar(2016, 9, 31);
+    private Paint mDatePaint;
+    private Drawable mCalendarBackground;
+
+    public OriginalDynamicCalendar(Context context, int type) {
+        super(context, type);
+
+        boolean defValue = SystemProperties.getBoolean(CALENDAR_CONFIG_KEY,
+                mContext.getResources().getBoolean(R.bool.config_show_dynamic_calendar));
+        mIsChecked = UtilitiesExt.getLauncherSettingsBoolean(mContext,
+                DynamicIconSettingsFragment.PRE_DYNAMIC_CALENDAR, defValue);
+    }
+
+    @Override
+    protected void init() {
+        Typeface font = Typeface.create("sans-serif", Typeface.NORMAL);
+
+        mDatePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mDatePaint.setTypeface(font);
+        mDatePaint.setTextAlign(Paint.Align.CENTER);
+        mDatePaint.setAntiAlias(true);
+        mDatePaint.setColor(Color.WHITE);
+
+        mCalendarBackground = ContextCompat.getDrawable(mContext, R.drawable.ic_calendar_plate_original);
+    }
+
+    @Override
+    protected boolean hasChanged() {
+        String currentDate = DynamicIconUtils.getDateOfMonth(Calendar.getInstance());
+        if (mLastDate.equals(currentDate)) {
+            return false;
+        } else {
+            mLastDate = currentDate;
+            return true;
+        }
+    }
+
+    @Override
+    protected IntentFilter getReceiverFilter() {
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_TIME_TICK);
+        filter.addAction(Intent.ACTION_DATE_CHANGED);
+        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
+        return filter;
+    }
+
+    public Drawable getStableBackground() {
+        return mCalendarBackground;
+    }
+
+    public DynamicIconDrawCallback getDynamicIconDrawCallback() {
+        return mDrawCallback;
+    }
+
+    @Override
+    protected void draw(Canvas canvas, View icon, float scale, Point center) {
+        if (canvas == null || center == null || !(icon instanceof BubbleTextView)) {
+            return;
+        }
+
+        String day;
+        day = DynamicIconUtils.getDateOfMonth(mIsChecked ? Calendar.getInstance() : mDefaultDate);
+
+        //init icon real rect on the  canvas
+        Rect iconRect = getIconRealRect(icon, scale, center);
+        if (iconRect == null) {
+            return;
+        }
+
+        float dateSize = iconRect.height() * DATE_SIZE_FACTOR;
+        mDatePaint.setTextSize(scale * dateSize);
+
+        Paint.FontMetrics fm = mDatePaint.getFontMetrics();
+        float dateBaseline = (float)(center.y - fm.ascent * 0.5);
+
+        canvas.save();
+        canvas.drawText(day, center.x, dateBaseline, mDatePaint);
+        canvas.restore();
+    }
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/DynamicIcon.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/DynamicIcon.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/DynamicIcon.java	(revision 173368)
@@ -0,0 +1,150 @@
+package com.sprd.ext.dynamicIcon;
+
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.graphics.Canvas;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.view.View;
+
+import com.android.launcher3.BubbleTextView;
+import com.sprd.ext.UtilitiesExt;
+import com.sprd.ext.dynamicIcon.DynamicIconUtils.DynamicAppChangedCallbacks;
+import com.sprd.ext.LogUtils;
+
+/**
+ * Created by SPRD on 10/18/16.
+ */
+public abstract class DynamicIcon extends BroadcastReceiver {
+
+    private static final String TAG = "DynamicIcon";
+
+    protected Context mContext;
+    protected ComponentName mComponent;
+    protected boolean mIsChecked;
+
+    private boolean mIsRegisted;
+    private int mType;
+    private DynamicAppChangedCallbacks mCallbacks;
+
+    protected abstract void init();
+    protected abstract boolean hasChanged();
+    protected abstract IntentFilter getReceiverFilter();
+    public abstract DynamicIconDrawCallback getDynamicIconDrawCallback();
+    public abstract Drawable getStableBackground();
+    protected abstract void draw(Canvas canvas, View icon, float scale, Point center);
+
+    public class DynamicIconDrawCallback {
+        public void drawDynamicIcon(Canvas canvas, View icon, float scale, Point center) {}
+    }
+
+    protected DynamicIconDrawCallback mDrawCallback = new DynamicIconDrawCallback() {
+        @Override
+        public void drawDynamicIcon(Canvas canvas, View icon, float scale, Point center) {
+                draw(canvas, icon, scale, center);
+        }
+    };
+
+    public DynamicIcon(Context context, int type) {
+        mContext = context;
+        mType = type;
+        init();
+    }
+
+    public void setDynamicIconDrawCallback(DynamicAppChangedCallbacks callbacks) {
+        mCallbacks = callbacks;
+    }
+
+    public void setCheckedState(boolean isChecked) {
+        mIsChecked = isChecked;
+    }
+
+    public void setComponentName(ComponentName component) {
+        mComponent = component;
+    }
+
+    public ComponentName getComponentName() {
+        return mComponent;
+    }
+
+    public CharSequence getAppLabel() {
+        CharSequence ch = null;
+        if (mComponent != null) {
+            String pkgName = mComponent.getPackageName();
+            ch = UtilitiesExt.getAppLabelByPackageName(mContext, pkgName);
+        }
+        return ch;
+    }
+
+    public int getType() {
+        return mType;
+    }
+
+    public boolean isCheckedState() {
+        return mIsChecked;
+    }
+
+    protected Rect getIconRealRect(View icon, float scale, Point center) {
+        if (!(icon instanceof BubbleTextView)) {
+            return null;
+        }
+
+        Rect iconRect = ((BubbleTextView) icon).getIconRect();
+
+        if (iconRect.centerX() != center.x || iconRect.centerY() != center.y
+                || scale != DynamicIconUtils.STABLE_SCALE) {
+
+            int newIconWidth = Math.round(iconRect.width() * scale);
+            int newIconHeight = Math.round(iconRect.height() * scale);
+
+            iconRect.left = center.x - (newIconWidth >> 1);
+            iconRect.top = center.y - (newIconHeight >> 1);
+            iconRect.right = iconRect.left + newIconWidth;
+            iconRect.bottom = iconRect.top + newIconHeight;
+        }
+        return iconRect;
+    }
+
+    protected void forceUpdateView(boolean force) {
+        if (force || hasChanged()) {
+            if (mCallbacks != null) {
+                mCallbacks.bindComponentDynamicIconChanged(mComponent);
+            }
+        }
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        final String action = intent.getAction();
+        if (mIsChecked) {
+            if (LogUtils.DEBUG_DYNAMIC_ICON) {
+                LogUtils.d(TAG, "Receive broadcast: " + action + ", this = " + this);
+            }
+
+            forceUpdateView(false);
+        }
+    }
+
+    public boolean registerReceiver() {
+        if (!mIsRegisted) {
+            IntentFilter filter = getReceiverFilter();
+            mContext.registerReceiver(this, filter);
+            mIsRegisted = true;
+            return true;
+        }
+        return false;
+    }
+
+    public boolean unRegisterReceiver() {
+        if (mIsRegisted) {
+            mContext.unregisterReceiver(this);
+            mIsRegisted = false;
+            return true;
+        }
+        return false;
+    }
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/DynamicIconSettings.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/DynamicIconSettings.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/DynamicIconSettings.java	(revision 173368)
@@ -0,0 +1,17 @@
+package com.sprd.ext.dynamicIcon;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+/**
+ * Created by SPRD on 12/2/16.
+ */
+public class DynamicIconSettings extends Activity {
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        getFragmentManager().beginTransaction().replace(android.R.id.content, new DynamicIconSettingsFragment())
+                .commit();
+    }
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/DynamicIconUtils.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/DynamicIconUtils.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/dynamicIcon/DynamicIconUtils.java	(revision 173368)
@@ -0,0 +1,600 @@
+package com.sprd.ext.dynamicIcon;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.database.Cursor;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Point;
+import android.graphics.drawable.Drawable;
+import android.os.SystemProperties;
+import android.text.TextUtils;
+import android.view.View;
+
+import com.android.launcher3.AppInfo;
+import com.android.launcher3.BubbleTextView;
+import com.android.launcher3.Folder;
+import com.android.launcher3.FolderIcon;
+import com.android.launcher3.FolderInfo;
+import com.android.launcher3.IconCache;
+import com.android.launcher3.ItemInfo;
+import com.android.launcher3.Launcher;
+import com.android.launcher3.R;
+import com.android.launcher3.ShortcutAndWidgetContainer;
+import com.android.launcher3.ShortcutInfo;
+import com.android.launcher3.Utilities;
+import com.android.launcher3.Workspace;
+import com.android.launcher3.allapps.AllAppsContainerView;
+import com.android.launcher3.util.Thunk;
+import com.sprd.ext.FeatureOption;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.UtilitiesExt;
+import com.sprd.ext.dynamicIcon.DynamicIcon.DynamicIconDrawCallback;
+import com.sprd.ext.dynamicIcon.calendar.DynamicCalendar;
+import com.sprd.ext.dynamicIcon.calendar.OriginalDynamicCalendar;
+import com.sprd.ext.dynamicIcon.deskclock.OriginalDynamicDeskclock;
+
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Locale;
+
+/**
+ * Created by SPRD on 10/19/16.
+ */
+public class DynamicIconUtils {
+
+    private static final String TAG = "DynamicIconUtils";
+
+    public static final float STABLE_SCALE = 1.0f;
+
+    public static final int DYNAMIC_CALENDAR_TYPE = 1001;
+    public static final int DYNAMIC_CLOCK_TYPE = 1002;
+    public static final ComponentName sCalendarComponentName =
+            new ComponentName("com.android.calendar", "com.android.calendar.AllInOneActivity");
+    public static final ComponentName sDeskClockComponentName =
+            new ComponentName("com.android.deskclock", "com.android.deskclock.DeskClock");
+
+    // Ture if the dynamic icon is the customize icon from sprd,
+    // otherwise, it is similar to the AOSP icon.
+    private  static final boolean CUSTOMIZE_DYNAMIC_ICON =
+            SystemProperties.getBoolean("ro.launcher.dyicon.customize", true);
+    private static final String GOOGLE = "google";
+    private volatile static DynamicIconUtils INSTANCE;
+    private static final int INVALID_NUM = -1;
+    private ArrayList<DynamicIcon> DYNAMIC_INFOS = new ArrayList<>();
+
+    private Launcher mLauncher;
+    private Workspace mWorkspace;
+    private AllAppsContainerView mAppsView;
+    private ComponentName mDynamicCalCn;
+    private ComponentName mDynamicClockCn;
+    private Context mContext;
+
+    @Thunk final Object mLock = new Object();
+
+    private boolean mResumed;
+    private boolean mNeedRegister;
+
+    public DynamicIconUtils(Context context) {
+        mContext = context;
+        if (FeatureOption.SPRD_DYNAMIC_CALENDAR_SUPPORT) {
+            mDynamicCalCn = getDynamicIconCnByType(DYNAMIC_CALENDAR_TYPE);
+        }
+        if (FeatureOption.SPRD_DYNAMIC_CLOCK_SUPPORT) {
+            mDynamicClockCn = getDynamicIconCnByType(DYNAMIC_CLOCK_TYPE);
+        }
+        loadDynamicIconInfo();
+    }
+
+    public static DynamicIconUtils getInstance(Context context) {
+        if (INSTANCE == null) {
+            synchronized(DynamicIconUtils.class){
+                if (INSTANCE == null) {
+                    INSTANCE = new DynamicIconUtils(context);
+                }
+            }
+        }
+        return INSTANCE;
+    }
+
+    /**
+     * Set this as the current Launcher activity object for the loader.
+     */
+    public void initialize(Launcher launcher) {
+        synchronized (mLock) {
+            if (launcher != null) {
+                if (mLauncher != null) {
+                    LogUtils.w(TAG, "initialize called twice! old=" + mLauncher + " new=" + launcher);
+                }
+
+                //step1: init object
+                mLauncher = launcher;
+                mWorkspace = launcher.getWorkspace();
+                mAppsView = launcher.getAppsView();
+                mResumed = true;
+
+                //step2: bind dynamic icon
+                initDynamicIconDrawCallback();
+                updateDynamicIconRegisterState();
+                if (mLauncher != null) {
+                    mLauncher.bindDynamicIconIfNeeded();
+                }
+            }
+        }
+    }
+
+    private void initDynamicIconDrawCallback() {
+        for (int i = 0; i < DYNAMIC_INFOS.size(); i++) {
+            DynamicIcon dynamicIcon = DYNAMIC_INFOS.get(i);
+            if (mLauncher != null) {
+                dynamicIcon.setDynamicIconDrawCallback(mLauncher);
+            }
+        }
+    }
+
+    /**
+     * Reset all objects when onDestroy is called in the launcher activity.
+     */
+    public void destroy() {
+        mLauncher = null;
+        mWorkspace = null;
+        mAppsView = null;
+
+        mResumed = false;
+        mNeedRegister = false;
+
+        resetDynamicIconInfo(false);
+    }
+
+    /**
+     * Get the stable part of the dynamic icon for the ComponentName
+     */
+    public Drawable getStableBGForComponent(ComponentName componentName) {
+        return getStableBGAt(supportDynamicIcon(componentName));
+    }
+
+    /**
+     * Get DynamicIconDrawCallback according to componentName
+     */
+    public DynamicIconDrawCallback getDIDCForComponent(ComponentName componentName) {
+        return getDynamicIconCallbackAt(supportDynamicIcon(componentName));
+    }
+
+    public DynamicIcon getDynamicIconByType(int type) {
+        for (int i = 0; i < DYNAMIC_INFOS.size(); i ++) {
+            DynamicIcon icon = DYNAMIC_INFOS.get(i);
+            if (icon.getType() == type) {
+                return icon;
+            }
+        }
+        return null;
+    }
+
+    private ComponentName getDynamicIconCnByType(int type) {
+        // get the componentName of system apps that support dynamic icon by the type.
+        ComponentName cn = getComponentByType(type);
+
+        boolean isInstalled = UtilitiesExt.isAppInstalled(mContext, cn);
+        if (!isInstalled) {
+            cn = getCustomItemComponentName(type);
+            isInstalled = UtilitiesExt.isAppInstalled(mContext, cn);
+        }
+
+        if (!isInstalled) {
+            LogUtils.d(TAG, "The app (" + cn
+                + ") is not installed, so making the variable to be null");
+            cn = null;
+        }
+
+        if (LogUtils.DEBUG_DYNAMIC_ICON) {
+            LogUtils.d(TAG, "getDynamicIconCnByType: type = " + type + ", cn = " + cn);
+        }
+
+        return cn;
+    }
+
+    private ComponentName getCustomItemComponentName(int type) {
+        String componentName = "";
+        switch (type) {
+            case DYNAMIC_CALENDAR_TYPE:
+                componentName = mContext.getResources().getString(R.string.custom_dynamic_calendar);
+                break;
+            case DYNAMIC_CLOCK_TYPE:
+                componentName = mContext.getResources().getString(R.string.custom_dynamic_clock);
+                break;
+        }
+        return ComponentName.unflattenFromString(componentName);
+    }
+
+    private ComponentName getComponentByType(int type) {
+        ComponentName cn = null;
+        switch (type) {
+            case DYNAMIC_CALENDAR_TYPE:
+                cn = sCalendarComponentName;
+                break;
+            case DYNAMIC_CLOCK_TYPE:
+                cn = sDeskClockComponentName;
+                break;
+        }
+        return cn;
+    }
+
+    private int supportDynamicIcon(ComponentName componentName) {
+        if (!FeatureOption.SPRD_DYNAMIC_ICON_SUPPORT) {
+            return INVALID_NUM;
+        }
+
+        final int size = DYNAMIC_INFOS.size();
+        for(int i = 0; i < size; i++) {
+            if (DYNAMIC_INFOS.get(i).getComponentName().equals(componentName)) {
+                return i;
+            }
+        }
+
+        return INVALID_NUM;
+    }
+
+    private DynamicIconDrawCallback getDynamicIconCallbackAt(int index) {
+        if (index < 0 || index >= DYNAMIC_INFOS.size()) {
+            return null;
+        }
+
+        DynamicIcon dynamicIcon = DYNAMIC_INFOS.get(index);
+        DynamicIconDrawCallback drawCallback = dynamicIcon == null ?
+                null : dynamicIcon.getDynamicIconDrawCallback();
+
+         if (LogUtils.DEBUG_DYNAMIC_ICON) {
+             LogUtils.d(TAG, "getDynamicIconCallbackAt: index = " + index
+                    + ", component = " + DYNAMIC_INFOS.get(index).getComponentName()
+                    + ", drawCallback = " + drawCallback);
+         }
+        return drawCallback;
+    }
+
+    private Drawable getStableBGAt(int index) {
+        if (index < 0 || index >= DYNAMIC_INFOS.size()) {
+            return null;
+        }
+
+        if (LogUtils.DEBUG_DYNAMIC_ICON) {
+            LogUtils.d(TAG, "getStableBGAt: index = " + index
+                    + ", component = " + DYNAMIC_INFOS.get(index).getComponentName());
+        }
+        return DYNAMIC_INFOS.get(index).getStableBackground();
+    }
+
+    /**
+     * Load and initialize dynamic icon.
+     */
+    private void loadDynamicIconInfo() {
+        if (LogUtils.DEBUG_DYNAMIC_ICON) {
+            LogUtils.d(TAG, "start to load the dynamic icon info");
+        }
+        resetDynamicIconInfo(true);
+
+        if (FeatureOption.SPRD_DYNAMIC_CALENDAR_SUPPORT && mDynamicCalCn != null) {
+            DynamicIcon dynamicCal;
+            if (CUSTOMIZE_DYNAMIC_ICON && !isGoogleApp(mDynamicCalCn)) {
+                dynamicCal = new DynamicCalendar(mContext, DYNAMIC_CALENDAR_TYPE);
+            } else {
+                dynamicCal = new OriginalDynamicCalendar(mContext, DYNAMIC_CALENDAR_TYPE);
+            }
+            dynamicCal.setComponentName(mDynamicCalCn);
+            DYNAMIC_INFOS.add(dynamicCal);
+        }
+
+        if (FeatureOption.SPRD_DYNAMIC_CLOCK_SUPPORT && mDynamicClockCn != null) {
+            DynamicIcon dynamicClock;
+            dynamicClock = new OriginalDynamicDeskclock(mContext, DYNAMIC_CLOCK_TYPE);
+            dynamicClock.setComponentName(mDynamicClockCn);
+            DYNAMIC_INFOS.add(dynamicClock);
+        }
+
+        if (LogUtils.DEBUG_DYNAMIC_ICON) {
+            LogUtils.d(TAG, "load complete: DYNAMIC_INFOS = " + DYNAMIC_INFOS.toString());
+        }
+    }
+
+    private void resetDynamicIconInfo(boolean isClear) {
+        for (int i = 0; i < DYNAMIC_INFOS.size(); i++) {
+            DynamicIcon dynamicIcon = DYNAMIC_INFOS.get(i);
+            dynamicIcon.setDynamicIconDrawCallback(null);
+            dynamicIcon.unRegisterReceiver();
+        }
+        if (isClear) {
+            DYNAMIC_INFOS.clear();
+        }
+    }
+
+    private boolean isGoogleApp(ComponentName cn) {
+        if (cn != null) {
+            String pkgName = cn.getPackageName();
+            if (!TextUtils.isEmpty(pkgName)
+                    && pkgName.contains(GOOGLE)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void registerReceiver() {
+        for (int i = 0; i < DYNAMIC_INFOS.size(); i++) {
+            DynamicIcon dynamicIcon = DYNAMIC_INFOS.get(i);
+            if (dynamicIcon.isCheckedState()) {
+                dynamicIcon.registerReceiver();
+            }
+        }
+    }
+
+    private void unRegisterReceiver() {
+        for (int i = 0; i < DYNAMIC_INFOS.size(); i++) {
+            DynamicIcon dynamicIcon = DYNAMIC_INFOS.get(i);
+            dynamicIcon.unRegisterReceiver();
+        }
+    }
+
+    public void syncResumeState(boolean resumed) {
+        mResumed = resumed;
+        updateDynamicIconRegisterState();
+    }
+
+
+    private void updateDynamicIconRegisterState() {
+        if (LogUtils.DEBUG_DYNAMIC_ICON) {
+            LogUtils.d(TAG, "updateDynamicIconRegisterState, mResumed:mNeedRegister->"
+                    + mResumed + ":" + mNeedRegister);
+        }
+        if (mResumed != mNeedRegister) {
+            mNeedRegister = mResumed;
+            if (mNeedRegister) {
+                registerReceiver();
+            } else {
+                unRegisterReceiver();
+            }
+        }
+    }
+
+    public void updateComponentDynamicIconChanged(final ComponentName component) {
+        updateWorkspaceDynamicIconChanged(component);
+        if (mAppsView != null && mLauncher.isAppsViewVisible()) {
+            mAppsView.updateAppsDynamicIconChanged(component);
+        }
+    }
+
+    /**
+     * SPRD: Update dynamic icon of shortcuts and folders in workspace and hotseat
+     * with the given component.
+     */
+    private void updateWorkspaceDynamicIconChanged(final ComponentName component) {
+        if (mWorkspace == null) {
+            return;
+        }
+        final ArrayList<ShortcutAndWidgetContainer> childrenLayouts =
+                mWorkspace.getAllShortcutAndWidgetContainers();
+        int childCount;
+        View view;
+        Object tag;
+        for (ShortcutAndWidgetContainer layout : childrenLayouts) {
+            childCount = layout.getChildCount();
+            for (int j = 0; j < childCount; j++) {
+                view = layout.getChildAt(j);
+
+                if (view != null) {
+                    tag = view.getTag();
+                } else {
+                    if (LogUtils.DEBUG_DYNAMIC_ICON) {
+                        LogUtils.d(TAG, "updateWorkspaceDynamicIconChanged: view is null pointer");
+                    }
+                    continue;
+                }
+
+                if (tag instanceof ShortcutInfo) {
+                    final ShortcutInfo info = (ShortcutInfo) tag;
+                    final Intent intent = info.getIntent();
+                    final ComponentName componentName = intent.getComponent();
+                    if (componentName != null && componentName.equals(component)) {
+                        if (LogUtils.DEBUG_DYNAMIC_ICON_ALL) {
+                            LogUtils.d(TAG, "updateWorkspaceDynamicIconChanged: component = " + component
+                                    + ", cellX = " + info.cellX + ", cellY = " + info.cellY
+                                    + ", screenId = " + info.screenId);
+                        }
+                        view.invalidate();
+                    }
+                }
+            }
+        }
+
+        /// SPRD: Update shortcut within folder if open folder exists.
+        Folder openFolder = mWorkspace.getOpenFolder();
+        updateFolderContentDynamicIcon(openFolder, component, false);
+    }
+
+    /**
+     * SPRD: Update dynamic icon of the content shortcut.
+     */
+    private boolean updateFolderContentDynamicIcon(Folder folder, ComponentName component, boolean init) {
+        boolean hasDynamicIcon = false;
+        if (folder == null) {
+            return false;
+        }
+
+        final ArrayList<ShortcutAndWidgetContainer> childrenLayouts =
+                folder.getAllShortcutContainersInFolder();
+        int childCount;
+        View view;
+        Object tag;
+
+        for (ShortcutAndWidgetContainer layout : childrenLayouts) {
+            childCount = layout.getChildCount();
+            for (int j = 0; j < childCount; j++) {
+                view = layout.getChildAt(j);
+                tag = view.getTag();
+
+                if (tag instanceof ShortcutInfo) {
+                    final ShortcutInfo info = (ShortcutInfo) tag;
+                    final Intent intent = info.getIntent();
+                    final ComponentName componentName = intent.getComponent();
+
+                    if (init) {
+                        info.dynamicIconDrawCallback = getDIDCForComponent(componentName);
+                        if (info.dynamicIconDrawCallback != null) {
+                            if (LogUtils.DEBUG_DYNAMIC_ICON) {
+                                LogUtils.d(TAG, "updateFolderContentDynamicIcon:find componentName = " + componentName
+                                        + ", info.dynamicIconDrawCallback = " + info.dynamicIconDrawCallback
+                                        + ", cellX = " + info.cellX + ", cellY = " + info.cellY
+                                        + ", screenId = " + info.screenId);
+                            }
+                            hasDynamicIcon = true;
+                        }
+                    } else if (componentName != null && componentName.equals(component)) {
+                        view.invalidate();
+                        if (LogUtils.DEBUG_DYNAMIC_ICON_ALL) {
+                            LogUtils.d(TAG, "updateFolderContentDynamicIcon:find componentName = " + componentName
+                                    + ", cellX = " + info.cellX + ", cellY = " + info.cellY
+                                    + ", screenId = " + info.screenId);
+                        }
+                    }
+                }
+            }
+        }
+        return hasDynamicIcon;
+    }
+
+    /**
+     * SPRD: Update dynamic icon  of shortcuts in workspace and hotseat.
+     */
+    public void updateShortcutsAndFoldersDynamicIcon() {
+        if (mWorkspace == null) {
+            return;
+        }
+
+        final ArrayList<ShortcutAndWidgetContainer> childrenLayouts =
+                mWorkspace.getAllShortcutAndWidgetContainers();
+        int childCount;
+        View view;
+        Object tag;
+        for (ShortcutAndWidgetContainer layout : childrenLayouts) {
+            childCount = layout.getChildCount();
+            for (int j = 0; j < childCount; j++) {
+                view = layout.getChildAt(j);
+                tag = view.getTag();
+
+                if (tag instanceof ShortcutInfo) {
+                    final ShortcutInfo info = (ShortcutInfo) tag;
+                    final Intent intent = info.getIntent();
+                    final ComponentName componentName = intent.getComponent();
+                    info.dynamicIconDrawCallback = getDIDCForComponent(componentName);
+                    if (info.dynamicIconDrawCallback != null) {
+                        if (LogUtils.DEBUG_DYNAMIC_ICON) {
+                            LogUtils.d(TAG, "updateShortcutsAndFoldersDynamicIcon: componentName = " + componentName
+                                    + ", dynamicIconDrawCallback = " + info.dynamicIconDrawCallback
+                                    + ", cellX = " + info.cellX + ", cellY = " + info.cellY
+                                    + ", screenId = " + info.screenId);
+                        }
+                        view.invalidate();
+                    }
+                } else if (tag instanceof FolderInfo) {
+                    Folder folder = ((FolderIcon) view).getFolder();
+                    boolean hasDynamicIcon = updateFolderContentDynamicIcon(folder, null, true);
+                    if (hasDynamicIcon) {
+                        final FolderInfo info = (FolderInfo) tag;
+                        if (LogUtils.DEBUG_DYNAMIC_ICON) {
+                            LogUtils.d(TAG, "updateShortcutsAndFoldersDynamicIcon: cellX = " + info.cellX
+                                    + ", cellY = " + info.cellY + ", screenId = " + info.screenId);
+                        }
+                        view.invalidate();
+                    }
+                }
+            }
+        }
+    }
+
+     /**
+     * SPRD: Get DynamicIconDrawCallback of the app info with given component
+     */
+    public void updateDIDCInAppInfo(final ArrayList<AppInfo> apps) {
+        if(apps == null){
+            LogUtils.e(TAG, "updateDIDCInAppInfo: apps == null");
+            return;
+        }
+        final int size = apps.size();
+        AppInfo appInfo;
+        for (int i = 0; i < size; i++) {
+            appInfo = apps.get(i);
+            appInfo.dynamicIconDrawCallback = getDIDCForComponent(appInfo.componentName);
+        }
+    }
+
+    /**
+     * SPRD: Draw dynamic part of the dynamic icon if needed.
+     * @param canvas the canvas to draw the dynamic icon.
+     * @param icon the view on which to draw the dynamic icon.
+     * @param scale the scale of the dynamic icon.
+     * @param center the center of the dynamic icon.
+     */
+    public static void drawDynamicIconIfNeed(Canvas canvas, View icon, float scale, Point center) {
+        if (!FeatureOption.SPRD_DYNAMIC_ICON_SUPPORT) {
+            return;
+        }
+        if (icon instanceof BubbleTextView) {
+            ItemInfo info = (ItemInfo) icon.getTag();
+            if (info != null) {
+                DynamicIconDrawCallback callback = info.dynamicIconDrawCallback;
+                if (callback != null) {
+                    if (LogUtils.DEBUG_DYNAMIC_ICON_ALL) {
+                        LogUtils.d(TAG, "drawDynamicIconIfNeed: parent = " + icon.getParent().getParent()
+                                + "callback = " + callback);
+                    }
+                    callback.drawDynamicIcon(canvas, icon, scale, center);
+                }
+            }
+        }
+    }
+
+    public interface DynamicAppChangedCallbacks {
+        void bindComponentDynamicIconChanged(ComponentName component);
+    }
+
+    public static boolean isDynamicIconView(final View v) {
+        if (v instanceof BubbleTextView) {
+            ItemInfo info = (ItemInfo) v.getTag();
+            if (info != null && info.dynamicIconDrawCallback != null) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean updateDynamicIconBgIfNeeded(Cursor c, int iconIndex, ComponentName cn) {
+        boolean update = false;
+        if (FeatureOption.SPRD_DYNAMIC_ICON_SUPPORT) {
+            Drawable d = getStableBGForComponent(cn);
+            if (d != null) {
+                Bitmap bitmap = IconCache.loadIconNoResize(c, iconIndex, null);
+                Bitmap stableGg = Utilities.createIconBitmap(d, mContext);
+                if (bitmap != stableGg) {
+                    update = true;
+                }
+            }
+        }
+
+        if (LogUtils.DEBUG_DYNAMIC_ICON) {
+            LogUtils.d(TAG, "updateDynamicIconBgIfNeeded: update = " + update);
+        }
+        return update;
+    }
+
+    public static String getDateOfMonth(Calendar calendar) {
+        return Integer.toString(calendar.get(Calendar.DAY_OF_MONTH));
+    }
+
+    public static String getDayOfWeek(Calendar calendar, Locale locale) {
+        return calendar.getDisplayName(
+                Calendar.DAY_OF_WEEK, Calendar.SHORT, locale).toUpperCase(Locale.ENGLISH);
+    }
+
+    public static int getTimeByField(Calendar calendar, int field) {
+        return calendar.get(field);
+    }
+}
\ No newline at end of file
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/sms/UnreadMessageItem.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/sms/UnreadMessageItem.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/sms/UnreadMessageItem.java	(revision 173368)
@@ -0,0 +1,124 @@
+package com.sprd.ext.unreadnotifier.sms;
+
+import android.Manifest;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.SystemProperties;
+import android.provider.BaseColumns;
+
+import com.android.launcher3.R;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.UtilitiesExt;
+import com.sprd.ext.unreadnotifier.BaseContentObserver;
+import com.sprd.ext.unreadnotifier.MMSAppUtils;
+import com.sprd.ext.unreadnotifier.UnreadBaseItem;
+import com.sprd.ext.unreadnotifier.UnreadInfoManager;
+import com.sprd.ext.unreadnotifier.UnreadSettingsFragment;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+/**
+ * Created by SPRD on 2016/11/22.
+ */
+
+public class UnreadMessageItem extends UnreadBaseItem {
+    private static final String TAG = "MessageUnreadItem";
+    private static final Uri MMS_CONTENT_URI = Uri.parse("content://mms");
+    private static final Uri SMS_CONTENT_URI = Uri.parse("content://sms");
+    private static final Uri MMSSMS_CONTENT_URI = Uri.parse("content://mms-sms");
+
+    static final ComponentName DEFAULT_CNAME = new ComponentName("com.android.messaging",
+            "com.android.messaging.ui.conversationlist.ConversationListActivity");
+
+    private static final String PROP_DEFAULT_SMS = "ro.launcher.unread.sms";
+
+    public UnreadMessageItem(Context context) {
+        super(context);
+        mContentObserver = new BaseContentObserver(new Handler(), context, MMSSMS_CONTENT_URI, this);
+        mPermission = Manifest.permission.READ_SMS;
+        mPrefKey = UnreadSettingsFragment.PREF_KEY_UNREAD_SMS;
+        mType = UnreadInfoManager.TYPE_SMS;
+        mDefaultCn = DEFAULT_CNAME;
+        boolean defaultState = mContext.getResources().getBoolean(R.bool.config_default_unread_sms_enable);
+        mDefaultState = SystemProperties.getBoolean(PROP_DEFAULT_SMS, defaultState);
+    }
+
+    @Override
+    public int readUnreadCount() {
+        int unreadSms = 0;
+        int unreadMms = 0;
+        ContentResolver resolver = mContext.getContentResolver();
+
+        boolean result = checkPermission();
+        if (!result) {
+            LogUtils.w(TAG, "no READ_SMS Permission");
+            return 0;
+        }
+
+        Cursor smsCursor = null;
+        try {
+            smsCursor = resolver.query(SMS_CONTENT_URI, new String[]{BaseColumns._ID},
+                    "type =1 AND read = 0", null, null);
+            if(smsCursor != null) {
+                unreadSms = smsCursor.getCount();
+            }
+        } catch (Exception e) {
+            // TODO: handle exception
+            LogUtils.d(TAG, "readUnreadCount SMS Exception: "+ e);
+        } finally {
+            UtilitiesExt.closeCursorSilently(smsCursor);
+        }
+
+        Cursor mmsCursor = null;
+        try {
+            mmsCursor = resolver.query(MMS_CONTENT_URI, new String[]{BaseColumns._ID},
+                    "msg_box = 1 AND read = 0 AND ( m_type =130 OR m_type = 132 ) AND thread_id > 0",
+                    null, null);
+            if(mmsCursor != null) {
+                unreadMms = mmsCursor.getCount();
+            }
+        } catch (Exception e) {
+            // TODO: handle exception
+            LogUtils.d(TAG, "readUnreadCount MMS Exception: "+ e);
+        } finally {
+            UtilitiesExt.closeCursorSilently(mmsCursor);
+        }
+
+        if(LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "readUnreadCount: unread [sms : mms] = ["
+                    + unreadSms + " : " + unreadMms + "]");
+        }
+
+        return unreadMms + unreadSms;
+    }
+
+    @Override
+    public String getUnreadHintString() {
+        String name = mContext.getString(R.string.unread_sms);
+        return mContext.getString(R.string.unread_hint, name);
+    }
+
+    @Override
+    public ArrayList<String> loadApps(Context context) {
+        Collection<MMSAppUtils.SmsApplicationData> smsApplications =
+                MMSAppUtils.getApplicationCollection(context);
+
+        ArrayList<String> installedMsgList = new ArrayList<>();
+
+        for (MMSAppUtils.SmsApplicationData smsApplicationData : smsApplications) {
+            ComponentName componentName = new ComponentName(smsApplicationData.mPackageName, smsApplicationData.smsClassName);
+            String scName = componentName.flattenToShortString();
+            installedMsgList.add(scName);
+        }
+
+        return installedMsgList;
+    }
+}
+
+
+
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/sms/DefaultSmsPreference.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/sms/DefaultSmsPreference.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/sms/DefaultSmsPreference.java	(revision 173368)
@@ -0,0 +1,36 @@
+package com.sprd.ext.unreadnotifier.sms;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+
+import com.sprd.ext.unreadnotifier.AppListPreference;
+import com.sprd.ext.unreadnotifier.UnreadInfoManager;
+
+import java.util.ArrayList;
+
+/**
+ * Created by SPRD on 10/20/16.
+ */
+public class DefaultSmsPreference extends AppListPreference {
+    public DefaultSmsPreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        item = UnreadInfoManager.getInstance(context).getItemByType(UnreadInfoManager.TYPE_SMS);
+        if (item != null) {
+            isPermissionGranted = item.checkPermission();
+            initState = item.isPersistChecked();
+
+            //get initValue before verifyDefaultCN
+            initValue = item.readSavedValues();
+
+            ArrayList<String> listValues = item.loadApps(item.mContext);
+            item.setInstalledList(listValues);
+            item.verifyDefaultCN(listValues, UnreadMessageItem.DEFAULT_CNAME);
+
+            String pkgName = TextUtils.isEmpty(item.mCurrentCn) ? null
+                    : ComponentName.unflattenFromString(item.mCurrentCn).getPackageName();
+            setListValues(listValues, pkgName);
+        }
+    }
+}
\ No newline at end of file
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/UnreadSettingsFragment.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/UnreadSettingsFragment.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/UnreadSettingsFragment.java	(revision 173368)
@@ -0,0 +1,251 @@
+package com.sprd.ext.unreadnotifier;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.os.Build;
+import android.os.Bundle;
+import android.preference.Preference;
+import android.preference.PreferenceFragment;
+import android.text.TextUtils;
+import android.widget.Toast;
+
+import com.android.launcher3.R;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.unreadnotifier.calendar.CalendarPreference;
+import com.sprd.ext.unreadnotifier.call.DefaultPhonePreference;
+import com.sprd.ext.unreadnotifier.email.EmailPreference;
+import com.sprd.ext.unreadnotifier.sms.DefaultSmsPreference;
+
+/**
+ * Created by SPRD on 10/21/16.
+ */
+
+/**
+ * This fragment shows the unread settings preferences.
+ */
+public class UnreadSettingsFragment extends PreferenceFragment
+        implements Preference.OnPreferenceChangeListener,
+        AppListPreference.OnPreferenceCheckBoxClickListener{
+    private static final String TAG = "UnreadSettingsFragment";
+    private Context mContext;
+    private PackageManager mPm;
+
+    public static final String PREF_KEY_MISS_CALL = "pref_missed_call_count";
+    public static final String PREF_KEY_UNREAD_SMS = "pref_unread_sms_count";
+    public static final String PREF_KEY_UNREAD_EMAIL = "pref_unread_email_count";
+    public static final String PREF_KEY_UNREAD_CALENDAR = "pref_unread_calendar_count";
+
+    private DefaultPhonePreference mDefaultPhonePref;
+    private DefaultSmsPreference mDefaultSmsPref;
+    private EmailPreference mEmailPref;
+    private CalendarPreference mCalendarPref;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        mContext = getActivity();
+        mPm = mContext.getPackageManager();
+
+        UnreadInfoManager.getInstance(mContext).createItemIfNeeded();
+        addPreferencesFromResource(R.xml.unread_settings_preferences);
+
+        init();
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+        if(LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "onStop");
+        }
+
+        updateUnreadItemInfo(mDefaultPhonePref);
+        updateUnreadItemInfo(mDefaultSmsPref);
+        updateUnreadItemInfo(mEmailPref);
+        updateUnreadItemInfo(mCalendarPref);
+    }
+
+    public void updateUnreadItemInfo(AppListPreference preference) {
+        if(preference == null) {
+            return;
+        }
+        UnreadBaseItem item = preference.item;
+        if(item == null) {
+            return;
+        }
+        //get the initial value and state
+        boolean oldState = preference.initState;
+        String oldValue = preference.initValue;
+        boolean isOldGranted = preference.isPermissionGranted;
+
+        //get the current value and state
+        boolean currentState = item.isPersistChecked();
+        boolean isCurrentGranted = item.checkPermission();
+        ComponentName currentCn = item.getCurrentComponentName();
+        String currentValue = null;
+        if(currentCn != null) {
+            currentValue = currentCn.flattenToShortString();
+        }
+
+        boolean isOldEmpty = TextUtils.isEmpty(oldValue);
+        boolean isCurrentEmpty = TextUtils.isEmpty(currentValue);
+
+        if(!isCurrentGranted) {
+            return;
+        }
+
+        if(LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "item = "+item
+                    + ", oldState = "+oldState + ", oldValue = "+oldValue + ", isOldGranted = "+isOldGranted
+                    + ",currentState = "+ currentState + ",currentValue = "+ currentValue + ", isCurrentGranted = true.");
+        }
+
+        if(currentState != oldState) {
+            //checkbox state changed
+            if(currentState ) {
+                item.mContentObserver.registerContentObserver();
+                item.updateUIFromDatabase();
+            } else {
+                item.mContentObserver.unregisterContentObserver();
+                item.setUnreadCount(0);
+                UnreadInfoManager.updateUI(mContext, oldValue);
+            }
+        } else {
+            //checkbox state unchanged
+            if(currentState) {
+                //if oldValue is not empty, clear the unread info on the old icon.
+                if(!isOldEmpty && !oldValue.equals(currentValue)) {
+                    UnreadInfoManager.updateUI(mContext, oldValue);
+                }
+
+                //update the unread info on the new icon.
+                if(!isOldGranted) {
+                    //from permission denied to permission granted, need to re-register observer
+                    item.mContentObserver.registerContentObserver();
+                    item.updateUIFromDatabase();
+                } else {
+                    if((isOldEmpty && !isCurrentEmpty) || (!isOldEmpty && !oldValue.equals(currentValue))) {
+                        UnreadInfoManager.updateUI(mContext, currentValue);
+                    }
+                }
+            }
+        }
+
+    }
+
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        if (preference instanceof AppListPreference) {
+            ((AppListPreference) preference).item.mCurrentCn = (String)newValue;
+            ((AppListPreference) preference).setValue((String)newValue);
+            preference.setSummary(((AppListPreference) preference).getEntry());
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public void onPreferenceCheckboxClick(Preference preference) {
+        String key = preference.getKey();
+        if(LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "onPreferenceCheckboxClick, key is: "+ key);
+        }
+
+        UnreadBaseItem item = UnreadInfoManager.getInstance(mContext).getItemByKey(key);
+
+        if (item != null) {
+            if (item.isPersistChecked() && !item.checkPermission()) {
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+                    requestPermissions(new String[] {item.mPermission}, item.mType);
+                }
+            }
+        }
+    }
+
+    @Override
+    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
+        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+        if(LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "onRequestPermissionsResult, requestCode: " + requestCode + ", permissions:" + permissions+ "grantResults: "+grantResults.length);
+        }
+
+        UnreadBaseItem item = UnreadInfoManager.getInstance(mContext).getItemByType(requestCode);
+        if(item != null) {
+            if (grantResults.length == 1) {
+                if (grantResults[0] == PackageManager.PERMISSION_DENIED) {
+                    Toast.makeText(mContext, item.getUnreadHintString(), Toast.LENGTH_LONG).show();
+                }
+            } else {
+                LogUtils.e(TAG, "grantResult length error.");
+            }
+        }
+
+    }
+
+    private void init() {
+        mDefaultPhonePref = (DefaultPhonePreference) findPreference(PREF_KEY_MISS_CALL);
+        initPref(mDefaultPhonePref, R.string.pref_missed_call_count_summary);
+
+        mDefaultSmsPref = (DefaultSmsPreference) findPreference(PREF_KEY_UNREAD_SMS);
+        initPref(mDefaultSmsPref, R.string.pref_unread_sms_count_summary);
+
+        mEmailPref = (EmailPreference) findPreference(PREF_KEY_UNREAD_EMAIL);
+        initPref(mEmailPref, R.string.pref_unread_email_count_summary);
+
+        mCalendarPref = (CalendarPreference) findPreference(PREF_KEY_UNREAD_CALENDAR);
+        initPref(mCalendarPref, R.string.pref_unread_calendar_count_summary);
+    }
+
+    private boolean hasValidSelectItem(AppListPreference pref) {
+        return pref != null && pref.item != null && pref.item.mInstalledList != null
+                && !pref.item.mInstalledList.isEmpty();
+    }
+
+    private void initPref(Preference pref, int defaultSummaryID) {
+        if (pref != null) {
+            if (pref instanceof AppListPreference) {
+                AppListPreference appListPref = (AppListPreference)pref;
+                if (hasValidSelectItem(appListPref)) {
+                    appListPref.setOnPreferenceCheckBoxClickListener(this);
+                    appListPref.setPreferenceChecked(appListPref.item.isPersistChecked());
+                    loadPrefsSetting(appListPref, defaultSummaryID);
+                } else {
+                    removePref(appListPref);
+                    return;
+                }
+            }
+            pref.setOnPreferenceChangeListener(this);
+        }
+    }
+
+    private void loadPrefsSetting(AppListPreference preference, int defaultSummaryID) {
+        if (preference == null) {
+            return;
+        }
+
+        boolean ret = false;
+        ApplicationInfo info = null;
+        try {
+            UnreadBaseItem item = preference.item;
+            String pkgName = ComponentName.unflattenFromString(item.mCurrentCn).getPackageName();
+            LogUtils.d(TAG, "loadPrefsSetting preference.mCurrentCn: "+item.mCurrentCn);
+            LogUtils.d(TAG, "loadPrefsSetting pkgName: "+pkgName);
+            info = mPm.getApplicationInfo(pkgName, 0);
+            ret = info != null;
+        } catch (Exception e) {
+            LogUtils.e(TAG, "loadPrefsSetting failed, e:" + e);
+        }
+
+        preference.setSummary(ret ? info.loadLabel(mPm) : getString(defaultSummaryID));
+    }
+
+    private void removePref(Preference pref) {
+        if (pref != null) {
+            getPreferenceScreen().removePreference(pref);
+            LogUtils.e(TAG, "preference: " +pref.getTitle()+ " is null, remove it.");
+        }
+    }
+}
\ No newline at end of file
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/UnreadInfoManager.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/UnreadInfoManager.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/UnreadInfoManager.java	(revision 173368)
@@ -0,0 +1,235 @@
+package com.sprd.ext.unreadnotifier;
+
+import android.annotation.SuppressLint;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.os.Build;
+import android.text.TextUtils;
+import android.widget.Toast;
+
+import com.android.launcher3.Launcher;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.unreadnotifier.calendar.UnreadCalendarItem;
+import com.sprd.ext.unreadnotifier.call.MissCallItem;
+import com.sprd.ext.unreadnotifier.email.UnreadEmailItem;
+import com.sprd.ext.unreadnotifier.sms.UnreadMessageItem;
+
+import java.util.ArrayList;
+
+/**
+ * Created by SPRD on 11/15/16.
+ */
+
+public class UnreadInfoManager {
+    private static final String TAG = "UnreadInfoManager";
+
+    private static final int PERMISSIONS_REQUEST_CODE = 1001;
+
+    @SuppressLint("StaticFieldLeak")
+    private static UnreadInfoManager INSTANCE;
+    public Context mContext;
+
+    public static final int TYPE_CALL_LOG = 101;
+    public static final int TYPE_SMS = 102;
+    public static final int TYPE_EMAIL = 103;
+    public static final int TYPE_CALENDAR = 104;
+
+    private UnreadMessageItem mMessageUnreadItem;
+    private MissCallItem mMissCallItem;
+    private UnreadEmailItem mUnreadEmailItem;
+    private UnreadCalendarItem mUnreadCalendarItem;
+
+    private static final ArrayList<UnreadBaseItem> ALL_ITEMS =
+            new ArrayList<>();
+    private static final ArrayList<UnreadBaseItem> ALL_GRANTEDPERMISSION_ITEMS =
+            new ArrayList<>();
+    private static final ArrayList<UnreadBaseItem> ALL_DENIEDPERMISSION_ITEMS =
+            new ArrayList<>();
+
+    private UnreadInfoManager(Context context) {
+        mContext = context;
+    }
+
+    public static UnreadInfoManager getInstance(Context context) {
+        synchronized (UnreadInfoManager.class) {
+            if (INSTANCE == null) {
+                INSTANCE = new UnreadInfoManager(context);
+            }
+        }
+        return INSTANCE;
+    }
+
+    void createItemIfNeeded() {
+        if(ALL_ITEMS.isEmpty()) {
+            if(LogUtils.DEBUG_UNREAD) {
+                LogUtils.d(TAG, " ALL_ITEMS is empty, need create items.");
+            }
+            createItems();
+        }
+
+    }
+
+    private void createItems() {
+        if(mMessageUnreadItem == null) {
+            mMessageUnreadItem = new UnreadMessageItem(mContext);
+            ALL_ITEMS.add(mMessageUnreadItem);
+        }
+
+        if(mMissCallItem == null) {
+            mMissCallItem = new MissCallItem( mContext);
+            ALL_ITEMS.add(mMissCallItem);
+        }
+
+        if(mUnreadEmailItem == null) {
+            mUnreadEmailItem = new UnreadEmailItem(mContext);
+            ALL_ITEMS.add(mUnreadEmailItem);
+        }
+
+        if(mUnreadCalendarItem == null) {
+            mUnreadCalendarItem = new UnreadCalendarItem(mContext);
+            ALL_ITEMS.add(mUnreadCalendarItem);
+        }
+
+        if(LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "createItems(), size of ALL_ITEMS is "+ALL_ITEMS.size());
+        }
+    }
+
+    void initAppsAndPermissionList() {
+        int N = ALL_ITEMS.size();
+
+        ALL_GRANTEDPERMISSION_ITEMS.clear();
+        ALL_DENIEDPERMISSION_ITEMS.clear();
+
+        for(int i = 0; i<N;i++) {
+            UnreadBaseItem item = ALL_ITEMS.get(i);
+
+            //verify ComponentName
+            ArrayList<String> listValues = item.loadApps(item.mContext);
+            item.verifyDefaultCN(listValues, item.mDefaultCn);
+            item.setInstalledList(listValues);
+
+            //init permission List
+            if (item.isPersistChecked()) {
+                if (item.checkPermission()) {
+                    ALL_GRANTEDPERMISSION_ITEMS.add(item);
+                } else {
+                    ALL_DENIEDPERMISSION_ITEMS.add(item);
+                }
+            }
+        }
+    }
+
+    void initUnreadInfo(Context context){
+        int N = ALL_DENIEDPERMISSION_ITEMS.size();
+
+        String[] deniedString = new String[N];
+        for (int i = 0 ; i < N; i++) {
+            deniedString[i] = ALL_DENIEDPERMISSION_ITEMS.get(i).mPermission;
+        }
+        if(N > 0) {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+                ((Launcher) context).requestPermissions(deniedString, PERMISSIONS_REQUEST_CODE);
+            }
+        }
+
+        N = ALL_GRANTEDPERMISSION_ITEMS.size();
+        for (int i = 0 ; i < N; i++) {
+            UnreadBaseItem item = ALL_GRANTEDPERMISSION_ITEMS.get(i);
+            if(item != null) {
+                item.mContentObserver.registerContentObserver();
+                item.updateUIFromDatabase();
+            }
+        }
+    }
+
+    boolean isDeniedPermissionItem(String key) {
+        int N = ALL_DENIEDPERMISSION_ITEMS.size();
+        for (int i = 0 ; i < N; i++) {
+            UnreadBaseItem item = ALL_DENIEDPERMISSION_ITEMS.get(i);
+            if(item != null && item.getCurrentComponentName() != null) {
+                String value = item.getCurrentComponentName().flattenToShortString();
+                if (value.equals(key)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    public UnreadBaseItem getItemByType(int type) {
+        for (int i = 0; i < ALL_ITEMS.size(); i++) {
+            UnreadBaseItem item = ALL_ITEMS.get(i);
+            if (item.mType == type) {
+                return item;
+            }
+        }
+        return null;
+    }
+
+    public UnreadBaseItem getItemByKey(String key) {
+        for (int i = 0; i < ALL_ITEMS.size(); i++) {
+            UnreadBaseItem item = ALL_ITEMS.get(i);
+            if (item.mPrefKey.equals(key)) {
+                return item;
+            }
+        }
+        return null;
+    }
+
+    public void handleRequestPermissionResult(String[] permissions,
+                                              int[] grantResults) {
+        if(LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "handleRequestPermissionResult, onPermissionsResult counts: " + permissions.length + ":" + grantResults.length);
+        }
+
+        for (int i = 0; i < ALL_DENIEDPERMISSION_ITEMS.size(); i++) {
+            UnreadBaseItem item = ALL_DENIEDPERMISSION_ITEMS.get(i);
+            if(grantResults.length > 0 && permissions.length >0 && item.mPermission.equals(permissions[i])) {
+                if (grantResults[i] == PackageManager.PERMISSION_GRANTED) {
+                    if(LogUtils.DEBUG_UNREAD) {
+                        LogUtils.d(TAG, "handleRequestPermissionResult, permission granted:" + item.mPermission);
+                    }
+                    item.mContentObserver.registerContentObserver();
+                    item.updateUIFromDatabase();
+                } else if (grantResults[i] == PackageManager.PERMISSION_DENIED){
+                    Toast.makeText(mContext, item.getUnreadHintString(), Toast.LENGTH_LONG).show();
+                    if(LogUtils.DEBUG_UNREAD) {
+                        LogUtils.d(TAG, "handleRequestPermissionResult, permission denied:" + item.mPermission);
+                    }
+                }
+            }
+        }
+
+    }
+
+    static void updateUI(final Context context, final String desComponentName) {
+        if(LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "updateUI, desComponentName = "+desComponentName);
+        }
+        if (!TextUtils.isEmpty(desComponentName)) {
+            ComponentName cmpName = ComponentName.unflattenFromString(desComponentName);
+            int unreadCount = getUnreadCountForDesComponent(cmpName);
+            UnreadLoaderUtils.getInstance(context).updateComponentUnreadInfo(unreadCount, cmpName);
+        }
+    }
+
+    private static int getUnreadCountForDesComponent(final ComponentName desComponentName) {
+        int result = 0;
+        for(UnreadBaseItem item : ALL_ITEMS) {
+            if (!TextUtils.isEmpty(item.mCurrentCn)) {
+                ComponentName cmpName = ComponentName.unflattenFromString(item.mCurrentCn);
+                if (cmpName.equals(desComponentName)) {
+                    result += item.getUnreadCount();
+                }
+            }
+        }
+        if(LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "getUnreadCountForDesComponent, unreadCount of desComponentName: "
+                    +desComponentName+" is: "+result);
+        }
+        return result;
+    }
+
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/UnreadLoaderUtils.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/UnreadLoaderUtils.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/UnreadLoaderUtils.java	(revision 173368)
@@ -0,0 +1,670 @@
+package com.sprd.ext.unreadnotifier;
+
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.graphics.Canvas;
+import android.os.AsyncTask;
+import android.view.View;
+
+import com.android.launcher3.BubbleTextView;
+import com.android.launcher3.Folder;
+import com.android.launcher3.FolderIcon;
+import com.android.launcher3.FolderInfo;
+import com.android.launcher3.ItemInfo;
+import com.android.launcher3.Launcher;
+import com.android.launcher3.ShortcutAndWidgetContainer;
+import com.android.launcher3.ShortcutInfo;
+import com.android.launcher3.Workspace;
+import com.android.launcher3.allapps.AllAppsContainerView;
+import com.sprd.ext.BadgeUtils;
+import com.sprd.ext.LogUtils;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+
+/**
+ * Created by SPRD on 2016/9/27.
+ */
+class UnreadSupportShortcut {
+    UnreadSupportShortcut(String pkgName, String clsName, String keyString, int type) {
+        mComponent = new ComponentName(pkgName, clsName);
+        mKey = keyString;
+        mShortcutType = type;
+        mUnreadNum = 0;
+    }
+
+    ComponentName mComponent;
+    String mKey;
+    int mShortcutType;
+    int mUnreadNum;
+
+    @Override
+    public String toString() {
+        return "{UnreadSupportShortcut[" + mComponent + "], key = " + mKey + ",type = "
+                + mShortcutType + ",unreadNum = " + mUnreadNum + "}";
+    }
+}
+
+/**
+ * This class is a util class, implemented to do the following two things,:
+ *
+ * 1.Read config xml to get the shortcuts which support displaying unread number,
+ * then get the initial value of the unread number of each component and update
+ * shortcuts and folders through callbacks implemented in Launcher.
+ *
+ * 2. Receive unread broadcast sent by application, update shortcuts and folders in
+ * workspace, hot seat and update application icons in app customize paged view.
+ */
+public class UnreadLoaderUtils extends BroadcastReceiver {
+    private static final String TAG = "UnreadLoaderUtils";
+
+    private static final String PREFS_FILE_NAME = TAG + "_Pref";
+
+    private static final int UNREAD_TYPE_INTERNAL = 0;
+    private static final int UNREAD_TYPE_EXTERNAL = 1;
+
+    static final int INVALID_NUM = -1;
+
+    public static final String ACTION_UNREAD_CHANGED = "com.sprd.action.UNREAD_CHANGED";
+    private static final String EXTRA_UNREAD_COMPONENT = "com.sprd.intent.extra.UNREAD_COMPONENT";
+    private static final String EXTRA_UNREAD_NUMBER = "com.sprd.intent.extra.UNREAD_NUMBER";
+
+    private static final int MAX_UNREAD_COUNT = 99;
+
+    private static final ArrayList<UnreadSupportShortcut> UNREAD_SUPPORT_SHORTCUTS =
+            new ArrayList<>();
+
+    private static int sUnreadSupportShortcutsNum = 0;
+    private static final Object LOG_LOCK = new Object();
+
+    private Context mContext;
+
+    private SharedPreferences mSharePrefs;
+
+    private static UnreadLoaderUtils INSTANCE;
+
+    private Launcher mLauncher;
+    private Workspace mWorkspace;
+    private AllAppsContainerView mAppsView;
+
+    private WeakReference<UnreadCallbacks> mCallbacks;
+
+    private UnreadLoaderUtils(Context context) {
+        mContext = context;
+        mSharePrefs = mContext.getSharedPreferences(PREFS_FILE_NAME, Context.MODE_PRIVATE);
+    }
+
+    public static UnreadLoaderUtils getInstance(Context context) {
+        if (INSTANCE == null) {
+            INSTANCE = new UnreadLoaderUtils(context);
+        }
+        return INSTANCE;
+    }
+
+    @Override
+    public void onReceive(final Context context, final Intent intent) {
+        final String action = intent.getAction();
+        if (ACTION_UNREAD_CHANGED.equals(action)) {
+            final ComponentName componentName = ComponentName.unflattenFromString(
+                     intent.getStringExtra(EXTRA_UNREAD_COMPONENT));
+            final int unreadNum = intent.getIntExtra(EXTRA_UNREAD_NUMBER, INVALID_NUM);
+
+            updateComponentUnreadInfo(unreadNum , componentName);
+        }
+    }
+
+    public void updateComponentUnreadInfo(int unreadNum, ComponentName componentName) {
+        if (LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "[[[ updateComponentUnreadInfo ]]]: componentName = " + componentName
+                    + ", unreadNum = " + unreadNum + ", mCallbacks = " + mCallbacks);
+        }
+
+        if (componentName != null && unreadNum != INVALID_NUM) {
+            saveAndUpdateUI(componentName, unreadNum);
+        }
+    }
+
+    /**
+     * Set this as the current Launcher activity object for the loader.
+     */
+    public void initialize(Launcher launcher) {
+        mLauncher = launcher;
+        mWorkspace = mLauncher.getWorkspace();
+        mAppsView = mLauncher.getAppsView();
+
+        mCallbacks = new WeakReference<>((UnreadCallbacks)launcher);
+        if (LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "initialize: launcher = " + launcher
+                    + ", mCallbacks = " + mCallbacks);
+        }
+
+        UnreadInfoManager.getInstance(mContext).createItemIfNeeded();
+        UnreadInfoManager.getInstance(mContext).initAppsAndPermissionList();
+
+        loadAndInitUnreadShortcuts();
+    }
+
+    /**
+     * Load and initialize unread shortcuts.
+     */
+    public void loadAndInitUnreadShortcuts() {
+        new AsyncTask<Void, Void, Void>() {
+            @Override
+            protected Void doInBackground(Void... unused) {
+                loadUnreadSupportShortcuts();
+                return null;
+            }
+
+            @Override
+            protected void onPostExecute(final Void result) {
+                //Make sure initialization of UNREAD_SUPPORT_SHORTCUTS has completed before initUnreadInfo.
+                UnreadInfoManager.getInstance(mContext).initUnreadInfo(mLauncher);
+
+                if (mCallbacks != null) {
+                    UnreadCallbacks callbacks = mCallbacks.get();
+                    if (callbacks != null) {
+                        callbacks.bindUnreadInfoIfNeeded();
+                    }
+                }
+            }
+        }.execute();
+    }
+
+    private void saveAndUpdateUI(final ComponentName component, final int unReadNum) {
+        final String key = component.flattenToShortString();
+        final int index = supportUnreadFeature(component);
+        boolean needUpdate = false;
+        if (index != INVALID_NUM) {
+            if (UNREAD_SUPPORT_SHORTCUTS.get(index).mUnreadNum != unReadNum) {
+                saveUnreadNum(key, unReadNum);
+                needUpdate = true;
+            }
+        } else {
+            //add new info
+            if (unReadNum > 0) {
+                saveUnreadNum(key, unReadNum);
+                needUpdate = true;
+            }
+        }
+
+        if (needUpdate) {
+            if (index != INVALID_NUM) {
+                UNREAD_SUPPORT_SHORTCUTS.get(index).mUnreadNum = unReadNum;
+                if (LogUtils.DEBUG_UNREAD) {
+                    LogUtils.d(TAG, "saveAndUpdateUI,update SupportList, key:" + key + " success.");
+                }
+            } else {
+                UnreadSupportShortcut usShortcut = new UnreadSupportShortcut(
+                        component.getPackageName(),component.getClassName(),
+                        key,UNREAD_TYPE_EXTERNAL);
+                usShortcut.mUnreadNum = unReadNum;
+                UNREAD_SUPPORT_SHORTCUTS.add(usShortcut);
+                sUnreadSupportShortcutsNum = UNREAD_SUPPORT_SHORTCUTS.size();
+                if (LogUtils.DEBUG_UNREAD) {
+                    LogUtils.d(TAG, "saveAndUpdateUI, add To SupportList, key:" + key + " success."
+                            + getUnreadSupportShortcutInfo());
+                }
+            }
+
+            if(mCallbacks != null) {
+                final UnreadCallbacks callbacks = mCallbacks.get();
+                if (callbacks != null) {
+                    callbacks.bindComponentUnreadChanged(component, unReadNum);
+                }
+            }
+        }
+    }
+
+    private int readUnreadNum(final String key) {
+        return mSharePrefs.getInt(key, INVALID_NUM);
+    }
+
+    private boolean saveUnreadNum(final String key, final int unReadNum) {
+        SharedPreferences.Editor editor = mSharePrefs.edit();
+        editor.putInt(key, unReadNum).apply();
+        return true;
+    }
+
+    private boolean deleteUnreadNum(final String key) {
+        SharedPreferences.Editor editor = mSharePrefs.edit();
+        editor.remove(key).apply();
+        return true;
+    }
+
+    private void loadUnreadSupportShortcuts() {
+        long start = System.currentTimeMillis();
+        if (LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "loadUnreadSupportShortcuts begin: start = " + start);
+        }
+
+        // Clear all previous parsed unread shortcuts.
+        UNREAD_SUPPORT_SHORTCUTS.clear();
+
+        for (String key : mSharePrefs.getAll().keySet()) {
+            boolean needCreateShortCut = false;
+            int loadNum = 0;
+            if (!UnreadInfoManager.getInstance(mContext).isDeniedPermissionItem(key)) {
+                loadNum = readUnreadNum(key);
+                needCreateShortCut = loadNum > 0;
+            }
+
+            if (needCreateShortCut) {
+                ComponentName cmpName = ComponentName.unflattenFromString(key);
+
+                UnreadSupportShortcut usShortcut = new UnreadSupportShortcut(
+                        cmpName.getPackageName(), cmpName.getClassName(),
+                        key, UNREAD_TYPE_INTERNAL );
+                usShortcut.mUnreadNum = loadNum;
+                if (!UNREAD_SUPPORT_SHORTCUTS.contains( usShortcut )) {
+                    UNREAD_SUPPORT_SHORTCUTS.add(usShortcut);
+                }
+            } else {
+                deleteUnreadNum(key);
+            }
+        }
+
+        sUnreadSupportShortcutsNum = UNREAD_SUPPORT_SHORTCUTS.size();
+
+        if (LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "loadUnreadSupportShortcuts end: time used = "
+                    + (System.currentTimeMillis() - start) + ",sUnreadSupportShortcutsNum = "
+                    + sUnreadSupportShortcutsNum + getUnreadSupportShortcutInfo());
+        }
+    }
+
+    /**
+     * Get unread support shortcut information, since the information are stored
+     * in an array list, we may query it and modify it at the same time, a lock
+     * is needed.
+     *
+     * @return SupportShortString
+     */
+    private static String getUnreadSupportShortcutInfo() {
+        String info = " Unread support shortcuts are ";
+        ArrayList<UnreadSupportShortcut> logList = new ArrayList<>(UNREAD_SUPPORT_SHORTCUTS);
+        synchronized (LOG_LOCK) {
+            info += logList.toString();
+        }
+        return info;
+    }
+
+    /**
+     * Whether the given component support unread feature.
+     *
+     * @param component component
+     * @return array index, find fail return INVALID_NUM
+     */
+    static int supportUnreadFeature(ComponentName component) {
+        if (component == null) {
+            return INVALID_NUM;
+        }
+
+        final int size = UNREAD_SUPPORT_SHORTCUTS.size();
+        for (int i = 0; i < size; i++) {
+            if (UNREAD_SUPPORT_SHORTCUTS.get(i).mComponent.equals(component)) {
+                return i;
+            }
+        }
+
+        return INVALID_NUM;
+    }
+
+    /**
+     * Get unread number of application at the given position in the supported
+     * shortcut list.
+     *
+     * @param index
+     * @return
+     */
+    static synchronized int getUnreadNumberAt(int index) {
+        if (index < 0 || index >= sUnreadSupportShortcutsNum) {
+            return 0;
+        }
+        return UNREAD_SUPPORT_SHORTCUTS.get(index).mUnreadNum;
+    }
+
+    /**
+     * Get unread number for the given component.
+     *
+     * @param component
+     * @return
+     */
+    public static int getUnreadNumberOfComponent(ComponentName component) {
+        final int index = supportUnreadFeature(component);
+        return getUnreadNumberAt(index);
+    }
+
+    public void bindComponentUnreadChanged(final ComponentName component, final int unreadNum) {
+        if (mWorkspace != null) {
+            updateComponentUnreadChanged(component, unreadNum);
+        }
+
+        if (mAppsView != null) {
+            mAppsView.updateAppsUnreadChanged(component, unreadNum);
+        }
+    }
+
+    /**
+     * SPRD: Update unread number of shortcuts and folders in workspace and hotseat
+     * with the given component.
+     *
+     * @param component app component
+     * @param unreadNum app unreadNum
+     */
+    public void updateComponentUnreadChanged(ComponentName component, int unreadNum) {
+        if (LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "updateComponentUnreadChanged: component = " + component
+                    + ", unreadNum = " + unreadNum);
+        }
+        final ArrayList<ShortcutAndWidgetContainer> childrenLayouts =
+                mWorkspace.getAllShortcutAndWidgetContainers();
+        int childCount;
+        View view;
+        Object tag;
+        for (ShortcutAndWidgetContainer layout : childrenLayouts) {
+            childCount = layout.getChildCount();
+            for (int j = 0; j < childCount; j++) {
+                view = layout.getChildAt(j);
+
+                if (view != null) {
+                    tag = view.getTag();
+                } else {
+                    if (LogUtils.DEBUG_UNREAD) {
+                        LogUtils.d(TAG, "updateComponentUnreadChanged: view is null pointer");
+                    }
+                    continue;
+                }
+
+                if (tag instanceof ShortcutInfo) {
+                    final ShortcutInfo info = (ShortcutInfo) tag;
+                    final Intent intent = info.getIntent();
+                    final ComponentName componentName = intent.getComponent();
+                    if (componentName != null && componentName.equals(component)) {
+                        if (info.unreadNum != unreadNum) {
+                            info.unreadNum = unreadNum;
+                            if (LogUtils.DEBUG_UNREAD) {
+                                LogUtils.d(TAG, "updateComponentUnreadChanged is ShortcutInfo: find componentName = "
+                                        + componentName + "cellX = " + info.cellX +
+                                        ",cellY = " + info.cellY + ", Screen:" + info.screenId);
+                            }
+                            view.invalidate();
+                        }
+
+                    }
+                } else if (tag instanceof FolderInfo) {
+                    if (updateFolderUnreadNum((FolderIcon) view, component, unreadNum)) {
+                        final FolderInfo info = (FolderInfo) tag;
+                        if (LogUtils.DEBUG_UNREAD) {
+                            LogUtils.d(TAG, "updateComponentUnreadChanged is FolderInfo: " +
+                                    "component = " + component + "cellX = " + info.cellX +
+                                    ",cellY = " + info.cellY + ", Screen:" + info.screenId);
+                        }
+                        view.invalidate();
+                    }
+
+                }
+            }
+        }
+
+        /// SPRD: Update shortcut within folder if open folder exists.
+        Folder openFolder = mWorkspace.getOpenFolder();
+        updateContentUnreadNum(openFolder);
+    }
+
+    /**
+     * SPRD: Update the unread message of the shortcut with the given information.
+     *
+     * @param unreadNum the number of the unread message.
+     */
+    public static boolean updateFolderUnreadNum(FolderIcon folderIcon, ComponentName component, int unreadNum) {
+        if (folderIcon == null) {
+            return false;
+        }
+        final ArrayList<ShortcutInfo> contents = folderIcon.getFolderInfo().contents;
+        final int contentsCount = contents.size();
+        int unreadNumTotal = 0;
+        ShortcutInfo shortcutInfo;
+        ComponentName name;
+        final ArrayList<ComponentName> components = new ArrayList<>();
+        for (int i = 0; i < contentsCount; i++) {
+            shortcutInfo = contents.get(i);
+            name = shortcutInfo.getIntent().getComponent();
+            if (name != null && name.equals(component)) {
+                shortcutInfo.unreadNum = unreadNum;
+            }
+            if (shortcutInfo.unreadNum > 0) {
+                int j;
+                for (j = 0; j < components.size(); j++) {
+                    if (name != null && name.equals(components.get(j))) {
+                        break;
+                    }
+                }
+
+                if (j >= components.size()) {
+                    components.add(name);
+                    if (LogUtils.DEBUG_UNREAD) {
+                        LogUtils.d(TAG, "updateFolderUnreadNum, shortcutInfo.unreadNum = " +shortcutInfo.unreadNum+ ", cellX = " + shortcutInfo.cellX +
+                                ", cellY = " + shortcutInfo.cellY + ", Screen:" + shortcutInfo.screenId + ", container: "+shortcutInfo.container);
+                    }
+                    unreadNumTotal += shortcutInfo.unreadNum;
+                }
+            }
+        }
+        if (LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "updateFolderUnreadNum, end: unreadNumTotal = " + unreadNumTotal);
+        }
+
+        return setFolderUnreadNum(folderIcon, unreadNumTotal);
+    }
+
+    /**
+     * SPRD: Update the unread message number of the shortcut with the given value.
+     *
+     * @param unreadNum the number of the unread message.
+     */
+    public static boolean setFolderUnreadNum(FolderIcon folderIcon, int unreadNum) {
+        if (folderIcon == null) {
+            return false;
+        }
+
+        FolderInfo info = folderIcon.getFolderInfo();
+        if (LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "setFolderUnreadNum: unreadNum = " + unreadNum + ", info = " + info);
+        }
+
+        if (unreadNum <= 0) {
+            unreadNum = 0;
+        }
+
+        if (unreadNum != info.unreadNum) {
+            info.unreadNum = unreadNum;
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * SPRD: Update unread number of the content shortcut.
+     */
+    public void updateContentUnreadNum(Folder folder) {
+        if (folder == null) {
+            return;
+        }
+        if (LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "Folder updateContentUnreadNum: folder.getInfo() = " + folder.getInfo());
+        }
+        final ArrayList<ShortcutAndWidgetContainer> childrenLayouts =
+                folder.getAllShortcutContainersInFolder();
+        int childCount;
+        View view;
+        Object tag;
+
+        for (ShortcutAndWidgetContainer layout : childrenLayouts) {
+            childCount = layout.getChildCount();
+            for (int j = 0; j < childCount; j++) {
+                view = layout.getChildAt(j);
+                tag = view.getTag();
+                if (LogUtils.DEBUG_UNREAD) {
+                    LogUtils.d(TAG, "updateShortcutsAndFoldersUnread: tag = " + tag + ", j = "
+                            + j + ", view = " + view);
+                }
+                if (tag instanceof ShortcutInfo) {
+                    final ShortcutInfo info = (ShortcutInfo) tag;
+                    if (LogUtils.DEBUG_UNREAD) {
+                        LogUtils.d(TAG, "updateShortcutsAndFoldersUnread:info =" + info.toString());
+                    }
+                    view.invalidate();
+                }
+            }
+        }
+    }
+
+    /**
+     * SPRD: Update unread number of shortcuts and folders in workspace and hotseat.
+     */
+    public void updateShortcutsAndFoldersUnread() {
+        if (mWorkspace == null) {
+            return;
+        }
+
+        if (LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "updateShortcutsAndFolderUnread: this = " + this);
+        }
+        final ArrayList<ShortcutAndWidgetContainer> childrenLayouts =
+                mWorkspace.getAllShortcutAndWidgetContainers();
+        int childCount;
+        View view;
+        Object tag;
+        for (ShortcutAndWidgetContainer layout : childrenLayouts) {
+            childCount = layout.getChildCount();
+            for (int j = 0; j < childCount; j++) {
+                view = layout.getChildAt(j);
+                tag = view.getTag();
+                if (tag instanceof ShortcutInfo) {
+                    final ShortcutInfo info = (ShortcutInfo) tag;
+                    final Intent intent = info.getIntent();
+                    final ComponentName componentName = intent.getComponent();
+                    final int num = getUnreadNumberOfComponent(componentName);
+                    if (info.unreadNum != num) {
+                        if (LogUtils.DEBUG_UNREAD) {
+                            LogUtils.d(TAG, "updateShortcutsAndFoldersUnread is ShortcutInfo: " +
+                                    ", component = " + componentName + "cellX = " + info.cellX +
+                                    ",cellY = " + info.cellY + ", Screen:" + info.screenId);
+                        }
+                        info.unreadNum = num;
+                        view.invalidate();
+                    }
+                } else if (tag instanceof FolderInfo) {
+                    if (updateFolderUnreadNum((FolderIcon) view)) {
+                        if (LogUtils.DEBUG_UNREAD) {
+                            final FolderInfo info = (FolderInfo) tag;
+                            LogUtils.d(TAG, "updateComponentUnreadChanged is FolderInfo: " +
+                                    " cellX = " + info.cellX +
+                                    ",cellY = " + info.cellY + ", Screen:" + info.screenId);
+                        }
+                        view.invalidate();
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * SPRD: Update unread number of the folder, the number is the total unread number
+     * of all shortcuts in folder, duplicate shortcut will be only count once.
+     */
+    public boolean updateFolderUnreadNum(FolderIcon folderIcon) {
+        if (folderIcon == null) {
+            return false;
+        }
+        final ArrayList<ShortcutInfo> contents = folderIcon.getFolderInfo().contents;
+        final int contentsCount = contents.size();
+        int unreadNumTotal = 0;
+        final ArrayList<ComponentName> components = new ArrayList<>();
+        ShortcutInfo shortcutInfo;
+        ComponentName componentName;
+        int unreadNum;
+        for (int i = 0; i < contentsCount; i++) {
+            shortcutInfo = contents.get(i);
+            componentName = shortcutInfo.getIntent().getComponent();
+            unreadNum = getUnreadNumberOfComponent(componentName);
+            if (unreadNum > 0) {
+                shortcutInfo.unreadNum = unreadNum;
+                int j;
+                for (j = 0; j < components.size(); j++) {
+                    if (componentName != null && componentName.equals(components.get(j))) {
+                        break;
+                    }
+                }
+
+                if (j >= components.size()) {
+                    components.add(componentName);
+                    if (LogUtils.DEBUG_UNREAD) {
+                        LogUtils.d(TAG, "updateFolderUnreadNum, shortcutInfo.unreadNum = " +shortcutInfo.unreadNum+ ", cellX = " + shortcutInfo.cellX +
+                                ", cellY = " + shortcutInfo.cellY + ", Screen:" + shortcutInfo.screenId + ", container: "+shortcutInfo.container);
+                    }
+                    unreadNumTotal += unreadNum;
+                }
+            }
+        }
+        if (LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "updateFolderUnreadNum end: unreadNumTotal = " + unreadNumTotal);
+        }
+        return setFolderUnreadNum(folderIcon, unreadNumTotal);
+    }
+
+    /**
+     * Draw unread number for the given icon.
+     *
+     * @param canvas
+     * @param icon
+     * @return
+     */
+    public static void drawUnreadEventIfNeed(Canvas canvas, View icon) {
+        if (icon.getTag() instanceof ItemInfo) {
+            ItemInfo info = (ItemInfo) icon.getTag();
+            if (info.unreadNum > 0) {
+                String unreadText;
+                if (info.unreadNum > MAX_UNREAD_COUNT) {
+                    unreadText = Integer.toString(MAX_UNREAD_COUNT) + "+";
+                } else {
+                    unreadText = Integer.toString(info.unreadNum);
+                }
+                BadgeUtils.drawBadge(canvas, icon, unreadText);
+            }
+        }
+    }
+
+
+    public static boolean shouldDrawUnreadInfo(final View v) {
+        boolean result = false;
+        if(v instanceof BubbleTextView) {
+            ItemInfo info = (ItemInfo) v.getTag();
+            if(info!= null && info.unreadNum > 0) {
+                result = true;
+            }
+        }
+        return result;
+    }
+
+    public interface UnreadCallbacks {
+        /**
+         * Bind shortcuts and application icons with the given component, and
+         * update folders unread which contains the given component.
+         *
+         * @param component
+         * @param unreadNum
+         */
+        void bindComponentUnreadChanged(ComponentName component, int unreadNum);
+
+        /**
+         * Bind unread shortcut information if needed, this call back is used to
+         * update shortcuts and folders when launcher first created.
+         */
+        void bindUnreadInfoIfNeeded();
+    }
+}
+
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/email/UnreadEmailItem.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/email/UnreadEmailItem.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/email/UnreadEmailItem.java	(revision 173368)
@@ -0,0 +1,104 @@
+package com.sprd.ext.unreadnotifier.email;
+
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.SystemProperties;
+
+import com.android.launcher3.R;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.UtilitiesExt;
+import com.sprd.ext.unreadnotifier.BaseContentObserver;
+import com.sprd.ext.unreadnotifier.UnreadBaseItem;
+import com.sprd.ext.unreadnotifier.UnreadInfoManager;
+import com.sprd.ext.unreadnotifier.UnreadSettingsFragment;
+
+import java.util.ArrayList;
+
+/**
+ * Created by SPRD on 1/25/17.
+ */
+
+public class UnreadEmailItem extends UnreadBaseItem{
+    private static final String TAG = "UnreadEmailItem";
+    private static final Uri EMAILS_CONTENT_URI = Uri.parse("content://com.android.email.provider/mailbox");
+    private static final Uri EMAILS_NOTIFY_URI = Uri.parse("content://com.android.email.notifier");
+
+    static final ComponentName DEFAULT_CNAME = new ComponentName("com.android.email",
+            "com.android.email.activity.Welcome");
+
+    private static final String PROP_DEFAULT_EMAIL = "ro.launcher.unread.email";
+
+    public UnreadEmailItem(Context context) {
+        super(context);
+        mContentObserver = new BaseContentObserver(new Handler(), context, EMAILS_NOTIFY_URI, this);
+        mPermission = "com.android.email.permission.ACCESS_PROVIDER";
+        mPrefKey = UnreadSettingsFragment.PREF_KEY_UNREAD_EMAIL;
+        mType = UnreadInfoManager.TYPE_EMAIL;
+        mDefaultCn = DEFAULT_CNAME;
+        boolean defaultState = mContext.getResources().getBoolean(R.bool.config_default_unread_email_enable);
+        mDefaultState = SystemProperties.getBoolean(PROP_DEFAULT_EMAIL, defaultState);
+    }
+
+    @Override
+    public int readUnreadCount() {
+        int unreadEmail = 0;
+        int unRead;
+
+        ContentResolver resolver = mContext.getContentResolver();
+
+        boolean result = checkPermission();
+        if (!result) {
+            LogUtils.w(TAG, "no READ EMAIL Permission");
+            return 0;
+        }
+
+        Cursor cursor = null;
+        try {
+            cursor = resolver.query(EMAILS_CONTENT_URI, new String[] {"unreadCount"},
+                    "type = ?", new String[] {"0"}, null);
+            if(cursor != null) {
+                while (cursor.moveToNext()) {
+                    unRead = cursor.getInt(0);
+                    if (unRead > 0) {
+                        unreadEmail += unRead;
+                    }
+                }
+            }
+        } catch (Exception e) {
+            // TODO: handle exception
+            LogUtils.d(TAG, "readUnreadCount Exception: "+ e);
+        } finally {
+            UtilitiesExt.closeCursorSilently(cursor);
+        }
+
+        if(LogUtils.DEBUG_UNREAD) LogUtils.d(TAG, "readUnreadCount: unreadEmail = " + unreadEmail);
+
+        return unreadEmail;
+    }
+
+    @Override
+    public String getUnreadHintString() {
+        String name = mContext.getString(R.string.unread_email);
+        return mContext.getString(R.string.unread_hint, name);
+    }
+
+    @Override
+    public ArrayList<String> loadApps(Context context) {
+        String[] emailLists = context.getResources().getStringArray(R.array.support_email_component_array);
+
+        ArrayList<String> installEmailList = new ArrayList<>();
+        for (String emailList : emailLists) {
+            ComponentName componentName = ComponentName.unflattenFromString( emailList );
+            boolean isInstalled = UtilitiesExt.isAppInstalled(context, componentName);
+            if (isInstalled) {
+                installEmailList.add(componentName.flattenToShortString());
+            }
+        }
+
+        return installEmailList;
+    }
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/email/EmailPreference.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/email/EmailPreference.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/email/EmailPreference.java	(revision 173368)
@@ -0,0 +1,38 @@
+package com.sprd.ext.unreadnotifier.email;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+
+import com.sprd.ext.unreadnotifier.AppListPreference;
+import com.sprd.ext.unreadnotifier.UnreadInfoManager;
+
+import java.util.ArrayList;
+
+/**
+ * Created by SPRD on 1/25/17.
+ */
+
+public class EmailPreference extends AppListPreference {
+    public EmailPreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        item = UnreadInfoManager.getInstance(context).getItemByType(UnreadInfoManager.TYPE_EMAIL);
+        if (item != null) {
+            isPermissionGranted = item.checkPermission();
+            initState = item.isPersistChecked();
+
+            //get initValue before verifyDefaultCN
+            initValue = item.readSavedValues();
+
+            ArrayList<String> listValues = item.loadApps(item.mContext);
+            item.setInstalledList(listValues);
+            item.verifyDefaultCN(listValues, UnreadEmailItem.DEFAULT_CNAME);
+
+            String pkgName = TextUtils.isEmpty(item.mCurrentCn) ? null
+                    : ComponentName.unflattenFromString(item.mCurrentCn).getPackageName();
+            setListValues(listValues, pkgName);
+        }
+    }
+
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/UnreadBaseItem.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/UnreadBaseItem.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/UnreadBaseItem.java	(revision 173368)
@@ -0,0 +1,170 @@
+package com.sprd.ext.unreadnotifier;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.pm.PackageManager;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.preference.PreferenceManager;
+import android.text.TextUtils;
+
+import java.util.ArrayList;
+
+/**
+ * Created by SPRD on 2016/11/22.
+ */
+
+public abstract class UnreadBaseItem {
+    protected int mType;
+    private int mUnreadCount;
+    protected BaseContentObserver mContentObserver;
+    protected String mPermission;
+    protected String mPrefKey;
+    public Context mContext;
+    protected ComponentName mDefaultCn;
+    protected boolean mDefaultState;
+
+    public String mCurrentCn = "";
+    ArrayList<String> mInstalledList = new ArrayList<>();
+
+    public UnreadBaseItem(Context context) {
+        mContext = context;
+    }
+
+    public boolean checkPermission() {
+        boolean isChecked = true;
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+            isChecked = mContext.checkSelfPermission(mPermission) == PackageManager.PERMISSION_GRANTED;
+        }
+        return isChecked;
+    }
+
+    public boolean isPersistChecked() {
+        return AppListPreference.isPreferenceChecked(mContext, mPrefKey, mDefaultState);
+    }
+
+    /**
+     * Send broadcast to update the unread info.
+     */
+    void updateUIFromDatabase() {
+        new AsyncTask<Void, Void, Integer>() {
+            @Override
+            protected Integer doInBackground(Void... params) {
+                return readUnreadCount();
+            }
+
+            @Override
+            protected void onPostExecute(Integer unReadNum) {
+                setUnreadCount(unReadNum);
+                UnreadInfoManager.updateUI(mContext, mCurrentCn);
+            }
+        }.execute();
+
+    }
+
+    ComponentName getCurrentComponentName() {
+        ComponentName componentName = null;
+        String value = readSavedValues();
+        if (!TextUtils.isEmpty(value)) {
+            componentName = ComponentName.unflattenFromString(value);
+        }
+
+        return componentName;
+    }
+
+    void setUnreadCount(int num) {
+        if (num >= 0) {
+            mUnreadCount = num;
+        }
+    }
+
+    int getUnreadCount() {
+        return mUnreadCount;
+    }
+
+    public String readSavedValues() {
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
+        return sp.getString(mPrefKey, "");
+    }
+
+    private void saveValues(String value) {
+        SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(mContext).edit();
+        editor.putString(mPrefKey, value);
+        editor.apply();
+    }
+
+    public void verifyDefaultCN(final ArrayList<String> installedList, final ComponentName defCn) {
+        if (installedList.size() == 0) {
+            return;
+        }
+
+        String savedValue = readSavedValues();
+
+        int N = installedList.size();
+        String cN = null;
+
+        if (N == 1) {
+            cN = installedList.get(0);
+            mCurrentCn = cN;
+            if (!cN.equals(savedValue)) {
+                saveValues(cN);
+            }
+        } else {
+            String defaultCn = null;
+            if(defCn != null) {
+                defaultCn = defCn.flattenToShortString();
+            }
+
+            boolean isSavedValueEmpty = TextUtils.isEmpty(savedValue);
+            boolean isDefaultCNEmpty = TextUtils.isEmpty(defaultCn);
+
+            boolean isSavedValueFound = false;
+            boolean isDefaultCNFound = false;
+            for (String cName: installedList) {
+                //if the default app value is existed
+                if(!isDefaultCNEmpty && !isDefaultCNFound) {
+                    if (cName.equals(defaultCn)) {
+                        cN = defaultCn;
+                        isDefaultCNFound = true;
+                    }
+                }
+
+                //if the current app value is existed
+                if(!isSavedValueEmpty && !isSavedValueFound) {
+                    if (cName.equals(savedValue)) {
+                        isSavedValueFound = true;
+                    }
+                }
+
+            }
+
+            if (isDefaultCNFound) {
+                if(isSavedValueEmpty || !isSavedValueFound) {
+                    mCurrentCn = cN;
+                    saveValues(mCurrentCn);
+                } else {
+                    mCurrentCn = savedValue;
+                }
+            } else {
+                if (isSavedValueEmpty || !isSavedValueFound) {
+                    mCurrentCn = "";
+                    saveValues(mCurrentCn);
+                } else {
+                    mCurrentCn = savedValue;
+                }
+            }
+        }
+    }
+
+    public void setInstalledList(ArrayList<String> list) {
+        mInstalledList = list;
+    }
+
+    public abstract int readUnreadCount();
+
+    public abstract String getUnreadHintString();
+
+    public abstract ArrayList<String> loadApps(Context context);
+
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/calendar/UnreadCalendarItem.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/calendar/UnreadCalendarItem.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/calendar/UnreadCalendarItem.java	(revision 173368)
@@ -0,0 +1,120 @@
+package com.sprd.ext.unreadnotifier.calendar;
+
+import android.Manifest;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.SystemProperties;
+import android.provider.CalendarContract;
+import android.provider.CalendarContract.CalendarAlerts;
+
+import com.android.launcher3.R;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.UtilitiesExt;
+import com.sprd.ext.unreadnotifier.BaseContentObserver;
+import com.sprd.ext.unreadnotifier.UnreadBaseItem;
+import com.sprd.ext.unreadnotifier.UnreadInfoManager;
+import com.sprd.ext.unreadnotifier.UnreadSettingsFragment;
+
+import java.util.ArrayList;
+
+/**
+ * Created by SPRD on 2/8/17.
+ */
+
+public class UnreadCalendarItem extends UnreadBaseItem{
+    private static final String TAG = "UnreadCalendarItem";
+    private static final Uri CALENDARS_CONTENT_URI = CalendarContract.CalendarAlerts.CONTENT_URI;
+
+    static final ComponentName DEFAULT_CNAME = new ComponentName("com.android.calendar",
+            "com.android.calendar.AllInOneActivity");
+
+    private static final String PROP_DEFAULT_CALENDAR = "ro.launcher.unread.calendar";
+
+    public UnreadCalendarItem(Context context) {
+        super(context);
+        mContentObserver = new BaseContentObserver(new Handler(), context, CALENDARS_CONTENT_URI, this);
+        mPermission = Manifest.permission.READ_CALENDAR;
+        mPrefKey = UnreadSettingsFragment.PREF_KEY_UNREAD_CALENDAR;
+        mDefaultCn = DEFAULT_CNAME;
+        mType = UnreadInfoManager.TYPE_CALENDAR;
+        boolean defaultState = mContext.getResources().getBoolean(R.bool.config_default_unread_calendar_enable);
+        mDefaultState =  SystemProperties.getBoolean(PROP_DEFAULT_CALENDAR, defaultState);
+    }
+
+    @Override
+    public int readUnreadCount() {
+        String[] ALERT_PROJECTION = new String[] { CalendarAlerts._ID, // 0
+                CalendarAlerts.EVENT_ID, // 1
+                CalendarAlerts.STATE, // 2
+                CalendarAlerts.TITLE, // 3
+                CalendarAlerts.EVENT_LOCATION, // 4
+                CalendarAlerts.SELF_ATTENDEE_STATUS, // 5
+                CalendarAlerts.ALL_DAY, // 6
+                CalendarAlerts.ALARM_TIME, // 7
+                CalendarAlerts.MINUTES, // 8
+                CalendarAlerts.BEGIN, // 9
+                CalendarAlerts.END, // 10
+                CalendarAlerts.DESCRIPTION, // 11
+        };
+        int unreadEvents = 0;
+
+        boolean result = checkPermission();
+        if (!result) {
+            LogUtils.w(TAG, "no READ_CALENDAR Permission");
+            return 0;
+        }
+        ContentResolver resolver = mContext.getContentResolver();
+        Cursor alertCursor = null;
+        try {
+            alertCursor= resolver
+                    .query(CALENDARS_CONTENT_URI,
+                            ALERT_PROJECTION,
+                            ("(" + CalendarAlerts.STATE + "=? OR "
+                                    + CalendarAlerts.STATE + "=?) AND "
+                                    + CalendarAlerts.ALARM_TIME + "<=" + System
+                                    .currentTimeMillis()),
+                            new String[] {
+                                    Integer.toString(CalendarAlerts.STATE_FIRED),
+                                    Integer.toString(CalendarAlerts.STATE_SCHEDULED) },
+                            "begin DESC, end DESC");
+            if(alertCursor != null) {
+                unreadEvents = alertCursor.getCount();
+            }
+        } catch (Exception e) {
+            // TODO: handle exception
+            LogUtils.d(TAG, "readUnreadCount Exception: "+ e);
+        } finally {
+            UtilitiesExt.closeCursorSilently(alertCursor);
+        }
+
+        if(LogUtils.DEBUG_UNREAD) LogUtils.d(TAG, "readUnreadCount, unread Calendar num = "+unreadEvents);
+
+        return unreadEvents;
+    }
+
+    @Override
+    public String getUnreadHintString() {
+        String name = mContext.getString(R.string.unread_calendar);
+        return mContext.getString(R.string.unread_hint, name);
+    }
+
+    @Override
+    public ArrayList<String> loadApps(Context context) {
+        String[] calLists = context.getResources().getStringArray(R.array.support_calendar_component_array);
+
+        ArrayList<String> installedCalendarList = new ArrayList<>();
+        for (String calList : calLists) {
+            ComponentName componentName = ComponentName.unflattenFromString( calList );
+            boolean isInstalled = UtilitiesExt.isAppInstalled(context, componentName );
+            if (isInstalled) {
+                installedCalendarList.add(componentName.flattenToShortString());
+            }
+        }
+
+        return installedCalendarList;
+    }
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/calendar/CalendarPreference.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/calendar/CalendarPreference.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/calendar/CalendarPreference.java	(revision 173368)
@@ -0,0 +1,39 @@
+package com.sprd.ext.unreadnotifier.calendar;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+
+import com.sprd.ext.unreadnotifier.AppListPreference;
+import com.sprd.ext.unreadnotifier.UnreadInfoManager;
+
+import java.util.ArrayList;
+
+/**
+ * Created by SPRD on 2/8/17.
+ */
+
+public class CalendarPreference extends AppListPreference{
+    public CalendarPreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        item = UnreadInfoManager.getInstance(context).getItemByType(UnreadInfoManager.TYPE_CALENDAR);
+
+        if (item != null) {
+            isPermissionGranted = item.checkPermission();
+            initState = item.isPersistChecked();
+
+            //get initValue before verifyDefaultCN
+            initValue = item.readSavedValues();
+
+            ArrayList<String> listValues = item.loadApps(item.mContext);
+            item.setInstalledList(listValues);
+            item.verifyDefaultCN(listValues, UnreadCalendarItem.DEFAULT_CNAME);
+
+            String pkgName = TextUtils.isEmpty(item.mCurrentCn) ? null
+                    : ComponentName.unflattenFromString(item.mCurrentCn).getPackageName();
+            setListValues(listValues, pkgName);
+        }
+    }
+
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/AppListPreference.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/AppListPreference.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/AppListPreference.java	(revision 173368)
@@ -0,0 +1,207 @@
+package com.sprd.ext.unreadnotifier;
+
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+import android.preference.ListPreference;
+import android.preference.Preference;
+import android.preference.PreferenceManager;
+import android.support.annotation.NonNull;
+import android.util.AttributeSet;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.CheckBox;
+import android.widget.ImageView;
+import android.widget.ListAdapter;
+import android.widget.TextView;
+
+import com.android.launcher3.R;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by SPRD on 10/20/16.
+ */
+
+public class AppListPreference extends ListPreference {
+    private static final String ITEM_NONE_VALUE = "";
+    private Drawable[] mEntryDrawables;
+    private boolean mShowItemNone = false;
+    private OnPreferenceCheckBoxClickListener mCheckBoxListener;
+
+    private CheckBox mCheckBox;
+    private static final String CHECKBOX_KEY = "_checked";
+
+    protected boolean isPermissionGranted;
+    protected boolean initState;
+    protected String initValue;
+    public UnreadBaseItem item;
+
+
+    interface OnPreferenceCheckBoxClickListener {
+        /**
+         * Called when a view has been clicked.
+         *
+         * @param preference The view that was clicked.
+         */
+        void onPreferenceCheckboxClick(Preference preference);
+    }
+
+
+
+    private class AppArrayAdapter extends ArrayAdapter<CharSequence> {
+        private Drawable[] mImageDrawables = null;
+        private int mSelectedIndex = 0;
+        AppArrayAdapter(Context context, int textViewResourceId,
+                        CharSequence[] objects, Drawable[] imageDrawables, int selectedIndex) {
+            super(context, textViewResourceId, objects);
+            mSelectedIndex = selectedIndex;
+            mImageDrawables = imageDrawables;
+        }
+
+        @NonNull
+        @Override
+        public View getView(int position, View convertView, @NonNull ViewGroup parent) {
+            ViewHolders viewHolder = null;
+            if (convertView == null || convertView.getTag() == null) {
+                LayoutInflater inflater = ((Activity)getContext()).getLayoutInflater();
+                convertView = inflater.inflate(R.layout.app_preference_item, null);
+                viewHolder =  new ViewHolders();
+                viewHolder.m_iv = (ImageView) convertView.findViewById(R.id.app_image);
+                viewHolder.m_tv = (TextView) convertView.findViewById(R.id.app_label);
+                viewHolder.m_tv_select = (TextView) convertView.findViewById(R.id.select_label);
+                convertView.setTag(viewHolder);
+            } else {
+                viewHolder = (ViewHolders) convertView.getTag();
+            }
+
+            viewHolder.m_tv.setText(getItem(position));
+            if (position == mSelectedIndex) {
+                viewHolder.m_tv_select.setVisibility(View.VISIBLE);
+            }
+            viewHolder.m_iv.setImageDrawable(mImageDrawables[position]);
+            return convertView;
+        }
+    }
+
+    private class ViewHolders {
+        ImageView m_iv;
+        TextView m_tv;
+        TextView m_tv_select;
+    }
+
+
+    public AppListPreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        setWidgetLayoutResource(R.layout.listpref_widget_checkbox);
+    }
+
+    public void setShowItemNone(boolean showItemNone) {
+        mShowItemNone = showItemNone;
+    }
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    protected void setListValues(ArrayList<String> listValues, String defaultPackageName) {
+        // Look up all package names in PackageManager. Skip ones we can't find.
+        PackageManager pm = getContext().getPackageManager();
+        final int entryCount = listValues.size() + (mShowItemNone ? 1 : 0);
+        List<CharSequence> applicationNames = new ArrayList<>(entryCount);
+        List<CharSequence> validatedNames = new ArrayList<>(entryCount);
+        List<Drawable> entryDrawables = new ArrayList<>(entryCount);
+        int selectedIndex = -1;
+        for (int i = 0; i < listValues.size(); i++) {
+            try {
+                String listValue = listValues.get(i);
+                String packageName = listValue.substring(0, listValue.indexOf("/"));
+                ApplicationInfo appInfo = pm.getApplicationInfo(packageName, 0);
+                applicationNames.add(appInfo.loadLabel(pm));
+                validatedNames.add(listValues.get(i));
+                entryDrawables.add(appInfo.loadIcon(pm));
+                if (defaultPackageName != null &&
+                        appInfo.packageName.contentEquals(defaultPackageName)) {
+                    selectedIndex = i;
+                }
+            } catch (PackageManager.NameNotFoundException e) {
+                // Skip unknown packages.
+            }
+        }
+        if (mShowItemNone) {
+            applicationNames.add(getContext().getResources().getText(R.string.app_list_preference_none));
+            validatedNames.add(ITEM_NONE_VALUE);
+            entryDrawables.add(getContext().getDrawable(R.drawable.ic_remove_circle));
+        }
+        setEntries(applicationNames.toArray(new CharSequence[applicationNames.size()]));
+        setEntryValues(
+                validatedNames.toArray(new CharSequence[validatedNames.size()]));
+        mEntryDrawables = entryDrawables.toArray(new Drawable[entryDrawables.size()]);
+
+        if (selectedIndex != -1) {
+            setValueIndex(selectedIndex);
+        } else {
+            setValue(null);
+        }
+    }
+
+    private ListAdapter createListAdapter() {
+        final String selectedValue = getValue();
+        final boolean selectedNone = selectedValue == null ||
+                (mShowItemNone && selectedValue.contentEquals(ITEM_NONE_VALUE));
+        int selectedIndex = selectedNone ? -1 : findIndexOfValue(selectedValue);
+
+        return new AppArrayAdapter(getContext(),
+                R.layout.app_preference_item, getEntries(), mEntryDrawables, selectedIndex);
+    }
+
+    @Override
+    protected void onBindView(View view) {
+        super.onBindView(view);
+        mCheckBox = (CheckBox) view.findViewById(R.id.checkbox);
+        mCheckBox.setChecked(isPreferenceChecked(getContext(),getKey(),false));
+
+        mCheckBox.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                setPreferenceChecked(mCheckBox.isChecked());
+                if(mCheckBoxListener != null){
+                    mCheckBoxListener.onPreferenceCheckboxClick(AppListPreference.this);
+                }
+
+            }
+        });
+    }
+
+    void setOnPreferenceCheckBoxClickListener(OnPreferenceCheckBoxClickListener l){
+        mCheckBoxListener = l;
+    }
+
+    void setPreferenceChecked(boolean bool){
+        SharedPreferences sharePref = PreferenceManager.getDefaultSharedPreferences(getContext());
+        SharedPreferences.Editor editor = sharePref.edit();
+        editor.putBoolean(getKey()+CHECKBOX_KEY, bool).apply();
+        if(mCheckBox != null && mCheckBox.isChecked() != bool){
+            mCheckBox.setChecked(bool);
+        }
+    }
+
+    static boolean isPreferenceChecked(Context context, String prefKey, boolean defValue) {
+        SharedPreferences sharePref = PreferenceManager.getDefaultSharedPreferences(context);
+        return sharePref.getBoolean(prefKey + CHECKBOX_KEY, defValue);
+    }
+
+    @Override
+    protected void onPrepareDialogBuilder(AlertDialog.Builder builder) {
+        builder.setAdapter(createListAdapter(), this);
+        super.onPrepareDialogBuilder(builder);
+    }
+
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/UnreadActivity.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/UnreadActivity.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/UnreadActivity.java	(revision 173368)
@@ -0,0 +1,25 @@
+package com.sprd.ext.unreadnotifier;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.view.Menu;
+
+
+public class UnreadActivity extends Activity {
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        getFragmentManager().beginTransaction().replace(android.R.id.content, new UnreadSettingsFragment())
+                .commit();
+    }
+
+    public boolean onCreateOptionsMenu(Menu paramMenu)
+    {
+        return true;
+    }
+
+    protected void onDestroy()
+    {
+        super.onDestroy();
+    }
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/call/MissCallItem.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/call/MissCallItem.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/call/MissCallItem.java	(revision 173368)
@@ -0,0 +1,102 @@
+package com.sprd.ext.unreadnotifier.call;
+
+import android.Manifest;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.SystemProperties;
+import android.provider.BaseColumns;
+import android.provider.CallLog;
+
+import com.android.launcher3.R;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.UtilitiesExt;
+import com.sprd.ext.unreadnotifier.BaseContentObserver;
+import com.sprd.ext.unreadnotifier.CallAppUtils;
+import com.sprd.ext.unreadnotifier.UnreadBaseItem;
+import com.sprd.ext.unreadnotifier.UnreadInfoManager;
+import com.sprd.ext.unreadnotifier.UnreadSettingsFragment;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+/**
+ * Created by SPRD on 2016/11/22.
+ */
+
+public class MissCallItem extends UnreadBaseItem {
+    private static final String TAG = "MissCallItem";
+    private static final Uri CALLS_CONTENT_URI = CallLog.Calls.CONTENT_URI;
+    private static final String MISSED_CALLS_SELECTION =
+            CallLog.Calls.TYPE + " = " + CallLog.Calls.MISSED_TYPE + " AND " + CallLog.Calls.NEW + " = 1";
+
+    static final ComponentName DEFAULT_CNAME = new ComponentName("com.android.dialer",
+            "com.android.dialer.DialtactsActivity");
+
+    private static final String PROP_DEFAULT_CALL = "ro.launcher.unread.call";
+
+    public MissCallItem(Context context) {
+        super(context);
+        mContentObserver = new BaseContentObserver(new Handler(), context, CALLS_CONTENT_URI, this);
+        mPermission = Manifest.permission.READ_CALL_LOG;
+        mPrefKey = UnreadSettingsFragment.PREF_KEY_MISS_CALL;
+        mType = UnreadInfoManager.TYPE_CALL_LOG;
+        mDefaultCn = DEFAULT_CNAME;
+        boolean defaultState = mContext.getResources().getBoolean(R.bool.config_default_unread_call_enable);
+        mDefaultState = SystemProperties.getBoolean(PROP_DEFAULT_CALL, defaultState);
+    }
+
+    @Override
+    public int readUnreadCount() {
+        int missedCalls = 0;
+        ContentResolver resolver = mContext.getContentResolver();
+
+        boolean result = checkPermission();
+        if (!result) {
+            LogUtils.w(TAG, "no READ_CALL_LOG Permission");
+            return 0;
+        }
+
+        Cursor cursor = null;
+        try {
+            cursor = resolver.query(CALLS_CONTENT_URI, new String[]{BaseColumns._ID},
+                    MISSED_CALLS_SELECTION, null, null);
+            if(cursor != null) {
+                missedCalls = cursor.getCount();
+            }
+        } catch (Exception e) {
+            // TODO: handle exception
+            LogUtils.d(TAG, "readUnreadCount Exception: "+ e);
+        } finally {
+            UtilitiesExt.closeCursorSilently(cursor);
+        }
+
+        if(LogUtils.DEBUG_UNREAD) LogUtils.d(TAG, "readUnreadCount, missedCalls = "+missedCalls);
+
+        return missedCalls;
+    }
+
+    @Override
+    public String getUnreadHintString() {
+        String name = mContext.getString(R.string.unread_call);
+        return mContext.getString(R.string.unread_hint, name);
+    }
+
+    @Override
+    public ArrayList<String> loadApps(Context context) {
+        Collection<CallAppUtils.CallApplicationData> callApplications =
+                CallAppUtils.getInstalledDialerApplications(context);
+
+        ArrayList<String> installedPhoneList = new ArrayList<>();
+        for (CallAppUtils.CallApplicationData callApplication : callApplications) {
+            ComponentName componentName = new ComponentName(callApplication.mPackageName, callApplication.callClassName);
+            String scName = componentName.flattenToShortString();
+            installedPhoneList.add(scName);
+        }
+
+        return installedPhoneList;
+    }
+}
\ No newline at end of file
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/call/DefaultPhonePreference.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/call/DefaultPhonePreference.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/call/DefaultPhonePreference.java	(revision 173368)
@@ -0,0 +1,37 @@
+package com.sprd.ext.unreadnotifier.call;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+
+import com.sprd.ext.unreadnotifier.AppListPreference;
+import com.sprd.ext.unreadnotifier.UnreadInfoManager;
+
+import java.util.ArrayList;
+
+/**
+ * Created by SPRD on 10/20/16.
+ */
+public class DefaultPhonePreference extends AppListPreference {
+    public DefaultPhonePreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        item = UnreadInfoManager.getInstance(context).getItemByType(UnreadInfoManager.TYPE_CALL_LOG);
+        if (item != null) {
+            isPermissionGranted = item.checkPermission();
+            initState = item.isPersistChecked();
+
+            //get initValue before verifyDefaultCN
+            initValue = item.readSavedValues();
+
+            ArrayList<String> listValues = item.loadApps(item.mContext);
+            item.setInstalledList(listValues);
+            item.verifyDefaultCN(listValues, MissCallItem.DEFAULT_CNAME);
+
+            String pkgName = TextUtils.isEmpty(item.mCurrentCn) ? null
+                    : ComponentName.unflattenFromString(item.mCurrentCn).getPackageName();
+            setListValues(listValues, pkgName);
+        }
+    }
+
+}
\ No newline at end of file
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/BaseContentObserver.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/BaseContentObserver.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/BaseContentObserver.java	(revision 173368)
@@ -0,0 +1,46 @@
+package com.sprd.ext.unreadnotifier;
+
+import android.content.Context;
+import android.database.ContentObserver;
+import android.net.Uri;
+import android.os.Handler;
+
+import com.sprd.ext.LogUtils;
+
+/**
+ * Created by SPRD on 2016/11/23.
+ */
+
+public class BaseContentObserver extends ContentObserver {
+    private static final String TAG = "BaseContentObserver";
+    private Uri mUri;
+    private Context mContext;
+    private UnreadBaseItem mItem;
+
+    public BaseContentObserver(Handler handler,Context context,Uri uri, UnreadBaseItem item) {
+        super(handler);
+        mContext = context;
+        mUri = uri;
+        mItem = item;
+    }
+
+    void registerContentObserver() {
+        mContext.getContentResolver().registerContentObserver(mUri, true, this);
+    }
+
+    void unregisterContentObserver() {
+        mContext.getContentResolver().unregisterContentObserver(this);
+    }
+
+    @Override
+    public void onChange(boolean selfChange, Uri uri) {
+        super.onChange(selfChange, uri);
+        if(LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, String.format("onChange: uri=%s selfChange=%b", uri.toString(), selfChange));
+        }
+        if (mItem != null) {
+            mItem.updateUIFromDatabase();
+        }
+    }
+
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/CallAppUtils.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/CallAppUtils.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/CallAppUtils.java	(revision 173368)
@@ -0,0 +1,91 @@
+package com.sprd.ext.unreadnotifier;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.os.Build;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * Created by SPRD on 10/16/16.
+ */
+public class CallAppUtils {
+    public static class CallApplicationData {
+        /**
+         * Name of this SMS app for display.
+         */
+        public String mApplicationName;
+
+        /**
+         * Package name for this SMS app.
+         */
+        public String mPackageName;
+
+        /**
+         * Activity class name for this SMS app.
+         */
+        public String callClassName;
+
+        public CallApplicationData(String applicationName, String packageName) {
+            mApplicationName = applicationName;
+            mPackageName = packageName;
+        }
+    }
+
+    /**
+     * Returns a list of installed and available dialer applications.
+     **/
+    @TargetApi(Build.VERSION_CODES.M)
+    public static Collection<CallApplicationData> getInstalledDialerApplications(Context context) {
+        PackageManager packageManager = context.getPackageManager();
+
+        // Get the list of apps registered for the DIAL intent with empty scheme
+        Intent intent = new Intent(Intent.ACTION_DIAL);
+        List<ResolveInfo> resolveInfoList = packageManager.queryIntentActivities(intent, 0);
+
+        List<String> callPackageNames = new ArrayList<>();
+
+        for (ResolveInfo resolveInfo : resolveInfoList) {
+            final ActivityInfo activityInfo = resolveInfo.activityInfo;
+            if (activityInfo != null && !callPackageNames.contains(activityInfo.packageName)) {
+                callPackageNames.add(activityInfo.packageName);
+            }
+        }
+
+        Intent intentAll = new Intent(Intent.ACTION_MAIN);
+        intentAll.addCategory(Intent.CATEGORY_LAUNCHER);
+        List<ResolveInfo> allResolveInfoList = packageManager.queryIntentActivities(intentAll, 0);
+
+        HashMap<String, CallApplicationData> callActivityInfo = new HashMap<>();
+
+        // Add one entry to the map for every sms Application
+        for (ResolveInfo resolveInfo : allResolveInfoList) {
+            final ActivityInfo activityInfo = resolveInfo.activityInfo;
+            if (activityInfo == null) {
+                continue;
+            }
+            final String packageName = activityInfo.packageName;
+
+            if(callPackageNames.contains(packageName)) {
+
+                if (!callActivityInfo.containsKey(packageName)) {
+                    final String applicationName = resolveInfo.loadLabel(packageManager).toString();
+                    final CallApplicationData callApplicationData = new CallApplicationData(
+                            applicationName, packageName);
+                    callApplicationData.callClassName = activityInfo.name;
+                    callActivityInfo.put(packageName, callApplicationData);
+                }
+            }
+        }
+
+        return callActivityInfo.values();
+    }
+
+}
Index: packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/MMSAppUtils.java
===================================================================
--- packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/MMSAppUtils.java	(revision 0)
+++ packages/apps/Launcher3/ext/src/com/sprd/ext/unreadnotifier/MMSAppUtils.java	(revision 173368)
@@ -0,0 +1,114 @@
+package com.sprd.ext.unreadnotifier;
+
+import android.Manifest;
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.os.Binder;
+import android.os.Build;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * Created by SPRD on 10/16/16.
+ */
+
+public class MMSAppUtils {
+    public static class SmsApplicationData {
+        /**
+         * Name of this SMS app for display.
+         */
+        public String mApplicationName;
+
+        /**
+         * Package name for this SMS app.
+         */
+        public String mPackageName;
+
+        /**
+         * Activity class name for this SMS app.
+         */
+        public String smsClassName;
+
+        public SmsApplicationData(String applicationName, String packageName) {
+            mApplicationName = applicationName;
+            mPackageName = packageName;
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    private static Collection<SmsApplicationData> getApplicationCollectionInternal(
+            Context context) {
+        PackageManager packageManager = context.getPackageManager();
+
+        // Get the list of apps registered for SMS
+        Intent smsIntent = new Intent("android.provider.Telephony.SMS_DELIVER");
+        List<ResolveInfo> smsReceivers = packageManager.queryBroadcastReceivers(smsIntent, 0);
+
+        // Get package names for all SMS apps
+        List<String> smsPackageNames = new ArrayList<>();
+
+        for (ResolveInfo resolveInfo : smsReceivers) {
+            final ActivityInfo activityInfo = resolveInfo.activityInfo;
+            if (activityInfo == null) {
+                continue;
+            }
+            if (!Manifest.permission.BROADCAST_SMS.equals(activityInfo.permission)) {
+                continue;
+            }
+            if (!smsPackageNames.contains(activityInfo.packageName)) {
+                smsPackageNames.add(activityInfo.packageName);
+            }
+        }
+
+        Intent intent = new Intent(Intent.ACTION_MAIN);
+        intent.addCategory(Intent.CATEGORY_LAUNCHER);
+        List<ResolveInfo> allResolveInfoList = packageManager.queryIntentActivities(intent, 0);
+
+        HashMap<String, SmsApplicationData> smsActivityInfo = new HashMap<>();
+
+        // Add one entry to the map for every sms Application
+        for (ResolveInfo resolveInfo : allResolveInfoList) {
+            final ActivityInfo activityInfo = resolveInfo.activityInfo;
+            if (activityInfo == null) {
+                continue;
+            }
+            final String packageName = activityInfo.packageName;
+
+            if(smsPackageNames.contains(packageName)) {
+
+                if (!smsActivityInfo.containsKey(packageName)) {
+                    final String applicationName = resolveInfo.loadLabel(packageManager).toString();
+                    final SmsApplicationData smsApplicationData = new SmsApplicationData(
+                            applicationName, packageName);
+                    smsApplicationData.smsClassName = activityInfo.name;
+                    smsActivityInfo.put(packageName, smsApplicationData);
+                }
+            }
+
+        }
+
+        return smsActivityInfo.values();
+    }
+
+    /**
+     * Returns the list of available SMS apps defined as apps that are registered for both the
+     * SMS_RECEIVED_ACTION (SMS) and WAP_PUSH_RECEIVED_ACTION (MMS) broadcasts (and their broadcast
+     * receivers are enabled)
+     *
+     */
+    public static Collection<SmsApplicationData> getApplicationCollection(Context context) {
+        final long token = Binder.clearCallingIdentity();
+        try {
+            return getApplicationCollectionInternal(context);
+        } finally {
+            Binder.restoreCallingIdentity(token);
+        }
+    }
+}
Index: packages/apps/Launcher3/ext/res/values-tr/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-tr/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-tr/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Geçmek için sallayın" </string>
+    <string name="shake_to_switch_summary">"Kilit ekranında değilken bir sonraki veya bir önceki duvar kağıdına geçmek için cihazı sallayın"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-lo-rLA/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-lo-rLA/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-lo-rLA/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"ສັ່ນ​ເພື່ອ​ປ່ຽນ"</string>
+    <string name="shake_to_switch_summary">"ເມື່ອ​ໜ້າ​ຈໍ​ບໍ່​ໄດ້​ລ໊ອກສັ່ນ​ໂທ​ລະ​ສັບ​ຊ້າຍ​ຂວາ​ເພື່ອ​ປ່ຽນ​ວໍ​ເປ​ເປີ "</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/drawable-xxhdpi/ic_calendar_plate.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-xxhdpi/ic_calendar_plate.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-xxhdpi/ic_calendar_plate.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-xxhdpi/ic_calendar_plate.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-xxhdpi/ic_calendar_plate.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/drawable-xxhdpi/ic_dial_plate.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-xxhdpi/ic_dial_plate.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-xxhdpi/ic_dial_plate.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-xxhdpi/ic_dial_plate.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-xxhdpi/ic_dial_plate.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/drawable-xxhdpi/ic_dial_plate_original.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-xxhdpi/ic_dial_plate_original.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-xxhdpi/ic_dial_plate_original.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-xxhdpi/ic_dial_plate_original.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-xxhdpi/ic_dial_plate_original.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/values-gl-rES/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-gl-rES/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-gl-rES/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Axitar o interruptor"</string>
+    <string name="shake_to_switch_summary">"Axitar o dispositivo para cambiar o seguinte ou anterior muro cando a pantalla non está bloqueada"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-mai-rIN/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-mai-rIN/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-mai-rIN/strings.xml	(revision 173368)
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="unread_notifier_title">"बिना पढल छाप"</string>
+    <string name="unread_call">"फोन"</string>
+    <string name="unread_sms">"SMS"</string>
+    <string name="unread_email">"ई मेल"</string>
+    <string name="unread_calendar">"दिनक जानकारी देअ बला"</string>
+    <string name="unread_hint">"विफल चाह <xliff:g id="unread_type">%1$s</xliff:g> अनुमति, कृपाकय पहिने अनुमति लागू करू।"</string>
+    <string name="app_list_preference_none">"कृपाकय एकटा एपक चयन करू"</string>
+    <string name="pref_missed_call_count_title">"हरेलाह काॅल्स"</string>
+    <string name="pref_missed_call_count_summary">"एकटा फोनक एप चयन करू, एहि पर छुटल काँलक संख्या सब केर प्रदर्शित करू"</string>
+    <string name="pref_unread_sms_count_title">"बिन पढल संदेश"</string>
+    <string name="pref_unread_sms_count_summary">"एकटा SMS एपक चयन करू, एहि पर बिन पढल संदेशक सँख्या सभक प्रदर्शन करू"</string>
+    <string name="pref_unread_email_count_title">"बिना पढल इ-मेल"</string>
+    <string name="pref_unread_email_count_summary">"एकटा इ-मेल एपक चयन करू, एहि पर बिना पढल इ-मेल सँख्या प्रदर्शन करू"</string>
+    <string name="pref_unread_calendar_count_title">"बिन पढल पंचाँग"</string>
+    <string name="pref_unread_calendar_count_summary">"एकटा पंचांगक एपक चयन करू, एहि पर बिना पढल पंचांगक घटना सब केर प्रदर्शित करू"</string>
+    <string name="selected_text">"चुनाय गेल"</string>
+    <string name="dynamic_icon_title">"गतिशील आइकन"</string>
+    <string name="allow_circular_sliding_title">"डेस्कटापक चकरी"</string>
+    <string name="shake_to_switch">"बदलबाक लेल हिलाऊ"</string>
+    <string name="shake_to_switch_summary">"अगला वा पहिलका वाल पेपर पर जेवाक लेल उपकरण केर हिलाऊ जहन मुख्य स्क्रीनमे जाइत होइक।"</string>
+    <string name="folder_default_name">"पोथी बला फोल्डर"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-am/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-am/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-am/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"ለመቀየር ይነቅንቁ"</string>
+    <string name="shake_to_switch_summary">"መመልከቻው ባልተቆለፈ ግዜ ወደሚቀጥለው ወይም ወደቀደመው ልጣፍ ለመቀየር መሳሪያውን ይነቅንቁ"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-kn-rIN/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-kn-rIN/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-kn-rIN/strings.xml	(revision 173368)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"ಬದಲಿಸಲು ಅಲುಗಿಸಿ"</string>
+    <string name="shake_to_switch_summary">"ಲಾಕ್ ಸ್ಕ್ರೀನ್ ಇಲ್ಲದಿರುವಾಗ ಹಿಂದಿನ ಅಥವಾ ಮುಂದಿನ ವಾಲ್ ಪೇಪರ್ ಬದಲಿಸಲು ಸಾಧನವನ್ನು ಅಲುಗಿಸಿ"</string>
+    <string name="dynamic_icon_title">"ಡೈನಮಿಕ್ ಐಕಾನ್"</string>
+    <string name="dynamic_calendar">"ದಿನಚರಿ ಪುಸ್ತಕ"</string>
+    <string name="dynamic_clock">"ಗಡಿಯಾರ"</string>
+    <string name="allow_circular_sliding_title">ಡೆಸ್ಕ್ ಟಾಪ್ ಆವರ್ತನ</string>
+    <string name="folder_default_name">"ಕಡತಕೋಶ"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-ne-rNP/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-ne-rNP/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-ne-rNP/strings.xml	(revision 173368)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"परिवर्तन गर्न हल्लाउनुहोस्"</string>
+    <string name="shake_to_switch_summary">"लक स्क्रिन नहुँदा अर्को वा पछिल्लो वालपेपर परिवर्तन गर्न यन्त्रलाई हल्लाउनुहोस्"</string>
+    <string name="dynamic_icon_title">"डाइनामिक प्रतिमा"</string>
+    <string name="dynamic_calendar">"पात्रो"</string>
+    <string name="dynamic_clock">"घडी"</string>
+    <string name="allow_circular_sliding_title">"डेस्कटप चक्र"</string>
+    <string name="folder_default_name">"फोल्डर"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-sq-rAL/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-sq-rAL/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-sq-rAL/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Tundeni për ta ndryshuar"</string>
+    <string name="shake_to_switch_summary">"Tundeni pajisjen për të kaluar në figurën e murit tjetër ose të mëparshme kur nuk është në ekranin e kyçur"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-el/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-el/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-el/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Ανακινήστε για εναλλαγή"</string>
+    <string name="shake_to_switch_summary">"Ανακινήστε τη συσκευή για εναλλαγή σε επόμενη ή προηγούμενη ταπετσαρία όταν η οθόνη δεν είναι κλειδωμένη" </string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-doi-rIN/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-doi-rIN/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-doi-rIN/strings.xml	(revision 173368)
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="unread_notifier_title">"अनपढ़ेआ बैज"</string>
+    <string name="unread_call">"फोन"</string>
+    <string name="unread_sms">"एसएमएस"</string>
+    <string name="unread_email">"ईमेल"</string>
+    <string name="unread_calendar">"कलेंडर"</string>
+    <string name="unread_hint">"लापता <xliff:g id="unread_type">%1$s</xliff:g> मंजूरी लोड़चदा, किरपा करियै पैह्​ले मंजूरी देओ।"</string>
+    <string name="app_list_preference_none">"किरपा करियै ऐप चुनो।"</string>
+    <string name="pref_missed_call_count_title">"मिस्ड काल"</string>
+    <string name="pref_missed_call_count_summary">"फोन ऐप चुनो, उस पर मिस्ड काल नंबर प्रदर्शत करो"</string>
+    <string name="pref_unread_sms_count_title">"अनपढ़ेआ सनेहा"</string>
+    <string name="pref_unread_sms_count_summary">"SMS ऐप चुनो, उस पर अनपढ़े सनेह् दी संख्या प्रदर्शत करो"</string>
+    <string name="pref_unread_email_count_title">"अनपढ़ी ईमेल"</string>
+    <string name="pref_unread_email_count_summary">"ईमेल ऐप चुनो, उस पर अनपढ़े मेल नंबर प्रदर्शत करो"</string>
+    <string name="pref_unread_calendar_count_title">"अनपढ़ेआ कैलेंडर"</string>
+    <string name="pref_unread_calendar_count_summary">"कैलेंडर ऐप चुनो, उस पर अनपढ़े कैलेंडर ईवेंट प्रदर्शत करो"</string>
+    <string name="selected_text">"चोनमीं"</string>
+    <string name="dynamic_icon_title">"गतिशील आइकन"</string>
+    <string name="allow_circular_sliding_title">"डेस्कटाप साइकल"</string>
+    <string name="shake_to_switch">"स्विच करने लेई हलाओ"</string>
+    <string name="shake_to_switch_summary">"मुक्ख स्क्रीन च दाखल होंदे बेल्लै अगले जां पिछले वालपेपर पर स्विच करने लेई डिवाइस शेक करो"</string>
+    <string name="folder_default_name">"फ़ाइल फ़ोल्डर"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-gu-rIN/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-gu-rIN/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-gu-rIN/strings.xml	(revision 173368)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"બદલવા હલાવો"</string>
+    <string name="shake_to_switch_summary">"જયારે સ્ક્રીન બંધ ન હોય, ત્યારે પહેલા કે પછીનું વોલપેપર બદલવા ડીવાઈસ હલાવો" </string>
+    <string name="dynamic_icon_title">"ડાઈનામિક આઈકોન"</string>
+    <string name="dynamic_calendar">"કેલેન્ડર"</string>
+    <string name="dynamic_clock">ઘડિયાલ</string>
+    <string name="allow_circular_sliding_title">"ડેસ્કટોપ સાઈકલ"</string>
+    <string name="folder_default_name">ફોલ્ડર</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-ar/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-ar/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-ar/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"هز الجهاز للتشغيل"</string>
+    <string name="shake_to_switch_summary">"قم بهز الجهاز لتشغيل الخلفية التالية أو السابقة عند عدم قفل الشاشة"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-as/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-as/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-as/strings.xml	(revision 173368)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"ছুইচত জোকাৰি দিওক"</string>
+    <string name="shake_to_switch_summary">"যেতিয়া স্ক্ৰীণ লক না থাকে পৰবৰ্তী ছুইচৰ বাবে ডিভাইচটো জোকাৰ দিওক অথবা পূৰ্ববৰ্তী ওয়ালপেপাৰত"</string>
+    <string name="dynamic_icon_title">"ডায়নামিক আইকণ"</string>
+    <string name="dynamic_calendar">"কেলেণ্ডাৰ"</string>
+    <string name="dynamic_clock">"ঘড়ি"</string>
+    <string name="allow_circular_sliding_title">ডেস্কটপ চাইকল</string>
+    <string name="folder_default_name">"ফ’ল্ডাৰ"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-or-rIN/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-or-rIN/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-or-rIN/strings.xml	(revision 173368)
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="unread_notifier_title">"ପଢ଼ାହୋଇ ନ ଥିବା ବ୍ୟାଜ୍"</string>
+    <string name="unread_call">"ଫୋନ"</string>
+    <string name="unread_sms">"ଏସେମେସ"</string>
+    <string name="unread_email">"ଇମେଲ"</string>
+    <string name="unread_calendar">"କେଲେଣ୍ଡର"</string>
+    <string name="unread_hint">"ଆବଶ୍ୟକ <xliff:g id="unread_type">%1$s</xliff:g> ଅନୁମତି ନେଇପାରି ନାହାଁନ୍ତି, ଦୟାକରି ପ୍ରଥମେ ଅନୁମତି ପାଇଁ ଆବେଦନ କରନ୍ତୁ ।"</string>
+    <string name="app_list_preference_none">"ଦୟାକରି ଗୋଟିଏ ଆପ୍ ଚୟନ କରନ୍ତୁ ।"</string>
+    <string name="pref_missed_call_count_title">"ମିସ୍‌ଡ୍‌ କଲ୍‌"</string>
+    <string name="pref_missed_call_count_summary">"ଗୋଟିଏ ଫୋନ୍ ଆପ୍ ଚୟନ କରନ୍ତୁ, ମିସ୍ଡ କଲ୍ ର ନମ୍ବର ଏହା ଉପରେ ଡିସପ୍ଲେ କରନ୍ତୁ"</string>
+    <string name="pref_unread_sms_count_title">"ପଢ଼ାହୋଇ ନ ଥିବା ମେସେଜ୍"</string>
+    <string name="pref_unread_sms_count_summary">"ଏକ SMS ଆପ୍ ଚୟନ କରନ୍ତୁ, ପଢ଼ାହୋଇ ନ ଥିବା ମେସେଜ୍ ନମ୍ବର ଏହା ଉପରେ ଡିସପ୍ଲେ କରନ୍ତୁ"</string>
+    <string name="pref_unread_email_count_title">"ପଢ଼ାହୋଇ ନ ଥିବା ଇମେଲ୍"</string>
+    <string name="pref_unread_email_count_summary">"ଏକ ଇମେଲ୍ ଆପ୍ ଚୟନ କରନ୍ତୁ, ପଢ଼ାହୋଇ ନ ଥିବା ମେଲ୍ ଏହା ଉପରେ ପ୍ରଦର୍ଶନ କରନ୍ତୁ"</string>
+    <string name="pref_unread_calendar_count_title">"ପଢ଼ାହୋଇ ନ ଥିବା କ୍ୟାଲେଣ୍ଡର"</string>
+    <string name="pref_unread_calendar_count_summary">"ଏକ କ୍ୟାଲେଣ୍ଡର ଆପ୍ ଚୟନ କରନ୍ତୁ, ଏଥିରେ ପଢ଼ାହୋଇ ନ ଥିବା କ୍ୟାଲେଣ୍ଡର କାର୍ଯ୍ୟକ୍ରମଗୁଡ଼ିକ ପ୍ରଦର୍ଶିତ କରନ୍ତୁ"</string>
+    <string name="selected_text">"ସିଲେକ୍ଟ ହେଲା"</string>
+    <string name="dynamic_icon_title">"ଡାଇନାମିକ୍ ଆଇକନ୍"</string>
+    <string name="allow_circular_sliding_title">"ଡେସ୍କଟପ୍‍ ଚକ୍ର"</string>
+    <string name="shake_to_switch">"ସ୍ୱିଚ୍ କରିବା ପାଇଁ ହଲାନ୍ତୁ"</string>
+    <string name="shake_to_switch_summary">"ମେନ୍ ସ୍କ୍ରିନ୍ କୁ ପ୍ରବେଶ କରିବା ସମୟରେ ପରବର୍ତ୍ତୀ କିମ୍ବା ପୂର୍ବବର୍ତ୍ତୀ ୱାଲପେପର୍ କୁ ସ୍ୱିଚ୍ କରିବା ପାଇଁ ଡିଭାଇସ୍ କୁ ହଲାନ୍ତୁ"</string>
+    <string name="folder_default_name">"ଫାଇଲ୍ ଫୋଲ୍ଡର"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-in/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-in/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-in/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Kocok untuk mengganti"</string>
+    <string name="shake_to_switch_summary">"Kocok perangkat untuk mengganti gambar dinding sesudah atau sebelum ketika tidak mengunci layar"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-ug/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-ug/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-ug/strings.xml	(revision 173368)
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="allow_circular_sliding_title">"ئۈستەل يۈزى دەۋرىلىكى"</string>
+    <string name="shake_to_switch">"لىڭشىتىش ئارقىلىق تەگلىكنى ئۆزگەرتىش"</string>
+    <string name="shake_to_switch_summary">"ئاساسى ئېكرانغا كىرگەندە لىڭشىتىش ئارقىلىق كېيىنكى ياكى ئالدىنقى تەگلىككە ئۆزگەرتىش"</string>
+    <string name="unread_notifier_title">"ئوقۇلمىغان ماركا"</string>
+    <string name="unread_call">تېلېفون</string>
+    <string name="unread_sms">قىسقا ئۇچۇر</string>
+    <string name="unread_email">"Email"</string>
+    <string name="unread_calendar">كالېندار</string>
+    <string name="unread_hint">".ھوقۇق يوق، ئالدى بىلەن ھوقۇققا ئىلتىماس قىلىڭ<xliff:g id="unread_type">%1$s</xliff:g>تەلەپ قىلىنغان"</string>
+    <string name="app_list_preference_none">".بىر ئەپ تاللاڭ"</string>
+    <string name="pref_missed_call_count_title">يوقالغان تېلىفۇن</string>
+    <string name="pref_missed_call_count_summary">"ئالمىغان تېلىڧۇننىڭ سانىنى كۆرسىتىشكە بىر يانڧۇن ئەپى تاللاڭ"</string>
+    <string name="pref_unread_sms_count_title">"ئوقۇلمىغان ئۇچۇر"</string>
+    <string name="pref_unread_sms_count_summary">"ئوقۇلمىغان ئۇچۇر سانىنى كۆرسىتىشكە بىر قىسقا ئۇچۇر ئەپى تاللاڭ"</string>
+    <string name="pref_unread_email_count_title">"ئوقۇلمىغان ئېلخەت"</string>
+    <string name="pref_unread_email_count_summary">"ئوقۇلمىغان ئۇچۇر سانىنى كۆرسىتىشكە بىر ئېلىخەت ئەپى تاللاڭ"</string>
+    <string name="pref_unread_calendar_count_title">"ئوقۇلمىغان كالىندار"</string>
+    <string name="pref_unread_calendar_count_summary">"ئوقۇلمىغان كالىندار ۋەقەلىك سانىنى كۆرسىتىشكە بىر كالىندار ئەپى تاللاڭ"</string>
+    <string name="selected_text">"تاللاندى"</string>
+    <string name="dynamic_icon_title">"ھەرىكەتچان بەلگە"</string>
+    <string name="folder_default_name">"ھۆججەت پاپكىسى"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-it/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-it/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-it/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Agita per passare"</string>
+    <string name="shake_to_switch_summary">"Agita il dispositivo per passare al prossimo sfondo o al precedente quando non c’è il blocco schermo"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-iw/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-iw/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-iw/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">נערו כדי לשנות</string>
+    <string name="shake_to_switch_summary">נערו את המכשיר כדי לעבור לטפט הבא או הקודם כשאינכם במצב נעילת מסך</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-uk/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-uk/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-uk/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Струснути для перемикання"</string>
+    <string name="shake_to_switch_summary">"Струсніть пристрій для переходу до наступних або попереднім шпалер при розблокованому екрані"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-pt-rPT/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-pt-rPT/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-pt-rPT/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Agitar para mudar"</string>
+    <string name="shake_to_switch_summary">"Agitar o aparelho para mudar o próximo ou anterior papel de parede quando não bloquear a tela"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-pa-rIN/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-pa-rIN/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-pa-rIN/strings.xml	(revision 173368)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"ਬਦਲਣ ਲਈ ਹਿਲਾਓ"</string>
+    <string name="shake_to_switch_summary">"ਜਦੋਂ ਲੌਕ ਸਕ੍ਰੀਨ ਨਾ ਹੋਵੇ ਤਾਂ ਅਗਲਾ ਜਾਂ ਪਿਛਲਾ ਵਾਲਪੇਪਰ ਬਦਲਣ ਲਈ ਡਿਵਾਈਸ ਹਿਲਾਓ"</string>
+    <string name="dynamic_icon_title">"ਡਾਇਨੈਮਿਕ ਆਈਕਨ"</string>
+    <string name="dynamic_calendar">"ਕੈਲੰਡਰ"</string>
+    <string name="dynamic_clock">ਘੜੀ</string>
+    <string name="allow_circular_sliding_title">"ਡੈਸਕਟੌਪ ਸਾਈਕਲ"</string>
+    <string name="folder_default_name">"ਫੋਲਡਰ"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-fa/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-fa/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-fa/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"برای تغییر، دستگاه را بلرزانید"</string>
+    <string name="shake_to_switch_summary">"هنگامی که در صفحه قفل نیست، برای رفتن به تصویر زمینه قبلی یا بعدی دستگاه را بلرزانید"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-bg/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-bg/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-bg/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Разтърсете за превключване"</string>
+    <string name="shake_to_switch_summary">"Разтърсете устройството за да превключите на следващ или предишен тапет когато екрана не е заключен"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-ta-rIN/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-ta-rIN/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-ta-rIN/strings.xml	(revision 173368)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"மாற்றுவதற்கு குலுக்கவும்"</string>
+    <string name="shake_to_switch_summary">"லாக் ஸ்கிரீனில் இல்லாதபோது அடுத்த அல்லது முந்தைய வால்பேப்பருக்கு மாற டிவைஸை குலுக்கவும்"</string>
+    <string name="dynamic_icon_title">"டைனமிக் ஐகான்"</string>
+    <string name="dynamic_calendar">நாட்காட்டி</string>
+    <string name="dynamic_clock">"கடிகாரம்"</string>
+    <string name="allow_circular_sliding_title">"டெக்ஸ்டாப் சுழற்சி"</string>
+    <string name="folder_default_name">"கோப்புறை"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_calendar_plate.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_calendar_plate.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_calendar_plate.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_calendar_plate.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_calendar_plate.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_dial_plate.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_dial_plate.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_dial_plate.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_dial_plate.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_dial_plate.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_calendar_plate_original.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_calendar_plate_original.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_calendar_plate_original.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_calendar_plate_original.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_calendar_plate_original.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_dial_plate_original.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_dial_plate_original.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_dial_plate_original.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_dial_plate_original.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-xhdpi/ic_dial_plate_original.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/values-fi/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-fi/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-fi/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Ravista vaihtaaksesi"</string>
+    <string name="shake_to_switch_summary">"Ravista laitetta vaihtaaksesi taustakuvaa kun näyttö ei ole lukittu"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-te-rIN/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-te-rIN/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-te-rIN/strings.xml	(revision 173368)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"మారడం కోసం కుదపండి"</string>
+    <string name="shake_to_switch_summary">"లాక్ స్క్రీన్ కాకుండా ఉన్నప్పుడు తదుపరి లేదా మునుపటి వాల్ పేపర్ కు మారడం కోసం పరికరం కుదపండి"</string>
+    <string name="dynamic_icon_title">"డైనమిక్ ఐకాన్"</string>
+    <string name="dynamic_calendar">"కాలెండర్"</string>
+    <string name="dynamic_clock">"గడియారం"</string>
+    <string name="allow_circular_sliding_title">"డెస్క్ టాప్ సైకిల్"</string>
+    <string name="folder_default_name">"ఫోల్డరు"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-nb/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-nb/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-nb/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Rist for å bytte"</string>
+    <string name="shake_to_switch_summary">"Snu enheten for å bytte til neste eller forrige bakgrunn når skjermen ikke er låst"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-bo/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-bo/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-bo/strings.xml	(revision 173368)
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="allow_circular_sliding_title">ཅོག་རེས་འཁོར་རེས།</string>
+    <string name="shake_to_switch">"གཡབ་ནས་རྩིག་ཤོག་བརྗེ་སྒྱུར་བྱེད།"</string>
+    <string name="shake_to_switch_summary">"འཆར་ཡོལ་མ་སྒྲོག་པའི་སྐབས་སུ། ཁ་པར་གཡས་སམ་གཡོན་དུ་གཡབ་པས་ན་རྩིག་ཤོག་གོང་མའམ་འོག་མར་བརྗེ་སྒྱུར་བྱེད།"</string>
+    <string name="unread_notifier_title">"མ་བཀླག་པའི་མཚོན་རྟགས།"</string>
+    <string name="unread_call">"ཁ་པར་"</string>
+    <string name="unread_sms">"འཕྲིན་ཐུང་།"</string>
+    <string name="unread_email">"སྦྲགས་ཡིག"</string>
+    <string name="unread_calendar">ཚེས་ཐོ།</string>
+    <string name="unread_hint">"དགོས་ངེས་ཀྱི་དབང་ཚད་<xliff:g id="unread_type">%1$s</xliff:g>མི་འདུག ཐོག་མར་དབང་ཚད་ཀྱི་རེ་འདུན་ཞུ་རོགས།"</string>
+    <string name="app_list_preference_none">"ཉེར་སྤྱོད་ཅིག་འདམ་རོགས།"</string>
+    <string name="pref_missed_call_count_title">དང་ལེན་མ་བྱས་བའི་ཁ་པར། </string>
+    <string name="pref_missed_call_count_summary">"ཉེར་སྤྱོད་ཅིག་བདམས་ནས་མ་བླངས་པའི་ཁ་པར་ཁ་གྲངས་འཆར་དུ་འཇུག"</string>
+    <string name="pref_unread_sms_count_title">"མ་བཀླག་པའི་ཆ་འཕྲིན།"</string>
+    <string name="pref_unread_sms_count_summary">"ཉེར་སྤྱོད་གཅིག་བདམས་ནས་མ་བཀླག་པའི་ཆ་འཕྲིན་གྱི་ཁ་གྲངས་འཆར་དུ་འཇུག"</string>
+    <string name="pref_unread_email_count_title">"མ་བཀླག་པའི་གློག་རྡུལ་སྦྲག་ཡིག"</string>
+    <string name="pref_unread_email_count_summary">"ཉེར་སྤྱོད་ཅིག་བདམས་ནས་མ་བཀླག་པའི་ཆ་འཕྲིན་གྱི་ཁ་གྲངས་འཆར་དུ་འཇུག"</string>
+    <string name="pref_unread_calendar_count_title">"མ་ཀླག་པའི་ཚེས་ཐོ་དོན་རྐྱེན།"</string>
+    <string name="pref_unread_calendar_count_summary">"ཉེར་སྤྱོད་ཅིག་བདམས་ནས་མ་བཀླག་པའི་ཚེས་ཐོའི་དོན་རྐྱེན་གྱི་ཁ་གྲངས་འཆར་དུ་འཇུག"</string>
+    <string name="selected_text">"བདམས། "</string>
+    <string name="dynamic_icon_title">"འགུལ་རིས་རྟགས་རིས།"</string>
+    <string name="folder_default_name">དཀར་ཆག</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-zh-rCN/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-zh-rCN/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-zh-rCN/strings.xml	(revision 173368)
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <!--SPRD Add for unreadNotifier function  start-->
+    <string name="unread_notifier_title">未读标记</string>
+    <string name="unread_call">电话</string>
+    <string name="unread_sms">短信</string>
+    <string name="unread_email">电子邮件</string>
+    <string name="unread_calendar">日历</string>
+    <string name="unread_hint">缺乏必要的<xliff:g id="unread_type">%1$s</xliff:g>权限，请先申请权限。</string>
+
+    <string name="app_list_preference_none">请选择一个应用</string>
+
+    <string name="pref_missed_call_count_title">未接来电</string>
+    <string name="pref_missed_call_count_summary">请选择一个应用以显示未接来电个数</string>
+    <string name="pref_unread_sms_count_title">未读信息</string>
+    <string name="pref_unread_sms_count_summary">请选择一个应用以显示未读信息个数</string>
+    <string name="pref_unread_email_count_title">未读电子邮件</string>
+    <string name="pref_unread_email_count_summary">请选择一个应用以显示未读邮件个数</string>
+    <string name="pref_unread_calendar_count_title">未读日历事件</string>
+    <string name="pref_unread_calendar_count_summary">请选择一个应用以显示未读日历事件个数</string>
+
+    <string name="selected_text">已选择</string>
+    <!--SPRD Add for unreadNotifier function  end-->
+
+    <string name="dynamic_icon_title">"动态图标"</string>
+
+    <!--SPRD Add for SPRD_CIRCULAR_SLIDING_SUPPORT start {-->
+    <string name="allow_circular_sliding_title">桌面循环滑动</string>
+    <!--end }-->
+
+    <string name="shake_to_switch">"摇换壁纸"</string>
+    <string name="shake_to_switch_summary">"非锁屏界面时，向右或向左摇手机，切换显示上一张或下一张壁纸"</string>
+
+    <string name="folder_default_name">文件夹</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values/config.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values/config.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values/config.xml	(revision 173368)
@@ -0,0 +1,18 @@
+<resources>
+    <!-- Default settings of unread function -->
+    <bool name="config_default_unread_call_enable">true</bool>
+    <bool name="config_default_unread_sms_enable">true</bool>
+    <bool name="config_default_unread_email_enable">false</bool>
+    <bool name="config_default_unread_calendar_enable">false</bool>
+
+    <bool name="config_hide_dynamic_icon_settings">false</bool>
+    <bool name="config_show_dynamic_calendar">true</bool>
+    <bool name="config_show_dynamic_clock">true</bool>
+
+    <string name="custom_dynamic_clock" translatable="false">com.google.android.deskclock/com.android.deskclock.DeskClock</string>
+    <string name="custom_dynamic_calendar" translatable="false">com.google.android.calendar/com.android.calendar.AllInOneActivity</string>
+
+    <bool name="allow_circle_slide">false</bool>
+
+    <bool name="allow_shake_change_wallpaper">false</bool>
+</resources>
Index: packages/apps/Launcher3/ext/res/values/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values/strings.xml	(revision 173368)
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <!--SPRD Add for unreadNotifier function  start-->
+    <string name="unread_notifier_title">Unread badge</string>
+    <string name="unread_call">Phone</string>
+    <string name="unread_sms">SMS</string>
+    <string name="unread_email">Email</string>
+    <string name="unread_calendar">Calendar</string>
+    <string name="unread_hint">Miss required <xliff:g id="unread_type">%1$s</xliff:g> permission, Please apply permission first.</string>
+
+    <string name="app_list_preference_none">Please select a app.</string>
+
+    <string name="pref_missed_call_count_title">Missed call</string>
+    <string name="pref_missed_call_count_summary">Select a Phone app, display the missed calls number on it</string>
+    <string name="pref_unread_sms_count_title">Unread message</string>
+    <string name="pref_unread_sms_count_summary">Select a SMS app, display the unread messages number on it</string>
+    <string name="pref_unread_email_count_title">Unread email</string>
+    <string name="pref_unread_email_count_summary">Select a Email app, display the unread mail number on it</string>
+    <string name="pref_unread_calendar_count_title">Unread calendar</string>
+    <string name="pref_unread_calendar_count_summary">Select a Calendar app, display the unread calendar events on it</string>
+
+    <string name="selected_text">Selected</string>
+    <!--SPRD Add for unreadNotifier function  end-->
+
+    <string name="dynamic_icon_title">Dynamic icon</string>
+    <string name="dynamic_calendar" translatable="false">Calendar</string>
+    <string name="dynamic_clock" translatable="false">Clock</string>
+
+    <!--SPRD Add for SPRD_CIRCULAR_SLIDING_SUPPORT start {-->
+    <string name="allow_circular_sliding_title">Desktop cycle</string>
+    <!--end }-->
+
+    <string name="shake_to_switch">Shake to switch wallpaper</string>
+    <string name="shake_to_switch_summary">Shake the device to switch to the next or previous wallpaper when entering main screen</string>
+
+    <string name="folder_default_name">Folder</string>
+
+    <string name="title_text">Warning!</string>
+    <string name="iv_title_summary_text">Peringatan!</string>
+    <string name="tv_content_one_text">Your Andromax has been Rootd or Bootloader has been unlocked,any altering in the software or hardware component through sofware may cause damage to the device and harm the user.\n\nSmartfren disclaim any liability for harm to the user.</string>
+    <string name="tv_content_two_text">Your warranty is VOID!</string>
+    <string name="tv_content_three_text">The device will continue boot-up in  <xliff:g id="time">%1$s</xliff:g> seconds\n</string>
+    <string name="tv_content_four_text">Andromax Anda telah di Root atau dibuka Bootloader-nya,segala jenis perubahan pada software ataupun hardware melalui software dapat menyebabkan kerusakan pada perangkat dan membahayakon pengguna.\n\nSmartfren tidak bertanggung jawab atas resiko yang ditimbulkan.</string>
+    <string name="tv_content_five_text">Garansi Anda sudah tidak beriaku!</string>
+    <string name="tv_content_six_text">Perangkot akan menyala dalam 5 detik.</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values/attrs.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values/attrs.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values/attrs.xml	(revision 173368)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <declare-styleable name="SprdAppInfo">
+        <attr name="clsName" format="string" />
+        <attr name="pkgName" format="string" />
+        <attr name="position" format="integer" />
+    </declare-styleable>
+</resources>
\ No newline at end of file
Index: packages/apps/Launcher3/ext/res/values/dimens.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values/dimens.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values/dimens.xml	(revision 173368)
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2009 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<resources>
+    <!-- add for dynamic clock-->
+    <dimen name="dynamic_clock_center_radius">2dp</dimen>
+    <dimen name="dynamic_clock_second_width">1dp</dimen>
+    <dimen name="dynamic_clock_minute_width">1dp</dimen>
+    <dimen name="dynamic_clock_hour_width">1dp</dimen>
+    <dimen name="dynamic_clock_center_radius_original">2dp</dimen>
+    <dimen name="dynamic_clock_second_width_original">1dp</dimen>
+    <dimen name="dynamic_clock_minute_width_original">2dp</dimen>
+    <dimen name="dynamic_clock_hour_width_original">2dp</dimen>
+
+    <!-- add for icon badge-->
+    <dimen name="badge_text_size">12sp</dimen>
+
+    <dimen name="rootloader_padding_left">16dp</dimen>
+    <dimen name="rootloader_padding_right">16dp</dimen>
+    <dimen name="rootloader_padding_bottom">16dp</dimen>
+</resources>
Index: packages/apps/Launcher3/ext/res/values/arrays.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values/arrays.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values/arrays.xml	(revision 173368)
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+
+    <!--Add for unread function: Email list -->
+    <string-array name="support_email_component_array" translatable="false">
+        <item>com.android.email/.activity.Welcome</item>
+    </string-array>
+    <!--Add for unread function: Calendar list -->
+    <string-array name="support_calendar_component_array" translatable="false">
+        <item>com.android.calendar/.AllInOneActivity</item>
+        <item>com.google.android.calendar/com.android.calendar.AllInOneActivity</item>
+    </string-array>
+
+    <string-array name="predictedapp_list" translatable="false">
+        <item>com.android.settings/.Settings</item>
+        <item>com.android.camera2/com.android.camera.CameraLauncher</item>
+        <item>com.android.gallery3d/.app.GalleryActivity</item>
+        <item>com.android.email/.activity.Welcome</item>
+        <item>com.android.calculator2/.Calculator</item>
+        <item>com.sprd.note/.NoteActivity</item>
+    </string-array>
+</resources>
\ No newline at end of file
Index: packages/apps/Launcher3/ext/res/values/colors.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values/colors.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values/colors.xml	(revision 173368)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <!-- add for dynamic clock-->
+    <color name="dynamic_clock_second_hand">#FFFEC226</color>
+    <color name="dynamic_clock_minute_hand">#FFE2E2E2</color>
+    <color name="dynamic_clock_hour_hand">#FFE2E2E2</color>
+
+    <!-- add for dynamic calendar-->
+    <color name="dynamic_calendar_week">#FFE5E5E5</color>
+    <color name="dynamic_calendar_date">#FFE85B5B</color>
+
+    <!-- add for icon badge-->
+    <color name="badge_bg_color">#FFFF0000</color>
+    <color name="badge_text_color">#FFFFFFFF</color>
+
+    <color name="quantum_panel_transparent_text_color">#FFFFFFFF</color>
+</resources>
\ No newline at end of file
Index: packages/apps/Launcher3/ext/res/values-ka-rGE/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-ka-rGE/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-ka-rGE/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"შეარხიეთ ჩასართავად"</string>
+    <string name="shake_to_switch_summary">"შეარხიეთ მოწყობილობა ეკრანის წინა ან მომდევნო ფონზე გადასასვლელად, როცა ეკრანი ბლოკირებული არ არის"</string>
+</resources>
\ No newline at end of file
Index: packages/apps/Launcher3/ext/res/values-nl/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-nl/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-nl/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Schud om te veranderen"</string>
+    <string name="shake_to_switch_summary">"Schud het apparaat om over te schakelen naar volgende of vorige achtergrond bij een ontgrendeld scherm"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-mni-rIN/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-mni-rIN/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-mni-rIN/strings.xml	(revision 173368)
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="unread_notifier_title">"রীদ তৌদবা বেদজ"</string>
+    <string name="unread_call">"ফোন"</string>
+    <string name="unread_sms">"SMS"</string>
+    <string name="unread_email">"ইমেল"</string>
+    <string name="unread_calendar">"কেলেন্দর"</string>
+    <string name="unread_hint">"মিস তৌবা দরকার ওই <xliff:g id="unread_type">%1$s</xliff:g> অয়াবা লৌবা, অহানবদা অয়াবা লৌবগী দরখ্বাস্ট থাবিয়ু."</string>
+    <string name="app_list_preference_none">"এপ অমা খনবিয়ু."</string>
+    <string name="pref_missed_call_count_title">"মিস তৌবা কোল"</string>
+    <string name="pref_missed_call_count_summary">"ফোন এপ অমা খল্লু, মদুগী মথক্তা মিস তৌখিবা পোন নম্বর অদু উৎলু"</string>
+    <string name="pref_unread_sms_count_title">"পাদবা মেসেজ"</string>
+    <string name="pref_unread_sms_count_summary">"SMS এপ অমা খল্লু, মদুগী মথক্তা পাদবা মেসেজশীং অদু উৎলু"</string>
+    <string name="pref_unread_email_count_title">"পাদবা ইমেল"</string>
+    <string name="pref_unread_email_count_summary">"ইমেল এপ অমা খল্লু, মদুগী মথক্তা পাদবা মেল নম্বর অদু উৎলু"</string>
+    <string name="pref_unread_calendar_count_title">"পাদবা কেলেন্দর"</string>
+    <string name="pref_unread_calendar_count_summary">"কেলেন্দর এপ অমা খল্লু, মদুগী মথক্তা পাদবা কেলেন্দরগী থৌদোকশীং অদু উৎলু"</string>
+    <string name="selected_text">"খল্লে"</string>
+    <string name="dynamic_icon_title">"দাইনামিক আইকোন"</string>
+    <string name="allow_circular_sliding_title">"দেস্কটোপ সাইকল"</string>
+    <string name="shake_to_switch">"ওন্নবা নিকউ"</string>
+    <string name="shake_to_switch_summary">"মরু ওইবা স্ক্রীন চংবা মতমদা দিভাইস অদু মথংগী নত্ত্রগা মমাংগী ৱালপেপর দা ওন্নবা নিকউ"</string>
+    <string name="folder_default_name">"ফাইল ফোল্দর"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/drawable-mdpi/ic_calendar_plate.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-mdpi/ic_calendar_plate.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-mdpi/ic_calendar_plate.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-mdpi/ic_calendar_plate.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-mdpi/ic_calendar_plate.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/drawable-mdpi/ic_dial_plate.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-mdpi/ic_dial_plate.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-mdpi/ic_dial_plate.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-mdpi/ic_dial_plate.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-mdpi/ic_dial_plate.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/drawable-mdpi/ic_calendar_plate_original.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-mdpi/ic_calendar_plate_original.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-mdpi/ic_calendar_plate_original.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-mdpi/ic_calendar_plate_original.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-mdpi/ic_calendar_plate_original.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/drawable-mdpi/ic_dial_plate_original.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-mdpi/ic_dial_plate_original.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-mdpi/ic_dial_plate_original.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-mdpi/ic_dial_plate_original.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-mdpi/ic_dial_plate_original.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/values-vi/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-vi/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-vi/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Lắc để chuyển đổi"</string>
+    <string name="shake_to_switch_summary">"Lắc thiết bị để chuyển đổi hình nền tiếp theo hoặc trước đó khi không khóa màn hình"</string>
+</resources>
\ No newline at end of file
Index: packages/apps/Launcher3/ext/res/values-ro/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-ro/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-ro/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Scuturați pentru a comuta"</string>
+    <string name="shake_to_switch_summary">"Scuturați dispozitivul pentru a comuta la imaginea de fundal următoare sau anterioară atunci când ecranul nu este blocat"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-ur-rPK/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-ur-rPK/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-ur-rPK/strings.xml	(revision 173368)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"سوئچ کرنے کے لئے ہلائیں"</string>
+    <string name="shake_to_switch_summary">"اگلے پر یا پچھلے وال پیپر پر سوئچ کرنے کے لئے آلہ کو ہلائیں جب اسکرین مقفل نہ ہو"</string>
+    <string name="dynamic_icon_title">"متحرک آئکن"</string>
+    <string name="dynamic_calendar">"کیلنڈر"</string>
+    <string name="dynamic_clock">"گھڑی"</string>
+    <string name="allow_circular_sliding_title">"ڈسک ٹاپ سرکل"</string>
+    <string name="folder_default_name">فولڈر</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-et-rEE/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-et-rEE/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-et-rEE/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Muutmiseks raputa"</string>
+    <string name="shake_to_switch_summary">"Raputa seadet, et  vahetada järgmise või eelmise taustapildi peale kui ekraan pole lukustatud"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-ca/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-ca/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-ca/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Sacsegeu el dispositiu per a canviar"</string>
+    <string name="shake_to_switch_summary">"Quan la pantalla estigui protegida, sacsegeu el dispositiu per a passar al fons de pantalla anterior o següent"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/drawable/ic_remove_circle.xml
===================================================================
--- packages/apps/Launcher3/ext/res/drawable/ic_remove_circle.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable/ic_remove_circle.xml	(revision 173368)
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+        android:height="48dp"
+        android:width="48dp"
+        android:tint="#db4437"
+        android:viewportHeight="48"
+        android:viewportWidth="48" >
+    <path android:fillColor="@android:color/white"
+          android:pathData="M24,4C12.95,4,4,12.95,4,24
+                         s8.95,20,20,20,20-8.95,20-20
+                         S35.05,4,24,4zm10,22H14v-4h20v4z"/>
+</vector>
Index: packages/apps/Launcher3/ext/res/values-ru/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-ru/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-ru/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Встряхнуть для переключения"</string>
+    <string name="shake_to_switch_summary">"Встряхните устройство для перехода к следующим или предыдущим обоям при разблокированном экране"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-km-rKH/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-km-rKH/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-km-rKH/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">អង្រួនដើម្បីផ្លាស់ប្តូរ</string>
+    <string name="shake_to_switch_summary">អង្រួនទូរស័ព្ទដើម្បីផ្លាស់ប្តូរទៅរូបផ្ទៃអេក្រងខាងមុខឬខាងក្រោយនៅពេលជាប់សោរអេក្រង់</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-ceb/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-ceb/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-ceb/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Uyoga aron mo-ilis"</string>
+    <string name="shake_to_switch_summary">"Uyoga ang aparato aron moilis sa sunod o sa miagi nga wallpaper kon wala masirado ang eskren"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-ml-rIN/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-ml-rIN/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-ml-rIN/strings.xml	(revision 173368)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"മാറ്റാൻ കുലുക്കുക"</string>
+    <string name="shake_to_switch_summary">"ലോക്ക് സ്ക്രീനില്‍ അല്ലാത്തപ്പോള്‍ അടുത്തതോ, അല്ലെങ്കിൽ മുന്നിലേയോ, വാള്‍പേപ്പറിലേക്ക് മാറാനായി ഉപകരണത്തെ കുലുക്കുക"</string>
+    <string name="dynamic_icon_title">"ഡൈനാമിക് ഐകൺ"</string>
+    <string name="dynamic_calendar">"കലണ്ടര്‍"</string>
+    <string name="dynamic_clock">"ക്ലോക്ക്"</string>
+    <string name="allow_circular_sliding_title">ഡെസ്ക്ടോപ്പ് സൈക്കിള്‍</string>
+    <string name="folder_default_name">"ഫോള്‍ഡര്‍"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-mk-rMK/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-mk-rMK/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-mk-rMK/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Протресете за да се префрлите"</string>
+    <string name="shake_to_switch_summary">"Кога екранот не е заклучен, протресете го уредот за да се префрлите на идната или претходната позадина"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-es-rES/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-es-rES/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-es-rES/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Agitar para cambiar"</string>
+    <string name="shake_to_switch_summary">"Agitar el dispositivo para cambiar al siguiente o anterior fondo de pantalla cuando no esté bloqueada la pantalla"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-eu-rES/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-eu-rES/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-eu-rES/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Astindu aldatzeko"</string>
+    <string name="shake_to_switch_summary">"Astindu gailua hurrengo edo aurreko horma-paperera igarotzeko pantaila blokeatuta ez dagoenean"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-zh-rHK/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-zh-rHK/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-zh-rHK/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"搖換桌布"</string>
+    <string name="shake_to_switch_summary">"非鎖屏桌面時，向左或向右搖手機，切換顯示上一張或下一張桌布"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-mr-rIN/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-mr-rIN/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-mr-rIN/strings.xml	(revision 173368)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"स्वीच हलवा"</string>
+    <string name="shake_to_switch_summary">"पुढील गोष्टी कडे स्वीच करण्यासाठी डिव्हाइस हलवा किंवा जेव्हा स्क्रीन लॉक नसतो तेव्हा मागील वॉलपेपर हलवा"</string>
+    <string name="dynamic_icon_title">"डायनॅमिक आयकन"</string>
+    <string name="dynamic_calendar">"कॅलेंडर"</string>
+    <string name="dynamic_clock">"क्लॉक"</string>
+    <string name="allow_circular_sliding_title">डेस्कटॉप सायकल</string>
+    <string name="folder_default_name">"फोल्डर"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-cs/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-cs/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-cs/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Zatřepáním změníte"</string>
+    <string name="shake_to_switch_summary">"Zatřepáním odemknutým zařízením změníte pozadí na následující nebo předcházející"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-pt-rBR/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-pt-rBR/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-pt-rBR/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Agite para alterar"</string>
+    <string name="shake_to_switch_summary">"Agite o dispositivo para alterar para o papel de parede anterior ou seguinte quando não estiver na tela bloqueada"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/drawable-hdpi/ic_calendar_plate.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-hdpi/ic_calendar_plate.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-hdpi/ic_calendar_plate.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-hdpi/ic_calendar_plate.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-hdpi/ic_calendar_plate.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/drawable-hdpi/ic_dial_plate.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-hdpi/ic_dial_plate.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-hdpi/ic_dial_plate.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-hdpi/ic_dial_plate.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-hdpi/ic_dial_plate.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/drawable-hdpi/ic_calendar_plate_original.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-hdpi/ic_calendar_plate_original.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-hdpi/ic_calendar_plate_original.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-hdpi/ic_calendar_plate_original.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-hdpi/ic_calendar_plate_original.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/drawable-hdpi/ic_dial_plate_original.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-hdpi/ic_dial_plate_original.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-hdpi/ic_dial_plate_original.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-hdpi/ic_dial_plate_original.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-hdpi/ic_dial_plate_original.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/drawable-hdpi/ic_info.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-hdpi/ic_info.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-hdpi/ic_info.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-hdpi/ic_info.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-hdpi/ic_info.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/values-kok-rIN/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-kok-rIN/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-kok-rIN/strings.xml	(revision 173368)
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="unread_notifier_title">"वाचूंक नाशिल्ले बॅज"</string>
+    <string name="unread_call">"फोन"</string>
+    <string name="unread_sms">"SMS"</string>
+    <string name="unread_email">"ईमेल"</string>
+    <string name="unread_calendar">"दिनदर्शिका"</string>
+    <string name="unread_hint">"जाय आशिल्ली<xliff:g id="unread_type">%1$s</xliff:g> मान्यताय ना, उपकार करून पयलीं मान्यतायेक अर्ज करचो."</string>
+    <string name="app_list_preference_none">"उपकार करून एक ॲप वेंच्चो."</string>
+    <string name="pref_missed_call_count_title">"चुकील्ले कॉल"</string>
+    <string name="pref_missed_call_count_summary">"एक फोन ॲप वेंच्चो, ताचेर चुकिल्ल्या कॉलांचो क्रमांक दाखोवचो"</string>
+    <string name="pref_unread_sms_count_title">"वाचूंक नाशिल्ले संदेश"</string>
+    <string name="pref_unread_sms_count_summary">"एक एसएमएस ॲप वेंच्चो, ताचेर वाचूंक नाशिल्ल्या संदेशांचो क्रमांक दाखोवचो "</string>
+    <string name="pref_unread_email_count_title">"वाचूंक नाशिल्ले ईमेल"</string>
+    <string name="pref_unread_email_count_summary">"एक ईमेल ॲप वेंच्चो, ताचेर वाचूंक नाशिल्ल्या ईमेलांचो क्रमांक दाखोवचो"</string>
+    <string name="pref_unread_calendar_count_title">"वाचूंक नाशिल्ल्यो दिनदर्शिका"</string>
+    <string name="pref_unread_calendar_count_summary">"एक दिनदर्शिका ॲप वेंच्चो, ताचेर वाचूंक नाशिल्ल्या दिनदर्शिका सुवाळे दाखोवचे"</string>
+    <string name="selected_text">"वेंचले"</string>
+    <string name="dynamic_icon_title">"डायनॅमीन आयकॉन"</string>
+    <string name="allow_circular_sliding_title">"डेस्कटॉप सायकल"</string>
+    <string name="shake_to_switch">"स्वीच करुंक हालयात"</string>
+    <string name="shake_to_switch_summary">"मुखेल स्क्रीनींत वतना फुडलो वा आदलो वॉलपेपर स्वीच करूंक यंत्र हालोवचो"</string>
+    <string name="folder_default_name">"फायल फॉल्डर"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-sk/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-sk/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-sk/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Potrasením prepnúť"</string>
+    <string name="shake_to_switch_summary">"Potrasením zariadenia prepnete na ďalšiu alebo predchádzajúcu tapetu, ak obrazovka nie je uzamknutá"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-my-rMM/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-my-rMM/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-my-rMM/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">" ဖြင့္ပိတ္ရန္ လႈပ္ခါပါ"</string>
+    <string name="shake_to_switch_summary">"ဖန္သားျပင္ ေသာ့မခတ္ခ်ိန္တြင္ ပိုစတာ အေဟာင္း (သို ့) အသစ္ ဖြင့္ပိတ္ရန္ စက္ကို ဘယ္ညာလႈပ္ခါပါ"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/drawable-xxxhdpi/ic_calendar_plate.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-xxxhdpi/ic_calendar_plate.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-xxxhdpi/ic_calendar_plate.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-xxxhdpi/ic_calendar_plate.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-xxxhdpi/ic_calendar_plate.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/drawable-xxxhdpi/ic_dial_plate.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-xxxhdpi/ic_dial_plate.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-xxxhdpi/ic_dial_plate.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-xxxhdpi/ic_dial_plate.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-xxxhdpi/ic_dial_plate.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/drawable-xxxhdpi/ic_dial_plate_original.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/drawable-xxxhdpi/ic_dial_plate_original.png
===================================================================
--- packages/apps/Launcher3/ext/res/drawable-xxxhdpi/ic_dial_plate_original.png	(revision 0)
+++ packages/apps/Launcher3/ext/res/drawable-xxxhdpi/ic_dial_plate_original.png	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/drawable-xxxhdpi/ic_dial_plate_original.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/values-es-rUS/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-es-rUS/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-es-rUS/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Agitar para cambiar"</string>
+    <string name="shake_to_switch_summary">"Agitar el dispositivo para cambiar al siguiente o anterior fondo de pantalla cuando no esté bloqueada la pantalla"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-sl/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-sl/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-sl/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Stresite za preklop"</string>
+    <string name="shake_to_switch_summary">"Ko zaslon ni zaklenjen, stresite napravo za preklop na naslednje ali predhodno ozadje"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/layout/listpref_widget_checkbox.xml
===================================================================
--- packages/apps/Launcher3/ext/res/layout/listpref_widget_checkbox.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/layout/listpref_widget_checkbox.xml	(revision 173368)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<CheckBox xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/checkbox"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:focusable="false"
+    android:background="@null"
+    android:padding="8dp"/>
Index: packages/apps/Launcher3/ext/res/layout/web_view.xml
===================================================================
--- packages/apps/Launcher3/ext/res/layout/web_view.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/layout/web_view.xml	(revision 173368)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<WebView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:id="@+id/webView"
+    />
Index: packages/apps/Launcher3/ext/res/layout/app_preference_item.xml
===================================================================
--- packages/apps/Launcher3/ext/res/layout/app_preference_item.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/layout/app_preference_item.xml	(revision 173368)
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="?android:attr/listPreferredItemHeight"
+    android:padding="6dip">
+    <ImageView
+        android:id="@+id/app_image"
+        android:layout_width="wrap_content"
+        android:layout_height="match_parent"
+        android:adjustViewBounds="true"
+        android:padding="6dip"
+        />
+    <TextView
+        android:id="@+id/app_label"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:minHeight="?android:attr/listPreferredItemHeight"
+        android:textAppearance="?android:attr/textAppearanceMedium"
+        android:textColor="?android:attr/textColorAlertDialogListItem"
+        android:gravity="center_vertical"
+        android:paddingEnd="7dip"
+        android:ellipsize="marquee"
+        />
+    <TextView
+        android:id="@+id/select_label"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:minHeight="?android:attr/listPreferredItemHeight"
+        android:textAppearance="?android:attr/textAppearanceSmall"
+        android:gravity="center_vertical"
+        android:text="@string/selected_text"
+        android:visibility="gone"
+        android:paddingEnd="7dip"
+        />
+</LinearLayout>
\ No newline at end of file
Index: packages/apps/Launcher3/ext/res/layout/rootbootloader.xml
===================================================================
--- packages/apps/Launcher3/ext/res/layout/rootbootloader.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/layout/rootbootloader.xml	(revision 173368)
@@ -0,0 +1,93 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingBottom="@dimen/rootloader_padding_bottom"
+    android:paddingLeft="@dimen/rootloader_padding_left"
+    android:paddingRight="@dimen/rootloader_padding_right"
+    android:background="#FF000000">
+
+    <ImageView
+        android:layout_width="50dp"
+        android:layout_height="50dp"
+        android:id="@+id/iv_title"
+        android:src="@drawable/ic_info" />
+
+    <TextView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:textSize="20sp"
+        android:layout_toRightOf="@id/iv_title"
+        android:id="@+id/tv_title"
+        android:text="@string/title_text"
+        android:textColor="#FFFFF000"/>
+
+    <TextView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:textSize="20sp"
+        android:layout_toRightOf="@id/iv_title"
+        android:layout_below="@id/tv_title"
+        android:id="@+id/iv_title_summary"
+        android:text="@string/iv_title_summary_text"
+        android:textColor="#FFFFF000"/>
+
+    <View
+        android:layout_width="match_parent"
+        android:layout_height="2dp"
+        android:id="@+id/line"
+        android:layout_marginTop="10dp"
+        android:layout_below="@id/iv_title"
+        android:background="#FFFFF000"/>
+
+    <TextView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:id="@+id/tv_content_one"
+        android:layout_below="@+id/line"
+        android:layout_marginTop="10dp"
+        android:text="@string/tv_content_one_text"/>
+
+    <TextView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:id="@+id/tv_content_two"
+        android:textColor="#FFFFF000"
+        android:textSize="20dp"
+        android:layout_below="@+id/tv_content_one"
+        android:text="@string/tv_content_two_text"/>
+
+    <TextView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:id="@+id/tv_content_three"
+        android:textSize="15sp"
+        android:layout_below="@+id/tv_content_two" />
+
+    <TextView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:id="@+id/tv_content_four"
+        android:textSize="15sp"
+        android:layout_below="@+id/tv_content_three"
+        android:text="@string/tv_content_four_text"/>
+
+    <TextView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:id="@+id/tv_content_five"
+        android:textColor="#FFFFF000"
+        android:textSize="20dp"
+        android:layout_below="@+id/tv_content_four"
+        android:text="@string/tv_content_five_text"/>
+
+    <TextView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:id="@+id/tv_content_six"
+        android:textSize="15sp"
+        android:layout_below="@+id/tv_content_five"
+        android:text="@string/tv_content_six_text"/>
+
+</RelativeLayout>
+
Index: packages/apps/Launcher3/ext/res/values-ms-rMY/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-ms-rMY/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-ms-rMY/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Goncang untuk tukar"</string>
+    <string name="shake_to_switch_summary">"Goncang peranti untuk menukar ke kertas dinding seterusnya atau sebelumnya apabila tidak dalam skrin berkunci"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-da/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-da/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-da/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Ryst for at skifte"</string>
+    <string name="shake_to_switch_summary">"Ryst enheden for at skifte til næste eller forrige tapet, når låseskærmen er aktiv"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-sr/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-sr/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-sr/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Протресите за пребацивање"</string>
+    <string name="shake_to_switch_summary">"Протресите уређај да бисте пребацили на следећу или претходну позадину, када екран није закључан"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-de/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-de/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-de/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Schütteln zum Umschalten"</string>
+    <string name="shake_to_switch_summary">"Schütteln Sie das Gerät, um auf dem nicht gesperrten Bildschirm zum nächsten oder vorherigen Hintergrundbild zu wechseln"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-ha/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-ha/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-ha/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"A girgiza don sauyawa"</string>
+    <string name="shake_to_switch_summary">"A girgiza waya don a sauya hoton bango na gaba ko na baya idan allo ba arufe yake ba"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-sv/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-sv/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-sv/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Skaka för att växla"</string>
+    <string name="shake_to_switch_summary">"Skaka enheten för att växla till nästa eller föregående bakgrund när skärmen inte är låst"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-sw/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-sw/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-sw/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Tikisa kubadili"</string>
+    <string name="shake_to_switch_summary">"Tikisa kifaa kubadili bamba ukuta ijayo au iliopita wakati skrini hijafungwa"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-zh-rTW/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-zh-rTW/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-zh-rTW/strings.xml	(revision 173368)
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <!--SPRD Add for unreadNotifier function  start-->
+    <string name="unread_notifier_title">未讀標記</string>
+    <string name="unread_call">電話</string>
+    <string name="unread_sms">簡訊</string>
+    <string name="unread_email">電子郵件</string>
+    <string name="unread_calendar">日曆</string>
+    <string name="unread_hint">缺乏必要的<xliff:g id="unread_type">%1$s</xliff:g>許可權，請先申請權限。</string>
+
+    <string name="app_list_preference_none">請選擇壹個應用</string>
+
+    <string name="pref_missed_call_count_title">未接來電</string>
+    <string name="pref_missed_call_count_summary">請選擇壹個應用以顯示未接來電個數</string>
+    <string name="pref_unread_sms_count_title">未讀訊息</string>
+    <string name="pref_unread_sms_count_summary">請選擇壹個應用以顯示未讀訊息個數</string>
+
+    <string name="pref_unread_email_count_title">未讀電子郵件</string>
+    <string name="pref_unread_email_count_summary">請選擇壹個應用以顯示未讀郵件個數</string>
+    <string name="pref_unread_calendar_count_title">未讀日曆事件</string>
+    <string name="pref_unread_calendar_count_summary">請選擇壹個應用以顯示未讀日曆事件計數</string>
+
+    <string name="selected_text">已選擇</string>
+    <!--SPRD Add for unreadNotifier function  end-->
+
+    <string name="dynamic_icon_title">"動態圖示"</string>
+
+    <!--SPRD Add for SPRD_CIRCULAR_SLIDING_SUPPORT start {-->
+    <string name="allow_circular_sliding_title">桌面循環滑動</string>
+    <!--end }-->
+
+    <string name="shake_to_switch">"搖換桌布"</string>
+    <string name="shake_to_switch_summary">"非鎖屏桌面時，向左或向右搖手機，切換顯示上壹張或下壹張桌布"</string>
+
+    <string name="folder_default_name">資料夾</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/raw/collision.ogg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/ext/res/raw/collision.ogg
===================================================================
--- packages/apps/Launcher3/ext/res/raw/collision.ogg	(revision 0)
+++ packages/apps/Launcher3/ext/res/raw/collision.ogg	(revision 173368)

Property changes on: packages/apps/Launcher3/ext/res/raw/collision.ogg
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/ext/res/values-hi/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-hi/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-hi/strings.xml	(revision 173368)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"स्विच करने के लिए हिलाएं"</string>
+    <string name="shake_to_switch_summary">"जब लॉक स्क्रीन न हो तो अगले अथवा पिछले वालपेपर पर स्विच करने के लिए डिवाइस हिलाएं"</string>
+    <string name="dynamic_icon_title">"डायनामिक आइकन"</string>
+    <string name="dynamic_calendar">"कैलेंडर"</string>
+    <string name="dynamic_clock">"घड़ी"</string>
+    <string name="allow_circular_sliding_title">"डैस्कटॉप साइकिल"</string>
+    <string name="folder_default_name">"फ़ोल्डर"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-si-rLK/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-si-rLK/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-si-rLK/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"මාරු කිරීමට සොලවන්න"</string>
+    <string name="shake_to_switch_summary">"තිරය අගුලු දමා නැති විට ඊළඟ හෝ පෙර බිතුපතට මාරු වීමට උපාංගය සොලවන්න"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/xml/settings_preferences_ext.xml
===================================================================
--- packages/apps/Launcher3/ext/res/xml/settings_preferences_ext.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/xml/settings_preferences_ext.xml	(revision 173368)
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2015 Google Inc.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+     SPRD_SETTINGS_ACTIVITY_SUPPORT
+-->
+
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
+    <Preference
+        android:key="pref_unreadNotifier"
+        android:title="@string/unread_notifier_title"
+    />
+
+    <Preference
+        android:key="pref_dynamicIcon"
+        android:title="@string/dynamic_icon_title"
+    />
+
+    <SwitchPreference
+            android:key="pref_allowRotation"
+            android:title="@string/allow_rotation_title"
+            android:defaultValue="@bool/allow_rotation"
+            android:persistent="false"
+    />
+
+    <SwitchPreference
+            android:key="pref_allowCircularSliding"
+            android:title="@string/allow_circular_sliding_title"
+            android:defaultValue="@bool/allow_circle_slide"
+            android:persistent="false"
+    />
+
+    <SwitchPreference
+        android:key="pref_shake_change_wallpaper"
+        android:title="@string/shake_to_switch"
+        android:summary="@string/shake_to_switch_summary"
+        android:defaultValue="@bool/allow_shake_change_wallpaper"
+        android:persistent="false"
+     />
+
+</PreferenceScreen>
Index: packages/apps/Launcher3/ext/res/xml/dw_base_customize.xml
===================================================================
--- packages/apps/Launcher3/ext/res/xml/dw_base_customize.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/xml/dw_base_customize.xml	(revision 173368)
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2015 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<favorites xmlns:launcher="http://schemas.android.com/apk/res-auto/com.android.launcher3">
+
+    <appwidget
+        launcher:screen="0"
+        launcher:x="0"
+        launcher:y="0"
+        launcher:spanX="4"
+        launcher:spanY="2"
+        launcher:packageName="com.android.deskclock"
+        launcher:className="com.android.alarmclock.DigitalAppWidgetProvider" />
+
+    <favorite
+        launcher:screen="0"
+        launcher:x="-2"
+        launcher:y="-1"
+        launcher:packageName="com.android.music"
+        launcher:className="com.android.music.MusicBrowserActivity" />
+
+    <favorite
+        launcher:screen="0"
+        launcher:x="-1"
+        launcher:y="-1"
+        launcher:packageName="com.android.settings"
+        launcher:className="com.android.settings.Settings" />
+
+</favorites>
Index: packages/apps/Launcher3/ext/res/xml/customize_app_positions.xml
===================================================================
--- packages/apps/Launcher3/ext/res/xml/customize_app_positions.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/xml/customize_app_positions.xml	(revision 173368)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Apps xmlns:launcher="http://schemas.android.com/apk/res-auto">
+    <App
+        launcher:pkgName="com.smartfren"
+        launcher:position="0" />
+    <App
+        launcher:pkgName="cn.wps.moffice_eng"
+        launcher:position="1" />
+</Apps>
\ No newline at end of file
Index: packages/apps/Launcher3/ext/res/xml/dw_vendor_customize.xml
===================================================================
--- packages/apps/Launcher3/ext/res/xml/dw_vendor_customize.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/xml/dw_vendor_customize.xml	(revision 173368)
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2015 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<favorites xmlns:launcher="http://schemas.android.com/apk/res-auto/com.android.launcher3">
+
+    <!--to do add for vendor customize-->
+
+</favorites>
Index: packages/apps/Launcher3/ext/res/xml/dynamic_icon_settings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/xml/dynamic_icon_settings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/xml/dynamic_icon_settings.xml	(revision 173368)
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
+    android:title="@string/dynamic_icon_title">
+
+    <SwitchPreference
+        android:key="pref_calendar"
+        android:title="@string/dynamic_calendar"
+        android:persistent="false" />
+
+    <SwitchPreference
+        android:key="pref_clock"
+        android:title="@string/dynamic_clock"
+        android:persistent="false" />
+
+</PreferenceScreen>
\ No newline at end of file
Index: packages/apps/Launcher3/ext/res/xml/unread_settings_preferences.xml
===================================================================
--- packages/apps/Launcher3/ext/res/xml/unread_settings_preferences.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/xml/unread_settings_preferences.xml	(revision 173368)
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
+
+        <com.sprd.ext.unreadnotifier.call.DefaultPhonePreference
+            android:key="pref_missed_call_count"
+            android:summary="@string/pref_missed_call_count_summary"
+            android:title="@string/pref_missed_call_count_title"
+            />
+
+        <com.sprd.ext.unreadnotifier.sms.DefaultSmsPreference
+            android:key="pref_unread_sms_count"
+            android:summary="@string/pref_unread_sms_count_summary"
+            android:title="@string/pref_unread_sms_count_title"/>
+
+        <com.sprd.ext.unreadnotifier.email.EmailPreference
+            android:key="pref_unread_email_count"
+            android:summary="@string/pref_unread_email_count_summary"
+            android:title="@string/pref_unread_email_count_title" />
+
+        <com.sprd.ext.unreadnotifier.calendar.CalendarPreference
+            android:key="pref_unread_calendar_count"
+            android:summary="@string/pref_unread_calendar_count_summary"
+            android:title="@string/pref_unread_calendar_count_title" />
+</PreferenceScreen>
\ No newline at end of file
Index: packages/apps/Launcher3/ext/res/values-bn-rBD/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-bn-rBD/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-bn-rBD/strings.xml	(revision 173368)
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"বদলাতে নাড়ান"</string>
+    <string name="shake_to_switch_summary">"যখন স্ক্রীন লক থাকে না পরের বা আগের ওয়ালপেপারে বদলাতে ডিভাইসটিকে নাড়ান"</string>
+    <string name="dynamic_icon_title">"ডাইনামিক আইকোন"</string>
+    <string name="dynamic_calendar">ক্যালেন্ডার</string>
+    <string name="dynamic_clock">"ঘড়ি"</string>
+    <string name="allow_circular_sliding_title">"ডেস্কটপ আবর্ত"</string>
+    <string name="folder_default_name">"ফোল্ডার"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-bs-rBA/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-bs-rBA/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-bs-rBA/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Protresite za promjenu"</string>
+    <string name="shake_to_switch_summary">"Protresite uređaj da pređete na prethodnu ili slijedeću pozadinu kada ekran nije zaključan"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-hr/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-hr/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-hr/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Protresite za promjenu"</string>
+    <string name="shake_to_switch_summary">"Protresite uređaj kako bi promijenili pozadinu na sljedeću ili na prethodnu, kada niste na zaslonu zaključavanja"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-pl/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-pl/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-pl/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Potrząśnij żeby zmienić"</string>
+    <string name="shake_to_switch_summary">"Potrząśnij urządzeniem aby zmienić poprzednią lub następną tapetę, gdy ekran nie jest zablokowany."</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-th/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-th/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-th/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"เขย่าเพื่อเปลี่ยน"</string>
+    <string name="shake_to_switch_summary">"เขย่าโทรศัพท์ที่จะเปลี่ยนวอลล์เปเปอร์ถัดไปหรือก่อน,เมื่อไม่ได้ล็อคหน้าจอ"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-hu/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-hu/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-hu/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Rázza meg a bekapcsoláshoz"</string>
+    <string name="shake_to_switch_summary">"Rázza meg a készüléket az előző vagy következő háttérképre lépéshez, ha a képernyő nincs zárolva"</string>
+</resources>
\ No newline at end of file
Index: packages/apps/Launcher3/ext/res/values-land/dimens.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-land/dimens.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-land/dimens.xml	(revision 173368)
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2009 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<resources>
+<!-- Add for unread events feature. -->
+    <dimen name="workspace_unread_margin_right">20dp</dimen>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-lt/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-lt/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-lt/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Pakratykite perjungimui"</string>
+    <string name="shake_to_switch_summary">"Pakratykite  pretaisą, kad įjungtumėte buvusį ar sekanti  fono vaizdą kai  ekranas atrakintas" </string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-tl/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-tl/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-tl/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Kalugin upang mapalitan"</string>
+    <string name="shake_to_switch_summary">"Kalogin ang aparato upang lumipat sa susunod o nakaraang wallpaper kapag hindi nakakandado ang eskren"</string>
+</resources>
Index: packages/apps/Launcher3/ext/res/values-lv/strings.xml
===================================================================
--- packages/apps/Launcher3/ext/res/values-lv/strings.xml	(revision 0)
+++ packages/apps/Launcher3/ext/res/values-lv/strings.xml	(revision 173368)
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="shake_to_switch">"Kratīt, lai pārslēgtu"</string>
+    <string name="shake_to_switch_summary">"Kratiet ierīci, lai pārslēgtu nākošo vai iepriekšējo ekrāntapeti, kad ekrāns nav slēgts"</string>
+</resources>
Index: packages/apps/Launcher3/AndroidManifest.xml
===================================================================
--- packages/apps/Launcher3/AndroidManifest.xml	(revision 173367)
+++ packages/apps/Launcher3/AndroidManifest.xml	(revision 173368)
@@ -19,8 +19,9 @@
 -->
 <manifest
     xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
     package="com.android.launcher3">
-    <uses-sdk android:targetSdkVersion="23" android:minSdkVersion="23"/>
+    <uses-sdk android:targetSdkVersion="24" android:minSdkVersion="24"/>
 
     <permission
         android:name="com.android.launcher.permission.INSTALL_SHORTCUT"
@@ -48,8 +49,7 @@
         android:name="com.android.launcher3.permission.RECEIVE_FIRST_LOAD_BROADCAST"
         android:protectionLevel="signatureOrSystem" />
 
-        <uses-permission android:name="android.permission.INTERNET"/>
-
+    <uses-permission android:name="android.permission.INTERNET"/>
     <uses-permission android:name="android.permission.CALL_PHONE" />
     <uses-permission android:name="android.permission.SET_WALLPAPER" />
     <uses-permission android:name="android.permission.SET_WALLPAPER_HINTS" />
@@ -64,10 +64,16 @@
     <uses-permission android:name="com.android.launcher3.permission.WRITE_SETTINGS" />
     <uses-permission android:name="com.android.launcher3.permission.RECEIVE_LAUNCH_BROADCASTS" />
     <uses-permission android:name="com.android.launcher3.permission.RECEIVE_FIRST_LOAD_BROADCAST" />
+
+    <!-- SPRD Add for bug628090-->
+    <uses-permission android:name="android.permission.MANAGE_USERS"/>
+
+    <!-- SPRD Add for unreadNotifier Function  start-->
     <uses-permission android:name="android.permission.READ_CALL_LOG" />
     <uses-permission android:name="android.permission.READ_SMS" />
-    <uses-permission android:name="com.android.email.permission.ACCESS_PROVIDER"/>
-    <uses-permission android:name="android.permission.PACKAGE_USAGE_STATS" />
+    <uses-permission android:name="com.android.email.permission.ACCESS_PROVIDER" />
+    <uses-permission android:name="android.permission.READ_CALENDAR" />
+    <!-- SPRD Add for unreadNotifier Function  end-->
 
     <application
         android:allowBackup="@bool/enable_backup"
@@ -77,7 +83,8 @@
         android:label="@string/app_name"
         android:largeHeap="@bool/config_largeHeap"
         android:restoreAnyVersion="true"
-        android:supportsRtl="true" >
+        android:supportsRtl="true"
+        tools:ignore="ManifestResource">
 
         <activity
             android:name="com.android.launcher3.Launcher"
@@ -88,7 +95,7 @@
             android:windowSoftInputMode="adjustPan"
             android:screenOrientation="nosensor"
             android:configChanges="keyboard|keyboardHidden|navigation"
-            android:resumeWhilePausing="false"
+            android:resumeWhilePausing="true"
             android:taskAffinity=""
             android:enabled="true"
             android:resizeableActivity="false">
@@ -134,6 +141,43 @@
             android:process=":settings_process">
         </activity>
 
+        <activity
+            android:name="com.sprd.ext.root.RootBootLoader"
+            android:theme="@android:style/Theme.Holo.NoActionBar"
+			android:excludeFromRecents="true">
+        </activity>
+
+        <activity
+            android:name="com.sprd.ext.SprdSettingsActivity"
+            android:theme="@android:style/Theme.DeviceDefault.Light.DarkActionBar"
+            android:label="@string/settings_button_text"
+            android:autoRemoveFromRecents="true"
+            android:process=":sprd_settings_process">
+        </activity>
+
+        <!-- SPRD Add for unreadNotifier Function  start-->
+        <activity android:name="com.sprd.ext.unreadnotifier.UnreadActivity"
+            android:configChanges="orientation|keyboardHidden|screenSize"
+            android:theme="@android:style/Theme.DeviceDefault.Light.DarkActionBar"
+            android:label="@string/unread_notifier_title">
+
+            <intent-filter>
+                <action android:name="com.sprd.ACTION_UNREAD_ACTIVITY" />
+            </intent-filter>
+        </activity>
+        <!-- SPRD Add for unreadNotifier Function  end-->
+
+        <activity
+            android:name="com.sprd.ext.dynamicIcon.DynamicIconSettings"
+            android:theme="@android:style/Theme.DeviceDefault.Light.DarkActionBar"
+            android:label="@string/dynamic_icon_title"
+            android:autoRemoveFromRecents="true">
+            <intent-filter>
+                <action android:name="com.sprd.ACTION_DYNAMIC_ICON_SETTINGS" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
+
         <!-- Intent received used to install shortcuts from other applications -->
         <receiver
             android:name="com.android.launcher3.InstallShortcutReceiver"
@@ -156,14 +200,6 @@
             </intent-filter>
         </receiver>
 
-        <activity
-            android:name="com.android.launcher3.RootBootLoader"
-            android:theme="@android:style/Theme.Holo.NoActionBar"
-            android:excludeFromRecents="true" >
-            <intent-filter>
-            </intent-filter>
-        </activity>
-
         <!-- The settings provider contains Home's data, like the workspace favorites -->
         <provider
             android:name="com.android.launcher3.LauncherProvider"
@@ -222,6 +258,5 @@
         <service android:name="com.android.launcher3.testing.MemoryTracker" />
 
         -->
-
     </application>
 </manifest>
Index: vendor/sprd/feature_configs/base/config.mk
===================================================================
--- vendor/sprd/feature_configs/base/config.mk	(revision 173367)
+++ vendor/sprd/feature_configs/base/config.mk	(revision 173368)
@@ -29,8 +29,8 @@
     LimitOwnerInfoLength \
     MultiPartCallPlugin \
     LauncherDrmAddon \
-    DynamicCalendarIcon \
-    DynamicDeskClockIcon \
+   # DynamicCalendarIcon \
+   # DynamicDeskClockIcon \
     SystemUIAudioProfile \
     SystemClockPlugin \
     SimLockSupport \
@@ -53,6 +53,6 @@
     SprdQuickSearchBox \
     NoteBook \
     CellBroadcastReceiver \
-    Omacp \
-    UnreadInfo \
-	SprdCuccAppSortAddon 
+    Omacp 
+    #UnreadInfo \
+    #	SprdCuccAppSortAddon 
Index: vendor/sprd/plugins/packages/apps/Launcher3/WallpaperPicker/Android.mk
===================================================================
--- vendor/sprd/plugins/packages/apps/Launcher3/WallpaperPicker/Android.mk	(revision 173367)
+++ vendor/sprd/plugins/packages/apps/Launcher3/WallpaperPicker/Android.mk	(revision 173368)
@@ -1,2 +1,2 @@
-LOCAL_PATH := $(call my-dir)
-include $(call all-makefiles-under,$(LOCAL_PATH))
+#LOCAL_PATH := $(call my-dir)
+#include $(call all-makefiles-under,$(LOCAL_PATH))
