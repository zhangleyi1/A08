Index: packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperCropActivity.java
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperCropActivity.java	(revision 182200)
+++ packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperCropActivity.java	(revision 182201)
@@ -523,7 +523,7 @@
 
         public void updateCropView(WallpaperCropActivity a, TileSource src) {
             Point wallpaperSize = WallpaperUtils.getDefaultWallpaperSize(
-                    a.getResources(), a.getWindowManager(),src.getImageWidth());
+                    a.getResources(), a.getWindowManager(), src.getImageWidth());
             RectF crop = Utils.getMaxCropRect(src.getImageWidth(), src.getImageHeight(),
                     wallpaperSize.x, wallpaperSize.y, false /* leftAligned */);
 
Index: packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperPickerActivity.java
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperPickerActivity.java	(revision 182200)
+++ packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperPickerActivity.java	(revision 182201)
@@ -26,8 +26,8 @@
 import android.content.Intent;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.content.res.Configuration;
 import android.content.res.Resources;
-import android.content.res.Configuration;
 import android.database.Cursor;
 import android.database.DataSetObserver;
 import android.graphics.Bitmap;
@@ -83,6 +83,7 @@
 import com.android.launcher3.util.Thunk;
 import com.android.photos.BitmapRegionTileSource;
 import com.android.photos.BitmapRegionTileSource.BitmapSource;
+import com.sprd.ext.FeatureOption;
 import com.sprd.ext.LogUtils;
 
 import java.io.ByteArrayInputStream;
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_09_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/tile_shadow_top.9.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/ic_actionbar_accept.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_07.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_08.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_09.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_10_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/ic_images.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_11_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_12_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_13_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_14_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_10.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_11.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_12.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_13.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_14.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/tile_shadow_bottom.9.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_07_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_08_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/values-iw/strings.xml
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/values-iw/strings.xml	(revision 182200)
+++ packages/apps/Launcher3/WallpaperPicker/res/values-iw/strings.xml	(revision 182201)
@@ -27,7 +27,7 @@
       <item quantity="two">‏נבחרו %1$d פריטים</item>
       <item quantity="many">‏נבחרו %1$d פריטים</item>
       <item quantity="other">‏נבחרו %1$d פריטים</item>
-      <item quantity="one">נבחר פריט אחד</item>
+      <item quantity="one">‏נבחרו %1$d פריטים</item>
     </plurals>
     <string name="wallpaper_accessibility_name" msgid="4093221025304876354">"‏טפט %1$d מתוך %2$d"</string>
     <string name="announce_selection" msgid="123723511662250539">"בחרת <xliff:g id="LABEL">%1$s</xliff:g>"</string>
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_06.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_06.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_06.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_06.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_06.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_07.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_07.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_07.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_07.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_07.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_08.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_08.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_08.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_08.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_08.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_09.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_09.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_09.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_09.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_09.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_00_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_00_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_00_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_00_small.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_00_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_01_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_01_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_01_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_01_small.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_01_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_10_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_10_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_10_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_10_small.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_10_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_02_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_02_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_02_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_02_small.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_02_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_11_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_11_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_11_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_11_small.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_11_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_03_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_03_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_03_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_03_small.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_03_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_04_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_04_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_04_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_04_small.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_04_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_05_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_05_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_05_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_05_small.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_05_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_06_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_06_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_06_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_06_small.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_06_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_07_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_07_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_07_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_07_small.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_07_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_00.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_00.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_00.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_00.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_00.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_08_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_08_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_08_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_08_small.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_08_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_01.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_01.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_01.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_01.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_01.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_09_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_09_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_09_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_09_small.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_09_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_10.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_10.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_10.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_10.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_10.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_02.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_02.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_02.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_02.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_02.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_11.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_11.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_11.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_11.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_11.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_03.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_03.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_03.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_03.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_03.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_04.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_04.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_04.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_04.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_04.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_05.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_05.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_05.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_05.png	(revision 182201)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_05.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/src/com/android/launcher3/PagedView.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/PagedView.java	(revision 182200)
+++ packages/apps/Launcher3/src/com/android/launcher3/PagedView.java	(revision 182201)
@@ -861,11 +861,11 @@
                         childHeightMode = MeasureSpec.EXACTLY;
                     }
 
-                        childWidth = getViewportWidth() - horizontalPadding
-                                - mInsets.left - mInsets.right;
-                        childHeight = getViewportHeight() - verticalPadding
-                                - mInsets.top - mInsets.bottom;
-                        mNormalChildHeight = childHeight;
+                    childWidth = getViewportWidth() - horizontalPadding
+                            - mInsets.left - mInsets.right;
+                    childHeight = getViewportHeight() - verticalPadding
+                            - mInsets.top - mInsets.bottom;
+                    mNormalChildHeight = childHeight;
                 } else {
                     childWidthMode = MeasureSpec.EXACTLY;
                     childHeightMode = MeasureSpec.EXACTLY;
@@ -922,7 +922,7 @@
                 lp = (LayoutParams) child.getLayoutParams();
                 int childTop;
                 if (lp.isFullScreenPage) {
-                        childTop = offsetY;
+                    childTop = offsetY;
                 } else {
                     childTop = offsetY + getPaddingTop() + mInsets.top;
                     if (mCenterPagesVertically) {
Index: packages/apps/Launcher3/src/com/android/launcher3/CellLayout.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/CellLayout.java	(revision 182200)
+++ packages/apps/Launcher3/src/com/android/launcher3/CellLayout.java	(revision 182201)
@@ -171,7 +171,6 @@
     private DragAndDropAccessibilityDelegate mTouchHelper;
     private boolean mUseTouchHelper = false;
 
-
     public CellLayout(Context context) {
         this(context, null);
     }
@@ -877,7 +876,6 @@
             mHeightGap = mOriginalHeightGap;
         }
 
-
         // Make the feedback view large enough to hold the blur bitmap.
         mTouchFeedbackView.measure(
                 MeasureSpec.makeMeasureSpec(mCellWidth + mTouchFeedbackView.getExtraSize(),
@@ -1062,14 +1060,20 @@
         final int oldDragCellX = mDragCell[0];
         final int oldDragCellY = mDragCell[1];
 
-        if (dragOutline == null && v == null) {
+        if (dragOutline == null) {
             return;
         }
 
         if (cellX != oldDragCellX || cellY != oldDragCellY) {
-            Point dragOffset = dragObject.dragView.getDragVisualizeOffset();
-            Rect dragRegion = dragObject.dragView.getDragRegion();
+            DragView dragView = dragObject.dragView;
+            Point dragOffset = null;
+            Rect dragRegion = null;
 
+            if (dragView != null) {
+                dragOffset = dragObject.dragView.getDragVisualizeOffset();
+                dragRegion = dragObject.dragView.getDragRegion();
+            }
+
             mDragCell[0] = cellX;
             mDragCell[1] = cellY;
             // Find the top left corner of the rect the object will occupy
@@ -3014,8 +3018,4 @@
 
         return true;
     }
-
-
-
-
 }
Index: packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java	(revision 182200)
+++ packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java	(revision 182201)
@@ -250,7 +250,8 @@
         textPaint.setTextSize(iconTextSizePx);
         FontMetrics fm = textPaint.getFontMetrics();
         cellWidthPx = iconSizePx;
-        cellHeightPx = iconSizePx + iconDrawablePaddingPx + (int) Math.ceil(fm.bottom - fm.top);
+        cellHeightPx = iconSizePx + iconDrawablePaddingPx + (int) Math.ceil(fm.bottom - fm.top) +
+                res.getDimensionPixelSize(R.dimen.adjust_cell_height);
         final float scaleDps = res.getDimensionPixelSize(R.dimen.dragViewScale);
         dragViewScale = (iconSizePx + scaleDps) / iconSizePx;
 
@@ -267,7 +268,11 @@
                 (availableWidthPx - 4 * edgeMarginPx) / inv.numFolderColumns);
         folderCellHeightPx = cellHeightPx + edgeMarginPx;
         folderBackgroundOffset = -edgeMarginPx;
-        folderIconSizePx = iconSizePx + 2 * -folderBackgroundOffset;
+        if (isVerticalBarLayout()) {
+            folderIconSizePx = iconSizePx;
+        } else {
+            folderIconSizePx = iconSizePx + 2 * -folderBackgroundOffset;
+        }
     }
 
     /**
Index: packages/apps/Launcher3/src/com/android/launcher3/FolderIcon.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/FolderIcon.java	(revision 182200)
+++ packages/apps/Launcher3/src/com/android/launcher3/FolderIcon.java	(revision 182201)
@@ -1,826 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.launcher3;
-
-import android.animation.Animator;
-import android.animation.AnimatorListenerAdapter;
-import android.animation.ValueAnimator;
-import android.animation.ValueAnimator.AnimatorUpdateListener;
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Point;
-import android.graphics.PorterDuff;
-import android.graphics.Rect;
-import android.graphics.drawable.Drawable;
-import android.os.Looper;
-import android.os.Parcelable;
-import android.util.AttributeSet;
-import android.view.LayoutInflater;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.ViewConfiguration;
-import android.view.ViewGroup;
-import android.view.animation.AccelerateInterpolator;
-import android.view.animation.DecelerateInterpolator;
-import android.widget.FrameLayout;
-import android.widget.ImageView;
-import android.widget.TextView;
-
-import com.android.launcher3.DropTarget.DragObject;
-import com.android.launcher3.FolderInfo.FolderListener;
-import com.android.launcher3.util.Thunk;
-
-import com.sprd.ext.UtilitiesExt;
-import com.sprd.ext.dynamicIcon.DynamicIconUtils;
-import com.sprd.ext.foldername.FolderNameUtils;
-import com.sprd.ext.FeatureOption;
-import com.sprd.ext.LogUtils;
-import com.sprd.ext.unreadnotifier.UnreadLoaderUtils;
-
-import java.util.ArrayList;
-
-/**
- * An icon that can appear on in the workspace representing an {@link UserFolder}.
- */
-public class FolderIcon extends FrameLayout implements FolderListener {
-    @Thunk Launcher mLauncher;
-    @Thunk Folder mFolder;
-    private FolderInfo mInfo;
-    @Thunk static boolean sStaticValuesDirty = true;
-
-    private CheckLongPressHelper mLongPressHelper;
-    private StylusEventHelper mStylusEventHelper;
-
-    // The number of icons to display in the
-    public static final int NUM_ITEMS_IN_PREVIEW = 3;
-    private static final int CONSUMPTION_ANIMATION_DURATION = 100;
-    private static final int DROP_IN_ANIMATION_DURATION = 400;
-    private static final int INITIAL_ITEM_ANIMATION_DURATION = 350;
-    private static final int FINAL_ITEM_ANIMATION_DURATION = 200;
-
-    // The degree to which the inner ring grows when accepting drop
-    private static final float INNER_RING_GROWTH_FACTOR = 0.15f;
-
-    // The degree to which the outer ring is scaled in its natural state
-    private static final float OUTER_RING_GROWTH_FACTOR = 0.3f;
-
-    // The amount of vertical spread between items in the stack [0...1]
-    private static final float PERSPECTIVE_SHIFT_FACTOR = 0.18f;
-
-    // Flag as to whether or not to draw an outer ring. Currently none is designed.
-    public static final boolean HAS_OUTER_RING = true;
-
-    // Flag whether the folder should open itself when an item is dragged over is enabled.
-    public static final boolean SPRING_LOADING_ENABLED = true;
-
-    // The degree to which the item in the back of the stack is scaled [0...1]
-    // (0 means it's not scaled at all, 1 means it's scaled to nothing)
-    private static final float PERSPECTIVE_SCALE_FACTOR = 0.35f;
-
-    // Delay when drag enters until the folder opens, in miliseconds.
-    private static final int ON_OPEN_DELAY = 800;
-
-    public static Drawable sSharedFolderLeaveBehind = null;
-
-    @Thunk ImageView mPreviewBackground;
-    @Thunk BubbleTextView mFolderName;
-
-    FolderRingAnimator mFolderRingAnimator = null;
-    private static final String TAG = "Launcher.FolderIcon";
-
-    // These variables are all associated with the drawing of the preview; they are stored
-    // as member variables for shared usage and to avoid computation on each frame
-    private int mIntrinsicIconSize;
-    private float mBaselineIconScale;
-    private int mBaselineIconSize;
-    private int mAvailableSpaceInPreview;
-    private int mTotalWidth = -1;
-    private int mPreviewOffsetX;
-    private int mPreviewOffsetY;
-    private float mMaxPerspectiveShift;
-    boolean mAnimating = false;
-    private Rect mOldBounds = new Rect();
-
-    private float mSlop;
-
-    private PreviewItemDrawingParams mParams = new PreviewItemDrawingParams(0, 0, 0, 0);
-    @Thunk PreviewItemDrawingParams mAnimParams = new PreviewItemDrawingParams(0, 0, 0, 0);
-    @Thunk ArrayList<ShortcutInfo> mHiddenItems = new ArrayList<ShortcutInfo>();
-
-    private Alarm mOpenAlarm = new Alarm();
-    @Thunk ItemInfo mDragInfo;
-
-    public FolderIcon(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init();
-    }
-
-    public FolderIcon(Context context) {
-        super(context);
-        init();
-    }
-
-    private void init() {
-        mLongPressHelper = new CheckLongPressHelper(this);
-        mStylusEventHelper = new StylusEventHelper(this);
-        setAccessibilityDelegate(LauncherAppState.getInstance().getAccessibilityDelegate());
-    }
-
-    public boolean isDropEnabled() {
-        final ViewGroup cellLayoutChildren = (ViewGroup) getParent();
-        final ViewGroup cellLayout = (ViewGroup) cellLayoutChildren.getParent();
-        final Workspace workspace = (Workspace) cellLayout.getParent();
-        return !workspace.workspaceInModalState();
-    }
-
-    static FolderIcon fromXml(int resId, Launcher launcher, ViewGroup group,
-            FolderInfo folderInfo, IconCache iconCache) {
-        @SuppressWarnings("all") // suppress dead code warning
-        final boolean error = INITIAL_ITEM_ANIMATION_DURATION >= DROP_IN_ANIMATION_DURATION;
-        if (error) {
-            throw new IllegalStateException("DROP_IN_ANIMATION_DURATION must be greater than " +
-                    "INITIAL_ITEM_ANIMATION_DURATION, as sequencing of adding first two items " +
-                    "is dependent on this");
-        }
-
-        DeviceProfile grid = launcher.getDeviceProfile();
-
-        FolderIcon icon = (FolderIcon) LayoutInflater.from(launcher).inflate(resId, group, false);
-        icon.setClipToPadding(false);
-        icon.mFolderName = (BubbleTextView) icon.findViewById(R.id.folder_icon_name);
-        FolderNameUtils.updateFolderTitle(launcher, folderInfo);
-        icon.mFolderName.setText(folderInfo.title);
-        icon.mFolderName.setCompoundDrawablePadding(0);
-        FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) icon.mFolderName.getLayoutParams();
-        lp.topMargin = grid.iconSizePx + grid.iconDrawablePaddingPx;
-
-        // Offset the preview background to center this view accordingly
-        icon.mPreviewBackground = (ImageView) icon.findViewById(R.id.preview_background);
-        lp = (FrameLayout.LayoutParams) icon.mPreviewBackground.getLayoutParams();
-        lp.topMargin = grid.folderBackgroundOffset;
-        lp.width = grid.folderIconSizePx;
-        lp.height = grid.folderIconSizePx;
-
-        icon.setTag(folderInfo);
-        icon.setOnClickListener(launcher);
-        icon.mInfo = folderInfo;
-        icon.mLauncher = launcher;
-        icon.setContentDescription(String.format(launcher.getString(R.string.folder_name_format),
-                folderInfo.title));
-        Folder folder = Folder.fromXml(launcher);
-        folder.setDragController(launcher.getDragController());
-        folder.setFolderIcon(icon);
-        folder.bind(folderInfo);
-        icon.mFolder = folder;
-
-        icon.mFolderRingAnimator = new FolderRingAnimator(launcher, icon);
-        folderInfo.addListener(icon);
-
-        icon.setOnFocusChangeListener(launcher.mFocusHandler);
-        return icon;
-    }
-
-    @Override
-    protected Parcelable onSaveInstanceState() {
-        sStaticValuesDirty = true;
-        return super.onSaveInstanceState();
-    }
-
-    public static class FolderRingAnimator {
-        public int mCellX;
-        public int mCellY;
-        @Thunk CellLayout mCellLayout;
-        public float mOuterRingSize;
-        public float mInnerRingSize;
-        public FolderIcon mFolderIcon = null;
-        public static Drawable sSharedOuterRingDrawable = null;
-        public static Drawable sSharedInnerRingDrawable = null;
-        public static int sPreviewSize = -1;
-        public static int sPreviewPadding = -1;
-
-        private ValueAnimator mAcceptAnimator;
-        private ValueAnimator mNeutralAnimator;
-
-        public FolderRingAnimator(Launcher launcher, FolderIcon folderIcon) {
-            mFolderIcon = folderIcon;
-            Resources res = launcher.getResources();
-
-            // We need to reload the static values when configuration changes in case they are
-            // different in another configuration
-            if (sStaticValuesDirty) {
-                if (Looper.myLooper() != Looper.getMainLooper()) {
-                    throw new RuntimeException("FolderRingAnimator loading drawables on non-UI thread "
-                            + Thread.currentThread());
-                }
-
-                DeviceProfile grid = launcher.getDeviceProfile();
-                sPreviewSize = grid.folderIconSizePx;
-                sPreviewPadding = res.getDimensionPixelSize(R.dimen.folder_preview_padding);
-                sSharedOuterRingDrawable = res.getDrawable(R.drawable.portal_ring_outer);
-                sSharedInnerRingDrawable = res.getDrawable(R.drawable.portal_ring_inner_nolip);
-                sSharedFolderLeaveBehind = res.getDrawable(R.drawable.portal_ring_rest);
-                sStaticValuesDirty = false;
-            }
-        }
-
-        public void animateToAcceptState() {
-            if (mNeutralAnimator != null) {
-                mNeutralAnimator.cancel();
-            }
-            mAcceptAnimator = LauncherAnimUtils.ofFloat(mCellLayout, 0f, 1f);
-            mAcceptAnimator.setDuration(CONSUMPTION_ANIMATION_DURATION);
-
-            final int previewSize = sPreviewSize;
-            mAcceptAnimator.addUpdateListener(new AnimatorUpdateListener() {
-                public void onAnimationUpdate(ValueAnimator animation) {
-                    final float percent = (Float) animation.getAnimatedValue();
-                    mOuterRingSize = (1 + percent * OUTER_RING_GROWTH_FACTOR) * previewSize;
-                    mInnerRingSize = (1 + percent * INNER_RING_GROWTH_FACTOR) * previewSize;
-                    if (mCellLayout != null) {
-                        mCellLayout.invalidate();
-                    }
-                }
-            });
-            mAcceptAnimator.addListener(new AnimatorListenerAdapter() {
-                @Override
-                public void onAnimationStart(Animator animation) {
-                    if (mFolderIcon != null) {
-                        mFolderIcon.mPreviewBackground.setVisibility(INVISIBLE);
-                    }
-                }
-            });
-            mAcceptAnimator.start();
-        }
-
-        public void animateToNaturalState() {
-            if (mAcceptAnimator != null) {
-                mAcceptAnimator.cancel();
-            }
-            mNeutralAnimator = LauncherAnimUtils.ofFloat(mCellLayout, 0f, 1f);
-            mNeutralAnimator.setDuration(CONSUMPTION_ANIMATION_DURATION);
-
-            final int previewSize = sPreviewSize;
-            mNeutralAnimator.addUpdateListener(new AnimatorUpdateListener() {
-                public void onAnimationUpdate(ValueAnimator animation) {
-                    final float percent = (Float) animation.getAnimatedValue();
-                    mOuterRingSize = (1 + (1 - percent) * OUTER_RING_GROWTH_FACTOR) * previewSize;
-                    mInnerRingSize = (1 + (1 - percent) * INNER_RING_GROWTH_FACTOR) * previewSize;
-                    if (mCellLayout != null) {
-                        mCellLayout.invalidate();
-                    }
-                }
-            });
-            mNeutralAnimator.addListener(new AnimatorListenerAdapter() {
-                @Override
-                public void onAnimationEnd(Animator animation) {
-                    if (mCellLayout != null) {
-                        mCellLayout.hideFolderAccept(FolderRingAnimator.this);
-                    }
-                    if (mFolderIcon != null) {
-                        mFolderIcon.mPreviewBackground.setVisibility(VISIBLE);
-                    }
-                }
-            });
-            mNeutralAnimator.start();
-        }
-
-        // Location is expressed in window coordinates
-        public void getCell(int[] loc) {
-            loc[0] = mCellX;
-            loc[1] = mCellY;
-        }
-
-        // Location is expressed in window coordinates
-        public void setCell(int x, int y) {
-            mCellX = x;
-            mCellY = y;
-        }
-
-        public void setCellLayout(CellLayout layout) {
-            mCellLayout = layout;
-        }
-
-        public float getOuterRingSize() {
-            return mOuterRingSize;
-        }
-
-        public float getInnerRingSize() {
-            return mInnerRingSize;
-        }
-    }
-
-    public Folder getFolder() {
-        return mFolder;
-    }
-
-    public FolderInfo getFolderInfo() {
-        return mInfo;
-    }
-
-    private boolean willAcceptItem(ItemInfo item) {
-        final int itemType = item.itemType;
-        return ((itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
-                itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) &&
-                !mFolder.isFull() && item != mInfo && !mInfo.opened);
-    }
-
-    public boolean acceptDrop(Object dragInfo) {
-        final ItemInfo item = (ItemInfo) dragInfo;
-        return !mFolder.isDestroyed() && willAcceptItem(item);
-    }
-
-    public void addItem(ShortcutInfo item) {
-        mInfo.add(item);
-    }
-
-    public void onDragEnter(Object dragInfo) {
-        if (mFolder.isDestroyed() || !willAcceptItem((ItemInfo) dragInfo)) return;
-        CellLayout.LayoutParams lp = (CellLayout.LayoutParams) getLayoutParams();
-        CellLayout layout = (CellLayout) getParent().getParent();
-        mFolderRingAnimator.setCell(lp.cellX, lp.cellY);
-        mFolderRingAnimator.setCellLayout(layout);
-        mFolderRingAnimator.animateToAcceptState();
-        layout.showFolderAccept(mFolderRingAnimator);
-        mOpenAlarm.setOnAlarmListener(mOnOpenListener);
-        if (SPRING_LOADING_ENABLED &&
-                ((dragInfo instanceof AppInfo) || (dragInfo instanceof ShortcutInfo))) {
-            // TODO: we currently don't support spring-loading for PendingAddShortcutInfos even
-            // though widget-style shortcuts can be added to folders. The issue is that we need
-            // to deal with configuration activities which are currently handled in
-            // Workspace#onDropExternal.
-            mOpenAlarm.setAlarm(ON_OPEN_DELAY);
-        }
-        mDragInfo = (ItemInfo) dragInfo;
-    }
-
-    public void onDragOver(Object dragInfo) {
-    }
-
-    OnAlarmListener mOnOpenListener = new OnAlarmListener() {
-        public void onAlarm(Alarm alarm) {
-            ShortcutInfo item;
-            if (mDragInfo instanceof AppInfo) {
-                // Came from all apps -- make a copy.
-                item = ((AppInfo) mDragInfo).makeShortcut();
-                item.spanX = 1;
-                item.spanY = 1;
-            } else {
-                // ShortcutInfo
-                item = (ShortcutInfo) mDragInfo;
-            }
-            mFolder.beginExternalDrag(item);
-            mLauncher.openFolder(FolderIcon.this);
-        }
-    };
-
-    public void performCreateAnimation(final ShortcutInfo destInfo, final View destView,
-            final ShortcutInfo srcInfo, final DragView srcView, Rect dstRect,
-            float scaleRelativeToDragLayer, Runnable postAnimationRunnable) {
-
-        // These correspond two the drawable and view that the icon was dropped _onto_
-        Drawable animateDrawable = getTopDrawable((TextView) destView);
-        computePreviewDrawingParams(animateDrawable.getIntrinsicWidth(),
-                destView.getMeasuredWidth());
-
-        // This will animate the first item from it's position as an icon into its
-        // position as the first item in the preview
-        animateFirstItem(animateDrawable, INITIAL_ITEM_ANIMATION_DURATION, false, null);
-        addItem(destInfo);
-
-        // This will animate the dragView (srcView) into the new folder
-        onDrop(srcInfo, srcView, dstRect, scaleRelativeToDragLayer, 1, postAnimationRunnable, null);
-    }
-
-    public void performDestroyAnimation(final View finalView, Runnable onCompleteRunnable) {
-        Drawable animateDrawable = getTopDrawable((TextView) finalView);
-        computePreviewDrawingParams(animateDrawable.getIntrinsicWidth(),
-                finalView.getMeasuredWidth());
-
-        // This will animate the first item from it's position as an icon into its
-        // position as the first item in the preview
-        animateFirstItem(animateDrawable, FINAL_ITEM_ANIMATION_DURATION, true,
-                onCompleteRunnable);
-    }
-
-    public void onDragExit(Object dragInfo) {
-        onDragExit();
-    }
-
-    public void onDragExit() {
-        mFolderRingAnimator.animateToNaturalState();
-        mOpenAlarm.cancelAlarm();
-    }
-
-    private void onDrop(final ShortcutInfo item, DragView animateView, Rect finalRect,
-            float scaleRelativeToDragLayer, int index, Runnable postAnimationRunnable,
-            DragObject d) {
-        item.cellX = -1;
-        item.cellY = -1;
-
-        // Typically, the animateView corresponds to the DragView; however, if this is being done
-        // after a configuration activity (ie. for a Shortcut being dragged from AllApps) we
-        // will not have a view to animate
-        if (animateView != null) {
-            DragLayer dragLayer = mLauncher.getDragLayer();
-            Rect from = new Rect();
-            dragLayer.getViewRectRelativeToSelf(animateView, from);
-            Rect to = finalRect;
-            if (to == null) {
-                to = new Rect();
-                Workspace workspace = mLauncher.getWorkspace();
-                // Set cellLayout and this to it's final state to compute final animation locations
-                if (getParent() != null) {
-                    workspace.setFinalTransitionTransform((CellLayout) getParent().getParent());
-                }
-                float scaleX = getScaleX();
-                float scaleY = getScaleY();
-                setScaleX(1.0f);
-                setScaleY(1.0f);
-                scaleRelativeToDragLayer = dragLayer.getDescendantRectRelativeToSelf(this, to);
-                // Finished computing final animation locations, restore current state
-                setScaleX(scaleX);
-                setScaleY(scaleY);
-                if (getParent() != null) {
-                    workspace.resetTransitionTransform((CellLayout) getParent().getParent());
-                }
-            }
-
-            int[] center = new int[2];
-            float scale = getLocalCenterForIndex(index, center);
-            center[0] = (int) Math.round(scaleRelativeToDragLayer * center[0]);
-            center[1] = (int) Math.round(scaleRelativeToDragLayer * center[1]);
-
-            to.offset(center[0] - animateView.getMeasuredWidth() / 2,
-                      center[1] - animateView.getMeasuredHeight() / 2);
-
-            float finalAlpha = index < NUM_ITEMS_IN_PREVIEW ? 0.5f : 0f;
-
-            float finalScale = scale * scaleRelativeToDragLayer;
-            dragLayer.animateView(animateView, from, to, finalAlpha,
-                    1, 1, finalScale, finalScale, DROP_IN_ANIMATION_DURATION,
-                    new DecelerateInterpolator(2), new AccelerateInterpolator(2),
-                    postAnimationRunnable, DragLayer.ANIMATION_END_DISAPPEAR, null);
-            addItem(item);
-            mHiddenItems.add(item);
-            mFolder.hideItem(item);
-            postDelayed(new Runnable() {
-                public void run() {
-                    mHiddenItems.remove(item);
-                    mFolder.showItem(item);
-                    invalidate();
-                }
-            }, DROP_IN_ANIMATION_DURATION);
-        } else {
-            addItem(item);
-        }
-    }
-
-    public void onDrop(DragObject d) {
-        ShortcutInfo item;
-        if (d.dragInfo instanceof AppInfo) {
-            // Came from all apps -- make a copy
-            item = ((AppInfo) d.dragInfo).makeShortcut();
-        } else {
-            item = (ShortcutInfo) d.dragInfo;
-        }
-        mFolder.notifyDrop();
-        onDrop(item, d.dragView, null, 1.0f, mInfo.contents.size(), d.postAnimationRunnable, d);
-    }
-
-    private void computePreviewDrawingParams(int drawableSize, int totalSize) {
-        if (mIntrinsicIconSize != drawableSize || mTotalWidth != totalSize) {
-            DeviceProfile grid = mLauncher.getDeviceProfile();
-
-            mIntrinsicIconSize = drawableSize;
-            mTotalWidth = totalSize;
-
-            final int previewSize = mPreviewBackground.getLayoutParams().height;
-            final int previewPadding = FolderRingAnimator.sPreviewPadding;
-
-            mAvailableSpaceInPreview = (previewSize - 2 * previewPadding);
-            // cos(45) = 0.707  + ~= 0.1) = 0.8f
-            int adjustedAvailableSpace = (int) ((mAvailableSpaceInPreview / 2) * (1 + 0.8f));
-
-            int unscaledHeight = (int) (mIntrinsicIconSize * (1 + PERSPECTIVE_SHIFT_FACTOR));
-
-            mBaselineIconScale = (1.0f * adjustedAvailableSpace / unscaledHeight);
-
-            mBaselineIconSize = (int) (mIntrinsicIconSize * mBaselineIconScale);
-            mMaxPerspectiveShift = mBaselineIconSize * PERSPECTIVE_SHIFT_FACTOR;
-
-            mPreviewOffsetX = (mTotalWidth - mAvailableSpaceInPreview) / 2;
-            mPreviewOffsetY = previewPadding + grid.folderBackgroundOffset;
-        }
-    }
-
-    private void computePreviewDrawingParams(Drawable d) {
-        computePreviewDrawingParams(d.getIntrinsicWidth(), getMeasuredWidth());
-    }
-
-    class PreviewItemDrawingParams {
-        PreviewItemDrawingParams(float transX, float transY, float scale, float overlayAlpha) {
-            this.transX = transX;
-            this.transY = transY;
-            this.scale = scale;
-            this.overlayAlpha = overlayAlpha;
-        }
-        float transX;
-        float transY;
-        float scale;
-        float overlayAlpha;
-        Drawable drawable;
-    }
-
-    private float getLocalCenterForIndex(int index, int[] center) {
-        mParams = computePreviewItemDrawingParams(Math.min(NUM_ITEMS_IN_PREVIEW, index), mParams);
-
-        mParams.transX += mPreviewOffsetX;
-        mParams.transY += mPreviewOffsetY;
-        float offsetX = mParams.transX + (mParams.scale * mIntrinsicIconSize) / 2;
-        float offsetY = mParams.transY + (mParams.scale * mIntrinsicIconSize) / 2;
-
-        center[0] = (int) Math.round(offsetX);
-        center[1] = (int) Math.round(offsetY);
-        return mParams.scale;
-    }
-
-    private PreviewItemDrawingParams computePreviewItemDrawingParams(int index,
-            PreviewItemDrawingParams params) {
-        index = NUM_ITEMS_IN_PREVIEW - index - 1;
-        float r = (index * 1.0f) / (NUM_ITEMS_IN_PREVIEW - 1);
-        float scale = (1 - PERSPECTIVE_SCALE_FACTOR * (1 - r));
-
-        float offset = (1 - r) * mMaxPerspectiveShift;
-        float scaledSize = scale * mBaselineIconSize;
-        float scaleOffsetCorrection = (1 - scale) * mBaselineIconSize;
-
-        // We want to imagine our coordinates from the bottom left, growing up and to the
-        // right. This is natural for the x-axis, but for the y-axis, we have to invert things.
-        float transY = mAvailableSpaceInPreview - (offset + scaledSize + scaleOffsetCorrection) + getPaddingTop();
-        float transX = (mAvailableSpaceInPreview - scaledSize) / 2;
-        float totalScale = mBaselineIconScale * scale;
-        final float overlayAlpha = (80 * (1 - r)) / 255f;
-
-        if (params == null) {
-            params = new PreviewItemDrawingParams(transX, transY, totalScale, overlayAlpha);
-        } else {
-            params.transX = transX;
-            params.transY = transY;
-            params.scale = totalScale;
-            params.overlayAlpha = overlayAlpha;
-        }
-        return params;
-    }
-
-    private void drawPreviewItem(Canvas canvas, PreviewItemDrawingParams params, TextView textView) {
-        canvas.save();
-        canvas.translate(params.transX + mPreviewOffsetX, params.transY + mPreviewOffsetY);
-        canvas.scale(params.scale, params.scale);
-        Drawable d = params.drawable;
-
-        if (d != null) {
-            mOldBounds.set(d.getBounds());
-            d.setBounds(0, 0, mIntrinsicIconSize, mIntrinsicIconSize);
-            if (d instanceof FastBitmapDrawable) {
-                FastBitmapDrawable fd = (FastBitmapDrawable) d;
-                float oldBrightness = fd.getBrightness();
-                fd.setBrightness(params.overlayAlpha);
-                d.draw(canvas);
-                fd.setBrightness(oldBrightness);
-            } else {
-                d.setColorFilter(Color.argb((int) (params.overlayAlpha * 255), 255, 255, 255),
-                        PorterDuff.Mode.SRC_ATOP);
-                d.draw(canvas);
-                d.clearColorFilter();
-            }
-            d.setBounds(mOldBounds);
-        }
-        canvas.restore();
-
-        if (FeatureOption.SPRD_DYNAMIC_ICON_SUPPORT) {
-            if (textView != null) {
-                Object tag = textView.getTag();
-                if (tag instanceof ItemInfo) {
-                    ItemInfo info = (ItemInfo) tag;
-                    if (info.dynamicIconDrawCallback != null) {
-                        drawDynamicPartOfIcon(canvas, params, textView);
-                    }
-                }
-            }
-        }
-    }
-
-    private void drawDynamicPartOfIcon(Canvas canvas, PreviewItemDrawingParams params, TextView textView) {
-        float offsetX = params.transX + mPreviewOffsetX + (params.scale * mIntrinsicIconSize) / 2;
-        float offsetY = params.transY + mPreviewOffsetY + (params.scale * mIntrinsicIconSize) / 2;
-        canvas.save();
-        Point center = new Point(Math.round(offsetX), Math.round(offsetY));
-        DynamicIconUtils.drawDynamicIconIfNeed(canvas, textView, params.scale, center);
-        canvas.restore();
-    }
-
-    @Override
-    protected void dispatchDraw(Canvas canvas) {
-        super.dispatchDraw(canvas);
-
-        if (mFolder == null) return;
-        if (mFolder.getItemCount() == 0 && !mAnimating) return;
-
-        ArrayList<View> items = mFolder.getItemsInReadingOrder();
-        Drawable d;
-        TextView v;
-
-        // Update our drawing parameters if necessary
-        if (mAnimating) {
-            computePreviewDrawingParams(mAnimParams.drawable);
-        } else {
-            v = (TextView) items.get(0);
-            d = getTopDrawable(v);
-            computePreviewDrawingParams(d);
-        }
-
-        int nItemsInPreview = Math.min(items.size(), NUM_ITEMS_IN_PREVIEW);
-        if (!mAnimating) {
-            for (int i = nItemsInPreview - 1; i >= 0; i--) {
-                v = (TextView) items.get(i);
-                if (!mHiddenItems.contains(v.getTag())) {
-                    d = getTopDrawable(v);
-                    mParams = computePreviewItemDrawingParams(i, mParams);
-                    mParams.drawable = d;
-                    drawPreviewItem(canvas, mParams, v);
-                }
-            }
-        } else {
-            drawPreviewItem(canvas, mAnimParams, null);
-        }
-        UtilitiesExt.drawDebugRect(canvas, getIconRect(), Color.GREEN);
-        if (FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
-            UnreadLoaderUtils.drawUnreadEventIfNeed(canvas, this);
-        }
-    }
-
-    private Drawable getTopDrawable(TextView v) {
-        Drawable d = v.getCompoundDrawables()[1];
-        return (d instanceof PreloadIconDrawable) ? ((PreloadIconDrawable) d).mIcon : d;
-    }
-
-    private void animateFirstItem(final Drawable d, int duration, final boolean reverse,
-            final Runnable onCompleteRunnable) {
-        final PreviewItemDrawingParams finalParams = computePreviewItemDrawingParams(0, null);
-
-        float iconSize = mLauncher.getDeviceProfile().iconSizePx;
-        final float scale0 = iconSize / d.getIntrinsicWidth() ;
-        final float transX0 = (mAvailableSpaceInPreview - iconSize) / 2;
-        final float transY0 = (mAvailableSpaceInPreview - iconSize) / 2 + getPaddingTop();
-        mAnimParams.drawable = d;
-
-        ValueAnimator va = LauncherAnimUtils.ofFloat(this, 0f, 1.0f);
-        va.addUpdateListener(new AnimatorUpdateListener(){
-            public void onAnimationUpdate(ValueAnimator animation) {
-                float progress = (Float) animation.getAnimatedValue();
-                if (reverse) {
-                    progress = 1 - progress;
-                    mPreviewBackground.setAlpha(progress);
-                }
-
-                mAnimParams.transX = transX0 + progress * (finalParams.transX - transX0);
-                mAnimParams.transY = transY0 + progress * (finalParams.transY - transY0);
-                mAnimParams.scale = scale0 + progress * (finalParams.scale - scale0);
-                invalidate();
-            }
-        });
-        va.addListener(new AnimatorListenerAdapter() {
-            @Override
-            public void onAnimationStart(Animator animation) {
-                mAnimating = true;
-            }
-            @Override
-            public void onAnimationEnd(Animator animation) {
-                mAnimating = false;
-                if (onCompleteRunnable != null) {
-                    onCompleteRunnable.run();
-                }
-            }
-        });
-        va.setDuration(duration);
-        va.start();
-    }
-
-    public void setTextVisible(boolean visible) {
-        if (visible) {
-            mFolderName.setVisibility(VISIBLE);
-        } else {
-            mFolderName.setVisibility(INVISIBLE);
-        }
-    }
-
-    public boolean getTextVisible() {
-        return mFolderName.getVisibility() == VISIBLE;
-    }
-
-    public void onItemsChanged() {
-        invalidate();
-        requestLayout();
-    }
-
-    public void onAdd(ShortcutInfo item) {
-        if (LogUtils.DEBUG) {
-            LogUtils.d(TAG, "onAdd item = " + item);
-        }
-        if (FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
-            UnreadLoaderUtils.updateFolderUnreadNum(this, item.intent.getComponent(), item.unreadNum);
-        }
-        invalidate();
-        requestLayout();
-    }
-
-    public void onRemove(ShortcutInfo item) {
-        if (LogUtils.DEBUG) {
-            LogUtils.d(TAG, "onRemove item = " + item);
-        }
-        if (FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
-            UnreadLoaderUtils.updateFolderUnreadNum(this, item.intent.getComponent(), item.unreadNum);
-        }
-        invalidate();
-        requestLayout();
-    }
-
-    public void onTitleChanged(CharSequence title) {
-        mFolderName.setText(title);
-        setContentDescription(String.format(getContext().getString(R.string.folder_name_format),
-                title));
-    }
-
-    @Override
-    public boolean onTouchEvent(MotionEvent event) {
-        // Call the superclass onTouchEvent first, because sometimes it changes the state to
-        // isPressed() on an ACTION_UP
-        boolean result = super.onTouchEvent(event);
-
-        // Check for a stylus button press, if it occurs cancel any long press checks.
-        if (mStylusEventHelper.checkAndPerformStylusEvent(event)) {
-            mLongPressHelper.cancelLongPress();
-            return true;
-        }
-
-        switch (event.getAction()) {
-            case MotionEvent.ACTION_DOWN:
-                mLongPressHelper.postCheckForLongPress();
-                break;
-            case MotionEvent.ACTION_CANCEL:
-            case MotionEvent.ACTION_UP:
-                mLongPressHelper.cancelLongPress();
-                break;
-            case MotionEvent.ACTION_MOVE:
-                if (!Utilities.pointInView(this, event.getX(), event.getY(), mSlop)) {
-                    mLongPressHelper.cancelLongPress();
-                }
-                break;
-        }
-        return result;
-    }
-
-    @Override
-    protected void onAttachedToWindow() {
-        super.onAttachedToWindow();
-        mSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();
-    }
-
-    @Override
-    public void cancelLongPress() {
-        super.cancelLongPress();
-
-        mLongPressHelper.cancelLongPress();
-    }
-
-    public Rect getIconRect() {
-        DeviceProfile grid = mLauncher.getDeviceProfile();
-        int iconSize = grid.folderIconSizePx;
-
-        Point center = new Point(getScrollX() + (getWidth() >> 1),
-                getScrollY() + getPaddingTop() + (iconSize >> 1));
-        Rect iconRect = new Rect();
-
-        iconRect.left   = center.x - (iconSize >> 1);
-        iconRect.top    = center.y - (iconSize >> 1);
-        iconRect.right  = iconRect.left + iconSize;
-        iconRect.bottom = iconRect.top + iconSize;
-        return iconRect;
-    }
-}
Index: packages/apps/Launcher3/src/com/android/launcher3/InstallShortcutReceiver.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/InstallShortcutReceiver.java	(revision 182200)
+++ packages/apps/Launcher3/src/com/android/launcher3/InstallShortcutReceiver.java	(revision 182201)
@@ -287,12 +287,13 @@
             final UserHandleCompat extraUser = UserHandleCompat.fromIntent(data);
             if (extraUser != null) {
                 long userId = UserManagerCompat.getInstance(mContext).getSerialNumberForUser(extraUser);
+            if (launchIntent != null) {
                 launchIntent.putExtra(ShortcutInfo.EXTRA_PROFILE, userId);
-                if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo extraUser:" + extraUser.toString());
             }
 
+            if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo extraUser:" + extraUser.toString());
             if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo data:" + data.toString());
-            if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo launchIntent:" + launchIntent.toString());
+            if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo launchIntent:" + launchIntent);
         }
 
         /**
Index: packages/apps/Launcher3/src/com/android/launcher3/Launcher.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/Launcher.java	(revision 182200)
+++ packages/apps/Launcher3/src/com/android/launcher3/Launcher.java	(revision 182201)
@@ -222,6 +222,10 @@
     private static final String RUNTIME_STATE_PENDING_ADD_WIDGET_INFO = "launcher.add_widget_info";
     // Type: parcelable
     private static final String RUNTIME_STATE_PENDING_ADD_WIDGET_ID = "launcher.add_widget_id";
+    // Type: boolean
+    private static final String RUNTIME_CREATE_USER_FOLDER_ON_DROP = "launcher.create_folder";
+    // Type: boolean
+    private static final String RUNTIME_ADD_TO_EXISTING_FOLDER_ON_DROP = "launcher.add_to_folder";
 
     static final String INTRO_SCREEN_DISMISSED = "launcher.intro_screen_dismissed";
     static final String FIRST_RUN_ACTIVITY_DISPLAYED = "launcher.first_run_activity_displayed";
@@ -550,6 +554,11 @@
         setupViews();
         mDeviceProfile.layout(this);
 
+        if (FeatureOption.SPRD_CUSTOMIZEAPPSORT_SUPPORT) {
+            CustomizeAppSort.setContext(this);
+            CustomizeAppSort.getInstance().loadCustomizeAppsData();
+        }
+
        if (LogUtils.DEBUG_UNREAD) {
             LogUtils.d(TAG, "launcher unread support:" + FeatureOption.SPRD_UNREAD_INFO_SUPPORT);
         }
@@ -656,7 +665,9 @@
         //SPRD: SPRD_CIRCLE_SLIDE_SUPPORT end }
 
         if(WallpaperChangeController.ALLOW_SHAKE_CHANGE_WALLPAPER_KEY.equals(settings)){
-            mWallpaperChangeController.setShakeWallpaperEnabled((boolean)value);
+            if (mWallpaperChangeController != null) {
+                mWallpaperChangeController.setShakeWallpaperEnabled((boolean) value);
+            }
         }
     }
 
@@ -1529,6 +1540,10 @@
         if (currentScreen != PagedView.INVALID_RESTORE_PAGE) {
             mWorkspace.setRestorePage(currentScreen);
         }
+        mWorkspace.setAddingtoExistingFolderOnDrop(
+                savedState.getBoolean(RUNTIME_ADD_TO_EXISTING_FOLDER_ON_DROP));
+        mWorkspace.setCreatingUserFolderOnDrop(
+                savedState.getBoolean(RUNTIME_CREATE_USER_FOLDER_ON_DROP));
 
         final long pendingAddContainer = savedState.getLong(RUNTIME_STATE_PENDING_ADD_CONTAINER, -1);
         final long pendingAddScreen = savedState.getLong(RUNTIME_STATE_PENDING_ADD_SCREEN, -1);
@@ -1603,4015 +1618,4 @@
         }
 
         // Setup the drag controller (drop targets have to be added in reverse order in priority)
-        dragController.setDragScoller(mWorkspace);
-        dragController.setScrollView(mDragLayer);
-        dragController.setMoveTarget(mWorkspace);
-        dragController.addDropTarget(mWorkspace);
-        if (mSearchDropTargetBar != null) {
-            mSearchDropTargetBar.setup(this, dragController);
-            mSearchDropTargetBar.setQsbSearchBar(getOrCreateQsbBar());
-        }
-
-        if (TestingUtils.MEMORY_DUMP_ENABLED) {
-            TestingUtils.addWeightWatcher(this);
-        }
-    }
-
-    private void setupOverviewPanel() {
-        mOverviewPanel = (ViewGroup) findViewById(R.id.overview_panel);
-
-        // Long-clicking buttons in the overview panel does the same thing as clicking them.
-        OnLongClickListener performClickOnLongClick = new OnLongClickListener() {
-            @Override
-            public boolean onLongClick(View v) {
-                return v.performClick();
-            }
-        };
-
-        // Bind wallpaper button actions
-        View wallpaperButton = findViewById(R.id.wallpaper_button);
-        wallpaperButton.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                if (!mWorkspace.isSwitchingState()) {
-                    onClickWallpaperPicker(view);
-                }
-            }
-        });
-        wallpaperButton.setOnLongClickListener(performClickOnLongClick);
-        wallpaperButton.setOnTouchListener(getHapticFeedbackTouchListener());
-
-        // Bind widget button actions
-        mWidgetsButton = findViewById(R.id.widget_button);
-        mWidgetsButton.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                if (!mWorkspace.isSwitchingState()) {
-                    onClickAddWidgetButton(view);
-                }
-            }
-        });
-        mWidgetsButton.setOnLongClickListener(performClickOnLongClick);
-        mWidgetsButton.setOnTouchListener(getHapticFeedbackTouchListener());
-
-        // Bind settings actions
-        View settingsButton = findViewById(R.id.settings_button);
-        boolean hasSettings = hasSettings();
-        if (hasSettings) {
-            settingsButton.setOnClickListener(new OnClickListener() {
-                @Override
-                public void onClick(View view) {
-                    if (!mWorkspace.isSwitchingState()) {
-                        onClickSettingsButton(view);
-                    }
-                }
-            });
-            settingsButton.setOnLongClickListener(performClickOnLongClick);
-            settingsButton.setOnTouchListener(getHapticFeedbackTouchListener());
-        } else {
-            settingsButton.setVisibility(View.GONE);
-        }
-        mSortAppsButton = (TextView)findViewById(R.id.sort_app_button);
-        mSortAppsButton.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View arg0) {
-                if (!mWorkspace.isSwitchingState()) {
-                    showDialog(DIALOG_SORT_APP);
-                    showAppsView(false /* animated */, false /* resetListToTop */, true /* updatePredictedApps */, false /* focusSearchBar */);
-                }
-            }
-        });
-
-        mOverviewPanel.setAlpha(0f);
-    }
-
-    @Override
-    protected Dialog onCreateDialog(int id) {
-        switch (id) {
-            case DIALOG_SORT_APP:
-                return showAppSortDlg();
-        }
-        return super.onCreateDialog(id);
-    }
-
-    public Dialog showAppSortDlg() {
-        AlertDialog.Builder builder = new AlertDialog.Builder(this);
-        builder.setTitle(getResources().getString(R.string.edit_sort));
-        final String[] items = new String[3];
-        items[0] = getResources().getString(R.string.edit_sort_default);
-        items[1] = getResources().getString(R.string.edit_sort_by_name);
-        items[2] = getResources().getString(R.string.edit_sort_by_install_time);
-        SharedPreferences sortPreference = getSharedPreferences(APPS_SORT_TYPE,
-                Context.MODE_PRIVATE);
-        builder.setSingleChoiceItems(items, sortPreference.getInt(SORT_TYPE_KEY, 0),
-                new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, final int which) {
-                        new Thread(new Runnable() {
-                            @Override
-                            public void run() {
-                                mAppsView.post(new Runnable() {
-                                    public void run() {
-                                        if (mAppsView != null) {
-                                            SharedPreferences.Editor mSharedEditor = getSharedPreferences(
-                                                    APPS_SORT_TYPE, Context.MODE_PRIVATE).edit();
-                                            mSharedEditor.putInt(SORT_TYPE_KEY, which).apply();
-                                            mAppsView.updateApps();
-                                        }
-                                    }
-                                });
-                            }
-                        }).start();
-                        Launcher.this.removeDialog(DIALOG_SORT_APP);
-                    }
-                });
-        builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
-            @Override
-            public void onCancel(DialogInterface dialog) {
-                Launcher.this.removeDialog(DIALOG_SORT_APP);
-            }
-        });
-        AlertDialog ad = builder.create();
-        ad.show();
-        return ad;
-    }
-
-    /**
-     * Sets the all apps button. This method is called from {@link Hotseat}.
-     */
-    public void setAllAppsButton(View allAppsButton) {
-        mAllAppsButton = allAppsButton;
-    }
-
-    public View getAllAppsButton() {
-        return mAllAppsButton;
-    }
-
-    public View getWidgetsButton() {
-        return mWidgetsButton;
-    }
-
-    /**
-     * Creates a view representing a shortcut.
-     *
-     * @param info The data structure describing the shortcut.
-     */
-    View createShortcut(ShortcutInfo info) {
-        return createShortcut((ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentPage()), info);
-    }
-
-    /**
-     * Creates a view representing a shortcut inflated from the specified resource.
-     *
-     * @param parent The group the shortcut belongs to.
-     * @param info The data structure describing the shortcut.
-     *
-     * @return A View inflated from layoutResId.
-     */
-    public View createShortcut(ViewGroup parent, ShortcutInfo info) {
-        BubbleTextView favorite = (BubbleTextView) mInflater.inflate(R.layout.app_icon,
-            parent, false);
-
-        if (mDynamicIconUtils != null && info != null && info.intent != null) {
-            ComponentName cn = info.intent.getComponent();
-            Drawable d = mDynamicIconUtils.getStableBGForComponent(cn);
-            if (d != null) {
-                info.setIcon(Utilities.createIconBitmap(d, Launcher.this));
-                info.dynamicIconDrawCallback = mDynamicIconUtils.getDIDCForComponent(cn);
-                info.customIcon = true;
-                LogUtils.d(TAG, "createShortcut: dynamic icon, intent = " + info.intent);
-            }
-        }
-
-        favorite.applyFromShortcutInfo(info, mIconCache);
-        favorite.setCompoundDrawablePadding(mDeviceProfile.iconDrawablePaddingPx);
-        favorite.setOnClickListener(this);
-        favorite.setOnFocusChangeListener(mFocusHandler);
-        return favorite;
-    }
-
-    /**
-     * Add a shortcut to the workspace.
-     *
-     * @param data The intent describing the shortcut.
-     */
-    private void completeAddShortcut(Intent data, long container, long screenId, int cellX,
-            int cellY) {
-        int[] cellXY = mTmpAddItemCellCoordinates;
-        int[] touchXY = mPendingAddInfo.dropPos;
-        CellLayout layout = getCellLayout(container, screenId);
-
-        ShortcutInfo info = InstallShortcutReceiver.fromShortcutIntent(this, data);
-        if (info == null || mPendingAddInfo.componentName == null) {
-            return;
-        }
-        if (!PackageManagerHelper.hasPermissionForActivity(
-                this, info.intent, mPendingAddInfo.componentName.getPackageName())) {
-            // The app is trying to add a shortcut without sufficient permissions
-            Log.e(TAG, "Ignoring malicious intent " + info.intent.toUri(0));
-            return;
-        }
-        final View view = createShortcut(info);
-
-        boolean foundCellSpan = false;
-        // First we check if we already know the exact location where we want to add this item.
-        if (cellX >= 0 && cellY >= 0) {
-            cellXY[0] = cellX;
-            cellXY[1] = cellY;
-            foundCellSpan = true;
-
-            // If appropriate, either create a folder or add to an existing folder
-            if (mWorkspace.createUserFolderIfNecessary(view, container, layout, cellXY, 0,
-                    true, null,null)) {
-                return;
-            }
-            DragObject dragObject = new DragObject();
-            dragObject.dragInfo = info;
-            if (mWorkspace.addToExistingFolderIfNecessary(view, layout, cellXY, 0, dragObject,
-                    true)) {
-                return;
-            }
-        } else if (touchXY != null) {
-            // when dragging and dropping, just find the closest free spot
-            int[] result = layout.findNearestVacantArea(touchXY[0], touchXY[1], 1, 1, cellXY);
-            foundCellSpan = (result != null);
-        } else {
-            foundCellSpan = layout.findCellForSpan(cellXY, 1, 1);
-        }
-
-        if (!foundCellSpan) {
-            showOutOfSpaceMessage(isHotseatLayout(layout));
-            return;
-        }
-
-        LauncherModel.addItemToDatabase(this, info, container, screenId, cellXY[0], cellXY[1]);
-
-        if (!mRestoring) {
-            mWorkspace.addInScreen(view, container, screenId, cellXY[0], cellXY[1], 1, 1,
-                    isWorkspaceLocked());
-        }
-    }
-
-    /**
-     * Add a widget to the workspace.
-     *
-     * @param appWidgetId The app widget id
-     */
-    @Thunk void completeAddAppWidget(int appWidgetId, long container, long screenId,
-            AppWidgetHostView hostView, LauncherAppWidgetProviderInfo appWidgetInfo) {
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "completeAddAppWidget: appWidgetId = " + appWidgetId
-                    + ", container = " + container + ", screenId = " + screenId);
-        }
-
-        ItemInfo info = mPendingAddInfo;
-        if (appWidgetInfo == null) {
-            appWidgetInfo = mAppWidgetManager.getLauncherAppWidgetInfo(appWidgetId);
-        }
-
-        if (appWidgetInfo.isCustomWidget) {
-            appWidgetId = LauncherAppWidgetInfo.CUSTOM_WIDGET_ID;
-        }
-
-        LauncherAppWidgetInfo launcherInfo;
-        launcherInfo = new LauncherAppWidgetInfo(appWidgetId, appWidgetInfo.provider);
-        launcherInfo.spanX = info.spanX;
-        launcherInfo.spanY = info.spanY;
-        launcherInfo.minSpanX = info.minSpanX;
-        launcherInfo.minSpanY = info.minSpanY;
-        launcherInfo.user = mAppWidgetManager.getUser(appWidgetInfo);
-
-        LauncherModel.addItemToDatabase(this, launcherInfo,
-                container, screenId, info.cellX, info.cellY);
-
-        if (!mRestoring) {
-            if (hostView == null) {
-                // Perform actual inflation because we're live
-                launcherInfo.hostView = mAppWidgetHost.createView(this, appWidgetId,
-                        appWidgetInfo);
-            } else {
-                // The AppWidgetHostView has already been inflated and instantiated
-                launcherInfo.hostView = hostView;
-            }
-            launcherInfo.hostView.setVisibility(View.VISIBLE);
-            addAppWidgetToWorkspace(launcherInfo, appWidgetInfo, isWorkspaceLocked());
-        }
-        resetAddInfo();
-    }
-
-    private void addAppWidgetToWorkspace(LauncherAppWidgetInfo item,
-            LauncherAppWidgetProviderInfo appWidgetInfo, boolean insert) {
-        item.hostView.setTag(item);
-        item.onBindAppWidget(this);
-
-        item.hostView.setFocusable(true);
-        item.hostView.setOnFocusChangeListener(mFocusHandler);
-
-        mWorkspace.addInScreen(item.hostView, item.container, item.screenId,
-                item.cellX, item.cellY, item.spanX, item.spanY, insert);
-
-        if (!item.isCustomWidget()) {
-            addWidgetToAutoAdvanceIfNeeded(item.hostView, appWidgetInfo);
-        }
-    }
-
-    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            final String action = intent.getAction();
-            if (Intent.ACTION_SCREEN_OFF.equals(action)) {
-                mUserPresent = false;
-                mDragLayer.clearAllResizeFrames();
-                updateAutoAdvanceState();
-
-                // Reset AllApps to its initial state only if we are not in the middle of
-                // processing a multi-step drop
-                if (mAppsView != null && mWidgetsView != null &&
-                        mPendingAddInfo.container == ItemInfo.NO_ID) {
-                    if (!showWorkspace(false)) {
-                        // If we are already on the workspace, then manually reset all apps
-                        mAppsView.reset();
-                    }
-                }
-            } else if (Intent.ACTION_USER_PRESENT.equals(action)) {
-                mUserPresent = true;
-                updateAutoAdvanceState();
-            } else if (ENABLE_DEBUG_INTENTS && DebugIntents.DELETE_DATABASE.equals(action)) {
-                mModel.resetLoadedState(false, true);
-                mModel.startLoader(PagedView.INVALID_RESTORE_PAGE,
-                        LauncherModel.LOADER_FLAG_CLEAR_WORKSPACE);
-            } else if (ENABLE_DEBUG_INTENTS && DebugIntents.MIGRATE_DATABASE.equals(action)) {
-                mModel.resetLoadedState(false, true);
-                mModel.startLoader(PagedView.INVALID_RESTORE_PAGE,
-                        LauncherModel.LOADER_FLAG_CLEAR_WORKSPACE
-                                | LauncherModel.LOADER_FLAG_MIGRATE_SHORTCUTS);
-            }
-        }
-    };
-
-    @Override
-    public void onAttachedToWindow() {
-        super.onAttachedToWindow();
-
-        // Listen for broadcasts related to user-presence
-        final IntentFilter filter = new IntentFilter();
-        filter.addAction(Intent.ACTION_SCREEN_OFF);
-        filter.addAction(Intent.ACTION_USER_PRESENT);
-        // For handling managed profiles
-        if (ENABLE_DEBUG_INTENTS) {
-            filter.addAction(DebugIntents.DELETE_DATABASE);
-            filter.addAction(DebugIntents.MIGRATE_DATABASE);
-        }
-        registerReceiver(mReceiver, filter);
-        FirstFrameAnimatorHelper.initializeDrawListener(getWindow().getDecorView());
-        mAttached = true;
-        mVisible = true;
-
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.onAttachedToWindow();
-        }
-    }
-
-    @Override
-    public void onDetachedFromWindow() {
-        super.onDetachedFromWindow();
-        mVisible = false;
-
-        if (mAttached) {
-            unregisterReceiver(mReceiver);
-            mAttached = false;
-        }
-        updateAutoAdvanceState();
-
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.onDetachedFromWindow();
-        }
-    }
-
-    public void onWindowVisibilityChanged(int visibility) {
-        mVisible = visibility == View.VISIBLE;
-        updateAutoAdvanceState();
-        // The following code used to be in onResume, but it turns out onResume is called when
-        // you're in All Apps and click home to go to the workspace. onWindowVisibilityChanged
-        // is a more appropriate event to handle
-        if (mVisible) {
-            if (!mWorkspaceLoading) {
-                final ViewTreeObserver observer = mWorkspace.getViewTreeObserver();
-                // We want to let Launcher draw itself at least once before we force it to build
-                // layers on all the workspace pages, so that transitioning to Launcher from other
-                // apps is nice and speedy.
-                observer.addOnDrawListener(new ViewTreeObserver.OnDrawListener() {
-                    private boolean mStarted = false;
-                    public void onDraw() {
-                        if (mStarted) return;
-                        mStarted = true;
-                        // We delay the layer building a bit in order to give
-                        // other message processing a time to run.  In particular
-                        // this avoids a delay in hiding the IME if it was
-                        // currently shown, because doing that may involve
-                        // some communication back with the app.
-                        mWorkspace.postDelayed(mBuildLayersRunnable, 500);
-                        final ViewTreeObserver.OnDrawListener listener = this;
-                        mWorkspace.post(new Runnable() {
-                            public void run() {
-                                if (mWorkspace != null &&
-                                        mWorkspace.getViewTreeObserver() != null) {
-                                    mWorkspace.getViewTreeObserver().
-                                            removeOnDrawListener(listener);
-                                }
-                            }
-                        });
-                        return;
-                    }
-                });
-            }
-            clearTypedText();
-        }
-    }
-
-    @Thunk void sendAdvanceMessage(long delay) {
-        mHandler.removeMessages(ADVANCE_MSG);
-        Message msg = mHandler.obtainMessage(ADVANCE_MSG);
-        mHandler.sendMessageDelayed(msg, delay);
-        mAutoAdvanceSentTime = System.currentTimeMillis();
-    }
-
-    @Thunk void updateAutoAdvanceState() {
-        boolean autoAdvanceRunning = mVisible && mUserPresent && !mWidgetsToAdvance.isEmpty();
-        if (autoAdvanceRunning != mAutoAdvanceRunning) {
-            mAutoAdvanceRunning = autoAdvanceRunning;
-            if (autoAdvanceRunning) {
-                long delay = mAutoAdvanceTimeLeft == -1 ? mAdvanceInterval : mAutoAdvanceTimeLeft;
-                sendAdvanceMessage(delay);
-            } else {
-                if (!mWidgetsToAdvance.isEmpty()) {
-                    mAutoAdvanceTimeLeft = Math.max(0, mAdvanceInterval -
-                            (System.currentTimeMillis() - mAutoAdvanceSentTime));
-                }
-                mHandler.removeMessages(ADVANCE_MSG);
-                mHandler.removeMessages(0); // Remove messages sent using postDelayed()
-            }
-        }
-    }
-
-    @Thunk final Handler mHandler = new Handler(new Handler.Callback() {
-
-        @Override
-        public boolean handleMessage(Message msg) {
-            if (msg.what == ADVANCE_MSG) {
-                int i = 0;
-                for (View key: mWidgetsToAdvance.keySet()) {
-                    final View v = key.findViewById(mWidgetsToAdvance.get(key).autoAdvanceViewId);
-                    final int delay = mAdvanceStagger * i;
-                    if (v instanceof Advanceable) {
-                        mHandler.postDelayed(new Runnable() {
-                           public void run() {
-                               ((Advanceable) v).advance();
-                           }
-                       }, delay);
-                    }
-                    i++;
-                }
-                sendAdvanceMessage(mAdvanceInterval);
-            }
-            return true;
-        }
-    });
-
-    private void addWidgetToAutoAdvanceIfNeeded(View hostView, AppWidgetProviderInfo appWidgetInfo) {
-        if (appWidgetInfo == null || appWidgetInfo.autoAdvanceViewId == -1) return;
-        View v = hostView.findViewById(appWidgetInfo.autoAdvanceViewId);
-        if (v instanceof Advanceable) {
-            mWidgetsToAdvance.put(hostView, appWidgetInfo);
-            ((Advanceable) v).fyiWillBeAdvancedByHostKThx();
-            updateAutoAdvanceState();
-        }
-    }
-
-    private void removeWidgetToAutoAdvance(View hostView) {
-        if (mWidgetsToAdvance.containsKey(hostView)) {
-            mWidgetsToAdvance.remove(hostView);
-            updateAutoAdvanceState();
-        }
-    }
-
-    public void showOutOfSpaceMessage(boolean isHotseatLayout) {
-        int strId = (isHotseatLayout ? R.string.hotseat_out_of_space : R.string.out_of_space);
-        Toast.makeText(this, getString(strId), Toast.LENGTH_SHORT).show();
-    }
-
-    public DragLayer getDragLayer() {
-        return mDragLayer;
-    }
-
-    public AllAppsContainerView getAppsView() {
-        return mAppsView;
-    }
-
-    public WidgetsContainerView getWidgetsView() {
-        return mWidgetsView;
-    }
-
-    public Workspace getWorkspace() {
-        return mWorkspace;
-    }
-
-    public Hotseat getHotseat() {
-        return mHotseat;
-    }
-
-    public ViewGroup getOverviewPanel() {
-        return mOverviewPanel;
-    }
-
-    public SearchDropTargetBar getSearchDropTargetBar() {
-        return mSearchDropTargetBar;
-    }
-
-    public LauncherAppWidgetHost getAppWidgetHost() {
-        return mAppWidgetHost;
-    }
-
-    public LauncherModel getModel() {
-        return mModel;
-    }
-
-    protected SharedPreferences getSharedPrefs() {
-        return mSharedPrefs;
-    }
-
-    public DeviceProfile getDeviceProfile() {
-        return mDeviceProfile;
-    }
-
-    public void closeSystemDialogs() {
-        getWindow().closeAllPanels();
-
-        // Whatever we were doing is hereby canceled.
-        setWaitingForResult(false);
-    }
-
-    @Override
-    protected void onNewIntent(Intent intent) {
-        long startTime = 0;
-        if (DEBUG_RESUME_TIME) {
-            startTime = System.currentTimeMillis();
-        }
-        super.onNewIntent(intent);
-
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "onNewIntent: intent = " + intent);
-        }
-
-        // Close the menu
-        Folder openFolder = mWorkspace.getOpenFolder();
-        boolean alreadyOnHome = mHasFocus && ((intent.getFlags() &
-                Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT)
-                != Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
-        boolean isActionMain = Intent.ACTION_MAIN.equals(intent.getAction());
-        if (isActionMain) {
-            // also will cancel mWaitingForResult.
-            closeSystemDialogs();
-
-            if (mWorkspace == null) {
-                // Can be cases where mWorkspace is null, this prevents a NPE
-                return;
-            }
-            // In all these cases, only animate if we're already on home
-            mWorkspace.exitWidgetResizeMode();
-
-            closeFolder(alreadyOnHome);
-            exitSpringLoadedDragMode();
-
-            // If we are already on home, then just animate back to the workspace,
-            // otherwise, just wait until onResume to set the state back to Workspace
-            if (alreadyOnHome) {
-                showWorkspace(true);
-            } else {
-                mOnResumeState = State.WORKSPACE;
-            }
-
-            final View v = getWindow().peekDecorView();
-            if (v != null && v.getWindowToken() != null) {
-                InputMethodManager imm = (InputMethodManager) getSystemService(
-                        INPUT_METHOD_SERVICE);
-                imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
-            }
-
-            // Reset the apps view
-            if (!alreadyOnHome && mAppsView != null) {
-                mAppsView.scrollToTop();
-            }
-
-            // Reset the widgets view
-            if (!alreadyOnHome && mWidgetsView != null) {
-                mWidgetsView.scrollToTop();
-            }
-
-            if (mLauncherCallbacks != null) {
-                mLauncherCallbacks.onHomeIntent();
-            }
-        }
-
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.onNewIntent(intent);
-        }
-
-        // Defer moving to the default screen until after we callback to the LauncherCallbacks
-        // as slow logic in the callbacks eat into the time the scroller expects for the snapToPage
-        // animation.
-        if (isActionMain) {
-            boolean moveToDefaultScreen = mLauncherCallbacks != null ?
-                    mLauncherCallbacks.shouldMoveToDefaultScreenOnHomeIntent() : true;
-            if (alreadyOnHome && mState == State.WORKSPACE && !mWorkspace.isTouchActive() &&
-                    openFolder == null && moveToDefaultScreen) {
-
-                // We use this flag to suppress noisy callbacks above custom content state
-                // from onResume.
-                mMoveToDefaultScreenFromNewIntent = true;
-                mWorkspace.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        if (mWorkspace != null) {
-                            mWorkspace.moveToDefaultScreen(true);
-                        }
-                    }
-                });
-            }
-        }
-
-        if (DEBUG_RESUME_TIME) {
-            Log.d(TAG, "Time spent in onNewIntent: " + (System.currentTimeMillis() - startTime));
-        }
-    }
-
-    @Override
-    public void onRestoreInstanceState(Bundle state) {
-        super.onRestoreInstanceState(state);
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "onRestoreInstanceState: state = " + state
-                    + ", mSavedInstanceState = " + mSavedInstanceState);
-        }
-        for (int page: mSynchronouslyBoundPages) {
-            mWorkspace.restoreInstanceStateForChild(page);
-        }
-    }
-
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        // Catches the case where our activity is created and immediately destroyed and our views
-        // are not yet fully bound. In this case, we can't trust the state of our activity and
-        // instead save our previous state (which hasn't yet been consumed / applied, a fact we
-        // know as it's not null)
-        if (isWorkspaceLoading() && mSavedState != null) {
-            outState.putAll(mSavedState);
-            return;
-        }
-
-        if (mWorkspace.getChildCount() > 0) {
-            mSharedPrefs.edit().putInt(RUNTIME_STATE_CURRENT_SCREEN,
-                            mWorkspace.getCurrentPageOffsetFromCustomContent()).apply();
-        }
-        super.onSaveInstanceState(outState);
-
-        outState.putInt(RUNTIME_STATE, mState.ordinal());
-        // We close any open folder since it will not be re-opened, and we need to make sure
-        // this state is reflected.
-        closeFolder(false);
-
-        if (mPendingAddInfo.container != ItemInfo.NO_ID && mPendingAddInfo.screenId > -1 &&
-                (mWaitingForResult)) {
-            outState.putLong(RUNTIME_STATE_PENDING_ADD_CONTAINER, mPendingAddInfo.container);
-            outState.putLong(RUNTIME_STATE_PENDING_ADD_SCREEN, mPendingAddInfo.screenId);
-            outState.putInt(RUNTIME_STATE_PENDING_ADD_CELL_X, mPendingAddInfo.cellX);
-            outState.putInt(RUNTIME_STATE_PENDING_ADD_CELL_Y, mPendingAddInfo.cellY);
-            outState.putInt(RUNTIME_STATE_PENDING_ADD_SPAN_X, mPendingAddInfo.spanX);
-            outState.putInt(RUNTIME_STATE_PENDING_ADD_SPAN_Y, mPendingAddInfo.spanY);
-            outState.putParcelable(RUNTIME_STATE_PENDING_ADD_COMPONENT,
-                    mPendingAddInfo.componentName);
-            outState.putParcelable(RUNTIME_STATE_PENDING_ADD_WIDGET_INFO, mPendingAddWidgetInfo);
-            outState.putInt(RUNTIME_STATE_PENDING_ADD_WIDGET_ID, mPendingAddWidgetId);
-        }
-
-        // Save the current widgets tray?
-        // TODO(hyunyoungs)
-        // SPRD:598450 There is a empty screen when roating the screen
-        outState.putBoolean(HASCONFIGWIDGET, mHasConfigWidget);
-
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.onSaveInstanceState(outState);
-        }
-
-        if (mPredictedAppController != null) {
-            mPredictedAppController.savePredictedList();
-        }
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "(Launcher)onDestroy: this = " + this);
-        }
-
-        if (mPredictedAppController != null) {
-            mPredictedAppController.savePredictedList();
-        }
-
-        // Remove all pending runnables
-        mHandler.removeMessages(ADVANCE_MSG);
-        mHandler.removeMessages(0);
-        mWorkspace.removeCallbacks(mBuildLayersRunnable);
-
-        // Stop callbacks from LauncherModel
-        LauncherAppState app = (LauncherAppState.getInstance());
-
-        if (mDynamicIconUtils != null) {
-            mDynamicIconUtils.destroy();
-            mDynamicIconUtils = null;
-        }
-
-        // It's possible to receive onDestroy after a new Launcher activity has
-        // been created. In this case, don't interfere with the new Launcher.
-        if (mModel.isCurrentCallbacks(this)) {
-            mModel.stopLoader();
-            app.setLauncher(null);
-        }
-
-        try {
-            mAppWidgetHost.stopListening();
-        } catch (NullPointerException ex) {
-            Log.w(TAG, "problem while stopping AppWidgetHost during Launcher destruction", ex);
-        }
-        mAppWidgetHost = null;
-
-        mWidgetsToAdvance.clear();
-
-        TextKeyListener.getInstance().release();
-
-        if (mUnreadLoaderUtils != null) {
-            unregisterReceiver( mUnreadLoaderUtils);
-        }
-        unregisterReceiver(mCloseSystemDialogsReceiver);
-
-        mDragLayer.clearAllResizeFrames();
-
-        /* SPRD: bug608160 @{ */
-        mDragLayer.clearAnimation();
-        mDragLayer.clearAnimatedView();
-        /* @} */
-
-        ((ViewGroup) mWorkspace.getParent()).removeAllViews();
-        mWorkspace.removeAllWorkspaceScreens();
-        mWorkspace = null;
-        mDragController = null;
-
-        LauncherAnimUtils.onDestroyActivity();
-
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.onDestroy();
-        }
-
-
-        unRegisterListener();
-        if (mMotionSound != null) {
-            mMotionSound.stop();
-            mMotionSound.release();
-            mMotionSound = null;
-        }
-    }
-
-    public DragController getDragController() {
-        return mDragController;
-    }
-
-    @Override
-    public void startActivityForResult(Intent intent, int requestCode) {
-        onStartForResult(requestCode);
-        super.startActivityForResult(intent, requestCode);
-    }
-
-    @Override
-    public void startIntentSenderForResult (IntentSender intent, int requestCode,
-            Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options) {
-        onStartForResult(requestCode);
-        try {
-            super.startIntentSenderForResult(intent, requestCode,
-                fillInIntent, flagsMask, flagsValues, extraFlags, options);
-        } catch (IntentSender.SendIntentException e) {
-            throw new ActivityNotFoundException();
-        }
-    }
-
-    private void onStartForResult(int requestCode) {
-        if (requestCode >= 0) {
-            setWaitingForResult(true);
-        }
-    }
-
-    /**
-     * Indicates that we want global search for this activity by setting the globalSearch
-     * argument for {@link #startSearch} to true.
-     */
-    @Override
-    public void startSearch(String initialQuery, boolean selectInitialQuery,
-            Bundle appSearchData, boolean globalSearch) {
-
-        if (initialQuery == null) {
-            // Use any text typed in the launcher as the initial query
-            initialQuery = getTypedText();
-        }
-        if (appSearchData == null) {
-            appSearchData = new Bundle();
-            appSearchData.putString("source", "launcher-search");
-        }
-        Rect sourceBounds = new Rect();
-        if (mSearchDropTargetBar != null) {
-            sourceBounds = mSearchDropTargetBar.getSearchBarBounds();
-        }
-
-        boolean clearTextImmediately = startSearch(initialQuery, selectInitialQuery,
-                appSearchData, sourceBounds);
-        if (clearTextImmediately) {
-            clearTypedText();
-        }
-
-        // We need to show the workspace after starting the search
-        showWorkspace(true);
-    }
-
-    /**
-     * Start a text search.
-     *
-     * @return {@code true} if the search will start immediately, so any further keypresses
-     * will be handled directly by the search UI. {@code false} if {@link Launcher} should continue
-     * to buffer keypresses.
-     */
-    public boolean startSearch(String initialQuery,
-            boolean selectInitialQuery, Bundle appSearchData, Rect sourceBounds) {
-        if (mLauncherCallbacks != null && mLauncherCallbacks.providesSearch()) {
-            return mLauncherCallbacks.startSearch(initialQuery, selectInitialQuery, appSearchData,
-                    sourceBounds);
-        }
-
-        startGlobalSearch(initialQuery, selectInitialQuery,
-                appSearchData, sourceBounds);
-        return false;
-    }
-
-    /**
-     * Starts the global search activity. This code is a copied from SearchManager
-     */
-    private void startGlobalSearch(String initialQuery,
-            boolean selectInitialQuery, Bundle appSearchData, Rect sourceBounds) {
-        final SearchManager searchManager =
-            (SearchManager) getSystemService(Context.SEARCH_SERVICE);
-        ComponentName globalSearchActivity = searchManager.getGlobalSearchActivity();
-        if (globalSearchActivity == null) {
-            Log.w(TAG, "No global search activity found.");
-            return;
-        }
-        Intent intent = new Intent(SearchManager.INTENT_ACTION_GLOBAL_SEARCH);
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        intent.setComponent(globalSearchActivity);
-        // Make sure that we have a Bundle to put source in
-        if (appSearchData == null) {
-            appSearchData = new Bundle();
-        } else {
-            appSearchData = new Bundle(appSearchData);
-        }
-        // Set source to package name of app that starts global search if not set already.
-        if (!appSearchData.containsKey("source")) {
-            appSearchData.putString("source", getPackageName());
-        }
-        intent.putExtra(SearchManager.APP_DATA, appSearchData);
-        if (!TextUtils.isEmpty(initialQuery)) {
-            intent.putExtra(SearchManager.QUERY, initialQuery);
-        }
-        if (selectInitialQuery) {
-            intent.putExtra(SearchManager.EXTRA_SELECT_QUERY, selectInitialQuery);
-        }
-        intent.setSourceBounds(sourceBounds);
-        try {
-            startActivity(intent);
-        } catch (ActivityNotFoundException ex) {
-            Log.e(TAG, "Global search activity not found: " + globalSearchActivity);
-        }
-    }
-
-    public boolean isOnCustomContent() {
-        return mWorkspace.isOnOrMovingToCustomContent();
-    }
-
-    @Override
-    public boolean onPrepareOptionsMenu(Menu menu) {
-        super.onPrepareOptionsMenu(menu);
-        if (mLauncherCallbacks != null) {
-            return mLauncherCallbacks.onPrepareOptionsMenu(menu);
-        }
-        return false;
-    }
-
-    @Override
-    public boolean onSearchRequested() {
-        startSearch(null, false, null, true);
-        // Use a custom animation for launching search
-        return true;
-    }
-
-    public boolean isWorkspaceLocked() {
-        return mWorkspaceLoading || mWaitingForResult;
-    }
-
-    public boolean isWorkspaceLoading() {
-        return mWorkspaceLoading;
-    }
-
-    private void setWorkspaceLoading(boolean value) {
-        boolean isLocked = isWorkspaceLocked();
-        mWorkspaceLoading = value;
-        if (isLocked != isWorkspaceLocked()) {
-            onWorkspaceLockedChanged();
-        }
-    }
-
-    private void setWaitingForResult(boolean value) {
-        boolean isLocked = isWorkspaceLocked();
-        mWaitingForResult = value;
-        if (isLocked != isWorkspaceLocked()) {
-            onWorkspaceLockedChanged();
-        }
-    }
-
-    protected void onWorkspaceLockedChanged() {
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.onWorkspaceLockedChanged();
-        }
-    }
-
-    private void resetAddInfo() {
-        mPendingAddInfo.container = ItemInfo.NO_ID;
-        mPendingAddInfo.screenId = -1;
-        mPendingAddInfo.cellX = mPendingAddInfo.cellY = -1;
-        mPendingAddInfo.spanX = mPendingAddInfo.spanY = -1;
-        mPendingAddInfo.minSpanX = mPendingAddInfo.minSpanY = 1;
-        mPendingAddInfo.dropPos = null;
-        mPendingAddInfo.componentName = null;
-    }
-
-    void addAppWidgetFromDropImpl(final int appWidgetId, final ItemInfo info, final
-            AppWidgetHostView boundWidget, final LauncherAppWidgetProviderInfo appWidgetInfo) {
-        if (LOGD) {
-            Log.d(TAG, "Adding widget from drop");
-        }
-        addAppWidgetImpl(appWidgetId, info, boundWidget, appWidgetInfo, 0);
-    }
-
-    void addAppWidgetImpl(final int appWidgetId, final ItemInfo info,
-            final AppWidgetHostView boundWidget, final LauncherAppWidgetProviderInfo appWidgetInfo,
-            int delay) {
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "addAppWidgetImpl: appWidgetId = " + appWidgetId
-                    + ", info = " + info + ", boundWidget = " + boundWidget
-                    + ", appWidgetInfo = " + appWidgetInfo + ", delay = " + delay);
-        }
-        if (appWidgetInfo.configure != null) {
-            mPendingAddWidgetInfo = appWidgetInfo;
-            mPendingAddWidgetId = appWidgetId;
-
-            // SPRD:598450 There is a empty screen when roating the screen
-            mHasConfigWidget = true;
-            // Launch over to configure widget, if needed
-            mAppWidgetManager.startConfigActivity(appWidgetInfo, appWidgetId, this,
-                    mAppWidgetHost, REQUEST_CREATE_APPWIDGET);
-
-        } else {
-            // Otherwise just add it
-            Runnable onComplete = new Runnable() {
-                @Override
-                public void run() {
-                    // Exit spring loaded mode if necessary after adding the widget
-                    exitSpringLoadedDragModeDelayed(true, EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT,
-                            null);
-                }
-            };
-            completeAddAppWidget(appWidgetId, info.container, info.screenId, boundWidget,
-                    appWidgetInfo);
-            mWorkspace.removeExtraEmptyScreenDelayed(true, onComplete, delay, false);
-        }
-    }
-
-    protected void moveToCustomContentScreen(boolean animate) {
-        // Close any folders that may be open.
-        closeFolder();
-        mWorkspace.moveToCustomContentScreen(animate);
-    }
-
-    public void addPendingItem(PendingAddItemInfo info, long container, long screenId,
-            int[] cell, int spanX, int spanY) {
-        switch (info.itemType) {
-            case LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET:
-            case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
-                int span[] = new int[2];
-                span[0] = spanX;
-                span[1] = spanY;
-                addAppWidgetFromDrop((PendingAddWidgetInfo) info,
-                        container, screenId, cell, span);
-                break;
-            case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
-                processShortcutFromDrop(info.componentName, container, screenId, cell);
-                break;
-            default:
-                throw new IllegalStateException("Unknown item type: " + info.itemType);
-            }
-    }
-
-    /**
-     * Process a shortcut drop.
-     *
-     * @param componentName The name of the component
-     * @param screenId The ID of the screen where it should be added
-     * @param cell The cell it should be added to, optional
-     */
-    private void processShortcutFromDrop(ComponentName componentName, long container, long screenId,
-            int[] cell) {
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "processShortcutFromDrop componentName = " + componentName + ", container = " + container
-                    + ", screenId = " + screenId);
-        }
-        resetAddInfo();
-        mPendingAddInfo.container = container;
-        mPendingAddInfo.screenId = screenId;
-        mPendingAddInfo.dropPos = null;
-        mPendingAddInfo.componentName = componentName;
-
-        if (cell != null) {
-            mPendingAddInfo.cellX = cell[0];
-            mPendingAddInfo.cellY = cell[1];
-        }
-
-        Intent createShortcutIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
-        createShortcutIntent.setComponent(componentName);
-        Utilities.startActivityForResultSafely(this, createShortcutIntent, REQUEST_CREATE_SHORTCUT);
-    }
-
-    /**
-     * Process a widget drop.
-     *
-     * @param info The PendingAppWidgetInfo of the widget being added.
-     * @param screenId The ID of the screen where it should be added
-     * @param cell The cell it should be added to, optional
-     */
-    private void addAppWidgetFromDrop(PendingAddWidgetInfo info, long container, long screenId,
-            int[] cell, int[] span) {
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "addAppWidgetFromDrop: info = " + info + ", container = " + container + ", screenId = "
-                    + screenId);
-        }
-        resetAddInfo();
-        mPendingAddInfo.container = info.container = container;
-        mPendingAddInfo.screenId = info.screenId = screenId;
-        mPendingAddInfo.dropPos = null;
-        mPendingAddInfo.minSpanX = info.minSpanX;
-        mPendingAddInfo.minSpanY = info.minSpanY;
-
-        if (cell != null) {
-            mPendingAddInfo.cellX = cell[0];
-            mPendingAddInfo.cellY = cell[1];
-        }
-        if (span != null) {
-            mPendingAddInfo.spanX = span[0];
-            mPendingAddInfo.spanY = span[1];
-        }
-
-        AppWidgetHostView hostView = info.boundWidget;
-        int appWidgetId;
-        if (hostView != null) {
-            // In the case where we've prebound the widget, we remove it from the DragLayer
-            if (LOGD) {
-                Log.d(TAG, "Removing widget view from drag layer and setting boundWidget to null");
-            }
-            getDragLayer().removeView(hostView);
-
-            appWidgetId = hostView.getAppWidgetId();
-            addAppWidgetFromDropImpl(appWidgetId, info, hostView, info.info);
-
-            // Clear the boundWidget so that it doesn't get destroyed.
-            info.boundWidget = null;
-        } else {
-            // In this case, we either need to start an activity to get permission to bind
-            // the widget, or we need to start an activity to configure the widget, or both.
-            appWidgetId = getAppWidgetHost().allocateAppWidgetId();
-            Bundle options = info.bindOptions;
-
-            boolean success = mAppWidgetManager.bindAppWidgetIdIfAllowed(
-                    appWidgetId, info.info, options);
-            if (success) {
-                addAppWidgetFromDropImpl(appWidgetId, info, null, info.info);
-            } else {
-                mPendingAddWidgetInfo = info.info;
-                Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_BIND);
-                intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
-                intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER, info.componentName);
-                mAppWidgetManager.getUser(mPendingAddWidgetInfo)
-                    .addToIntent(intent, AppWidgetManager.EXTRA_APPWIDGET_PROVIDER_PROFILE);
-                // TODO: we need to make sure that this accounts for the options bundle.
-                // intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, options);
-                startActivityForResult(intent, REQUEST_BIND_APPWIDGET);
-            }
-        }
-    }
-
-    FolderIcon addFolder(CellLayout layout, long container, final long screenId, int cellX,
-            int cellY) {
-        final FolderInfo folderInfo = new FolderInfo();
-        if(FeatureOption.SPRD_DEFAULT_FOLDER_NAME_SUPPORT){
-            folderInfo.title = "";
-        }else{
-            folderInfo.title = getText(R.string.folder_name);
-        }
-
-        // Update the model
-        LauncherModel.addItemToDatabase(Launcher.this, folderInfo, container, screenId,
-                cellX, cellY);
-        sFolders.put(folderInfo.id, folderInfo);
-
-        // Create the view
-        FolderIcon newFolder =
-            FolderIcon.fromXml(R.layout.folder_icon, this, layout, folderInfo, mIconCache);
-        mWorkspace.addInScreen(newFolder, container, screenId, cellX, cellY, 1, 1,
-                isWorkspaceLocked());
-        // Force measure the new folder icon
-        CellLayout parent = mWorkspace.getParentCellLayoutForView(newFolder);
-        parent.getShortcutsAndWidgets().measureChild(newFolder);
-        return newFolder;
-    }
-
-    /**
-     * Unbinds the view for the specified item, and removes the item and all its children.
-     *
-     * @param v the view being removed.
-     * @param itemInfo the {@link ItemInfo} for this view.
-     * @param deleteFromDb whether or not to delete this item from the db.
-     */
-    public boolean removeItem(View v, ItemInfo itemInfo, boolean deleteFromDb) {
-        if (itemInfo instanceof ShortcutInfo) {
-            // Remove the shortcut from the folder before removing it from launcher
-            FolderInfo folderInfo = sFolders.get(itemInfo.container);
-            if (folderInfo != null) {
-                folderInfo.remove((ShortcutInfo) itemInfo);
-            } else {
-                mWorkspace.removeWorkspaceItem(v);
-            }
-            if (deleteFromDb) {
-                LauncherModel.deleteItemFromDatabase(this, itemInfo);
-            }
-        } else if (itemInfo instanceof FolderInfo) {
-            final FolderInfo folderInfo = (FolderInfo) itemInfo;
-            unbindFolder(folderInfo);
-            mWorkspace.removeWorkspaceItem(v);
-            if (deleteFromDb) {
-                LauncherModel.deleteFolderAndContentsFromDatabase(this, folderInfo);
-            }
-        } else if (itemInfo instanceof LauncherAppWidgetInfo) {
-            final LauncherAppWidgetInfo widgetInfo = (LauncherAppWidgetInfo) itemInfo;
-            mWorkspace.removeWorkspaceItem(v);
-            removeWidgetToAutoAdvance(widgetInfo.hostView);
-            widgetInfo.hostView = null;
-            if (deleteFromDb) {
-                deleteWidgetInfo(widgetInfo);
-            }
-
-        } else {
-            return false;
-        }
-        return true;
-    }
-
-    /**
-     * Unbinds any launcher references to the folder.
-     */
-    private void unbindFolder(FolderInfo folder) {
-        sFolders.remove(folder.id);
-    }
-
-    /**
-     * Deletes the widget info and the widget id.
-     */
-    private void deleteWidgetInfo(final LauncherAppWidgetInfo widgetInfo) {
-        final LauncherAppWidgetHost appWidgetHost = getAppWidgetHost();
-        if (appWidgetHost != null && !widgetInfo.isCustomWidget() && widgetInfo.isWidgetIdValid()) {
-            // Deleting an app widget ID is a void call but writes to disk before returning
-            // to the caller...
-            new AsyncTask<Void, Void, Void>() {
-                public Void doInBackground(Void ... args) {
-                    appWidgetHost.deleteAppWidgetId(widgetInfo.appWidgetId);
-                    return null;
-                }
-            }.executeOnExecutor(Utilities.THREAD_POOL_EXECUTOR);
-        }
-        LauncherModel.deleteItemFromDatabase(this, widgetInfo);
-    }
-
-    @Override
-    public boolean dispatchKeyEvent(KeyEvent event) {
-        if (event.getAction() == KeyEvent.ACTION_DOWN) {
-            switch (event.getKeyCode()) {
-                case KeyEvent.KEYCODE_HOME:
-                    return true;
-                case KeyEvent.KEYCODE_VOLUME_DOWN:
-                    if (Utilities.isPropertyEnabled(DUMP_STATE_PROPERTY)) {
-                        dumpState();
-                        return true;
-                    }
-                    break;
-            }
-        } else if (event.getAction() == KeyEvent.ACTION_UP) {
-            switch (event.getKeyCode()) {
-                case KeyEvent.KEYCODE_HOME:
-                    return true;
-            }
-        }
-
-        return super.dispatchKeyEvent(event);
-    }
-
-    @Override
-    public void onBackPressed() {
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "Back key pressed, mState = " + mState + ", mOnResumeState = " + mOnResumeState);
-        }
-        if (mLauncherCallbacks != null && mLauncherCallbacks.handleBackPressed()) {
-            return;
-        }
-
-        if (mDragController.isDragging()) {
-            mDragController.cancelDrag();
-            return;
-        }
-
-        if (isAppsViewVisible()) {
-            showWorkspace(true);
-            if (FeatureOption.SPRD_BGTRANSPARENT_SUPPORT) {
-                showWorkspaceSearchAndHotseat();
-            }
-        } else if (isWidgetsViewVisible())  {
-            showOverviewMode(true);
-        } else if (mWorkspace.isInOverviewMode()) {
-            showWorkspace(true);
-        } else if (mWorkspace.getOpenFolder() != null) {
-            Folder openFolder = mWorkspace.getOpenFolder();
-            if (openFolder.isEditingName()) {
-                openFolder.dismissEditingName();
-            } else {
-                closeFolder();
-            }
-        } else {
-            mWorkspace.exitWidgetResizeMode();
-
-            // Back button is a no-op here, but give at least some feedback for the button press
-            mWorkspace.showOutlinesTemporarily();
-        }
-    }
-
-    /**
-     * Re-listen when widget host is reset.
-     */
-    @Override
-    public void onAppWidgetHostReset() {
-        if (mAppWidgetHost != null) {
-            mAppWidgetHost.startListening();
-        }
-
-        // Recreate the QSB, as the widget has been reset.
-        bindSearchProviderChanged();
-    }
-
-    /**
-     * Launches the intent referred by the clicked shortcut.
-     *
-     * @param v The view representing the clicked shortcut.
-     */
-    public void onClick(View v) {
-        // Make sure that rogue clicks don't get through while allapps is launching, or after the
-        // view has detached (it's possible for this to happen if the view is removed mid touch).
-        if (v.getWindowToken() == null) {
-            return;
-        }
-
-        if (!mWorkspace.isFinishedSwitchingState()) {
-            return;
-        }
-
-        if (v instanceof Workspace) {
-            if (mWorkspace.isInOverviewMode()) {
-                showWorkspace(true);
-            }
-            return;
-        }
-
-        if (v instanceof CellLayout) {
-            if (mWorkspace.isInOverviewMode()) {
-                showWorkspace(mWorkspace.indexOfChild(v), true);
-            }
-        }
-
-        Object tag = v.getTag();
-        if (tag instanceof ShortcutInfo) {
-            onClickAppShortcut(v);
-        } else if (tag instanceof FolderInfo) {
-            if (v instanceof FolderIcon) {
-                onClickFolderIcon(v);
-            }
-        } else if (v == mAllAppsButton) {
-            onClickAllAppsButton(v);
-        } else if (tag instanceof AppInfo) {
-            startAppShortcutOrInfoActivity(v);
-        } else if (tag instanceof LauncherAppWidgetInfo) {
-            if (v instanceof PendingAppWidgetHostView) {
-                onClickPendingWidget((PendingAppWidgetHostView) v);
-            }
-        }
-    }
-
-    @SuppressLint("ClickableViewAccessibility")
-    public boolean onTouch(View v, MotionEvent event) {
-        return false;
-    }
-
-    /**
-     * Event handler for the app widget view which has not fully restored.
-     */
-    public void onClickPendingWidget(final PendingAppWidgetHostView v) {
-        if (mIsSafeModeEnabled) {
-            Toast.makeText(this, R.string.safemode_widget_error, Toast.LENGTH_SHORT).show();
-            return;
-        }
-
-        final LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) v.getTag();
-        if (v.isReadyForClickSetup()) {
-            int widgetId = info.appWidgetId;
-            LauncherAppWidgetProviderInfo appWidgetInfo =
-                    mAppWidgetManager.getLauncherAppWidgetInfo(widgetId);
-            if (appWidgetInfo != null) {
-                mPendingAddWidgetInfo = appWidgetInfo;
-                mPendingAddInfo.copyFrom(info);
-                mPendingAddWidgetId = widgetId;
-
-                AppWidgetManagerCompat.getInstance(this).startConfigActivity(appWidgetInfo,
-                        info.appWidgetId, this, mAppWidgetHost, REQUEST_RECONFIGURE_APPWIDGET);
-            }
-        } else if (info.installProgress < 0) {
-            // The install has not been queued
-            final String packageName = info.providerName.getPackageName();
-            showBrokenAppInstallDialog(packageName,
-                new DialogInterface.OnClickListener() {
-                    public void onClick(DialogInterface dialog, int id) {
-                        startActivitySafely(v, LauncherModel.getMarketIntent(packageName), info);
-                    }
-                });
-        } else {
-            // Download has started.
-            final String packageName = info.providerName.getPackageName();
-            startActivitySafely(v, LauncherModel.getMarketIntent(packageName), info);
-        }
-    }
-
-    /**
-     * Event handler for the "grid" button that appears on the home screen, which
-     * enters all apps mode.
-     *
-     * @param v The view that was clicked.
-     */
-    protected void onClickAllAppsButton(View v) {
-        if (LOGD) Log.d(TAG, "onClickAllAppsButton");
-        if (!isAppsViewVisible()) {
-            showAppsView(true /* animated */, false /* resetListToTop */,
-                    true /* updatePredictedApps */, false /* focusSearchBar */);
-
-            if (mLauncherCallbacks != null) {
-                mLauncherCallbacks.onClickAllAppsButton(v);
-            }
-        }
-    }
-
-    protected void onLongClickAllAppsButton(View v) {
-        if (LOGD) Log.d(TAG, "onLongClickAllAppsButton");
-        if (!isAppsViewVisible()) {
-            showAppsView(true /* animated */, false /* resetListToTop */,
-                    true /* updatePredictedApps */, true /* focusSearchBar */);
-        }
-    }
-
-    private void showBrokenAppInstallDialog(final String packageName,
-            DialogInterface.OnClickListener onSearchClickListener) {
-        new AlertDialog.Builder(this)
-            .setTitle(R.string.abandoned_promises_title)
-            .setMessage(R.string.abandoned_promise_explanation)
-            .setPositiveButton(R.string.abandoned_search, onSearchClickListener)
-            .setNeutralButton(R.string.abandoned_clean_this,
-                new DialogInterface.OnClickListener() {
-                    public void onClick(DialogInterface dialog, int id) {
-                        final UserHandleCompat user = UserHandleCompat.myUserHandle();
-                        mWorkspace.removeAbandonedPromise(packageName, user);
-                    }
-                })
-            .create().show();
-        return;
-    }
-
-    /**
-     * Event handler for an app shortcut click.
-     *
-     * @param v The view that was clicked. Must be a tagged with a {@link ShortcutInfo}.
-     */
-    protected void onClickAppShortcut(final View v) {
-        if (LOGD) Log.d(TAG, "onClickAppShortcut");
-        Object tag = v.getTag();
-        if (!(tag instanceof ShortcutInfo)) {
-            throw new IllegalArgumentException("Input must be a Shortcut");
-        }
-
-        // Open shortcut
-        final ShortcutInfo shortcut = (ShortcutInfo) tag;
-
-        if (shortcut.isDisabled != 0) {
-            if ((shortcut.isDisabled & ShortcutInfo.FLAG_DISABLED_SUSPENDED) != 0
-                || (shortcut.isDisabled & ShortcutInfo.FLAG_DISABLED_QUIET_USER) != 0) {
-                // Launch activity anyway, framework will tell the user why the app is suspended.
-            } else {
-                int error = R.string.activity_not_available;
-                if ((shortcut.isDisabled & ShortcutInfo.FLAG_DISABLED_SAFEMODE) != 0) {
-                    error = R.string.safemode_shortcut_error;
-                }
-                Toast.makeText(this, error, Toast.LENGTH_SHORT).show();
-                return;
-            }
-        }
-
-        // Check for abandoned promise
-        if ((v instanceof BubbleTextView)
-                && shortcut.isPromise()
-                && !shortcut.hasStatusFlag(ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE)) {
-            showBrokenAppInstallDialog(
-                    shortcut.getTargetComponent().getPackageName(),
-                    new DialogInterface.OnClickListener() {
-                        public void onClick(DialogInterface dialog, int id) {
-                            startAppShortcutOrInfoActivity(v);
-                        }
-                    });
-            return;
-        }
-
-        // Start activities
-        startAppShortcutOrInfoActivity(v);
-
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.onClickAppShortcut(v);
-        }
-    }
-
-    @Thunk void startAppShortcutOrInfoActivity(View v) {
-        Object tag = v.getTag();
-        final ShortcutInfo shortcut;
-        final Intent intent;
-        if (tag instanceof ShortcutInfo) {
-            shortcut = (ShortcutInfo) tag;
-            intent = shortcut.intent;
-            int[] pos = new int[2];
-            v.getLocationOnScreen(pos);
-            intent.setSourceBounds(new Rect(pos[0], pos[1],
-                    pos[0] + v.getWidth(), pos[1] + v.getHeight()));
-
-        } else if (tag instanceof AppInfo) {
-            shortcut = null;
-            intent = ((AppInfo) tag).intent;
-        } else {
-            throw new IllegalArgumentException("Input must be a Shortcut or AppInfo");
-        }
-
-        boolean success = startActivitySafely(v, intent, tag);
-        mStats.recordLaunch(v, intent, shortcut);
-        intent.setSourceBounds(null);
-
-        if (success && v instanceof BubbleTextView) {
-            mWaitingForResume = (BubbleTextView) v;
-            mWaitingForResume.setStayPressed(true);
-        }
-    }
-
-    /**
-     * Event handler for a folder icon click.
-     *
-     * @param v The view that was clicked. Must be an instance of {@link FolderIcon}.
-     */
-    protected void onClickFolderIcon(View v) {
-        if (LOGD) Log.d(TAG, "onClickFolder");
-        if (!(v instanceof FolderIcon)){
-            throw new IllegalArgumentException("Input must be a FolderIcon");
-        }
-
-        // TODO(sunnygoyal): Re-evaluate this code.
-        FolderIcon folderIcon = (FolderIcon) v;
-        final FolderInfo info = folderIcon.getFolderInfo();
-        Folder openFolder = mWorkspace.getFolderForTag(info);
-
-        // If the folder info reports that the associated folder is open, then verify that
-        // it is actually opened. There have been a few instances where this gets out of sync.
-        if (info.opened && openFolder == null) {
-            Log.d(TAG, "Folder info marked as open, but associated folder is not open. Screen: "
-                    + info.screenId + " (" + info.cellX + ", " + info.cellY + ")");
-            info.opened = false;
-        }
-
-        if (!info.opened && !folderIcon.getFolder().isDestroyed()) {
-            // Close any open folder
-            closeFolder();
-            // Open the requested folder
-            openFolder(folderIcon);
-        } else {
-            // Find the open folder...
-            int folderScreen;
-            if (openFolder != null) {
-                folderScreen = mWorkspace.getPageForView(openFolder);
-                // .. and close it
-                closeFolder(openFolder, true);
-                if (folderScreen != mWorkspace.getCurrentPage()) {
-                    // Close any folder open on the current screen
-                    closeFolder();
-                    // Pull the folder onto this screen
-                    openFolder(folderIcon);
-                }
-            }
-        }
-
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.onClickFolderIcon(v);
-        }
-    }
-
-    /**
-     * Event handler for the (Add) Widgets button that appears after a long press
-     * on the home screen.
-     */
-    protected void onClickAddWidgetButton(View view) {
-        if (LOGD) Log.d(TAG, "onClickAddWidgetButton");
-        if (mIsSafeModeEnabled) {
-            Toast.makeText(this, R.string.safemode_widget_error, Toast.LENGTH_SHORT).show();
-        } else {
-            showWidgetsView(true /* animated */, true /* resetPageToZero */);
-            if (mLauncherCallbacks != null) {
-                mLauncherCallbacks.onClickAddWidgetButton(view);
-            }
-        }
-    }
-
-    /**
-     * Event handler for the wallpaper picker button that appears after a long press
-     * on the home screen.
-     */
-    protected void onClickWallpaperPicker(View v) {
-        if (!Utilities.isWallapaperAllowed(this)) {
-            Toast.makeText(this, R.string.msg_disabled_by_admin, Toast.LENGTH_SHORT).show();
-            return;
-        }
-
-        if (LOGD) Log.d(TAG, "onClickWallpaperPicker");
-        int pageScroll = mWorkspace.getScrollForPage(mWorkspace.getPageNearestToCenterOfScreen());
-        float offset = mWorkspace.mWallpaperOffset.wallpaperOffsetForScroll(pageScroll);
-        startActivityForResult(new Intent(Intent.ACTION_SET_WALLPAPER).setPackage(getPackageName())
-                        .putExtra(WallpaperPickerActivity.EXTRA_WALLPAPER_OFFSET, offset),
-                REQUEST_PICK_WALLPAPER);
-
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.onClickWallpaperPicker(v);
-        }
-    }
-
-    /**
-     * Event handler for a click on the settings button that appears after a long press
-     * on the home screen.
-     */
-    protected void onClickSettingsButton(View v) {
-        if (LOGD) Log.d(TAG, "onClickSettingsButton");
-        if(FeatureOption.SPRD_SETTINGS_ACTIVITY_SUPPORT){
-            startActivity(new Intent(this, SprdSettingsActivity.class));
-        }else{
-            startActivity(new Intent(Settings.ACTION_SETTINGS));
-            return;
-        }
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.onClickSettingsButton(v);
-        }
-    }
-
-    public View.OnTouchListener getHapticFeedbackTouchListener() {
-        if (mHapticFeedbackTouchListener == null) {
-            mHapticFeedbackTouchListener = new View.OnTouchListener() {
-                @SuppressLint("ClickableViewAccessibility")
-                @Override
-                public boolean onTouch(View v, MotionEvent event) {
-                    if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) {
-                        v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
-                    }
-                    return false;
-                }
-            };
-        }
-        return mHapticFeedbackTouchListener;
-    }
-
-    public void onDragStarted(View view) {
-        if (isOnCustomContent()) {
-            // Custom content screen doesn't participate in drag and drop. If on custom
-            // content screen, move to default.
-            moveWorkspaceToDefaultScreen();
-        }
-
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.onDragStarted(view);
-        }
-    }
-
-    /**
-     * Called when the user stops interacting with the launcher.
-     * This implies that the user is now on the homescreen and is not doing housekeeping.
-     */
-    protected void onInteractionEnd() {
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.onInteractionEnd();
-        }
-    }
-
-    /**
-     * Called when the user starts interacting with the launcher.
-     * The possible interactions are:
-     *  - open all apps
-     *  - reorder an app shortcut, or a widget
-     *  - open the overview mode.
-     * This is a good time to stop doing things that only make sense
-     * when the user is on the homescreen and not doing housekeeping.
-     */
-    protected void onInteractionBegin() {
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.onInteractionBegin();
-        }
-    }
-
-    /** Updates the interaction state. */
-    public void updateInteraction(Workspace.State fromState, Workspace.State toState) {
-        // Only update the interacting state if we are transitioning to/from a view with an
-        // overlay
-        boolean fromStateWithOverlay = fromState != Workspace.State.NORMAL;
-        boolean toStateWithOverlay = toState != Workspace.State.NORMAL;
-        if (toStateWithOverlay) {
-            onInteractionBegin();
-        } else if (fromStateWithOverlay) {
-            onInteractionEnd();
-        }
-    }
-
-    void startApplicationDetailsActivity(ComponentName componentName, UserHandleCompat user) {
-        try {
-            LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
-            launcherApps.showAppDetailsForProfile(componentName, user);
-        } catch (SecurityException e) {
-            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
-            Log.e(TAG, "Launcher does not have permission to launch settings");
-        } catch (ActivityNotFoundException e) {
-            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
-            Log.e(TAG, "Unable to launch settings");
-        }
-    }
-
-    // returns true if the activity was started
-    boolean startApplicationUninstallActivity(ComponentName componentName, int flags,
-            UserHandleCompat user) {
-        if ((flags & AppInfo.DOWNLOADED_FLAG) == 0) {
-            // System applications cannot be installed. For now, show a toast explaining that.
-            // We may give them the option of disabling apps this way.
-            int messageId = R.string.uninstall_system_app_text;
-            Toast.makeText(this, messageId, Toast.LENGTH_SHORT).show();
-            return false;
-        } else {
-            String packageName = componentName.getPackageName();
-            String className = componentName.getClassName();
-            Intent intent = new Intent(
-                    Intent.ACTION_DELETE, Uri.fromParts("package", packageName, className));
-            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
-                    Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
-            if (user != null) {
-                user.addToIntent(intent, Intent.EXTRA_USER);
-            }
-            startActivity(intent);
-            return true;
-        }
-    }
-
-    private boolean startActivity(View v, Intent intent, Object tag) {
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        try {
-            // Only launch using the new animation if the shortcut has not opted out (this is a
-            // private contract between launcher and may be ignored in the future).
-            boolean useLaunchAnimation = (v != null) &&
-                    !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);
-            LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
-            UserManagerCompat userManager = UserManagerCompat.getInstance(this);
-
-            UserHandleCompat user = null;
-            if (intent.hasExtra(AppInfo.EXTRA_PROFILE)) {
-                long serialNumber = intent.getLongExtra(AppInfo.EXTRA_PROFILE, -1);
-                user = userManager.getUserForSerialNumber(serialNumber);
-            }
-
-            Bundle optsBundle = null;
-            if (useLaunchAnimation) {
-                ActivityOptions opts = null;
-                if (Utilities.ATLEAST_MARSHMALLOW) {
-                    int left = 0, top = 0;
-                    int width = v.getMeasuredWidth(), height = v.getMeasuredHeight();
-                    if (v instanceof TextView) {
-                        // Launch from center of icon, not entire view
-                        Drawable icon = Workspace.getTextViewIcon((TextView) v);
-                        if (icon != null) {
-                            Rect bounds = icon.getBounds();
-                            left = (width - bounds.width()) / 2;
-                            top = v.getPaddingTop();
-                            width = bounds.width();
-                            height = bounds.height();
-                        }
-                    }
-                    opts = ActivityOptions.makeClipRevealAnimation(v, left, top, width, height);
-                } else if (!Utilities.ATLEAST_LOLLIPOP) {
-                    // Below L, we use a scale up animation
-                    opts = ActivityOptions.makeScaleUpAnimation(v, 0, 0,
-                                    v.getMeasuredWidth(), v.getMeasuredHeight());
-                } else if (Utilities.ATLEAST_LOLLIPOP_MR1) {
-                    // On L devices, we use the device default slide-up transition.
-                    // On L MR1 devices, we a custom version of the slide-up transition which
-                    // doesn't have the delay present in the device default.
-                    opts = ActivityOptions.makeCustomAnimation(this,
-                            R.anim.task_open_enter, R.anim.no_anim);
-                }
-                optsBundle = opts != null ? opts.toBundle() : null;
-                //Bug 661753 add for animation
-                optsBundle = PlatformHelper.overrideOptsBundle(v, optsBundle, null);
-            }
-
-            if (user == null) {
-                user = UserHandleCompat.myUserHandle();
-            }
-            if (LOGD) LogUtils.d(TAG, "startActivity:" + intent.toString() + " user:" + user.toString());
-            if (user.equals(UserHandleCompat.myUserHandle())) {
-                StrictMode.VmPolicy oldPolicy = StrictMode.getVmPolicy();
-                try {
-                    // Temporarily disable deathPenalty on all default checks. For eg, shortcuts
-                    // containing file Uris would cause a crash as penaltyDeathOnFileUriExposure
-                    // is enabled by default on NYC.
-                    StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectAll()
-                            .penaltyLog().build());
-                    // Could be launching some bookkeeping activity
-                    startActivity(intent, optsBundle);
-                } finally {
-                    StrictMode.setVmPolicy(oldPolicy);
-                }
-            } else {
-                // TODO Component can be null when shortcuts are supported for secondary user
-                try {
-                    if (intent.getComponent() != null && !PlatformHelper.isAppCloneUser(user.getUser())) {
-                        launcherApps.startActivityForProfile(intent.getComponent(), user,
-                                intent.getSourceBounds(), optsBundle);
-                    } else {
-                        PlatformHelper.startActivityAsUser(this, intent, optsBundle, user.getUser());
-                    }
-                } catch (ActivityNotFoundException e) {
-                    LogUtils.w(TAG, "activity not found.intent:" + intent.toString());
-                    Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
-                    return false;
-                }
-            }
-            return true;
-        } catch (SecurityException e) {
-            if (Utilities.ATLEAST_MARSHMALLOW && tag instanceof ItemInfo) {
-                // Due to legacy reasons, direct call shortcuts require Launchers to have the
-                // corresponding permission. Show the appropriate permission prompt if that
-                // is the case.
-                if (intent.getComponent() == null
-                        && Intent.ACTION_CALL.equals(intent.getAction())
-                        && checkSelfPermission(Manifest.permission.CALL_PHONE) !=
-                            PackageManager.PERMISSION_GRANTED) {
-                    // TODO: Rename sPendingAddItem to a generic name.
-                    sPendingAddItem = preparePendingAddArgs(REQUEST_PERMISSION_CALL_PHONE, intent,
-                            0, (ItemInfo) tag);
-                    requestPermissions(new String[]{Manifest.permission.CALL_PHONE},
-                            REQUEST_PERMISSION_CALL_PHONE);
-                    return false;
-                }
-            }
-            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
-            Log.e(TAG, "Launcher does not have the permission to launch " + intent +
-                    ". Make sure to create a MAIN intent-filter for the corresponding activity " +
-                    "or use the exported attribute for this activity. "
-                    + "tag="+ tag + " intent=" + intent, e);
-        }
-        return false;
-    }
-
-    public boolean startActivitySafely(View v, Intent intent, Object tag) {
-        boolean success = false;
-        if (mIsSafeModeEnabled && !Utilities.isSystemApp(this, intent)) {
-            Toast.makeText(this, R.string.safemode_shortcut_error, Toast.LENGTH_SHORT).show();
-            return false;
-        }
-        try {
-            success = startActivity(v, intent, tag);
-            if (mPredictedAppController != null && success) {
-                mPredictedAppController.updatePredictedList(intent.getComponent());
-            }
-        } catch (ActivityNotFoundException e) {
-            if (v instanceof TextView){
-                return success;
-            }
-            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
-            Log.e(TAG, "Unable to launch. tag=" + tag + " intent=" + intent, e);
-        }
-        return success;
-    }
-
-    /**
-     * This method draws the FolderIcon to an ImageView and then adds and positions that ImageView
-     * in the DragLayer in the exact absolute location of the original FolderIcon.
-     */
-    private void copyFolderIconToImage(FolderIcon fi) {
-        final int width = fi.getMeasuredWidth();
-        final int height = fi.getMeasuredHeight();
-
-        // Lazy load ImageView, Bitmap and Canvas
-        if (mFolderIconImageView == null) {
-            mFolderIconImageView = new ImageView(this);
-        }
-        if (mFolderIconBitmap == null || mFolderIconBitmap.getWidth() != width ||
-                mFolderIconBitmap.getHeight() != height) {
-            mFolderIconBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
-            mFolderIconCanvas = new Canvas(mFolderIconBitmap);
-        }
-
-        DragLayer.LayoutParams lp;
-        if (mFolderIconImageView.getLayoutParams() instanceof DragLayer.LayoutParams) {
-            lp = (DragLayer.LayoutParams) mFolderIconImageView.getLayoutParams();
-        } else {
-            lp = new DragLayer.LayoutParams(width, height);
-        }
-
-        // The layout from which the folder is being opened may be scaled, adjust the starting
-        // view size by this scale factor.
-        float scale = mDragLayer.getDescendantRectRelativeToSelf(fi, mRectForFolderAnimation);
-        lp.customPosition = true;
-        lp.x = mRectForFolderAnimation.left;
-        lp.y = mRectForFolderAnimation.top;
-        lp.width = (int) (scale * width);
-        lp.height = (int) (scale * height);
-
-        mFolderIconCanvas.drawColor(0, PorterDuff.Mode.CLEAR);
-        fi.draw(mFolderIconCanvas);
-        mFolderIconImageView.setImageBitmap(mFolderIconBitmap);
-        if (fi.getFolder() != null) {
-            mFolderIconImageView.setPivotX(fi.getFolder().getPivotXForIconAnimation());
-            mFolderIconImageView.setPivotY(fi.getFolder().getPivotYForIconAnimation());
-        }
-        // Just in case this image view is still in the drag layer from a previous animation,
-        // we remove it and re-add it.
-        if (mDragLayer.indexOfChild(mFolderIconImageView) != -1) {
-            mDragLayer.removeView(mFolderIconImageView);
-        }
-        mDragLayer.addView(mFolderIconImageView, lp);
-        if (fi.getFolder() != null) {
-            fi.getFolder().bringToFront();
-        }
-    }
-
-    private void growAndFadeOutFolderIcon(FolderIcon fi) {
-        if (fi == null) return;
-        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 0);
-        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1.5f);
-        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1.5f);
-
-        FolderInfo info = (FolderInfo) fi.getTag();
-        if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
-            CellLayout cl = (CellLayout) fi.getParent().getParent();
-            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) fi.getLayoutParams();
-            cl.setFolderLeaveBehindCell(lp.cellX, lp.cellY);
-        }
-
-        // Push an ImageView copy of the FolderIcon into the DragLayer and hide the original
-        copyFolderIconToImage(fi);
-        fi.setVisibility(View.INVISIBLE);
-
-        ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(mFolderIconImageView, alpha,
-                scaleX, scaleY);
-        if (Utilities.ATLEAST_LOLLIPOP) {
-            oa.setInterpolator(new LogDecelerateInterpolator(100, 0));
-        }
-        oa.setDuration(getResources().getInteger(R.integer.config_folderExpandDuration));
-        oa.start();
-    }
-
-    private void shrinkAndFadeInFolderIcon(final FolderIcon fi, boolean animate) {
-        if (fi == null) return;
-        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1.0f);
-        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1.0f);
-        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1.0f);
-
-        final CellLayout cl = (CellLayout) fi.getParent().getParent();
-
-        // We remove and re-draw the FolderIcon in-case it has changed
-        mDragLayer.removeView(mFolderIconImageView);
-        copyFolderIconToImage(fi);
-        ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(mFolderIconImageView, alpha,
-                scaleX, scaleY);
-        oa.setDuration(getResources().getInteger(R.integer.config_folderExpandDuration));
-        oa.addListener(new AnimatorListenerAdapter() {
-            @Override
-            public void onAnimationEnd(Animator animation) {
-                if (cl != null) {
-                    cl.clearFolderLeaveBehind();
-                    // Remove the ImageView copy of the FolderIcon and make the original visible.
-                    mDragLayer.removeView(mFolderIconImageView);
-                    fi.setVisibility(View.VISIBLE);
-                }
-            }
-        });
-        oa.start();
-        if (!animate) {
-            oa.end();
-        }
-    }
-
-    /**
-     * Opens the user folder described by the specified tag. The opening of the folder
-     * is animated relative to the specified View. If the View is null, no animation
-     * is played.
-     *
-     * @param folderInfo The FolderInfo describing the folder to open.
-     */
-    public void openFolder(FolderIcon folderIcon) {
-        Folder folder = folderIcon.getFolder();
-        Folder openFolder = mWorkspace != null ? mWorkspace.getOpenFolder() : null;
-        if (openFolder != null && openFolder != folder) {
-            // Close any open folder before opening a folder.
-            closeFolder();
-        }
-
-        FolderInfo info = folder.mInfo;
-
-        info.opened = true;
-
-        // While the folder is open, the position of the icon cannot change.
-        ((CellLayout.LayoutParams) folderIcon.getLayoutParams()).canReorder = false;
-
-        // Just verify that the folder hasn't already been added to the DragLayer.
-        // There was a one-off crash where the folder had a parent already.
-        if (folder.getParent() == null) {
-            mDragLayer.addView(folder);
-            mDragController.addDropTarget((DropTarget) folder);
-        } else {
-            Log.w(TAG, "Opening folder (" + folder + ") which already has a parent (" +
-                    folder.getParent() + ").");
-        }
-        folder.animateOpen();
-        growAndFadeOutFolderIcon(folderIcon);
-
-        // Notify the accessibility manager that this folder "window" has appeared and occluded
-        // the workspace items
-        folder.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
-        getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
-    }
-
-    public void closeFolder() {
-        closeFolder(true);
-    }
-
-    public void closeFolder(boolean animate) {
-        Folder folder = mWorkspace != null ? mWorkspace.getOpenFolder() : null;
-        if (folder != null) {
-            if (folder.isEditingName()) {
-                folder.dismissEditingName();
-            }
-            closeFolder(folder, animate);
-        }
-    }
-
-    public void closeFolder(Folder folder, boolean animate) {
-        folder.getInfo().opened = false;
-
-        ViewParent viewParent = folder.getParent();
-        if(viewParent != null && viewParent.getParent() != null) {
-            FolderIcon fi = (FolderIcon) mWorkspace.getViewForTag(folder.mInfo);
-            shrinkAndFadeInFolderIcon(fi, animate);
-            if (fi != null) {
-                ((CellLayout.LayoutParams) fi.getLayoutParams()).canReorder = true;
-            }
-        }else{
-            if(LOGD) {
-                Log.d(TAG, "closeFolder, folder = "+ folder);
-            }
-        }
-        if (animate) {
-            folder.animateClosed();
-        } else {
-            folder.close(false);
-        }
-
-        // Notify the accessibility manager that this folder "window" has disappeared and no
-        // longer occludes the workspace items
-        getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
-    }
-
-    public boolean onLongClick(View v) {
-        if (!isDraggingEnabled()) return false;
-        if (isWorkspaceLocked()) return false;
-        if (mState != State.WORKSPACE) return false;
-
-        if (v == mAllAppsButton) {
-            onLongClickAllAppsButton(v);
-            return true;
-        }
-
-        if (v instanceof Workspace) {
-            if (!mWorkspace.isInOverviewMode()) {
-                if (!mWorkspace.isTouchActive()) {
-                    showOverviewMode(true);
-                    mWorkspace.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
-                            HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING);
-                    return true;
-                } else {
-                    return false;
-                }
-            } else {
-                return false;
-            }
-        }
-
-        CellLayout.CellInfo longClickCellInfo = null;
-        View itemUnderLongClick = null;
-        if (v.getTag() instanceof ItemInfo) {
-            ItemInfo info = (ItemInfo) v.getTag();
-            longClickCellInfo = new CellLayout.CellInfo(v, info);
-            itemUnderLongClick = longClickCellInfo.cell;
-            resetAddInfo();
-        }
-
-        // The hotseat touch handling does not go through Workspace, and we always allow long press
-        // on hotseat items.
-        final boolean inHotseat = isHotseatLayout(v);
-        if (!mDragController.isDragging()) {
-            if (itemUnderLongClick == null) {
-                // User long pressed on empty space
-                mWorkspace.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
-                        HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING);
-                if (mWorkspace.isInOverviewMode()) {
-                    mWorkspace.startReordering(v);
-                } else {
-                    showOverviewMode(true);
-                }
-            } else {
-                final boolean isAllAppsButton = inHotseat && isAllAppsButtonRank(
-                        mHotseat.getOrderInHotseat(
-                                longClickCellInfo.cellX,
-                                longClickCellInfo.cellY));
-                if (!(itemUnderLongClick instanceof Folder || isAllAppsButton)) {
-                    // User long pressed on an item
-                    mWorkspace.startDrag(longClickCellInfo);
-                }
-            }
-        }
-        return true;
-    }
-
-    boolean isHotseatLayout(View layout) {
-        return mHotseat != null && layout != null &&
-                (layout instanceof CellLayout) && (layout == mHotseat.getLayout());
-    }
-
-    /**
-     * Returns the CellLayout of the specified container at the specified screen.
-     */
-    public CellLayout getCellLayout(long container, long screenId) {
-        if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
-            if (mHotseat != null) {
-                return mHotseat.getLayout();
-            } else {
-                return null;
-            }
-        } else {
-            return mWorkspace.getScreenWithId(screenId);
-        }
-    }
-
-    /**
-     * For overridden classes.
-     */
-    public boolean isAllAppsVisible() {
-        return isAppsViewVisible();
-    }
-
-    public boolean isAppsViewVisible() {
-        return (mState == State.APPS) || (mOnResumeState == State.APPS);
-    }
-
-    public boolean isWidgetsViewVisible() {
-        return (mState == State.WIDGETS) || (mOnResumeState == State.WIDGETS);
-    }
-
-    public boolean isWorkspaceVisible() {
-        return (mState == State.WORKSPACE) || (mOnResumeState == State.WORKSPACE);
-    }
-
-    private void setWorkspaceBackground(int background) {
-        switch (background) {
-            case WORKSPACE_BACKGROUND_TRANSPARENT:
-                getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
-                break;
-            case WORKSPACE_BACKGROUND_BLACK:
-                getWindow().setBackgroundDrawable(null);
-                break;
-            default:
-                getWindow().setBackgroundDrawable(mWorkspaceBackgroundDrawable);
-        }
-    }
-
-    protected void changeWallpaperVisiblity(boolean visible) {
-        int wpflags = visible ? WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER : 0;
-        int curflags = getWindow().getAttributes().flags
-                & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
-        if (wpflags != curflags) {
-            getWindow().setFlags(wpflags, WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER);
-        }
-        setWorkspaceBackground(visible ? WORKSPACE_BACKGROUND_GRADIENT : WORKSPACE_BACKGROUND_BLACK);
-    }
-
-    @Override
-    public void onTrimMemory(int level) {
-        super.onTrimMemory(level);
-        if (level >= ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
-            // The widget preview db can result in holding onto over
-            // 3MB of memory for caching which isn't necessary.
-            SQLiteDatabase.releaseMemory();
-
-            // This clears all widget bitmaps from the widget tray
-            // TODO(hyunyoungs)
-        }
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.onTrimMemory(level);
-        }
-    }
-
-    /**
-     * @return whether or not the Launcher state changed.
-     */
-    public boolean showWorkspace(boolean animated) {
-        return showWorkspace(WorkspaceStateTransitionAnimation.SCROLL_TO_CURRENT_PAGE, animated, null);
-    }
-
-    /**
-     * @return whether or not the Launcher state changed.
-     */
-    public boolean showWorkspace(boolean animated, Runnable onCompleteRunnable) {
-        return showWorkspace(WorkspaceStateTransitionAnimation.SCROLL_TO_CURRENT_PAGE, animated,
-                onCompleteRunnable);
-    }
-
-    /**
-     * @return whether or not the Launcher state changed.
-     */
-    protected boolean showWorkspace(int snapToPage, boolean animated) {
-        return showWorkspace(snapToPage, animated, null);
-    }
-
-    /**
-     * @return whether or not the Launcher state changed.
-     */
-    boolean showWorkspace(int snapToPage, boolean animated, Runnable onCompleteRunnable) {
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "showWorkspace: animated = " + animated + ", mState = " + mState);
-        }
-        boolean changed = mState != State.WORKSPACE ||
-                mWorkspace.getState() != Workspace.State.NORMAL;
-        if (changed) {
-            if (mWorkspace != null) {
-                mWorkspace.setVisibility(View.VISIBLE);
-                mWorkspace.setInOverviewMode(false);
-                mStateTransitionAnimation.startAnimationToWorkspace(mState, mWorkspace.getState(),
-                        Workspace.State.NORMAL, snapToPage, animated, onCompleteRunnable);
-            }
-
-            // Set focus to the AppsCustomize button
-            if (mAllAppsButton != null) {
-                mAllAppsButton.requestFocus();
-            }
-        }
-
-        // Change the state *after* we've called all the transition code
-        mState = State.WORKSPACE;
-
-        mPageIndicators.setVisibility(View.VISIBLE);
-
-        // Resume the auto-advance of widgets
-        mUserPresent = true;
-        updateAutoAdvanceState();
-
-        if (changed) {
-            // Send an accessibility event to announce the context change
-            getWindow().getDecorView()
-                    .sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
-        }
-        return changed;
-    }
-
-    /**
-     * Shows the overview button.
-     */
-    void showOverviewMode(boolean animated) {
-        mWorkspace.setInOverviewMode(true);
-        showOverviewMode(animated, false);
-    }
-
-    /**
-     * Shows the overview button, and if {@param requestButtonFocus} is set, will force the focus
-     * onto one of the overview panel buttons.
-     */
-    void showOverviewMode(boolean animated, boolean requestButtonFocus) {
-        Runnable postAnimRunnable = null;
-        if (requestButtonFocus) {
-            postAnimRunnable = new Runnable() {
-                @Override
-                public void run() {
-                    // Hitting the menu button when in touch mode does not trigger touch mode to
-                    // be disabled, so if requested, force focus on one of the overview panel
-                    // buttons.
-                    mOverviewPanel.requestFocusFromTouch();
-                }
-            };
-        }
-        mWorkspace.setVisibility(View.VISIBLE);
-        mStateTransitionAnimation.startAnimationToWorkspace(mState, mWorkspace.getState(),
-                Workspace.State.OVERVIEW,
-                WorkspaceStateTransitionAnimation.SCROLL_TO_CURRENT_PAGE, animated,
-                postAnimRunnable);
-        mState = State.WORKSPACE;
-    }
-
-    /**
-     * Shows the apps view.
-     */
-    void showAppsView(boolean animated, boolean resetListToTop, boolean updatePredictedApps,
-            boolean focusSearchBar) {
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "showAllApps: animated = " + animated + ", mState = " + mState + ", focusSearchBar = "+ focusSearchBar);
-        }
-        if (resetListToTop) {
-            mAppsView.scrollToTop();
-        }
-        if (updatePredictedApps) {
-            tryAndUpdatePredictedApps();
-        }
-        showAppsOrWidgets(State.APPS, animated, focusSearchBar);
-    }
-
-    /**
-     * Shows the widgets view.
-     */
-    void showWidgetsView(boolean animated, boolean resetPageToZero) {
-        if (LOGD) Log.d(TAG, "showWidgetsView:" + animated + " resetPageToZero:" + resetPageToZero);
-        if (resetPageToZero) {
-            mWidgetsView.scrollToTop();
-        }
-        showAppsOrWidgets(State.WIDGETS, animated, false);
-
-        mWidgetsView.post(new Runnable() {
-            @Override
-            public void run() {
-                mWidgetsView.requestFocus();
-            }
-        });
-    }
-
-    /**
-     * Sets up the transition to show the apps/widgets view.
-     *
-     * @return whether the current from and to state allowed this operation
-     */
-    // TODO: calling method should use the return value so that when {@code false} is returned
-    // the workspace transition doesn't fall into invalid state.
-    private boolean showAppsOrWidgets(State toState, boolean animated, boolean focusSearchBar) {
-        if (mState != State.WORKSPACE &&  mState != State.APPS_SPRING_LOADED &&
-                mState != State.WIDGETS_SPRING_LOADED) {
-            return false;
-        }
-        if (toState != State.APPS && toState != State.WIDGETS) {
-            return false;
-        }
-
-        if (toState == State.APPS) {
-            mStateTransitionAnimation.startAnimationToAllApps(mWorkspace.getState(), animated,
-                    focusSearchBar);
-        } else {
-            mStateTransitionAnimation.startAnimationToWidgets(mWorkspace.getState(), animated);
-        }
-
-        mPageIndicators.setVisibility(View.INVISIBLE);
-
-        // Change the state *after* we've called all the transition code
-        mState = toState;
-
-        // Pause the auto-advance of widgets until we are out of AllApps
-        mUserPresent = false;
-        updateAutoAdvanceState();
-        closeFolder();
-
-        // Send an accessibility event to announce the context change
-        getWindow().getDecorView()
-                .sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
-        return true;
-    }
-
-    /**
-     * Updates the workspace and interaction state on state change, and return the animation to this
-     * new state.
-     */
-    public Animator startWorkspaceStateChangeAnimation(Workspace.State toState, int toPage,
-            boolean animated, HashMap<View, Integer> layerViews) {
-        if (mWorkspace == null) {
-            return null;
-        }
-        Workspace.State fromState = mWorkspace.getState();
-        Animator anim = mWorkspace.setStateWithAnimation(toState, toPage, animated, layerViews);
-        updateInteraction(fromState, toState);
-        return anim;
-    }
-
-    public void enterSpringLoadedDragMode() {
-        if (LOGD) Log.d(TAG, String.format("enterSpringLoadedDragMode [mState=%s", mState.name()));
-        if (mState == State.WORKSPACE || mState == State.APPS_SPRING_LOADED ||
-                mState == State.WIDGETS_SPRING_LOADED) {
-            return;
-        }
-
-        mStateTransitionAnimation.startAnimationToWorkspace(mState, mWorkspace.getState(),
-                Workspace.State.SPRING_LOADED,
-                WorkspaceStateTransitionAnimation.SCROLL_TO_CURRENT_PAGE, true /* animated */,
-                null /* onCompleteRunnable */);
-        mState = isAppsViewVisible() ? State.APPS_SPRING_LOADED : State.WIDGETS_SPRING_LOADED;
-    }
-
-    public void exitSpringLoadedDragModeDelayed(final boolean successfulDrop, int delay,
-            final Runnable onCompleteRunnable) {
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "exitSpringLoadedDragModeDelayed successfulDrop = " + successfulDrop + ", delay = "
-                    + delay + ", mState = " + mState);
-        }
-        if (mState != State.APPS_SPRING_LOADED && mState != State.WIDGETS_SPRING_LOADED) return;
-
-        mHandler.postDelayed(new Runnable() {
-            @Override
-            public void run() {
-                if (successfulDrop) {
-                    // TODO(hyunyoungs): verify if this hack is still needed, if not, delete.
-                    //
-                    // Before we show workspace, hide all apps again because
-                    // exitSpringLoadedDragMode made it visible. This is a bit hacky; we should
-                    // clean up our state transition functions
-                    mWidgetsView.setVisibility(View.GONE);
-                    showWorkspace(true, onCompleteRunnable);
-                } else {
-                    exitSpringLoadedDragMode();
-                }
-            }
-        }, delay);
-    }
-
-    void exitSpringLoadedDragMode() {
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "exitSpringLoadedDragMode mState = " + mState);
-        }
-        if (mState == State.APPS_SPRING_LOADED) {
-            showAppsView(true /* animated */, false /* resetListToTop */,
-                    false /* updatePredictedApps */, false /* focusSearchBar */);
-        } else if (mState == State.WIDGETS_SPRING_LOADED) {
-            showWidgetsView(true, false);
-        }
-    }
-
-    /**
-     * Updates the set of predicted apps if it hasn't been updated since the last time Launcher was
-     * resumed.
-     */
-    private void tryAndUpdatePredictedApps() {
-        if (mPredictedAppController != null) {
-            List<ComponentKey> apps = mPredictedAppController.getCurrentPredictedList();
-            if (apps != null) {
-                mAppsView.setPredictedApps(apps);
-            }
-            return;
-        }
-        if (mLauncherCallbacks != null) {
-            List<ComponentKey> apps = mLauncherCallbacks.getPredictedApps();
-            if (apps != null) {
-                mAppsView.setPredictedApps(apps);
-            }
-        }
-    }
-
-    void lockAllApps() {
-        // TODO
-    }
-
-    void unlockAllApps() {
-        // TODO
-    }
-
-    public boolean launcherCallbacksProvidesSearch() {
-        return (mLauncherCallbacks != null && mLauncherCallbacks.providesSearch());
-    }
-
-    public View getOrCreateQsbBar() {
-        if(FeatureOption.SPRD_HIDESEARCHBAR_SUPPORT) {
-            return null;
-        }
-        if (launcherCallbacksProvidesSearch()) {
-            return mLauncherCallbacks.getQsbBar();
-        }
-
-        if (mQsb == null) {
-            AppWidgetProviderInfo searchProvider = Utilities.getSearchWidgetProvider(this);
-            if (searchProvider == null) {
-                return null;
-            }
-
-            Bundle opts = new Bundle();
-            opts.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY,
-                    AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX);
-
-            // Determine the min and max dimensions of the widget.
-            LauncherAppState app = LauncherAppState.getInstance();
-            DeviceProfile portraitProfile = app.getInvariantDeviceProfile().portraitProfile;
-            DeviceProfile landscapeProfile = app.getInvariantDeviceProfile().landscapeProfile;
-            float density = getResources().getDisplayMetrics().density;
-            Point searchDimens = portraitProfile.getSearchBarDimensForWidgetOpts(getResources());
-            int maxHeight = (int) (searchDimens.y / density);
-            int minHeight = maxHeight;
-            int maxWidth = (int) (searchDimens.x / density);
-            int minWidth = maxWidth;
-            if (!landscapeProfile.isVerticalBarLayout()) {
-                searchDimens = landscapeProfile.getSearchBarDimensForWidgetOpts(getResources());
-                maxHeight = (int) Math.max(maxHeight, searchDimens.y / density);
-                minHeight = (int) Math.min(minHeight, searchDimens.y / density);
-                maxWidth = (int) Math.max(maxWidth, searchDimens.x / density);
-                minWidth = (int) Math.min(minWidth, searchDimens.x / density);
-            }
-            opts.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, maxHeight);
-            opts.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, minHeight);
-            opts.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, maxWidth);
-            opts.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, minWidth);
-            if (LOGD) {
-                Log.d(TAG, "QSB widget options: maxHeight=" + maxHeight + " minHeight=" + minHeight
-                        + " maxWidth=" + maxWidth + " minWidth=" + minWidth);
-            }
-
-            if (mLauncherCallbacks != null) {
-                opts.putAll(mLauncherCallbacks.getAdditionalSearchWidgetOptions());
-            }
-
-            int widgetId = mSharedPrefs.getInt(QSB_WIDGET_ID, -1);
-            AppWidgetProviderInfo widgetInfo = mAppWidgetManager.getAppWidgetInfo(widgetId);
-            if (!searchProvider.provider.flattenToString().equals(
-                    mSharedPrefs.getString(QSB_WIDGET_PROVIDER, null))
-                    || (widgetInfo == null)
-                    || !widgetInfo.provider.equals(searchProvider.provider)) {
-                // A valid widget is not already bound.
-                if (widgetId > -1) {
-                    mAppWidgetHost.deleteAppWidgetId(widgetId);
-                    widgetId = -1;
-                }
-
-                // Try to bind a new widget
-                widgetId = mAppWidgetHost.allocateAppWidgetId();
-
-                if (!AppWidgetManagerCompat.getInstance(this)
-                        .bindAppWidgetIdIfAllowed(widgetId, searchProvider, opts)) {
-                    mAppWidgetHost.deleteAppWidgetId(widgetId);
-                    widgetId = -1;
-                }
-
-                mSharedPrefs.edit()
-                    .putInt(QSB_WIDGET_ID, widgetId)
-                    .putString(QSB_WIDGET_PROVIDER, searchProvider.provider.flattenToString())
-                    .apply();
-            }
-
-            mAppWidgetHost.setQsbWidgetId(widgetId);
-            if (widgetId != -1) {
-                mQsb = mAppWidgetHost.createView(this, widgetId, searchProvider);
-                mQsb.setId(R.id.qsb_widget);
-                mQsb.updateAppWidgetOptions(opts);
-                mQsb.setPadding(0, 0, 0, 0);
-                mSearchDropTargetBar.addView(mQsb);
-                mSearchDropTargetBar.setQsbSearchBar(mQsb);
-            }
-        }
-        return mQsb;
-    }
-
-    private void reinflateQSBIfNecessary() {
-        if (mQsb instanceof LauncherAppWidgetHostView &&
-                ((LauncherAppWidgetHostView) mQsb).isReinflateRequired()) {
-            mSearchDropTargetBar.removeView(mQsb);
-            mQsb = null;
-            mSearchDropTargetBar.setQsbSearchBar(getOrCreateQsbBar());
-        }
-    }
-
-    @Override
-    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
-        final boolean result = super.dispatchPopulateAccessibilityEvent(event);
-        final List<CharSequence> text = event.getText();
-        text.clear();
-        // Populate event with a fake title based on the current state.
-        if (mState == State.APPS) {
-            text.add(getString(R.string.all_apps_button_label));
-        } else if (mState == State.WIDGETS) {
-            text.add(getString(R.string.widget_button_text));
-        } else if (mWorkspace != null) {
-            text.add(mWorkspace.getCurrentPageDescription());
-        } else {
-            text.add(getString(R.string.all_apps_home_button_label));
-        }
-        return result;
-    }
-
-    /**
-     * Receives notifications when system dialogs are to be closed.
-     */
-    @Thunk class CloseSystemDialogsIntentReceiver extends BroadcastReceiver {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            closeSystemDialogs();
-        }
-    }
-
-    /**
-     * If the activity is currently paused, signal that we need to run the passed Runnable
-     * in onResume.
-     *
-     * This needs to be called from incoming places where resources might have been loaded
-     * while the activity is paused. That is because the Configuration (e.g., rotation)  might be
-     * wrong when we're not running, and if the activity comes back to what the configuration was
-     * when we were paused, activity is not restarted.
-     *
-     * Implementation of the method from LauncherModel.Callbacks.
-     *
-     * @return {@code true} if we are currently paused. The caller might be able to skip some work
-     */
-    @Thunk boolean waitUntilResume(Runnable run, boolean deletePreviousRunnables) {
-        if (mPaused) {
-            if (LOGD) Log.d(TAG, "Deferring update until onResume");
-            if (deletePreviousRunnables) {
-                while (mBindOnResumeCallbacks.remove(run)) {
-                }
-            }
-            mBindOnResumeCallbacks.add(run);
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    private boolean waitUntilResume(Runnable run) {
-        return waitUntilResume(run, false);
-    }
-
-    public void addOnResumeCallback(Runnable run) {
-        mOnResumeCallbacks.add(run);
-    }
-
-    /**
-     * If the activity is currently paused, signal that we need to re-run the loader
-     * in onResume.
-     *
-     * This needs to be called from incoming places where resources might have been loaded
-     * while we are paused.  That is becaues the Configuration might be wrong
-     * when we're not running, and if it comes back to what it was when we
-     * were paused, we are not restarted.
-     *
-     * Implementation of the method from LauncherModel.Callbacks.
-     *
-     * @return true if we are currently paused.  The caller might be able to
-     * skip some work in that case since we will come back again.
-     */
-    public boolean setLoadOnResume() {
-        if (mPaused) {
-            if (LOGD) Log.d(TAG, "setLoadOnResume");
-            mOnResumeNeedsLoad = true;
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    /**
-     * Implementation of the method from LauncherModel.Callbacks.
-     */
-    public int getCurrentWorkspaceScreen() {
-        if (mWorkspace != null) {
-            return mWorkspace.getCurrentPage();
-        } else {
-            return SCREEN_COUNT / 2;
-        }
-    }
-
-    /**
-     * Refreshes the shortcuts shown on the workspace.
-     *
-     * Implementation of the method from LauncherModel.Callbacks.
-     */
-    public void startBinding() {
-        setWorkspaceLoading(true);
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "startBinding: this = " + this);
-        }
-
-        // If we're starting binding all over again, clear any bind calls we'd postponed in
-        // the past (see waitUntilResume) -- we don't need them since we're starting binding
-        // from scratch again
-        mBindOnResumeCallbacks.clear();
-
-        // Clear the workspace because it's going to be rebound
-        mWorkspace.clearDropTargets();
-        mWorkspace.removeAllWorkspaceScreens();
-
-        mWidgetsToAdvance.clear();
-        if (mHotseat != null) {
-            mHotseat.resetLayout();
-        }
-    }
-
-    @Override
-    public void bindScreens(ArrayList<Long> orderedScreenIds) {
-        bindAddScreens(orderedScreenIds);
-
-        // If there are no screens, we need to have an empty screen
-        if (orderedScreenIds.size() == 0) {
-            mWorkspace.addExtraEmptyScreen();
-        }
-
-        // Create the custom content page (this call updates mDefaultScreen which calls
-        // setCurrentPage() so ensure that all pages are added before calling this).
-        if (hasCustomContentToLeft()) {
-            mWorkspace.createCustomContentContainer();
-            populateCustomContentContainer();
-        }
-    }
-
-    @Override
-    public void bindAddScreens(ArrayList<Long> orderedScreenIds) {
-        int count = orderedScreenIds.size();
-        for (int i = 0; i < count; i++) {
-            mWorkspace.insertNewWorkspaceScreenBeforeEmptyScreen(orderedScreenIds.get(i));
-        }
-    }
-
-    public void bindAppsAdded(final ArrayList<Long> newScreens,
-                              final ArrayList<ItemInfo> addNotAnimated,
-                              final ArrayList<ItemInfo> addAnimated,
-                              final ArrayList<AppInfo> addedApps) {
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "bindAppsAdded: " + Log.getStackTraceString(new Throwable())
-                    +", addedApps = " + addedApps);
-        }
-        Runnable r = new Runnable() {
-            public void run() {
-                bindAppsAdded(newScreens, addNotAnimated, addAnimated, addedApps);
-            }
-        };
-        if (waitUntilResume(r)) {
-            return;
-        }
-
-        // Add the new screens
-        if (newScreens != null) {
-            bindAddScreens(newScreens);
-        }
-
-        // We add the items without animation on non-visible pages, and with
-        // animations on the new page (which we will try and snap to).
-        if (addNotAnimated != null && !addNotAnimated.isEmpty()) {
-            bindItems(addNotAnimated, 0,
-                    addNotAnimated.size(), false);
-        }
-        if (addAnimated != null && !addAnimated.isEmpty()) {
-            bindItems(addAnimated, 0,
-                    addAnimated.size(), true);
-        }
-
-        // Remove the extra empty screen
-        mWorkspace.removeExtraEmptyScreen(false, false);
-
-        if (addedApps != null && mAppsView != null) {
-            mAppsView.addApps(addedApps);
-        }
-    }
-
-    /**
-     * Bind the items start-end from the list.
-     *
-     * Implementation of the method from LauncherModel.Callbacks.
-     */
-    @Override
-    public void bindItems(final ArrayList<ItemInfo> shortcuts, final int start, final int end,
-                          final boolean forceAnimateIcons) {
-        Runnable r = new Runnable() {
-            public void run() {
-                bindItems(shortcuts, start, end, forceAnimateIcons);
-            }
-        };
-        if (waitUntilResume(r)) {
-            return;
-        }
-
-        // Get the list of added shortcuts and intersect them with the set of shortcuts here
-        final AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
-        final Collection<Animator> bounceAnims = new ArrayList<Animator>();
-        final boolean animateIcons = forceAnimateIcons && canRunNewAppsAnimation();
-        Workspace workspace = mWorkspace;
-        long newShortcutsScreenId = -1;
-        for (int i = start; i < end; i++) {
-            final ItemInfo item = shortcuts.get(i);
-            if (LogUtils.DEBUG_ALL) {
-                LogUtils.d(TAG, "bindItems: start = " + start + ", end = " + end
-                        + "item = " + item + ", this = " + this);
-            }
-
-            // Short circuit if we are loading dock items for a configuration which has no dock
-            if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT &&
-                    mHotseat == null) {
-                continue;
-            }
-
-            final View view;
-            switch (item.itemType) {
-                case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
-                case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
-                    ShortcutInfo info = (ShortcutInfo) item;
-                    view = createShortcut(info);
-
-                    /*
-                     * TODO: FIX collision case
-                     */
-                    if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
-                        CellLayout cl = mWorkspace.getScreenWithId(item.screenId);
-                        if (cl != null && cl.isOccupied(item.cellX, item.cellY)) {
-                            View v = cl.getChildAt(item.cellX, item.cellY);
-                            Object tag = v.getTag();
-                            String desc = "Collision while binding workspace item: " + item
-                                    + ". Collides with " + tag;
-                            if (LauncherAppState.isDogfoodBuild()) {
-                                throw (new RuntimeException(desc));
-                            } else {
-                                Log.d(TAG, desc);
-                            }
-                        }
-                    }
-                    break;
-                case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
-                    view = FolderIcon.fromXml(R.layout.folder_icon, this,
-                            (ViewGroup) workspace.getChildAt(workspace.getCurrentPage()),
-                            (FolderInfo) item, mIconCache);
-                    break;
-                default:
-                    throw new RuntimeException("Invalid Item Type");
-            }
-
-            workspace.addInScreenFromBind(view, item.container, item.screenId, item.cellX,
-                    item.cellY, 1, 1);
-            if (animateIcons) {
-                // Animate all the applications up now
-                view.setAlpha(0f);
-                view.setScaleX(0f);
-                view.setScaleY(0f);
-                bounceAnims.add(createNewAppBounceAnimation(view, i));
-                newShortcutsScreenId = item.screenId;
-            }
-        }
-
-        if (animateIcons) {
-            // Animate to the correct page
-            if (newShortcutsScreenId > -1) {
-                long currentScreenId = mWorkspace.getScreenIdForPageIndex(mWorkspace.getNextPage());
-                final int newScreenIndex = mWorkspace.getPageIndexForScreenId(newShortcutsScreenId);
-                final Runnable startBounceAnimRunnable = new Runnable() {
-                    public void run() {
-                        anim.playTogether(bounceAnims);
-                        anim.start();
-                    }
-                };
-                if (newShortcutsScreenId != currentScreenId) {
-                    // We post the animation slightly delayed to prevent slowdowns
-                    // when we are loading right after we return to launcher.
-                    mWorkspace.postDelayed(new Runnable() {
-                        public void run() {
-                            if (mWorkspace != null) {
-                                mWorkspace.snapToPage(newScreenIndex);
-                                mWorkspace.postDelayed(startBounceAnimRunnable,
-                                        NEW_APPS_ANIMATION_DELAY);
-                            }
-                        }
-                    }, NEW_APPS_PAGE_MOVE_DELAY);
-                } else {
-                    mWorkspace.postDelayed(startBounceAnimRunnable, NEW_APPS_ANIMATION_DELAY);
-                }
-            }
-        }
-        workspace.requestLayout();
-    }
-
-    /**
-     * Implementation of the method from LauncherModel.Callbacks.
-     */
-    public void bindFolders(final LongArrayMap<FolderInfo> folders) {
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "bindFolders: this = " + this);
-        }
-        Runnable r = new Runnable() {
-            public void run() {
-                bindFolders(folders);
-            }
-        };
-        if (waitUntilResume(r)) {
-            return;
-        }
-        sFolders = folders.clone();
-    }
-
-    private void bindSafeModeWidget(LauncherAppWidgetInfo item) {
-        PendingAppWidgetHostView view = new PendingAppWidgetHostView(this, item, true);
-        view.updateIcon(mIconCache);
-        item.hostView = view;
-        item.hostView.updateAppWidget(null);
-        item.hostView.setOnClickListener(this);
-        addAppWidgetToWorkspace(item, null, false);
-        mWorkspace.requestLayout();
-    }
-
-    /**
-     * Add the views for a widget to the workspace.
-     *
-     * Implementation of the method from LauncherModel.Callbacks.
-     */
-    public void bindAppWidget(final LauncherAppWidgetInfo item) {
-        Runnable r = new Runnable() {
-            public void run() {
-                bindAppWidget(item);
-            }
-        };
-        if (waitUntilResume(r)) {
-            return;
-        }
-
-        if (mIsSafeModeEnabled) {
-            bindSafeModeWidget(item);
-            return;
-        }
-
-        final long start = DEBUG_WIDGETS ? SystemClock.uptimeMillis() : 0;
-        if (DEBUG_WIDGETS) {
-            Log.d(TAG, "bindAppWidget: " + item);
-        }
-
-        final LauncherAppWidgetProviderInfo appWidgetInfo;
-
-        if (item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)) {
-            // If the provider is not ready, bind as a pending widget.
-            appWidgetInfo = null;
-        } else if (item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_ID_NOT_VALID)) {
-            // The widget id is not valid. Try to find the widget based on the provider info.
-            appWidgetInfo = mAppWidgetManager.findProvider(item.providerName, item.user);
-        } else {
-            appWidgetInfo = mAppWidgetManager.getLauncherAppWidgetInfo(item.appWidgetId);
-        }
-
-        // If the provider is ready, but the width is not yet restored, try to restore it.
-        if (!item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) &&
-                (item.restoreStatus != LauncherAppWidgetInfo.RESTORE_COMPLETED)) {
-            if (appWidgetInfo == null) {
-                if (DEBUG_WIDGETS) {
-                    Log.d(TAG, "Removing restored widget: id=" + item.appWidgetId
-                            + " belongs to component " + item.providerName
-                            + ", as the povider is null");
-                }
-                LauncherModel.deleteItemFromDatabase(this, item);
-                return;
-            }
-
-            // If we do not have a valid id, try to bind an id.
-            if (item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_ID_NOT_VALID)) {
-                // Note: This assumes that the id remap broadcast is received before this step.
-                // If that is not the case, the id remap will be ignored and user may see the
-                // click to setup view.
-                PendingAddWidgetInfo pendingInfo = new PendingAddWidgetInfo(this, appWidgetInfo, null);
-                pendingInfo.spanX = item.spanX;
-                pendingInfo.spanY = item.spanY;
-                pendingInfo.minSpanX = item.minSpanX;
-                pendingInfo.minSpanY = item.minSpanY;
-                Bundle options = WidgetHostViewLoader.getDefaultOptionsForWidget(this, pendingInfo);
-
-                int newWidgetId = mAppWidgetHost.allocateAppWidgetId();
-                boolean success = mAppWidgetManager.bindAppWidgetIdIfAllowed(
-                        newWidgetId, appWidgetInfo, options);
-
-                // TODO consider showing a permission dialog when the widget is clicked.
-                if (!success) {
-                    mAppWidgetHost.deleteAppWidgetId(newWidgetId);
-                    if (DEBUG_WIDGETS) {
-                        Log.d(TAG, "Removing restored widget: id=" + item.appWidgetId
-                                + " belongs to component " + item.providerName
-                                + ", as the launcher is unable to bing a new widget id");
-                    }
-                    LauncherModel.deleteItemFromDatabase(this, item);
-                    return;
-                }
-
-                item.appWidgetId = newWidgetId;
-
-                // If the widget has a configure activity, it is still needs to set it up, otherwise
-                // the widget is ready to go.
-                item.restoreStatus = (appWidgetInfo.configure == null)
-                        ? LauncherAppWidgetInfo.RESTORE_COMPLETED
-                        : LauncherAppWidgetInfo.FLAG_UI_NOT_READY;
-
-                LauncherModel.updateItemInDatabase(this, item);
-            } else if (item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_UI_NOT_READY)
-                    && (appWidgetInfo.configure == null)) {
-                // The widget was marked as UI not ready, but there is no configure activity to
-                // update the UI.
-                item.restoreStatus = LauncherAppWidgetInfo.RESTORE_COMPLETED;
-                LauncherModel.updateItemInDatabase(this, item);
-            }
-        }
-
-        if (item.restoreStatus == LauncherAppWidgetInfo.RESTORE_COMPLETED) {
-            if (DEBUG_WIDGETS) {
-                Log.d(TAG, "bindAppWidget: id=" + item.appWidgetId + " belongs to component "
-                        + appWidgetInfo.provider);
-            }
-
-            // Verify that we own the widget
-            if (appWidgetInfo == null) {
-                Log.e(TAG, "Removing invalid widget: id=" + item.appWidgetId);
-                deleteWidgetInfo(item);
-                return;
-            }
-
-            item.hostView = mAppWidgetHost.createView(this, item.appWidgetId, appWidgetInfo);
-            item.minSpanX = appWidgetInfo.minSpanX;
-            item.minSpanY = appWidgetInfo.minSpanY;
-            addAppWidgetToWorkspace(item, appWidgetInfo, false);
-        } else {
-            PendingAppWidgetHostView view = new PendingAppWidgetHostView(this, item,
-                    mIsSafeModeEnabled);
-            view.updateIcon(mIconCache);
-            item.hostView = view;
-            item.hostView.updateAppWidget(null);
-            item.hostView.setOnClickListener(this);
-            addAppWidgetToWorkspace(item, null, false);
-        }
-        mWorkspace.requestLayout();
-
-        if (DEBUG_WIDGETS) {
-            Log.d(TAG, "bound widget id="+item.appWidgetId+" in "
-                    + (SystemClock.uptimeMillis()-start) + "ms");
-        }
-    }
-
-    /**
-     * Restores a pending widget.
-     *
-     * @param appWidgetId The app widget id
-     * @param cellInfo The position on screen where to create the widget.
-     */
-    private void completeRestoreAppWidget(final int appWidgetId) {
-        LauncherAppWidgetHostView view = mWorkspace.getWidgetForAppWidgetId(appWidgetId);
-        if ((view == null) || !(view instanceof PendingAppWidgetHostView)) {
-            Log.e(TAG, "Widget update called, when the widget no longer exists.");
-            return;
-        }
-
-        LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) view.getTag();
-        info.restoreStatus = LauncherAppWidgetInfo.RESTORE_COMPLETED;
-
-        mWorkspace.reinflateWidgetsIfNecessary();
-        LauncherModel.updateItemInDatabase(this, info);
-    }
-
-    public void onPageBoundSynchronously(int page) {
-        mSynchronouslyBoundPages.add(page);
-    }
-
-    /**
-     * Callback saying that there aren't any more items to bind.
-     *
-     * Implementation of the method from LauncherModel.Callbacks.
-     */
-    public void finishBindingItems() {
-        if (LogUtils.DEBUG) {
-            LogUtils.d(TAG, "finishBindingItems: mSavedState = " + mSavedState + ", mSavedInstanceState = " + mSavedInstanceState);
-        }
-        Runnable r = new Runnable() {
-            public void run() {
-                finishBindingItems();
-            }
-        };
-        if (waitUntilResume(r)) {
-            return;
-        }
-        if (mSavedState != null) {
-            if (!mWorkspace.hasFocus()) {
-                mWorkspace.getChildAt(mWorkspace.getCurrentPage()).requestFocus();
-            }
-            mSavedState = null;
-        }
-
-        mWorkspace.restoreInstanceStateForRemainingPages();
-
-        setWorkspaceLoading(false);
-        sendLoadingCompleteBroadcastIfNecessary();
-        if (LogUtils.DEBUG_LOADER)LogUtils.d(TAG, "WorkspaceLoading Complete");
-
-        // If we received the result of any pending adds while the loader was running (e.g. the
-        // widget configuration forced an orientation change), process them now.
-        if (sPendingAddItem != null) {
-            final long screenId = completeAdd(sPendingAddItem);
-
-            // TODO: this moves the user to the page where the pending item was added. Ideally,
-            // the screen would be guaranteed to exist after bind, and the page would be set through
-            // the workspace restore process.
-            mWorkspace.post(new Runnable() {
-                @Override
-                public void run() {
-                    if (mWorkspace != null) {
-                        mWorkspace.snapToScreenId(screenId);
-                    }
-                }
-            });
-            sPendingAddItem = null;
-        }
-
-        InstallShortcutReceiver.disableAndFlushInstallQueue(this);
-
-        /*SPRD:598450 There is a empty screen when roating the screen @{*/
-        if(!mHasConfigWidget){
-            mWorkspace.removeExtraEmptyScreen(false, false);
-        }
-        /* @} */
-
-        if (FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
-            if (mUnreadLoadCompleted) {
-                bindWorkspaceUnreadInfo();
-            }
-            mBindingWorkspaceFinished = true;
-        }
-
-        if (FeatureOption.SPRD_DYNAMIC_ICON_SUPPORT) {
-            if (mDynamicIconLoadCompleted) {
-                bindWorkspaceDynamicInfo();
-            }
-            mBindingWorkspaceCompleted = true;
-        }
-
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.finishBindingItems(false);
-        }
-    }
-
-    private void sendLoadingCompleteBroadcastIfNecessary() {
-        if (!mSharedPrefs.getBoolean(FIRST_LOAD_COMPLETE, false)) {
-            String permission =
-                    getResources().getString(R.string.receive_first_load_broadcast_permission);
-            Intent intent = new Intent(ACTION_FIRST_LOAD_COMPLETE);
-            sendBroadcast(intent, permission);
-            SharedPreferences.Editor editor = mSharedPrefs.edit();
-            editor.putBoolean(FIRST_LOAD_COMPLETE, true);
-            editor.apply();
-        }
-    }
-
-    public boolean isAllAppsButtonRank(int rank) {
-        if (mHotseat != null) {
-            return mHotseat.isAllAppsButtonRank(rank);
-        }
-        return false;
-    }
-
-    private boolean canRunNewAppsAnimation() {
-        long diff = System.currentTimeMillis() - mDragController.getLastGestureUpTime();
-        return diff > (NEW_APPS_ANIMATION_INACTIVE_TIMEOUT_SECONDS * 1000)
-                && (mClings == null || !mClings.isVisible());
-    }
-
-    private ValueAnimator createNewAppBounceAnimation(View v, int i) {
-        ValueAnimator bounceAnim = LauncherAnimUtils.ofPropertyValuesHolder(v,
-                PropertyValuesHolder.ofFloat("alpha", 1f),
-                PropertyValuesHolder.ofFloat("scaleX", 1f),
-                PropertyValuesHolder.ofFloat("scaleY", 1f));
-        bounceAnim.setDuration(InstallShortcutReceiver.NEW_SHORTCUT_BOUNCE_DURATION);
-        bounceAnim.setStartDelay(i * InstallShortcutReceiver.NEW_SHORTCUT_STAGGER_DELAY);
-        bounceAnim.setInterpolator(new OvershootInterpolator(BOUNCE_ANIMATION_TENSION));
-        return bounceAnim;
-    }
-
-    public boolean useVerticalBarLayout() {
-        return mDeviceProfile.isVerticalBarLayout();
-    }
-
-    /** Returns the search bar bounds in pixels. */
-    public Rect getSearchBarBounds() {
-        return mDeviceProfile.getSearchBarBounds(Utilities.isRtl(getResources()));
-    }
-
-    public int getSearchBarHeight() {
-        if (mLauncherCallbacks != null) {
-            return mLauncherCallbacks.getSearchBarHeight();
-        }
-        return LauncherCallbacks.SEARCH_BAR_HEIGHT_NORMAL;
-    }
-
-    public void bindSearchProviderChanged() {
-        if(FeatureOption.SPRD_HIDESEARCHBAR_SUPPORT) {
-            return;
-        }
-        if (mSearchDropTargetBar == null) {
-            return;
-        }
-        if (mQsb != null) {
-            mSearchDropTargetBar.removeView(mQsb);
-            mQsb = null;
-        }
-        mSearchDropTargetBar.setQsbSearchBar(getOrCreateQsbBar());
-    }
-
-    /**
-     * A runnable that we can dequeue and re-enqueue when all applications are bound (to prevent
-     * multiple calls to bind the same list.)
-     */
-    @Thunk ArrayList<AppInfo> mTmpAppsList;
-    private Runnable mBindAllApplicationsRunnable = new Runnable() {
-        public void run() {
-            bindAllApplications(mTmpAppsList);
-            mTmpAppsList = null;
-        }
-    };
-
-    /**
-     * Add the icons for all apps.
-     *
-     * Implementation of the method from LauncherModel.Callbacks.
-     */
-    public void bindAllApplications(final ArrayList<AppInfo> apps) {
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "bindAllApplications: apps.size = " + apps.size());
-        }
-        if (waitUntilResume(mBindAllApplicationsRunnable, true)) {
-            mTmpAppsList = apps;
-            return;
-        }
-
-        if (mDynamicIconUtils != null) {
-            mDynamicIconUtils.updateDIDCInAppInfo(apps);
-        }
-
-        if (mAppsView != null) {
-            mAppsView.setApps(apps);
-        }
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.bindAllApplications(apps);
-        }
-    }
-
-    /**
-     * A package was updated.
-     *
-     * Implementation of the method from LauncherModel.Callbacks.
-     */
-    public void bindAppsUpdated(final ArrayList<AppInfo> apps) {
-        if (LogUtils.DEBUG) {
-            LogUtils.d(TAG, "bindAppsUpdated: apps = " + apps);
-        }
-        Runnable r = new Runnable() {
-            public void run() {
-                bindAppsUpdated(apps);
-            }
-        };
-        if (waitUntilResume(r)) {
-            return;
-        }
-
-        if (mAppsView != null) {
-            mAppsView.updateApps(apps);
-        }
-    }
-
-    @Override
-    public void bindWidgetsRestored(final ArrayList<LauncherAppWidgetInfo> widgets) {
-        Runnable r = new Runnable() {
-            public void run() {
-                bindWidgetsRestored(widgets);
-            }
-        };
-        if (waitUntilResume(r)) {
-            return;
-        }
-        mWorkspace.widgetsRestored(widgets);
-    }
-
-    /**
-     * Some shortcuts were updated in the background.
-     *
-     * Implementation of the method from LauncherModel.Callbacks.
-     */
-    @Override
-    public void bindShortcutsChanged(final ArrayList<ShortcutInfo> updated,
-            final ArrayList<ShortcutInfo> removed, final UserHandleCompat user) {
-        Runnable r = new Runnable() {
-            public void run() {
-                bindShortcutsChanged(updated, removed, user);
-            }
-        };
-        if (waitUntilResume(r)) {
-            return;
-        }
-
-        if (!updated.isEmpty()) {
-            mWorkspace.updateShortcuts(updated);
-        }
-
-        if (!removed.isEmpty()) {
-            HashSet<ComponentName> removedComponents = new HashSet<ComponentName>();
-            for (ShortcutInfo si : removed) {
-                removedComponents.add(si.getTargetComponent());
-            }
-            mWorkspace.removeItemsByComponentName(removedComponents, user);
-            // Notify the drag controller
-            mDragController.onAppsRemoved(new HashSet<String>(), removedComponents);
-        }
-    }
-
-    /**
-     * Update the state of a package, typically related to install state.
-     *
-     * Implementation of the method from LauncherModel.Callbacks.
-     */
-    @Override
-    public void bindRestoreItemsChange(final HashSet<ItemInfo> updates) {
-        Runnable r = new Runnable() {
-            public void run() {
-                bindRestoreItemsChange(updates);
-            }
-        };
-        if (waitUntilResume(r)) {
-            return;
-        }
-
-        mWorkspace.updateRestoreItems(updates);
-    }
-
-    /**
-     * A package was uninstalled/updated.  We take both the super set of packageNames
-     * in addition to specific applications to remove, the reason being that
-     * this can be called when a package is updated as well.  In that scenario,
-     * we only remove specific components from the workspace and hotseat, where as
-     * package-removal should clear all items by package name.
-     */
-    @Override
-    public void bindWorkspaceComponentsRemoved(
-            final HashSet<String> packageNames, final HashSet<ComponentName> components,
-            final UserHandleCompat user) {
-        if (LogUtils.DEBUG_ALL) {
-            LogUtils.d(TAG, "bindComponentsRemoved: " + Log.getStackTraceString(new Throwable())+
-                    ", packageNames = " + packageNames);
-        }
-        Runnable r = new Runnable() {
-            public void run() {
-                bindWorkspaceComponentsRemoved(packageNames, components, user);
-            }
-        };
-        if (waitUntilResume(r)) {
-            return;
-        }
-        if (!packageNames.isEmpty()) {
-            mWorkspace.removeItemsByPackageName(packageNames, user);
-        }
-        if (!components.isEmpty()) {
-            mWorkspace.removeItemsByComponentName(components, user);
-        }
-        // Notify the drag controller
-        mDragController.onAppsRemoved(packageNames, components);
-
-    }
-
-    @Override
-    public void bindAppInfosRemoved(final ArrayList<AppInfo> appInfos) {
-        Runnable r = new Runnable() {
-            public void run() {
-                bindAppInfosRemoved(appInfos);
-            }
-        };
-        if (waitUntilResume(r)) {
-            return;
-        }
-
-        // Update AllApps
-        if (mAppsView != null) {
-            mAppsView.removeApps(appInfos);
-            if (mPredictedAppController != null) {
-                mPredictedAppController.removeAppsFromPredicteList(appInfos);
-            }
-        }
-    }
-
-    private Runnable mBindWidgetModelRunnable = new Runnable() {
-            public void run() {
-                bindWidgetsModel(mWidgetsModel);
-            }
-        };
-
-    @Override
-    public void bindWidgetsModel(WidgetsModel model) {
-        if (waitUntilResume(mBindWidgetModelRunnable, true)) {
-            mWidgetsModel = model;
-            return;
-        }
-
-        if (mWidgetsView != null && model != null) {
-            mWidgetsView.addWidgets(model);
-            mWidgetsModel = null;
-        }
-    }
-
-    @Override
-    public void notifyWidgetProvidersChanged() {
-        if (mWorkspace != null && mWorkspace.getState().shouldUpdateWidget) {
-            mModel.refreshAndBindWidgetsAndShortcuts(this, mWidgetsView.isEmpty());
-        }
-    }
-
-    private int mapConfigurationOriActivityInfoOri(int configOri) {
-        final Display d = getWindowManager().getDefaultDisplay();
-        int naturalOri = Configuration.ORIENTATION_LANDSCAPE;
-        switch (d.getRotation()) {
-        case Surface.ROTATION_0:
-        case Surface.ROTATION_180:
-            // We are currently in the same basic orientation as the natural orientation
-            naturalOri = configOri;
-            break;
-        case Surface.ROTATION_90:
-        case Surface.ROTATION_270:
-            // We are currently in the other basic orientation to the natural orientation
-            naturalOri = (configOri == Configuration.ORIENTATION_LANDSCAPE) ?
-                    Configuration.ORIENTATION_PORTRAIT : Configuration.ORIENTATION_LANDSCAPE;
-            break;
-        }
-
-        int[] oriMap = {
-                ActivityInfo.SCREEN_ORIENTATION_PORTRAIT,
-                ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE,
-                ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT,
-                ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE
-        };
-        // Since the map starts at portrait, we need to offset if this device's natural orientation
-        // is landscape.
-        int indexOffset = 0;
-        if (naturalOri == Configuration.ORIENTATION_LANDSCAPE) {
-            indexOffset = 1;
-        }
-        return oriMap[(d.getRotation() + indexOffset) % 4];
-    }
-
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)
-    public void lockScreenOrientation() {
-        if (mRotationEnabled) {
-            if (Utilities.ATLEAST_JB_MR2) {
-                setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LOCKED);
-            } else {
-                setRequestedOrientation(mapConfigurationOriActivityInfoOri(getResources()
-                        .getConfiguration().orientation));
-            }
-        }
-    }
-
-    public void unlockScreenOrientation(boolean immediate) {
-        if (mRotationEnabled) {
-            if (immediate) {
-                setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
-            } else {
-                mHandler.postDelayed(new Runnable() {
-                    public void run() {
-                        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
-                    }
-                }, mRestoreScreenOrientationDelay);
-            }
-        }
-    }
-
-    protected boolean isLauncherPreinstalled() {
-        if (mLauncherCallbacks != null) {
-            return mLauncherCallbacks.isLauncherPreinstalled();
-        }
-        PackageManager pm = getPackageManager();
-        try {
-            ApplicationInfo ai = pm.getApplicationInfo(getComponentName().getPackageName(), 0);
-            if ((ai.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
-                return true;
-            } else {
-                return false;
-            }
-        } catch (NameNotFoundException e) {
-            e.printStackTrace();
-            return false;
-        }
-    }
-
-    /**
-     * This method indicates whether or not we should suggest default wallpaper dimensions
-     * when our wallpaper cropper was not yet used to set a wallpaper.
-     */
-    protected boolean overrideWallpaperDimensions() {
-        if (mLauncherCallbacks != null) {
-            return mLauncherCallbacks.overrideWallpaperDimensions();
-        }
-        return true;
-    }
-
-    /**
-     * To be overridden by subclasses to indicate that there is an activity to launch
-     * before showing the standard launcher experience.
-     */
-    protected boolean hasFirstRunActivity() {
-        if (mLauncherCallbacks != null) {
-            return mLauncherCallbacks.hasFirstRunActivity();
-        }
-        return false;
-    }
-
-    /**
-     * To be overridden by subclasses to launch any first run activity
-     */
-    protected Intent getFirstRunActivity() {
-        if (mLauncherCallbacks != null) {
-            return mLauncherCallbacks.getFirstRunActivity();
-        }
-        return null;
-    }
-
-    private boolean shouldRunFirstRunActivity() {
-        return !ActivityManager.isRunningInTestHarness() &&
-                !mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false);
-    }
-
-    protected boolean hasRunFirstRunActivity() {
-        return mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false);
-    }
-
-    public boolean showFirstRunActivity() {
-        if (shouldRunFirstRunActivity() &&
-                hasFirstRunActivity()) {
-            Intent firstRunIntent = getFirstRunActivity();
-            if (firstRunIntent != null) {
-                startActivity(firstRunIntent);
-                markFirstRunActivityShown();
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private void markFirstRunActivityShown() {
-        SharedPreferences.Editor editor = mSharedPrefs.edit();
-        editor.putBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, true);
-        editor.apply();
-    }
-
-    /**
-     * To be overridden by subclasses to indicate that there is an in-activity full-screen intro
-     * screen that must be displayed and dismissed.
-     */
-    protected boolean hasDismissableIntroScreen() {
-        if (mLauncherCallbacks != null) {
-            return mLauncherCallbacks.hasDismissableIntroScreen();
-        }
-        return false;
-    }
-
-    /**
-     * Full screen intro screen to be shown and dismissed before the launcher can be used.
-     */
-    protected View getIntroScreen() {
-        if (mLauncherCallbacks != null) {
-            return mLauncherCallbacks.getIntroScreen();
-        }
-        return null;
-    }
-
-    /**
-     * To be overriden by subclasses to indicate whether the in-activity intro screen has been
-     * dismissed. This method is ignored if #hasDismissableIntroScreen returns false.
-     */
-    private boolean shouldShowIntroScreen() {
-        return hasDismissableIntroScreen() &&
-                !mSharedPrefs.getBoolean(INTRO_SCREEN_DISMISSED, false);
-    }
-
-    protected void showIntroScreen() {
-        View introScreen = getIntroScreen();
-        changeWallpaperVisiblity(false);
-        if (introScreen != null) {
-            mDragLayer.showOverlayView(introScreen);
-        }
-    }
-
-    public void dismissIntroScreen() {
-        markIntroScreenDismissed();
-        if (showFirstRunActivity()) {
-            // We delay hiding the intro view until the first run activity is showing. This
-            // avoids a blip.
-            mWorkspace.postDelayed(new Runnable() {
-                @Override
-                public void run() {
-                    mDragLayer.dismissOverlayView();
-                    showFirstRunClings();
-                }
-            }, ACTIVITY_START_DELAY);
-        } else {
-            mDragLayer.dismissOverlayView();
-            showFirstRunClings();
-        }
-        changeWallpaperVisiblity(true);
-    }
-
-    private void markIntroScreenDismissed() {
-        SharedPreferences.Editor editor = mSharedPrefs.edit();
-        editor.putBoolean(INTRO_SCREEN_DISMISSED, true);
-        editor.apply();
-    }
-
-    @Thunk void showFirstRunClings() {
-        // The two first run cling paths are mutually exclusive, if the launcher is preinstalled
-        // on the device, then we always show the first run cling experience (or if there is no
-        // launcher2). Otherwise, we prompt the user upon started for migration
-        LauncherClings launcherClings = new LauncherClings(this);
-        if (launcherClings.shouldShowFirstRunOrMigrationClings()) {
-            mClings = launcherClings;
-            if (mModel.canMigrateFromOldLauncherDb(this)) {
-                launcherClings.showMigrationCling();
-            } else {
-                launcherClings.showLongPressCling(true);
-            }
-        }
-    }
-
-    public void showWorkspaceSearchAndHotseat() {
-        if (mWorkspace != null) mWorkspace.setAlpha(1f);
-        if (mHotseat != null) mHotseat.setAlpha(1f);
-        if (mPageIndicators != null) mPageIndicators.setAlpha(1f);
-        if (mSearchDropTargetBar != null) mSearchDropTargetBar.animateToState(
-                SearchDropTargetBar.State.SEARCH_BAR, 0);
-    }
-
-    void hideWorkspaceSearchAndHotseat() {
-        if (mWorkspace != null) mWorkspace.setAlpha(0f);
-        if (mHotseat != null) mHotseat.setAlpha(0f);
-        if (mPageIndicators != null) mPageIndicators.setAlpha(0f);
-        if (mSearchDropTargetBar != null) mSearchDropTargetBar.animateToState(
-                SearchDropTargetBar.State.INVISIBLE, 0);
-    }
-
-    // TODO: These method should be a part of LauncherSearchCallback
-    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
-    public ItemInfo createAppDragInfo(Intent appLaunchIntent) {
-        // Called from search suggestion
-        UserHandleCompat user = null;
-        if (Utilities.ATLEAST_LOLLIPOP) {
-            UserHandle userHandle = appLaunchIntent.getParcelableExtra(Intent.EXTRA_USER);
-            if (userHandle != null) {
-                user = UserHandleCompat.fromUser(userHandle);
-            }
-        }
-        return createAppDragInfo(appLaunchIntent, user);
-    }
-
-    // TODO: This method should be a part of LauncherSearchCallback
-    public ItemInfo createAppDragInfo(Intent intent, UserHandleCompat user) {
-        if (user == null) {
-            user = UserHandleCompat.myUserHandle();
-        }
-
-        // Called from search suggestion, add the profile extra to the intent to ensure that we
-        // can launch it correctly
-        LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
-        LauncherActivityInfoCompat activityInfo = launcherApps.resolveActivity(intent, user);
-        if (activityInfo == null) {
-            return null;
-        }
-        return new AppInfo(this, activityInfo, user, mIconCache);
-    }
-
-    // TODO: This method should be a part of LauncherSearchCallback
-    public ItemInfo createShortcutDragInfo(Intent shortcutIntent, CharSequence caption,
-            Bitmap icon) {
-        return new ShortcutInfo(shortcutIntent, caption, caption, icon,
-                UserHandleCompat.myUserHandle());
-    }
-
-    // TODO: This method should be a part of LauncherSearchCallback
-    public void startDrag(View dragView, ItemInfo dragInfo, DragSource source) {
-        dragView.setTag(dragInfo);
-        mWorkspace.onExternalDragStartedWithItem(dragView);
-        mWorkspace.beginExternalDragShared(dragView, source);
-    }
-
-    protected void moveWorkspaceToDefaultScreen() {
-        mWorkspace.moveToDefaultScreen(false);
-    }
-
-    @Override
-    public void onPageSwitch(View newPage, int newPageIndex) {
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.onPageSwitch(newPage, newPageIndex);
-        }
-    }
-
-    /**
-     * Returns a FastBitmapDrawable with the icon, accurately sized.
-     */
-    public FastBitmapDrawable createIconDrawable(Bitmap icon) {
-        FastBitmapDrawable d = new FastBitmapDrawable(icon);
-        d.setFilterBitmap(true);
-        resizeIconDrawable(d);
-        return d;
-    }
-
-    /**
-     * Resizes an icon drawable to the correct icon size.
-     */
-    public Drawable resizeIconDrawable(Drawable icon) {
-        icon.setBounds(0, 0, mDeviceProfile.iconSizePx, mDeviceProfile.iconSizePx);
-        return icon;
-    }
-
-    /**
-     * Prints out out state for debugging.
-     */
-    public void dumpState() {
-        Log.d(TAG, "BEGIN launcher3 dump state for launcher " + this);
-        Log.d(TAG, "mSavedState=" + mSavedState);
-        Log.d(TAG, "mWorkspaceLoading=" + mWorkspaceLoading);
-        Log.d(TAG, "mRestoring=" + mRestoring);
-        Log.d(TAG, "mWaitingForResult=" + mWaitingForResult);
-        Log.d(TAG, "mSavedInstanceState=" + mSavedInstanceState);
-        Log.d(TAG, "sFolders.size=" + sFolders.size());
-        mModel.dumpState();
-        // TODO(hyunyoungs): add mWidgetsView.dumpState(); or mWidgetsModel.dumpState();
-
-        Log.d(TAG, "END launcher3 dump state");
-    }
-
-    @Override
-    public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args) {
-        super.dump(prefix, fd, writer, args);
-        synchronized (sDumpLogs) {
-            writer.println(" ");
-            writer.println("Debug logs: ");
-            for (int i = 0; i < sDumpLogs.size(); i++) {
-                writer.println("  " + sDumpLogs.get(i));
-            }
-        }
-        if (mLauncherCallbacks != null) {
-            mLauncherCallbacks.dump(prefix, fd, writer, args);
-        }
-    }
-
-    public static void dumpDebugLogsToConsole() {
-        if (DEBUG_DUMP_LOG) {
-            synchronized (sDumpLogs) {
-                Log.d(TAG, "");
-                Log.d(TAG, "*********************");
-                Log.d(TAG, "Launcher debug logs: ");
-                for (int i = 0; i < sDumpLogs.size(); i++) {
-                    Log.d(TAG, "  " + sDumpLogs.get(i));
-                }
-                Log.d(TAG, "*********************");
-                Log.d(TAG, "");
-            }
-        }
-    }
-
-    public static void addDumpLog(String tag, String log, boolean debugLog) {
-        addDumpLog(tag, log, null, debugLog);
-    }
-
-    public static void addDumpLog(String tag, String log, Exception e, boolean debugLog) {
-        if (debugLog) {
-            if (e != null) {
-                Log.d(tag, log, e);
-            } else {
-                Log.d(tag, log);
-            }
-        }
-        if (DEBUG_DUMP_LOG) {
-            sDateStamp.setTime(System.currentTimeMillis());
-            synchronized (sDumpLogs) {
-                sDumpLogs.add(sDateFormat.format(sDateStamp) + ": " + tag + ", " + log
-                    + (e == null ? "" : (", Exception: " + e)));
-            }
-        }
-    }
-
-    public static CustomAppWidget getCustomAppWidget(String name) {
-        return sCustomAppWidgets.get(name);
-    }
-
-    public static HashMap<String, CustomAppWidget> getCustomAppWidgets() {
-        return sCustomAppWidgets;
-    }
-
-    public void dumpLogsToLocalData() {
-        if (DEBUG_DUMP_LOG) {
-            new AsyncTask<Void, Void, Void>() {
-                public Void doInBackground(Void ... args) {
-                    boolean success = false;
-                    sDateStamp.setTime(sRunStart);
-                    String FILENAME = sDateStamp.getMonth() + "-"
-                            + sDateStamp.getDay() + "_"
-                            + sDateStamp.getHours() + "-"
-                            + sDateStamp.getMinutes() + "_"
-                            + sDateStamp.getSeconds() + ".txt";
-
-                    FileOutputStream fos = null;
-                    File outFile = null;
-                    try {
-                        outFile = new File(getFilesDir(), FILENAME);
-                        outFile.createNewFile();
-                        fos = new FileOutputStream(outFile);
-                    } catch (Exception e) {
-                        e.printStackTrace();
-                    }
-                    if (fos != null) {
-                        PrintWriter writer = new PrintWriter(fos);
-
-                        writer.println(" ");
-                        writer.println("Debug logs: ");
-                        synchronized (sDumpLogs) {
-                            for (int i = 0; i < sDumpLogs.size(); i++) {
-                                writer.println("  " + sDumpLogs.get(i));
-                            }
-                        }
-                        writer.close();
-                    }
-                    try {
-                        if (fos != null) {
-                            fos.close();
-                            success = true;
-                        }
-                    } catch (IOException e) {
-                        e.printStackTrace();
-                    }
-                    return null;
-                }
-            }.executeOnExecutor(Utilities.THREAD_POOL_EXECUTOR);
-        }
-    }
-
-    public static List<View> getFolderContents(View icon) {
-        if (icon instanceof FolderIcon) {
-            return ((FolderIcon) icon).getFolder().getItemsInReadingOrder();
-        } else {
-            return Collections.EMPTY_LIST;
-        }
-    }
-
-    /**SPRD: Added for unread badge feature.@{**/
-
-    /**
-     * SPRD: Bind component unread information in workspace and all apps list.
-     *
-     * @param component the component name of the app.
-     * @param unreadNum the number of the unread message.
-     */
-    public void bindComponentUnreadChanged(final ComponentName component, final int unreadNum) {
-        if (LogUtils.DEBUG_UNREAD) {
-            LogUtils.d(TAG, "bindComponentUnreadChanged: component = " + component
-                    + ", unreadNum = " + unreadNum + ", this = " + this);
-        }
-        // Post to message queue to avoid possible ANR.
-        mHandler.post(new Runnable() {
-            public void run() {
-                final long start = System.currentTimeMillis();
-                if (LogUtils.DEBUG_PERFORMANCE) {
-                    LogUtils.d(TAG, "bindComponentUnreadChanged begin: component = " + component
-                            + ", unreadNum = " + unreadNum + ", start = " + start);
-                }
-
-                mUnreadLoaderUtils.bindComponentUnreadChanged(component, unreadNum);
-
-                if (LogUtils.DEBUG_PERFORMANCE) {
-                    LogUtils.d(TAG, "bindComponentUnreadChanged end: current time = "
-                            + System.currentTimeMillis() + ", time used = "
-                            + (System.currentTimeMillis() - start));
-                }
-            }
-        });
-    }
-
-    /**
-     * SPRD: Bind shortcuts unread number if binding process has finished.
-     */
-    public void bindUnreadInfoIfNeeded() {
-        if (LogUtils.DEBUG_UNREAD) {
-            LogUtils.d(TAG, "bindUnreadInfoIfNeeded: mBindingWorkspaceFinished = "
-                    + mBindingWorkspaceFinished + ", mBindingAppsFinished: "+mBindingAppsFinished +", thread = " + Thread.currentThread());
-        }
-        if (mBindingWorkspaceFinished) {
-            bindWorkspaceUnreadInfo();
-        }
-
-        if (mBindingAppsFinished) {
-            bindAppsUnreadInfo();
-        }
-        mUnreadLoadCompleted = true;
-    }
-
-    /**
-     * SPRD: Bind unread number to shortcuts with data in UnreadLoaderUtils.
-     */
-    private void bindWorkspaceUnreadInfo() {
-        mHandler.post(new Runnable() {
-            public void run() {
-                final long start = System.currentTimeMillis();
-                if (LogUtils.DEBUG_PERFORMANCE) {
-                    LogUtils.d(TAG, "bindWorkspaceUnreadInfo begin: start = " + start);
-                }
-                mUnreadLoaderUtils.updateShortcutsAndFoldersUnread();
-                if (LogUtils.DEBUG_PERFORMANCE) {
-                    LogUtils.d(TAG, "bindWorkspaceUnreadInfo end: current time = "
-                            + System.currentTimeMillis() + ",time used = "
-                            + (System.currentTimeMillis() - start));
-                }
-            }
-        });
-    }
-
-    /**
-     * SPRD: Bind unread number to shortcuts with data in UnreadLoaderUtils.
-     */
-    private void bindAppsUnreadInfo() {
-        mHandler.post(new Runnable() {
-            public void run() {
-                final long start = System.currentTimeMillis();
-                if (LogUtils.DEBUG_PERFORMANCE) {
-                    LogUtils.d(TAG, "bindAppsUnreadInfo begin: start = " + start);
-                }
-              //  mUnreadLoaderUtils.updateAppsUnread(); //Update AllApps Unread if needed.
-                if (LogUtils.DEBUG_PERFORMANCE) {
-                    LogUtils.d(TAG, "bindAppsUnreadInfo end: current time = "
-                            + System.currentTimeMillis() + ",time used = "
-                            + (System.currentTimeMillis() - start));
-                }
-            }
-        });
-    }
-    /**@}**/
-
-
-    /**SPRD: Added for dynamic icon feature.@{**/
-
-    /**
-     * SPRD: Bind component draw callback of the dynamic icon in workspace.
-     *
-     * @param component the component name of the app.
-     */
-    public void bindComponentDynamicIconChanged(final ComponentName component) {
-        mHandler.post(new Runnable() {
-            public void run() {
-                final long start = System.currentTimeMillis();
-                if (LogUtils.DEBUG_PERFORMANCE) {
-                    LogUtils.d(TAG, "bindComponentDynamicIconChanged begin: component = " + component
-                            + ", start = " + start);
-                }
-
-                if (mDynamicIconUtils != null) {
-                    mDynamicIconUtils.updateComponentDynamicIconChanged(component);
-                }
-
-                if (LogUtils.DEBUG_PERFORMANCE) {
-                    LogUtils.d(TAG, "bindComponentDynamicIconChanged end: current time = "
-                            + System.currentTimeMillis() + ", time used = "
-                            + (System.currentTimeMillis() - start));
-                }
-            }
-        });
-    }
-
-    public void bindDynamicIconIfNeeded() {
-        if (LogUtils.DEBUG_DYNAMIC_ICON) {
-            LogUtils.d(TAG, "bindDynamicIconIfNeeded: mBindingWorkspaceCompleted = "
-                    + mBindingWorkspaceCompleted + ", thread = " + Thread.currentThread());
-        }
-        if (mBindingWorkspaceCompleted) {
-            bindWorkspaceDynamicInfo();
-        }
-        if (mBindingAppsCompleted) {
-            // bind dynamic icon info that in the all app container if needed
-        }
-        mDynamicIconLoadCompleted = true;
-    }
-
-    private void bindWorkspaceDynamicInfo() {
-        mHandler.post(new Runnable() {
-            public void run() {
-                final long start = System.currentTimeMillis();
-                if (LogUtils.DEBUG_PERFORMANCE) {
-                    LogUtils.d(TAG, "bindWorkspaceDynamicInfo begin: start = " + start);
-                }
-
-                if (mDynamicIconUtils != null) {
-                    mDynamicIconUtils.updateShortcutsAndFoldersDynamicIcon();
-                }
-
-                if (LogUtils.DEBUG_PERFORMANCE) {
-                    LogUtils.d(TAG, "bindWorkspaceDynamicInfo end: current time = "
-                            + System.currentTimeMillis() + ",time used = "
-                            + (System.currentTimeMillis() - start));
-                }
-            }
-        });
-    }
-
-    @Override
-    public void onSensorChanged(SensorEvent event) {
-        int sensorType = event.sensor.getType();
-        if (sensorType == Sensor.TYPE_ACCELEROMETER) {
-            long currentUpdateTime = System.currentTimeMillis();
-            long timeInterval = currentUpdateTime - mSensorLastUpdateTime;
-            if(timeInterval < UPTATE_INTERVAL_TIME){
-                return;
-            }
-            mSensorLastUpdateTime = currentUpdateTime;
-            float x = event.values[0];
-            float y = event.values[1];
-            float z = event.values[2];
-            float deltaX = Math.abs(x - lastX);
-            float deltaY = Math.abs(y - lastY);
-            float deltaZ = Math.abs(z - lastZ);
-
-            lastX = x;
-            lastY = y;
-            lastZ = z;
-
-            double speed = deltaX + deltaY + deltaZ;
-            
-            if (mIsFrist) {
-                mIsFrist = false;
-            } else {
-                if (isWorkspaceVisible() && speed > SPEED_SHRESHOLD) {
-                    if (mMotionSound != null) {
-                        mMotionSound.start();
-                        if (LogUtils.DEBUG) LogUtils.d(TAG, "mMotionSound is started");
-                    }
-                }
-            }
-        }
-    }
-
-    @Override
-    public void onAccuracyChanged(Sensor sensor, int accuracy) {
-
-    }
-
-    private void registerListener(){
-        if(mSensorManager != null) {
-            Sensor sensor = mSensorManager.getDefaultSensor( Sensor.TYPE_ACCELEROMETER );
-            if(sensor != null){
-                mSensorManager.registerListener(this, sensor, SensorManager.SENSOR_DELAY_NORMAL);
-            }
-        }
-    }
-
-    private void unRegisterListener() {
-        if (mSensorManager != null)
-            mSensorManager.unregisterListener(this);
-    }
-}
-
-interface DebugIntents {
-    static final String DELETE_DATABASE = "com.android.launcher3.action.DELETE_DATABASE";
-    static final String MIGRATE_DATABASE = "com.android.launcher3.action.MIGRATE_DATABASE";
-}
+        dra
\ No newline at end of file
Index: packages/apps/Launcher3/src/com/android/launcher3/ShortcutAndWidgetContainer.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/ShortcutAndWidgetContainer.java	(revision 182200)
+++ packages/apps/Launcher3/src/com/android/launcher3/ShortcutAndWidgetContainer.java	(revision 182201)
@@ -153,6 +153,9 @@
                 // Otherwise, center the icon
                 int cHeight = getCellContentHeight();
                 int cellPaddingY = (int) Math.max(0, ((lp.height - cHeight) / 2f));
+                if (mIsHotseatLayout && grid.isVerticalBarLayout()) {
+                    cellPaddingY = (int) ((lp.height - cHeight) / 2f);
+                }
                 int cellPaddingX = (int) (grid.edgeMarginPx / 2f);
                 child.setPadding(cellPaddingX, cellPaddingY, cellPaddingX, 0);
             }
Index: packages/apps/Launcher3/src/com/android/launcher3/util/WallpaperUtils.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/util/WallpaperUtils.java	(revision 182200)
+++ packages/apps/Launcher3/src/com/android/launcher3/util/WallpaperUtils.java	(revision 182201)
@@ -25,6 +25,7 @@
 import android.view.WindowManager;
 
 import com.android.launcher3.Utilities;
+import com.sprd.ext.FeatureOption;
 
 /**
  * Utility methods for wallpaper management.
@@ -122,11 +123,16 @@
         }
         return sDefaultWallpaperSize;
     }
-	private static Point sWallpaperSize;
+
+    private static Point sWallpaperSize;
     private static int sLastWidth;
 
     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
     public static Point getDefaultWallpaperSize(Resources res, WindowManager windowManager, int width) {
+        if (!FeatureOption.SPRD_ADAPTIVE_WALLPAPER_SUPPORT) {
+            return getDefaultWallpaperSize(res, windowManager);
+        }
+
         if (sWallpaperSize == null || width != sLastWidth) {
             sLastWidth = width;
             Point minDims = new Point();
Index: packages/apps/Launcher3/src/com/android/launcher3/util/ManagedProfileHeuristic.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/util/ManagedProfileHeuristic.java	(revision 182200)
+++ packages/apps/Launcher3/src/com/android/launcher3/util/ManagedProfileHeuristic.java	(revision 182201)
@@ -35,6 +35,8 @@
 import com.android.launcher3.compat.UserHandleCompat;
 import com.android.launcher3.compat.UserManagerCompat;
 import com.sprd.PlatformHelper;
+import com.sprd.ext.AppCloneUtils;
+import com.sprd.ext.LogUtils;
 
 import java.util.ArrayList;
 import java.util.Collections;
Index: packages/apps/Launcher3/src/com/android/launcher3/Workspace.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/Workspace.java	(revision 182200)
+++ packages/apps/Launcher3/src/com/android/launcher3/Workspace.java	(revision 182201)
@@ -496,7 +496,20 @@
     void disableLayoutTransitions() {
         setLayoutTransition(null);
     }
+    boolean getCreatingUserFolderOnDrop() {
+        return mCreateUserFolderOnDrop;
+    }
+    void setCreatingUserFolderOnDrop(boolean createFolderOnDrop) {
+        mCreateUserFolderOnDrop = createFolderOnDrop;
+    }
+    boolean getAddingtoExistingFolderOnDrop() {
+        return mAddToExistingFolderOnDrop;
+    }
+    void setAddingtoExistingFolderOnDrop(boolean addingtoExistingFolderOnDrop) {
+        mAddToExistingFolderOnDrop = addingtoExistingFolderOnDrop;
+    }
 
+
     @Override
     public void onChildViewAdded(View parent, View child) {
         if (!(child instanceof CellLayout)) {
@@ -621,7 +634,6 @@
         } else {
             setCurrentPage(getCurrentPage() + 1);
         }
-
     }
 
     public void removeCustomContentPage() {
@@ -628,7 +640,6 @@
         CellLayout customScreen = getScreenWithId(CUSTOM_CONTENT_SCREEN_ID);
         if (customScreen == null) {
             throw new RuntimeException("Expected custom content screen to exist");
-
         }
 
         mWorkspaceScreens.remove(CUSTOM_CONTENT_SCREEN_ID);
@@ -1807,7 +1818,6 @@
             mLauncher.getHotseat().setTranslationX(translationX);
         }
 
-
         if (getPageIndicator() != null) {
             getPageIndicator().setTranslationX(translationX);
         }
Index: packages/apps/Launcher3/src/com/android/launcher3/IconCache.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/IconCache.java	(revision 182200)
+++ packages/apps/Launcher3/src/com/android/launcher3/IconCache.java	(revision 182201)
@@ -48,11 +48,12 @@
 import com.android.launcher3.config.FeatureFlags;
 import com.android.launcher3.model.PackageItemInfo;
 import com.android.launcher3.util.ComponentKey;
+import com.android.launcher3.util.PackageManagerHelper;
 import com.android.launcher3.util.SQLiteCacheHelper;
 import com.android.launcher3.util.Thunk;
-
+import com.sprd.ext.FeatureOption;
+import com.sprd.ext.LogUtils;
 import com.sprd.ext.dynamicIcon.DynamicIconUtils;
-import com.sprd.ext.FeatureOption;
 
 import java.util.Collections;
 import java.util.HashMap;
@@ -222,6 +223,11 @@
             for (LauncherActivityInfoCompat app : mLauncherApps.getActivityList(packageName, user)) {
                 addIconToDBAndMemCache(app, info, userSerial);
             }
+            if (PackageManagerHelper.isAppOnSdcard(mPackageManager, packageName)) {
+                if (LogUtils.DEBUG_ALL) LogUtils.d(TAG, "updateIconsForPkg " + packageName + ", GC begin");
+                Runtime.getRuntime().gc();
+                if (LogUtils.DEBUG_ALL) LogUtils.d(TAG, "updateIconsForPkg ExternalApp, GC end");
+            }
         } catch (NameNotFoundException e) {
             Log.d(TAG, "Package not found", e);
             return;
@@ -250,7 +256,7 @@
             // Fail if we don't have any apps
             // TODO: Fix this. Only fail for the current user.
             if (apps == null || apps.isEmpty()) {
-                return;
+                continue;
             }
 
             // Update icon cache. This happens in segments and {@link #onPackageIconsUpdated}
Index: packages/apps/Launcher3/src/com/android/launcher3/compat/UserManagerCompatVL.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/compat/UserManagerCompatVL.java	(revision 182200)
+++ packages/apps/Launcher3/src/com/android/launcher3/compat/UserManagerCompatVL.java	(revision 182201)
@@ -26,6 +26,7 @@
 
 import com.android.launcher3.Utilities;
 import com.android.launcher3.util.LongArrayMap;
+import com.sprd.ext.LogUtils;
 
 import java.util.ArrayList;
 import java.util.Collections;
Index: packages/apps/Launcher3/res/values/config.xml
===================================================================
--- packages/apps/Launcher3/res/values/config.xml	(revision 182200)
+++ packages/apps/Launcher3/res/values/config.xml	(revision 182201)
@@ -92,4 +92,6 @@
     <item type="id" name="action_move_screen_forwards" />
     <item type="id" name="action_resize" />
 
+    <bool name="config_app_title_single_line">true</bool>
+    <integer name="config_app_title_max_line">1</integer>
 </resources>
Index: packages/apps/Launcher3/res/values/dimens.xml
===================================================================
--- packages/apps/Launcher3/res/values/dimens.xml	(revision 182200)
+++ packages/apps/Launcher3/res/values/dimens.xml	(revision 182201)
@@ -166,4 +166,6 @@
     <dimen name="pending_widget_min_padding">8dp</dimen>
     <dimen name="pending_widget_elevation">2dp</dimen>
 
+    <!--Add for app title shown in two lines-->
+    <dimen name="adjust_cell_height">0dp</dimen>
 </resources>
Index: packages/apps/Launcher3/res/xml/default_workspace_5x5.xml
===================================================================
--- packages/apps/Launcher3/res/xml/default_workspace_5x5.xml	(revision 182200)
+++ packages/apps/Launcher3/res/xml/default_workspace_5x5.xml	(revision 182201)
@@ -29,7 +29,7 @@
 
     </resolve>
 
-   <!-- <resolve
+    <resolve
         launcher:screen="0"
         launcher:x="1"
         launcher:y="-1" >
@@ -36,7 +36,7 @@
 	    <favorite launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_GALLERY;end" />
 	    <favorite launcher:uri="#Intent;type=images/*;end" />
 
-    </resolve>-->
+    </resolve>
 
     <resolve
         launcher:screen="0"
@@ -47,7 +47,7 @@
     </resolve>
 
     <!-- base customization -->
-    <!--<include launcher:workspace="@xml/dw_base_customize" />-->
+    <include launcher:workspace="@xml/dw_base_customize" />
 
     <!-- vendor customization -->
     <include launcher:workspace="@xml/dw_vendor_customize" />
Index: packages/apps/Dialer/src/com/android/dialer/settings/DialerSettingsActivity.java
===================================================================
--- packages/apps/Dialer/src/com/android/dialer/settings/DialerSettingsActivity.java	(revision 182200)
+++ packages/apps/Dialer/src/com/android/dialer/settings/DialerSettingsActivity.java	(revision 182201)
@@ -167,7 +167,9 @@
         }
         /* SPRD: add for bug628790 & 649504 @{ */
         boolean isSupportVideoMeeting = false;
-        if (ImsManager.isVolteEnabledByPlatform(this) && isSupportVideoMeeting) {
+        // SPRD: modify for bug711822
+        if (PermissionsUtil.hasPermission(this, READ_PHONE_STATE)
+                && ImsManager.isVolteEnabledByPlatform(this) && isSupportVideoMeeting) {
             Header videoPhotoSettingsHeader = new Header();
             videoPhotoSettingsHeader.titleRes = R.string.video_photo_select_title;
             videoPhotoSettingsHeader.fragment
Index: packages/apps/Dialer/InCallUI/src/com/android/sprd/incallui/VoiceClearCodeHelper.java
===================================================================
--- packages/apps/Dialer/InCallUI/src/com/android/sprd/incallui/VoiceClearCodeHelper.java	(revision 0)
+++ packages/apps/Dialer/InCallUI/src/com/android/sprd/incallui/VoiceClearCodeHelper.java	(revision 182201)
@@ -0,0 +1,60 @@
+package com.android.sprd.incallui;
+
+import android.app.AddonManager;
+import android.content.Context;
+
+import com.android.incallui.Log;
+import com.android.incallui.NeededForReflection;
+import com.android.dialer.R;
+
+/**
+ * Support voice clear code in incallui.
+ */
+public class VoiceClearCodeHelper {
+    private static String TAG = "VoiceClearCodeHelper";
+    static VoiceClearCodeHelper sInstance;
+    static Context sContext;
+
+    public VoiceClearCodeHelper() {
+
+    }
+
+    public static VoiceClearCodeHelper getInstance(Context context) {
+        if (sInstance == null) {
+            synchronized (VoiceClearCodeHelper.class) {
+                sContext = context;
+                AddonManager addonManager = new AddonManager(context);
+                sInstance = (VoiceClearCodeHelper) addonManager.getAddon(
+                        R.string.incallui_voice_clear_code_plugin_name, VoiceClearCodeHelper.class);
+            }
+        }
+        Log.d(TAG, "getInstance [" + sInstance + "]");
+        return sInstance;
+    }
+
+    public void showToastMessage(Context context, String reason) {
+        // Do nothing
+    }
+
+    public boolean isVoiceClearCodeLabel(String callStateLabel) {
+        return false;
+    }
+
+    public boolean isSpecialVoiceClearCode(String number) {
+        return false;
+    }
+
+    @NeededForReflection
+    public String[] getClearCodeStrings() {
+        String unobtainableNumber = sContext
+                .getString(R.string.callFailed_unobtainable_number);
+        String congestion = sContext.getString(R.string.callFailed_congestion);
+        String userBusy = sContext.getString(R.string.callFailed_userBusy);
+        String limitExceeded = sContext
+                .getString(R.string.callFailed_limitExceeded);
+        String[] clearCodeStrings = new String[] { unobtainableNumber,
+                congestion, userBusy, limitExceeded };
+        return clearCodeStrings;
+    }
+    /* @} */
+}
Index: packages/apps/Dialer/InCallUI/src/com/android/sprd/incallui/InCallUITelcelHelper.java
===================================================================
--- packages/apps/Dialer/InCallUI/src/com/android/sprd/incallui/InCallUITelcelHelper.java	(revision 182200)
+++ packages/apps/Dialer/InCallUI/src/com/android/sprd/incallui/InCallUITelcelHelper.java	(revision 182201)
@@ -2,7 +2,6 @@
 
 import com.android.incallui.CallCardFragment;
 import com.android.incallui.Log;
-import com.android.incallui.NeededForReflection;
 import com.android.dialer.R;
 
 import android.app.AddonManager;
@@ -13,7 +12,7 @@
 import android.content.DialogInterface;
 import com.android.incallui.CallList;
 /**
- * Handle call fail cause
+ * Handle telcel feature
  */
 public class InCallUITelcelHelper {
     private static String TAG = "InCallUITelcelHelper";
@@ -36,33 +35,6 @@
         return sInstance;
     }
 
-    /* SPRD: Voice Clear Code @{ */
-    public void showToastMessage(Context context, String reason) {
-        // Do nothing
-    }
-
-    public boolean isVoiceClearCodeLabel(String callStateLabel) {
-        return false;
-    }
-
-    public boolean isSpecialVoiceClearCode(String number) {
-        return false;
-    }
-
-    @NeededForReflection
-    public String[] getClearCodeStrings() {
-        String unobtainableNumber = sContext
-                .getString(R.string.callFailed_unobtainable_number);
-        String congestion = sContext.getString(R.string.callFailed_congestion);
-        String userBusy = sContext.getString(R.string.callFailed_userBusy);
-        String limitExceeded = sContext
-                .getString(R.string.callFailed_limitExceeded);
-        String[] clearCodeStrings = new String[] { unobtainableNumber,
-                congestion, userBusy, limitExceeded };
-        return clearCodeStrings;
-    }
-    /* @} */
-
     /* SPRD: FDN in dialer feature. @{ */
     public boolean isSupportFdnListName(int subId) {
         return false;
Index: packages/apps/Dialer/InCallUI/src/com/android/sprd/incallui/HideConferencePreviewViewHelper.java
===================================================================
--- packages/apps/Dialer/InCallUI/src/com/android/sprd/incallui/HideConferencePreviewViewHelper.java	(revision 0)
+++ packages/apps/Dialer/InCallUI/src/com/android/sprd/incallui/HideConferencePreviewViewHelper.java	(revision 182201)
@@ -0,0 +1,30 @@
+package com.android.sprd.incallui;
+
+import android.app.AddonManager;
+import android.content.Context;
+
+import com.android.incallui.Log;
+import com.android.dialer.R;
+
+public class HideConferencePreviewViewHelper {
+
+    private static final String TAG = HideConferencePreviewViewHelper.class.getSimpleName();
+
+    static HideConferencePreviewViewHelper sInstance;
+
+    public static HideConferencePreviewViewHelper getInstance(Context context) {
+        if (sInstance != null) {
+            return sInstance;
+        }
+        sInstance = (HideConferencePreviewViewHelper) AddonManager.getDefault().getAddon(
+                R.string.incallui_hide_conference_preview_view_plugin_name, HideConferencePreviewViewHelper.class);
+        Log.i(TAG, "getInstance [" + sInstance + "]");
+
+        return sInstance;
+    }
+
+    public boolean isShowPreviewVideoViews() {
+        Log.i(TAG, "isShowPreviewVideoViews true") ;
+        return true;
+    }
+}
Index: packages/apps/Dialer/InCallUI/src/com/android/incallui/Call.java
===================================================================
--- packages/apps/Dialer/InCallUI/src/com/android/incallui/Call.java	(revision 182200)
+++ packages/apps/Dialer/InCallUI/src/com/android/incallui/Call.java	(revision 182201)
@@ -658,6 +658,11 @@
         }
     }
 
+    /*SPRD: add for bug736451 {@*/
+    public int getRealState() {
+       return mState;
+    }
+
     public void setState(int state) {
         mState = state;
         if (mState == State.INCOMING) {
Index: packages/apps/Dialer/InCallUI/src/com/android/incallui/InCallPresenter.java
===================================================================
--- packages/apps/Dialer/InCallUI/src/com/android/incallui/InCallPresenter.java	(revision 182200)
+++ packages/apps/Dialer/InCallUI/src/com/android/incallui/InCallPresenter.java	(revision 182201)
@@ -60,7 +60,7 @@
 import com.android.dialer.util.TelecomUtil;
 import com.android.incallui.util.TelecomCallUtil;
 import com.android.incalluibind.ObjectFactory;
-import com.android.sprd.incallui.InCallUITelcelHelper;
+import com.android.sprd.incallui.VoiceClearCodeHelper;
 import com.android.sprd.incallui.InCallUiUtils;
 import com.android.sprd.incallui.InCallUICuccHelper;
 
@@ -1418,9 +1418,9 @@
                 setDisconnectCauseForMissingAccounts(call);
             }
             /* SPRD: Voice Clear Code @{ */
-            InCallUITelcelHelper callFailCauseHelper = InCallUITelcelHelper.getInstance(mContext);
-            callFailCauseHelper.showToastMessage(mContext, call.getDisconnectCause().getReason());
-            if (callFailCauseHelper.isSpecialVoiceClearCode(call.getNumber())) {
+            VoiceClearCodeHelper voiceClearCodeHelper = VoiceClearCodeHelper.getInstance(mContext);
+            voiceClearCodeHelper.showToastMessage(mContext, call.getDisconnectCause().getReason());
+            if (voiceClearCodeHelper.isSpecialVoiceClearCode(call.getNumber())) {
                 return;
             }
             /* @} */
Index: packages/apps/Dialer/InCallUI/src/com/android/incallui/CallCardPresenter.java
===================================================================
--- packages/apps/Dialer/InCallUI/src/com/android/incallui/CallCardPresenter.java	(revision 182200)
+++ packages/apps/Dialer/InCallUI/src/com/android/incallui/CallCardPresenter.java	(revision 182201)
@@ -96,6 +96,7 @@
     private boolean mHasShownToast = false;
     private InCallContactInteractions mInCallContactInteractions;
     private boolean mIsFullscreen = false;
+    private boolean mIsConferenceState = false; //SPRD:Add for bug675442
 
     // SPRD: FDN in dialer feature.
     private static final int INVALID_SUBSCRIPTION_ID = -1;
@@ -268,6 +269,14 @@
         Call previousPrimary = mPrimary;
         mPrimary = primary;
 
+        /* SPRD: Add for bug675442 @{*/
+        boolean conferenceStateChanged = false;
+        if (mPrimary != null) {
+            conferenceStateChanged = (mIsConferenceState != mPrimary.isConferenceCall());
+            mIsConferenceState = mPrimary.isConferenceCall();
+        }
+        /* @} */
+
         /* SPRD: Use cpu time instead of system time @{ */
         if (isPrimaryCallActive()) {
             mPrimary.updateConnectRealTimeMillis();
@@ -282,7 +291,7 @@
         // 1. Primary call changed.
         // 2. The call's ability to manage conference has changed.
         // 3. The call subject should be shown or hidden.
-        if (shouldRefreshPrimaryInfo(primaryChanged, ui, shouldShowCallSubject(mPrimary))) {
+        if (shouldRefreshPrimaryInfo(primaryChanged, ui, shouldShowCallSubject(mPrimary)) || conferenceStateChanged) {
             // primary call has changed
             if (previousPrimary != null) {
                 //clear progess spinner (if any) related to previous primary call
@@ -649,6 +658,10 @@
     }
 
     private void onContactInfoComplete(String callId, ContactCacheEntry entry, boolean isPrimary) {
+        //SPRD: add for bug667033
+        if (mPrimary != null && !callId.equals(mPrimary.getId())) {
+            return;
+        }
         final boolean entryMatchesExistingCall =
                 (isPrimary && mPrimary != null && TextUtils.equals(callId,  mPrimary.getId())) ||
                 (!isPrimary && mSecondary != null && TextUtils.equals(callId, mSecondary.getId()));
Index: packages/apps/Dialer/InCallUI/src/com/android/incallui/CallButtonPresenter.java
===================================================================
--- packages/apps/Dialer/InCallUI/src/com/android/incallui/CallButtonPresenter.java	(revision 182200)
+++ packages/apps/Dialer/InCallUI/src/com/android/incallui/CallButtonPresenter.java	(revision 182201)
@@ -724,7 +724,7 @@
     public void inviteClicked() {
         Log.i(this, "inviteClicked");
         final CallButtonUi ui = getUi();
-        String [] numberArray = CallList.getInstance().getConferenceCallNumberArray();
+        String [] numberArray = CallList.getInstance().getAcitveConferenceCallNumberArray();
         Intent intentPick = new Intent(MULTI_PICK_CONTACTS_ACTION).
                 putExtra("checked_limit_count",MAX_GROUP_CALL_NUMBER - CallList.getInstance().getConferenceCallSize()).
                 putExtra("checked_min_limit_count", MIN_CONTACTS_NUMBER).
Index: packages/apps/Dialer/InCallUI/src/com/android/incallui/VideoCallPresenter.java
===================================================================
--- packages/apps/Dialer/InCallUI/src/com/android/incallui/VideoCallPresenter.java	(revision 182200)
+++ packages/apps/Dialer/InCallUI/src/com/android/incallui/VideoCallPresenter.java	(revision 182201)
@@ -42,6 +42,7 @@
 import com.android.incallui.InCallVideoCallCallbackNotifier.SurfaceChangeListener;
 import com.android.incallui.InCallVideoCallCallbackNotifier.VideoEventListener;
 import static android.Manifest.permission.READ_PHONE_STATE;
+import com.android.sprd.incallui.HideConferencePreviewViewHelper;
 import com.android.ims.ImsManager;
 import android.content.pm.PackageManager;
 import java.util.Objects;
@@ -322,7 +323,8 @@
                 enableCamera(mVideoCall, true);
             }
             if(mContext != null && ImsManager.isVolteEnabledByPlatform(mContext) && mPrimaryCall != null
-                    && mPrimaryCall.isVideoCall(mContext) && ((mPrimaryCall.isConferenceCall() && !mPrimaryCall.hasProperty(Details.PROPERTY_GENERIC_CONFERENCE)) || mPrimaryCall.isConferenceCall())){
+                    && mPrimaryCall.isVideoCall(mContext) && ((mPrimaryCall.isConferenceCall() && !mPrimaryCall.hasProperty(Details.PROPERTY_GENERIC_CONFERENCE)) || mPrimaryCall.isConferenceCall())
+                    && !HideConferencePreviewViewHelper.getInstance(mContext).isShowPreviewVideoViews()){
                 ui.showPreviewVideoViews(false);
                 Log.d(this, "onSurfaceCreated isConferenceCall = " + mPrimaryCall.isConferenceCall()
                         + " isGenericConferenceCall=" +mPrimaryCall.isGenericConferenceCall());
@@ -477,7 +479,8 @@
             currentCall = primary = callList.getActiveCall();
             /* SPRD: Added for video call conference @{ */
             if (mContext != null && mContext.checkSelfPermission(READ_PHONE_STATE) == PackageManager.PERMISSION_GRANTED && ImsManager.isVolteEnabledByPlatform(mContext) && primary != null && primary.isVideoCall(mContext)
-                    && primary.isConferenceCall() && getUi() != null && getUi().isPreviewVideoSurfaceCreated() && (mPreviewSurfaceState == PreviewSurfaceState.SURFACE_SET)) {
+                    && primary.isConferenceCall() && getUi() != null && getUi().isPreviewVideoSurfaceCreated() && (mPreviewSurfaceState == PreviewSurfaceState.SURFACE_SET)
+                    && !HideConferencePreviewViewHelper.getInstance(mContext).isShowPreviewVideoViews()) {
                 getUi().showPreviewVideoViews(false);
                 Log.i(this, "onStateChange isConferenceCall = " + primary.isConferenceCall()
                         + " isGenericConferenceCall" + primary.isGenericConferenceCall());
@@ -968,7 +971,8 @@
             mVideoCall.setPreviewSurface(ui.getPreviewVideoSurface());
             /* SPRD: Added for video call conference @{ */
             if(mContext != null && ImsManager.isVolteEnabledByPlatform(mContext) && mPrimaryCall != null
-                    && mPrimaryCall.isVideoCall(mContext) && ((mPrimaryCall.isConferenceCall() && !mPrimaryCall.hasProperty(Details.PROPERTY_GENERIC_CONFERENCE)) || mPrimaryCall.isConferenceCall())){
+                    && mPrimaryCall.isVideoCall(mContext) && ((mPrimaryCall.isConferenceCall() && !mPrimaryCall.hasProperty(Details.PROPERTY_GENERIC_CONFERENCE)) || mPrimaryCall.isConferenceCall())
+                    && !HideConferencePreviewViewHelper.getInstance(mContext).isShowPreviewVideoViews()){
                 ui.showPreviewVideoViews(false);
                 Log.d(this, "onCameraDimensionsChange isConferenceCall = " + mPrimaryCall.isConferenceCall()
                         + " isGenericConferenceCall=" +mPrimaryCall.isGenericConferenceCall());
Index: packages/apps/Dialer/InCallUI/src/com/android/incallui/CallList.java
===================================================================
--- packages/apps/Dialer/InCallUI/src/com/android/incallui/CallList.java	(revision 182200)
+++ packages/apps/Dialer/InCallUI/src/com/android/incallui/CallList.java	(revision 182201)
@@ -723,6 +723,12 @@
                 || Call.State.REDIALING == state);
     }
 
+    //SPRD: add for bug736451, allow inviting same number when dialing
+    private boolean isforgroundAcitveCall(Call call) {
+        final int state = call.getRealState();
+        return (Call.State.ACTIVE == state);
+    }
+
     @NeededForReflection
     public boolean hasValidGroupCall() {
         Call multiCall = null;
@@ -771,6 +777,25 @@
         }
         return ConferenceCallNumberArray;
     }
+
+    //SPRD: add for bug736451
+    public String[] getAcitveConferenceCallNumberArray() {
+        String[] ConferenceCallNumberArray = new String[getConferenceCallSize()];
+
+        if (getAllConferenceCall() != null && getAllConferenceCall().getChildCallIds() != null) {
+            String[] mCallerIds = getAllConferenceCall().getChildCallIds().toArray(new String[0]);
+            for (int i = 0, j = 0; i < mCallerIds.length; i++) {
+                if (mCallerIds[i] != null) {
+                    Call childCall = getCallById(mCallerIds[i]);
+                    if (childCall != null && isforgroundAcitveCall(childCall)) {
+                        ConferenceCallNumberArray[j] = childCall.getNumber();
+                        j++;
+                    }
+                }
+            }
+        }
+        return ConferenceCallNumberArray;
+    }
     /* @} */
 
 
Index: packages/apps/Dialer/InCallUI/src/com/android/incallui/InCallActivity.java
===================================================================
--- packages/apps/Dialer/InCallUI/src/com/android/incallui/InCallActivity.java	(revision 182200)
+++ packages/apps/Dialer/InCallUI/src/com/android/incallui/InCallActivity.java	(revision 182201)
@@ -1216,7 +1216,14 @@
                 // Attempt to switch foreground and background/incoming calls failed
                 // ("Failed to switch or hold calls")
                 errorMessageResId = R.string.incall_error_supp_service_switch;
-
+                /** SPRD: Add for bug677098 @{ */
+                final Call activeCall = CallList.getInstance().getActiveCall();
+                if (activeCall !=null &&(CallList.getInstance().getCallSize() == 1) ) {
+                    errorMessageResId = R.string.incall_error_supp_service_hold;
+                }else {
+                    errorMessageResId = R.string.incall_error_supp_service_switch;
+                }
+                /** @} */
                 final Call call = CallList.getInstance().getActiveOrBackgroundCall();
                 if (call != null && call.getState() != State.ONHOLD) {
                    //SPRD:Bug 623584 add protection to avoid crash
Index: packages/apps/Dialer/InCallUI/src/com/android/incallui/CallCardFragment.java
===================================================================
--- packages/apps/Dialer/InCallUI/src/com/android/incallui/CallCardFragment.java	(revision 182200)
+++ packages/apps/Dialer/InCallUI/src/com/android/incallui/CallCardFragment.java	(revision 182201)
@@ -67,6 +67,7 @@
 import com.android.sprd.incallui.InCallUITelcelHelper;
 import com.android.sprd.incallui.InCallUiUtils;
 import com.android.sprd.incallui.InCallUICuccHelper;
+import com.android.sprd.incallui.VoiceClearCodeHelper;
 
 import java.util.List;
 import android.content.res.Configuration;
@@ -489,9 +490,9 @@
                 }
 
                 // Perform animation of video view.
-                ViewPropertyAnimator videoViewAnimator = videoView.animate()
-                        .setInterpolator(AnimUtils.EASE_OUT_EASE_IN)
-                        .setDuration(mVideoAnimationDuration);
+//                ViewPropertyAnimator videoViewAnimator = videoView.animate()
+//                        .setInterpolator(AnimUtils.EASE_OUT_EASE_IN)
+//                        .setDuration(mVideoAnimationDuration);
                 /* SPRD: delete for Bug607473
                  * @Org:
                  *  if (mIsLandscape) {
@@ -499,9 +500,9 @@
                  *          .translationX(visible ? videoViewTranslation : 0);
                  *  } else {
                  *   */
-                    videoViewAnimator
-                            .translationY(visible ? videoViewTranslation : 0);
-                videoViewAnimator.start();
+//                    videoViewAnimator
+//                            .translationY(visible ? videoViewTranslation : 0);
+//                videoViewAnimator.start();
 
                 // Animate the call card sliding.
                 ViewPropertyAnimator callCardAnimator = mPrimaryCallCardContainer.animate()
@@ -784,7 +785,7 @@
      */
     @Override
     public void setSecondaryInfoVisible(final boolean visible) {
-        boolean wasVisible = mSecondaryCallInfo.isShown();
+        boolean wasVisible = mSecondaryCallInfo.isShown() || mSecondaryCallInfo.getVisibility() == View.VISIBLE;
         final boolean isVisible = visible && mHasSecondaryCallInfo;
         /* SPRD: add for bug607081*/
         if(getActivity() != null){
@@ -1353,9 +1354,9 @@
                     callStateLabel = context.getString(R.string.card_title_call_ended);
                 } else {
                     /* SPRD: Voice Clear Code @{ */
-                    InCallUITelcelHelper callFailCauseHelper = InCallUITelcelHelper
+                    VoiceClearCodeHelper voiceClearCodeHelper = VoiceClearCodeHelper
                             .getInstance(getActivity());
-                    if (callFailCauseHelper.isVoiceClearCodeLabel(callStateLabel.toString())) {
+                    if (voiceClearCodeHelper.isVoiceClearCodeLabel(callStateLabel.toString())) {
                         callStateLabel = context.getString(R.string.card_title_call_ended);
                     }
                 }
Index: packages/apps/Dialer/InCallUI/res/values-zh-rCN/strings.xml
===================================================================
--- packages/apps/Dialer/InCallUI/res/values-zh-rCN/strings.xml	(revision 182200)
+++ packages/apps/Dialer/InCallUI/res/values-zh-rCN/strings.xml	(revision 182201)
@@ -207,6 +207,15 @@
     <string name="display_preview_video">显示本端图像</string>
     <string name="set_substitute_image">请先设置替换图片</string>
     <!-- @} -->
+
+    <!-- SPRD:add for background music call -->
+    <string name="background_music_on">开启背景音乐</string>
+    <string name="background_music_off">关闭背景音乐</string>
+    <string name="fail_to_play_bgm_check_permission">背景音乐播放失败，请对电话应用开放访问存储的权限后重新选择音乐文件。</string>
+    <!-- add for Bug677098 -->
+    <string name="incall_error_supp_service_hold">"当前网络不支持呼叫保持"</string>
+    <!-- @} -->
+
     <string name="volume_boost_on">音量提升打开</string>
    <string name="volume_boost_off">音量提升关闭</string>
    <string name="calls_list">通话清单</string>
Index: packages/apps/Dialer/InCallUI/res/values/config_ex.xml
===================================================================
--- packages/apps/Dialer/InCallUI/res/values/config_ex.xml	(revision 182200)
+++ packages/apps/Dialer/InCallUI/res/values/config_ex.xml	(revision 182201)
@@ -32,4 +32,11 @@
     <string name="shake_phone_to_start_recording_plugin_name" translatable="false">
         plugin.sprd.shakePhoneToStartRecording.ShakePhoneToStartRecordingPlugin
     </string>
+    <string name="incallui_hide_conference_preview_view_plugin_name">
+        com.sprd.incallui.hideConferencePreviewViewPlugin.HideConferencePreviewViewPlugin
+    </string>
+    <!-- SPRD : Voice Clear Code Feature. @{ -->
+    <string name="incallui_voice_clear_code_plugin_name">
+        com.sprd.incallui.voiceClearCodePlugin.VoiceClearCodePlugin
+    </string>
 </resources>
Index: packages/apps/Dialer/InCallUI/res/values/strings.xml
===================================================================
--- packages/apps/Dialer/InCallUI/res/values/strings.xml	(revision 182200)
+++ packages/apps/Dialer/InCallUI/res/values/strings.xml	(revision 182201)
@@ -542,4 +542,11 @@
    <string name="volume_boost_on">Volume boost ON</string>
    <string name="volume_boost_off">Volume boost OFF</string>
    <string name="calls_list">Calls List</string>
+    <!-- SPRD:add for background music call -->
+    <string name="background_music_on">Play Background Music</string>
+    <string name="background_music_off">Stop Background Music</string>
+    <string name="fail_to_play_bgm_check_permission">Fail to play background music. Please grant access storage permission to Phone app and select music file again.</string>
+    <!-- add for Bug677098 -->
+    <string name="incall_error_supp_service_hold">Call hold not supported by network</string>
+    <!-- @} -->
 </resources>
Index: packages/apps/Dialer/InCallUI/res/layout/video_call_views.xml
===================================================================
--- packages/apps/Dialer/InCallUI/res/layout/video_call_views.xml	(revision 182200)
+++ packages/apps/Dialer/InCallUI/res/layout/video_call_views.xml	(revision 182201)
@@ -22,7 +22,7 @@
 
     <TextureView
         android:id="@+id/incomingVideo"
-        android:layout_gravity="center"
+        android:layout_gravity="bottom|center"
         android:layout_width="match_parent"
         android:layout_height="match_parent" />
     <!-- The width and height are replaced at runtime based on the selected camera. -->
Index: packages/apps/Dialer/InCallUI/res/values-zh-rTW/strings.xml
===================================================================
--- packages/apps/Dialer/InCallUI/res/values-zh-rTW/strings.xml	(revision 182200)
+++ packages/apps/Dialer/InCallUI/res/values-zh-rTW/strings.xml	(revision 182201)
@@ -205,4 +205,11 @@
     <string name="display_preview_video">顯示本端圖像</string>
     <string name="set_substitute_image">請先設置替換圖片</string>
     <!-- @} -->
+        <!-- SPRD:add for background music call -->
+    <string name="background_music_on">開啟背景音樂</string>
+    <string name="background_music_off">關閉背景音樂</string>
+    <string name="fail_to_play_bgm_check_permission">"背景音樂播放失敗，請對電話應用開放訪問存儲的權限後重新選擇音樂檔案。"</string>
+    <!-- add for Bug677098 -->
+    <string name="incall_error_supp_service_hold">"當前網絡不支持呼叫保持"</string>
+    <!-- @} -->
 </resources>
Index: packages/apps/Nfc/src/com/android/nfc/BeamShareActivity.java
===================================================================
--- packages/apps/Nfc/src/com/android/nfc/BeamShareActivity.java	(revision 182200)
+++ packages/apps/Nfc/src/com/android/nfc/BeamShareActivity.java	(revision 182201)
@@ -19,6 +19,8 @@
 import java.util.ArrayList;
 
 import android.app.Activity;
+import android.app.ActivityManager;
+import android.app.ActivityManagerNative;
 import android.app.AlertDialog;
 import android.content.BroadcastReceiver;
 import android.content.Context;
@@ -26,6 +28,7 @@
 import android.content.ClipData;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.nfc.BeamShareData;
 import android.nfc.NdefMessage;
@@ -33,8 +36,11 @@
 import android.nfc.NfcAdapter;
 import android.os.Bundle;
 import android.os.UserHandle;
+import android.os.RemoteException;
 import android.util.Log;
+import android.util.EventLog;
 import android.webkit.URLUtil;
+import android.Manifest.permission;
 
 import com.android.internal.R;
 
@@ -202,16 +208,26 @@
             int numValidUris = 0;
             for (Uri uri : mUris) {
                 try {
+                    int uid = ActivityManagerNative.getDefault().getLaunchedFromUid(getActivityToken());
+                    if (uri.getScheme().equalsIgnoreCase("file") &&
+                            getApplicationContext().checkPermission(permission.READ_EXTERNAL_STORAGE, -1, uid) !=
+                            PackageManager.PERMISSION_GRANTED) {
+                        Log.e(TAG, "File based Uri doesn't have External Storage Permission.");
+                        EventLog.writeEvent(0x534e4554, "37287958", uid, uri.getPath());
+                        break;
+                    }
                     grantUriPermission("com.android.nfc", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
                     uriArray[numValidUris++] = uri;
                     if (DBG) Log.d(TAG, "Found uri: " + uri);
                 } catch (SecurityException e) {
                     Log.e(TAG, "Security exception granting uri permission to NFC process.");
-                    numValidUris = 0;
                     break;
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Remote exception accessing uid of the calling process.");
+                    break;
                 }
             }
-            if (numValidUris > 0) {
+            if (numValidUris != 0 && numValidUris == mUris.size()) {
                 shareData = new BeamShareData(null, uriArray, myUserHandle, 0);
             } else {
                 // No uris left
Index: packages/apps/ExactCalculator/src/com/android/calculator2/KeyMaps.java
===================================================================
--- packages/apps/ExactCalculator/src/com/android/calculator2/KeyMaps.java	(revision 182200)
+++ packages/apps/ExactCalculator/src/com/android/calculator2/KeyMaps.java	(revision 182201)
@@ -422,7 +422,9 @@
     static void validateMaps() {
         Locale locale = Locale.getDefault();
         String lname = locale.toString();
-        if (lname != sLocaleForMaps) {
+        /* SPRD edited for BUG 680622 @{*/
+        if (!lname.equals(sLocaleForMaps)) {
+          /* @}*/
             Log.v ("Calculator", "Setting local to: " + lname);
             sKeyValForFun = new HashMap<String, Integer>();
             sKeyValForFun.put("sin", R.id.fun_sin);
Index: packages/apps/ExactCalculator/src/com/android/calculator2/Evaluator.java
===================================================================
--- packages/apps/ExactCalculator/src/com/android/calculator2/Evaluator.java	(revision 182200)
+++ packages/apps/ExactCalculator/src/com/android/calculator2/Evaluator.java	(revision 182201)
@@ -355,6 +355,12 @@
         @Override
         protected InitialResult doInBackground(Void... nothing) {
             try {
+                if(mCurrentMode) { // add for bug677137
+                    String exprStr = mExpr.toSpannableStringBuilder(mCalculator).toString();
+                    if(exprStr.length() > 10){
+                        return new InitialResult(R.string.timeout);
+                    }
+                }
                 CalculatorExpr.EvalResult res = mExpr.eval(mDm);
                 if (isTooBig(res)) {
                     // Avoid starting a long uninterruptible decimal conversion.
Index: packages/apps/Settings/AndroidManifest.xml
===================================================================
--- packages/apps/Settings/AndroidManifest.xml	(revision 182200)
+++ packages/apps/Settings/AndroidManifest.xml	(revision 182201)
@@ -3231,7 +3231,6 @@
                 <action android:name="com.android.settings.timerpower.SHUTDOWN" />
                 <action android:name="alarm_killed" />
                 <action android:name="cancel_snooze" />
-                <action android:name="android.intent.action.ACTION_SHUTDOWN" />
             </intent-filter>
         </receiver>
 
Index: packages/apps/Settings/src/com/android/settings/wifi/CmccAdvancedWifiSettings.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/wifi/CmccAdvancedWifiSettings.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/wifi/CmccAdvancedWifiSettings.java	(revision 182201)
@@ -205,8 +205,13 @@
 
         mConnectSwitch = (SwitchPreference) findPreference(KEY_WIFI_CONNECT_ALARM_SWITCH);
         mConnectTimePref = (Preference) findPreference(KEY_WIFI_CONNECT_ALARM_TIME);
+        boolean isConnectSwitchChecked = Settings.Global.getInt(getContentResolver(), WifiManagerEx.WIFI_CONNECT_ALARM_FLAG, 0) == 1;
+        mConnectSwitch.setChecked(isConnectSwitchChecked);
+
         mDisconnectSwitch = (SwitchPreference) findPreference(KEY_WIFI_DISCONNECT_ALARM_SWITCH);
         mDisconnectTimePref = (Preference) findPreference(KEY_WIFI_DISCONNECT_ALARM_TIME);
+        boolean isDisconnectSwitchChecked = Settings.Global.getInt(getContentResolver(), WifiManagerEx.WIFI_DISCONNECT_ALARM_FLAG, 0) == 1;
+        mDisconnectSwitch.setChecked(isDisconnectSwitchChecked);
 
         int hourOfDay = Settings.Global.getInt(getContentResolver(), WifiManagerEx.WIFI_CONNECT_ALARM_HOUR, 0);
         int minute = Settings.Global.getInt(getContentResolver(), WifiManagerEx.WIFI_CONNECT_ALARM_MINUTE, 0);
Index: packages/apps/Settings/src/com/android/settings/fuelgauge/PowerUsageSummary.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/fuelgauge/PowerUsageSummary.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/fuelgauge/PowerUsageSummary.java	(revision 182201)
@@ -26,6 +26,8 @@
 import android.os.Message;
 import android.os.Process;
 import android.os.UserHandle;
+import android.os.UserManager;
+import android.provider.SearchIndexableResource;
 import android.support.v7.preference.Preference;
 import android.support.v7.preference.PreferenceGroup;
 import android.text.TextUtils;
@@ -41,6 +43,9 @@
 import com.android.internal.os.BatterySipper.DrainType;
 import com.android.internal.os.PowerProfile;
 import com.android.settings.R;
+import com.android.settings.search.BaseSearchIndexProvider;
+import com.android.settings.search.Indexable;
+import com.android.settings.search.Indexable.SearchIndexProvider;
 import com.android.settings.Settings.HighPowerApplicationsActivity;
 import com.android.settings.SettingsActivity;
 import com.android.settings.applications.ManageApplications;
@@ -65,7 +70,7 @@
  * Displays a list of apps and subsystems that consume power, ordered by how much power was
  * consumed since the last time it was unplugged.
  */
-public class PowerUsageSummary extends PowerUsageBase {
+public class PowerUsageSummary extends PowerUsageBase implements Indexable {
 
     private static final boolean DEBUG = false;
 
@@ -83,6 +88,7 @@
 
     private static final String KEY_APP_LIST = "app_list";
     private static final String KEY_BATTERY_HISTORY = "battery_history";
+    private static final String KEY_PROTECTED_APP = "app_protected_app";
 
     private static final int MENU_STATS_TYPE = Menu.FIRST;
     private static final int MENU_HIGH_POWER_APPS = Menu.FIRST + 3;
@@ -106,8 +112,9 @@
 
         addPreferencesFromResource(R.xml.power_usage_summary);
         /* SPRD: New feature 545923, Add settings interface for 'protected application' @{ */
-        Preference mProtectedApp = (Preference) findPreference("app_protected_app");
-        if (!SprdPluginProtectedAppAddonStub.getInstance().isDefault() || !packageExists()) {
+        Preference mProtectedApp = (Preference) findPreference(KEY_PROTECTED_APP);
+        if (!SprdPluginProtectedAppAddonStub.getInstance().isDefault() || !packageExists()
+                || !UserManager.get(getContext()).isAdminUser()) {
             if (mProtectedApp != null) {
                 getPreferenceScreen().removePreference(mProtectedApp);
             }
@@ -567,4 +574,29 @@
             return new SummaryProvider(activity, summaryLoader);
         }
     };
+
+    public static final Indexable.SearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =
+            new BaseSearchIndexProvider() {
+                @Override
+                public List<SearchIndexableResource> getXmlResourcesToIndex(Context context,
+                        boolean enabled) {
+                    ArrayList<SearchIndexableResource> result =
+                            new ArrayList<SearchIndexableResource>();
+
+                    SearchIndexableResource sir = new SearchIndexableResource(context);
+                    sir.xmlResId = R.xml.power_usage_summary;
+                    result.add(sir);
+
+                    return result;
+                }
+
+                @Override
+                public List<String> getNonIndexableKeys(Context context) {
+                    ArrayList<String> result = new ArrayList<String>();
+                    if (!UserManager.get(context).isAdminUser()) {
+                        result.add(KEY_PROTECTED_APP);
+                    }
+                    return result;
+                }
+            };
 }
Index: packages/apps/Settings/src/com/android/settings/deviceinfo/StorageWizardFormatProgress.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/deviceinfo/StorageWizardFormatProgress.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/deviceinfo/StorageWizardFormatProgress.java	(revision 182201)
@@ -34,6 +34,7 @@
 import android.widget.Toast;
 
 import com.android.settings.R;
+import com.android.settings.Utils;
 
 import java.util.Objects;
 
@@ -66,6 +67,11 @@
 
         getNextButton().setVisibility(View.GONE);
 
+        if (Utils.isMonkeyRunning()) {
+            finish();
+            return;
+        }
+
         mTask = (PartitionTask) getLastNonConfigurationInstance();
         if (mTask == null) {
             mTask = new PartitionTask();
Index: packages/apps/Settings/src/com/android/settings/accounts/ManageAccountsSettings.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/accounts/ManageAccountsSettings.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/accounts/ManageAccountsSettings.java	(revision 182201)
@@ -36,6 +36,7 @@
 import android.os.UserHandle;
 import android.support.v7.preference.Preference;
 import android.support.v7.preference.Preference.OnPreferenceClickListener;
+import android.support.v7.preference.PreferenceGroup;
 import android.support.v7.preference.PreferenceScreen;
 import android.util.Log;
 import android.view.LayoutInflater;
@@ -83,7 +84,7 @@
 
     // If an account type is set, then show only accounts of that type
     private String mAccountType;
-    // Temporary hack, to deal with backward compatibility 
+    // Temporary hack, to deal with backward compatibility
     // mFirstAccount is used for the injected preferences
     private Account mFirstAccount;
 
@@ -445,15 +446,18 @@
     }
 
     /**
-     * Filters through the preference list provided by GoogleLoginService.
+     * Recursively filters through the preference list provided by GoogleLoginService.
      *
      * This method removes all the invalid intent from the list, adds account name as extra into the
      * intent, and hack the location settings to start it as a fragment.
      */
-    private void updatePreferenceIntents(PreferenceScreen prefs) {
+    private void updatePreferenceIntents(PreferenceGroup prefs) {
         final PackageManager pm = getActivity().getPackageManager();
         for (int i = 0; i < prefs.getPreferenceCount();) {
             Preference pref = prefs.getPreference(i);
+            if (pref instanceof PreferenceGroup) {
+                updatePreferenceIntents((PreferenceGroup) pref);
+            }
             Intent intent = pref.getIntent();
             if (intent != null) {
                 // Hack. Launch "Location" as fragment instead of as activity.
@@ -502,8 +506,8 @@
                                 } else {
                                     Log.e(TAG,
                                             "Refusing to launch authenticator intent because"
-                                            + "it exploits Settings permissions: "
-                                            + prefIntent);
+                                                    + " it exploits Settings permissions: "
+                                                    + prefIntent);
                                 }
                                 return true;
                             }
@@ -523,7 +527,8 @@
     private boolean isSafeIntent(PackageManager pm, Intent intent) {
         AuthenticatorDescription authDesc =
                 mAuthenticatorHelper.getAccountTypeDescription(mAccountType);
-        ResolveInfo resolveInfo = pm.resolveActivity(intent, 0);
+        ResolveInfo resolveInfo =
+            pm.resolveActivityAsUser(intent, 0, mUserHandle.getIdentifier());
         if (resolveInfo == null) {
             return false;
         }
@@ -530,13 +535,18 @@
         ActivityInfo resolvedActivityInfo = resolveInfo.activityInfo;
         ApplicationInfo resolvedAppInfo = resolvedActivityInfo.applicationInfo;
         try {
+            if (resolvedActivityInfo.exported) {
+                if (resolvedActivityInfo.permission == null) {
+                    return true; // exported activity without permission.
+                } else if (pm.checkPermission(resolvedActivityInfo.permission,
+                        authDesc.packageName) == PackageManager.PERMISSION_GRANTED) {
+                    return true;
+                }
+            }
             ApplicationInfo authenticatorAppInf = pm.getApplicationInfo(authDesc.packageName, 0);
-            return resolvedActivityInfo.exported
-                    || resolvedAppInfo.uid == authenticatorAppInf.uid;
+            return  resolvedAppInfo.uid == authenticatorAppInf.uid;
         } catch (NameNotFoundException e) {
-            Log.e(TAG,
-                    "Intent considered unsafe due to exception.",
-                    e);
+            Log.e(TAG, "Intent considered unsafe due to exception.", e);
             return false;
         }
     }
Index: packages/apps/Settings/src/com/android/settings/WirelessSettings.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/WirelessSettings.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/WirelessSettings.java	(revision 182201)
@@ -27,6 +27,7 @@
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.content.res.Resources;
+import android.database.ContentObserver;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.net.Uri;
@@ -34,6 +35,7 @@
 import android.nfc.NfcAdapter;
 import android.nfc.NfcManager;
 import android.os.Bundle;
+import android.os.Handler;
 import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.os.UserManager;
@@ -392,8 +394,27 @@
         } else {
             removePreference(KEY_WFC_SETTINGS);
         }
+        context.getContentResolver().registerContentObserver(
+                Settings.Global.getUriFor(Settings.Global.WFC_IMS_ENABLED), true,
+                mWfcEnableObserver);
     }
 
+    private ContentObserver mWfcEnableObserver = new ContentObserver(new Handler()) {
+        @Override
+        public void onChange(boolean selfChange) {
+            boolean enabled = ImsManager.isWfcEnabledByUser(getActivity())
+                    && ImsManager.isNonTtyOrTtyOnVolteEnabled(getActivity());
+            Log.d(TAG,"[mWfcEnableObserver][wfcEnabled]: " + enabled);
+            // update WFC setting
+            final Context context = getActivity();
+            PreferenceScreen ps = (PreferenceScreen) findPreference("wifi_calling_settings");
+            Log.d(TAG,"[mWfcEnableObserver][ps]: " + ps);
+            if (ps != null)
+                ps.setSummary(WifiCallingSettings.getWfcModeSummary(
+                        context, ImsManager.getWfcMode(context)));
+            }
+    };
+
     @Override
     public void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
@@ -411,6 +432,7 @@
         if (mNfcEnabler != null) {
             mNfcEnabler.pause();
         }
+        getActivity().getContentResolver().unregisterContentObserver(mWfcEnableObserver);
     }
 
     @Override
Index: packages/apps/Settings/src/com/android/settings/ChooseLockGeneric.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/ChooseLockGeneric.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/ChooseLockGeneric.java	(revision 182201)
@@ -699,8 +699,14 @@
         }
 
         private void removeManagedProfileFingerprintsAndFinishIfNecessary(final int parentUserId) {
+            final Activity activity = getActivity();
+            // Activity has been detached, so just finish it
+            if (activity == null) {
+                finish();
+                return;
+            }
             mFingerprintManager.setActiveUser(UserHandle.myUserId());
-            final UserManager um = UserManager.get(getActivity());
+            final UserManager um = UserManager.get(activity);
             boolean hasChildProfile = false;
             if (!um.getUserInfo(parentUserId).isManagedProfile()) {
                 // Current user is primary profile, remove work profile fingerprints if necessary
Index: packages/apps/Settings/src/com/android/settings/Utils.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/Utils.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/Utils.java	(revision 182201)
@@ -393,6 +393,9 @@
     }
 
     public static void assignDefaultPhoto(Context context, int userId) {
+        /*SPRD 669532: ignore the action if context is null @{ */
+        if (context == null) return;
+        /* @} */
         UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);
         Bitmap bitmap = getDefaultUserIconAsBitmap(userId);
         um.setUserIcon(userId, bitmap);
Index: packages/apps/Settings/src/com/android/settings/applications/RunningState.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/applications/RunningState.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/applications/RunningState.java	(revision 182201)
@@ -900,6 +900,13 @@
             context.getResources().getStringArray(
                     com.android.internal.R.array.third_party_persistent_service_processes);
         if (si != null && si.process != null) {
+            final PackageManager pm = context.getPackageManager();
+            String[] pkgs = pm.getPackagesForUid(si.uid);
+
+            if (pkgs == null) {
+                return false;
+            }
+
             for (int i = 0; i < m3rdPartyPersistentServiceProcesses.length; i++) {
                 if (si.process.equals(m3rdPartyPersistentServiceProcesses[i])) {
                     return true;
Index: packages/apps/Settings/src/com/android/settings/applications/DefaultAppSettingsUtils.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/applications/DefaultAppSettingsUtils.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/applications/DefaultAppSettingsUtils.java	(revision 182201)
@@ -79,7 +79,13 @@
                 return;
             }
 
-            appActivities = (ArrayList<ResolveInfo>) mPm.queryIntentActivities(intent, 0);
+            List<ResolveInfo> allResolveInfoList = mPm.queryIntentActivities(intent, 0);
+            if (allResolveInfoList.isEmpty()) {
+                Log.d(TAG, "getAppList,queryIntentActivities return EmptyList.");
+                return;
+            }
+
+            appActivities = (ArrayList<ResolveInfo>) allResolveInfoList;
             for (ResolveInfo resolveInfo : appActivities) {
                 if(isCurrentDefault(resolveInfo.activityInfo.packageName)) {
                     currentDefaultApp = new ComponentName(resolveInfo.activityInfo.packageName,
Index: packages/apps/Settings/src/com/android/settings/applications/RunningServiceDetails.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/applications/RunningServiceDetails.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/applications/RunningServiceDetails.java	(revision 182201)
@@ -569,7 +569,8 @@
          if (mContext != null && ((Activity) mContext).isResumed() && mNewFragment != null) {
               mNewFragment.dismiss();
              }
-        finish();
+        /*SPRD add for bug 652819*/
+        // finish();
        }
    /* @} */ 
        ensureData();
Index: packages/apps/Settings/src/com/android/settings/applications/DefaultAppList.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/applications/DefaultAppList.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/applications/DefaultAppList.java	(revision 182201)
@@ -81,7 +81,7 @@
                         count++;
                     }
                 }
-                if( count > 1)
+                if( count > 1 || count == 0)
                 /* @} */
                     application = "";
                 else
Index: packages/apps/Settings/src/com/android/settings/bluetooth/BluetoothSettings.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/bluetooth/BluetoothSettings.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/bluetooth/BluetoothSettings.java	(revision 182201)
@@ -201,7 +201,11 @@
 
         getActivity().registerReceiver(mReceiver, mIntentFilter);
         if (mLocalAdapter != null) {
-            updateContent(mLocalAdapter.getBluetoothState());
+            int state = mLocalAdapter.getBluetoothState();
+            updateContent(state);
+            if (state == BluetoothAdapter.STATE_BLE_ON) {
+                setOffMessage();
+            }
         }
     }
 
@@ -215,6 +219,11 @@
         // Make the device only visible to connected devices.
         mLocalAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE);
 
+        // SPRD��Remove paired device list preference in case memory leak
+        if (mPairedDevicesCategory != null && mPairedDevicesCategory.getPreferenceCount() > 0) {
+            mPairedDevicesCategory.removeAll();
+        }
+
         if (isUiRestricted()) {
             return;
         }
Index: packages/apps/Settings/src/com/android/settings/search/SearchIndexableResources.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/search/SearchIndexableResources.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/search/SearchIndexableResources.java	(revision 182201)
@@ -232,7 +232,7 @@
         sResMap.put(PowerUsageSummary.class.getName(),
                 new SearchIndexableResource(
                         Ranking.getRankForClassName(PowerUsageSummary.class.getName()),
-                        R.xml.power_usage_summary,
+                        NO_DATA_RES_ID,
                         PowerUsageSummary.class.getName(),
                         R.drawable.ic_settings_battery));
 
Index: packages/apps/Settings/src/com/android/settings/fingerprint/FingerprintEnrollFindSensor.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/fingerprint/FingerprintEnrollFindSensor.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/fingerprint/FingerprintEnrollFindSensor.java	(revision 182201)
@@ -16,6 +16,7 @@
 
 package com.android.settings.fingerprint;
 
+import android.app.FragmentManager;
 import android.content.Intent;
 import android.hardware.fingerprint.FingerprintManager;
 import android.os.Bundle;
@@ -73,6 +74,11 @@
         mSidecar = (FingerprintEnrollSidecar) getFragmentManager().findFragmentByTag(
                 FingerprintEnrollEnrolling.TAG_SIDECAR);
         if (mSidecar == null) {
+            if (mToken != null){
+                Intent intent = getIntent();
+                //if activity is recyled,token is not exist,so put in again
+                intent.putExtra(ChooseLockSettingsHelper.EXTRA_KEY_CHALLENGE_TOKEN, mToken);
+            }
             mSidecar = new FingerprintEnrollSidecar();
             getFragmentManager().beginTransaction()
                     .add(mSidecar, FingerprintEnrollEnrolling.TAG_SIDECAR).commit();
@@ -109,6 +115,10 @@
     @Override
     protected void onDestroy() {
         super.onDestroy();
+        if (mSidecar != null) {
+            //we should cancel listener if the activity is finished
+            mSidecar.setListener(null);
+        }
         mAnimation.stopAnimation();
     }
 
@@ -128,7 +138,14 @@
     }
 
     private void proceedToEnrolling() {
-        getFragmentManager().beginTransaction().remove(mSidecar).commit();
+        final FragmentManager f = getFragmentManager();
+        if (f.isDestroyed()) {
+            return;
+        }
+        if(mSidecar !=null){
+            mSidecar.setListener(null);
+            f.beginTransaction().remove(mSidecar).commit();
+        }
         mSidecar = null;
         startActivityForResult(getEnrollingIntent(), ENROLLING);
     }
Index: packages/apps/Settings/src/com/android/settings/fingerprint/FingerprintSettings.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/fingerprint/FingerprintSettings.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/fingerprint/FingerprintSettings.java	(revision 182201)
@@ -59,6 +59,11 @@
 import android.widget.EditText;
 import android.widget.TextView;
 import android.widget.Toast;
+import android.text.Editable;
+import android.text.InputFilter;
+import android.text.TextUtils;
+import android.text.TextWatcher;
+import android.widget.Button;
 
 import com.android.internal.logging.MetricsLogger;
 import com.android.internal.logging.MetricsProto.MetricsEvent;
@@ -72,6 +77,9 @@
 import com.android.settingslib.RestrictedLockUtils;
 
 import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
 
 import static com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;
 
@@ -110,6 +118,8 @@
 
     public static final String KEY_FINGERPRINT_SETTINGS = "fingerprint_settings";
 
+    private static final int TEXT_MAX_LENGTH = 50;
+
     @Override
     public Intent getIntent() {
         Intent modIntent = new Intent(super.getIntent());
@@ -162,6 +172,7 @@
         private boolean mLaunchedConfirm;
         private Drawable mHighlightDrawable;
         private int mUserId;
+        private boolean mNeedRetryFingerprint = false;
 
         private AuthenticationCallback mAuthCallback = new AuthenticationCallback() {
             @Override
@@ -266,7 +277,9 @@
         }
 
         private void retryFingerprint() {
-            if (!mInFingerprintLockout) {
+            // SPRD: modify the condition for 663188.
+            if (!mInFingerprintLockout
+                    && mFingerprintManager.getEnrolledFingerprints(mUserId).size() > 0) {
                 mFingerprintCancel = new CancellationSignal();
                 mFingerprintManager.authenticate(null, mFingerprintCancel, 0 /* flags */,
                         mAuthCallback, null, mUserId);
@@ -396,6 +409,7 @@
             // Make sure we reload the preference hierarchy since fingerprints may be added,
             // deleted or renamed.
             updatePreferences();
+            mNeedRetryFingerprint = true;
         }
 
         private void updatePreferences() {
@@ -407,6 +421,7 @@
         public void onPause() {
             super.onPause();
             stopFingerprint();
+            mNeedRetryFingerprint = false;
         }
 
         @Override
@@ -512,7 +527,7 @@
             String prefName = genKey(fpId);
             FingerprintPreference fpref = (FingerprintPreference) findPreference(prefName);
             final Drawable highlight = getHighlightDrawable();
-            if (highlight != null) {
+            if (highlight != null && fpref != null) {//modify for bug671415
                 final View view = fpref.getView();
                 final int centerX = view.getWidth() / 2;
                 final int centerY = view.getHeight() / 2;
@@ -562,7 +577,9 @@
             @Override
             public void run() {
                 mInFingerprintLockout = false;
-                retryFingerprint();
+                if (mNeedRetryFingerprint) {
+                    retryFingerprint();
+                }
             }
         };
 
@@ -574,7 +591,30 @@
             private Boolean mTextHadFocus;
             private int mTextSelectionStart;
             private int mTextSelectionEnd;
+            private Button positiveButton;
+            private static final int MSG_FINGER_RENAME_FILTER_UPDATE = 2000;
 
+            private Handler renameHandler = new Handler() {
+                @Override
+                public void handleMessage(android.os.Message msg) {
+                    switch (msg.what) {
+                        case MSG_FINGER_RENAME_FILTER_UPDATE:
+                            String name = (String) msg.obj;
+                            int index = msg.arg1;
+                            mDialogTextField.setText(name);
+                            mDialogTextField.setSelection(index);
+                        break;
+                    }
+                };
+            };
+
+            public static String stringFilter(String str) throws PatternSyntaxException {
+                String regEx = "[\uDBEC-\uDFD4]";
+                Pattern p = Pattern.compile(regEx);
+                Matcher m = p.matcher(str);
+                return m.replaceAll("");
+            }
+
             @Override
             public Dialog onCreateDialog(Bundle savedInstanceState) {
                 mFp = getArguments().getParcelable("fingerprint");
@@ -625,6 +665,46 @@
                                 R.id.fingerprint_rename_field);
                         CharSequence name = mFingerName == null ? mFp.getName() : mFingerName;
                         mDialogTextField.setText(name);
+                        // add by sprd for bug667200 begin
+                        mDialogTextField.setFilters(new InputFilter[]{new InputFilter.LengthFilter(TEXT_MAX_LENGTH)});
+                        mDialogTextField.addTextChangedListener(new TextWatcher() {
+                            @Override
+                            public void onTextChanged(CharSequence s, int start, int before,
+                                    int count) {
+                                String name = mDialogTextField.getText().toString();
+                                String filterName = stringFilter(name);
+                                if (filterName != null && !name.equals(filterName)) {
+                                    char[] nameArray = name.toCharArray();
+                                    char[] filterNameArray = filterName.toCharArray();
+                                    int index;
+                                    for (index = 0; index < filterNameArray.length; index++) {
+                                        if (filterNameArray[index] != nameArray[index]) {
+                                            break;
+                                        }
+                                    }
+                                    renameHandler.obtainMessage(MSG_FINGER_RENAME_FILTER_UPDATE,
+                                            index, 0, filterName).sendToTarget();
+                                }
+                            }
+
+                            @Override
+                            public void beforeTextChanged(CharSequence s, int start, int count,
+                                    int after) {
+                            }
+
+                            @Override
+                            public void afterTextChanged(Editable s) {
+                                if(positiveButton == null) {
+                                    positiveButton = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);
+                                }
+                                String content = s.toString();
+                                if(TextUtils.isEmpty(content)) {
+                                    positiveButton.setEnabled(false);
+                                } else {
+                                    positiveButton.setEnabled(true);
+                                }                    }
+                        });
+                        // add by sprd for bug667200 end
                         if (mTextHadFocus == null) {
                             mDialogTextField.selectAll();
                         } else {
@@ -800,6 +880,11 @@
                 final String key = annotation.getValue();
                 int start = msg.getSpanStart(annotation);
                 int end = msg.getSpanEnd(annotation);
+                Log.w(FingerprintSettingsFragment.TAG, "linkify  uri = " + uri + "start = " + start
+                        + "end = " + end);
+                if (TextUtils.isEmpty(uri)) {
+                    return rawText.toString().substring(0, start);
+                }
                 LearnMoreSpan link = null;
                 if (ANNOTATION_URL.equals(key)) {
                     link = new LearnMoreSpan(uri);
Index: packages/apps/Settings/src/com/android/settings/sim/SimDialogActivity.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/sim/SimDialogActivity.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/sim/SimDialogActivity.java	(revision 182201)
@@ -98,12 +98,20 @@
             case DATA_PICK:
             case CALLS_PICK:
             case SMS_PICK:
-                mSimChooseDialog = createDialog(this, dialogType);
-                mSimChooseDialog.show();
-                mDialogType=dialogType;
+                try {
+                    mSimChooseDialog = createDialog(this, dialogType);
+                    mSimChooseDialog.show();
+                    mDialogType=dialogType;
+                } catch (Exception e) {
+                    Log.d(TAG, "mSimChooseDialog show error: " + e.toString());
+                }
                 break;
             case PREFERRED_PICK:
-                displayPreferredDialog(extras.getInt(PREFERRED_SIM));
+                try {
+                    displayPreferredDialog(extras.getInt(PREFERRED_SIM));
+                } catch (Exception e) {
+                    Log.d(TAG, "displayPreferredDialog show error: " + e.toString());
+                }
                 break;
                 //SPRD: Feature for SIM Languages
             case LANGUAGE_PICK:
Index: packages/apps/Settings/src/com/android/settings/sim/SimSettings.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/sim/SimSettings.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/sim/SimSettings.java	(revision 182201)
@@ -404,7 +404,14 @@
 
         if (preference instanceof SimPreference) {
          // SPRD: modify for Re edit the SIM card interface
-            SimFragmentDialog.show(SimSettings.this, ((SimPreference) preference).getSlotId());
+            if (getActivity() != null && getActivity().isResumed()) {
+                try {
+                    SimFragmentDialog.show(SimSettings.this, ((SimPreference) preference).getSlotId());
+                } catch (Exception e) {
+                    Log.d(TAG, "SimFragmentDialog SimFragmentDialog: " + e.toString());
+                    return false;
+                }
+            }
         } else if (preference instanceof DataPreference) {
             intent.putExtra(SimDialogActivity.DIALOG_TYPE_KEY, SimDialogActivity.DATA_PICK);
             context.startActivity(intent);
@@ -541,7 +548,11 @@
 
     /* SPRD: Modify for bug 603907,Click to disable the SIM card, the pop-up "confirm" POP box, screen switch, POP box disappeared @{ */
     private void showStandbyAlertDialog(final int phoneId, final boolean onOff) {
-        StandbyAlertDialogFragment.show(SimSettings.this, phoneId, onOff);
+        try {
+            StandbyAlertDialogFragment.show(SimSettings.this, phoneId, onOff);
+        } catch (Exception e) {
+            Log.d(TAG, "StandbyAlertDialogFragment show error: "+ e.toString());
+        }
     }
 
     private void resetAlertDialogFragment(DialogFragment dialogFragment) {
Index: packages/apps/Settings/src/com/android/settings/WifiCallingSettings.java
===================================================================
--- packages/apps/Settings/src/com/android/settings/WifiCallingSettings.java	(revision 182200)
+++ packages/apps/Settings/src/com/android/settings/WifiCallingSettings.java	(revision 182201)
@@ -20,9 +20,12 @@
 import android.app.AlertDialog;
 import android.content.BroadcastReceiver;
 import android.content.Context;
+import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.database.ContentObserver;
 import android.os.Bundle;
+import android.os.Handler;
 import android.os.PersistableBundle;
 import android.support.v7.preference.ListPreference;
 import android.support.v7.preference.Preference;
@@ -32,6 +35,10 @@
 import android.telephony.PhoneStateListener;
 import android.telephony.TelephonyManager;
 import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.WindowManager;
+import android.widget.CheckBox;
 import android.widget.Switch;
 import android.widget.TextView;
 
@@ -41,6 +48,8 @@
 import com.android.internal.logging.MetricsProto.MetricsEvent;
 import com.android.internal.telephony.Phone;
 import com.android.settings.widget.SwitchBar;
+import android.provider.SettingsEx;
+import android.provider.Settings;
 
 /**
  * "Wi-Fi Calling settings" screen.  This preference screen lets you
@@ -64,6 +73,16 @@
     private boolean mValidListener = false;
     private boolean mEditableWfcMode = true;
 
+    private ContentObserver mWfcEnableObserver = new ContentObserver(new Handler()) {
+        @Override
+        public void onChange(boolean selfChange) {
+            boolean enabled = ImsManager.isWfcEnabledByUser(getActivity())
+                    && ImsManager.isNonTtyOrTtyOnVolteEnabled(getActivity());
+            Log.d(TAG,"[mWfcEnableObserver][wfcEnabled]: " + enabled);
+            mSwitchBar.setChecked(enabled);
+        }
+    };
+
     private final PhoneStateListener mPhoneStateListener = new PhoneStateListener() {
         /*
          * Enable/disable controls when in/out of a call and depending on
@@ -187,6 +206,7 @@
             mButtonWfcMode.setEntries(R.array.wifi_calling_mode_choices_without_wifi_only);
             mButtonWfcMode.setEntryValues(R.array.wifi_calling_mode_values_without_wifi_only);
         }
+
     }
 
     @Override
@@ -213,7 +233,9 @@
         updateButtonWfcMode(context, wfcEnabled, wfcMode);
 
         context.registerReceiver(mIntentReceiver, mIntentFilter);
-
+        context.getContentResolver().registerContentObserver(
+                Settings.Global.getUriFor(Settings.Global.WFC_IMS_ENABLED), true,
+                mWfcEnableObserver);
         Intent intent = getActivity().getIntent();
         if (intent.getBooleanExtra(Phone.EXTRA_KEY_ALERT_SHOW, false)) {
             showAlert(intent);
@@ -223,7 +245,7 @@
     @Override
     public void onPause() {
         super.onPause();
-
+        Log.d(TAG,"[onPause]");
         final Context context = getActivity();
 
         if (mValidListener) {
@@ -236,6 +258,7 @@
         }
 
         context.unregisterReceiver(mIntentReceiver);
+        context.getContentResolver().unregisterContentObserver(mWfcEnableObserver);
     }
 
     /**
@@ -243,8 +266,8 @@
      */
     @Override
     public void onSwitchChanged(Switch switchView, boolean isChecked) {
+        Log.d(TAG,"[isSwitchChecked]: " + isChecked);
         final Context context = getActivity();
-
         ImsManager.setWfcSetting(context, isChecked);
 
         int wfcMode = ImsManager.getWfcMode(context);
Index: packages/apps/Settings/src/com/sprd/settings/wifi/WifiSoftApSleepPolicy.java
===================================================================
--- packages/apps/Settings/src/com/sprd/settings/wifi/WifiSoftApSleepPolicy.java	(revision 182200)
+++ packages/apps/Settings/src/com/sprd/settings/wifi/WifiSoftApSleepPolicy.java	(revision 182201)
@@ -72,9 +72,7 @@
         String action = intent.getAction();
         //check null pointer
         init(mContext);
-        if (action != null) {
-            Log.e(TAG,"Receive " + action);
-        }
+
         if (WifiManager.WIFI_AP_STATE_CHANGED_ACTION.equals(action)) {
             isSoftApRunning = true;
             int hotspotState = intent.getIntExtra(
Index: packages/apps/Settings/src/com/sprd/settings/SprdUsbSettingsFragment.java
===================================================================
--- packages/apps/Settings/src/com/sprd/settings/SprdUsbSettingsFragment.java	(revision 182200)
+++ packages/apps/Settings/src/com/sprd/settings/SprdUsbSettingsFragment.java	(revision 182201)
@@ -1,4 +1,6 @@
-/** Created by Spreadst */
+/**
+ * Created by Spreadst
+ */
 package com.sprd.settings;
 
 import android.content.BroadcastReceiver;
@@ -9,6 +11,7 @@
 import android.os.BatteryManager;
 import android.os.Bundle;
 import android.os.SystemProperties;
+import android.os.UserHandle;
 import android.os.UserManager;
 import android.preference.PreferenceFragment;
 import android.preference.Preference;
@@ -20,9 +23,17 @@
 import com.android.settings.R;
 import com.android.settings.SettingsPreferenceFragment;
 import com.android.settings.Utils;
+import com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;
+import com.android.settingslib.RestrictedLockUtils;
 
+import android.support.v7.preference.PreferenceViewHolder;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.RadioButton;
+import android.widget.TextView;
+
 public class SprdUsbSettingsFragment extends SettingsPreferenceFragment
-        implements RadioButtonPreference.OnClickListener {
+        implements RadioButtonPreference.OnClickListener, RadioButtonPreference.OnFileTransferRestrictedListener {
 
     private final String LOG_TAG = "SprdUsbSettings";
     private final static boolean DBG = true;
@@ -48,6 +59,7 @@
 
     private boolean SUPPORT_CTA = SystemProperties.getBoolean("ro.usb.support_cta", false);
     private boolean mIsUnlocked = false;
+    private boolean mIsFileTransferRestricted;
 
     @SuppressWarnings("deprecation")
     public void onActivityCreated(Bundle savedInstanceState) {
@@ -70,17 +82,24 @@
         //mCdrom.setOnClickListener(this);
         //mMidi.setOnClickListener(this);
         mUms.setOnClickListener(this);
+        mMtp.setOnFileTransferRestrictedListener(this);
+        mPtp.setOnFileTransferRestrictedListener(this);
         if (!SUPPORT_UMS) {
             getPreferenceScreen().removePreference(mUms);
         }
         mUsbManager = (UsbManager) getActivity().getSystemService(Context.USB_SERVICE);
 
-        boolean isFileTransferRestricted = ((UserManager) getActivity().getSystemService(Context.USER_SERVICE))
+        mIsFileTransferRestricted = ((UserManager) getActivity().getSystemService(Context.USER_SERVICE))
                 .hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER);
-        if (isFileTransferRestricted) {
-            getPreferenceScreen().removePreference(mMtp);
-            getPreferenceScreen().removePreference(mPtp);
+        /* SPRD:Add for bug#733341 Disallow USB file transfer cts tests failed @{ */
+        if (mIsUnlocked && mIsFileTransferRestricted) {
+            boolean isMtpOrPtp = UsbManager.USB_FUNCTION_MTP.equals(getCurrentFunction()) || UsbManager.USB_FUNCTION_PTP.equals(getCurrentFunction());
+            if (isMtpOrPtp) {
+                mUsbManager.setUsbDataUnlocked(false);
+                mIsUnlocked = false;
+            }
         }
+        /* Bug733341 @} */
 
         mPowerDisconnectReceiver = new PowerDisconnectReceiver();
         getActivity().registerReceiver(mPowerDisconnectReceiver, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
@@ -109,7 +128,17 @@
     @Override
     public void onRadioButtonClicked(RadioButtonPreference preference) {
 
-        Log.d(LOG_TAG ,"onRadioButtonClicked");
+        Log.d(LOG_TAG, "onRadioButtonClicked");
+        /* SPRD:Add for bug#733341 Disallow USB file transfer cts tests failed @{*/
+        String key = preference.getKey();
+        if (mIsFileTransferRestricted && (KEY_MTP.equals(key) || KEY_PTP.equals(key))) {
+            EnforcedAdmin mEnforcedAdmin = RestrictedLockUtils.checkIfRestrictionEnforced(getActivity(),
+                    UserManager.DISALLOW_USB_FILE_TRANSFER, UserHandle.myUserId());
+            RestrictedLockUtils.sendShowAdminSupportDetailsIntent(
+                    getActivity(), mEnforcedAdmin);
+            return;
+        }
+        /* Bug733341 end@} */
         if (Utils.isMonkeyRunning()) {
             return;
         }
@@ -227,4 +256,20 @@
         return 1;
     }
 
+    /* SPRD:Add for bug#733341 Disallow USB file transfer cts tests failed @{ */
+    @Override
+    public void OnFileTransferRestricted(PreferenceViewHolder view) {
+        if (mIsFileTransferRestricted) {
+            TextView title = (TextView) view.findViewById(android.R.id.title);
+            ImageView infoButton = (ImageView) view.findViewById(R.id.restricted_icon);
+            RadioButton radioButton = (RadioButton) view.findViewById(android.R.id.checkbox);
+            TextView summary = (TextView) view.findViewById(android.R.id.summary);
+
+            radioButton.setVisibility(View.GONE);
+            infoButton.setVisibility(View.VISIBLE);
+            summary.setEnabled(false);
+            title.setEnabled(false);
+        }
+    }
+    /* Bug733341 @} */
 }
Index: packages/apps/Settings/src/com/sprd/settings/RadioButtonPreference.java
===================================================================
--- packages/apps/Settings/src/com/sprd/settings/RadioButtonPreference.java	(revision 182200)
+++ packages/apps/Settings/src/com/sprd/settings/RadioButtonPreference.java	(revision 182201)
@@ -25,7 +25,14 @@
         public abstract void onRadioButtonClicked(RadioButtonPreference emiter);
     }
 
+    /* SPRD:Add for bug#733341 Disallow USB file transfer cts tests failed @{ */
+    public interface OnFileTransferRestrictedListener {
+        public abstract void OnFileTransferRestricted(PreferenceViewHolder view);
+    }
+
     private OnClickListener mListener = null;
+    private OnFileTransferRestrictedListener mOnFileTransferRestrictedListener= null;
+    /* Bug733341 end @} */
 
     public RadioButtonPreference(Context context, AttributeSet attrs, int defStyle) {
         super(context, attrs, defStyle);
@@ -44,6 +51,10 @@
         mListener = listener;
     }
 
+    void setOnFileTransferRestrictedListener(OnFileTransferRestrictedListener listener) {
+        mOnFileTransferRestrictedListener = listener;
+    }
+
     @Override
     public void onClick() {
         if (mListener != null) {
@@ -60,5 +71,9 @@
             title.setSingleLine(false);
             title.setMaxLines(3);
         }
+        /* SPRD:Add for bug#733341 Disallow USB file transfer cts tests failed @{ */
+        if (mOnFileTransferRestrictedListener != null) {
+            mOnFileTransferRestrictedListener.OnFileTransferRestricted(view);
+        }
     }
 }
Index: packages/apps/Settings/res/layout/fingerprint_enroll_find_sensor_base.xml
===================================================================
--- packages/apps/Settings/res/layout/fingerprint_enroll_find_sensor_base.xml	(revision 182200)
+++ packages/apps/Settings/res/layout/fingerprint_enroll_find_sensor_base.xml	(revision 182201)
@@ -22,7 +22,8 @@
     android:layout_height="match_parent"
     style="?attr/fingerprint_layout_theme">
 
-    <FrameLayout
+    <LinearLayout
+        style="@style/SuwContentFrame"
         android:layout_width="match_parent"
         android:layout_height="match_parent"
         android:orientation="vertical"
@@ -29,43 +30,40 @@
         android:clipToPadding="false"
         android:clipChildren="false">
 
-        <include
-            layout="@layout/fingerprint_enroll_find_sensor_graphic"
+        <TextView
+            style="@style/TextAppearance.FingerprintMessage"
+            android:id="@+id/findsensor_textview"
             android:layout_width="match_parent"
-            android:layout_height="match_parent"
-            android:layout_gravity="center_horizontal|bottom"/>
+            android:layout_height="wrap_content"
+            android:layout_marginTop="@dimen/suw_description_margin_top"
+            android:text="@string/security_settings_fingerprint_enroll_find_sensor_message"/>
 
-        <LinearLayout
-            style="@style/SuwContentFrame"
+        <View
+            android:layout_height="0dp"
             android:layout_width="match_parent"
-            android:layout_height="match_parent"
-            android:orientation="vertical"
-            android:clipToPadding="false"
-            android:clipChildren="false">
+            android:layout_weight="1"/>
 
-            <TextView
-                style="@style/TextAppearance.FingerprintMessage"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:layout_marginTop="@dimen/suw_description_margin_top"
-                android:text="@string/security_settings_fingerprint_enroll_find_sensor_message"/>
+        <include
+            layout="@layout/fingerprint_enroll_find_sensor_graphic"
+            android:layout_width="@dimen/fingerprint_find_sensor_graphic_size"
+            android:layout_height="@dimen/fingerprint_find_sensor_graphic_size"
+            android:layout_gravity="center_horizontal"/>
 
-            <View
-                android:layout_height="0dp"
-                android:layout_width="match_parent"
-                android:layout_weight="1"/>
+        <View
+            android:layout_height="0dp"
+            android:layout_width="match_parent"
+            android:layout_weight="1"/>
 
-            <Button
-                style="@style/Button.FingerprintButton"
-                android:id="@+id/next_button"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:layout_marginBottom="4dp"
-                android:layout_marginEnd="-12dp"
-                android:layout_gravity="end"
-                android:gravity="end|center_vertical"
-                android:text="@string/fingerprint_enroll_button_next" />
+        <Button
+            style="@style/Button.FingerprintButton"
+            android:id="@+id/next_button"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="4dp"
+            android:layout_marginEnd="-12dp"
+            android:layout_gravity="end"
+            android:gravity="end|center_vertical"
+            android:text="@string/fingerprint_enroll_button_next" />
 
-        </LinearLayout>
-    </FrameLayout>
+    </LinearLayout>
 </com.android.setupwizardlib.SetupWizardLayout>
Index: packages/apps/Settings/res/layout/preference_widget_radiobutton.xml
===================================================================
--- packages/apps/Settings/res/layout/preference_widget_radiobutton.xml	(revision 182200)
+++ packages/apps/Settings/res/layout/preference_widget_radiobutton.xml	(revision 182201)
@@ -16,10 +16,27 @@
 
 <!-- Layout used by CheckBoxPreference for the checkbox style. This is inflated
      inside android.R.layout.preference. -->
-<RadioButton xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+android:id/checkbox"
-    android:layout_width="wrap_content"
-    android:layout_height="wrap_content"
-    android:layout_gravity="center"
-    android:focusable="false"
-    android:clickable="false" />
+<!--SPRD:Add for bug#733341 Disallow USB file transfer cts tests failed @{-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+    <RadioButton
+        android:id="@+android:id/checkbox"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center"
+        android:focusable="false"
+        android:clickable="false" />
+
+    <ImageView
+        android:id="@+id/restricted_icon"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center"
+        android:scaleType="centerInside"
+        android:src="@drawable/ic_info"
+        android:layout_marginRight="@dimen/restricted_icon_padding"
+        android:visibility="gone"/>
+
+</LinearLayout>
+<!--Bug733341 end @}-->
\ No newline at end of file
Index: packages/apps/Settings/res/layout/fingerprint_enroll_enrolling_content.xml
===================================================================
--- packages/apps/Settings/res/layout/fingerprint_enroll_enrolling_content.xml	(revision 182200)
+++ packages/apps/Settings/res/layout/fingerprint_enroll_enrolling_content.xml	(revision 182201)
@@ -35,6 +35,7 @@
         android:layout_width="?attr/fingerprint_progress_bar_size"
         android:layout_height="?attr/fingerprint_progress_bar_size"
         android:layout_centerInParent="true"
+        android:layoutDirection="ltr"
         style="?android:attr/progressBarStyleHorizontal"
         android:max="10000"
         android:progress="0"
Index: packages/apps/Settings/res/layout/fingerprint_enroll_finish_base.xml
===================================================================
--- packages/apps/Settings/res/layout/fingerprint_enroll_finish_base.xml	(revision 182200)
+++ packages/apps/Settings/res/layout/fingerprint_enroll_finish_base.xml	(revision 182201)
@@ -55,8 +55,8 @@
 
         <ImageView
             android:id="@+id/fingerprint_in_app_indicator"
-            android:layout_height="wrap_content"
-            android:layout_width="wrap_content"
+            android:layout_height="@dimen/fingerprint_in_app_indicator_size"
+            android:layout_width="@dimen/fingerprint_in_app_indicator_size"
             android:layout_weight="5"
             android:minHeight="@dimen/fingerprint_in_app_indicator_min_size"
             android:minWidth="@dimen/fingerprint_in_app_indicator_min_size"
Index: packages/apps/Settings/res/xml/language_settings.xml
===================================================================
--- packages/apps/Settings/res/xml/language_settings.xml	(revision 182200)
+++ packages/apps/Settings/res/xml/language_settings.xml	(revision 182201)
@@ -106,14 +106,4 @@
                 />
 
     </PreferenceCategory>
-
-    <!-- SPRD: Feature for SIM Languages @{ -->
-    <PreferenceScreen
-        android:key="simcard_stored_lang_edit"
-        android:summary="@string/edit_sim_lang_more"
-        android:title="@string/edit_sim_lang" >
-    </PreferenceScreen>
-    <!-- @} -->
-
-
 </PreferenceScreen>
Index: packages/apps/Settings/res/values-th/strings.xml
===================================================================
--- packages/apps/Settings/res/values-th/strings.xml	(revision 182200)
+++ packages/apps/Settings/res/values-th/strings.xml	(revision 182201)
@@ -2928,7 +2928,7 @@
     <string name="camera_gesture_desc" msgid="1831390075255870960">"เปิดแอปกล้องถ่ายรูปโดยบิดข้อมือ 2 ครั้ง"</string>
     <string name="camera_double_tap_power_gesture_title" msgid="1651873760405034645">"กดปุ่มเปิด/ปิด 2 ครั้งสำหรับกล้อง"</string>
     <string name="camera_double_tap_power_gesture_desc" msgid="7355664631775680376">"เปิดกล้องอย่างรวดเร็วโดยไม่ต้องปลดล็อกหน้าจอ"</string>
-    <string name="screen_zoom_title" msgid="5233515303733473927">"ขนาดที่แสดง"</string>
+    <string name="screen_zoom_title" msgid="5233515303733473927">"ขนาดการแสดงผล"</string>
     <string name="screen_zoom_short_summary" msgid="7291960817349834688">"ทำให้รายการบนหน้าจอมีขนาดใหญ่ขึ้นหรือเล็กลง"</string>
     <string name="screen_zoom_keywords" msgid="9176477565403352552">"ความหนาแน่นในการแสดงผล, ซูมหน้าจอ, ระดับ, การปรับระดับ"</string>
     <string name="screen_zoom_summary" msgid="6445488991799015407">"ทำให้รายการบนหน้าจอมีขนาดเล็กลงหรือใหญ่ขึ้น แอปบางส่วนบนหน้าจออาจเปลี่ยนตำแหน่ง"</string>
Index: packages/apps/Settings/res/values-ne-rNP/strings.xml
===================================================================
--- packages/apps/Settings/res/values-ne-rNP/strings.xml	(revision 182200)
+++ packages/apps/Settings/res/values-ne-rNP/strings.xml	(revision 182201)
@@ -440,7 +440,7 @@
     <string name="unlock_set_unlock_pattern_summary" msgid="7062696666227725593">"मध्यम सुरक्षा"</string>
     <string name="unlock_set_unlock_pin_title" msgid="5846029709462329515">"PIN"</string>
     <string name="unlock_set_unlock_pin_summary" msgid="907878650556383388">"मध्यमदेखि उच्च सुरक्षा"</string>
-    <string name="unlock_set_unlock_password_title" msgid="8775603825675090937">"पासवर्ड:"</string>
+    <string name="unlock_set_unlock_password_title" msgid="8775603825675090937">"पासवर्ड"</string>
     <string name="unlock_set_unlock_password_summary" msgid="8856220848940929546">"उच्च सुरक्षा"</string>
     <string name="unlock_set_do_later_title" msgid="4894767558414979243">"अहिले होइन"</string>
     <string name="current_screen_lock" msgid="4104091715420072219">"वर्तमान स्क्रिन लक"</string>
Index: packages/apps/Settings/res/values/dimens.xml
===================================================================
--- packages/apps/Settings/res/values/dimens.xml	(revision 182200)
+++ packages/apps/Settings/res/values/dimens.xml	(revision 182201)
@@ -228,7 +228,7 @@
     <dimen name="fingerprint_animation_size">88dp</dimen>
     <dimen name="fingerprint_progress_bar_size">192dp</dimen>
     <dimen name="fingerprint_enrolling_content_margin_top">36dp</dimen>
-    <dimen name="fingerprint_in_app_indicator_size">124dp</dimen>
+    <dimen name="fingerprint_in_app_indicator_size">160dp</dimen>
     <dimen name="fingerprint_in_app_indicator_min_size">124dp</dimen>
     <dimen name="fingerprint_in_app_indicator_max_size">264dp</dimen>
 
Index: packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterService.java
===================================================================
--- packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterService.java	(revision 182200)
+++ packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterService.java	(revision 182201)
@@ -1607,10 +1607,12 @@
         if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {
             return false;
         }
-
+        //  SPRD: modify for bug 707086
+        if (isDiscovering()) {
         // Pairing is unreliable while scanning, so cancel discovery
         // Note, remove this when native stack improves
         cancelDiscoveryNative();
+        }
 
         Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);
         msg.obj = device;
Index: packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppObexClientSession.java
===================================================================
--- packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppObexClientSession.java	(revision 182200)
+++ packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppObexClientSession.java	(revision 182201)
@@ -558,10 +558,10 @@
                 handleSendException(e.toString());
             } finally {
                 try {
+                    BluetoothOppUtility.closeSendFileInfo(mInfo.mUri);
                     if (outputStream != null) {
                       outputStream.close();
                     }
-                    BluetoothOppUtility.closeSendFileInfo(mInfo.mUri);
 
                     if (!error) {
                         responseCode = putOperation.getResponseCode();
Index: packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppUtility.java
===================================================================
--- packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppUtility.java	(revision 182200)
+++ packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppUtility.java	(revision 182201)
@@ -78,8 +78,8 @@
     private static final int OBEX_TIMEOUT_DELAY = 120000;
     private static boolean bIsSessionTimerSwitchOn = SystemProperties.getBoolean("persist.bt.autodisconnect", true);
     //<-- Add for Add for Bluetooth Opp auto disconnect Feature END
-	
-	public static boolean isBluetoothShareUri(Uri uri) {
+
+    public static boolean isBluetoothShareUri(Uri uri) {
         return uri.toString().startsWith(BluetoothShare.CONTENT_URI.toString());
     }
 
@@ -193,7 +193,7 @@
             return;
         }
 
-		if (!isBluetoothShareUri(uri)) {
+        if (!isBluetoothShareUri(uri)) {
             Log.e(TAG, "Trying to open a file that wasn't transfered over Bluetooth");
             return;
         }
@@ -408,7 +408,8 @@
             }
         }
     }
-	 /**
+
+    /**
      * Checks if the URI is in Environment.getExternalStorageDirectory() as it
      * is the only directory that is possibly readable by both the sender and
      * the Bluetooth process.
Index: packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java
===================================================================
--- packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java	(revision 182200)
+++ packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java	(revision 182201)
@@ -158,7 +158,7 @@
                 }
             }
         } else if ("file".equals(scheme)) {
-			if (uri.getPath() == null) {
+            if (uri.getPath() == null) {
                 Log.e(TAG, "Invalid URI path: " + uri);
                 return SEND_FILE_INFO_ERROR;
             }
Index: packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppLauncherActivity.java
===================================================================
--- packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppLauncherActivity.java	(revision 182200)
+++ packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppLauncherActivity.java	(revision 182201)
@@ -117,8 +117,8 @@
                     Thread t = new Thread(new Runnable() {
                         public void run() {
                             BluetoothOppManager.getInstance(BluetoothOppLauncherActivity.this)
-                                .saveSendingFileInfo(type,stream.toString(), 
-								false /* isHandover */, true /* fromExternal */);
+                                .saveSendingFileInfo(type,stream.toString(),
+                                    false /* isHandover */, true /* fromExternal */);
                             //Done getting file info..Launch device picker and finish this activity
                             launchDevicePicker();
                             //finish();
@@ -134,8 +134,8 @@
                         Thread t = new Thread(new Runnable() {
                             public void run() {
                                 BluetoothOppManager.getInstance(BluetoothOppLauncherActivity.this)
-                                    .saveSendingFileInfo(type,fileUri.toString(), 
-									false /* isHandover */, false /* fromExternal */);
+                                    .saveSendingFileInfo(type,fileUri.toString(),
+                                        false /* isHandover */, false /* fromExternal */);
                                 //Done getting file info..Launch device picker
                                 //and finish this activity
                                 launchDevicePicker();
@@ -163,8 +163,8 @@
                     Thread t = new Thread(new Runnable() {
                         public void run() {
                             BluetoothOppManager.getInstance(BluetoothOppLauncherActivity.this)
-                                .saveSendingFileInfo(mimeType,uris, 
-								 false /* isHandover */, true /* fromExternal */);
+                                .saveSendingFileInfo(mimeType,uris,
+                                    false /* isHandover */, true /* fromExternal */);
                             //Done getting file info..Launch device picker
                             //and finish this activity
                             launchDevicePicker();
Index: packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppHandoverReceiver.java
===================================================================
--- packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppHandoverReceiver.java	(revision 182200)
+++ packages/apps/Bluetooth/src/com/android/bluetooth/opp/BluetoothOppHandoverReceiver.java	(revision 182201)
@@ -50,7 +50,7 @@
                     // Save type/stream, will be used when adding transfer
                     // session to DB.
                     BluetoothOppManager.getInstance(context).saveSendingFileInfo(type,
-                            stream.toString(), true /* isHandover */, true /* fromExternal */);
+                            stream.toString(), true  /* isHandover */, true /* fromExternal */);
                 } else {
                     if (D) Log.d(TAG, "No mimeType or stream attached to handover request");
                 }
@@ -60,7 +60,7 @@
                 uris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
                 if (mimeType != null && uris != null) {
                     BluetoothOppManager.getInstance(context).saveSendingFileInfo(mimeType,
-                            uris, true/* isHandover */, true /* fromExternal */);
+                            uris, true /* isHandover */, true /* fromExternal */);
                 } else {
                     if (D) Log.d(TAG, "No mimeType or stream attached to handover request");
                     return;
Index: packages/apps/Bluetooth/AndroidManifest.xml
===================================================================
--- packages/apps/Bluetooth/AndroidManifest.xml	(revision 182200)
+++ packages/apps/Bluetooth/AndroidManifest.xml	(revision 182201)
@@ -221,7 +221,7 @@
                   android:label=""
                   android:theme="@android:style/Theme.Material"
                   android:excludeFromRecents="true"
-                  android:configChanges="orientation|keyboardHidden"
+                  android:configChanges="orientation|keyboardHidden|screenSize"
                   android:enabled="@bool/profile_supported_opp">
         </activity>
         <activity android:name=".pbap.BluetoothPbapActivity"
Index: packages/apps/Messaging/src/com/android/messaging/sms/MmsUtils.java
===================================================================
--- packages/apps/Messaging/src/com/android/messaging/sms/MmsUtils.java	(revision 182200)
+++ packages/apps/Messaging/src/com/android/messaging/sms/MmsUtils.java	(revision 182201)
@@ -3396,7 +3396,61 @@
         }
         return mGetDisplayNameHandlerThread;
     }
+    // Add for bug 732616 start
+    public static void showSmsDeliveryReport(final Context context,final Uri smsMessageUri){
+        Cursor telecursor = null;
+        String address = null;
+        String displayName =null;
+        String reportString =null;
+        LogUtil.d(TAG, "showSmsDeliveryReport:"+smsMessageUri);
+        try{
+            final ContentResolver resolver = Factory.get().getApplicationContext().getContentResolver();
+            telecursor = resolver.query(smsMessageUri,new String[] {Sms.ADDRESS},null,null/*selectionArgs*/,null/*sortOrder*/);
+            if(telecursor != null){
+                if(telecursor.moveToFirst()){
+                    address = telecursor.getString(0);
+                    LogUtil.d(TAG, "Get ADDRESS:"+address);
+                }
+            }
+        }catch(Exception e){
+            LogUtil.d(TAG, "Get ADDRESS:"+e.toString());
+        }finally{
+            if(telecursor != null){
+                telecursor.close();
+            }
+        }
+        CursorQueryData cursorQueryData = ContactUtil.lookupDestination(context, address);
+        Cursor cursor = cursorQueryData.performSynchronousQuery();
+        if (cursor == null) {
+            displayName = null;
+        } else {
+            try {
+                for (int i = 0; i < cursor.getCount(); i++) {
+                    cursor.moveToPosition(i);
+                    int nameFieldColumnIndex = cursor.getColumnIndex(ContactsContract.PhoneLookup.DISPLAY_NAME);
+                    displayName = cursor.getString(nameFieldColumnIndex);
+                    break;
+                }
+            } finally {
+                if (!cursor.isClosed()) {
+                    cursor.close();
+                }
+            }
+        }
 
+        String report = context.getString(R.string.delivery_toast_body);
+        if (displayName != null) {
+            reportString = String.format(report, displayName);
+        } else {
+            reportString = String.format(report, address);
+        }
+
+        LogUtil.d(TAG, "Report message is: " + report);
+        Intent notify = new Intent(NOTIFY_SHOW_MMS_SMS_REPORT_ACTION);
+        notify.putExtra("report", reportString);
+        context.sendBroadcast(notify);
+    }
+    // Add for bug 732616 end
     public static void showReportWithContactName(final Context context, final String address, final String report) {
         HandlerThread handlerThread = getHandlerThread();
         handlerThread.start();
Index: packages/apps/Messaging/src/com/android/messaging/receiver/SendStatusReceiver.java
===================================================================
--- packages/apps/Messaging/src/com/android/messaging/receiver/SendStatusReceiver.java	(revision 182200)
+++ packages/apps/Messaging/src/com/android/messaging/receiver/SendStatusReceiver.java	(revision 182201)
@@ -97,7 +97,7 @@
                 if (null != address) {
                     String report = context.getString(R.string.delivery_toast_body);
                     /* Add by SPRD for bug 571437 Start */
-                    MmsUtils.showReportWithContactName(context, address, report);
+                    //MmsUtils.showReportWithContactName(context, address, report);//Modify for bug 732616
                     /* Add by SPRD for bug 571437 end */
                 }
                 /* Add by SPRD for bug 531941 End */
Index: packages/apps/Messaging/src/com/android/messaging/datamodel/MessagingContentProvider.java
===================================================================
--- packages/apps/Messaging/src/com/android/messaging/datamodel/MessagingContentProvider.java	(revision 182200)
+++ packages/apps/Messaging/src/com/android/messaging/datamodel/MessagingContentProvider.java	(revision 182201)
@@ -580,7 +580,7 @@
                 DeleteMessageAction.deleteMessage(id);
                 break;
             case CLEAR_SIM_MESSAGES_CODE:
-                try {
+                try { /*Bug 728105 start*/
                     final DatabaseWrapper db = DataModel.get().getDatabase();
                     db.execSQL("delete from sim_messages");
                     Factory.get().getApplicationContext().getContentResolver().notifyChange(SIM_MESSAGE_LIST_VIEW_URI, null);
@@ -587,7 +587,7 @@
                 } catch (Exception e) {
                     e.printStackTrace();
                 }
-                break;
+                break; /*Bug 728105 end*/
             default:
                 break;
         }
Index: packages/apps/Messaging/src/com/android/messaging/datamodel/action/ProcessDeliveryReportAction.java
===================================================================
--- packages/apps/Messaging/src/com/android/messaging/datamodel/action/ProcessDeliveryReportAction.java	(revision 182200)
+++ packages/apps/Messaging/src/com/android/messaging/datamodel/action/ProcessDeliveryReportAction.java	(revision 182201)
@@ -34,6 +34,7 @@
 import com.android.messaging.util.LogUtil;
 
 import java.util.concurrent.TimeUnit;
+import com.android.messaging.Factory;
 
 public class ProcessDeliveryReportAction extends Action implements Parcelable {
     private static final String TAG = LogUtil.BUGLE_DATAMODEL_TAG;
@@ -70,7 +71,11 @@
             MmsUtils.updateSmsStatusAndDateSent(smsMessageUri, status, timeSentInMillis);
         }
         /* Modify by SPRD for bug 531941 End */
-
+        // Add for bug 732616 start
+        if(smsMessageUri != null && smsMessageUri.toString().startsWith(Telephony.Sms.CONTENT_URI.toString())){
+            MmsUtils.showSmsDeliveryReport(Factory.get().getApplicationContext(),smsMessageUri);
+        }
+        // Add for bug 732616 end
         // Update local message
         db.beginTransaction();
         try {
Index: packages/apps/Messaging/src/com/android/messaging/datamodel/media/GifImageResource.java
===================================================================
--- packages/apps/Messaging/src/com/android/messaging/datamodel/media/GifImageResource.java	(revision 182200)
+++ packages/apps/Messaging/src/com/android/messaging/datamodel/media/GifImageResource.java	(revision 182201)
@@ -23,6 +23,7 @@
 import android.support.rastermill.FrameSequenceDrawable;
 
 import com.android.messaging.util.Assert;
+import com.android.messaging.util.LogUtil;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -55,7 +56,14 @@
 
     @Override
     public Drawable getDrawable(Resources resources) {
-        return new FrameSequenceDrawable(mFrameSequence);
+        try {
+            return new FrameSequenceDrawable(mFrameSequence);
+        } catch (final Exception e) {
+            // Malicious gif images can make platform throw different kind of exceptions. Catch
+            // them all.
+            LogUtil.e(LogUtil.BUGLE_TAG, "Error getting drawable for GIF", e);
+            return null;
+        }
     }
 
     @Override
Index: packages/apps/Messaging/src/com/android/messaging/ui/conversation/ComposeMessageView.java
===================================================================
--- packages/apps/Messaging/src/com/android/messaging/ui/conversation/ComposeMessageView.java	(revision 182200)
+++ packages/apps/Messaging/src/com/android/messaging/ui/conversation/ComposeMessageView.java	(revision 182201)
@@ -632,7 +632,7 @@
             } else {
                 prefixSignature = "";
             }
-            mBinding.getData().setSending(true);
+            //mBinding.getData().setSending(true);/* deleted by sprd for Bug 672659*/
             final String messageToSend = mComposeEditText.getText().toString() + prefixSignature;
             /*SPRD: add for Bug 489231--new feature,enable signature text append to a message. end */
             mBinding.getData().setMessageText(messageToSend);
@@ -657,6 +657,7 @@
                                 }
                             }
                             /*Add by SPRD for bug581044  2016.07.08 End*/
+                            mBinding.getData().setSending(true);/* added by sprd for Bug 672659*/
                             final MessageData message = mBinding.getData()
                                     .prepareMessageForSending(mBinding);
                             //spread: function for sending empty msg start
@@ -811,8 +812,8 @@
         // As this is called asynchronously when message read check bound before updating text
         mBinding.ensureBound(data);
         // Add by SPRD for bug 563344
-        final boolean shouldUseSmilView = ( (MessageData.PROTOCOL_MMS_SMIL == data.mProtocol) &&
-                                            (data.getAttachments().size() > 0) );
+        final boolean shouldUseSmilView = ((MessageData.PROTOCOL_MMS_SMIL == data.mProtocol) &&
+                                            (data.getAttachments().size() > 0));
 
         // We have to cache the values of the DraftMessageData because when we set
         // mComposeEditText, its onTextChanged calls updateVisualsOnDraftChanged,
@@ -970,6 +971,7 @@
             Log.d("CompoeMessageView","addPendingAttachment Exception");
         }
     }
+
     @Override
     public void StartSlideshow() {
         mHost.StartSlideshow();
Index: packages/apps/Messaging/src/com/android/messaging/util/operater/CmccParameter.java
===================================================================
--- packages/apps/Messaging/src/com/android/messaging/util/operater/CmccParameter.java	(revision 182200)
+++ packages/apps/Messaging/src/com/android/messaging/util/operater/CmccParameter.java	(revision 182201)
@@ -24,6 +24,9 @@
         // using Cmcc Var
         b.putBoolean(MmsConfig.IS_CMCC_PARAM, true);
 
+        //hide encode type setting for Bug 686840
+        b.putInt(MmsConfig.ENCODETYPE_PREFE_STATUS, -1);
+
         return b;
     }
 
Index: packages/apps/Messaging/src/com/android/messaging/util/operater/CuccParameter.java
===================================================================
--- packages/apps/Messaging/src/com/android/messaging/util/operater/CuccParameter.java	(revision 182200)
+++ packages/apps/Messaging/src/com/android/messaging/util/operater/CuccParameter.java	(revision 182201)
@@ -23,6 +23,9 @@
         // Play Beep while Calling;
         b.putBoolean(MmsConfig.BEEP_ON_CALL_STATE, true);
 
+        //hide encode type setting for Bug 686840
+        b.putInt(MmsConfig.ENCODETYPE_PREFE_STATUS, -1);
+
         return b;
     }
 
Index: packages/apps/Messaging/res/xml-mcc334-mnc020/mms_config.xml
===================================================================
--- packages/apps/Messaging/res/xml-mcc334-mnc020/mms_config.xml	(revision 182200)
+++ packages/apps/Messaging/res/xml-mcc334-mnc020/mms_config.xml	(revision 182201)
@@ -30,4 +30,7 @@
 
     <!-- Maximum width for an attached image -->
     <int name="maxImageWidth">2592</int>
+
+    <!--function control for Telcel bug702045-->
+    <bool name="smsc_editable">false</bool>
 </mms_config>
Index: packages/inputmethods/LatinIME/java/src/com/android/inputmethod/latin/inputlogic/InputLogic.java
===================================================================
--- packages/inputmethods/LatinIME/java/src/com/android/inputmethod/latin/inputlogic/InputLogic.java	(revision 182200)
+++ packages/inputmethods/LatinIME/java/src/com/android/inputmethod/latin/inputlogic/InputLogic.java	(revision 182201)
@@ -192,7 +192,7 @@
             /* SPRD: bug597003, text has been deleted re-show after screen rotate @{ */
             final CharSequence textBeforeCursor =
                     mConnection.getTextBeforeCursor(Constants.EDITOR_CONTENTS_CACHE_SIZE, 0);
-            if (textBeforeCursor.length() == 0) {
+            if (textBeforeCursor != null && textBeforeCursor.length() == 0) {
                 mWordComposer.reset();
             }
             /* @} */
Index: packages/services/Telecomm/src/com/sprd/server/telecom/LocalToneHelper.java
===================================================================
--- packages/services/Telecomm/src/com/sprd/server/telecom/LocalToneHelper.java	(revision 0)
+++ packages/services/Telecomm/src/com/sprd/server/telecom/LocalToneHelper.java	(revision 182201)
@@ -0,0 +1,39 @@
+package com.sprd.server.telecom;
+
+import android.app.AddonManager;
+import android.content.Context;
+import android.util.Log;
+
+import com.android.server.telecom.CallAudioManager;
+import com.android.server.telecom.CallsManager;
+import com.android.server.telecom.CallsManagerListenerBase;
+import com.android.server.telecom.R;
+
+
+/**
+ * Local tone feature helper.
+ */
+public class LocalToneHelper extends CallsManagerListenerBase {
+    private static final String TAG = "LocalToneHelper";
+
+    static LocalToneHelper sInstance;
+
+    public static LocalToneHelper getInstance(Context context) {
+        if (sInstance == null) {
+            synchronized (LocalToneHelper.class) {
+                AddonManager addonManager = new AddonManager(context);
+                sInstance = (LocalToneHelper) addonManager.getAddon(
+                        R.string.telecom_local_tone_plugin, LocalToneHelper.class);
+            }
+        }
+        Log.d(TAG, "getInstance [" + sInstance + "]");
+        return sInstance;
+    }
+
+    public LocalToneHelper() {
+    }
+
+    public void init(Context context, CallsManager callsManager, CallAudioManager callAudioManager) {
+
+    }
+}
Index: packages/services/Telecomm/src/com/android/server/telecom/Log.java
===================================================================
--- packages/services/Telecomm/src/com/android/server/telecom/Log.java	(revision 182200)
+++ packages/services/Telecomm/src/com/android/server/telecom/Log.java	(revision 182201)
@@ -340,6 +340,7 @@
 
     public static final long DEFAULT_SESSION_TIMEOUT_MS = 30000L; // 30 seconds
     private static MessageDigest sMessageDigest;
+    private static final Object sMessageDigestLock = new Object();
 
     public static void initMd5Sum() {
         new AsyncTask<Void, Void, Void>() {
@@ -351,7 +352,9 @@
                 } catch (NoSuchAlgorithmException e) {
                     md = null;
                 }
-                sMessageDigest = md;
+                synchronized (sMessageDigestLock) {
+                    sMessageDigest = md;
+                }
                 return null;
             }
         }.execute();
@@ -821,13 +824,15 @@
     }
 
     private static String secureHash(byte[] input) {
-        if (sMessageDigest != null) {
-            sMessageDigest.reset();
-            sMessageDigest.update(input);
-            byte[] result = sMessageDigest.digest();
-            return encodeHex(result);
-        } else {
-            return "Uninitialized SHA1";
+        synchronized (sMessageDigestLock) {
+            if (sMessageDigest != null) {
+                sMessageDigest.reset();
+                sMessageDigest.update(input);
+                byte[] result = sMessageDigest.digest();
+                return encodeHex(result);
+            } else {
+                return "Uninitialized SHA1";
+            }
         }
     }
 
Index: packages/services/Telecomm/src/com/android/server/telecom/Call.java
===================================================================
--- packages/services/Telecomm/src/com/android/server/telecom/Call.java	(revision 182200)
+++ packages/services/Telecomm/src/com/android/server/telecom/Call.java	(revision 182201)
@@ -1065,7 +1065,10 @@
         service.incrementAssociatedCallCount();
         mConnectionService = service;
         mAnalytics.setCallConnectionService(service.getComponentName().flattenToShortString());
-        mConnectionService.addCall(this);
+        // SPRD: Add NullPointerException fix for 687060
+        if (mConnectionService != null) {
+            mConnectionService.addCall(this);
+        }
     }
 
     /**
Index: packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java
===================================================================
--- packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java	(revision 182200)
+++ packages/services/Telecomm/src/com/android/server/telecom/CallsManager.java	(revision 182201)
@@ -50,6 +50,7 @@
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
 import com.sprd.server.telecom.BlockIncomingCallNotifierUtils;
+import com.sprd.server.telecom.LocalToneHelper;
 import com.sprd.server.telecom.TelecomCmccHelper;
 import android.content.SharedPreferences;
 import android.content.pm.PackageManager.NameNotFoundException;
@@ -333,9 +334,11 @@
         PickUpToAnswerIncomingCallHelper.getInstance(context).init(context,this);
         // SPRD: Flip to mute for incoming call.
         FlipToMuteHelper.getInstance(context).init(context,this,mCallAudioManager);
-        UnholdToCallWithHangedupHelp.getInstance(context).init(context,this);
         // SPRD: Support Telcel Operator requirement
         mTelcelCallWaitingToneHelper = TelcelCallWaitingToneHelper.getInstance(context);
+        UnholdToCallWithHangedupHelp.getInstance(context).init(context,this);
+        // SPRD: Local Tone Feature.
+        LocalToneHelper.getInstance(context).init(context, this, mCallAudioManager);
     }
 
     public void setRespondViaSmsManager(RespondViaSmsManager respondViaSmsManager) {
@@ -1259,7 +1262,20 @@
         if (!mCalls.contains(call)) {
             Log.w(this, "Unknown call (%s) asked to disconnect", call);
         } else {
-            mLocallyDisconnectingCalls.add(call);
+            /* SPRD: Add for 737457
+             * @orig
+             * mLocallyDisconnectingCalls.add(call); @{ */
+            boolean shouldResumeHoldCall = true;
+            if (call.getParentCall() != null) {
+                if (!noConferenceCall()) {
+                    shouldResumeHoldCall = false;
+                }
+            }
+
+            if (shouldResumeHoldCall) {
+                mLocallyDisconnectingCalls.add(call);
+            }
+            /* @} */
             call.disconnect();
         }
     }
@@ -2386,4 +2402,14 @@
             }
         };
     };
+	
+    //SPRD: add for bug737457
+    private boolean noConferenceCall () {
+        for (Call c : mCalls) {
+            if (!c.isConference() && c.getParentCall() == null) {
+                return true;
+            }
+        }
+        return false;
+    }
 }
Index: packages/services/Telecomm/res/values/config_ex.xml
===================================================================
--- packages/services/Telecomm/res/values/config_ex.xml	(revision 182200)
+++ packages/services/Telecomm/res/values/config_ex.xml	(revision 182201)
@@ -35,4 +35,7 @@
     <string name="unhold_to_call_with_hangedup_plugin_name" translatable="false">
         plugin.sprd.unHoldToCallWithHangedup.UnholdToCallWithHangedupHelpPlugin
     </string>
+    <string name="telecom_local_tone_plugin">
+        com.sprd.telecom.localTonePlugin.LocalTonePlugin
+    </string>
 </resources>
Index: packages/services/Telephony/src/com/android/services/telephony/TelephonyConnection.java
===================================================================
--- packages/services/Telephony/src/com/android/services/telephony/TelephonyConnection.java	(revision 182200)
+++ packages/services/Telephony/src/com/android/services/telephony/TelephonyConnection.java	(revision 182201)
@@ -17,6 +17,7 @@
 package com.android.services.telephony;
 
 import android.content.Context;
+import android.content.Intent;
 import android.graphics.drawable.Icon;
 import android.net.Uri;
 import android.os.AsyncResult;
@@ -65,6 +66,9 @@
     private static final int MSG_MULTIPARTY_STATE_CHANGED = 5;
     private static final int MSG_CONFERENCE_MERGE_FAILED = 6;
     private static final int MSG_SUPP_SERVICE_NOTIFY = 7;
+    // SPRD: Local Tone Feature.
+    private static final String ACTION_MT_CONFERENCE_NOTIFICATION =
+            "com.android.ACTION_MT_CONFERENCE_NOTIFICATION";
 
     /**
      * Mappings from {@link com.android.internal.telephony.Connection} extras keys to their
@@ -136,7 +140,7 @@
                     break;
                 case MSG_SUPP_SERVICE_NOTIFY:
                     Log.v(TelephonyConnection.this, "MSG_SUPP_SERVICE_NOTIFY on phoneId : "
-                            +getPhone().getPhoneId());
+                            + (getPhone() != null ? getPhone().getPhoneId() : null));
                     SuppServiceNotification mSsNotification = null;
                     if (msg.obj != null && ((AsyncResult) msg.obj).result != null) {
                         mSsNotification =
@@ -671,6 +675,17 @@
 
         if (getConnectionProperties() != newProperties) {
             setConnectionProperties(newProperties);
+            /* SPRD: Local Tone Feature. @{ */
+            if (mIsMTConference) {
+                Intent intent = new Intent();
+                intent.setAction(ACTION_MT_CONFERENCE_NOTIFICATION);
+                Phone phone = getPhone();
+                if (phone != null) {
+                    phone.getContext().sendBroadcast(intent);
+                }
+
+            }
+            /* @} */
         }
     }
 
Index: packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java
===================================================================
--- packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java	(revision 182200)
+++ packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java	(revision 182201)
@@ -32,7 +32,9 @@
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
+import android.database.ContentObserver;
 import android.os.Bundle;
+import android.os.Handler;
 import android.os.PersistableBundle;
 import android.os.RemoteException;
 import android.os.SystemProperties;
@@ -68,6 +70,7 @@
 import com.android.phone.settings.PhoneAccountSettingsFragment;
 import com.android.phone.settings.VoicemailSettingsActivity;
 import com.android.services.telephony.sip.SipUtil;
+
 import com.sprd.settings.ActivityContainer;
 import android.content.SharedPreferences;
 import android.preference.PreferenceManager;
@@ -148,6 +151,7 @@
     private static final String HEADSET_AUTO_ANSWER_NAME="headset_auto_answer_name";
     private SharedPreferences mSharedPrefs;
 
+    private static final String TAG = "CallFeaturesSettings";
     /*
      * Click Listeners, handle click based on objects attached to UI.
      */
@@ -494,8 +498,53 @@
             }
         }
         /* @} */
+        if (getBaseContext() != null) {
+            getBaseContext().getContentResolver().registerContentObserver(
+                    Settings.Global.getUriFor(Settings.Global.WFC_IMS_ENABLED), true,
+                    mWfcEnableObserver);
+        }
     }
 
+    private ContentObserver mWfcEnableObserver = new ContentObserver(new Handler()) {
+        @Override
+        public void onChange(boolean selfChange) {
+            if (getBaseContext() == null) {
+                return;
+            }
+            boolean enabled = ImsManager.isWfcEnabledByUser(getBaseContext())
+                    && ImsManager.isNonTtyOrTtyOnVolteEnabled(getBaseContext());
+            Log.d(TAG,"[mWfcEnableObserver][wfcEnabled]: " + enabled);
+            // update WFC setting
+            PreferenceScreen ps = (PreferenceScreen) findPreference(
+                    getResources().getString(R.string.wifi_calling_settings_key));
+            Log.d(TAG,"[mWfcEnableObserver][ps]: " + ps);
+            if (ps != null) {
+                int resId = com.android.internal.R.string.wifi_calling_off_summary;
+                if (ImsManager.isWfcEnabledByUser(getBaseContext())) {
+                    int wfcMode = ImsManager.getWfcMode(getBaseContext());
+                    switch (wfcMode) {
+                        case ImsConfig.WfcModeFeatureValueConstants.WIFI_ONLY:
+                            resId = com.android.internal.R.string.wfc_mode_wifi_only_summary;
+                            break;
+                        case ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED:
+                            resId = com.android.internal.R.string
+                                                    .wfc_mode_cellular_preferred_summary;
+                            break;
+                        case ImsConfig.WfcModeFeatureValueConstants.WIFI_PREFERRED:
+                            resId = com.android.internal.R.string.wfc_mode_wifi_preferred_summary;
+                            break;
+                        case ImsConfig.WfcModeFeatureValueConstants.LTE_ONLY:
+                            resId = com.android.internal.R.string.wfc_mode_lte_only_summary;
+                            break;
+                        default:
+                            if (DBG) log("Unexpected WFC mode value: " + wfcMode);
+                    }
+                }
+                ps.setSummary(resId);
+            }
+         }
+    };
+
     /* SPRD: add for bug621437 @{ */
     protected void onPause() {
         super.onPause();
@@ -504,6 +553,9 @@
             mTelephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_NONE);
             isStateListenerRegistered = false;
         }
+        if (getBaseContext() != null) {
+            getBaseContext().getContentResolver().unregisterContentObserver(mWfcEnableObserver);
+        }
     }
     /* @} */
 
Index: packages/providers/MediaProvider/src/com/android/providers/media/MediaProvider.java
===================================================================
--- packages/providers/MediaProvider/src/com/android/providers/media/MediaProvider.java	(revision 182200)
+++ packages/providers/MediaProvider/src/com/android/providers/media/MediaProvider.java	(revision 182201)
@@ -17,6 +17,7 @@
 package com.android.providers.media;
 
 import static android.Manifest.permission.ACCESS_CACHE_FILESYSTEM;
+import static android.Manifest.permission.INTERACT_ACROSS_USERS;
 import static android.Manifest.permission.READ_EXTERNAL_STORAGE;
 import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
 import static android.Manifest.permission.WRITE_MEDIA_STORAGE;
@@ -42,6 +43,7 @@
 import android.content.UriMatcher;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.pm.UserInfo;
 import android.content.res.Resources;
 import android.database.Cursor;
 import android.database.DatabaseUtils;
@@ -61,6 +63,7 @@
 import android.os.Binder;
 import android.os.Bundle;
 import android.os.Environment;
+import android.os.FileUtils;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Message;
@@ -68,6 +71,8 @@
 import android.os.Process;
 import android.os.RemoteException;
 import android.os.SystemClock;
+import android.os.UserHandle;
+import android.os.UserManager;
 import android.os.storage.StorageManager;
 import android.os.storage.StorageVolume;
 import android.os.storage.VolumeInfo;
@@ -136,7 +141,6 @@
 
     private void updateStoragePaths() {
         mExternalStoragePaths = mStorageManager.getVolumePaths();
-
         try {
             mExternalPath =
                     Environment.getExternalStorageDirectory().getCanonicalPath() + File.separator;
@@ -5000,10 +5004,47 @@
             // don't write to non-cache, non-sdcard files.
             throw new FileNotFoundException("Can't access " + file);
         } else {
+            boolean hasWriteMediaStorage = c.checkCallingOrSelfPermission(WRITE_MEDIA_STORAGE)
+                    == PackageManager.PERMISSION_GRANTED;
+            boolean hasInteractAcrossUsers = c.checkCallingOrSelfPermission(INTERACT_ACROSS_USERS)
+                    == PackageManager.PERMISSION_GRANTED;
+            if (!hasWriteMediaStorage && !hasInteractAcrossUsers && isOtherUserExternalDir(path)) {
+                throw new FileNotFoundException("Can't access across users " + file);
+            }
             checkWorldReadAccess(path);
         }
     }
 
+    private boolean isOtherUserExternalDir(String path) {
+        List<VolumeInfo> volumes = mStorageManager.getVolumes();
+        for (VolumeInfo volume : volumes) {
+            if (contains(volume.path, path)) {
+                // If any of mExternalStoragePaths belongs to this volume and doesn't contain
+                // the path, then we consider the path to be from another user
+                for (String externalStoragePath : mExternalStoragePaths) {
+                    if (contains(volume.path, externalStoragePath)
+                            && !contains(externalStoragePath, path)) {
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    private static boolean contains(String dirPath, String filePath) {
+        if (dirPath== null || filePath == null) return false;
+
+        if (dirPath.equals(filePath)) {
+            return true;
+        }
+
+        if (!dirPath.endsWith("/")) {
+            dirPath += "/";
+        }
+        return filePath.startsWith(dirPath);
+    }
+
     private boolean isSecondaryExternalPath(String path) {
         for (int i = 1; i < mExternalStoragePaths.length; i++) {
             if (path.startsWith(mExternalStoragePaths[i])) {
Index: packages/providers/DownloadProvider/src/com/android/providers/downloads/DownloadProvider.java
===================================================================
--- packages/providers/DownloadProvider/src/com/android/providers/downloads/DownloadProvider.java	(revision 182200)
+++ packages/providers/DownloadProvider/src/com/android/providers/downloads/DownloadProvider.java	(revision 182201)
@@ -473,17 +473,42 @@
         final SQLiteDatabase db = mOpenHelper.getReadableDatabase();
         final Cursor cursor = db.query(DB_TABLE, new String[] {
                 Downloads.Impl._ID, Constants.UID }, null, null, null, null, null);
+        final ArrayList<Long> idsToDelete = new ArrayList<>();
         try {
             while (cursor.moveToNext()) {
-                grantAllDownloadsPermission(cursor.getLong(0), cursor.getInt(1));
+                final long downloadId = cursor.getLong(0);
+                final int uid = cursor.getInt(1);
+                final String ownerPackage = getPackageForUid(uid);
+                if (ownerPackage == null) {
+                    idsToDelete.add(downloadId);
+                } else {
+                    grantAllDownloadsPermission(ownerPackage, downloadId);
+                }
             }
         } finally {
             cursor.close();
         }
-
+        if (idsToDelete.size() > 0) {
+            Log.i(Constants.TAG,
+                    "Deleting downloads with ids " + idsToDelete + " as owner package is missing");
+            deleteDownloadsWithIds(idsToDelete);
+        }
         return true;
     }
 
+    private void deleteDownloadsWithIds(ArrayList<Long> downloadIds) {
+        final int N = downloadIds.size();
+        if (N == 0) {
+            return;
+        }
+        final StringBuilder queryBuilder = new StringBuilder(Downloads.Impl._ID + " in (");
+        for (int i = 0; i < N; i++) {
+            queryBuilder.append(downloadIds.get(i));
+            queryBuilder.append((i == N - 1) ? ")" : ",");
+        }
+        delete(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, queryBuilder.toString(), null);
+    }
+
     /**
      * Returns the content-provider-style MIME types of the various
      * types accessible through this content provider.
@@ -703,7 +728,13 @@
         }
 
         insertRequestHeaders(db, rowID, values);
-        grantAllDownloadsPermission(rowID, Binder.getCallingUid());
+
+        final String callingPackage = getPackageForUid(Binder.getCallingUid());
+        if (callingPackage == null) {
+            Log.e(Constants.TAG, "Package does not exist for calling uid");
+            return null;
+        }
+        grantAllDownloadsPermission(callingPackage, rowID);
         notifyContentChanged(uri, match);
 
         final long token = Binder.clearCallingIdentity();
@@ -722,6 +753,15 @@
         return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);
     }
 
+    private String getPackageForUid(int uid) {
+        String[] packages = getContext().getPackageManager().getPackagesForUid(uid);
+        if (packages == null || packages.length == 0) {
+            return null;
+        }
+        // For permission related purposes, any package belonging to the given uid should work.
+        return packages[0];
+    }
+
     /**
      * Check that the file URI provided for DESTINATION_FILE_URI is valid.
      */
@@ -1486,14 +1526,9 @@
         }
     }
 
-    private void grantAllDownloadsPermission(long id, int uid) {
-        final String[] packageNames = getContext().getPackageManager().getPackagesForUid(uid);
-        if (packageNames == null || packageNames.length == 0) return;
-
-        // We only need to grant to the first package, since the
-        // platform internally tracks based on UIDs
+    private void grantAllDownloadsPermission(String toPackage, long id) {
         final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);
-        getContext().grantUriPermission(packageNames[0], uri,
+        getContext().grantUriPermission(toPackage, uri,
                 Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
     }
 
