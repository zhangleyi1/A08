Index: kernel/sound/core/pcm_lib.c
===================================================================
--- kernel/sound/core/pcm_lib.c	(revision 182304)
+++ kernel/sound/core/pcm_lib.c	(revision 182305)
@@ -0,0 +1,2604 @@
+/*
+ *  Digital Audio (PCM) abstract layer
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
+ *                   Abramo Bagnara <abramo@alsa-project.org>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/math64.h>
+#include <linux/export.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/tlv.h>
+#include <sound/info.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/timer.h>
+#include <sound/sprd_memcpy_ops.h>
+
+/*
+ * fill ring buffer with silence
+ * runtime->silence_start: starting pointer to silence area
+ * runtime->silence_filled: size filled with silence
+ * runtime->silence_threshold: threshold from application
+ * runtime->silence_size: maximal size from application
+ *
+ * when runtime->silence_size >= runtime->boundary - fill processed area with silence immediately
+ */
+void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_uframes_t new_hw_ptr)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	snd_pcm_uframes_t frames, ofs, transfer;
+
+	if (runtime->silence_size < runtime->boundary) {
+		snd_pcm_sframes_t noise_dist, n;
+		if (runtime->silence_start != runtime->control->appl_ptr) {
+			n = runtime->control->appl_ptr - runtime->silence_start;
+			if (n < 0)
+				n += runtime->boundary;
+			if ((snd_pcm_uframes_t)n < runtime->silence_filled)
+				runtime->silence_filled -= n;
+			else
+				runtime->silence_filled = 0;
+			runtime->silence_start = runtime->control->appl_ptr;
+		}
+		if (runtime->silence_filled >= runtime->buffer_size)
+			return;
+		noise_dist = snd_pcm_playback_hw_avail(runtime) + runtime->silence_filled;
+		if (noise_dist >= (snd_pcm_sframes_t) runtime->silence_threshold)
+			return;
+		frames = runtime->silence_threshold - noise_dist;
+		if (frames > runtime->silence_size)
+			frames = runtime->silence_size;
+	} else {
+		if (new_hw_ptr == ULONG_MAX) {	/* initialization */
+			snd_pcm_sframes_t avail = snd_pcm_playback_hw_avail(runtime);
+			if (avail > runtime->buffer_size)
+				avail = runtime->buffer_size;
+			runtime->silence_filled = avail > 0 ? avail : 0;
+			runtime->silence_start = (runtime->status->hw_ptr +
+						  runtime->silence_filled) %
+						 runtime->boundary;
+		} else {
+			ofs = runtime->status->hw_ptr;
+			frames = new_hw_ptr - ofs;
+			if ((snd_pcm_sframes_t)frames < 0)
+				frames += runtime->boundary;
+			runtime->silence_filled -= frames;
+			if ((snd_pcm_sframes_t)runtime->silence_filled < 0) {
+				runtime->silence_filled = 0;
+				runtime->silence_start = new_hw_ptr;
+			} else {
+				runtime->silence_start = ofs;
+			}
+		}
+		frames = runtime->buffer_size - runtime->silence_filled;
+	}
+	if (snd_BUG_ON(frames > runtime->buffer_size))
+		return;
+	if (frames == 0)
+		return;
+	ofs = runtime->silence_start % runtime->buffer_size;
+	while (frames > 0) {
+		transfer = ofs + frames > runtime->buffer_size ? runtime->buffer_size - ofs : frames;
+		if (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED ||
+		    runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {
+			if (substream->ops->silence) {
+				int err;
+				err = substream->ops->silence(substream, -1, ofs, transfer);
+				snd_BUG_ON(err < 0);
+			} else {
+				char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, ofs);
+				snd_pcm_format_set_silence(runtime->format, hwbuf, transfer * runtime->channels);
+			}
+		} else {
+			unsigned int c;
+			unsigned int channels = runtime->channels;
+			if (substream->ops->silence) {
+				for (c = 0; c < channels; ++c) {
+					int err;
+					err = substream->ops->silence(substream, c, ofs, transfer);
+					snd_BUG_ON(err < 0);
+				}
+			} else {
+				size_t dma_csize = runtime->dma_bytes / channels;
+				for (c = 0; c < channels; ++c) {
+					char *hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, ofs);
+					snd_pcm_format_set_silence(runtime->format, hwbuf, transfer);
+				}
+			}
+		}
+		runtime->silence_filled += transfer;
+		frames -= transfer;
+		ofs = 0;
+	}
+}
+
+#ifdef CONFIG_SND_DEBUG
+void snd_pcm_debug_name(struct snd_pcm_substream *substream,
+			   char *name, size_t len)
+{
+	snprintf(name, len, "pcmC%dD%d%c:%d",
+		 substream->pcm->card->number,
+		 substream->pcm->device,
+		 substream->stream ? 'c' : 'p',
+		 substream->number);
+}
+EXPORT_SYMBOL(snd_pcm_debug_name);
+#endif
+
+#define XRUN_DEBUG_BASIC	(1<<0)
+#define XRUN_DEBUG_STACK	(1<<1)	/* dump also stack */
+#define XRUN_DEBUG_JIFFIESCHECK	(1<<2)	/* do jiffies check */
+#define XRUN_DEBUG_PERIODUPDATE	(1<<3)	/* full period update info */
+#define XRUN_DEBUG_HWPTRUPDATE	(1<<4)	/* full hwptr update info */
+#define XRUN_DEBUG_LOG		(1<<5)	/* show last 10 positions on err */
+#define XRUN_DEBUG_LOGONCE	(1<<6)	/* do above only once */
+
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
+
+#define xrun_debug(substream, mask) \
+			((substream)->pstr->xrun_debug & (mask))
+#else
+#define xrun_debug(substream, mask)	0
+#endif
+
+#define dump_stack_on_xrun(substream) do {			\
+		if (xrun_debug(substream, XRUN_DEBUG_STACK))	\
+			dump_stack();				\
+	} while (0)
+
+static void xrun(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
+		snd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);
+	snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
+	if (xrun_debug(substream, XRUN_DEBUG_BASIC)) {
+		char name[16];
+		snd_pcm_debug_name(substream, name, sizeof(name));
+		snd_printd(KERN_DEBUG "XRUN: %s\n", name);
+		dump_stack_on_xrun(substream);
+	}
+}
+
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
+#define hw_ptr_error(substream, fmt, args...)				\
+	do {								\
+		if (xrun_debug(substream, XRUN_DEBUG_BASIC)) {		\
+			xrun_log_show(substream);			\
+			if (printk_ratelimit()) {			\
+				snd_printd("PCM: " fmt, ##args);	\
+			}						\
+			dump_stack_on_xrun(substream);			\
+		}							\
+	} while (0)
+
+#define XRUN_LOG_CNT	10
+
+struct hwptr_log_entry {
+	unsigned int in_interrupt;
+	unsigned long jiffies;
+	snd_pcm_uframes_t pos;
+	snd_pcm_uframes_t period_size;
+	snd_pcm_uframes_t buffer_size;
+	snd_pcm_uframes_t old_hw_ptr;
+	snd_pcm_uframes_t hw_ptr_base;
+};
+
+struct snd_pcm_hwptr_log {
+	unsigned int idx;
+	unsigned int hit: 1;
+	struct hwptr_log_entry entries[XRUN_LOG_CNT];
+};
+
+static void xrun_log(struct snd_pcm_substream *substream,
+		     snd_pcm_uframes_t pos, int in_interrupt)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_pcm_hwptr_log *log = runtime->hwptr_log;
+	struct hwptr_log_entry *entry;
+
+	if (log == NULL) {
+		log = kzalloc(sizeof(*log), GFP_ATOMIC);
+		if (log == NULL)
+			return;
+		runtime->hwptr_log = log;
+	} else {
+		if (xrun_debug(substream, XRUN_DEBUG_LOGONCE) && log->hit)
+			return;
+	}
+	entry = &log->entries[log->idx];
+	entry->in_interrupt = in_interrupt;
+	entry->jiffies = jiffies;
+	entry->pos = pos;
+	entry->period_size = runtime->period_size;
+	entry->buffer_size = runtime->buffer_size;
+	entry->old_hw_ptr = runtime->status->hw_ptr;
+	entry->hw_ptr_base = runtime->hw_ptr_base;
+	log->idx = (log->idx + 1) % XRUN_LOG_CNT;
+}
+
+static void xrun_log_show(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_hwptr_log *log = substream->runtime->hwptr_log;
+	struct hwptr_log_entry *entry;
+	char name[16];
+	unsigned int idx;
+	int cnt;
+
+	if (log == NULL)
+		return;
+	if (xrun_debug(substream, XRUN_DEBUG_LOGONCE) && log->hit)
+		return;
+	snd_pcm_debug_name(substream, name, sizeof(name));
+	for (cnt = 0, idx = log->idx; cnt < XRUN_LOG_CNT; cnt++) {
+		entry = &log->entries[idx];
+		if (entry->period_size == 0)
+			break;
+		snd_printd("hwptr log: %s: %sj=%lu, pos=%ld/%ld/%ld, "
+			   "hwptr=%ld/%ld\n",
+			   name, entry->in_interrupt ? "[Q] " : "",
+			   entry->jiffies,
+			   (unsigned long)entry->pos,
+			   (unsigned long)entry->period_size,
+			   (unsigned long)entry->buffer_size,
+			   (unsigned long)entry->old_hw_ptr,
+			   (unsigned long)entry->hw_ptr_base);
+		idx++;
+		idx %= XRUN_LOG_CNT;
+	}
+	log->hit = 1;
+}
+
+#else /* ! CONFIG_SND_PCM_XRUN_DEBUG */
+
+#define hw_ptr_error(substream, fmt, args...) do { } while (0)
+#define xrun_log(substream, pos, in_interrupt)	do { } while (0)
+#define xrun_log_show(substream)	do { } while (0)
+
+#endif
+
+int snd_pcm_update_state(struct snd_pcm_substream *substream,
+			 struct snd_pcm_runtime *runtime)
+{
+	snd_pcm_uframes_t avail;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		avail = snd_pcm_playback_avail(runtime);
+	else
+		avail = snd_pcm_capture_avail(runtime);
+	if (avail > runtime->avail_max)
+		runtime->avail_max = avail;
+	if (runtime->status->state == SNDRV_PCM_STATE_DRAINING) {
+		if (avail >= runtime->buffer_size) {
+			snd_pcm_drain_done(substream);
+			return -EPIPE;
+		}
+	} else {
+		if (avail >= runtime->stop_threshold) {
+			xrun(substream);
+			return -EPIPE;
+		}
+	}
+	if (runtime->twake) {
+		if (avail >= runtime->twake)
+			wake_up(&runtime->tsleep);
+	} else if (avail >= runtime->control->avail_min)
+		wake_up(&runtime->sleep);
+	return 0;
+}
+
+static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
+				  unsigned int in_interrupt)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	snd_pcm_uframes_t pos;
+	snd_pcm_uframes_t old_hw_ptr, new_hw_ptr, hw_base;
+	snd_pcm_sframes_t hdelta, delta;
+	unsigned long jdelta;
+	unsigned long curr_jiffies;
+	struct timespec curr_tstamp;
+	struct timespec audio_tstamp;
+	int crossed_boundary = 0;
+
+	old_hw_ptr = runtime->status->hw_ptr;
+
+	/*
+	 * group pointer, time and jiffies reads to allow for more
+	 * accurate correlations/corrections.
+	 * The values are stored at the end of this routine after
+	 * corrections for hw_ptr position
+	 */
+	pos = substream->ops->pointer(substream);
+	curr_jiffies = jiffies;
+	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE) {
+		snd_pcm_gettime(runtime, (struct timespec *)&curr_tstamp);
+
+		if ((runtime->hw.info & SNDRV_PCM_INFO_HAS_WALL_CLOCK) &&
+			(substream->ops->wall_clock))
+			substream->ops->wall_clock(substream, &audio_tstamp);
+	}
+
+	if (pos == SNDRV_PCM_POS_XRUN) {
+		xrun(substream);
+		return -EPIPE;
+	}
+	if (pos >= runtime->buffer_size) {
+		if (printk_ratelimit()) {
+			char name[16];
+			snd_pcm_debug_name(substream, name, sizeof(name));
+			xrun_log_show(substream);
+			snd_printd(KERN_ERR  "BUG: %s, pos = %ld, "
+				   "buffer size = %ld, period size = %ld\n",
+				   name, pos, runtime->buffer_size,
+				   runtime->period_size);
+		}
+		pos = 0;
+	}
+	pos -= pos % runtime->min_align;
+	if (xrun_debug(substream, XRUN_DEBUG_LOG))
+		xrun_log(substream, pos, in_interrupt);
+	hw_base = runtime->hw_ptr_base;
+	new_hw_ptr = hw_base + pos;
+	if (in_interrupt) {
+		/* we know that one period was processed */
+		/* delta = "expected next hw_ptr" for in_interrupt != 0 */
+		delta = runtime->hw_ptr_interrupt + runtime->period_size;
+		if (delta > new_hw_ptr) {
+			/* check for double acknowledged interrupts */
+			hdelta = curr_jiffies - runtime->hw_ptr_jiffies;
+			if (hdelta > runtime->hw_ptr_buffer_jiffies/2) {
+				hw_base += runtime->buffer_size;
+				if (hw_base >= runtime->boundary) {
+					hw_base = 0;
+					crossed_boundary++;
+				}
+				new_hw_ptr = hw_base + pos;
+				goto __delta;
+			}
+		}
+	}
+	/* new_hw_ptr might be lower than old_hw_ptr in case when */
+	/* pointer crosses the end of the ring buffer */
+	if (new_hw_ptr < old_hw_ptr) {
+		hw_base += runtime->buffer_size;
+		if (hw_base >= runtime->boundary) {
+			hw_base = 0;
+			crossed_boundary++;
+		}
+		new_hw_ptr = hw_base + pos;
+	}
+      __delta:
+	delta = new_hw_ptr - old_hw_ptr;
+	if (delta < 0)
+		delta += runtime->boundary;
+	if (xrun_debug(substream, in_interrupt ?
+			XRUN_DEBUG_PERIODUPDATE : XRUN_DEBUG_HWPTRUPDATE)) {
+		char name[16];
+		snd_pcm_debug_name(substream, name, sizeof(name));
+		snd_printd("%s_update: %s: pos=%u/%u/%u, "
+			   "hwptr=%ld/%ld/%ld/%ld\n",
+			   in_interrupt ? "period" : "hwptr",
+			   name,
+			   (unsigned int)pos,
+			   (unsigned int)runtime->period_size,
+			   (unsigned int)runtime->buffer_size,
+			   (unsigned long)delta,
+			   (unsigned long)old_hw_ptr,
+			   (unsigned long)new_hw_ptr,
+			   (unsigned long)runtime->hw_ptr_base);
+	}
+
+	if (runtime->no_period_wakeup) {
+		snd_pcm_sframes_t xrun_threshold;
+		/*
+		 * Without regular period interrupts, we have to check
+		 * the elapsed time to detect xruns.
+		 */
+		jdelta = curr_jiffies - runtime->hw_ptr_jiffies;
+		if (jdelta < runtime->hw_ptr_buffer_jiffies / 2)
+			goto no_delta_check;
+		hdelta = jdelta - delta * HZ / runtime->rate;
+		xrun_threshold = runtime->hw_ptr_buffer_jiffies / 2 + 1;
+		while (hdelta > xrun_threshold) {
+			delta += runtime->buffer_size;
+			hw_base += runtime->buffer_size;
+			if (hw_base >= runtime->boundary) {
+				hw_base = 0;
+				crossed_boundary++;
+			}
+			new_hw_ptr = hw_base + pos;
+			hdelta -= runtime->hw_ptr_buffer_jiffies;
+		}
+		goto no_delta_check;
+	}
+
+	/* something must be really wrong */
+	if (delta >= runtime->buffer_size + runtime->period_size) {
+		hw_ptr_error(substream,
+			       "Unexpected hw_pointer value %s"
+			       "(stream=%i, pos=%ld, new_hw_ptr=%ld, "
+			       "old_hw_ptr=%ld)\n",
+				     in_interrupt ? "[Q] " : "[P]",
+				     substream->stream, (long)pos,
+				     (long)new_hw_ptr, (long)old_hw_ptr);
+		return 0;
+	}
+
+	/* Do jiffies check only in xrun_debug mode */
+	if (!xrun_debug(substream, XRUN_DEBUG_JIFFIESCHECK))
+		goto no_jiffies_check;
+
+	/* Skip the jiffies check for hardwares with BATCH flag.
+	 * Such hardware usually just increases the position at each IRQ,
+	 * thus it can't give any strange position.
+	 */
+	if (runtime->hw.info & SNDRV_PCM_INFO_BATCH)
+		goto no_jiffies_check;
+	hdelta = delta;
+	if (hdelta < runtime->delay)
+		goto no_jiffies_check;
+	hdelta -= runtime->delay;
+	jdelta = curr_jiffies - runtime->hw_ptr_jiffies;
+	if (((hdelta * HZ) / runtime->rate) > jdelta + HZ/100) {
+		delta = jdelta /
+			(((runtime->period_size * HZ) / runtime->rate)
+								+ HZ/100);
+		/* move new_hw_ptr according jiffies not pos variable */
+		new_hw_ptr = old_hw_ptr;
+		hw_base = delta;
+		/* use loop to avoid checks for delta overflows */
+		/* the delta value is small or zero in most cases */
+		while (delta > 0) {
+			new_hw_ptr += runtime->period_size;
+			if (new_hw_ptr >= runtime->boundary) {
+				new_hw_ptr -= runtime->boundary;
+				crossed_boundary--;
+			}
+			delta--;
+		}
+		/* align hw_base to buffer_size */
+		hw_ptr_error(substream,
+			     "hw_ptr skipping! %s"
+			     "(pos=%ld, delta=%ld, period=%ld, "
+			     "jdelta=%lu/%lu/%lu, hw_ptr=%ld/%ld)\n",
+			     in_interrupt ? "[Q] " : "",
+			     (long)pos, (long)hdelta,
+			     (long)runtime->period_size, jdelta,
+			     ((hdelta * HZ) / runtime->rate), hw_base,
+			     (unsigned long)old_hw_ptr,
+			     (unsigned long)new_hw_ptr);
+		/* reset values to proper state */
+		delta = 0;
+		hw_base = new_hw_ptr - (new_hw_ptr % runtime->buffer_size);
+	}
+ no_jiffies_check:
+	if (delta > runtime->period_size + runtime->period_size / 2) {
+		hw_ptr_error(substream,
+			     "Lost interrupts? %s"
+			     "(stream=%i, delta=%ld, new_hw_ptr=%ld, "
+			     "old_hw_ptr=%ld)\n",
+			     in_interrupt ? "[Q] " : "",
+			     substream->stream, (long)delta,
+			     (long)new_hw_ptr,
+			     (long)old_hw_ptr);
+	}
+
+ no_delta_check:
+	if (runtime->status->hw_ptr == new_hw_ptr)
+		return 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
+	    runtime->silence_size > 0)
+		snd_pcm_playback_silence(substream, new_hw_ptr);
+
+	if (in_interrupt) {
+		delta = new_hw_ptr - runtime->hw_ptr_interrupt;
+		if (delta < 0)
+			delta += runtime->boundary;
+		delta -= (snd_pcm_uframes_t)delta % runtime->period_size;
+		runtime->hw_ptr_interrupt += delta;
+		if (runtime->hw_ptr_interrupt >= runtime->boundary)
+			runtime->hw_ptr_interrupt -= runtime->boundary;
+	}
+	runtime->hw_ptr_base = hw_base;
+	runtime->status->hw_ptr = new_hw_ptr;
+	runtime->hw_ptr_jiffies = curr_jiffies;
+	if (crossed_boundary) {
+		snd_BUG_ON(crossed_boundary != 1);
+		runtime->hw_ptr_wrap += runtime->boundary;
+	}
+	if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE) {
+		runtime->status->tstamp = curr_tstamp;
+
+		if (!(runtime->hw.info & SNDRV_PCM_INFO_HAS_WALL_CLOCK)) {
+			/*
+			 * no wall clock available, provide audio timestamp
+			 * derived from pointer position+delay
+			 */
+			u64 audio_frames, audio_nsecs;
+
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				audio_frames = runtime->hw_ptr_wrap
+					+ runtime->status->hw_ptr
+					- runtime->delay;
+			else
+				audio_frames = runtime->hw_ptr_wrap
+					+ runtime->status->hw_ptr
+					+ runtime->delay;
+			audio_nsecs = div_u64(audio_frames * 1000000000LL,
+					runtime->rate);
+			audio_tstamp = ns_to_timespec(audio_nsecs);
+		}
+		runtime->status->audio_tstamp = audio_tstamp;
+	}
+
+	return snd_pcm_update_state(substream, runtime);
+}
+
+/* CAUTION: call it with irq disabled */
+int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_update_hw_ptr0(substream, 0);
+}
+
+/**
+ * snd_pcm_set_ops - set the PCM operators
+ * @pcm: the pcm instance
+ * @direction: stream direction, SNDRV_PCM_STREAM_XXX
+ * @ops: the operator table
+ *
+ * Sets the given PCM operators to the pcm instance.
+ */
+void snd_pcm_set_ops(struct snd_pcm *pcm, int direction, struct snd_pcm_ops *ops)
+{
+	struct snd_pcm_str *stream = &pcm->streams[direction];
+	struct snd_pcm_substream *substream;
+	
+	for (substream = stream->substream; substream != NULL; substream = substream->next)
+		substream->ops = ops;
+}
+
+EXPORT_SYMBOL(snd_pcm_set_ops);
+
+/**
+ * snd_pcm_sync - set the PCM sync id
+ * @substream: the pcm substream
+ *
+ * Sets the PCM sync identifier for the card.
+ */
+void snd_pcm_set_sync(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	
+	runtime->sync.id32[0] = substream->pcm->card->number;
+	runtime->sync.id32[1] = -1;
+	runtime->sync.id32[2] = -1;
+	runtime->sync.id32[3] = -1;
+}
+
+EXPORT_SYMBOL(snd_pcm_set_sync);
+
+/*
+ *  Standard ioctl routine
+ */
+
+static inline unsigned int div32(unsigned int a, unsigned int b, 
+				 unsigned int *r)
+{
+	if (b == 0) {
+		*r = 0;
+		return UINT_MAX;
+	}
+	*r = a % b;
+	return a / b;
+}
+
+static inline unsigned int div_down(unsigned int a, unsigned int b)
+{
+	if (b == 0)
+		return UINT_MAX;
+	return a / b;
+}
+
+static inline unsigned int div_up(unsigned int a, unsigned int b)
+{
+	unsigned int r;
+	unsigned int q;
+	if (b == 0)
+		return UINT_MAX;
+	q = div32(a, b, &r);
+	if (r)
+		++q;
+	return q;
+}
+
+static inline unsigned int mul(unsigned int a, unsigned int b)
+{
+	if (a == 0)
+		return 0;
+	if (div_down(UINT_MAX, a) < b)
+		return UINT_MAX;
+	return a * b;
+}
+
+static inline unsigned int muldiv32(unsigned int a, unsigned int b,
+				    unsigned int c, unsigned int *r)
+{
+	u_int64_t n = (u_int64_t) a * b;
+	if (c == 0) {
+		snd_BUG_ON(!n);
+		*r = 0;
+		return UINT_MAX;
+	}
+	n = div_u64_rem(n, c, r);
+	if (n >= UINT_MAX) {
+		*r = 0;
+		return UINT_MAX;
+	}
+	return n;
+}
+
+/**
+ * snd_interval_refine - refine the interval value of configurator
+ * @i: the interval value to refine
+ * @v: the interval value to refer to
+ *
+ * Refines the interval value with the reference value.
+ * The interval is changed to the range satisfying both intervals.
+ * The interval status (min, max, integer, etc.) are evaluated.
+ *
+ * Return: Positive if the value is changed, zero if it's not changed, or a
+ * negative error code.
+ */
+int snd_interval_refine(struct snd_interval *i, const struct snd_interval *v)
+{
+	int changed = 0;
+	if (snd_BUG_ON(snd_interval_empty(i)))
+		return -EINVAL;
+	if (i->min < v->min) {
+		i->min = v->min;
+		i->openmin = v->openmin;
+		changed = 1;
+	} else if (i->min == v->min && !i->openmin && v->openmin) {
+		i->openmin = 1;
+		changed = 1;
+	}
+	if (i->max > v->max) {
+		i->max = v->max;
+		i->openmax = v->openmax;
+		changed = 1;
+	} else if (i->max == v->max && !i->openmax && v->openmax) {
+		i->openmax = 1;
+		changed = 1;
+	}
+	if (!i->integer && v->integer) {
+		i->integer = 1;
+		changed = 1;
+	}
+	if (i->integer) {
+		if (i->openmin) {
+			i->min++;
+			i->openmin = 0;
+		}
+		if (i->openmax) {
+			i->max--;
+			i->openmax = 0;
+		}
+	} else if (!i->openmin && !i->openmax && i->min == i->max)
+		i->integer = 1;
+	if (snd_interval_checkempty(i)) {
+		snd_interval_none(i);
+		return -EINVAL;
+	}
+	return changed;
+}
+
+EXPORT_SYMBOL(snd_interval_refine);
+
+static int snd_interval_refine_first(struct snd_interval *i)
+{
+	if (snd_BUG_ON(snd_interval_empty(i)))
+		return -EINVAL;
+	if (snd_interval_single(i))
+		return 0;
+	i->max = i->min;
+	i->openmax = i->openmin;
+	if (i->openmax)
+		i->max++;
+	return 1;
+}
+
+static int snd_interval_refine_last(struct snd_interval *i)
+{
+	if (snd_BUG_ON(snd_interval_empty(i)))
+		return -EINVAL;
+	if (snd_interval_single(i))
+		return 0;
+	i->min = i->max;
+	i->openmin = i->openmax;
+	if (i->openmin)
+		i->min--;
+	return 1;
+}
+
+void snd_interval_mul(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c)
+{
+	if (a->empty || b->empty) {
+		snd_interval_none(c);
+		return;
+	}
+	c->empty = 0;
+	c->min = mul(a->min, b->min);
+	c->openmin = (a->openmin || b->openmin);
+	c->max = mul(a->max,  b->max);
+	c->openmax = (a->openmax || b->openmax);
+	c->integer = (a->integer && b->integer);
+}
+
+/**
+ * snd_interval_div - refine the interval value with division
+ * @a: dividend
+ * @b: divisor
+ * @c: quotient
+ *
+ * c = a / b
+ *
+ * Returns non-zero if the value is changed, zero if not changed.
+ */
+void snd_interval_div(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c)
+{
+	unsigned int r;
+	if (a->empty || b->empty) {
+		snd_interval_none(c);
+		return;
+	}
+	c->empty = 0;
+	c->min = div32(a->min, b->max, &r);
+	c->openmin = (r || a->openmin || b->openmax);
+	if (b->min > 0) {
+		c->max = div32(a->max, b->min, &r);
+		if (r) {
+			c->max++;
+			c->openmax = 1;
+		} else
+			c->openmax = (a->openmax || b->openmin);
+	} else {
+		c->max = UINT_MAX;
+		c->openmax = 0;
+	}
+	c->integer = 0;
+}
+
+/**
+ * snd_interval_muldivk - refine the interval value
+ * @a: dividend 1
+ * @b: dividend 2
+ * @k: divisor (as integer)
+ * @c: result
+  *
+ * c = a * b / k
+ *
+ * Returns non-zero if the value is changed, zero if not changed.
+ */
+void snd_interval_muldivk(const struct snd_interval *a, const struct snd_interval *b,
+		      unsigned int k, struct snd_interval *c)
+{
+	unsigned int r;
+	if (a->empty || b->empty) {
+		snd_interval_none(c);
+		return;
+	}
+	c->empty = 0;
+	c->min = muldiv32(a->min, b->min, k, &r);
+	c->openmin = (r || a->openmin || b->openmin);
+	c->max = muldiv32(a->max, b->max, k, &r);
+	if (r) {
+		c->max++;
+		c->openmax = 1;
+	} else
+		c->openmax = (a->openmax || b->openmax);
+	c->integer = 0;
+}
+
+/**
+ * snd_interval_mulkdiv - refine the interval value
+ * @a: dividend 1
+ * @k: dividend 2 (as integer)
+ * @b: divisor
+ * @c: result
+ *
+ * c = a * k / b
+ *
+ * Returns non-zero if the value is changed, zero if not changed.
+ */
+void snd_interval_mulkdiv(const struct snd_interval *a, unsigned int k,
+		      const struct snd_interval *b, struct snd_interval *c)
+{
+	unsigned int r;
+	if (a->empty || b->empty) {
+		snd_interval_none(c);
+		return;
+	}
+	c->empty = 0;
+	c->min = muldiv32(a->min, k, b->max, &r);
+	c->openmin = (r || a->openmin || b->openmax);
+	if (b->min > 0) {
+		c->max = muldiv32(a->max, k, b->min, &r);
+		if (r) {
+			c->max++;
+			c->openmax = 1;
+		} else
+			c->openmax = (a->openmax || b->openmin);
+	} else {
+		c->max = UINT_MAX;
+		c->openmax = 0;
+	}
+	c->integer = 0;
+}
+
+/* ---- */
+
+
+/**
+ * snd_interval_ratnum - refine the interval value
+ * @i: interval to refine
+ * @rats_count: number of ratnum_t 
+ * @rats: ratnum_t array
+ * @nump: pointer to store the resultant numerator
+ * @denp: pointer to store the resultant denominator
+ *
+ * Return: Positive if the value is changed, zero if it's not changed, or a
+ * negative error code.
+ */
+int snd_interval_ratnum(struct snd_interval *i,
+			unsigned int rats_count, struct snd_ratnum *rats,
+			unsigned int *nump, unsigned int *denp)
+{
+	unsigned int best_num, best_den;
+	int best_diff;
+	unsigned int k;
+	struct snd_interval t;
+	int err;
+	unsigned int result_num, result_den;
+	int result_diff;
+
+	best_num = best_den = best_diff = 0;
+	for (k = 0; k < rats_count; ++k) {
+		unsigned int num = rats[k].num;
+		unsigned int den;
+		unsigned int q = i->min;
+		int diff;
+		if (q == 0)
+			q = 1;
+		den = div_up(num, q);
+		if (den < rats[k].den_min)
+			continue;
+		if (den > rats[k].den_max)
+			den = rats[k].den_max;
+		else {
+			unsigned int r;
+			r = (den - rats[k].den_min) % rats[k].den_step;
+			if (r != 0)
+				den -= r;
+		}
+		diff = num - q * den;
+		if (diff < 0)
+			diff = -diff;
+		if (best_num == 0 ||
+		    diff * best_den < best_diff * den) {
+			best_diff = diff;
+			best_den = den;
+			best_num = num;
+		}
+	}
+	if (best_den == 0) {
+		i->empty = 1;
+		return -EINVAL;
+	}
+	t.min = div_down(best_num, best_den);
+	t.openmin = !!(best_num % best_den);
+	
+	result_num = best_num;
+	result_diff = best_diff;
+	result_den = best_den;
+	best_num = best_den = best_diff = 0;
+	for (k = 0; k < rats_count; ++k) {
+		unsigned int num = rats[k].num;
+		unsigned int den;
+		unsigned int q = i->max;
+		int diff;
+		if (q == 0) {
+			i->empty = 1;
+			return -EINVAL;
+		}
+		den = div_down(num, q);
+		if (den > rats[k].den_max)
+			continue;
+		if (den < rats[k].den_min)
+			den = rats[k].den_min;
+		else {
+			unsigned int r;
+			r = (den - rats[k].den_min) % rats[k].den_step;
+			if (r != 0)
+				den += rats[k].den_step - r;
+		}
+		diff = q * den - num;
+		if (diff < 0)
+			diff = -diff;
+		if (best_num == 0 ||
+		    diff * best_den < best_diff * den) {
+			best_diff = diff;
+			best_den = den;
+			best_num = num;
+		}
+	}
+	if (best_den == 0) {
+		i->empty = 1;
+		return -EINVAL;
+	}
+	t.max = div_up(best_num, best_den);
+	t.openmax = !!(best_num % best_den);
+	t.integer = 0;
+	err = snd_interval_refine(i, &t);
+	if (err < 0)
+		return err;
+
+	if (snd_interval_single(i)) {
+		if (best_diff * result_den < result_diff * best_den) {
+			result_num = best_num;
+			result_den = best_den;
+		}
+		if (nump)
+			*nump = result_num;
+		if (denp)
+			*denp = result_den;
+	}
+	return err;
+}
+
+EXPORT_SYMBOL(snd_interval_ratnum);
+
+/**
+ * snd_interval_ratden - refine the interval value
+ * @i: interval to refine
+ * @rats_count: number of struct ratden
+ * @rats: struct ratden array
+ * @nump: pointer to store the resultant numerator
+ * @denp: pointer to store the resultant denominator
+ *
+ * Return: Positive if the value is changed, zero if it's not changed, or a
+ * negative error code.
+ */
+static int snd_interval_ratden(struct snd_interval *i,
+			       unsigned int rats_count, struct snd_ratden *rats,
+			       unsigned int *nump, unsigned int *denp)
+{
+	unsigned int best_num, best_diff, best_den;
+	unsigned int k;
+	struct snd_interval t;
+	int err;
+
+	best_num = best_den = best_diff = 0;
+	for (k = 0; k < rats_count; ++k) {
+		unsigned int num;
+		unsigned int den = rats[k].den;
+		unsigned int q = i->min;
+		int diff;
+		num = mul(q, den);
+		if (num > rats[k].num_max)
+			continue;
+		if (num < rats[k].num_min)
+			num = rats[k].num_max;
+		else {
+			unsigned int r;
+			r = (num - rats[k].num_min) % rats[k].num_step;
+			if (r != 0)
+				num += rats[k].num_step - r;
+		}
+		diff = num - q * den;
+		if (best_num == 0 ||
+		    diff * best_den < best_diff * den) {
+			best_diff = diff;
+			best_den = den;
+			best_num = num;
+		}
+	}
+	if (best_den == 0) {
+		i->empty = 1;
+		return -EINVAL;
+	}
+	t.min = div_down(best_num, best_den);
+	t.openmin = !!(best_num % best_den);
+	
+	best_num = best_den = best_diff = 0;
+	for (k = 0; k < rats_count; ++k) {
+		unsigned int num;
+		unsigned int den = rats[k].den;
+		unsigned int q = i->max;
+		int diff;
+		num = mul(q, den);
+		if (num < rats[k].num_min)
+			continue;
+		if (num > rats[k].num_max)
+			num = rats[k].num_max;
+		else {
+			unsigned int r;
+			r = (num - rats[k].num_min) % rats[k].num_step;
+			if (r != 0)
+				num -= r;
+		}
+		diff = q * den - num;
+		if (best_num == 0 ||
+		    diff * best_den < best_diff * den) {
+			best_diff = diff;
+			best_den = den;
+			best_num = num;
+		}
+	}
+	if (best_den == 0) {
+		i->empty = 1;
+		return -EINVAL;
+	}
+	t.max = div_up(best_num, best_den);
+	t.openmax = !!(best_num % best_den);
+	t.integer = 0;
+	err = snd_interval_refine(i, &t);
+	if (err < 0)
+		return err;
+
+	if (snd_interval_single(i)) {
+		if (nump)
+			*nump = best_num;
+		if (denp)
+			*denp = best_den;
+	}
+	return err;
+}
+
+/**
+ * snd_interval_list - refine the interval value from the list
+ * @i: the interval value to refine
+ * @count: the number of elements in the list
+ * @list: the value list
+ * @mask: the bit-mask to evaluate
+ *
+ * Refines the interval value from the list.
+ * When mask is non-zero, only the elements corresponding to bit 1 are
+ * evaluated.
+ *
+ * Return: Positive if the value is changed, zero if it's not changed, or a
+ * negative error code.
+ */
+int snd_interval_list(struct snd_interval *i, unsigned int count,
+		      const unsigned int *list, unsigned int mask)
+{
+        unsigned int k;
+	struct snd_interval list_range;
+
+	if (!count) {
+		i->empty = 1;
+		return -EINVAL;
+	}
+	snd_interval_any(&list_range);
+	list_range.min = UINT_MAX;
+	list_range.max = 0;
+        for (k = 0; k < count; k++) {
+		if (mask && !(mask & (1 << k)))
+			continue;
+		if (!snd_interval_test(i, list[k]))
+			continue;
+		list_range.min = min(list_range.min, list[k]);
+		list_range.max = max(list_range.max, list[k]);
+        }
+	return snd_interval_refine(i, &list_range);
+}
+
+EXPORT_SYMBOL(snd_interval_list);
+
+static int snd_interval_step(struct snd_interval *i, unsigned int min, unsigned int step)
+{
+	unsigned int n;
+	int changed = 0;
+	n = (i->min - min) % step;
+	if (n != 0 || i->openmin) {
+		i->min += step - n;
+		changed = 1;
+	}
+	n = (i->max - min) % step;
+	if (n != 0 || i->openmax) {
+		i->max -= n;
+		changed = 1;
+	}
+	if (snd_interval_checkempty(i)) {
+		i->empty = 1;
+		return -EINVAL;
+	}
+	return changed;
+}
+
+/* Info constraints helpers */
+
+/**
+ * snd_pcm_hw_rule_add - add the hw-constraint rule
+ * @runtime: the pcm runtime instance
+ * @cond: condition bits
+ * @var: the variable to evaluate
+ * @func: the evaluation function
+ * @private: the private data pointer passed to function
+ * @dep: the dependent variables
+ *
+ * Return: Zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime, unsigned int cond,
+			int var,
+			snd_pcm_hw_rule_func_t func, void *private,
+			int dep, ...)
+{
+	struct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;
+	struct snd_pcm_hw_rule *c;
+	unsigned int k;
+	va_list args;
+	va_start(args, dep);
+	if (constrs->rules_num >= constrs->rules_all) {
+		struct snd_pcm_hw_rule *new;
+		unsigned int new_rules = constrs->rules_all + 16;
+		new = kcalloc(new_rules, sizeof(*c), GFP_KERNEL);
+		if (!new) {
+			va_end(args);
+			return -ENOMEM;
+		}
+		if (constrs->rules) {
+			memcpy(new, constrs->rules,
+			       constrs->rules_num * sizeof(*c));
+			kfree(constrs->rules);
+		}
+		constrs->rules = new;
+		constrs->rules_all = new_rules;
+	}
+	c = &constrs->rules[constrs->rules_num];
+	c->cond = cond;
+	c->func = func;
+	c->var = var;
+	c->private = private;
+	k = 0;
+	while (1) {
+		if (snd_BUG_ON(k >= ARRAY_SIZE(c->deps))) {
+			va_end(args);
+			return -EINVAL;
+		}
+		c->deps[k++] = dep;
+		if (dep < 0)
+			break;
+		dep = va_arg(args, int);
+	}
+	constrs->rules_num++;
+	va_end(args);
+	return 0;
+}
+
+EXPORT_SYMBOL(snd_pcm_hw_rule_add);
+
+/**
+ * snd_pcm_hw_constraint_mask - apply the given bitmap mask constraint
+ * @runtime: PCM runtime instance
+ * @var: hw_params variable to apply the mask
+ * @mask: the bitmap mask
+ *
+ * Apply the constraint of the given bitmap mask to a 32-bit mask parameter.
+ *
+ * Return: Zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_hw_constraint_mask(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
+			       u_int32_t mask)
+{
+	struct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;
+	struct snd_mask *maskp = constrs_mask(constrs, var);
+	*maskp->bits &= mask;
+	memset(maskp->bits + 1, 0, (SNDRV_MASK_MAX-32) / 8); /* clear rest */
+	if (*maskp->bits == 0)
+		return -EINVAL;
+	return 0;
+}
+
+/**
+ * snd_pcm_hw_constraint_mask64 - apply the given bitmap mask constraint
+ * @runtime: PCM runtime instance
+ * @var: hw_params variable to apply the mask
+ * @mask: the 64bit bitmap mask
+ *
+ * Apply the constraint of the given bitmap mask to a 64-bit mask parameter.
+ *
+ * Return: Zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
+				 u_int64_t mask)
+{
+	struct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;
+	struct snd_mask *maskp = constrs_mask(constrs, var);
+	maskp->bits[0] &= (u_int32_t)mask;
+	maskp->bits[1] &= (u_int32_t)(mask >> 32);
+	memset(maskp->bits + 2, 0, (SNDRV_MASK_MAX-64) / 8); /* clear rest */
+	if (! maskp->bits[0] && ! maskp->bits[1])
+		return -EINVAL;
+	return 0;
+}
+
+/**
+ * snd_pcm_hw_constraint_integer - apply an integer constraint to an interval
+ * @runtime: PCM runtime instance
+ * @var: hw_params variable to apply the integer constraint
+ *
+ * Apply the constraint of integer to an interval parameter.
+ *
+ * Return: Positive if the value is changed, zero if it's not changed, or a
+ * negative error code.
+ */
+int snd_pcm_hw_constraint_integer(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var)
+{
+	struct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;
+	return snd_interval_setinteger(constrs_interval(constrs, var));
+}
+
+EXPORT_SYMBOL(snd_pcm_hw_constraint_integer);
+
+/**
+ * snd_pcm_hw_constraint_minmax - apply a min/max range constraint to an interval
+ * @runtime: PCM runtime instance
+ * @var: hw_params variable to apply the range
+ * @min: the minimal value
+ * @max: the maximal value
+ * 
+ * Apply the min/max range constraint to an interval parameter.
+ *
+ * Return: Positive if the value is changed, zero if it's not changed, or a
+ * negative error code.
+ */
+int snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
+				 unsigned int min, unsigned int max)
+{
+	struct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;
+	struct snd_interval t;
+	t.min = min;
+	t.max = max;
+	t.openmin = t.openmax = 0;
+	t.integer = 0;
+	return snd_interval_refine(constrs_interval(constrs, var), &t);
+}
+
+EXPORT_SYMBOL(snd_pcm_hw_constraint_minmax);
+
+static int snd_pcm_hw_rule_list(struct snd_pcm_hw_params *params,
+				struct snd_pcm_hw_rule *rule)
+{
+	struct snd_pcm_hw_constraint_list *list = rule->private;
+	return snd_interval_list(hw_param_interval(params, rule->var), list->count, list->list, list->mask);
+}		
+
+
+/**
+ * snd_pcm_hw_constraint_list - apply a list of constraints to a parameter
+ * @runtime: PCM runtime instance
+ * @cond: condition bits
+ * @var: hw_params variable to apply the list constraint
+ * @l: list
+ * 
+ * Apply the list of constraints to an interval parameter.
+ *
+ * Return: Zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime,
+			       unsigned int cond,
+			       snd_pcm_hw_param_t var,
+			       const struct snd_pcm_hw_constraint_list *l)
+{
+	return snd_pcm_hw_rule_add(runtime, cond, var,
+				   snd_pcm_hw_rule_list, (void *)l,
+				   var, -1);
+}
+
+EXPORT_SYMBOL(snd_pcm_hw_constraint_list);
+
+static int snd_pcm_hw_rule_ratnums(struct snd_pcm_hw_params *params,
+				   struct snd_pcm_hw_rule *rule)
+{
+	struct snd_pcm_hw_constraint_ratnums *r = rule->private;
+	unsigned int num = 0, den = 0;
+	int err;
+	err = snd_interval_ratnum(hw_param_interval(params, rule->var),
+				  r->nrats, r->rats, &num, &den);
+	if (err >= 0 && den && rule->var == SNDRV_PCM_HW_PARAM_RATE) {
+		params->rate_num = num;
+		params->rate_den = den;
+	}
+	return err;
+}
+
+/**
+ * snd_pcm_hw_constraint_ratnums - apply ratnums constraint to a parameter
+ * @runtime: PCM runtime instance
+ * @cond: condition bits
+ * @var: hw_params variable to apply the ratnums constraint
+ * @r: struct snd_ratnums constriants
+ *
+ * Return: Zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime, 
+				  unsigned int cond,
+				  snd_pcm_hw_param_t var,
+				  struct snd_pcm_hw_constraint_ratnums *r)
+{
+	return snd_pcm_hw_rule_add(runtime, cond, var,
+				   snd_pcm_hw_rule_ratnums, r,
+				   var, -1);
+}
+
+EXPORT_SYMBOL(snd_pcm_hw_constraint_ratnums);
+
+static int snd_pcm_hw_rule_ratdens(struct snd_pcm_hw_params *params,
+				   struct snd_pcm_hw_rule *rule)
+{
+	struct snd_pcm_hw_constraint_ratdens *r = rule->private;
+	unsigned int num = 0, den = 0;
+	int err = snd_interval_ratden(hw_param_interval(params, rule->var),
+				  r->nrats, r->rats, &num, &den);
+	if (err >= 0 && den && rule->var == SNDRV_PCM_HW_PARAM_RATE) {
+		params->rate_num = num;
+		params->rate_den = den;
+	}
+	return err;
+}
+
+/**
+ * snd_pcm_hw_constraint_ratdens - apply ratdens constraint to a parameter
+ * @runtime: PCM runtime instance
+ * @cond: condition bits
+ * @var: hw_params variable to apply the ratdens constraint
+ * @r: struct snd_ratdens constriants
+ *
+ * Return: Zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime, 
+				  unsigned int cond,
+				  snd_pcm_hw_param_t var,
+				  struct snd_pcm_hw_constraint_ratdens *r)
+{
+	return snd_pcm_hw_rule_add(runtime, cond, var,
+				   snd_pcm_hw_rule_ratdens, r,
+				   var, -1);
+}
+
+EXPORT_SYMBOL(snd_pcm_hw_constraint_ratdens);
+
+static int snd_pcm_hw_rule_msbits(struct snd_pcm_hw_params *params,
+				  struct snd_pcm_hw_rule *rule)
+{
+	unsigned int l = (unsigned long) rule->private;
+	int width = l & 0xffff;
+	unsigned int msbits = l >> 16;
+	struct snd_interval *i = hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);
+	if (snd_interval_single(i) && snd_interval_value(i) == width)
+		params->msbits = msbits;
+	return 0;
+}
+
+/**
+ * snd_pcm_hw_constraint_msbits - add a hw constraint msbits rule
+ * @runtime: PCM runtime instance
+ * @cond: condition bits
+ * @width: sample bits width
+ * @msbits: msbits width
+ *
+ * Return: Zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_hw_constraint_msbits(struct snd_pcm_runtime *runtime, 
+				 unsigned int cond,
+				 unsigned int width,
+				 unsigned int msbits)
+{
+	unsigned long l = (msbits << 16) | width;
+	return snd_pcm_hw_rule_add(runtime, cond, -1,
+				    snd_pcm_hw_rule_msbits,
+				    (void*) l,
+				    SNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);
+}
+
+EXPORT_SYMBOL(snd_pcm_hw_constraint_msbits);
+
+static int snd_pcm_hw_rule_step(struct snd_pcm_hw_params *params,
+				struct snd_pcm_hw_rule *rule)
+{
+	unsigned long step = (unsigned long) rule->private;
+	return snd_interval_step(hw_param_interval(params, rule->var), 0, step);
+}
+
+/**
+ * snd_pcm_hw_constraint_step - add a hw constraint step rule
+ * @runtime: PCM runtime instance
+ * @cond: condition bits
+ * @var: hw_params variable to apply the step constraint
+ * @step: step size
+ *
+ * Return: Zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_hw_constraint_step(struct snd_pcm_runtime *runtime,
+			       unsigned int cond,
+			       snd_pcm_hw_param_t var,
+			       unsigned long step)
+{
+	return snd_pcm_hw_rule_add(runtime, cond, var, 
+				   snd_pcm_hw_rule_step, (void *) step,
+				   var, -1);
+}
+
+EXPORT_SYMBOL(snd_pcm_hw_constraint_step);
+
+static int snd_pcm_hw_rule_pow2(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)
+{
+	static unsigned int pow2_sizes[] = {
+		1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7,
+		1<<8, 1<<9, 1<<10, 1<<11, 1<<12, 1<<13, 1<<14, 1<<15,
+		1<<16, 1<<17, 1<<18, 1<<19, 1<<20, 1<<21, 1<<22, 1<<23,
+		1<<24, 1<<25, 1<<26, 1<<27, 1<<28, 1<<29, 1<<30
+	};
+	return snd_interval_list(hw_param_interval(params, rule->var),
+				 ARRAY_SIZE(pow2_sizes), pow2_sizes, 0);
+}		
+
+/**
+ * snd_pcm_hw_constraint_pow2 - add a hw constraint power-of-2 rule
+ * @runtime: PCM runtime instance
+ * @cond: condition bits
+ * @var: hw_params variable to apply the power-of-2 constraint
+ *
+ * Return: Zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,
+			       unsigned int cond,
+			       snd_pcm_hw_param_t var)
+{
+	return snd_pcm_hw_rule_add(runtime, cond, var, 
+				   snd_pcm_hw_rule_pow2, NULL,
+				   var, -1);
+}
+
+EXPORT_SYMBOL(snd_pcm_hw_constraint_pow2);
+
+static int snd_pcm_hw_rule_noresample_func(struct snd_pcm_hw_params *params,
+					   struct snd_pcm_hw_rule *rule)
+{
+	unsigned int base_rate = (unsigned int)(uintptr_t)rule->private;
+	struct snd_interval *rate;
+
+	rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	return snd_interval_list(rate, 1, &base_rate, 0);
+}
+
+/**
+ * snd_pcm_hw_rule_noresample - add a rule to allow disabling hw resampling
+ * @runtime: PCM runtime instance
+ * @base_rate: the rate at which the hardware does not resample
+ *
+ * Return: Zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_hw_rule_noresample(struct snd_pcm_runtime *runtime,
+			       unsigned int base_rate)
+{
+	return snd_pcm_hw_rule_add(runtime, SNDRV_PCM_HW_PARAMS_NORESAMPLE,
+				   SNDRV_PCM_HW_PARAM_RATE,
+				   snd_pcm_hw_rule_noresample_func,
+				   (void *)(uintptr_t)base_rate,
+				   SNDRV_PCM_HW_PARAM_RATE, -1);
+}
+EXPORT_SYMBOL(snd_pcm_hw_rule_noresample);
+
+static void _snd_pcm_hw_param_any(struct snd_pcm_hw_params *params,
+				  snd_pcm_hw_param_t var)
+{
+	if (hw_is_mask(var)) {
+		snd_mask_any(hw_param_mask(params, var));
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+		return;
+	}
+	if (hw_is_interval(var)) {
+		snd_interval_any(hw_param_interval(params, var));
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+		return;
+	}
+	snd_BUG();
+}
+
+void _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params)
+{
+	unsigned int k;
+	memset(params, 0, sizeof(*params));
+	for (k = SNDRV_PCM_HW_PARAM_FIRST_MASK; k <= SNDRV_PCM_HW_PARAM_LAST_MASK; k++)
+		_snd_pcm_hw_param_any(params, k);
+	for (k = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL; k <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; k++)
+		_snd_pcm_hw_param_any(params, k);
+	params->info = ~0U;
+}
+
+EXPORT_SYMBOL(_snd_pcm_hw_params_any);
+
+/**
+ * snd_pcm_hw_param_value - return @params field @var value
+ * @params: the hw_params instance
+ * @var: parameter to retrieve
+ * @dir: pointer to the direction (-1,0,1) or %NULL
+ *
+ * Return: The value for field @var if it's fixed in configuration space
+ * defined by @params. -%EINVAL otherwise.
+ */
+int snd_pcm_hw_param_value(const struct snd_pcm_hw_params *params,
+			   snd_pcm_hw_param_t var, int *dir)
+{
+	if (hw_is_mask(var)) {
+		const struct snd_mask *mask = hw_param_mask_c(params, var);
+		if (!snd_mask_single(mask))
+			return -EINVAL;
+		if (dir)
+			*dir = 0;
+		return snd_mask_value(mask);
+	}
+	if (hw_is_interval(var)) {
+		const struct snd_interval *i = hw_param_interval_c(params, var);
+		if (!snd_interval_single(i))
+			return -EINVAL;
+		if (dir)
+			*dir = i->openmin;
+		return snd_interval_value(i);
+	}
+	return -EINVAL;
+}
+
+EXPORT_SYMBOL(snd_pcm_hw_param_value);
+
+void _snd_pcm_hw_param_setempty(struct snd_pcm_hw_params *params,
+				snd_pcm_hw_param_t var)
+{
+	if (hw_is_mask(var)) {
+		snd_mask_none(hw_param_mask(params, var));
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+	} else if (hw_is_interval(var)) {
+		snd_interval_none(hw_param_interval(params, var));
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+	} else {
+		snd_BUG();
+	}
+}
+
+EXPORT_SYMBOL(_snd_pcm_hw_param_setempty);
+
+static int _snd_pcm_hw_param_first(struct snd_pcm_hw_params *params,
+				   snd_pcm_hw_param_t var)
+{
+	int changed;
+	if (hw_is_mask(var))
+		changed = snd_mask_refine_first(hw_param_mask(params, var));
+	else if (hw_is_interval(var))
+		changed = snd_interval_refine_first(hw_param_interval(params, var));
+	else
+		return -EINVAL;
+	if (changed) {
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+	}
+	return changed;
+}
+
+
+/**
+ * snd_pcm_hw_param_first - refine config space and return minimum value
+ * @pcm: PCM instance
+ * @params: the hw_params instance
+ * @var: parameter to retrieve
+ * @dir: pointer to the direction (-1,0,1) or %NULL
+ *
+ * Inside configuration space defined by @params remove from @var all
+ * values > minimum. Reduce configuration space accordingly.
+ *
+ * Return: The minimum, or a negative error code on failure.
+ */
+int snd_pcm_hw_param_first(struct snd_pcm_substream *pcm, 
+			   struct snd_pcm_hw_params *params, 
+			   snd_pcm_hw_param_t var, int *dir)
+{
+	int changed = _snd_pcm_hw_param_first(params, var);
+	if (changed < 0)
+		return changed;
+	if (params->rmask) {
+		int err = snd_pcm_hw_refine(pcm, params);
+		if (snd_BUG_ON(err < 0))
+			return err;
+	}
+	return snd_pcm_hw_param_value(params, var, dir);
+}
+
+EXPORT_SYMBOL(snd_pcm_hw_param_first);
+
+static int _snd_pcm_hw_param_last(struct snd_pcm_hw_params *params,
+				  snd_pcm_hw_param_t var)
+{
+	int changed;
+	if (hw_is_mask(var))
+		changed = snd_mask_refine_last(hw_param_mask(params, var));
+	else if (hw_is_interval(var))
+		changed = snd_interval_refine_last(hw_param_interval(params, var));
+	else
+		return -EINVAL;
+	if (changed) {
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+	}
+	return changed;
+}
+
+
+/**
+ * snd_pcm_hw_param_last - refine config space and return maximum value
+ * @pcm: PCM instance
+ * @params: the hw_params instance
+ * @var: parameter to retrieve
+ * @dir: pointer to the direction (-1,0,1) or %NULL
+ *
+ * Inside configuration space defined by @params remove from @var all
+ * values < maximum. Reduce configuration space accordingly.
+ *
+ * Return: The maximum, or a negative error code on failure.
+ */
+int snd_pcm_hw_param_last(struct snd_pcm_substream *pcm, 
+			  struct snd_pcm_hw_params *params,
+			  snd_pcm_hw_param_t var, int *dir)
+{
+	int changed = _snd_pcm_hw_param_last(params, var);
+	if (changed < 0)
+		return changed;
+	if (params->rmask) {
+		int err = snd_pcm_hw_refine(pcm, params);
+		if (snd_BUG_ON(err < 0))
+			return err;
+	}
+	return snd_pcm_hw_param_value(params, var, dir);
+}
+
+EXPORT_SYMBOL(snd_pcm_hw_param_last);
+
+/**
+ * snd_pcm_hw_param_choose - choose a configuration defined by @params
+ * @pcm: PCM instance
+ * @params: the hw_params instance
+ *
+ * Choose one configuration from configuration space defined by @params.
+ * The configuration chosen is that obtained fixing in this order:
+ * first access, first format, first subformat, min channels,
+ * min rate, min period time, max buffer size, min tick time
+ *
+ * Return: Zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_hw_params_choose(struct snd_pcm_substream *pcm,
+			     struct snd_pcm_hw_params *params)
+{
+	static int vars[] = {
+		SNDRV_PCM_HW_PARAM_ACCESS,
+		SNDRV_PCM_HW_PARAM_FORMAT,
+		SNDRV_PCM_HW_PARAM_SUBFORMAT,
+		SNDRV_PCM_HW_PARAM_CHANNELS,
+		SNDRV_PCM_HW_PARAM_RATE,
+		SNDRV_PCM_HW_PARAM_PERIOD_TIME,
+		SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+		SNDRV_PCM_HW_PARAM_TICK_TIME,
+		-1
+	};
+	int err, *v;
+
+	for (v = vars; *v != -1; v++) {
+		if (*v != SNDRV_PCM_HW_PARAM_BUFFER_SIZE)
+			err = snd_pcm_hw_param_first(pcm, params, *v, NULL);
+		else
+			err = snd_pcm_hw_param_last(pcm, params, *v, NULL);
+		if (snd_BUG_ON(err < 0))
+			return err;
+	}
+	return 0;
+}
+
+static int snd_pcm_lib_ioctl_reset(struct snd_pcm_substream *substream,
+				   void *arg)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned long flags;
+	snd_pcm_stream_lock_irqsave(substream, flags);
+	if (snd_pcm_running(substream) &&
+	    snd_pcm_update_hw_ptr(substream) >= 0)
+		runtime->status->hw_ptr %= runtime->buffer_size;
+	else {
+		runtime->status->hw_ptr = 0;
+		runtime->hw_ptr_wrap = 0;
+	}
+	snd_pcm_stream_unlock_irqrestore(substream, flags);
+	return 0;
+}
+
+static int snd_pcm_lib_ioctl_channel_info(struct snd_pcm_substream *substream,
+					  void *arg)
+{
+	struct snd_pcm_channel_info *info = arg;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int width;
+	if (!(runtime->info & SNDRV_PCM_INFO_MMAP)) {
+		info->offset = -1;
+		return 0;
+	}
+	width = snd_pcm_format_physical_width(runtime->format);
+	if (width < 0)
+		return width;
+	info->offset = 0;
+	switch (runtime->access) {
+	case SNDRV_PCM_ACCESS_MMAP_INTERLEAVED:
+	case SNDRV_PCM_ACCESS_RW_INTERLEAVED:
+		info->first = info->channel * width;
+		info->step = runtime->channels * width;
+		break;
+	case SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED:
+	case SNDRV_PCM_ACCESS_RW_NONINTERLEAVED:
+	{
+		size_t size = runtime->dma_bytes / runtime->channels;
+		info->first = info->channel * size * 8;
+		info->step = width;
+		break;
+	}
+	default:
+		snd_BUG();
+		break;
+	}
+	return 0;
+}
+
+static int snd_pcm_lib_ioctl_fifo_size(struct snd_pcm_substream *substream,
+				       void *arg)
+{
+	struct snd_pcm_hw_params *params = arg;
+	snd_pcm_format_t format;
+	int channels;
+	ssize_t frame_size;
+
+	params->fifo_size = substream->runtime->hw.fifo_size;
+	if (!(substream->runtime->hw.info & SNDRV_PCM_INFO_FIFO_IN_FRAMES)) {
+		format = params_format(params);
+		channels = params_channels(params);
+		frame_size = snd_pcm_format_size(format, channels);
+		if (frame_size > 0)
+			params->fifo_size /= (unsigned)frame_size;
+	}
+	return 0;
+}
+
+/**
+ * snd_pcm_lib_ioctl - a generic PCM ioctl callback
+ * @substream: the pcm substream instance
+ * @cmd: ioctl command
+ * @arg: ioctl argument
+ *
+ * Processes the generic ioctl commands for PCM.
+ * Can be passed as the ioctl callback for PCM ops.
+ *
+ * Return: Zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
+		      unsigned int cmd, void *arg)
+{
+	switch (cmd) {
+	case SNDRV_PCM_IOCTL1_INFO:
+		return 0;
+	case SNDRV_PCM_IOCTL1_RESET:
+		return snd_pcm_lib_ioctl_reset(substream, arg);
+	case SNDRV_PCM_IOCTL1_CHANNEL_INFO:
+		return snd_pcm_lib_ioctl_channel_info(substream, arg);
+	case SNDRV_PCM_IOCTL1_FIFO_SIZE:
+		return snd_pcm_lib_ioctl_fifo_size(substream, arg);
+	}
+	return -ENXIO;
+}
+
+EXPORT_SYMBOL(snd_pcm_lib_ioctl);
+
+/**
+ * snd_pcm_period_elapsed - update the pcm status for the next period
+ * @substream: the pcm substream instance
+ *
+ * This function is called from the interrupt handler when the
+ * PCM has processed the period size.  It will update the current
+ * pointer, wake up sleepers, etc.
+ *
+ * Even if more than one periods have elapsed since the last call, you
+ * have to call this only once.
+ */
+void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime;
+	unsigned long flags;
+
+	if (PCM_RUNTIME_CHECK(substream))
+		return;
+	runtime = substream->runtime;
+
+	if (runtime->transfer_ack_begin)
+		runtime->transfer_ack_begin(substream);
+
+	snd_pcm_stream_lock_irqsave(substream, flags);
+	if (!snd_pcm_running(substream) ||
+	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
+		goto _end;
+
+	if (substream->timer_running)
+		snd_timer_interrupt(substream->timer, 1);
+ _end:
+	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
+	snd_pcm_stream_unlock_irqrestore(substream, flags);
+	if (runtime->transfer_ack_end)
+		runtime->transfer_ack_end(substream);
+}
+
+EXPORT_SYMBOL(snd_pcm_period_elapsed);
+
+/*
+ * Wait until avail_min data becomes available
+ * Returns a negative error code if any error occurs during operation.
+ * The available space is stored on availp.  When err = 0 and avail = 0
+ * on the capture stream, it indicates the stream is in DRAINING state.
+ */
+static int wait_for_avail(struct snd_pcm_substream *substream,
+			      snd_pcm_uframes_t *availp)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int is_playback = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	wait_queue_t wait;
+	int err = 0;
+	snd_pcm_uframes_t avail = 0;
+	long wait_time, tout;
+
+	init_waitqueue_entry(&wait, current);
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue(&runtime->tsleep, &wait);
+
+	if (runtime->no_period_wakeup)
+		wait_time = MAX_SCHEDULE_TIMEOUT;
+	else {
+
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			wait_time = 1;
+		else
+			wait_time = 2;
+
+		if (runtime->rate) {
+			long t = runtime->period_size * 2 / runtime->rate;
+			wait_time = max(t, wait_time);
+		}
+		wait_time = msecs_to_jiffies(wait_time * 1000);
+	}
+
+	for (;;) {
+		if (signal_pending(current)) {
+			err = -ERESTARTSYS;
+			break;
+		}
+
+		/*
+		 * We need to check if space became available already
+		 * (and thus the wakeup happened already) first to close
+		 * the race of space already having become available.
+		 * This check must happen after been added to the waitqueue
+		 * and having current state be INTERRUPTIBLE.
+		 */
+		if (is_playback)
+			avail = snd_pcm_playback_avail(runtime);
+		else
+			avail = snd_pcm_capture_avail(runtime);
+		if (avail >= runtime->twake)
+			break;
+		snd_pcm_stream_unlock_irq(substream);
+
+		tout = schedule_timeout(wait_time);
+
+		snd_pcm_stream_lock_irq(substream);
+		set_current_state(TASK_INTERRUPTIBLE);
+		switch (runtime->status->state) {
+		case SNDRV_PCM_STATE_SUSPENDED:
+			err = -ESTRPIPE;
+			goto _endloop;
+		case SNDRV_PCM_STATE_XRUN:
+			err = -EPIPE;
+			goto _endloop;
+		case SNDRV_PCM_STATE_DRAINING:
+			if (is_playback)
+				err = -EPIPE;
+			else 
+				avail = 0; /* indicate draining */
+			goto _endloop;
+		case SNDRV_PCM_STATE_OPEN:
+		case SNDRV_PCM_STATE_SETUP:
+		case SNDRV_PCM_STATE_DISCONNECTED:
+			err = -EBADFD;
+			goto _endloop;
+		case SNDRV_PCM_STATE_PAUSED:
+			continue;
+		}
+		if (!tout) {
+			snd_printd("%s write error (DMA or IRQ trouble?)\n",
+				   is_playback ? "playback" : "capture");
+			err = -EIO;
+			break;
+		}
+	}
+ _endloop:
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&runtime->tsleep, &wait);
+	*availp = avail;
+	return err;
+}
+	
+static int snd_pcm_lib_write_transfer(struct snd_pcm_substream *substream,
+				      unsigned int hwoff,
+				      unsigned long data, unsigned int off,
+				      snd_pcm_uframes_t frames)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err;
+	char __user *buf = (char __user *) data + frames_to_bytes(runtime, off);
+	if (substream->ops->copy) {
+		if ((err = substream->ops->copy(substream, -1, hwoff, buf, frames)) < 0)
+			return err;
+	} else {
+		char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
+		
+		if (unalign_copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames)))
+			return -EFAULT;
+	}
+	return 0;
+}
+ 
+typedef int (*transfer_f)(struct snd_pcm_substream *substream, unsigned int hwoff,
+			  unsigned long data, unsigned int off,
+			  snd_pcm_uframes_t size);
+
+static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream, 
+					    unsigned long data,
+					    snd_pcm_uframes_t size,
+					    int nonblock,
+					    transfer_f transfer)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	snd_pcm_uframes_t xfer = 0;
+	snd_pcm_uframes_t offset = 0;
+	snd_pcm_uframes_t avail;
+	int err = 0;
+
+	if (size == 0)
+		return 0;
+
+	snd_pcm_stream_lock_irq(substream);
+	switch (runtime->status->state) {
+	case SNDRV_PCM_STATE_PREPARED:
+	case SNDRV_PCM_STATE_RUNNING:
+	case SNDRV_PCM_STATE_PAUSED:
+		break;
+	case SNDRV_PCM_STATE_XRUN:
+		err = -EPIPE;
+		goto _end_unlock;
+	case SNDRV_PCM_STATE_SUSPENDED:
+		err = -ESTRPIPE;
+		goto _end_unlock;
+	default:
+		err = -EBADFD;
+		goto _end_unlock;
+	}
+
+	runtime->twake = runtime->control->avail_min ? : 1;
+	if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+		snd_pcm_update_hw_ptr(substream);
+	avail = snd_pcm_playback_avail(runtime);
+	while (size > 0) {
+		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
+		snd_pcm_uframes_t cont;
+		if (!avail) {
+			if (nonblock) {
+				err = -EAGAIN;
+				goto _end_unlock;
+			}
+			runtime->twake = min_t(snd_pcm_uframes_t, size,
+					runtime->control->avail_min ? : 1);
+			err = wait_for_avail(substream, &avail);
+			if (err < 0)
+				goto _end_unlock;
+		}
+		frames = size > avail ? avail : size;
+		cont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;
+		if (frames > cont)
+			frames = cont;
+		if (snd_BUG_ON(!frames)) {
+			runtime->twake = 0;
+			snd_pcm_stream_unlock_irq(substream);
+			return -EINVAL;
+		}
+		appl_ptr = runtime->control->appl_ptr;
+		appl_ofs = appl_ptr % runtime->buffer_size;
+		snd_pcm_stream_unlock_irq(substream);
+		err = transfer(substream, appl_ofs, data, offset, frames);
+		snd_pcm_stream_lock_irq(substream);
+		if (err < 0)
+			goto _end_unlock;
+		switch (runtime->status->state) {
+		case SNDRV_PCM_STATE_XRUN:
+			err = -EPIPE;
+			goto _end_unlock;
+		case SNDRV_PCM_STATE_SUSPENDED:
+			err = -ESTRPIPE;
+			goto _end_unlock;
+		default:
+			break;
+		}
+		appl_ptr += frames;
+		if (appl_ptr >= runtime->boundary)
+			appl_ptr -= runtime->boundary;
+		runtime->control->appl_ptr = appl_ptr;
+		if (substream->ops->ack)
+			substream->ops->ack(substream);
+
+		offset += frames;
+		size -= frames;
+		xfer += frames;
+		avail -= frames;
+		if (runtime->status->state == SNDRV_PCM_STATE_PREPARED &&
+		    snd_pcm_playback_hw_avail(runtime) >= (snd_pcm_sframes_t)runtime->start_threshold) {
+			err = snd_pcm_start(substream);
+			if (err < 0)
+				goto _end_unlock;
+		}
+	}
+ _end_unlock:
+	runtime->twake = 0;
+	if (xfer > 0 && err >= 0)
+		snd_pcm_update_state(substream, runtime);
+	snd_pcm_stream_unlock_irq(substream);
+	return xfer > 0 ? (snd_pcm_sframes_t)xfer : err;
+}
+
+/* sanity-check for read/write methods */
+static int pcm_sanity_check(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime;
+	if (PCM_RUNTIME_CHECK(substream))
+		return -ENXIO;
+	runtime = substream->runtime;
+	if (snd_BUG_ON(!substream->ops->copy && !runtime->dma_area))
+		return -EINVAL;
+	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
+		return -EBADFD;
+	return 0;
+}
+
+snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream, const void __user *buf, snd_pcm_uframes_t size)
+{
+	struct snd_pcm_runtime *runtime;
+	int nonblock;
+	int err;
+
+	err = pcm_sanity_check(substream);
+	if (err < 0)
+		return err;
+	runtime = substream->runtime;
+	nonblock = !!(substream->f_flags & O_NONBLOCK);
+
+	if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&
+	    runtime->channels > 1)
+		return -EINVAL;
+	return snd_pcm_lib_write1(substream, (unsigned long)buf, size, nonblock,
+				  snd_pcm_lib_write_transfer);
+}
+
+EXPORT_SYMBOL(snd_pcm_lib_write);
+
+static int snd_pcm_lib_writev_transfer(struct snd_pcm_substream *substream,
+				       unsigned int hwoff,
+				       unsigned long data, unsigned int off,
+				       snd_pcm_uframes_t frames)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err;
+	void __user **bufs = (void __user **)data;
+	int channels = runtime->channels;
+	int c;
+	if (substream->ops->copy) {
+		if (snd_BUG_ON(!substream->ops->silence))
+			return -EINVAL;
+		for (c = 0; c < channels; ++c, ++bufs) {
+			if (*bufs == NULL) {
+				if ((err = substream->ops->silence(substream, c, hwoff, frames)) < 0)
+					return err;
+			} else {
+				char __user *buf = *bufs + samples_to_bytes(runtime, off);
+				if ((err = substream->ops->copy(substream, c, hwoff, buf, frames)) < 0)
+					return err;
+			}
+		}
+	} else {
+		/* default transfer behaviour */
+		size_t dma_csize = runtime->dma_bytes / channels;
+		for (c = 0; c < channels; ++c, ++bufs) {
+			char *hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);
+			if (*bufs == NULL) {
+				snd_pcm_format_set_silence(runtime->format, hwbuf, frames);
+			} else {
+				char __user *buf = *bufs + samples_to_bytes(runtime, off);
+				if (unalign_copy_from_user(hwbuf, buf, samples_to_bytes(runtime, frames)))
+					return -EFAULT;
+			}
+		}
+	}
+	return 0;
+}
+ 
+snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
+				     void __user **bufs,
+				     snd_pcm_uframes_t frames)
+{
+	struct snd_pcm_runtime *runtime;
+	int nonblock;
+	int err;
+
+	err = pcm_sanity_check(substream);
+	if (err < 0)
+		return err;
+	runtime = substream->runtime;
+	nonblock = !!(substream->f_flags & O_NONBLOCK);
+
+	if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
+		return -EINVAL;
+	return snd_pcm_lib_write1(substream, (unsigned long)bufs, frames,
+				  nonblock, snd_pcm_lib_writev_transfer);
+}
+
+EXPORT_SYMBOL(snd_pcm_lib_writev);
+
+static int snd_pcm_lib_read_transfer(struct snd_pcm_substream *substream, 
+				     unsigned int hwoff,
+				     unsigned long data, unsigned int off,
+				     snd_pcm_uframes_t frames)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err;
+	char __user *buf = (char __user *) data + frames_to_bytes(runtime, off);
+	if (substream->ops->copy) {
+		if ((err = substream->ops->copy(substream, -1, hwoff, buf, frames)) < 0)
+			return err;
+	} else {
+		char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
+		if (unalign_copy_to_user(buf, hwbuf, frames_to_bytes(runtime, frames)))
+			return -EFAULT;
+	}
+	return 0;
+}
+
+static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
+					   unsigned long data,
+					   snd_pcm_uframes_t size,
+					   int nonblock,
+					   transfer_f transfer)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	snd_pcm_uframes_t xfer = 0;
+	snd_pcm_uframes_t offset = 0;
+	snd_pcm_uframes_t avail;
+	int err = 0;
+
+	if (size == 0)
+		return 0;
+
+	snd_pcm_stream_lock_irq(substream);
+	switch (runtime->status->state) {
+	case SNDRV_PCM_STATE_PREPARED:
+		if (size >= runtime->start_threshold) {
+			err = snd_pcm_start(substream);
+			if (err < 0)
+				goto _end_unlock;
+		}
+		break;
+	case SNDRV_PCM_STATE_DRAINING:
+	case SNDRV_PCM_STATE_RUNNING:
+	case SNDRV_PCM_STATE_PAUSED:
+		break;
+	case SNDRV_PCM_STATE_XRUN:
+		err = -EPIPE;
+		goto _end_unlock;
+	case SNDRV_PCM_STATE_SUSPENDED:
+		err = -ESTRPIPE;
+		goto _end_unlock;
+	default:
+		err = -EBADFD;
+		goto _end_unlock;
+	}
+
+	runtime->twake = runtime->control->avail_min ? : 1;
+	if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+		snd_pcm_update_hw_ptr(substream);
+	avail = snd_pcm_capture_avail(runtime);
+	while (size > 0) {
+		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
+		snd_pcm_uframes_t cont;
+		if (!avail) {
+			if (runtime->status->state ==
+			    SNDRV_PCM_STATE_DRAINING) {
+				snd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);
+				goto _end_unlock;
+			}
+			if (nonblock) {
+				err = -EAGAIN;
+				goto _end_unlock;
+			}
+			runtime->twake = min_t(snd_pcm_uframes_t, size,
+					runtime->control->avail_min ? : 1);
+			err = wait_for_avail(substream, &avail);
+			if (err < 0)
+				goto _end_unlock;
+			if (!avail)
+				continue; /* draining */
+		}
+		frames = size > avail ? avail : size;
+		cont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;
+		if (frames > cont)
+			frames = cont;
+		if (snd_BUG_ON(!frames)) {
+			runtime->twake = 0;
+			snd_pcm_stream_unlock_irq(substream);
+			return -EINVAL;
+		}
+		appl_ptr = runtime->control->appl_ptr;
+		appl_ofs = appl_ptr % runtime->buffer_size;
+		snd_pcm_stream_unlock_irq(substream);
+		err = transfer(substream, appl_ofs, data, offset, frames);
+		snd_pcm_stream_lock_irq(substream);
+		if (err < 0)
+			goto _end_unlock;
+		switch (runtime->status->state) {
+		case SNDRV_PCM_STATE_XRUN:
+			err = -EPIPE;
+			goto _end_unlock;
+		case SNDRV_PCM_STATE_SUSPENDED:
+			err = -ESTRPIPE;
+			goto _end_unlock;
+		default:
+			break;
+		}
+		appl_ptr += frames;
+		if (appl_ptr >= runtime->boundary)
+			appl_ptr -= runtime->boundary;
+		runtime->control->appl_ptr = appl_ptr;
+		if (substream->ops->ack)
+			substream->ops->ack(substream);
+
+		offset += frames;
+		size -= frames;
+		xfer += frames;
+		avail -= frames;
+	}
+ _end_unlock:
+	runtime->twake = 0;
+	if (xfer > 0 && err >= 0)
+		snd_pcm_update_state(substream, runtime);
+	snd_pcm_stream_unlock_irq(substream);
+	return xfer > 0 ? (snd_pcm_sframes_t)xfer : err;
+}
+
+snd_pcm_sframes_t snd_pcm_lib_read(struct snd_pcm_substream *substream, void __user *buf, snd_pcm_uframes_t size)
+{
+	struct snd_pcm_runtime *runtime;
+	int nonblock;
+	int err;
+	
+	err = pcm_sanity_check(substream);
+	if (err < 0)
+		return err;
+	runtime = substream->runtime;
+	nonblock = !!(substream->f_flags & O_NONBLOCK);
+	if (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED)
+		return -EINVAL;
+	return snd_pcm_lib_read1(substream, (unsigned long)buf, size, nonblock, snd_pcm_lib_read_transfer);
+}
+
+EXPORT_SYMBOL(snd_pcm_lib_read);
+
+static int snd_pcm_lib_readv_transfer(struct snd_pcm_substream *substream,
+				      unsigned int hwoff,
+				      unsigned long data, unsigned int off,
+				      snd_pcm_uframes_t frames)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err;
+	void __user **bufs = (void __user **)data;
+	int channels = runtime->channels;
+	int c;
+	if (substream->ops->copy) {
+		for (c = 0; c < channels; ++c, ++bufs) {
+			char __user *buf;
+			if (*bufs == NULL)
+				continue;
+			buf = *bufs + samples_to_bytes(runtime, off);
+			if ((err = substream->ops->copy(substream, c, hwoff, buf, frames)) < 0)
+				return err;
+		}
+	} else {
+		snd_pcm_uframes_t dma_csize = runtime->dma_bytes / channels;
+		for (c = 0; c < channels; ++c, ++bufs) {
+			char *hwbuf;
+			char __user *buf;
+			if (*bufs == NULL)
+				continue;
+
+			hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);
+			buf = *bufs + samples_to_bytes(runtime, off);
+			if (unalign_copy_to_user(buf, hwbuf, samples_to_bytes(runtime, frames)))
+				return -EFAULT;
+		}
+	}
+	return 0;
+}
+ 
+snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
+				    void __user **bufs,
+				    snd_pcm_uframes_t frames)
+{
+	struct snd_pcm_runtime *runtime;
+	int nonblock;
+	int err;
+
+	err = pcm_sanity_check(substream);
+	if (err < 0)
+		return err;
+	runtime = substream->runtime;
+	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
+		return -EBADFD;
+
+	nonblock = !!(substream->f_flags & O_NONBLOCK);
+	if (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
+		return -EINVAL;
+	return snd_pcm_lib_read1(substream, (unsigned long)bufs, frames, nonblock, snd_pcm_lib_readv_transfer);
+}
+
+EXPORT_SYMBOL(snd_pcm_lib_readv);
+
+/*
+ * standard channel mapping helpers
+ */
+
+/* default channel maps for multi-channel playbacks, up to 8 channels */
+const struct snd_pcm_chmap_elem snd_pcm_std_chmaps[] = {
+	{ .channels = 1,
+	  .map = { SNDRV_CHMAP_MONO } },
+	{ .channels = 2,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },
+	{ .channels = 4,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
+	{ .channels = 6,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,
+		   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE } },
+	{ .channels = 8,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,
+		   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,
+		   SNDRV_CHMAP_SL, SNDRV_CHMAP_SR } },
+	{ }
+};
+EXPORT_SYMBOL_GPL(snd_pcm_std_chmaps);
+
+/* alternative channel maps with CLFE <-> surround swapped for 6/8 channels */
+const struct snd_pcm_chmap_elem snd_pcm_alt_chmaps[] = {
+	{ .channels = 1,
+	  .map = { SNDRV_CHMAP_MONO } },
+	{ .channels = 2,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },
+	{ .channels = 4,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
+	{ .channels = 6,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+		   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,
+		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
+	{ .channels = 8,
+	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+		   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,
+		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,
+		   SNDRV_CHMAP_SL, SNDRV_CHMAP_SR } },
+	{ }
+};
+EXPORT_SYMBOL_GPL(snd_pcm_alt_chmaps);
+
+static bool valid_chmap_channels(const struct snd_pcm_chmap *info, int ch)
+{
+	if (ch > info->max_channels)
+		return false;
+	return !info->channel_mask || (info->channel_mask & (1U << ch));
+}
+
+static int pcm_chmap_ctl_info(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_info *uinfo)
+{
+	struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 0;
+	uinfo->count = info->max_channels;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = SNDRV_CHMAP_LAST;
+	return 0;
+}
+
+/* get callback for channel map ctl element
+ * stores the channel position firstly matching with the current channels
+ */
+static int pcm_chmap_ctl_get(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+	unsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+	struct snd_pcm_substream *substream;
+	const struct snd_pcm_chmap_elem *map;
+
+	if (snd_BUG_ON(!info->chmap))
+		return -EINVAL;
+	substream = snd_pcm_chmap_substream(info, idx);
+	if (!substream)
+		return -ENODEV;
+	memset(ucontrol->value.integer.value, 0,
+	       sizeof(ucontrol->value.integer.value));
+	if (!substream->runtime)
+		return 0; /* no channels set */
+	for (map = info->chmap; map->channels; map++) {
+		int i;
+		if (map->channels == substream->runtime->channels &&
+		    valid_chmap_channels(info, map->channels)) {
+			for (i = 0; i < map->channels; i++)
+				ucontrol->value.integer.value[i] = map->map[i];
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+/* tlv callback for channel map ctl element
+ * expands the pre-defined channel maps in a form of TLV
+ */
+static int pcm_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,
+			     unsigned int size, unsigned int __user *tlv)
+{
+	struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+	const struct snd_pcm_chmap_elem *map;
+	unsigned int __user *dst;
+	int c, count = 0;
+
+	if (snd_BUG_ON(!info->chmap))
+		return -EINVAL;
+	if (size < 8)
+		return -ENOMEM;
+	if (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))
+		return -EFAULT;
+	size -= 8;
+	dst = tlv + 2;
+	for (map = info->chmap; map->channels; map++) {
+		int chs_bytes = map->channels * 4;
+		if (!valid_chmap_channels(info, map->channels))
+			continue;
+		if (size < 8)
+			return -ENOMEM;
+		if (put_user(SNDRV_CTL_TLVT_CHMAP_FIXED, dst) ||
+		    put_user(chs_bytes, dst + 1))
+			return -EFAULT;
+		dst += 2;
+		size -= 8;
+		count += 8;
+		if (size < chs_bytes)
+			return -ENOMEM;
+		size -= chs_bytes;
+		count += chs_bytes;
+		for (c = 0; c < map->channels; c++) {
+			if (put_user(map->map[c], dst))
+				return -EFAULT;
+			dst++;
+		}
+	}
+	if (put_user(count, tlv + 1))
+		return -EFAULT;
+	return 0;
+}
+
+static void pcm_chmap_ctl_private_free(struct snd_kcontrol *kcontrol)
+{
+	struct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);
+	info->pcm->streams[info->stream].chmap_kctl = NULL;
+	kfree(info);
+}
+
+/**
+ * snd_pcm_add_chmap_ctls - create channel-mapping control elements
+ * @pcm: the assigned PCM instance
+ * @stream: stream direction
+ * @chmap: channel map elements (for query)
+ * @max_channels: the max number of channels for the stream
+ * @private_value: the value passed to each kcontrol's private_value field
+ * @info_ret: store struct snd_pcm_chmap instance if non-NULL
+ *
+ * Create channel-mapping control elements assigned to the given PCM stream(s).
+ * Return: Zero if successful, or a negative error value.
+ */
+int snd_pcm_add_chmap_ctls(struct snd_pcm *pcm, int stream,
+			   const struct snd_pcm_chmap_elem *chmap,
+			   int max_channels,
+			   unsigned long private_value,
+			   struct snd_pcm_chmap **info_ret)
+{
+	struct snd_pcm_chmap *info;
+	struct snd_kcontrol_new knew = {
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_TLV_READ |
+			SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK,
+		.info = pcm_chmap_ctl_info,
+		.get = pcm_chmap_ctl_get,
+		.tlv.c = pcm_chmap_ctl_tlv,
+	};
+	int err;
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+	info->pcm = pcm;
+	info->stream = stream;
+	info->chmap = chmap;
+	info->max_channels = max_channels;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		knew.name = "Playback Channel Map";
+	else
+		knew.name = "Capture Channel Map";
+	knew.device = pcm->device;
+	knew.count = pcm->streams[stream].substream_count;
+	knew.private_value = private_value;
+	info->kctl = snd_ctl_new1(&knew, info);
+	if (!info->kctl) {
+		kfree(info);
+		return -ENOMEM;
+	}
+	info->kctl->private_free = pcm_chmap_ctl_private_free;
+	err = snd_ctl_add(pcm->card, info->kctl);
+	if (err < 0)
+		return err;
+	pcm->streams[stream].chmap_kctl = info->kctl;
+	if (info_ret)
+		*info_ret = info;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_pcm_add_chmap_ctls);
Index: chipram/Makefile
===================================================================
--- chipram/Makefile	(revision 182304)
+++ chipram/Makefile	(revision 182305)
@@ -712,6 +712,7 @@
 	@echo "CONFIG_UMCTL_28NM = y" >> $(obj)include/config.mk
 	@echo "CONFIG_SP9630_SPL_BASE = y" >> $(obj)include/config.mk
 	@echo "CONFIG_SECURE_BOOT = y" >> $(obj)include/config.mk
+	@echo "CONFIG_EFUSE = y" >> $(obj)include/config.mk
 sp9832a_2h12_volte_config        : preconfig
 	@$(MKCONFIG) $@ arm armv7 sp9630 spreadtrum sc9630
 	@echo "CONFIG_SPL_32K = y" >> $(obj)include/config.mk
Index: packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperCropActivity.java
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperCropActivity.java	(revision 182304)
+++ packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperCropActivity.java	(revision 182305)
@@ -523,7 +523,7 @@
 
         public void updateCropView(WallpaperCropActivity a, TileSource src) {
             Point wallpaperSize = WallpaperUtils.getDefaultWallpaperSize(
-                    a.getResources(), a.getWindowManager(), src.getImageWidth());
+                    a.getResources(), a.getWindowManager(),src.getImageWidth());
             RectF crop = Utils.getMaxCropRect(src.getImageWidth(), src.getImageHeight(),
                     wallpaperSize.x, wallpaperSize.y, false /* leftAligned */);
 
Index: packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperPickerActivity.java
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperPickerActivity.java	(revision 182304)
+++ packages/apps/Launcher3/WallpaperPicker/src/com/android/launcher3/WallpaperPickerActivity.java	(revision 182305)
@@ -26,8 +26,8 @@
 import android.content.Intent;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.content.res.Resources;
 import android.content.res.Configuration;
-import android.content.res.Resources;
 import android.database.Cursor;
 import android.database.DataSetObserver;
 import android.graphics.Bitmap;
@@ -83,7 +83,6 @@
 import com.android.launcher3.util.Thunk;
 import com.android.photos.BitmapRegionTileSource;
 import com.android.photos.BitmapRegionTileSource.BitmapSource;
-import com.sprd.ext.FeatureOption;
 import com.sprd.ext.LogUtils;
 
 import java.io.ByteArrayInputStream;
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_02_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_11_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_03_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_04_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_05_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_06_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_07_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_08_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_00.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_10.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_09_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_01.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_11.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_02.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_03.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_04.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_05.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_06.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_07.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_08.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_09.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_00_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_01_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-nodpi/wallpaper_10_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/values-iw/strings.xml
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/values-iw/strings.xml	(revision 182304)
+++ packages/apps/Launcher3/WallpaperPicker/res/values-iw/strings.xml	(revision 182305)
@@ -27,7 +27,7 @@
       <item quantity="two"> %1$d </item>
       <item quantity="many"> %1$d </item>
       <item quantity="other"> %1$d </item>
-      <item quantity="one"> %1$d </item>
+      <item quantity="one">  </item>
     </plurals>
     <string name="wallpaper_accessibility_name" msgid="4093221025304876354">" %1$d  %2$d"</string>
     <string name="announce_selection" msgid="123723511662250539">" <xliff:g id="LABEL">%1$s</xliff:g>"</string>
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_11.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_11.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_11.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_11.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_11.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_12.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_12.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_12.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_12.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_12.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_13.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_13.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_13.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_13.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_13.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/tile_shadow_top.9.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/tile_shadow_top.9.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/tile_shadow_top.9.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/tile_shadow_top.9.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/tile_shadow_top.9.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_14.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_14.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_14.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_14.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_14.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/ic_actionbar_accept.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/ic_actionbar_accept.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/ic_actionbar_accept.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/ic_actionbar_accept.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/ic_actionbar_accept.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/tile_shadow_bottom.9.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/tile_shadow_bottom.9.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/tile_shadow_bottom.9.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/tile_shadow_bottom.9.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/tile_shadow_bottom.9.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00_small.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01_small.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/ic_images.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/ic_images.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/ic_images.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/ic_images.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/ic_images.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03_small.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04_small.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05_small.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06_small.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_07_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_07_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_07_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_07_small.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_07_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_08_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_08_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_08_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_08_small.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_08_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_00.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_09_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_09_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_09_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_09_small.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_09_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_01.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_03.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_04.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_05.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_06.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_07.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_07.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_07.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_07.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_07.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_08.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_08.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_08.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_08.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_08.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_09.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_09.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_09.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_09.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_09.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_10_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_10_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_10_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_10_small.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_10_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_11_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_11_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_11_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_11_small.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_11_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_12_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_12_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_12_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_12_small.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_12_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_13_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_13_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_13_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_13_small.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_13_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_14_small.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_14_small.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_14_small.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_14_small.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_14_small.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_10.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_10.png
===================================================================
--- packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_10.png	(revision 0)
+++ packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_10.png	(revision 182305)

Property changes on: packages/apps/Launcher3/WallpaperPicker/res/drawable-xhdpi/wallpaper_10.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: packages/apps/Launcher3/src/com/android/launcher3/IconCache.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/IconCache.java	(revision 182304)
+++ packages/apps/Launcher3/src/com/android/launcher3/IconCache.java	(revision 182305)
@@ -48,12 +48,11 @@
 import com.android.launcher3.config.FeatureFlags;
 import com.android.launcher3.model.PackageItemInfo;
 import com.android.launcher3.util.ComponentKey;
-import com.android.launcher3.util.PackageManagerHelper;
 import com.android.launcher3.util.SQLiteCacheHelper;
 import com.android.launcher3.util.Thunk;
+
+import com.sprd.ext.dynamicIcon.DynamicIconUtils;
 import com.sprd.ext.FeatureOption;
-import com.sprd.ext.LogUtils;
-import com.sprd.ext.dynamicIcon.DynamicIconUtils;
 
 import java.util.Collections;
 import java.util.HashMap;
@@ -223,11 +222,6 @@
             for (LauncherActivityInfoCompat app : mLauncherApps.getActivityList(packageName, user)) {
                 addIconToDBAndMemCache(app, info, userSerial);
             }
-            if (PackageManagerHelper.isAppOnSdcard(mPackageManager, packageName)) {
-                if (LogUtils.DEBUG_ALL) LogUtils.d(TAG, "updateIconsForPkg " + packageName + ", GC begin");
-                Runtime.getRuntime().gc();
-                if (LogUtils.DEBUG_ALL) LogUtils.d(TAG, "updateIconsForPkg ExternalApp, GC end");
-            }
         } catch (NameNotFoundException e) {
             Log.d(TAG, "Package not found", e);
             return;
@@ -256,7 +250,7 @@
             // Fail if we don't have any apps
             // TODO: Fix this. Only fail for the current user.
             if (apps == null || apps.isEmpty()) {
-                continue;
+                return;
             }
 
             // Update icon cache. This happens in segments and {@link #onPackageIconsUpdated}
Index: packages/apps/Launcher3/src/com/android/launcher3/compat/UserManagerCompatVL.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/compat/UserManagerCompatVL.java	(revision 182304)
+++ packages/apps/Launcher3/src/com/android/launcher3/compat/UserManagerCompatVL.java	(revision 182305)
@@ -26,7 +26,6 @@
 
 import com.android.launcher3.Utilities;
 import com.android.launcher3.util.LongArrayMap;
-import com.sprd.ext.LogUtils;
 
 import java.util.ArrayList;
 import java.util.Collections;
Index: packages/apps/Launcher3/src/com/android/launcher3/PagedView.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/PagedView.java	(revision 182304)
+++ packages/apps/Launcher3/src/com/android/launcher3/PagedView.java	(revision 182305)
@@ -861,11 +861,11 @@
                         childHeightMode = MeasureSpec.EXACTLY;
                     }
 
-                    childWidth = getViewportWidth() - horizontalPadding
-                            - mInsets.left - mInsets.right;
-                    childHeight = getViewportHeight() - verticalPadding
-                            - mInsets.top - mInsets.bottom;
-                    mNormalChildHeight = childHeight;
+                        childWidth = getViewportWidth() - horizontalPadding
+                                - mInsets.left - mInsets.right;
+                        childHeight = getViewportHeight() - verticalPadding
+                                - mInsets.top - mInsets.bottom;
+                        mNormalChildHeight = childHeight;
                 } else {
                     childWidthMode = MeasureSpec.EXACTLY;
                     childHeightMode = MeasureSpec.EXACTLY;
@@ -922,7 +922,7 @@
                 lp = (LayoutParams) child.getLayoutParams();
                 int childTop;
                 if (lp.isFullScreenPage) {
-                    childTop = offsetY;
+                        childTop = offsetY;
                 } else {
                     childTop = offsetY + getPaddingTop() + mInsets.top;
                     if (mCenterPagesVertically) {
Index: packages/apps/Launcher3/src/com/android/launcher3/CellLayout.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/CellLayout.java	(revision 182304)
+++ packages/apps/Launcher3/src/com/android/launcher3/CellLayout.java	(revision 182305)
@@ -171,6 +171,7 @@
     private DragAndDropAccessibilityDelegate mTouchHelper;
     private boolean mUseTouchHelper = false;
 
+
     public CellLayout(Context context) {
         this(context, null);
     }
@@ -876,6 +877,7 @@
             mHeightGap = mOriginalHeightGap;
         }
 
+
         // Make the feedback view large enough to hold the blur bitmap.
         mTouchFeedbackView.measure(
                 MeasureSpec.makeMeasureSpec(mCellWidth + mTouchFeedbackView.getExtraSize(),
@@ -1060,20 +1062,14 @@
         final int oldDragCellX = mDragCell[0];
         final int oldDragCellY = mDragCell[1];
 
-        if (dragOutline == null) {
+        if (dragOutline == null && v == null) {
             return;
         }
 
         if (cellX != oldDragCellX || cellY != oldDragCellY) {
-            DragView dragView = dragObject.dragView;
-            Point dragOffset = null;
-            Rect dragRegion = null;
+            Point dragOffset = dragObject.dragView.getDragVisualizeOffset();
+            Rect dragRegion = dragObject.dragView.getDragRegion();
 
-            if (dragView != null) {
-                dragOffset = dragObject.dragView.getDragVisualizeOffset();
-                dragRegion = dragObject.dragView.getDragRegion();
-            }
-
             mDragCell[0] = cellX;
             mDragCell[1] = cellY;
             // Find the top left corner of the rect the object will occupy
@@ -3018,4 +3014,8 @@
 
         return true;
     }
+
+
+
+
 }
Index: packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java	(revision 182304)
+++ packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java	(revision 182305)
@@ -250,8 +250,7 @@
         textPaint.setTextSize(iconTextSizePx);
         FontMetrics fm = textPaint.getFontMetrics();
         cellWidthPx = iconSizePx;
-        cellHeightPx = iconSizePx + iconDrawablePaddingPx + (int) Math.ceil(fm.bottom - fm.top) +
-                res.getDimensionPixelSize(R.dimen.adjust_cell_height);
+        cellHeightPx = iconSizePx + iconDrawablePaddingPx + (int) Math.ceil(fm.bottom - fm.top);
         final float scaleDps = res.getDimensionPixelSize(R.dimen.dragViewScale);
         dragViewScale = (iconSizePx + scaleDps) / iconSizePx;
 
@@ -268,11 +267,7 @@
                 (availableWidthPx - 4 * edgeMarginPx) / inv.numFolderColumns);
         folderCellHeightPx = cellHeightPx + edgeMarginPx;
         folderBackgroundOffset = -edgeMarginPx;
-        if (isVerticalBarLayout()) {
-            folderIconSizePx = iconSizePx;
-        } else {
-            folderIconSizePx = iconSizePx + 2 * -folderBackgroundOffset;
-        }
+        folderIconSizePx = iconSizePx + 2 * -folderBackgroundOffset;
     }
 
     /**
Index: packages/apps/Launcher3/src/com/android/launcher3/FolderIcon.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/FolderIcon.java	(revision 182304)
+++ packages/apps/Launcher3/src/com/android/launcher3/FolderIcon.java	(revision 182305)
@@ -0,0 +1,826 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.launcher3;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.ValueAnimator;
+import android.animation.ValueAnimator.AnimatorUpdateListener;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Point;
+import android.graphics.PorterDuff;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.os.Looper;
+import android.os.Parcelable;
+import android.util.AttributeSet;
+import android.view.LayoutInflater;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.ViewGroup;
+import android.view.animation.AccelerateInterpolator;
+import android.view.animation.DecelerateInterpolator;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.android.launcher3.DropTarget.DragObject;
+import com.android.launcher3.FolderInfo.FolderListener;
+import com.android.launcher3.util.Thunk;
+
+import com.sprd.ext.UtilitiesExt;
+import com.sprd.ext.dynamicIcon.DynamicIconUtils;
+import com.sprd.ext.foldername.FolderNameUtils;
+import com.sprd.ext.FeatureOption;
+import com.sprd.ext.LogUtils;
+import com.sprd.ext.unreadnotifier.UnreadLoaderUtils;
+
+import java.util.ArrayList;
+
+/**
+ * An icon that can appear on in the workspace representing an {@link UserFolder}.
+ */
+public class FolderIcon extends FrameLayout implements FolderListener {
+    @Thunk Launcher mLauncher;
+    @Thunk Folder mFolder;
+    private FolderInfo mInfo;
+    @Thunk static boolean sStaticValuesDirty = true;
+
+    private CheckLongPressHelper mLongPressHelper;
+    private StylusEventHelper mStylusEventHelper;
+
+    // The number of icons to display in the
+    public static final int NUM_ITEMS_IN_PREVIEW = 3;
+    private static final int CONSUMPTION_ANIMATION_DURATION = 100;
+    private static final int DROP_IN_ANIMATION_DURATION = 400;
+    private static final int INITIAL_ITEM_ANIMATION_DURATION = 350;
+    private static final int FINAL_ITEM_ANIMATION_DURATION = 200;
+
+    // The degree to which the inner ring grows when accepting drop
+    private static final float INNER_RING_GROWTH_FACTOR = 0.15f;
+
+    // The degree to which the outer ring is scaled in its natural state
+    private static final float OUTER_RING_GROWTH_FACTOR = 0.3f;
+
+    // The amount of vertical spread between items in the stack [0...1]
+    private static final float PERSPECTIVE_SHIFT_FACTOR = 0.18f;
+
+    // Flag as to whether or not to draw an outer ring. Currently none is designed.
+    public static final boolean HAS_OUTER_RING = true;
+
+    // Flag whether the folder should open itself when an item is dragged over is enabled.
+    public static final boolean SPRING_LOADING_ENABLED = true;
+
+    // The degree to which the item in the back of the stack is scaled [0...1]
+    // (0 means it's not scaled at all, 1 means it's scaled to nothing)
+    private static final float PERSPECTIVE_SCALE_FACTOR = 0.35f;
+
+    // Delay when drag enters until the folder opens, in miliseconds.
+    private static final int ON_OPEN_DELAY = 800;
+
+    public static Drawable sSharedFolderLeaveBehind = null;
+
+    @Thunk ImageView mPreviewBackground;
+    @Thunk BubbleTextView mFolderName;
+
+    FolderRingAnimator mFolderRingAnimator = null;
+    private static final String TAG = "Launcher.FolderIcon";
+
+    // These variables are all associated with the drawing of the preview; they are stored
+    // as member variables for shared usage and to avoid computation on each frame
+    private int mIntrinsicIconSize;
+    private float mBaselineIconScale;
+    private int mBaselineIconSize;
+    private int mAvailableSpaceInPreview;
+    private int mTotalWidth = -1;
+    private int mPreviewOffsetX;
+    private int mPreviewOffsetY;
+    private float mMaxPerspectiveShift;
+    boolean mAnimating = false;
+    private Rect mOldBounds = new Rect();
+
+    private float mSlop;
+
+    private PreviewItemDrawingParams mParams = new PreviewItemDrawingParams(0, 0, 0, 0);
+    @Thunk PreviewItemDrawingParams mAnimParams = new PreviewItemDrawingParams(0, 0, 0, 0);
+    @Thunk ArrayList<ShortcutInfo> mHiddenItems = new ArrayList<ShortcutInfo>();
+
+    private Alarm mOpenAlarm = new Alarm();
+    @Thunk ItemInfo mDragInfo;
+
+    public FolderIcon(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init();
+    }
+
+    public FolderIcon(Context context) {
+        super(context);
+        init();
+    }
+
+    private void init() {
+        mLongPressHelper = new CheckLongPressHelper(this);
+        mStylusEventHelper = new StylusEventHelper(this);
+        setAccessibilityDelegate(LauncherAppState.getInstance().getAccessibilityDelegate());
+    }
+
+    public boolean isDropEnabled() {
+        final ViewGroup cellLayoutChildren = (ViewGroup) getParent();
+        final ViewGroup cellLayout = (ViewGroup) cellLayoutChildren.getParent();
+        final Workspace workspace = (Workspace) cellLayout.getParent();
+        return !workspace.workspaceInModalState();
+    }
+
+    static FolderIcon fromXml(int resId, Launcher launcher, ViewGroup group,
+            FolderInfo folderInfo, IconCache iconCache) {
+        @SuppressWarnings("all") // suppress dead code warning
+        final boolean error = INITIAL_ITEM_ANIMATION_DURATION >= DROP_IN_ANIMATION_DURATION;
+        if (error) {
+            throw new IllegalStateException("DROP_IN_ANIMATION_DURATION must be greater than " +
+                    "INITIAL_ITEM_ANIMATION_DURATION, as sequencing of adding first two items " +
+                    "is dependent on this");
+        }
+
+        DeviceProfile grid = launcher.getDeviceProfile();
+
+        FolderIcon icon = (FolderIcon) LayoutInflater.from(launcher).inflate(resId, group, false);
+        icon.setClipToPadding(false);
+        icon.mFolderName = (BubbleTextView) icon.findViewById(R.id.folder_icon_name);
+        FolderNameUtils.updateFolderTitle(launcher, folderInfo);
+        icon.mFolderName.setText(folderInfo.title);
+        icon.mFolderName.setCompoundDrawablePadding(0);
+        FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) icon.mFolderName.getLayoutParams();
+        lp.topMargin = grid.iconSizePx + grid.iconDrawablePaddingPx;
+
+        // Offset the preview background to center this view accordingly
+        icon.mPreviewBackground = (ImageView) icon.findViewById(R.id.preview_background);
+        lp = (FrameLayout.LayoutParams) icon.mPreviewBackground.getLayoutParams();
+        lp.topMargin = grid.folderBackgroundOffset;
+        lp.width = grid.folderIconSizePx;
+        lp.height = grid.folderIconSizePx;
+
+        icon.setTag(folderInfo);
+        icon.setOnClickListener(launcher);
+        icon.mInfo = folderInfo;
+        icon.mLauncher = launcher;
+        icon.setContentDescription(String.format(launcher.getString(R.string.folder_name_format),
+                folderInfo.title));
+        Folder folder = Folder.fromXml(launcher);
+        folder.setDragController(launcher.getDragController());
+        folder.setFolderIcon(icon);
+        folder.bind(folderInfo);
+        icon.mFolder = folder;
+
+        icon.mFolderRingAnimator = new FolderRingAnimator(launcher, icon);
+        folderInfo.addListener(icon);
+
+        icon.setOnFocusChangeListener(launcher.mFocusHandler);
+        return icon;
+    }
+
+    @Override
+    protected Parcelable onSaveInstanceState() {
+        sStaticValuesDirty = true;
+        return super.onSaveInstanceState();
+    }
+
+    public static class FolderRingAnimator {
+        public int mCellX;
+        public int mCellY;
+        @Thunk CellLayout mCellLayout;
+        public float mOuterRingSize;
+        public float mInnerRingSize;
+        public FolderIcon mFolderIcon = null;
+        public static Drawable sSharedOuterRingDrawable = null;
+        public static Drawable sSharedInnerRingDrawable = null;
+        public static int sPreviewSize = -1;
+        public static int sPreviewPadding = -1;
+
+        private ValueAnimator mAcceptAnimator;
+        private ValueAnimator mNeutralAnimator;
+
+        public FolderRingAnimator(Launcher launcher, FolderIcon folderIcon) {
+            mFolderIcon = folderIcon;
+            Resources res = launcher.getResources();
+
+            // We need to reload the static values when configuration changes in case they are
+            // different in another configuration
+            if (sStaticValuesDirty) {
+                if (Looper.myLooper() != Looper.getMainLooper()) {
+                    throw new RuntimeException("FolderRingAnimator loading drawables on non-UI thread "
+                            + Thread.currentThread());
+                }
+
+                DeviceProfile grid = launcher.getDeviceProfile();
+                sPreviewSize = grid.folderIconSizePx;
+                sPreviewPadding = res.getDimensionPixelSize(R.dimen.folder_preview_padding);
+                sSharedOuterRingDrawable = res.getDrawable(R.drawable.portal_ring_outer);
+                sSharedInnerRingDrawable = res.getDrawable(R.drawable.portal_ring_inner_nolip);
+                sSharedFolderLeaveBehind = res.getDrawable(R.drawable.portal_ring_rest);
+                sStaticValuesDirty = false;
+            }
+        }
+
+        public void animateToAcceptState() {
+            if (mNeutralAnimator != null) {
+                mNeutralAnimator.cancel();
+            }
+            mAcceptAnimator = LauncherAnimUtils.ofFloat(mCellLayout, 0f, 1f);
+            mAcceptAnimator.setDuration(CONSUMPTION_ANIMATION_DURATION);
+
+            final int previewSize = sPreviewSize;
+            mAcceptAnimator.addUpdateListener(new AnimatorUpdateListener() {
+                public void onAnimationUpdate(ValueAnimator animation) {
+                    final float percent = (Float) animation.getAnimatedValue();
+                    mOuterRingSize = (1 + percent * OUTER_RING_GROWTH_FACTOR) * previewSize;
+                    mInnerRingSize = (1 + percent * INNER_RING_GROWTH_FACTOR) * previewSize;
+                    if (mCellLayout != null) {
+                        mCellLayout.invalidate();
+                    }
+                }
+            });
+            mAcceptAnimator.addListener(new AnimatorListenerAdapter() {
+                @Override
+                public void onAnimationStart(Animator animation) {
+                    if (mFolderIcon != null) {
+                        mFolderIcon.mPreviewBackground.setVisibility(INVISIBLE);
+                    }
+                }
+            });
+            mAcceptAnimator.start();
+        }
+
+        public void animateToNaturalState() {
+            if (mAcceptAnimator != null) {
+                mAcceptAnimator.cancel();
+            }
+            mNeutralAnimator = LauncherAnimUtils.ofFloat(mCellLayout, 0f, 1f);
+            mNeutralAnimator.setDuration(CONSUMPTION_ANIMATION_DURATION);
+
+            final int previewSize = sPreviewSize;
+            mNeutralAnimator.addUpdateListener(new AnimatorUpdateListener() {
+                public void onAnimationUpdate(ValueAnimator animation) {
+                    final float percent = (Float) animation.getAnimatedValue();
+                    mOuterRingSize = (1 + (1 - percent) * OUTER_RING_GROWTH_FACTOR) * previewSize;
+                    mInnerRingSize = (1 + (1 - percent) * INNER_RING_GROWTH_FACTOR) * previewSize;
+                    if (mCellLayout != null) {
+                        mCellLayout.invalidate();
+                    }
+                }
+            });
+            mNeutralAnimator.addListener(new AnimatorListenerAdapter() {
+                @Override
+                public void onAnimationEnd(Animator animation) {
+                    if (mCellLayout != null) {
+                        mCellLayout.hideFolderAccept(FolderRingAnimator.this);
+                    }
+                    if (mFolderIcon != null) {
+                        mFolderIcon.mPreviewBackground.setVisibility(VISIBLE);
+                    }
+                }
+            });
+            mNeutralAnimator.start();
+        }
+
+        // Location is expressed in window coordinates
+        public void getCell(int[] loc) {
+            loc[0] = mCellX;
+            loc[1] = mCellY;
+        }
+
+        // Location is expressed in window coordinates
+        public void setCell(int x, int y) {
+            mCellX = x;
+            mCellY = y;
+        }
+
+        public void setCellLayout(CellLayout layout) {
+            mCellLayout = layout;
+        }
+
+        public float getOuterRingSize() {
+            return mOuterRingSize;
+        }
+
+        public float getInnerRingSize() {
+            return mInnerRingSize;
+        }
+    }
+
+    public Folder getFolder() {
+        return mFolder;
+    }
+
+    public FolderInfo getFolderInfo() {
+        return mInfo;
+    }
+
+    private boolean willAcceptItem(ItemInfo item) {
+        final int itemType = item.itemType;
+        return ((itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
+                itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) &&
+                !mFolder.isFull() && item != mInfo && !mInfo.opened);
+    }
+
+    public boolean acceptDrop(Object dragInfo) {
+        final ItemInfo item = (ItemInfo) dragInfo;
+        return !mFolder.isDestroyed() && willAcceptItem(item);
+    }
+
+    public void addItem(ShortcutInfo item) {
+        mInfo.add(item);
+    }
+
+    public void onDragEnter(Object dragInfo) {
+        if (mFolder.isDestroyed() || !willAcceptItem((ItemInfo) dragInfo)) return;
+        CellLayout.LayoutParams lp = (CellLayout.LayoutParams) getLayoutParams();
+        CellLayout layout = (CellLayout) getParent().getParent();
+        mFolderRingAnimator.setCell(lp.cellX, lp.cellY);
+        mFolderRingAnimator.setCellLayout(layout);
+        mFolderRingAnimator.animateToAcceptState();
+        layout.showFolderAccept(mFolderRingAnimator);
+        mOpenAlarm.setOnAlarmListener(mOnOpenListener);
+        if (SPRING_LOADING_ENABLED &&
+                ((dragInfo instanceof AppInfo) || (dragInfo instanceof ShortcutInfo))) {
+            // TODO: we currently don't support spring-loading for PendingAddShortcutInfos even
+            // though widget-style shortcuts can be added to folders. The issue is that we need
+            // to deal with configuration activities which are currently handled in
+            // Workspace#onDropExternal.
+            mOpenAlarm.setAlarm(ON_OPEN_DELAY);
+        }
+        mDragInfo = (ItemInfo) dragInfo;
+    }
+
+    public void onDragOver(Object dragInfo) {
+    }
+
+    OnAlarmListener mOnOpenListener = new OnAlarmListener() {
+        public void onAlarm(Alarm alarm) {
+            ShortcutInfo item;
+            if (mDragInfo instanceof AppInfo) {
+                // Came from all apps -- make a copy.
+                item = ((AppInfo) mDragInfo).makeShortcut();
+                item.spanX = 1;
+                item.spanY = 1;
+            } else {
+                // ShortcutInfo
+                item = (ShortcutInfo) mDragInfo;
+            }
+            mFolder.beginExternalDrag(item);
+            mLauncher.openFolder(FolderIcon.this);
+        }
+    };
+
+    public void performCreateAnimation(final ShortcutInfo destInfo, final View destView,
+            final ShortcutInfo srcInfo, final DragView srcView, Rect dstRect,
+            float scaleRelativeToDragLayer, Runnable postAnimationRunnable) {
+
+        // These correspond two the drawable and view that the icon was dropped _onto_
+        Drawable animateDrawable = getTopDrawable((TextView) destView);
+        computePreviewDrawingParams(animateDrawable.getIntrinsicWidth(),
+                destView.getMeasuredWidth());
+
+        // This will animate the first item from it's position as an icon into its
+        // position as the first item in the preview
+        animateFirstItem(animateDrawable, INITIAL_ITEM_ANIMATION_DURATION, false, null);
+        addItem(destInfo);
+
+        // This will animate the dragView (srcView) into the new folder
+        onDrop(srcInfo, srcView, dstRect, scaleRelativeToDragLayer, 1, postAnimationRunnable, null);
+    }
+
+    public void performDestroyAnimation(final View finalView, Runnable onCompleteRunnable) {
+        Drawable animateDrawable = getTopDrawable((TextView) finalView);
+        computePreviewDrawingParams(animateDrawable.getIntrinsicWidth(),
+                finalView.getMeasuredWidth());
+
+        // This will animate the first item from it's position as an icon into its
+        // position as the first item in the preview
+        animateFirstItem(animateDrawable, FINAL_ITEM_ANIMATION_DURATION, true,
+                onCompleteRunnable);
+    }
+
+    public void onDragExit(Object dragInfo) {
+        onDragExit();
+    }
+
+    public void onDragExit() {
+        mFolderRingAnimator.animateToNaturalState();
+        mOpenAlarm.cancelAlarm();
+    }
+
+    private void onDrop(final ShortcutInfo item, DragView animateView, Rect finalRect,
+            float scaleRelativeToDragLayer, int index, Runnable postAnimationRunnable,
+            DragObject d) {
+        item.cellX = -1;
+        item.cellY = -1;
+
+        // Typically, the animateView corresponds to the DragView; however, if this is being done
+        // after a configuration activity (ie. for a Shortcut being dragged from AllApps) we
+        // will not have a view to animate
+        if (animateView != null) {
+            DragLayer dragLayer = mLauncher.getDragLayer();
+            Rect from = new Rect();
+            dragLayer.getViewRectRelativeToSelf(animateView, from);
+            Rect to = finalRect;
+            if (to == null) {
+                to = new Rect();
+                Workspace workspace = mLauncher.getWorkspace();
+                // Set cellLayout and this to it's final state to compute final animation locations
+                if (getParent() != null) {
+                    workspace.setFinalTransitionTransform((CellLayout) getParent().getParent());
+                }
+                float scaleX = getScaleX();
+                float scaleY = getScaleY();
+                setScaleX(1.0f);
+                setScaleY(1.0f);
+                scaleRelativeToDragLayer = dragLayer.getDescendantRectRelativeToSelf(this, to);
+                // Finished computing final animation locations, restore current state
+                setScaleX(scaleX);
+                setScaleY(scaleY);
+                if (getParent() != null) {
+                    workspace.resetTransitionTransform((CellLayout) getParent().getParent());
+                }
+            }
+
+            int[] center = new int[2];
+            float scale = getLocalCenterForIndex(index, center);
+            center[0] = (int) Math.round(scaleRelativeToDragLayer * center[0]);
+            center[1] = (int) Math.round(scaleRelativeToDragLayer * center[1]);
+
+            to.offset(center[0] - animateView.getMeasuredWidth() / 2,
+                      center[1] - animateView.getMeasuredHeight() / 2);
+
+            float finalAlpha = index < NUM_ITEMS_IN_PREVIEW ? 0.5f : 0f;
+
+            float finalScale = scale * scaleRelativeToDragLayer;
+            dragLayer.animateView(animateView, from, to, finalAlpha,
+                    1, 1, finalScale, finalScale, DROP_IN_ANIMATION_DURATION,
+                    new DecelerateInterpolator(2), new AccelerateInterpolator(2),
+                    postAnimationRunnable, DragLayer.ANIMATION_END_DISAPPEAR, null);
+            addItem(item);
+            mHiddenItems.add(item);
+            mFolder.hideItem(item);
+            postDelayed(new Runnable() {
+                public void run() {
+                    mHiddenItems.remove(item);
+                    mFolder.showItem(item);
+                    invalidate();
+                }
+            }, DROP_IN_ANIMATION_DURATION);
+        } else {
+            addItem(item);
+        }
+    }
+
+    public void onDrop(DragObject d) {
+        ShortcutInfo item;
+        if (d.dragInfo instanceof AppInfo) {
+            // Came from all apps -- make a copy
+            item = ((AppInfo) d.dragInfo).makeShortcut();
+        } else {
+            item = (ShortcutInfo) d.dragInfo;
+        }
+        mFolder.notifyDrop();
+        onDrop(item, d.dragView, null, 1.0f, mInfo.contents.size(), d.postAnimationRunnable, d);
+    }
+
+    private void computePreviewDrawingParams(int drawableSize, int totalSize) {
+        if (mIntrinsicIconSize != drawableSize || mTotalWidth != totalSize) {
+            DeviceProfile grid = mLauncher.getDeviceProfile();
+
+            mIntrinsicIconSize = drawableSize;
+            mTotalWidth = totalSize;
+
+            final int previewSize = mPreviewBackground.getLayoutParams().height;
+            final int previewPadding = FolderRingAnimator.sPreviewPadding;
+
+            mAvailableSpaceInPreview = (previewSize - 2 * previewPadding);
+            // cos(45) = 0.707  + ~= 0.1) = 0.8f
+            int adjustedAvailableSpace = (int) ((mAvailableSpaceInPreview / 2) * (1 + 0.8f));
+
+            int unscaledHeight = (int) (mIntrinsicIconSize * (1 + PERSPECTIVE_SHIFT_FACTOR));
+
+            mBaselineIconScale = (1.0f * adjustedAvailableSpace / unscaledHeight);
+
+            mBaselineIconSize = (int) (mIntrinsicIconSize * mBaselineIconScale);
+            mMaxPerspectiveShift = mBaselineIconSize * PERSPECTIVE_SHIFT_FACTOR;
+
+            mPreviewOffsetX = (mTotalWidth - mAvailableSpaceInPreview) / 2;
+            mPreviewOffsetY = previewPadding + grid.folderBackgroundOffset;
+        }
+    }
+
+    private void computePreviewDrawingParams(Drawable d) {
+        computePreviewDrawingParams(d.getIntrinsicWidth(), getMeasuredWidth());
+    }
+
+    class PreviewItemDrawingParams {
+        PreviewItemDrawingParams(float transX, float transY, float scale, float overlayAlpha) {
+            this.transX = transX;
+            this.transY = transY;
+            this.scale = scale;
+            this.overlayAlpha = overlayAlpha;
+        }
+        float transX;
+        float transY;
+        float scale;
+        float overlayAlpha;
+        Drawable drawable;
+    }
+
+    private float getLocalCenterForIndex(int index, int[] center) {
+        mParams = computePreviewItemDrawingParams(Math.min(NUM_ITEMS_IN_PREVIEW, index), mParams);
+
+        mParams.transX += mPreviewOffsetX;
+        mParams.transY += mPreviewOffsetY;
+        float offsetX = mParams.transX + (mParams.scale * mIntrinsicIconSize) / 2;
+        float offsetY = mParams.transY + (mParams.scale * mIntrinsicIconSize) / 2;
+
+        center[0] = (int) Math.round(offsetX);
+        center[1] = (int) Math.round(offsetY);
+        return mParams.scale;
+    }
+
+    private PreviewItemDrawingParams computePreviewItemDrawingParams(int index,
+            PreviewItemDrawingParams params) {
+        index = NUM_ITEMS_IN_PREVIEW - index - 1;
+        float r = (index * 1.0f) / (NUM_ITEMS_IN_PREVIEW - 1);
+        float scale = (1 - PERSPECTIVE_SCALE_FACTOR * (1 - r));
+
+        float offset = (1 - r) * mMaxPerspectiveShift;
+        float scaledSize = scale * mBaselineIconSize;
+        float scaleOffsetCorrection = (1 - scale) * mBaselineIconSize;
+
+        // We want to imagine our coordinates from the bottom left, growing up and to the
+        // right. This is natural for the x-axis, but for the y-axis, we have to invert things.
+        float transY = mAvailableSpaceInPreview - (offset + scaledSize + scaleOffsetCorrection) + getPaddingTop();
+        float transX = (mAvailableSpaceInPreview - scaledSize) / 2;
+        float totalScale = mBaselineIconScale * scale;
+        final float overlayAlpha = (80 * (1 - r)) / 255f;
+
+        if (params == null) {
+            params = new PreviewItemDrawingParams(transX, transY, totalScale, overlayAlpha);
+        } else {
+            params.transX = transX;
+            params.transY = transY;
+            params.scale = totalScale;
+            params.overlayAlpha = overlayAlpha;
+        }
+        return params;
+    }
+
+    private void drawPreviewItem(Canvas canvas, PreviewItemDrawingParams params, TextView textView) {
+        canvas.save();
+        canvas.translate(params.transX + mPreviewOffsetX, params.transY + mPreviewOffsetY);
+        canvas.scale(params.scale, params.scale);
+        Drawable d = params.drawable;
+
+        if (d != null) {
+            mOldBounds.set(d.getBounds());
+            d.setBounds(0, 0, mIntrinsicIconSize, mIntrinsicIconSize);
+            if (d instanceof FastBitmapDrawable) {
+                FastBitmapDrawable fd = (FastBitmapDrawable) d;
+                float oldBrightness = fd.getBrightness();
+                fd.setBrightness(params.overlayAlpha);
+                d.draw(canvas);
+                fd.setBrightness(oldBrightness);
+            } else {
+                d.setColorFilter(Color.argb((int) (params.overlayAlpha * 255), 255, 255, 255),
+                        PorterDuff.Mode.SRC_ATOP);
+                d.draw(canvas);
+                d.clearColorFilter();
+            }
+            d.setBounds(mOldBounds);
+        }
+        canvas.restore();
+
+        if (FeatureOption.SPRD_DYNAMIC_ICON_SUPPORT) {
+            if (textView != null) {
+                Object tag = textView.getTag();
+                if (tag instanceof ItemInfo) {
+                    ItemInfo info = (ItemInfo) tag;
+                    if (info.dynamicIconDrawCallback != null) {
+                        drawDynamicPartOfIcon(canvas, params, textView);
+                    }
+                }
+            }
+        }
+    }
+
+    private void drawDynamicPartOfIcon(Canvas canvas, PreviewItemDrawingParams params, TextView textView) {
+        float offsetX = params.transX + mPreviewOffsetX + (params.scale * mIntrinsicIconSize) / 2;
+        float offsetY = params.transY + mPreviewOffsetY + (params.scale * mIntrinsicIconSize) / 2;
+        canvas.save();
+        Point center = new Point(Math.round(offsetX), Math.round(offsetY));
+        DynamicIconUtils.drawDynamicIconIfNeed(canvas, textView, params.scale, center);
+        canvas.restore();
+    }
+
+    @Override
+    protected void dispatchDraw(Canvas canvas) {
+        super.dispatchDraw(canvas);
+
+        if (mFolder == null) return;
+        if (mFolder.getItemCount() == 0 && !mAnimating) return;
+
+        ArrayList<View> items = mFolder.getItemsInReadingOrder();
+        Drawable d;
+        TextView v;
+
+        // Update our drawing parameters if necessary
+        if (mAnimating) {
+            computePreviewDrawingParams(mAnimParams.drawable);
+        } else {
+            v = (TextView) items.get(0);
+            d = getTopDrawable(v);
+            computePreviewDrawingParams(d);
+        }
+
+        int nItemsInPreview = Math.min(items.size(), NUM_ITEMS_IN_PREVIEW);
+        if (!mAnimating) {
+            for (int i = nItemsInPreview - 1; i >= 0; i--) {
+                v = (TextView) items.get(i);
+                if (!mHiddenItems.contains(v.getTag())) {
+                    d = getTopDrawable(v);
+                    mParams = computePreviewItemDrawingParams(i, mParams);
+                    mParams.drawable = d;
+                    drawPreviewItem(canvas, mParams, v);
+                }
+            }
+        } else {
+            drawPreviewItem(canvas, mAnimParams, null);
+        }
+        UtilitiesExt.drawDebugRect(canvas, getIconRect(), Color.GREEN);
+        if (FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
+            UnreadLoaderUtils.drawUnreadEventIfNeed(canvas, this);
+        }
+    }
+
+    private Drawable getTopDrawable(TextView v) {
+        Drawable d = v.getCompoundDrawables()[1];
+        return (d instanceof PreloadIconDrawable) ? ((PreloadIconDrawable) d).mIcon : d;
+    }
+
+    private void animateFirstItem(final Drawable d, int duration, final boolean reverse,
+            final Runnable onCompleteRunnable) {
+        final PreviewItemDrawingParams finalParams = computePreviewItemDrawingParams(0, null);
+
+        float iconSize = mLauncher.getDeviceProfile().iconSizePx;
+        final float scale0 = iconSize / d.getIntrinsicWidth() ;
+        final float transX0 = (mAvailableSpaceInPreview - iconSize) / 2;
+        final float transY0 = (mAvailableSpaceInPreview - iconSize) / 2 + getPaddingTop();
+        mAnimParams.drawable = d;
+
+        ValueAnimator va = LauncherAnimUtils.ofFloat(this, 0f, 1.0f);
+        va.addUpdateListener(new AnimatorUpdateListener(){
+            public void onAnimationUpdate(ValueAnimator animation) {
+                float progress = (Float) animation.getAnimatedValue();
+                if (reverse) {
+                    progress = 1 - progress;
+                    mPreviewBackground.setAlpha(progress);
+                }
+
+                mAnimParams.transX = transX0 + progress * (finalParams.transX - transX0);
+                mAnimParams.transY = transY0 + progress * (finalParams.transY - transY0);
+                mAnimParams.scale = scale0 + progress * (finalParams.scale - scale0);
+                invalidate();
+            }
+        });
+        va.addListener(new AnimatorListenerAdapter() {
+            @Override
+            public void onAnimationStart(Animator animation) {
+                mAnimating = true;
+            }
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                mAnimating = false;
+                if (onCompleteRunnable != null) {
+                    onCompleteRunnable.run();
+                }
+            }
+        });
+        va.setDuration(duration);
+        va.start();
+    }
+
+    public void setTextVisible(boolean visible) {
+        if (visible) {
+            mFolderName.setVisibility(VISIBLE);
+        } else {
+            mFolderName.setVisibility(INVISIBLE);
+        }
+    }
+
+    public boolean getTextVisible() {
+        return mFolderName.getVisibility() == VISIBLE;
+    }
+
+    public void onItemsChanged() {
+        invalidate();
+        requestLayout();
+    }
+
+    public void onAdd(ShortcutInfo item) {
+        if (LogUtils.DEBUG) {
+            LogUtils.d(TAG, "onAdd item = " + item);
+        }
+        if (FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
+            UnreadLoaderUtils.updateFolderUnreadNum(this, item.intent.getComponent(), item.unreadNum);
+        }
+        invalidate();
+        requestLayout();
+    }
+
+    public void onRemove(ShortcutInfo item) {
+        if (LogUtils.DEBUG) {
+            LogUtils.d(TAG, "onRemove item = " + item);
+        }
+        if (FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
+            UnreadLoaderUtils.updateFolderUnreadNum(this, item.intent.getComponent(), item.unreadNum);
+        }
+        invalidate();
+        requestLayout();
+    }
+
+    public void onTitleChanged(CharSequence title) {
+        mFolderName.setText(title);
+        setContentDescription(String.format(getContext().getString(R.string.folder_name_format),
+                title));
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        // Call the superclass onTouchEvent first, because sometimes it changes the state to
+        // isPressed() on an ACTION_UP
+        boolean result = super.onTouchEvent(event);
+
+        // Check for a stylus button press, if it occurs cancel any long press checks.
+        if (mStylusEventHelper.checkAndPerformStylusEvent(event)) {
+            mLongPressHelper.cancelLongPress();
+            return true;
+        }
+
+        switch (event.getAction()) {
+            case MotionEvent.ACTION_DOWN:
+                mLongPressHelper.postCheckForLongPress();
+                break;
+            case MotionEvent.ACTION_CANCEL:
+            case MotionEvent.ACTION_UP:
+                mLongPressHelper.cancelLongPress();
+                break;
+            case MotionEvent.ACTION_MOVE:
+                if (!Utilities.pointInView(this, event.getX(), event.getY(), mSlop)) {
+                    mLongPressHelper.cancelLongPress();
+                }
+                break;
+        }
+        return result;
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        mSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();
+    }
+
+    @Override
+    public void cancelLongPress() {
+        super.cancelLongPress();
+
+        mLongPressHelper.cancelLongPress();
+    }
+
+    public Rect getIconRect() {
+        DeviceProfile grid = mLauncher.getDeviceProfile();
+        int iconSize = grid.folderIconSizePx;
+
+        Point center = new Point(getScrollX() + (getWidth() >> 1),
+                getScrollY() + getPaddingTop() + (iconSize >> 1));
+        Rect iconRect = new Rect();
+
+        iconRect.left   = center.x - (iconSize >> 1);
+        iconRect.top    = center.y - (iconSize >> 1);
+        iconRect.right  = iconRect.left + iconSize;
+        iconRect.bottom = iconRect.top + iconSize;
+        return iconRect;
+    }
+}
Index: packages/apps/Launcher3/src/com/android/launcher3/InstallShortcutReceiver.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/InstallShortcutReceiver.java	(revision 182304)
+++ packages/apps/Launcher3/src/com/android/launcher3/InstallShortcutReceiver.java	(revision 182305)
@@ -287,13 +287,12 @@
             final UserHandleCompat extraUser = UserHandleCompat.fromIntent(data);
             if (extraUser != null) {
                 long userId = UserManagerCompat.getInstance(mContext).getSerialNumberForUser(extraUser);
-            if (launchIntent != null) {
                 launchIntent.putExtra(ShortcutInfo.EXTRA_PROFILE, userId);
+                if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo extraUser:" + extraUser.toString());
             }
 
-            if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo extraUser:" + extraUser.toString());
             if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo data:" + data.toString());
-            if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo launchIntent:" + launchIntent);
+            if (DBG) LogUtils.d(TAG, "PendingInstallShortcutInfo launchIntent:" + launchIntent.toString());
         }
 
         /**
Index: packages/apps/Launcher3/src/com/android/launcher3/Launcher.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/Launcher.java	(revision 182304)
+++ packages/apps/Launcher3/src/com/android/launcher3/Launcher.java	(revision 182305)
@@ -222,10 +222,6 @@
     private static final String RUNTIME_STATE_PENDING_ADD_WIDGET_INFO = "launcher.add_widget_info";
     // Type: parcelable
     private static final String RUNTIME_STATE_PENDING_ADD_WIDGET_ID = "launcher.add_widget_id";
-    // Type: boolean
-    private static final String RUNTIME_CREATE_USER_FOLDER_ON_DROP = "launcher.create_folder";
-    // Type: boolean
-    private static final String RUNTIME_ADD_TO_EXISTING_FOLDER_ON_DROP = "launcher.add_to_folder";
 
     static final String INTRO_SCREEN_DISMISSED = "launcher.intro_screen_dismissed";
     static final String FIRST_RUN_ACTIVITY_DISPLAYED = "launcher.first_run_activity_displayed";
@@ -554,11 +550,6 @@
         setupViews();
         mDeviceProfile.layout(this);
 
-        if (FeatureOption.SPRD_CUSTOMIZEAPPSORT_SUPPORT) {
-            CustomizeAppSort.setContext(this);
-            CustomizeAppSort.getInstance().loadCustomizeAppsData();
-        }
-
        if (LogUtils.DEBUG_UNREAD) {
             LogUtils.d(TAG, "launcher unread support:" + FeatureOption.SPRD_UNREAD_INFO_SUPPORT);
         }
@@ -665,9 +656,7 @@
         //SPRD: SPRD_CIRCLE_SLIDE_SUPPORT end }
 
         if(WallpaperChangeController.ALLOW_SHAKE_CHANGE_WALLPAPER_KEY.equals(settings)){
-            if (mWallpaperChangeController != null) {
-                mWallpaperChangeController.setShakeWallpaperEnabled((boolean) value);
-            }
+            mWallpaperChangeController.setShakeWallpaperEnabled((boolean)value);
         }
     }
 
@@ -1540,10 +1529,6 @@
         if (currentScreen != PagedView.INVALID_RESTORE_PAGE) {
             mWorkspace.setRestorePage(currentScreen);
         }
-        mWorkspace.setAddingtoExistingFolderOnDrop(
-                savedState.getBoolean(RUNTIME_ADD_TO_EXISTING_FOLDER_ON_DROP));
-        mWorkspace.setCreatingUserFolderOnDrop(
-                savedState.getBoolean(RUNTIME_CREATE_USER_FOLDER_ON_DROP));
 
         final long pendingAddContainer = savedState.getLong(RUNTIME_STATE_PENDING_ADD_CONTAINER, -1);
         final long pendingAddScreen = savedState.getLong(RUNTIME_STATE_PENDING_ADD_SCREEN, -1);
@@ -1618,4 +1603,4015 @@
         }
 
         // Setup the drag controller (drop targets have to be added in reverse order in priority)
-        dra
\ No newline at end of file
+        dragController.setDragScoller(mWorkspace);
+        dragController.setScrollView(mDragLayer);
+        dragController.setMoveTarget(mWorkspace);
+        dragController.addDropTarget(mWorkspace);
+        if (mSearchDropTargetBar != null) {
+            mSearchDropTargetBar.setup(this, dragController);
+            mSearchDropTargetBar.setQsbSearchBar(getOrCreateQsbBar());
+        }
+
+        if (TestingUtils.MEMORY_DUMP_ENABLED) {
+            TestingUtils.addWeightWatcher(this);
+        }
+    }
+
+    private void setupOverviewPanel() {
+        mOverviewPanel = (ViewGroup) findViewById(R.id.overview_panel);
+
+        // Long-clicking buttons in the overview panel does the same thing as clicking them.
+        OnLongClickListener performClickOnLongClick = new OnLongClickListener() {
+            @Override
+            public boolean onLongClick(View v) {
+                return v.performClick();
+            }
+        };
+
+        // Bind wallpaper button actions
+        View wallpaperButton = findViewById(R.id.wallpaper_button);
+        wallpaperButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                if (!mWorkspace.isSwitchingState()) {
+                    onClickWallpaperPicker(view);
+                }
+            }
+        });
+        wallpaperButton.setOnLongClickListener(performClickOnLongClick);
+        wallpaperButton.setOnTouchListener(getHapticFeedbackTouchListener());
+
+        // Bind widget button actions
+        mWidgetsButton = findViewById(R.id.widget_button);
+        mWidgetsButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                if (!mWorkspace.isSwitchingState()) {
+                    onClickAddWidgetButton(view);
+                }
+            }
+        });
+        mWidgetsButton.setOnLongClickListener(performClickOnLongClick);
+        mWidgetsButton.setOnTouchListener(getHapticFeedbackTouchListener());
+
+        // Bind settings actions
+        View settingsButton = findViewById(R.id.settings_button);
+        boolean hasSettings = hasSettings();
+        if (hasSettings) {
+            settingsButton.setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View view) {
+                    if (!mWorkspace.isSwitchingState()) {
+                        onClickSettingsButton(view);
+                    }
+                }
+            });
+            settingsButton.setOnLongClickListener(performClickOnLongClick);
+            settingsButton.setOnTouchListener(getHapticFeedbackTouchListener());
+        } else {
+            settingsButton.setVisibility(View.GONE);
+        }
+        mSortAppsButton = (TextView)findViewById(R.id.sort_app_button);
+        mSortAppsButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View arg0) {
+                if (!mWorkspace.isSwitchingState()) {
+                    showDialog(DIALOG_SORT_APP);
+                    showAppsView(false /* animated */, false /* resetListToTop */, true /* updatePredictedApps */, false /* focusSearchBar */);
+                }
+            }
+        });
+
+        mOverviewPanel.setAlpha(0f);
+    }
+
+    @Override
+    protected Dialog onCreateDialog(int id) {
+        switch (id) {
+            case DIALOG_SORT_APP:
+                return showAppSortDlg();
+        }
+        return super.onCreateDialog(id);
+    }
+
+    public Dialog showAppSortDlg() {
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle(getResources().getString(R.string.edit_sort));
+        final String[] items = new String[3];
+        items[0] = getResources().getString(R.string.edit_sort_default);
+        items[1] = getResources().getString(R.string.edit_sort_by_name);
+        items[2] = getResources().getString(R.string.edit_sort_by_install_time);
+        SharedPreferences sortPreference = getSharedPreferences(APPS_SORT_TYPE,
+                Context.MODE_PRIVATE);
+        builder.setSingleChoiceItems(items, sortPreference.getInt(SORT_TYPE_KEY, 0),
+                new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, final int which) {
+                        new Thread(new Runnable() {
+                            @Override
+                            public void run() {
+                                mAppsView.post(new Runnable() {
+                                    public void run() {
+                                        if (mAppsView != null) {
+                                            SharedPreferences.Editor mSharedEditor = getSharedPreferences(
+                                                    APPS_SORT_TYPE, Context.MODE_PRIVATE).edit();
+                                            mSharedEditor.putInt(SORT_TYPE_KEY, which).apply();
+                                            mAppsView.updateApps();
+                                        }
+                                    }
+                                });
+                            }
+                        }).start();
+                        Launcher.this.removeDialog(DIALOG_SORT_APP);
+                    }
+                });
+        builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
+            @Override
+            public void onCancel(DialogInterface dialog) {
+                Launcher.this.removeDialog(DIALOG_SORT_APP);
+            }
+        });
+        AlertDialog ad = builder.create();
+        ad.show();
+        return ad;
+    }
+
+    /**
+     * Sets the all apps button. This method is called from {@link Hotseat}.
+     */
+    public void setAllAppsButton(View allAppsButton) {
+        mAllAppsButton = allAppsButton;
+    }
+
+    public View getAllAppsButton() {
+        return mAllAppsButton;
+    }
+
+    public View getWidgetsButton() {
+        return mWidgetsButton;
+    }
+
+    /**
+     * Creates a view representing a shortcut.
+     *
+     * @param info The data structure describing the shortcut.
+     */
+    View createShortcut(ShortcutInfo info) {
+        return createShortcut((ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentPage()), info);
+    }
+
+    /**
+     * Creates a view representing a shortcut inflated from the specified resource.
+     *
+     * @param parent The group the shortcut belongs to.
+     * @param info The data structure describing the shortcut.
+     *
+     * @return A View inflated from layoutResId.
+     */
+    public View createShortcut(ViewGroup parent, ShortcutInfo info) {
+        BubbleTextView favorite = (BubbleTextView) mInflater.inflate(R.layout.app_icon,
+            parent, false);
+
+        if (mDynamicIconUtils != null && info != null && info.intent != null) {
+            ComponentName cn = info.intent.getComponent();
+            Drawable d = mDynamicIconUtils.getStableBGForComponent(cn);
+            if (d != null) {
+                info.setIcon(Utilities.createIconBitmap(d, Launcher.this));
+                info.dynamicIconDrawCallback = mDynamicIconUtils.getDIDCForComponent(cn);
+                info.customIcon = true;
+                LogUtils.d(TAG, "createShortcut: dynamic icon, intent = " + info.intent);
+            }
+        }
+
+        favorite.applyFromShortcutInfo(info, mIconCache);
+        favorite.setCompoundDrawablePadding(mDeviceProfile.iconDrawablePaddingPx);
+        favorite.setOnClickListener(this);
+        favorite.setOnFocusChangeListener(mFocusHandler);
+        return favorite;
+    }
+
+    /**
+     * Add a shortcut to the workspace.
+     *
+     * @param data The intent describing the shortcut.
+     */
+    private void completeAddShortcut(Intent data, long container, long screenId, int cellX,
+            int cellY) {
+        int[] cellXY = mTmpAddItemCellCoordinates;
+        int[] touchXY = mPendingAddInfo.dropPos;
+        CellLayout layout = getCellLayout(container, screenId);
+
+        ShortcutInfo info = InstallShortcutReceiver.fromShortcutIntent(this, data);
+        if (info == null || mPendingAddInfo.componentName == null) {
+            return;
+        }
+        if (!PackageManagerHelper.hasPermissionForActivity(
+                this, info.intent, mPendingAddInfo.componentName.getPackageName())) {
+            // The app is trying to add a shortcut without sufficient permissions
+            Log.e(TAG, "Ignoring malicious intent " + info.intent.toUri(0));
+            return;
+        }
+        final View view = createShortcut(info);
+
+        boolean foundCellSpan = false;
+        // First we check if we already know the exact location where we want to add this item.
+        if (cellX >= 0 && cellY >= 0) {
+            cellXY[0] = cellX;
+            cellXY[1] = cellY;
+            foundCellSpan = true;
+
+            // If appropriate, either create a folder or add to an existing folder
+            if (mWorkspace.createUserFolderIfNecessary(view, container, layout, cellXY, 0,
+                    true, null,null)) {
+                return;
+            }
+            DragObject dragObject = new DragObject();
+            dragObject.dragInfo = info;
+            if (mWorkspace.addToExistingFolderIfNecessary(view, layout, cellXY, 0, dragObject,
+                    true)) {
+                return;
+            }
+        } else if (touchXY != null) {
+            // when dragging and dropping, just find the closest free spot
+            int[] result = layout.findNearestVacantArea(touchXY[0], touchXY[1], 1, 1, cellXY);
+            foundCellSpan = (result != null);
+        } else {
+            foundCellSpan = layout.findCellForSpan(cellXY, 1, 1);
+        }
+
+        if (!foundCellSpan) {
+            showOutOfSpaceMessage(isHotseatLayout(layout));
+            return;
+        }
+
+        LauncherModel.addItemToDatabase(this, info, container, screenId, cellXY[0], cellXY[1]);
+
+        if (!mRestoring) {
+            mWorkspace.addInScreen(view, container, screenId, cellXY[0], cellXY[1], 1, 1,
+                    isWorkspaceLocked());
+        }
+    }
+
+    /**
+     * Add a widget to the workspace.
+     *
+     * @param appWidgetId The app widget id
+     */
+    @Thunk void completeAddAppWidget(int appWidgetId, long container, long screenId,
+            AppWidgetHostView hostView, LauncherAppWidgetProviderInfo appWidgetInfo) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "completeAddAppWidget: appWidgetId = " + appWidgetId
+                    + ", container = " + container + ", screenId = " + screenId);
+        }
+
+        ItemInfo info = mPendingAddInfo;
+        if (appWidgetInfo == null) {
+            appWidgetInfo = mAppWidgetManager.getLauncherAppWidgetInfo(appWidgetId);
+        }
+
+        if (appWidgetInfo.isCustomWidget) {
+            appWidgetId = LauncherAppWidgetInfo.CUSTOM_WIDGET_ID;
+        }
+
+        LauncherAppWidgetInfo launcherInfo;
+        launcherInfo = new LauncherAppWidgetInfo(appWidgetId, appWidgetInfo.provider);
+        launcherInfo.spanX = info.spanX;
+        launcherInfo.spanY = info.spanY;
+        launcherInfo.minSpanX = info.minSpanX;
+        launcherInfo.minSpanY = info.minSpanY;
+        launcherInfo.user = mAppWidgetManager.getUser(appWidgetInfo);
+
+        LauncherModel.addItemToDatabase(this, launcherInfo,
+                container, screenId, info.cellX, info.cellY);
+
+        if (!mRestoring) {
+            if (hostView == null) {
+                // Perform actual inflation because we're live
+                launcherInfo.hostView = mAppWidgetHost.createView(this, appWidgetId,
+                        appWidgetInfo);
+            } else {
+                // The AppWidgetHostView has already been inflated and instantiated
+                launcherInfo.hostView = hostView;
+            }
+            launcherInfo.hostView.setVisibility(View.VISIBLE);
+            addAppWidgetToWorkspace(launcherInfo, appWidgetInfo, isWorkspaceLocked());
+        }
+        resetAddInfo();
+    }
+
+    private void addAppWidgetToWorkspace(LauncherAppWidgetInfo item,
+            LauncherAppWidgetProviderInfo appWidgetInfo, boolean insert) {
+        item.hostView.setTag(item);
+        item.onBindAppWidget(this);
+
+        item.hostView.setFocusable(true);
+        item.hostView.setOnFocusChangeListener(mFocusHandler);
+
+        mWorkspace.addInScreen(item.hostView, item.container, item.screenId,
+                item.cellX, item.cellY, item.spanX, item.spanY, insert);
+
+        if (!item.isCustomWidget()) {
+            addWidgetToAutoAdvanceIfNeeded(item.hostView, appWidgetInfo);
+        }
+    }
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            final String action = intent.getAction();
+            if (Intent.ACTION_SCREEN_OFF.equals(action)) {
+                mUserPresent = false;
+                mDragLayer.clearAllResizeFrames();
+                updateAutoAdvanceState();
+
+                // Reset AllApps to its initial state only if we are not in the middle of
+                // processing a multi-step drop
+                if (mAppsView != null && mWidgetsView != null &&
+                        mPendingAddInfo.container == ItemInfo.NO_ID) {
+                    if (!showWorkspace(false)) {
+                        // If we are already on the workspace, then manually reset all apps
+                        mAppsView.reset();
+                    }
+                }
+            } else if (Intent.ACTION_USER_PRESENT.equals(action)) {
+                mUserPresent = true;
+                updateAutoAdvanceState();
+            } else if (ENABLE_DEBUG_INTENTS && DebugIntents.DELETE_DATABASE.equals(action)) {
+                mModel.resetLoadedState(false, true);
+                mModel.startLoader(PagedView.INVALID_RESTORE_PAGE,
+                        LauncherModel.LOADER_FLAG_CLEAR_WORKSPACE);
+            } else if (ENABLE_DEBUG_INTENTS && DebugIntents.MIGRATE_DATABASE.equals(action)) {
+                mModel.resetLoadedState(false, true);
+                mModel.startLoader(PagedView.INVALID_RESTORE_PAGE,
+                        LauncherModel.LOADER_FLAG_CLEAR_WORKSPACE
+                                | LauncherModel.LOADER_FLAG_MIGRATE_SHORTCUTS);
+            }
+        }
+    };
+
+    @Override
+    public void onAttachedToWindow() {
+        super.onAttachedToWindow();
+
+        // Listen for broadcasts related to user-presence
+        final IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        filter.addAction(Intent.ACTION_USER_PRESENT);
+        // For handling managed profiles
+        if (ENABLE_DEBUG_INTENTS) {
+            filter.addAction(DebugIntents.DELETE_DATABASE);
+            filter.addAction(DebugIntents.MIGRATE_DATABASE);
+        }
+        registerReceiver(mReceiver, filter);
+        FirstFrameAnimatorHelper.initializeDrawListener(getWindow().getDecorView());
+        mAttached = true;
+        mVisible = true;
+
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.onAttachedToWindow();
+        }
+    }
+
+    @Override
+    public void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        mVisible = false;
+
+        if (mAttached) {
+            unregisterReceiver(mReceiver);
+            mAttached = false;
+        }
+        updateAutoAdvanceState();
+
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.onDetachedFromWindow();
+        }
+    }
+
+    public void onWindowVisibilityChanged(int visibility) {
+        mVisible = visibility == View.VISIBLE;
+        updateAutoAdvanceState();
+        // The following code used to be in onResume, but it turns out onResume is called when
+        // you're in All Apps and click home to go to the workspace. onWindowVisibilityChanged
+        // is a more appropriate event to handle
+        if (mVisible) {
+            if (!mWorkspaceLoading) {
+                final ViewTreeObserver observer = mWorkspace.getViewTreeObserver();
+                // We want to let Launcher draw itself at least once before we force it to build
+                // layers on all the workspace pages, so that transitioning to Launcher from other
+                // apps is nice and speedy.
+                observer.addOnDrawListener(new ViewTreeObserver.OnDrawListener() {
+                    private boolean mStarted = false;
+                    public void onDraw() {
+                        if (mStarted) return;
+                        mStarted = true;
+                        // We delay the layer building a bit in order to give
+                        // other message processing a time to run.  In particular
+                        // this avoids a delay in hiding the IME if it was
+                        // currently shown, because doing that may involve
+                        // some communication back with the app.
+                        mWorkspace.postDelayed(mBuildLayersRunnable, 500);
+                        final ViewTreeObserver.OnDrawListener listener = this;
+                        mWorkspace.post(new Runnable() {
+                            public void run() {
+                                if (mWorkspace != null &&
+                                        mWorkspace.getViewTreeObserver() != null) {
+                                    mWorkspace.getViewTreeObserver().
+                                            removeOnDrawListener(listener);
+                                }
+                            }
+                        });
+                        return;
+                    }
+                });
+            }
+            clearTypedText();
+        }
+    }
+
+    @Thunk void sendAdvanceMessage(long delay) {
+        mHandler.removeMessages(ADVANCE_MSG);
+        Message msg = mHandler.obtainMessage(ADVANCE_MSG);
+        mHandler.sendMessageDelayed(msg, delay);
+        mAutoAdvanceSentTime = System.currentTimeMillis();
+    }
+
+    @Thunk void updateAutoAdvanceState() {
+        boolean autoAdvanceRunning = mVisible && mUserPresent && !mWidgetsToAdvance.isEmpty();
+        if (autoAdvanceRunning != mAutoAdvanceRunning) {
+            mAutoAdvanceRunning = autoAdvanceRunning;
+            if (autoAdvanceRunning) {
+                long delay = mAutoAdvanceTimeLeft == -1 ? mAdvanceInterval : mAutoAdvanceTimeLeft;
+                sendAdvanceMessage(delay);
+            } else {
+                if (!mWidgetsToAdvance.isEmpty()) {
+                    mAutoAdvanceTimeLeft = Math.max(0, mAdvanceInterval -
+                            (System.currentTimeMillis() - mAutoAdvanceSentTime));
+                }
+                mHandler.removeMessages(ADVANCE_MSG);
+                mHandler.removeMessages(0); // Remove messages sent using postDelayed()
+            }
+        }
+    }
+
+    @Thunk final Handler mHandler = new Handler(new Handler.Callback() {
+
+        @Override
+        public boolean handleMessage(Message msg) {
+            if (msg.what == ADVANCE_MSG) {
+                int i = 0;
+                for (View key: mWidgetsToAdvance.keySet()) {
+                    final View v = key.findViewById(mWidgetsToAdvance.get(key).autoAdvanceViewId);
+                    final int delay = mAdvanceStagger * i;
+                    if (v instanceof Advanceable) {
+                        mHandler.postDelayed(new Runnable() {
+                           public void run() {
+                               ((Advanceable) v).advance();
+                           }
+                       }, delay);
+                    }
+                    i++;
+                }
+                sendAdvanceMessage(mAdvanceInterval);
+            }
+            return true;
+        }
+    });
+
+    private void addWidgetToAutoAdvanceIfNeeded(View hostView, AppWidgetProviderInfo appWidgetInfo) {
+        if (appWidgetInfo == null || appWidgetInfo.autoAdvanceViewId == -1) return;
+        View v = hostView.findViewById(appWidgetInfo.autoAdvanceViewId);
+        if (v instanceof Advanceable) {
+            mWidgetsToAdvance.put(hostView, appWidgetInfo);
+            ((Advanceable) v).fyiWillBeAdvancedByHostKThx();
+            updateAutoAdvanceState();
+        }
+    }
+
+    private void removeWidgetToAutoAdvance(View hostView) {
+        if (mWidgetsToAdvance.containsKey(hostView)) {
+            mWidgetsToAdvance.remove(hostView);
+            updateAutoAdvanceState();
+        }
+    }
+
+    public void showOutOfSpaceMessage(boolean isHotseatLayout) {
+        int strId = (isHotseatLayout ? R.string.hotseat_out_of_space : R.string.out_of_space);
+        Toast.makeText(this, getString(strId), Toast.LENGTH_SHORT).show();
+    }
+
+    public DragLayer getDragLayer() {
+        return mDragLayer;
+    }
+
+    public AllAppsContainerView getAppsView() {
+        return mAppsView;
+    }
+
+    public WidgetsContainerView getWidgetsView() {
+        return mWidgetsView;
+    }
+
+    public Workspace getWorkspace() {
+        return mWorkspace;
+    }
+
+    public Hotseat getHotseat() {
+        return mHotseat;
+    }
+
+    public ViewGroup getOverviewPanel() {
+        return mOverviewPanel;
+    }
+
+    public SearchDropTargetBar getSearchDropTargetBar() {
+        return mSearchDropTargetBar;
+    }
+
+    public LauncherAppWidgetHost getAppWidgetHost() {
+        return mAppWidgetHost;
+    }
+
+    public LauncherModel getModel() {
+        return mModel;
+    }
+
+    protected SharedPreferences getSharedPrefs() {
+        return mSharedPrefs;
+    }
+
+    public DeviceProfile getDeviceProfile() {
+        return mDeviceProfile;
+    }
+
+    public void closeSystemDialogs() {
+        getWindow().closeAllPanels();
+
+        // Whatever we were doing is hereby canceled.
+        setWaitingForResult(false);
+    }
+
+    @Override
+    protected void onNewIntent(Intent intent) {
+        long startTime = 0;
+        if (DEBUG_RESUME_TIME) {
+            startTime = System.currentTimeMillis();
+        }
+        super.onNewIntent(intent);
+
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "onNewIntent: intent = " + intent);
+        }
+
+        // Close the menu
+        Folder openFolder = mWorkspace.getOpenFolder();
+        boolean alreadyOnHome = mHasFocus && ((intent.getFlags() &
+                Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT)
+                != Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
+        boolean isActionMain = Intent.ACTION_MAIN.equals(intent.getAction());
+        if (isActionMain) {
+            // also will cancel mWaitingForResult.
+            closeSystemDialogs();
+
+            if (mWorkspace == null) {
+                // Can be cases where mWorkspace is null, this prevents a NPE
+                return;
+            }
+            // In all these cases, only animate if we're already on home
+            mWorkspace.exitWidgetResizeMode();
+
+            closeFolder(alreadyOnHome);
+            exitSpringLoadedDragMode();
+
+            // If we are already on home, then just animate back to the workspace,
+            // otherwise, just wait until onResume to set the state back to Workspace
+            if (alreadyOnHome) {
+                showWorkspace(true);
+            } else {
+                mOnResumeState = State.WORKSPACE;
+            }
+
+            final View v = getWindow().peekDecorView();
+            if (v != null && v.getWindowToken() != null) {
+                InputMethodManager imm = (InputMethodManager) getSystemService(
+                        INPUT_METHOD_SERVICE);
+                imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
+            }
+
+            // Reset the apps view
+            if (!alreadyOnHome && mAppsView != null) {
+                mAppsView.scrollToTop();
+            }
+
+            // Reset the widgets view
+            if (!alreadyOnHome && mWidgetsView != null) {
+                mWidgetsView.scrollToTop();
+            }
+
+            if (mLauncherCallbacks != null) {
+                mLauncherCallbacks.onHomeIntent();
+            }
+        }
+
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.onNewIntent(intent);
+        }
+
+        // Defer moving to the default screen until after we callback to the LauncherCallbacks
+        // as slow logic in the callbacks eat into the time the scroller expects for the snapToPage
+        // animation.
+        if (isActionMain) {
+            boolean moveToDefaultScreen = mLauncherCallbacks != null ?
+                    mLauncherCallbacks.shouldMoveToDefaultScreenOnHomeIntent() : true;
+            if (alreadyOnHome && mState == State.WORKSPACE && !mWorkspace.isTouchActive() &&
+                    openFolder == null && moveToDefaultScreen) {
+
+                // We use this flag to suppress noisy callbacks above custom content state
+                // from onResume.
+                mMoveToDefaultScreenFromNewIntent = true;
+                mWorkspace.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        if (mWorkspace != null) {
+                            mWorkspace.moveToDefaultScreen(true);
+                        }
+                    }
+                });
+            }
+        }
+
+        if (DEBUG_RESUME_TIME) {
+            Log.d(TAG, "Time spent in onNewIntent: " + (System.currentTimeMillis() - startTime));
+        }
+    }
+
+    @Override
+    public void onRestoreInstanceState(Bundle state) {
+        super.onRestoreInstanceState(state);
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "onRestoreInstanceState: state = " + state
+                    + ", mSavedInstanceState = " + mSavedInstanceState);
+        }
+        for (int page: mSynchronouslyBoundPages) {
+            mWorkspace.restoreInstanceStateForChild(page);
+        }
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        // Catches the case where our activity is created and immediately destroyed and our views
+        // are not yet fully bound. In this case, we can't trust the state of our activity and
+        // instead save our previous state (which hasn't yet been consumed / applied, a fact we
+        // know as it's not null)
+        if (isWorkspaceLoading() && mSavedState != null) {
+            outState.putAll(mSavedState);
+            return;
+        }
+
+        if (mWorkspace.getChildCount() > 0) {
+            mSharedPrefs.edit().putInt(RUNTIME_STATE_CURRENT_SCREEN,
+                            mWorkspace.getCurrentPageOffsetFromCustomContent()).apply();
+        }
+        super.onSaveInstanceState(outState);
+
+        outState.putInt(RUNTIME_STATE, mState.ordinal());
+        // We close any open folder since it will not be re-opened, and we need to make sure
+        // this state is reflected.
+        closeFolder(false);
+
+        if (mPendingAddInfo.container != ItemInfo.NO_ID && mPendingAddInfo.screenId > -1 &&
+                (mWaitingForResult)) {
+            outState.putLong(RUNTIME_STATE_PENDING_ADD_CONTAINER, mPendingAddInfo.container);
+            outState.putLong(RUNTIME_STATE_PENDING_ADD_SCREEN, mPendingAddInfo.screenId);
+            outState.putInt(RUNTIME_STATE_PENDING_ADD_CELL_X, mPendingAddInfo.cellX);
+            outState.putInt(RUNTIME_STATE_PENDING_ADD_CELL_Y, mPendingAddInfo.cellY);
+            outState.putInt(RUNTIME_STATE_PENDING_ADD_SPAN_X, mPendingAddInfo.spanX);
+            outState.putInt(RUNTIME_STATE_PENDING_ADD_SPAN_Y, mPendingAddInfo.spanY);
+            outState.putParcelable(RUNTIME_STATE_PENDING_ADD_COMPONENT,
+                    mPendingAddInfo.componentName);
+            outState.putParcelable(RUNTIME_STATE_PENDING_ADD_WIDGET_INFO, mPendingAddWidgetInfo);
+            outState.putInt(RUNTIME_STATE_PENDING_ADD_WIDGET_ID, mPendingAddWidgetId);
+        }
+
+        // Save the current widgets tray?
+        // TODO(hyunyoungs)
+        // SPRD:598450 There is a empty screen when roating the screen
+        outState.putBoolean(HASCONFIGWIDGET, mHasConfigWidget);
+
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.onSaveInstanceState(outState);
+        }
+
+        if (mPredictedAppController != null) {
+            mPredictedAppController.savePredictedList();
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "(Launcher)onDestroy: this = " + this);
+        }
+
+        if (mPredictedAppController != null) {
+            mPredictedAppController.savePredictedList();
+        }
+
+        // Remove all pending runnables
+        mHandler.removeMessages(ADVANCE_MSG);
+        mHandler.removeMessages(0);
+        mWorkspace.removeCallbacks(mBuildLayersRunnable);
+
+        // Stop callbacks from LauncherModel
+        LauncherAppState app = (LauncherAppState.getInstance());
+
+        if (mDynamicIconUtils != null) {
+            mDynamicIconUtils.destroy();
+            mDynamicIconUtils = null;
+        }
+
+        // It's possible to receive onDestroy after a new Launcher activity has
+        // been created. In this case, don't interfere with the new Launcher.
+        if (mModel.isCurrentCallbacks(this)) {
+            mModel.stopLoader();
+            app.setLauncher(null);
+        }
+
+        try {
+            mAppWidgetHost.stopListening();
+        } catch (NullPointerException ex) {
+            Log.w(TAG, "problem while stopping AppWidgetHost during Launcher destruction", ex);
+        }
+        mAppWidgetHost = null;
+
+        mWidgetsToAdvance.clear();
+
+        TextKeyListener.getInstance().release();
+
+        if (mUnreadLoaderUtils != null) {
+            unregisterReceiver( mUnreadLoaderUtils);
+        }
+        unregisterReceiver(mCloseSystemDialogsReceiver);
+
+        mDragLayer.clearAllResizeFrames();
+
+        /* SPRD: bug608160 @{ */
+        mDragLayer.clearAnimation();
+        mDragLayer.clearAnimatedView();
+        /* @} */
+
+        ((ViewGroup) mWorkspace.getParent()).removeAllViews();
+        mWorkspace.removeAllWorkspaceScreens();
+        mWorkspace = null;
+        mDragController = null;
+
+        LauncherAnimUtils.onDestroyActivity();
+
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.onDestroy();
+        }
+
+
+        unRegisterListener();
+        if (mMotionSound != null) {
+            mMotionSound.stop();
+            mMotionSound.release();
+            mMotionSound = null;
+        }
+    }
+
+    public DragController getDragController() {
+        return mDragController;
+    }
+
+    @Override
+    public void startActivityForResult(Intent intent, int requestCode) {
+        onStartForResult(requestCode);
+        super.startActivityForResult(intent, requestCode);
+    }
+
+    @Override
+    public void startIntentSenderForResult (IntentSender intent, int requestCode,
+            Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options) {
+        onStartForResult(requestCode);
+        try {
+            super.startIntentSenderForResult(intent, requestCode,
+                fillInIntent, flagsMask, flagsValues, extraFlags, options);
+        } catch (IntentSender.SendIntentException e) {
+            throw new ActivityNotFoundException();
+        }
+    }
+
+    private void onStartForResult(int requestCode) {
+        if (requestCode >= 0) {
+            setWaitingForResult(true);
+        }
+    }
+
+    /**
+     * Indicates that we want global search for this activity by setting the globalSearch
+     * argument for {@link #startSearch} to true.
+     */
+    @Override
+    public void startSearch(String initialQuery, boolean selectInitialQuery,
+            Bundle appSearchData, boolean globalSearch) {
+
+        if (initialQuery == null) {
+            // Use any text typed in the launcher as the initial query
+            initialQuery = getTypedText();
+        }
+        if (appSearchData == null) {
+            appSearchData = new Bundle();
+            appSearchData.putString("source", "launcher-search");
+        }
+        Rect sourceBounds = new Rect();
+        if (mSearchDropTargetBar != null) {
+            sourceBounds = mSearchDropTargetBar.getSearchBarBounds();
+        }
+
+        boolean clearTextImmediately = startSearch(initialQuery, selectInitialQuery,
+                appSearchData, sourceBounds);
+        if (clearTextImmediately) {
+            clearTypedText();
+        }
+
+        // We need to show the workspace after starting the search
+        showWorkspace(true);
+    }
+
+    /**
+     * Start a text search.
+     *
+     * @return {@code true} if the search will start immediately, so any further keypresses
+     * will be handled directly by the search UI. {@code false} if {@link Launcher} should continue
+     * to buffer keypresses.
+     */
+    public boolean startSearch(String initialQuery,
+            boolean selectInitialQuery, Bundle appSearchData, Rect sourceBounds) {
+        if (mLauncherCallbacks != null && mLauncherCallbacks.providesSearch()) {
+            return mLauncherCallbacks.startSearch(initialQuery, selectInitialQuery, appSearchData,
+                    sourceBounds);
+        }
+
+        startGlobalSearch(initialQuery, selectInitialQuery,
+                appSearchData, sourceBounds);
+        return false;
+    }
+
+    /**
+     * Starts the global search activity. This code is a copied from SearchManager
+     */
+    private void startGlobalSearch(String initialQuery,
+            boolean selectInitialQuery, Bundle appSearchData, Rect sourceBounds) {
+        final SearchManager searchManager =
+            (SearchManager) getSystemService(Context.SEARCH_SERVICE);
+        ComponentName globalSearchActivity = searchManager.getGlobalSearchActivity();
+        if (globalSearchActivity == null) {
+            Log.w(TAG, "No global search activity found.");
+            return;
+        }
+        Intent intent = new Intent(SearchManager.INTENT_ACTION_GLOBAL_SEARCH);
+        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        intent.setComponent(globalSearchActivity);
+        // Make sure that we have a Bundle to put source in
+        if (appSearchData == null) {
+            appSearchData = new Bundle();
+        } else {
+            appSearchData = new Bundle(appSearchData);
+        }
+        // Set source to package name of app that starts global search if not set already.
+        if (!appSearchData.containsKey("source")) {
+            appSearchData.putString("source", getPackageName());
+        }
+        intent.putExtra(SearchManager.APP_DATA, appSearchData);
+        if (!TextUtils.isEmpty(initialQuery)) {
+            intent.putExtra(SearchManager.QUERY, initialQuery);
+        }
+        if (selectInitialQuery) {
+            intent.putExtra(SearchManager.EXTRA_SELECT_QUERY, selectInitialQuery);
+        }
+        intent.setSourceBounds(sourceBounds);
+        try {
+            startActivity(intent);
+        } catch (ActivityNotFoundException ex) {
+            Log.e(TAG, "Global search activity not found: " + globalSearchActivity);
+        }
+    }
+
+    public boolean isOnCustomContent() {
+        return mWorkspace.isOnOrMovingToCustomContent();
+    }
+
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        super.onPrepareOptionsMenu(menu);
+        if (mLauncherCallbacks != null) {
+            return mLauncherCallbacks.onPrepareOptionsMenu(menu);
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onSearchRequested() {
+        startSearch(null, false, null, true);
+        // Use a custom animation for launching search
+        return true;
+    }
+
+    public boolean isWorkspaceLocked() {
+        return mWorkspaceLoading || mWaitingForResult;
+    }
+
+    public boolean isWorkspaceLoading() {
+        return mWorkspaceLoading;
+    }
+
+    private void setWorkspaceLoading(boolean value) {
+        boolean isLocked = isWorkspaceLocked();
+        mWorkspaceLoading = value;
+        if (isLocked != isWorkspaceLocked()) {
+            onWorkspaceLockedChanged();
+        }
+    }
+
+    private void setWaitingForResult(boolean value) {
+        boolean isLocked = isWorkspaceLocked();
+        mWaitingForResult = value;
+        if (isLocked != isWorkspaceLocked()) {
+            onWorkspaceLockedChanged();
+        }
+    }
+
+    protected void onWorkspaceLockedChanged() {
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.onWorkspaceLockedChanged();
+        }
+    }
+
+    private void resetAddInfo() {
+        mPendingAddInfo.container = ItemInfo.NO_ID;
+        mPendingAddInfo.screenId = -1;
+        mPendingAddInfo.cellX = mPendingAddInfo.cellY = -1;
+        mPendingAddInfo.spanX = mPendingAddInfo.spanY = -1;
+        mPendingAddInfo.minSpanX = mPendingAddInfo.minSpanY = 1;
+        mPendingAddInfo.dropPos = null;
+        mPendingAddInfo.componentName = null;
+    }
+
+    void addAppWidgetFromDropImpl(final int appWidgetId, final ItemInfo info, final
+            AppWidgetHostView boundWidget, final LauncherAppWidgetProviderInfo appWidgetInfo) {
+        if (LOGD) {
+            Log.d(TAG, "Adding widget from drop");
+        }
+        addAppWidgetImpl(appWidgetId, info, boundWidget, appWidgetInfo, 0);
+    }
+
+    void addAppWidgetImpl(final int appWidgetId, final ItemInfo info,
+            final AppWidgetHostView boundWidget, final LauncherAppWidgetProviderInfo appWidgetInfo,
+            int delay) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "addAppWidgetImpl: appWidgetId = " + appWidgetId
+                    + ", info = " + info + ", boundWidget = " + boundWidget
+                    + ", appWidgetInfo = " + appWidgetInfo + ", delay = " + delay);
+        }
+        if (appWidgetInfo.configure != null) {
+            mPendingAddWidgetInfo = appWidgetInfo;
+            mPendingAddWidgetId = appWidgetId;
+
+            // SPRD:598450 There is a empty screen when roating the screen
+            mHasConfigWidget = true;
+            // Launch over to configure widget, if needed
+            mAppWidgetManager.startConfigActivity(appWidgetInfo, appWidgetId, this,
+                    mAppWidgetHost, REQUEST_CREATE_APPWIDGET);
+
+        } else {
+            // Otherwise just add it
+            Runnable onComplete = new Runnable() {
+                @Override
+                public void run() {
+                    // Exit spring loaded mode if necessary after adding the widget
+                    exitSpringLoadedDragModeDelayed(true, EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT,
+                            null);
+                }
+            };
+            completeAddAppWidget(appWidgetId, info.container, info.screenId, boundWidget,
+                    appWidgetInfo);
+            mWorkspace.removeExtraEmptyScreenDelayed(true, onComplete, delay, false);
+        }
+    }
+
+    protected void moveToCustomContentScreen(boolean animate) {
+        // Close any folders that may be open.
+        closeFolder();
+        mWorkspace.moveToCustomContentScreen(animate);
+    }
+
+    public void addPendingItem(PendingAddItemInfo info, long container, long screenId,
+            int[] cell, int spanX, int spanY) {
+        switch (info.itemType) {
+            case LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET:
+            case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
+                int span[] = new int[2];
+                span[0] = spanX;
+                span[1] = spanY;
+                addAppWidgetFromDrop((PendingAddWidgetInfo) info,
+                        container, screenId, cell, span);
+                break;
+            case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
+                processShortcutFromDrop(info.componentName, container, screenId, cell);
+                break;
+            default:
+                throw new IllegalStateException("Unknown item type: " + info.itemType);
+            }
+    }
+
+    /**
+     * Process a shortcut drop.
+     *
+     * @param componentName The name of the component
+     * @param screenId The ID of the screen where it should be added
+     * @param cell The cell it should be added to, optional
+     */
+    private void processShortcutFromDrop(ComponentName componentName, long container, long screenId,
+            int[] cell) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "processShortcutFromDrop componentName = " + componentName + ", container = " + container
+                    + ", screenId = " + screenId);
+        }
+        resetAddInfo();
+        mPendingAddInfo.container = container;
+        mPendingAddInfo.screenId = screenId;
+        mPendingAddInfo.dropPos = null;
+        mPendingAddInfo.componentName = componentName;
+
+        if (cell != null) {
+            mPendingAddInfo.cellX = cell[0];
+            mPendingAddInfo.cellY = cell[1];
+        }
+
+        Intent createShortcutIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
+        createShortcutIntent.setComponent(componentName);
+        Utilities.startActivityForResultSafely(this, createShortcutIntent, REQUEST_CREATE_SHORTCUT);
+    }
+
+    /**
+     * Process a widget drop.
+     *
+     * @param info The PendingAppWidgetInfo of the widget being added.
+     * @param screenId The ID of the screen where it should be added
+     * @param cell The cell it should be added to, optional
+     */
+    private void addAppWidgetFromDrop(PendingAddWidgetInfo info, long container, long screenId,
+            int[] cell, int[] span) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "addAppWidgetFromDrop: info = " + info + ", container = " + container + ", screenId = "
+                    + screenId);
+        }
+        resetAddInfo();
+        mPendingAddInfo.container = info.container = container;
+        mPendingAddInfo.screenId = info.screenId = screenId;
+        mPendingAddInfo.dropPos = null;
+        mPendingAddInfo.minSpanX = info.minSpanX;
+        mPendingAddInfo.minSpanY = info.minSpanY;
+
+        if (cell != null) {
+            mPendingAddInfo.cellX = cell[0];
+            mPendingAddInfo.cellY = cell[1];
+        }
+        if (span != null) {
+            mPendingAddInfo.spanX = span[0];
+            mPendingAddInfo.spanY = span[1];
+        }
+
+        AppWidgetHostView hostView = info.boundWidget;
+        int appWidgetId;
+        if (hostView != null) {
+            // In the case where we've prebound the widget, we remove it from the DragLayer
+            if (LOGD) {
+                Log.d(TAG, "Removing widget view from drag layer and setting boundWidget to null");
+            }
+            getDragLayer().removeView(hostView);
+
+            appWidgetId = hostView.getAppWidgetId();
+            addAppWidgetFromDropImpl(appWidgetId, info, hostView, info.info);
+
+            // Clear the boundWidget so that it doesn't get destroyed.
+            info.boundWidget = null;
+        } else {
+            // In this case, we either need to start an activity to get permission to bind
+            // the widget, or we need to start an activity to configure the widget, or both.
+            appWidgetId = getAppWidgetHost().allocateAppWidgetId();
+            Bundle options = info.bindOptions;
+
+            boolean success = mAppWidgetManager.bindAppWidgetIdIfAllowed(
+                    appWidgetId, info.info, options);
+            if (success) {
+                addAppWidgetFromDropImpl(appWidgetId, info, null, info.info);
+            } else {
+                mPendingAddWidgetInfo = info.info;
+                Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_BIND);
+                intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
+                intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER, info.componentName);
+                mAppWidgetManager.getUser(mPendingAddWidgetInfo)
+                    .addToIntent(intent, AppWidgetManager.EXTRA_APPWIDGET_PROVIDER_PROFILE);
+                // TODO: we need to make sure that this accounts for the options bundle.
+                // intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, options);
+                startActivityForResult(intent, REQUEST_BIND_APPWIDGET);
+            }
+        }
+    }
+
+    FolderIcon addFolder(CellLayout layout, long container, final long screenId, int cellX,
+            int cellY) {
+        final FolderInfo folderInfo = new FolderInfo();
+        if(FeatureOption.SPRD_DEFAULT_FOLDER_NAME_SUPPORT){
+            folderInfo.title = "";
+        }else{
+            folderInfo.title = getText(R.string.folder_name);
+        }
+
+        // Update the model
+        LauncherModel.addItemToDatabase(Launcher.this, folderInfo, container, screenId,
+                cellX, cellY);
+        sFolders.put(folderInfo.id, folderInfo);
+
+        // Create the view
+        FolderIcon newFolder =
+            FolderIcon.fromXml(R.layout.folder_icon, this, layout, folderInfo, mIconCache);
+        mWorkspace.addInScreen(newFolder, container, screenId, cellX, cellY, 1, 1,
+                isWorkspaceLocked());
+        // Force measure the new folder icon
+        CellLayout parent = mWorkspace.getParentCellLayoutForView(newFolder);
+        parent.getShortcutsAndWidgets().measureChild(newFolder);
+        return newFolder;
+    }
+
+    /**
+     * Unbinds the view for the specified item, and removes the item and all its children.
+     *
+     * @param v the view being removed.
+     * @param itemInfo the {@link ItemInfo} for this view.
+     * @param deleteFromDb whether or not to delete this item from the db.
+     */
+    public boolean removeItem(View v, ItemInfo itemInfo, boolean deleteFromDb) {
+        if (itemInfo instanceof ShortcutInfo) {
+            // Remove the shortcut from the folder before removing it from launcher
+            FolderInfo folderInfo = sFolders.get(itemInfo.container);
+            if (folderInfo != null) {
+                folderInfo.remove((ShortcutInfo) itemInfo);
+            } else {
+                mWorkspace.removeWorkspaceItem(v);
+            }
+            if (deleteFromDb) {
+                LauncherModel.deleteItemFromDatabase(this, itemInfo);
+            }
+        } else if (itemInfo instanceof FolderInfo) {
+            final FolderInfo folderInfo = (FolderInfo) itemInfo;
+            unbindFolder(folderInfo);
+            mWorkspace.removeWorkspaceItem(v);
+            if (deleteFromDb) {
+                LauncherModel.deleteFolderAndContentsFromDatabase(this, folderInfo);
+            }
+        } else if (itemInfo instanceof LauncherAppWidgetInfo) {
+            final LauncherAppWidgetInfo widgetInfo = (LauncherAppWidgetInfo) itemInfo;
+            mWorkspace.removeWorkspaceItem(v);
+            removeWidgetToAutoAdvance(widgetInfo.hostView);
+            widgetInfo.hostView = null;
+            if (deleteFromDb) {
+                deleteWidgetInfo(widgetInfo);
+            }
+
+        } else {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Unbinds any launcher references to the folder.
+     */
+    private void unbindFolder(FolderInfo folder) {
+        sFolders.remove(folder.id);
+    }
+
+    /**
+     * Deletes the widget info and the widget id.
+     */
+    private void deleteWidgetInfo(final LauncherAppWidgetInfo widgetInfo) {
+        final LauncherAppWidgetHost appWidgetHost = getAppWidgetHost();
+        if (appWidgetHost != null && !widgetInfo.isCustomWidget() && widgetInfo.isWidgetIdValid()) {
+            // Deleting an app widget ID is a void call but writes to disk before returning
+            // to the caller...
+            new AsyncTask<Void, Void, Void>() {
+                public Void doInBackground(Void ... args) {
+                    appWidgetHost.deleteAppWidgetId(widgetInfo.appWidgetId);
+                    return null;
+                }
+            }.executeOnExecutor(Utilities.THREAD_POOL_EXECUTOR);
+        }
+        LauncherModel.deleteItemFromDatabase(this, widgetInfo);
+    }
+
+    @Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            switch (event.getKeyCode()) {
+                case KeyEvent.KEYCODE_HOME:
+                    return true;
+                case KeyEvent.KEYCODE_VOLUME_DOWN:
+                    if (Utilities.isPropertyEnabled(DUMP_STATE_PROPERTY)) {
+                        dumpState();
+                        return true;
+                    }
+                    break;
+            }
+        } else if (event.getAction() == KeyEvent.ACTION_UP) {
+            switch (event.getKeyCode()) {
+                case KeyEvent.KEYCODE_HOME:
+                    return true;
+            }
+        }
+
+        return super.dispatchKeyEvent(event);
+    }
+
+    @Override
+    public void onBackPressed() {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "Back key pressed, mState = " + mState + ", mOnResumeState = " + mOnResumeState);
+        }
+        if (mLauncherCallbacks != null && mLauncherCallbacks.handleBackPressed()) {
+            return;
+        }
+
+        if (mDragController.isDragging()) {
+            mDragController.cancelDrag();
+            return;
+        }
+
+        if (isAppsViewVisible()) {
+            showWorkspace(true);
+            if (FeatureOption.SPRD_BGTRANSPARENT_SUPPORT) {
+                showWorkspaceSearchAndHotseat();
+            }
+        } else if (isWidgetsViewVisible())  {
+            showOverviewMode(true);
+        } else if (mWorkspace.isInOverviewMode()) {
+            showWorkspace(true);
+        } else if (mWorkspace.getOpenFolder() != null) {
+            Folder openFolder = mWorkspace.getOpenFolder();
+            if (openFolder.isEditingName()) {
+                openFolder.dismissEditingName();
+            } else {
+                closeFolder();
+            }
+        } else {
+            mWorkspace.exitWidgetResizeMode();
+
+            // Back button is a no-op here, but give at least some feedback for the button press
+            mWorkspace.showOutlinesTemporarily();
+        }
+    }
+
+    /**
+     * Re-listen when widget host is reset.
+     */
+    @Override
+    public void onAppWidgetHostReset() {
+        if (mAppWidgetHost != null) {
+            mAppWidgetHost.startListening();
+        }
+
+        // Recreate the QSB, as the widget has been reset.
+        bindSearchProviderChanged();
+    }
+
+    /**
+     * Launches the intent referred by the clicked shortcut.
+     *
+     * @param v The view representing the clicked shortcut.
+     */
+    public void onClick(View v) {
+        // Make sure that rogue clicks don't get through while allapps is launching, or after the
+        // view has detached (it's possible for this to happen if the view is removed mid touch).
+        if (v.getWindowToken() == null) {
+            return;
+        }
+
+        if (!mWorkspace.isFinishedSwitchingState()) {
+            return;
+        }
+
+        if (v instanceof Workspace) {
+            if (mWorkspace.isInOverviewMode()) {
+                showWorkspace(true);
+            }
+            return;
+        }
+
+        if (v instanceof CellLayout) {
+            if (mWorkspace.isInOverviewMode()) {
+                showWorkspace(mWorkspace.indexOfChild(v), true);
+            }
+        }
+
+        Object tag = v.getTag();
+        if (tag instanceof ShortcutInfo) {
+            onClickAppShortcut(v);
+        } else if (tag instanceof FolderInfo) {
+            if (v instanceof FolderIcon) {
+                onClickFolderIcon(v);
+            }
+        } else if (v == mAllAppsButton) {
+            onClickAllAppsButton(v);
+        } else if (tag instanceof AppInfo) {
+            startAppShortcutOrInfoActivity(v);
+        } else if (tag instanceof LauncherAppWidgetInfo) {
+            if (v instanceof PendingAppWidgetHostView) {
+                onClickPendingWidget((PendingAppWidgetHostView) v);
+            }
+        }
+    }
+
+    @SuppressLint("ClickableViewAccessibility")
+    public boolean onTouch(View v, MotionEvent event) {
+        return false;
+    }
+
+    /**
+     * Event handler for the app widget view which has not fully restored.
+     */
+    public void onClickPendingWidget(final PendingAppWidgetHostView v) {
+        if (mIsSafeModeEnabled) {
+            Toast.makeText(this, R.string.safemode_widget_error, Toast.LENGTH_SHORT).show();
+            return;
+        }
+
+        final LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) v.getTag();
+        if (v.isReadyForClickSetup()) {
+            int widgetId = info.appWidgetId;
+            LauncherAppWidgetProviderInfo appWidgetInfo =
+                    mAppWidgetManager.getLauncherAppWidgetInfo(widgetId);
+            if (appWidgetInfo != null) {
+                mPendingAddWidgetInfo = appWidgetInfo;
+                mPendingAddInfo.copyFrom(info);
+                mPendingAddWidgetId = widgetId;
+
+                AppWidgetManagerCompat.getInstance(this).startConfigActivity(appWidgetInfo,
+                        info.appWidgetId, this, mAppWidgetHost, REQUEST_RECONFIGURE_APPWIDGET);
+            }
+        } else if (info.installProgress < 0) {
+            // The install has not been queued
+            final String packageName = info.providerName.getPackageName();
+            showBrokenAppInstallDialog(packageName,
+                new DialogInterface.OnClickListener() {
+                    public void onClick(DialogInterface dialog, int id) {
+                        startActivitySafely(v, LauncherModel.getMarketIntent(packageName), info);
+                    }
+                });
+        } else {
+            // Download has started.
+            final String packageName = info.providerName.getPackageName();
+            startActivitySafely(v, LauncherModel.getMarketIntent(packageName), info);
+        }
+    }
+
+    /**
+     * Event handler for the "grid" button that appears on the home screen, which
+     * enters all apps mode.
+     *
+     * @param v The view that was clicked.
+     */
+    protected void onClickAllAppsButton(View v) {
+        if (LOGD) Log.d(TAG, "onClickAllAppsButton");
+        if (!isAppsViewVisible()) {
+            showAppsView(true /* animated */, false /* resetListToTop */,
+                    true /* updatePredictedApps */, false /* focusSearchBar */);
+
+            if (mLauncherCallbacks != null) {
+                mLauncherCallbacks.onClickAllAppsButton(v);
+            }
+        }
+    }
+
+    protected void onLongClickAllAppsButton(View v) {
+        if (LOGD) Log.d(TAG, "onLongClickAllAppsButton");
+        if (!isAppsViewVisible()) {
+            showAppsView(true /* animated */, false /* resetListToTop */,
+                    true /* updatePredictedApps */, true /* focusSearchBar */);
+        }
+    }
+
+    private void showBrokenAppInstallDialog(final String packageName,
+            DialogInterface.OnClickListener onSearchClickListener) {
+        new AlertDialog.Builder(this)
+            .setTitle(R.string.abandoned_promises_title)
+            .setMessage(R.string.abandoned_promise_explanation)
+            .setPositiveButton(R.string.abandoned_search, onSearchClickListener)
+            .setNeutralButton(R.string.abandoned_clean_this,
+                new DialogInterface.OnClickListener() {
+                    public void onClick(DialogInterface dialog, int id) {
+                        final UserHandleCompat user = UserHandleCompat.myUserHandle();
+                        mWorkspace.removeAbandonedPromise(packageName, user);
+                    }
+                })
+            .create().show();
+        return;
+    }
+
+    /**
+     * Event handler for an app shortcut click.
+     *
+     * @param v The view that was clicked. Must be a tagged with a {@link ShortcutInfo}.
+     */
+    protected void onClickAppShortcut(final View v) {
+        if (LOGD) Log.d(TAG, "onClickAppShortcut");
+        Object tag = v.getTag();
+        if (!(tag instanceof ShortcutInfo)) {
+            throw new IllegalArgumentException("Input must be a Shortcut");
+        }
+
+        // Open shortcut
+        final ShortcutInfo shortcut = (ShortcutInfo) tag;
+
+        if (shortcut.isDisabled != 0) {
+            if ((shortcut.isDisabled & ShortcutInfo.FLAG_DISABLED_SUSPENDED) != 0
+                || (shortcut.isDisabled & ShortcutInfo.FLAG_DISABLED_QUIET_USER) != 0) {
+                // Launch activity anyway, framework will tell the user why the app is suspended.
+            } else {
+                int error = R.string.activity_not_available;
+                if ((shortcut.isDisabled & ShortcutInfo.FLAG_DISABLED_SAFEMODE) != 0) {
+                    error = R.string.safemode_shortcut_error;
+                }
+                Toast.makeText(this, error, Toast.LENGTH_SHORT).show();
+                return;
+            }
+        }
+
+        // Check for abandoned promise
+        if ((v instanceof BubbleTextView)
+                && shortcut.isPromise()
+                && !shortcut.hasStatusFlag(ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE)) {
+            showBrokenAppInstallDialog(
+                    shortcut.getTargetComponent().getPackageName(),
+                    new DialogInterface.OnClickListener() {
+                        public void onClick(DialogInterface dialog, int id) {
+                            startAppShortcutOrInfoActivity(v);
+                        }
+                    });
+            return;
+        }
+
+        // Start activities
+        startAppShortcutOrInfoActivity(v);
+
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.onClickAppShortcut(v);
+        }
+    }
+
+    @Thunk void startAppShortcutOrInfoActivity(View v) {
+        Object tag = v.getTag();
+        final ShortcutInfo shortcut;
+        final Intent intent;
+        if (tag instanceof ShortcutInfo) {
+            shortcut = (ShortcutInfo) tag;
+            intent = shortcut.intent;
+            int[] pos = new int[2];
+            v.getLocationOnScreen(pos);
+            intent.setSourceBounds(new Rect(pos[0], pos[1],
+                    pos[0] + v.getWidth(), pos[1] + v.getHeight()));
+
+        } else if (tag instanceof AppInfo) {
+            shortcut = null;
+            intent = ((AppInfo) tag).intent;
+        } else {
+            throw new IllegalArgumentException("Input must be a Shortcut or AppInfo");
+        }
+
+        boolean success = startActivitySafely(v, intent, tag);
+        mStats.recordLaunch(v, intent, shortcut);
+        intent.setSourceBounds(null);
+
+        if (success && v instanceof BubbleTextView) {
+            mWaitingForResume = (BubbleTextView) v;
+            mWaitingForResume.setStayPressed(true);
+        }
+    }
+
+    /**
+     * Event handler for a folder icon click.
+     *
+     * @param v The view that was clicked. Must be an instance of {@link FolderIcon}.
+     */
+    protected void onClickFolderIcon(View v) {
+        if (LOGD) Log.d(TAG, "onClickFolder");
+        if (!(v instanceof FolderIcon)){
+            throw new IllegalArgumentException("Input must be a FolderIcon");
+        }
+
+        // TODO(sunnygoyal): Re-evaluate this code.
+        FolderIcon folderIcon = (FolderIcon) v;
+        final FolderInfo info = folderIcon.getFolderInfo();
+        Folder openFolder = mWorkspace.getFolderForTag(info);
+
+        // If the folder info reports that the associated folder is open, then verify that
+        // it is actually opened. There have been a few instances where this gets out of sync.
+        if (info.opened && openFolder == null) {
+            Log.d(TAG, "Folder info marked as open, but associated folder is not open. Screen: "
+                    + info.screenId + " (" + info.cellX + ", " + info.cellY + ")");
+            info.opened = false;
+        }
+
+        if (!info.opened && !folderIcon.getFolder().isDestroyed()) {
+            // Close any open folder
+            closeFolder();
+            // Open the requested folder
+            openFolder(folderIcon);
+        } else {
+            // Find the open folder...
+            int folderScreen;
+            if (openFolder != null) {
+                folderScreen = mWorkspace.getPageForView(openFolder);
+                // .. and close it
+                closeFolder(openFolder, true);
+                if (folderScreen != mWorkspace.getCurrentPage()) {
+                    // Close any folder open on the current screen
+                    closeFolder();
+                    // Pull the folder onto this screen
+                    openFolder(folderIcon);
+                }
+            }
+        }
+
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.onClickFolderIcon(v);
+        }
+    }
+
+    /**
+     * Event handler for the (Add) Widgets button that appears after a long press
+     * on the home screen.
+     */
+    protected void onClickAddWidgetButton(View view) {
+        if (LOGD) Log.d(TAG, "onClickAddWidgetButton");
+        if (mIsSafeModeEnabled) {
+            Toast.makeText(this, R.string.safemode_widget_error, Toast.LENGTH_SHORT).show();
+        } else {
+            showWidgetsView(true /* animated */, true /* resetPageToZero */);
+            if (mLauncherCallbacks != null) {
+                mLauncherCallbacks.onClickAddWidgetButton(view);
+            }
+        }
+    }
+
+    /**
+     * Event handler for the wallpaper picker button that appears after a long press
+     * on the home screen.
+     */
+    protected void onClickWallpaperPicker(View v) {
+        if (!Utilities.isWallapaperAllowed(this)) {
+            Toast.makeText(this, R.string.msg_disabled_by_admin, Toast.LENGTH_SHORT).show();
+            return;
+        }
+
+        if (LOGD) Log.d(TAG, "onClickWallpaperPicker");
+        int pageScroll = mWorkspace.getScrollForPage(mWorkspace.getPageNearestToCenterOfScreen());
+        float offset = mWorkspace.mWallpaperOffset.wallpaperOffsetForScroll(pageScroll);
+        startActivityForResult(new Intent(Intent.ACTION_SET_WALLPAPER).setPackage(getPackageName())
+                        .putExtra(WallpaperPickerActivity.EXTRA_WALLPAPER_OFFSET, offset),
+                REQUEST_PICK_WALLPAPER);
+
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.onClickWallpaperPicker(v);
+        }
+    }
+
+    /**
+     * Event handler for a click on the settings button that appears after a long press
+     * on the home screen.
+     */
+    protected void onClickSettingsButton(View v) {
+        if (LOGD) Log.d(TAG, "onClickSettingsButton");
+        if(FeatureOption.SPRD_SETTINGS_ACTIVITY_SUPPORT){
+            startActivity(new Intent(this, SprdSettingsActivity.class));
+        }else{
+            startActivity(new Intent(Settings.ACTION_SETTINGS));
+            return;
+        }
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.onClickSettingsButton(v);
+        }
+    }
+
+    public View.OnTouchListener getHapticFeedbackTouchListener() {
+        if (mHapticFeedbackTouchListener == null) {
+            mHapticFeedbackTouchListener = new View.OnTouchListener() {
+                @SuppressLint("ClickableViewAccessibility")
+                @Override
+                public boolean onTouch(View v, MotionEvent event) {
+                    if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) {
+                        v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
+                    }
+                    return false;
+                }
+            };
+        }
+        return mHapticFeedbackTouchListener;
+    }
+
+    public void onDragStarted(View view) {
+        if (isOnCustomContent()) {
+            // Custom content screen doesn't participate in drag and drop. If on custom
+            // content screen, move to default.
+            moveWorkspaceToDefaultScreen();
+        }
+
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.onDragStarted(view);
+        }
+    }
+
+    /**
+     * Called when the user stops interacting with the launcher.
+     * This implies that the user is now on the homescreen and is not doing housekeeping.
+     */
+    protected void onInteractionEnd() {
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.onInteractionEnd();
+        }
+    }
+
+    /**
+     * Called when the user starts interacting with the launcher.
+     * The possible interactions are:
+     *  - open all apps
+     *  - reorder an app shortcut, or a widget
+     *  - open the overview mode.
+     * This is a good time to stop doing things that only make sense
+     * when the user is on the homescreen and not doing housekeeping.
+     */
+    protected void onInteractionBegin() {
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.onInteractionBegin();
+        }
+    }
+
+    /** Updates the interaction state. */
+    public void updateInteraction(Workspace.State fromState, Workspace.State toState) {
+        // Only update the interacting state if we are transitioning to/from a view with an
+        // overlay
+        boolean fromStateWithOverlay = fromState != Workspace.State.NORMAL;
+        boolean toStateWithOverlay = toState != Workspace.State.NORMAL;
+        if (toStateWithOverlay) {
+            onInteractionBegin();
+        } else if (fromStateWithOverlay) {
+            onInteractionEnd();
+        }
+    }
+
+    void startApplicationDetailsActivity(ComponentName componentName, UserHandleCompat user) {
+        try {
+            LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
+            launcherApps.showAppDetailsForProfile(componentName, user);
+        } catch (SecurityException e) {
+            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
+            Log.e(TAG, "Launcher does not have permission to launch settings");
+        } catch (ActivityNotFoundException e) {
+            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
+            Log.e(TAG, "Unable to launch settings");
+        }
+    }
+
+    // returns true if the activity was started
+    boolean startApplicationUninstallActivity(ComponentName componentName, int flags,
+            UserHandleCompat user) {
+        if ((flags & AppInfo.DOWNLOADED_FLAG) == 0) {
+            // System applications cannot be installed. For now, show a toast explaining that.
+            // We may give them the option of disabling apps this way.
+            int messageId = R.string.uninstall_system_app_text;
+            Toast.makeText(this, messageId, Toast.LENGTH_SHORT).show();
+            return false;
+        } else {
+            String packageName = componentName.getPackageName();
+            String className = componentName.getClassName();
+            Intent intent = new Intent(
+                    Intent.ACTION_DELETE, Uri.fromParts("package", packageName, className));
+            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
+                    Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
+            if (user != null) {
+                user.addToIntent(intent, Intent.EXTRA_USER);
+            }
+            startActivity(intent);
+            return true;
+        }
+    }
+
+    private boolean startActivity(View v, Intent intent, Object tag) {
+        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        try {
+            // Only launch using the new animation if the shortcut has not opted out (this is a
+            // private contract between launcher and may be ignored in the future).
+            boolean useLaunchAnimation = (v != null) &&
+                    !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);
+            LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
+            UserManagerCompat userManager = UserManagerCompat.getInstance(this);
+
+            UserHandleCompat user = null;
+            if (intent.hasExtra(AppInfo.EXTRA_PROFILE)) {
+                long serialNumber = intent.getLongExtra(AppInfo.EXTRA_PROFILE, -1);
+                user = userManager.getUserForSerialNumber(serialNumber);
+            }
+
+            Bundle optsBundle = null;
+            if (useLaunchAnimation) {
+                ActivityOptions opts = null;
+                if (Utilities.ATLEAST_MARSHMALLOW) {
+                    int left = 0, top = 0;
+                    int width = v.getMeasuredWidth(), height = v.getMeasuredHeight();
+                    if (v instanceof TextView) {
+                        // Launch from center of icon, not entire view
+                        Drawable icon = Workspace.getTextViewIcon((TextView) v);
+                        if (icon != null) {
+                            Rect bounds = icon.getBounds();
+                            left = (width - bounds.width()) / 2;
+                            top = v.getPaddingTop();
+                            width = bounds.width();
+                            height = bounds.height();
+                        }
+                    }
+                    opts = ActivityOptions.makeClipRevealAnimation(v, left, top, width, height);
+                } else if (!Utilities.ATLEAST_LOLLIPOP) {
+                    // Below L, we use a scale up animation
+                    opts = ActivityOptions.makeScaleUpAnimation(v, 0, 0,
+                                    v.getMeasuredWidth(), v.getMeasuredHeight());
+                } else if (Utilities.ATLEAST_LOLLIPOP_MR1) {
+                    // On L devices, we use the device default slide-up transition.
+                    // On L MR1 devices, we a custom version of the slide-up transition which
+                    // doesn't have the delay present in the device default.
+                    opts = ActivityOptions.makeCustomAnimation(this,
+                            R.anim.task_open_enter, R.anim.no_anim);
+                }
+                optsBundle = opts != null ? opts.toBundle() : null;
+                //Bug 661753 add for animation
+                optsBundle = PlatformHelper.overrideOptsBundle(v, optsBundle, null);
+            }
+
+            if (user == null) {
+                user = UserHandleCompat.myUserHandle();
+            }
+            if (LOGD) LogUtils.d(TAG, "startActivity:" + intent.toString() + " user:" + user.toString());
+            if (user.equals(UserHandleCompat.myUserHandle())) {
+                StrictMode.VmPolicy oldPolicy = StrictMode.getVmPolicy();
+                try {
+                    // Temporarily disable deathPenalty on all default checks. For eg, shortcuts
+                    // containing file Uris would cause a crash as penaltyDeathOnFileUriExposure
+                    // is enabled by default on NYC.
+                    StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectAll()
+                            .penaltyLog().build());
+                    // Could be launching some bookkeeping activity
+                    startActivity(intent, optsBundle);
+                } finally {
+                    StrictMode.setVmPolicy(oldPolicy);
+                }
+            } else {
+                // TODO Component can be null when shortcuts are supported for secondary user
+                try {
+                    if (intent.getComponent() != null && !PlatformHelper.isAppCloneUser(user.getUser())) {
+                        launcherApps.startActivityForProfile(intent.getComponent(), user,
+                                intent.getSourceBounds(), optsBundle);
+                    } else {
+                        PlatformHelper.startActivityAsUser(this, intent, optsBundle, user.getUser());
+                    }
+                } catch (ActivityNotFoundException e) {
+                    LogUtils.w(TAG, "activity not found.intent:" + intent.toString());
+                    Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
+                    return false;
+                }
+            }
+            return true;
+        } catch (SecurityException e) {
+            if (Utilities.ATLEAST_MARSHMALLOW && tag instanceof ItemInfo) {
+                // Due to legacy reasons, direct call shortcuts require Launchers to have the
+                // corresponding permission. Show the appropriate permission prompt if that
+                // is the case.
+                if (intent.getComponent() == null
+                        && Intent.ACTION_CALL.equals(intent.getAction())
+                        && checkSelfPermission(Manifest.permission.CALL_PHONE) !=
+                            PackageManager.PERMISSION_GRANTED) {
+                    // TODO: Rename sPendingAddItem to a generic name.
+                    sPendingAddItem = preparePendingAddArgs(REQUEST_PERMISSION_CALL_PHONE, intent,
+                            0, (ItemInfo) tag);
+                    requestPermissions(new String[]{Manifest.permission.CALL_PHONE},
+                            REQUEST_PERMISSION_CALL_PHONE);
+                    return false;
+                }
+            }
+            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
+            Log.e(TAG, "Launcher does not have the permission to launch " + intent +
+                    ". Make sure to create a MAIN intent-filter for the corresponding activity " +
+                    "or use the exported attribute for this activity. "
+                    + "tag="+ tag + " intent=" + intent, e);
+        }
+        return false;
+    }
+
+    public boolean startActivitySafely(View v, Intent intent, Object tag) {
+        boolean success = false;
+        if (mIsSafeModeEnabled && !Utilities.isSystemApp(this, intent)) {
+            Toast.makeText(this, R.string.safemode_shortcut_error, Toast.LENGTH_SHORT).show();
+            return false;
+        }
+        try {
+            success = startActivity(v, intent, tag);
+            if (mPredictedAppController != null && success) {
+                mPredictedAppController.updatePredictedList(intent.getComponent());
+            }
+        } catch (ActivityNotFoundException e) {
+            if (v instanceof TextView){
+                return success;
+            }
+            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
+            Log.e(TAG, "Unable to launch. tag=" + tag + " intent=" + intent, e);
+        }
+        return success;
+    }
+
+    /**
+     * This method draws the FolderIcon to an ImageView and then adds and positions that ImageView
+     * in the DragLayer in the exact absolute location of the original FolderIcon.
+     */
+    private void copyFolderIconToImage(FolderIcon fi) {
+        final int width = fi.getMeasuredWidth();
+        final int height = fi.getMeasuredHeight();
+
+        // Lazy load ImageView, Bitmap and Canvas
+        if (mFolderIconImageView == null) {
+            mFolderIconImageView = new ImageView(this);
+        }
+        if (mFolderIconBitmap == null || mFolderIconBitmap.getWidth() != width ||
+                mFolderIconBitmap.getHeight() != height) {
+            mFolderIconBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+            mFolderIconCanvas = new Canvas(mFolderIconBitmap);
+        }
+
+        DragLayer.LayoutParams lp;
+        if (mFolderIconImageView.getLayoutParams() instanceof DragLayer.LayoutParams) {
+            lp = (DragLayer.LayoutParams) mFolderIconImageView.getLayoutParams();
+        } else {
+            lp = new DragLayer.LayoutParams(width, height);
+        }
+
+        // The layout from which the folder is being opened may be scaled, adjust the starting
+        // view size by this scale factor.
+        float scale = mDragLayer.getDescendantRectRelativeToSelf(fi, mRectForFolderAnimation);
+        lp.customPosition = true;
+        lp.x = mRectForFolderAnimation.left;
+        lp.y = mRectForFolderAnimation.top;
+        lp.width = (int) (scale * width);
+        lp.height = (int) (scale * height);
+
+        mFolderIconCanvas.drawColor(0, PorterDuff.Mode.CLEAR);
+        fi.draw(mFolderIconCanvas);
+        mFolderIconImageView.setImageBitmap(mFolderIconBitmap);
+        if (fi.getFolder() != null) {
+            mFolderIconImageView.setPivotX(fi.getFolder().getPivotXForIconAnimation());
+            mFolderIconImageView.setPivotY(fi.getFolder().getPivotYForIconAnimation());
+        }
+        // Just in case this image view is still in the drag layer from a previous animation,
+        // we remove it and re-add it.
+        if (mDragLayer.indexOfChild(mFolderIconImageView) != -1) {
+            mDragLayer.removeView(mFolderIconImageView);
+        }
+        mDragLayer.addView(mFolderIconImageView, lp);
+        if (fi.getFolder() != null) {
+            fi.getFolder().bringToFront();
+        }
+    }
+
+    private void growAndFadeOutFolderIcon(FolderIcon fi) {
+        if (fi == null) return;
+        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 0);
+        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1.5f);
+        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1.5f);
+
+        FolderInfo info = (FolderInfo) fi.getTag();
+        if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
+            CellLayout cl = (CellLayout) fi.getParent().getParent();
+            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) fi.getLayoutParams();
+            cl.setFolderLeaveBehindCell(lp.cellX, lp.cellY);
+        }
+
+        // Push an ImageView copy of the FolderIcon into the DragLayer and hide the original
+        copyFolderIconToImage(fi);
+        fi.setVisibility(View.INVISIBLE);
+
+        ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(mFolderIconImageView, alpha,
+                scaleX, scaleY);
+        if (Utilities.ATLEAST_LOLLIPOP) {
+            oa.setInterpolator(new LogDecelerateInterpolator(100, 0));
+        }
+        oa.setDuration(getResources().getInteger(R.integer.config_folderExpandDuration));
+        oa.start();
+    }
+
+    private void shrinkAndFadeInFolderIcon(final FolderIcon fi, boolean animate) {
+        if (fi == null) return;
+        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1.0f);
+        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1.0f);
+        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1.0f);
+
+        final CellLayout cl = (CellLayout) fi.getParent().getParent();
+
+        // We remove and re-draw the FolderIcon in-case it has changed
+        mDragLayer.removeView(mFolderIconImageView);
+        copyFolderIconToImage(fi);
+        ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(mFolderIconImageView, alpha,
+                scaleX, scaleY);
+        oa.setDuration(getResources().getInteger(R.integer.config_folderExpandDuration));
+        oa.addListener(new AnimatorListenerAdapter() {
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                if (cl != null) {
+                    cl.clearFolderLeaveBehind();
+                    // Remove the ImageView copy of the FolderIcon and make the original visible.
+                    mDragLayer.removeView(mFolderIconImageView);
+                    fi.setVisibility(View.VISIBLE);
+                }
+            }
+        });
+        oa.start();
+        if (!animate) {
+            oa.end();
+        }
+    }
+
+    /**
+     * Opens the user folder described by the specified tag. The opening of the folder
+     * is animated relative to the specified View. If the View is null, no animation
+     * is played.
+     *
+     * @param folderInfo The FolderInfo describing the folder to open.
+     */
+    public void openFolder(FolderIcon folderIcon) {
+        Folder folder = folderIcon.getFolder();
+        Folder openFolder = mWorkspace != null ? mWorkspace.getOpenFolder() : null;
+        if (openFolder != null && openFolder != folder) {
+            // Close any open folder before opening a folder.
+            closeFolder();
+        }
+
+        FolderInfo info = folder.mInfo;
+
+        info.opened = true;
+
+        // While the folder is open, the position of the icon cannot change.
+        ((CellLayout.LayoutParams) folderIcon.getLayoutParams()).canReorder = false;
+
+        // Just verify that the folder hasn't already been added to the DragLayer.
+        // There was a one-off crash where the folder had a parent already.
+        if (folder.getParent() == null) {
+            mDragLayer.addView(folder);
+            mDragController.addDropTarget((DropTarget) folder);
+        } else {
+            Log.w(TAG, "Opening folder (" + folder + ") which already has a parent (" +
+                    folder.getParent() + ").");
+        }
+        folder.animateOpen();
+        growAndFadeOutFolderIcon(folderIcon);
+
+        // Notify the accessibility manager that this folder "window" has appeared and occluded
+        // the workspace items
+        folder.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
+        getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
+    }
+
+    public void closeFolder() {
+        closeFolder(true);
+    }
+
+    public void closeFolder(boolean animate) {
+        Folder folder = mWorkspace != null ? mWorkspace.getOpenFolder() : null;
+        if (folder != null) {
+            if (folder.isEditingName()) {
+                folder.dismissEditingName();
+            }
+            closeFolder(folder, animate);
+        }
+    }
+
+    public void closeFolder(Folder folder, boolean animate) {
+        folder.getInfo().opened = false;
+
+        ViewParent viewParent = folder.getParent();
+        if(viewParent != null && viewParent.getParent() != null) {
+            FolderIcon fi = (FolderIcon) mWorkspace.getViewForTag(folder.mInfo);
+            shrinkAndFadeInFolderIcon(fi, animate);
+            if (fi != null) {
+                ((CellLayout.LayoutParams) fi.getLayoutParams()).canReorder = true;
+            }
+        }else{
+            if(LOGD) {
+                Log.d(TAG, "closeFolder, folder = "+ folder);
+            }
+        }
+        if (animate) {
+            folder.animateClosed();
+        } else {
+            folder.close(false);
+        }
+
+        // Notify the accessibility manager that this folder "window" has disappeared and no
+        // longer occludes the workspace items
+        getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
+    }
+
+    public boolean onLongClick(View v) {
+        if (!isDraggingEnabled()) return false;
+        if (isWorkspaceLocked()) return false;
+        if (mState != State.WORKSPACE) return false;
+
+        if (v == mAllAppsButton) {
+            onLongClickAllAppsButton(v);
+            return true;
+        }
+
+        if (v instanceof Workspace) {
+            if (!mWorkspace.isInOverviewMode()) {
+                if (!mWorkspace.isTouchActive()) {
+                    showOverviewMode(true);
+                    mWorkspace.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
+                            HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING);
+                    return true;
+                } else {
+                    return false;
+                }
+            } else {
+                return false;
+            }
+        }
+
+        CellLayout.CellInfo longClickCellInfo = null;
+        View itemUnderLongClick = null;
+        if (v.getTag() instanceof ItemInfo) {
+            ItemInfo info = (ItemInfo) v.getTag();
+            longClickCellInfo = new CellLayout.CellInfo(v, info);
+            itemUnderLongClick = longClickCellInfo.cell;
+            resetAddInfo();
+        }
+
+        // The hotseat touch handling does not go through Workspace, and we always allow long press
+        // on hotseat items.
+        final boolean inHotseat = isHotseatLayout(v);
+        if (!mDragController.isDragging()) {
+            if (itemUnderLongClick == null) {
+                // User long pressed on empty space
+                mWorkspace.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
+                        HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING);
+                if (mWorkspace.isInOverviewMode()) {
+                    mWorkspace.startReordering(v);
+                } else {
+                    showOverviewMode(true);
+                }
+            } else {
+                final boolean isAllAppsButton = inHotseat && isAllAppsButtonRank(
+                        mHotseat.getOrderInHotseat(
+                                longClickCellInfo.cellX,
+                                longClickCellInfo.cellY));
+                if (!(itemUnderLongClick instanceof Folder || isAllAppsButton)) {
+                    // User long pressed on an item
+                    mWorkspace.startDrag(longClickCellInfo);
+                }
+            }
+        }
+        return true;
+    }
+
+    boolean isHotseatLayout(View layout) {
+        return mHotseat != null && layout != null &&
+                (layout instanceof CellLayout) && (layout == mHotseat.getLayout());
+    }
+
+    /**
+     * Returns the CellLayout of the specified container at the specified screen.
+     */
+    public CellLayout getCellLayout(long container, long screenId) {
+        if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
+            if (mHotseat != null) {
+                return mHotseat.getLayout();
+            } else {
+                return null;
+            }
+        } else {
+            return mWorkspace.getScreenWithId(screenId);
+        }
+    }
+
+    /**
+     * For overridden classes.
+     */
+    public boolean isAllAppsVisible() {
+        return isAppsViewVisible();
+    }
+
+    public boolean isAppsViewVisible() {
+        return (mState == State.APPS) || (mOnResumeState == State.APPS);
+    }
+
+    public boolean isWidgetsViewVisible() {
+        return (mState == State.WIDGETS) || (mOnResumeState == State.WIDGETS);
+    }
+
+    public boolean isWorkspaceVisible() {
+        return (mState == State.WORKSPACE) || (mOnResumeState == State.WORKSPACE);
+    }
+
+    private void setWorkspaceBackground(int background) {
+        switch (background) {
+            case WORKSPACE_BACKGROUND_TRANSPARENT:
+                getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
+                break;
+            case WORKSPACE_BACKGROUND_BLACK:
+                getWindow().setBackgroundDrawable(null);
+                break;
+            default:
+                getWindow().setBackgroundDrawable(mWorkspaceBackgroundDrawable);
+        }
+    }
+
+    protected void changeWallpaperVisiblity(boolean visible) {
+        int wpflags = visible ? WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER : 0;
+        int curflags = getWindow().getAttributes().flags
+                & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
+        if (wpflags != curflags) {
+            getWindow().setFlags(wpflags, WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER);
+        }
+        setWorkspaceBackground(visible ? WORKSPACE_BACKGROUND_GRADIENT : WORKSPACE_BACKGROUND_BLACK);
+    }
+
+    @Override
+    public void onTrimMemory(int level) {
+        super.onTrimMemory(level);
+        if (level >= ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {
+            // The widget preview db can result in holding onto over
+            // 3MB of memory for caching which isn't necessary.
+            SQLiteDatabase.releaseMemory();
+
+            // This clears all widget bitmaps from the widget tray
+            // TODO(hyunyoungs)
+        }
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.onTrimMemory(level);
+        }
+    }
+
+    /**
+     * @return whether or not the Launcher state changed.
+     */
+    public boolean showWorkspace(boolean animated) {
+        return showWorkspace(WorkspaceStateTransitionAnimation.SCROLL_TO_CURRENT_PAGE, animated, null);
+    }
+
+    /**
+     * @return whether or not the Launcher state changed.
+     */
+    public boolean showWorkspace(boolean animated, Runnable onCompleteRunnable) {
+        return showWorkspace(WorkspaceStateTransitionAnimation.SCROLL_TO_CURRENT_PAGE, animated,
+                onCompleteRunnable);
+    }
+
+    /**
+     * @return whether or not the Launcher state changed.
+     */
+    protected boolean showWorkspace(int snapToPage, boolean animated) {
+        return showWorkspace(snapToPage, animated, null);
+    }
+
+    /**
+     * @return whether or not the Launcher state changed.
+     */
+    boolean showWorkspace(int snapToPage, boolean animated, Runnable onCompleteRunnable) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "showWorkspace: animated = " + animated + ", mState = " + mState);
+        }
+        boolean changed = mState != State.WORKSPACE ||
+                mWorkspace.getState() != Workspace.State.NORMAL;
+        if (changed) {
+            if (mWorkspace != null) {
+                mWorkspace.setVisibility(View.VISIBLE);
+                mWorkspace.setInOverviewMode(false);
+                mStateTransitionAnimation.startAnimationToWorkspace(mState, mWorkspace.getState(),
+                        Workspace.State.NORMAL, snapToPage, animated, onCompleteRunnable);
+            }
+
+            // Set focus to the AppsCustomize button
+            if (mAllAppsButton != null) {
+                mAllAppsButton.requestFocus();
+            }
+        }
+
+        // Change the state *after* we've called all the transition code
+        mState = State.WORKSPACE;
+
+        mPageIndicators.setVisibility(View.VISIBLE);
+
+        // Resume the auto-advance of widgets
+        mUserPresent = true;
+        updateAutoAdvanceState();
+
+        if (changed) {
+            // Send an accessibility event to announce the context change
+            getWindow().getDecorView()
+                    .sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
+        }
+        return changed;
+    }
+
+    /**
+     * Shows the overview button.
+     */
+    void showOverviewMode(boolean animated) {
+        mWorkspace.setInOverviewMode(true);
+        showOverviewMode(animated, false);
+    }
+
+    /**
+     * Shows the overview button, and if {@param requestButtonFocus} is set, will force the focus
+     * onto one of the overview panel buttons.
+     */
+    void showOverviewMode(boolean animated, boolean requestButtonFocus) {
+        Runnable postAnimRunnable = null;
+        if (requestButtonFocus) {
+            postAnimRunnable = new Runnable() {
+                @Override
+                public void run() {
+                    // Hitting the menu button when in touch mode does not trigger touch mode to
+                    // be disabled, so if requested, force focus on one of the overview panel
+                    // buttons.
+                    mOverviewPanel.requestFocusFromTouch();
+                }
+            };
+        }
+        mWorkspace.setVisibility(View.VISIBLE);
+        mStateTransitionAnimation.startAnimationToWorkspace(mState, mWorkspace.getState(),
+                Workspace.State.OVERVIEW,
+                WorkspaceStateTransitionAnimation.SCROLL_TO_CURRENT_PAGE, animated,
+                postAnimRunnable);
+        mState = State.WORKSPACE;
+    }
+
+    /**
+     * Shows the apps view.
+     */
+    void showAppsView(boolean animated, boolean resetListToTop, boolean updatePredictedApps,
+            boolean focusSearchBar) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "showAllApps: animated = " + animated + ", mState = " + mState + ", focusSearchBar = "+ focusSearchBar);
+        }
+        if (resetListToTop) {
+            mAppsView.scrollToTop();
+        }
+        if (updatePredictedApps) {
+            tryAndUpdatePredictedApps();
+        }
+        showAppsOrWidgets(State.APPS, animated, focusSearchBar);
+    }
+
+    /**
+     * Shows the widgets view.
+     */
+    void showWidgetsView(boolean animated, boolean resetPageToZero) {
+        if (LOGD) Log.d(TAG, "showWidgetsView:" + animated + " resetPageToZero:" + resetPageToZero);
+        if (resetPageToZero) {
+            mWidgetsView.scrollToTop();
+        }
+        showAppsOrWidgets(State.WIDGETS, animated, false);
+
+        mWidgetsView.post(new Runnable() {
+            @Override
+            public void run() {
+                mWidgetsView.requestFocus();
+            }
+        });
+    }
+
+    /**
+     * Sets up the transition to show the apps/widgets view.
+     *
+     * @return whether the current from and to state allowed this operation
+     */
+    // TODO: calling method should use the return value so that when {@code false} is returned
+    // the workspace transition doesn't fall into invalid state.
+    private boolean showAppsOrWidgets(State toState, boolean animated, boolean focusSearchBar) {
+        if (mState != State.WORKSPACE &&  mState != State.APPS_SPRING_LOADED &&
+                mState != State.WIDGETS_SPRING_LOADED) {
+            return false;
+        }
+        if (toState != State.APPS && toState != State.WIDGETS) {
+            return false;
+        }
+
+        if (toState == State.APPS) {
+            mStateTransitionAnimation.startAnimationToAllApps(mWorkspace.getState(), animated,
+                    focusSearchBar);
+        } else {
+            mStateTransitionAnimation.startAnimationToWidgets(mWorkspace.getState(), animated);
+        }
+
+        mPageIndicators.setVisibility(View.INVISIBLE);
+
+        // Change the state *after* we've called all the transition code
+        mState = toState;
+
+        // Pause the auto-advance of widgets until we are out of AllApps
+        mUserPresent = false;
+        updateAutoAdvanceState();
+        closeFolder();
+
+        // Send an accessibility event to announce the context change
+        getWindow().getDecorView()
+                .sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
+        return true;
+    }
+
+    /**
+     * Updates the workspace and interaction state on state change, and return the animation to this
+     * new state.
+     */
+    public Animator startWorkspaceStateChangeAnimation(Workspace.State toState, int toPage,
+            boolean animated, HashMap<View, Integer> layerViews) {
+        if (mWorkspace == null) {
+            return null;
+        }
+        Workspace.State fromState = mWorkspace.getState();
+        Animator anim = mWorkspace.setStateWithAnimation(toState, toPage, animated, layerViews);
+        updateInteraction(fromState, toState);
+        return anim;
+    }
+
+    public void enterSpringLoadedDragMode() {
+        if (LOGD) Log.d(TAG, String.format("enterSpringLoadedDragMode [mState=%s", mState.name()));
+        if (mState == State.WORKSPACE || mState == State.APPS_SPRING_LOADED ||
+                mState == State.WIDGETS_SPRING_LOADED) {
+            return;
+        }
+
+        mStateTransitionAnimation.startAnimationToWorkspace(mState, mWorkspace.getState(),
+                Workspace.State.SPRING_LOADED,
+                WorkspaceStateTransitionAnimation.SCROLL_TO_CURRENT_PAGE, true /* animated */,
+                null /* onCompleteRunnable */);
+        mState = isAppsViewVisible() ? State.APPS_SPRING_LOADED : State.WIDGETS_SPRING_LOADED;
+    }
+
+    public void exitSpringLoadedDragModeDelayed(final boolean successfulDrop, int delay,
+            final Runnable onCompleteRunnable) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "exitSpringLoadedDragModeDelayed successfulDrop = " + successfulDrop + ", delay = "
+                    + delay + ", mState = " + mState);
+        }
+        if (mState != State.APPS_SPRING_LOADED && mState != State.WIDGETS_SPRING_LOADED) return;
+
+        mHandler.postDelayed(new Runnable() {
+            @Override
+            public void run() {
+                if (successfulDrop) {
+                    // TODO(hyunyoungs): verify if this hack is still needed, if not, delete.
+                    //
+                    // Before we show workspace, hide all apps again because
+                    // exitSpringLoadedDragMode made it visible. This is a bit hacky; we should
+                    // clean up our state transition functions
+                    mWidgetsView.setVisibility(View.GONE);
+                    showWorkspace(true, onCompleteRunnable);
+                } else {
+                    exitSpringLoadedDragMode();
+                }
+            }
+        }, delay);
+    }
+
+    void exitSpringLoadedDragMode() {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "exitSpringLoadedDragMode mState = " + mState);
+        }
+        if (mState == State.APPS_SPRING_LOADED) {
+            showAppsView(true /* animated */, false /* resetListToTop */,
+                    false /* updatePredictedApps */, false /* focusSearchBar */);
+        } else if (mState == State.WIDGETS_SPRING_LOADED) {
+            showWidgetsView(true, false);
+        }
+    }
+
+    /**
+     * Updates the set of predicted apps if it hasn't been updated since the last time Launcher was
+     * resumed.
+     */
+    private void tryAndUpdatePredictedApps() {
+        if (mPredictedAppController != null) {
+            List<ComponentKey> apps = mPredictedAppController.getCurrentPredictedList();
+            if (apps != null) {
+                mAppsView.setPredictedApps(apps);
+            }
+            return;
+        }
+        if (mLauncherCallbacks != null) {
+            List<ComponentKey> apps = mLauncherCallbacks.getPredictedApps();
+            if (apps != null) {
+                mAppsView.setPredictedApps(apps);
+            }
+        }
+    }
+
+    void lockAllApps() {
+        // TODO
+    }
+
+    void unlockAllApps() {
+        // TODO
+    }
+
+    public boolean launcherCallbacksProvidesSearch() {
+        return (mLauncherCallbacks != null && mLauncherCallbacks.providesSearch());
+    }
+
+    public View getOrCreateQsbBar() {
+        if(FeatureOption.SPRD_HIDESEARCHBAR_SUPPORT) {
+            return null;
+        }
+        if (launcherCallbacksProvidesSearch()) {
+            return mLauncherCallbacks.getQsbBar();
+        }
+
+        if (mQsb == null) {
+            AppWidgetProviderInfo searchProvider = Utilities.getSearchWidgetProvider(this);
+            if (searchProvider == null) {
+                return null;
+            }
+
+            Bundle opts = new Bundle();
+            opts.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY,
+                    AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX);
+
+            // Determine the min and max dimensions of the widget.
+            LauncherAppState app = LauncherAppState.getInstance();
+            DeviceProfile portraitProfile = app.getInvariantDeviceProfile().portraitProfile;
+            DeviceProfile landscapeProfile = app.getInvariantDeviceProfile().landscapeProfile;
+            float density = getResources().getDisplayMetrics().density;
+            Point searchDimens = portraitProfile.getSearchBarDimensForWidgetOpts(getResources());
+            int maxHeight = (int) (searchDimens.y / density);
+            int minHeight = maxHeight;
+            int maxWidth = (int) (searchDimens.x / density);
+            int minWidth = maxWidth;
+            if (!landscapeProfile.isVerticalBarLayout()) {
+                searchDimens = landscapeProfile.getSearchBarDimensForWidgetOpts(getResources());
+                maxHeight = (int) Math.max(maxHeight, searchDimens.y / density);
+                minHeight = (int) Math.min(minHeight, searchDimens.y / density);
+                maxWidth = (int) Math.max(maxWidth, searchDimens.x / density);
+                minWidth = (int) Math.min(minWidth, searchDimens.x / density);
+            }
+            opts.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, maxHeight);
+            opts.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, minHeight);
+            opts.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, maxWidth);
+            opts.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, minWidth);
+            if (LOGD) {
+                Log.d(TAG, "QSB widget options: maxHeight=" + maxHeight + " minHeight=" + minHeight
+                        + " maxWidth=" + maxWidth + " minWidth=" + minWidth);
+            }
+
+            if (mLauncherCallbacks != null) {
+                opts.putAll(mLauncherCallbacks.getAdditionalSearchWidgetOptions());
+            }
+
+            int widgetId = mSharedPrefs.getInt(QSB_WIDGET_ID, -1);
+            AppWidgetProviderInfo widgetInfo = mAppWidgetManager.getAppWidgetInfo(widgetId);
+            if (!searchProvider.provider.flattenToString().equals(
+                    mSharedPrefs.getString(QSB_WIDGET_PROVIDER, null))
+                    || (widgetInfo == null)
+                    || !widgetInfo.provider.equals(searchProvider.provider)) {
+                // A valid widget is not already bound.
+                if (widgetId > -1) {
+                    mAppWidgetHost.deleteAppWidgetId(widgetId);
+                    widgetId = -1;
+                }
+
+                // Try to bind a new widget
+                widgetId = mAppWidgetHost.allocateAppWidgetId();
+
+                if (!AppWidgetManagerCompat.getInstance(this)
+                        .bindAppWidgetIdIfAllowed(widgetId, searchProvider, opts)) {
+                    mAppWidgetHost.deleteAppWidgetId(widgetId);
+                    widgetId = -1;
+                }
+
+                mSharedPrefs.edit()
+                    .putInt(QSB_WIDGET_ID, widgetId)
+                    .putString(QSB_WIDGET_PROVIDER, searchProvider.provider.flattenToString())
+                    .apply();
+            }
+
+            mAppWidgetHost.setQsbWidgetId(widgetId);
+            if (widgetId != -1) {
+                mQsb = mAppWidgetHost.createView(this, widgetId, searchProvider);
+                mQsb.setId(R.id.qsb_widget);
+                mQsb.updateAppWidgetOptions(opts);
+                mQsb.setPadding(0, 0, 0, 0);
+                mSearchDropTargetBar.addView(mQsb);
+                mSearchDropTargetBar.setQsbSearchBar(mQsb);
+            }
+        }
+        return mQsb;
+    }
+
+    private void reinflateQSBIfNecessary() {
+        if (mQsb instanceof LauncherAppWidgetHostView &&
+                ((LauncherAppWidgetHostView) mQsb).isReinflateRequired()) {
+            mSearchDropTargetBar.removeView(mQsb);
+            mQsb = null;
+            mSearchDropTargetBar.setQsbSearchBar(getOrCreateQsbBar());
+        }
+    }
+
+    @Override
+    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
+        final boolean result = super.dispatchPopulateAccessibilityEvent(event);
+        final List<CharSequence> text = event.getText();
+        text.clear();
+        // Populate event with a fake title based on the current state.
+        if (mState == State.APPS) {
+            text.add(getString(R.string.all_apps_button_label));
+        } else if (mState == State.WIDGETS) {
+            text.add(getString(R.string.widget_button_text));
+        } else if (mWorkspace != null) {
+            text.add(mWorkspace.getCurrentPageDescription());
+        } else {
+            text.add(getString(R.string.all_apps_home_button_label));
+        }
+        return result;
+    }
+
+    /**
+     * Receives notifications when system dialogs are to be closed.
+     */
+    @Thunk class CloseSystemDialogsIntentReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            closeSystemDialogs();
+        }
+    }
+
+    /**
+     * If the activity is currently paused, signal that we need to run the passed Runnable
+     * in onResume.
+     *
+     * This needs to be called from incoming places where resources might have been loaded
+     * while the activity is paused. That is because the Configuration (e.g., rotation)  might be
+     * wrong when we're not running, and if the activity comes back to what the configuration was
+     * when we were paused, activity is not restarted.
+     *
+     * Implementation of the method from LauncherModel.Callbacks.
+     *
+     * @return {@code true} if we are currently paused. The caller might be able to skip some work
+     */
+    @Thunk boolean waitUntilResume(Runnable run, boolean deletePreviousRunnables) {
+        if (mPaused) {
+            if (LOGD) Log.d(TAG, "Deferring update until onResume");
+            if (deletePreviousRunnables) {
+                while (mBindOnResumeCallbacks.remove(run)) {
+                }
+            }
+            mBindOnResumeCallbacks.add(run);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    private boolean waitUntilResume(Runnable run) {
+        return waitUntilResume(run, false);
+    }
+
+    public void addOnResumeCallback(Runnable run) {
+        mOnResumeCallbacks.add(run);
+    }
+
+    /**
+     * If the activity is currently paused, signal that we need to re-run the loader
+     * in onResume.
+     *
+     * This needs to be called from incoming places where resources might have been loaded
+     * while we are paused.  That is becaues the Configuration might be wrong
+     * when we're not running, and if it comes back to what it was when we
+     * were paused, we are not restarted.
+     *
+     * Implementation of the method from LauncherModel.Callbacks.
+     *
+     * @return true if we are currently paused.  The caller might be able to
+     * skip some work in that case since we will come back again.
+     */
+    public boolean setLoadOnResume() {
+        if (mPaused) {
+            if (LOGD) Log.d(TAG, "setLoadOnResume");
+            mOnResumeNeedsLoad = true;
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Implementation of the method from LauncherModel.Callbacks.
+     */
+    public int getCurrentWorkspaceScreen() {
+        if (mWorkspace != null) {
+            return mWorkspace.getCurrentPage();
+        } else {
+            return SCREEN_COUNT / 2;
+        }
+    }
+
+    /**
+     * Refreshes the shortcuts shown on the workspace.
+     *
+     * Implementation of the method from LauncherModel.Callbacks.
+     */
+    public void startBinding() {
+        setWorkspaceLoading(true);
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "startBinding: this = " + this);
+        }
+
+        // If we're starting binding all over again, clear any bind calls we'd postponed in
+        // the past (see waitUntilResume) -- we don't need them since we're starting binding
+        // from scratch again
+        mBindOnResumeCallbacks.clear();
+
+        // Clear the workspace because it's going to be rebound
+        mWorkspace.clearDropTargets();
+        mWorkspace.removeAllWorkspaceScreens();
+
+        mWidgetsToAdvance.clear();
+        if (mHotseat != null) {
+            mHotseat.resetLayout();
+        }
+    }
+
+    @Override
+    public void bindScreens(ArrayList<Long> orderedScreenIds) {
+        bindAddScreens(orderedScreenIds);
+
+        // If there are no screens, we need to have an empty screen
+        if (orderedScreenIds.size() == 0) {
+            mWorkspace.addExtraEmptyScreen();
+        }
+
+        // Create the custom content page (this call updates mDefaultScreen which calls
+        // setCurrentPage() so ensure that all pages are added before calling this).
+        if (hasCustomContentToLeft()) {
+            mWorkspace.createCustomContentContainer();
+            populateCustomContentContainer();
+        }
+    }
+
+    @Override
+    public void bindAddScreens(ArrayList<Long> orderedScreenIds) {
+        int count = orderedScreenIds.size();
+        for (int i = 0; i < count; i++) {
+            mWorkspace.insertNewWorkspaceScreenBeforeEmptyScreen(orderedScreenIds.get(i));
+        }
+    }
+
+    public void bindAppsAdded(final ArrayList<Long> newScreens,
+                              final ArrayList<ItemInfo> addNotAnimated,
+                              final ArrayList<ItemInfo> addAnimated,
+                              final ArrayList<AppInfo> addedApps) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "bindAppsAdded: " + Log.getStackTraceString(new Throwable())
+                    +", addedApps = " + addedApps);
+        }
+        Runnable r = new Runnable() {
+            public void run() {
+                bindAppsAdded(newScreens, addNotAnimated, addAnimated, addedApps);
+            }
+        };
+        if (waitUntilResume(r)) {
+            return;
+        }
+
+        // Add the new screens
+        if (newScreens != null) {
+            bindAddScreens(newScreens);
+        }
+
+        // We add the items without animation on non-visible pages, and with
+        // animations on the new page (which we will try and snap to).
+        if (addNotAnimated != null && !addNotAnimated.isEmpty()) {
+            bindItems(addNotAnimated, 0,
+                    addNotAnimated.size(), false);
+        }
+        if (addAnimated != null && !addAnimated.isEmpty()) {
+            bindItems(addAnimated, 0,
+                    addAnimated.size(), true);
+        }
+
+        // Remove the extra empty screen
+        mWorkspace.removeExtraEmptyScreen(false, false);
+
+        if (addedApps != null && mAppsView != null) {
+            mAppsView.addApps(addedApps);
+        }
+    }
+
+    /**
+     * Bind the items start-end from the list.
+     *
+     * Implementation of the method from LauncherModel.Callbacks.
+     */
+    @Override
+    public void bindItems(final ArrayList<ItemInfo> shortcuts, final int start, final int end,
+                          final boolean forceAnimateIcons) {
+        Runnable r = new Runnable() {
+            public void run() {
+                bindItems(shortcuts, start, end, forceAnimateIcons);
+            }
+        };
+        if (waitUntilResume(r)) {
+            return;
+        }
+
+        // Get the list of added shortcuts and intersect them with the set of shortcuts here
+        final AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
+        final Collection<Animator> bounceAnims = new ArrayList<Animator>();
+        final boolean animateIcons = forceAnimateIcons && canRunNewAppsAnimation();
+        Workspace workspace = mWorkspace;
+        long newShortcutsScreenId = -1;
+        for (int i = start; i < end; i++) {
+            final ItemInfo item = shortcuts.get(i);
+            if (LogUtils.DEBUG_ALL) {
+                LogUtils.d(TAG, "bindItems: start = " + start + ", end = " + end
+                        + "item = " + item + ", this = " + this);
+            }
+
+            // Short circuit if we are loading dock items for a configuration which has no dock
+            if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT &&
+                    mHotseat == null) {
+                continue;
+            }
+
+            final View view;
+            switch (item.itemType) {
+                case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
+                case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
+                    ShortcutInfo info = (ShortcutInfo) item;
+                    view = createShortcut(info);
+
+                    /*
+                     * TODO: FIX collision case
+                     */
+                    if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
+                        CellLayout cl = mWorkspace.getScreenWithId(item.screenId);
+                        if (cl != null && cl.isOccupied(item.cellX, item.cellY)) {
+                            View v = cl.getChildAt(item.cellX, item.cellY);
+                            Object tag = v.getTag();
+                            String desc = "Collision while binding workspace item: " + item
+                                    + ". Collides with " + tag;
+                            if (LauncherAppState.isDogfoodBuild()) {
+                                throw (new RuntimeException(desc));
+                            } else {
+                                Log.d(TAG, desc);
+                            }
+                        }
+                    }
+                    break;
+                case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
+                    view = FolderIcon.fromXml(R.layout.folder_icon, this,
+                            (ViewGroup) workspace.getChildAt(workspace.getCurrentPage()),
+                            (FolderInfo) item, mIconCache);
+                    break;
+                default:
+                    throw new RuntimeException("Invalid Item Type");
+            }
+
+            workspace.addInScreenFromBind(view, item.container, item.screenId, item.cellX,
+                    item.cellY, 1, 1);
+            if (animateIcons) {
+                // Animate all the applications up now
+                view.setAlpha(0f);
+                view.setScaleX(0f);
+                view.setScaleY(0f);
+                bounceAnims.add(createNewAppBounceAnimation(view, i));
+                newShortcutsScreenId = item.screenId;
+            }
+        }
+
+        if (animateIcons) {
+            // Animate to the correct page
+            if (newShortcutsScreenId > -1) {
+                long currentScreenId = mWorkspace.getScreenIdForPageIndex(mWorkspace.getNextPage());
+                final int newScreenIndex = mWorkspace.getPageIndexForScreenId(newShortcutsScreenId);
+                final Runnable startBounceAnimRunnable = new Runnable() {
+                    public void run() {
+                        anim.playTogether(bounceAnims);
+                        anim.start();
+                    }
+                };
+                if (newShortcutsScreenId != currentScreenId) {
+                    // We post the animation slightly delayed to prevent slowdowns
+                    // when we are loading right after we return to launcher.
+                    mWorkspace.postDelayed(new Runnable() {
+                        public void run() {
+                            if (mWorkspace != null) {
+                                mWorkspace.snapToPage(newScreenIndex);
+                                mWorkspace.postDelayed(startBounceAnimRunnable,
+                                        NEW_APPS_ANIMATION_DELAY);
+                            }
+                        }
+                    }, NEW_APPS_PAGE_MOVE_DELAY);
+                } else {
+                    mWorkspace.postDelayed(startBounceAnimRunnable, NEW_APPS_ANIMATION_DELAY);
+                }
+            }
+        }
+        workspace.requestLayout();
+    }
+
+    /**
+     * Implementation of the method from LauncherModel.Callbacks.
+     */
+    public void bindFolders(final LongArrayMap<FolderInfo> folders) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "bindFolders: this = " + this);
+        }
+        Runnable r = new Runnable() {
+            public void run() {
+                bindFolders(folders);
+            }
+        };
+        if (waitUntilResume(r)) {
+            return;
+        }
+        sFolders = folders.clone();
+    }
+
+    private void bindSafeModeWidget(LauncherAppWidgetInfo item) {
+        PendingAppWidgetHostView view = new PendingAppWidgetHostView(this, item, true);
+        view.updateIcon(mIconCache);
+        item.hostView = view;
+        item.hostView.updateAppWidget(null);
+        item.hostView.setOnClickListener(this);
+        addAppWidgetToWorkspace(item, null, false);
+        mWorkspace.requestLayout();
+    }
+
+    /**
+     * Add the views for a widget to the workspace.
+     *
+     * Implementation of the method from LauncherModel.Callbacks.
+     */
+    public void bindAppWidget(final LauncherAppWidgetInfo item) {
+        Runnable r = new Runnable() {
+            public void run() {
+                bindAppWidget(item);
+            }
+        };
+        if (waitUntilResume(r)) {
+            return;
+        }
+
+        if (mIsSafeModeEnabled) {
+            bindSafeModeWidget(item);
+            return;
+        }
+
+        final long start = DEBUG_WIDGETS ? SystemClock.uptimeMillis() : 0;
+        if (DEBUG_WIDGETS) {
+            Log.d(TAG, "bindAppWidget: " + item);
+        }
+
+        final LauncherAppWidgetProviderInfo appWidgetInfo;
+
+        if (item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)) {
+            // If the provider is not ready, bind as a pending widget.
+            appWidgetInfo = null;
+        } else if (item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_ID_NOT_VALID)) {
+            // The widget id is not valid. Try to find the widget based on the provider info.
+            appWidgetInfo = mAppWidgetManager.findProvider(item.providerName, item.user);
+        } else {
+            appWidgetInfo = mAppWidgetManager.getLauncherAppWidgetInfo(item.appWidgetId);
+        }
+
+        // If the provider is ready, but the width is not yet restored, try to restore it.
+        if (!item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) &&
+                (item.restoreStatus != LauncherAppWidgetInfo.RESTORE_COMPLETED)) {
+            if (appWidgetInfo == null) {
+                if (DEBUG_WIDGETS) {
+                    Log.d(TAG, "Removing restored widget: id=" + item.appWidgetId
+                            + " belongs to component " + item.providerName
+                            + ", as the povider is null");
+                }
+                LauncherModel.deleteItemFromDatabase(this, item);
+                return;
+            }
+
+            // If we do not have a valid id, try to bind an id.
+            if (item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_ID_NOT_VALID)) {
+                // Note: This assumes that the id remap broadcast is received before this step.
+                // If that is not the case, the id remap will be ignored and user may see the
+                // click to setup view.
+                PendingAddWidgetInfo pendingInfo = new PendingAddWidgetInfo(this, appWidgetInfo, null);
+                pendingInfo.spanX = item.spanX;
+                pendingInfo.spanY = item.spanY;
+                pendingInfo.minSpanX = item.minSpanX;
+                pendingInfo.minSpanY = item.minSpanY;
+                Bundle options = WidgetHostViewLoader.getDefaultOptionsForWidget(this, pendingInfo);
+
+                int newWidgetId = mAppWidgetHost.allocateAppWidgetId();
+                boolean success = mAppWidgetManager.bindAppWidgetIdIfAllowed(
+                        newWidgetId, appWidgetInfo, options);
+
+                // TODO consider showing a permission dialog when the widget is clicked.
+                if (!success) {
+                    mAppWidgetHost.deleteAppWidgetId(newWidgetId);
+                    if (DEBUG_WIDGETS) {
+                        Log.d(TAG, "Removing restored widget: id=" + item.appWidgetId
+                                + " belongs to component " + item.providerName
+                                + ", as the launcher is unable to bing a new widget id");
+                    }
+                    LauncherModel.deleteItemFromDatabase(this, item);
+                    return;
+                }
+
+                item.appWidgetId = newWidgetId;
+
+                // If the widget has a configure activity, it is still needs to set it up, otherwise
+                // the widget is ready to go.
+                item.restoreStatus = (appWidgetInfo.configure == null)
+                        ? LauncherAppWidgetInfo.RESTORE_COMPLETED
+                        : LauncherAppWidgetInfo.FLAG_UI_NOT_READY;
+
+                LauncherModel.updateItemInDatabase(this, item);
+            } else if (item.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_UI_NOT_READY)
+                    && (appWidgetInfo.configure == null)) {
+                // The widget was marked as UI not ready, but there is no configure activity to
+                // update the UI.
+                item.restoreStatus = LauncherAppWidgetInfo.RESTORE_COMPLETED;
+                LauncherModel.updateItemInDatabase(this, item);
+            }
+        }
+
+        if (item.restoreStatus == LauncherAppWidgetInfo.RESTORE_COMPLETED) {
+            if (DEBUG_WIDGETS) {
+                Log.d(TAG, "bindAppWidget: id=" + item.appWidgetId + " belongs to component "
+                        + appWidgetInfo.provider);
+            }
+
+            // Verify that we own the widget
+            if (appWidgetInfo == null) {
+                Log.e(TAG, "Removing invalid widget: id=" + item.appWidgetId);
+                deleteWidgetInfo(item);
+                return;
+            }
+
+            item.hostView = mAppWidgetHost.createView(this, item.appWidgetId, appWidgetInfo);
+            item.minSpanX = appWidgetInfo.minSpanX;
+            item.minSpanY = appWidgetInfo.minSpanY;
+            addAppWidgetToWorkspace(item, appWidgetInfo, false);
+        } else {
+            PendingAppWidgetHostView view = new PendingAppWidgetHostView(this, item,
+                    mIsSafeModeEnabled);
+            view.updateIcon(mIconCache);
+            item.hostView = view;
+            item.hostView.updateAppWidget(null);
+            item.hostView.setOnClickListener(this);
+            addAppWidgetToWorkspace(item, null, false);
+        }
+        mWorkspace.requestLayout();
+
+        if (DEBUG_WIDGETS) {
+            Log.d(TAG, "bound widget id="+item.appWidgetId+" in "
+                    + (SystemClock.uptimeMillis()-start) + "ms");
+        }
+    }
+
+    /**
+     * Restores a pending widget.
+     *
+     * @param appWidgetId The app widget id
+     * @param cellInfo The position on screen where to create the widget.
+     */
+    private void completeRestoreAppWidget(final int appWidgetId) {
+        LauncherAppWidgetHostView view = mWorkspace.getWidgetForAppWidgetId(appWidgetId);
+        if ((view == null) || !(view instanceof PendingAppWidgetHostView)) {
+            Log.e(TAG, "Widget update called, when the widget no longer exists.");
+            return;
+        }
+
+        LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) view.getTag();
+        info.restoreStatus = LauncherAppWidgetInfo.RESTORE_COMPLETED;
+
+        mWorkspace.reinflateWidgetsIfNecessary();
+        LauncherModel.updateItemInDatabase(this, info);
+    }
+
+    public void onPageBoundSynchronously(int page) {
+        mSynchronouslyBoundPages.add(page);
+    }
+
+    /**
+     * Callback saying that there aren't any more items to bind.
+     *
+     * Implementation of the method from LauncherModel.Callbacks.
+     */
+    public void finishBindingItems() {
+        if (LogUtils.DEBUG) {
+            LogUtils.d(TAG, "finishBindingItems: mSavedState = " + mSavedState + ", mSavedInstanceState = " + mSavedInstanceState);
+        }
+        Runnable r = new Runnable() {
+            public void run() {
+                finishBindingItems();
+            }
+        };
+        if (waitUntilResume(r)) {
+            return;
+        }
+        if (mSavedState != null) {
+            if (!mWorkspace.hasFocus()) {
+                mWorkspace.getChildAt(mWorkspace.getCurrentPage()).requestFocus();
+            }
+            mSavedState = null;
+        }
+
+        mWorkspace.restoreInstanceStateForRemainingPages();
+
+        setWorkspaceLoading(false);
+        sendLoadingCompleteBroadcastIfNecessary();
+        if (LogUtils.DEBUG_LOADER)LogUtils.d(TAG, "WorkspaceLoading Complete");
+
+        // If we received the result of any pending adds while the loader was running (e.g. the
+        // widget configuration forced an orientation change), process them now.
+        if (sPendingAddItem != null) {
+            final long screenId = completeAdd(sPendingAddItem);
+
+            // TODO: this moves the user to the page where the pending item was added. Ideally,
+            // the screen would be guaranteed to exist after bind, and the page would be set through
+            // the workspace restore process.
+            mWorkspace.post(new Runnable() {
+                @Override
+                public void run() {
+                    if (mWorkspace != null) {
+                        mWorkspace.snapToScreenId(screenId);
+                    }
+                }
+            });
+            sPendingAddItem = null;
+        }
+
+        InstallShortcutReceiver.disableAndFlushInstallQueue(this);
+
+        /*SPRD:598450 There is a empty screen when roating the screen @{*/
+        if(!mHasConfigWidget){
+            mWorkspace.removeExtraEmptyScreen(false, false);
+        }
+        /* @} */
+
+        if (FeatureOption.SPRD_UNREAD_INFO_SUPPORT) {
+            if (mUnreadLoadCompleted) {
+                bindWorkspaceUnreadInfo();
+            }
+            mBindingWorkspaceFinished = true;
+        }
+
+        if (FeatureOption.SPRD_DYNAMIC_ICON_SUPPORT) {
+            if (mDynamicIconLoadCompleted) {
+                bindWorkspaceDynamicInfo();
+            }
+            mBindingWorkspaceCompleted = true;
+        }
+
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.finishBindingItems(false);
+        }
+    }
+
+    private void sendLoadingCompleteBroadcastIfNecessary() {
+        if (!mSharedPrefs.getBoolean(FIRST_LOAD_COMPLETE, false)) {
+            String permission =
+                    getResources().getString(R.string.receive_first_load_broadcast_permission);
+            Intent intent = new Intent(ACTION_FIRST_LOAD_COMPLETE);
+            sendBroadcast(intent, permission);
+            SharedPreferences.Editor editor = mSharedPrefs.edit();
+            editor.putBoolean(FIRST_LOAD_COMPLETE, true);
+            editor.apply();
+        }
+    }
+
+    public boolean isAllAppsButtonRank(int rank) {
+        if (mHotseat != null) {
+            return mHotseat.isAllAppsButtonRank(rank);
+        }
+        return false;
+    }
+
+    private boolean canRunNewAppsAnimation() {
+        long diff = System.currentTimeMillis() - mDragController.getLastGestureUpTime();
+        return diff > (NEW_APPS_ANIMATION_INACTIVE_TIMEOUT_SECONDS * 1000)
+                && (mClings == null || !mClings.isVisible());
+    }
+
+    private ValueAnimator createNewAppBounceAnimation(View v, int i) {
+        ValueAnimator bounceAnim = LauncherAnimUtils.ofPropertyValuesHolder(v,
+                PropertyValuesHolder.ofFloat("alpha", 1f),
+                PropertyValuesHolder.ofFloat("scaleX", 1f),
+                PropertyValuesHolder.ofFloat("scaleY", 1f));
+        bounceAnim.setDuration(InstallShortcutReceiver.NEW_SHORTCUT_BOUNCE_DURATION);
+        bounceAnim.setStartDelay(i * InstallShortcutReceiver.NEW_SHORTCUT_STAGGER_DELAY);
+        bounceAnim.setInterpolator(new OvershootInterpolator(BOUNCE_ANIMATION_TENSION));
+        return bounceAnim;
+    }
+
+    public boolean useVerticalBarLayout() {
+        return mDeviceProfile.isVerticalBarLayout();
+    }
+
+    /** Returns the search bar bounds in pixels. */
+    public Rect getSearchBarBounds() {
+        return mDeviceProfile.getSearchBarBounds(Utilities.isRtl(getResources()));
+    }
+
+    public int getSearchBarHeight() {
+        if (mLauncherCallbacks != null) {
+            return mLauncherCallbacks.getSearchBarHeight();
+        }
+        return LauncherCallbacks.SEARCH_BAR_HEIGHT_NORMAL;
+    }
+
+    public void bindSearchProviderChanged() {
+        if(FeatureOption.SPRD_HIDESEARCHBAR_SUPPORT) {
+            return;
+        }
+        if (mSearchDropTargetBar == null) {
+            return;
+        }
+        if (mQsb != null) {
+            mSearchDropTargetBar.removeView(mQsb);
+            mQsb = null;
+        }
+        mSearchDropTargetBar.setQsbSearchBar(getOrCreateQsbBar());
+    }
+
+    /**
+     * A runnable that we can dequeue and re-enqueue when all applications are bound (to prevent
+     * multiple calls to bind the same list.)
+     */
+    @Thunk ArrayList<AppInfo> mTmpAppsList;
+    private Runnable mBindAllApplicationsRunnable = new Runnable() {
+        public void run() {
+            bindAllApplications(mTmpAppsList);
+            mTmpAppsList = null;
+        }
+    };
+
+    /**
+     * Add the icons for all apps.
+     *
+     * Implementation of the method from LauncherModel.Callbacks.
+     */
+    public void bindAllApplications(final ArrayList<AppInfo> apps) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "bindAllApplications: apps.size = " + apps.size());
+        }
+        if (waitUntilResume(mBindAllApplicationsRunnable, true)) {
+            mTmpAppsList = apps;
+            return;
+        }
+
+        if (mDynamicIconUtils != null) {
+            mDynamicIconUtils.updateDIDCInAppInfo(apps);
+        }
+
+        if (mAppsView != null) {
+            mAppsView.setApps(apps);
+        }
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.bindAllApplications(apps);
+        }
+    }
+
+    /**
+     * A package was updated.
+     *
+     * Implementation of the method from LauncherModel.Callbacks.
+     */
+    public void bindAppsUpdated(final ArrayList<AppInfo> apps) {
+        if (LogUtils.DEBUG) {
+            LogUtils.d(TAG, "bindAppsUpdated: apps = " + apps);
+        }
+        Runnable r = new Runnable() {
+            public void run() {
+                bindAppsUpdated(apps);
+            }
+        };
+        if (waitUntilResume(r)) {
+            return;
+        }
+
+        if (mAppsView != null) {
+            mAppsView.updateApps(apps);
+        }
+    }
+
+    @Override
+    public void bindWidgetsRestored(final ArrayList<LauncherAppWidgetInfo> widgets) {
+        Runnable r = new Runnable() {
+            public void run() {
+                bindWidgetsRestored(widgets);
+            }
+        };
+        if (waitUntilResume(r)) {
+            return;
+        }
+        mWorkspace.widgetsRestored(widgets);
+    }
+
+    /**
+     * Some shortcuts were updated in the background.
+     *
+     * Implementation of the method from LauncherModel.Callbacks.
+     */
+    @Override
+    public void bindShortcutsChanged(final ArrayList<ShortcutInfo> updated,
+            final ArrayList<ShortcutInfo> removed, final UserHandleCompat user) {
+        Runnable r = new Runnable() {
+            public void run() {
+                bindShortcutsChanged(updated, removed, user);
+            }
+        };
+        if (waitUntilResume(r)) {
+            return;
+        }
+
+        if (!updated.isEmpty()) {
+            mWorkspace.updateShortcuts(updated);
+        }
+
+        if (!removed.isEmpty()) {
+            HashSet<ComponentName> removedComponents = new HashSet<ComponentName>();
+            for (ShortcutInfo si : removed) {
+                removedComponents.add(si.getTargetComponent());
+            }
+            mWorkspace.removeItemsByComponentName(removedComponents, user);
+            // Notify the drag controller
+            mDragController.onAppsRemoved(new HashSet<String>(), removedComponents);
+        }
+    }
+
+    /**
+     * Update the state of a package, typically related to install state.
+     *
+     * Implementation of the method from LauncherModel.Callbacks.
+     */
+    @Override
+    public void bindRestoreItemsChange(final HashSet<ItemInfo> updates) {
+        Runnable r = new Runnable() {
+            public void run() {
+                bindRestoreItemsChange(updates);
+            }
+        };
+        if (waitUntilResume(r)) {
+            return;
+        }
+
+        mWorkspace.updateRestoreItems(updates);
+    }
+
+    /**
+     * A package was uninstalled/updated.  We take both the super set of packageNames
+     * in addition to specific applications to remove, the reason being that
+     * this can be called when a package is updated as well.  In that scenario,
+     * we only remove specific components from the workspace and hotseat, where as
+     * package-removal should clear all items by package name.
+     */
+    @Override
+    public void bindWorkspaceComponentsRemoved(
+            final HashSet<String> packageNames, final HashSet<ComponentName> components,
+            final UserHandleCompat user) {
+        if (LogUtils.DEBUG_ALL) {
+            LogUtils.d(TAG, "bindComponentsRemoved: " + Log.getStackTraceString(new Throwable())+
+                    ", packageNames = " + packageNames);
+        }
+        Runnable r = new Runnable() {
+            public void run() {
+                bindWorkspaceComponentsRemoved(packageNames, components, user);
+            }
+        };
+        if (waitUntilResume(r)) {
+            return;
+        }
+        if (!packageNames.isEmpty()) {
+            mWorkspace.removeItemsByPackageName(packageNames, user);
+        }
+        if (!components.isEmpty()) {
+            mWorkspace.removeItemsByComponentName(components, user);
+        }
+        // Notify the drag controller
+        mDragController.onAppsRemoved(packageNames, components);
+
+    }
+
+    @Override
+    public void bindAppInfosRemoved(final ArrayList<AppInfo> appInfos) {
+        Runnable r = new Runnable() {
+            public void run() {
+                bindAppInfosRemoved(appInfos);
+            }
+        };
+        if (waitUntilResume(r)) {
+            return;
+        }
+
+        // Update AllApps
+        if (mAppsView != null) {
+            mAppsView.removeApps(appInfos);
+            if (mPredictedAppController != null) {
+                mPredictedAppController.removeAppsFromPredicteList(appInfos);
+            }
+        }
+    }
+
+    private Runnable mBindWidgetModelRunnable = new Runnable() {
+            public void run() {
+                bindWidgetsModel(mWidgetsModel);
+            }
+        };
+
+    @Override
+    public void bindWidgetsModel(WidgetsModel model) {
+        if (waitUntilResume(mBindWidgetModelRunnable, true)) {
+            mWidgetsModel = model;
+            return;
+        }
+
+        if (mWidgetsView != null && model != null) {
+            mWidgetsView.addWidgets(model);
+            mWidgetsModel = null;
+        }
+    }
+
+    @Override
+    public void notifyWidgetProvidersChanged() {
+        if (mWorkspace != null && mWorkspace.getState().shouldUpdateWidget) {
+            mModel.refreshAndBindWidgetsAndShortcuts(this, mWidgetsView.isEmpty());
+        }
+    }
+
+    private int mapConfigurationOriActivityInfoOri(int configOri) {
+        final Display d = getWindowManager().getDefaultDisplay();
+        int naturalOri = Configuration.ORIENTATION_LANDSCAPE;
+        switch (d.getRotation()) {
+        case Surface.ROTATION_0:
+        case Surface.ROTATION_180:
+            // We are currently in the same basic orientation as the natural orientation
+            naturalOri = configOri;
+            break;
+        case Surface.ROTATION_90:
+        case Surface.ROTATION_270:
+            // We are currently in the other basic orientation to the natural orientation
+            naturalOri = (configOri == Configuration.ORIENTATION_LANDSCAPE) ?
+                    Configuration.ORIENTATION_PORTRAIT : Configuration.ORIENTATION_LANDSCAPE;
+            break;
+        }
+
+        int[] oriMap = {
+                ActivityInfo.SCREEN_ORIENTATION_PORTRAIT,
+                ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE,
+                ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT,
+                ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE
+        };
+        // Since the map starts at portrait, we need to offset if this device's natural orientation
+        // is landscape.
+        int indexOffset = 0;
+        if (naturalOri == Configuration.ORIENTATION_LANDSCAPE) {
+            indexOffset = 1;
+        }
+        return oriMap[(d.getRotation() + indexOffset) % 4];
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)
+    public void lockScreenOrientation() {
+        if (mRotationEnabled) {
+            if (Utilities.ATLEAST_JB_MR2) {
+                setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LOCKED);
+            } else {
+                setRequestedOrientation(mapConfigurationOriActivityInfoOri(getResources()
+                        .getConfiguration().orientation));
+            }
+        }
+    }
+
+    public void unlockScreenOrientation(boolean immediate) {
+        if (mRotationEnabled) {
+            if (immediate) {
+                setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
+            } else {
+                mHandler.postDelayed(new Runnable() {
+                    public void run() {
+                        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
+                    }
+                }, mRestoreScreenOrientationDelay);
+            }
+        }
+    }
+
+    protected boolean isLauncherPreinstalled() {
+        if (mLauncherCallbacks != null) {
+            return mLauncherCallbacks.isLauncherPreinstalled();
+        }
+        PackageManager pm = getPackageManager();
+        try {
+            ApplicationInfo ai = pm.getApplicationInfo(getComponentName().getPackageName(), 0);
+            if ((ai.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
+                return true;
+            } else {
+                return false;
+            }
+        } catch (NameNotFoundException e) {
+            e.printStackTrace();
+            return false;
+        }
+    }
+
+    /**
+     * This method indicates whether or not we should suggest default wallpaper dimensions
+     * when our wallpaper cropper was not yet used to set a wallpaper.
+     */
+    protected boolean overrideWallpaperDimensions() {
+        if (mLauncherCallbacks != null) {
+            return mLauncherCallbacks.overrideWallpaperDimensions();
+        }
+        return true;
+    }
+
+    /**
+     * To be overridden by subclasses to indicate that there is an activity to launch
+     * before showing the standard launcher experience.
+     */
+    protected boolean hasFirstRunActivity() {
+        if (mLauncherCallbacks != null) {
+            return mLauncherCallbacks.hasFirstRunActivity();
+        }
+        return false;
+    }
+
+    /**
+     * To be overridden by subclasses to launch any first run activity
+     */
+    protected Intent getFirstRunActivity() {
+        if (mLauncherCallbacks != null) {
+            return mLauncherCallbacks.getFirstRunActivity();
+        }
+        return null;
+    }
+
+    private boolean shouldRunFirstRunActivity() {
+        return !ActivityManager.isRunningInTestHarness() &&
+                !mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false);
+    }
+
+    protected boolean hasRunFirstRunActivity() {
+        return mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, false);
+    }
+
+    public boolean showFirstRunActivity() {
+        if (shouldRunFirstRunActivity() &&
+                hasFirstRunActivity()) {
+            Intent firstRunIntent = getFirstRunActivity();
+            if (firstRunIntent != null) {
+                startActivity(firstRunIntent);
+                markFirstRunActivityShown();
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void markFirstRunActivityShown() {
+        SharedPreferences.Editor editor = mSharedPrefs.edit();
+        editor.putBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, true);
+        editor.apply();
+    }
+
+    /**
+     * To be overridden by subclasses to indicate that there is an in-activity full-screen intro
+     * screen that must be displayed and dismissed.
+     */
+    protected boolean hasDismissableIntroScreen() {
+        if (mLauncherCallbacks != null) {
+            return mLauncherCallbacks.hasDismissableIntroScreen();
+        }
+        return false;
+    }
+
+    /**
+     * Full screen intro screen to be shown and dismissed before the launcher can be used.
+     */
+    protected View getIntroScreen() {
+        if (mLauncherCallbacks != null) {
+            return mLauncherCallbacks.getIntroScreen();
+        }
+        return null;
+    }
+
+    /**
+     * To be overriden by subclasses to indicate whether the in-activity intro screen has been
+     * dismissed. This method is ignored if #hasDismissableIntroScreen returns false.
+     */
+    private boolean shouldShowIntroScreen() {
+        return hasDismissableIntroScreen() &&
+                !mSharedPrefs.getBoolean(INTRO_SCREEN_DISMISSED, false);
+    }
+
+    protected void showIntroScreen() {
+        View introScreen = getIntroScreen();
+        changeWallpaperVisiblity(false);
+        if (introScreen != null) {
+            mDragLayer.showOverlayView(introScreen);
+        }
+    }
+
+    public void dismissIntroScreen() {
+        markIntroScreenDismissed();
+        if (showFirstRunActivity()) {
+            // We delay hiding the intro view until the first run activity is showing. This
+            // avoids a blip.
+            mWorkspace.postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    mDragLayer.dismissOverlayView();
+                    showFirstRunClings();
+                }
+            }, ACTIVITY_START_DELAY);
+        } else {
+            mDragLayer.dismissOverlayView();
+            showFirstRunClings();
+        }
+        changeWallpaperVisiblity(true);
+    }
+
+    private void markIntroScreenDismissed() {
+        SharedPreferences.Editor editor = mSharedPrefs.edit();
+        editor.putBoolean(INTRO_SCREEN_DISMISSED, true);
+        editor.apply();
+    }
+
+    @Thunk void showFirstRunClings() {
+        // The two first run cling paths are mutually exclusive, if the launcher is preinstalled
+        // on the device, then we always show the first run cling experience (or if there is no
+        // launcher2). Otherwise, we prompt the user upon started for migration
+        LauncherClings launcherClings = new LauncherClings(this);
+        if (launcherClings.shouldShowFirstRunOrMigrationClings()) {
+            mClings = launcherClings;
+            if (mModel.canMigrateFromOldLauncherDb(this)) {
+                launcherClings.showMigrationCling();
+            } else {
+                launcherClings.showLongPressCling(true);
+            }
+        }
+    }
+
+    public void showWorkspaceSearchAndHotseat() {
+        if (mWorkspace != null) mWorkspace.setAlpha(1f);
+        if (mHotseat != null) mHotseat.setAlpha(1f);
+        if (mPageIndicators != null) mPageIndicators.setAlpha(1f);
+        if (mSearchDropTargetBar != null) mSearchDropTargetBar.animateToState(
+                SearchDropTargetBar.State.SEARCH_BAR, 0);
+    }
+
+    void hideWorkspaceSearchAndHotseat() {
+        if (mWorkspace != null) mWorkspace.setAlpha(0f);
+        if (mHotseat != null) mHotseat.setAlpha(0f);
+        if (mPageIndicators != null) mPageIndicators.setAlpha(0f);
+        if (mSearchDropTargetBar != null) mSearchDropTargetBar.animateToState(
+                SearchDropTargetBar.State.INVISIBLE, 0);
+    }
+
+    // TODO: These method should be a part of LauncherSearchCallback
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    public ItemInfo createAppDragInfo(Intent appLaunchIntent) {
+        // Called from search suggestion
+        UserHandleCompat user = null;
+        if (Utilities.ATLEAST_LOLLIPOP) {
+            UserHandle userHandle = appLaunchIntent.getParcelableExtra(Intent.EXTRA_USER);
+            if (userHandle != null) {
+                user = UserHandleCompat.fromUser(userHandle);
+            }
+        }
+        return createAppDragInfo(appLaunchIntent, user);
+    }
+
+    // TODO: This method should be a part of LauncherSearchCallback
+    public ItemInfo createAppDragInfo(Intent intent, UserHandleCompat user) {
+        if (user == null) {
+            user = UserHandleCompat.myUserHandle();
+        }
+
+        // Called from search suggestion, add the profile extra to the intent to ensure that we
+        // can launch it correctly
+        LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
+        LauncherActivityInfoCompat activityInfo = launcherApps.resolveActivity(intent, user);
+        if (activityInfo == null) {
+            return null;
+        }
+        return new AppInfo(this, activityInfo, user, mIconCache);
+    }
+
+    // TODO: This method should be a part of LauncherSearchCallback
+    public ItemInfo createShortcutDragInfo(Intent shortcutIntent, CharSequence caption,
+            Bitmap icon) {
+        return new ShortcutInfo(shortcutIntent, caption, caption, icon,
+                UserHandleCompat.myUserHandle());
+    }
+
+    // TODO: This method should be a part of LauncherSearchCallback
+    public void startDrag(View dragView, ItemInfo dragInfo, DragSource source) {
+        dragView.setTag(dragInfo);
+        mWorkspace.onExternalDragStartedWithItem(dragView);
+        mWorkspace.beginExternalDragShared(dragView, source);
+    }
+
+    protected void moveWorkspaceToDefaultScreen() {
+        mWorkspace.moveToDefaultScreen(false);
+    }
+
+    @Override
+    public void onPageSwitch(View newPage, int newPageIndex) {
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.onPageSwitch(newPage, newPageIndex);
+        }
+    }
+
+    /**
+     * Returns a FastBitmapDrawable with the icon, accurately sized.
+     */
+    public FastBitmapDrawable createIconDrawable(Bitmap icon) {
+        FastBitmapDrawable d = new FastBitmapDrawable(icon);
+        d.setFilterBitmap(true);
+        resizeIconDrawable(d);
+        return d;
+    }
+
+    /**
+     * Resizes an icon drawable to the correct icon size.
+     */
+    public Drawable resizeIconDrawable(Drawable icon) {
+        icon.setBounds(0, 0, mDeviceProfile.iconSizePx, mDeviceProfile.iconSizePx);
+        return icon;
+    }
+
+    /**
+     * Prints out out state for debugging.
+     */
+    public void dumpState() {
+        Log.d(TAG, "BEGIN launcher3 dump state for launcher " + this);
+        Log.d(TAG, "mSavedState=" + mSavedState);
+        Log.d(TAG, "mWorkspaceLoading=" + mWorkspaceLoading);
+        Log.d(TAG, "mRestoring=" + mRestoring);
+        Log.d(TAG, "mWaitingForResult=" + mWaitingForResult);
+        Log.d(TAG, "mSavedInstanceState=" + mSavedInstanceState);
+        Log.d(TAG, "sFolders.size=" + sFolders.size());
+        mModel.dumpState();
+        // TODO(hyunyoungs): add mWidgetsView.dumpState(); or mWidgetsModel.dumpState();
+
+        Log.d(TAG, "END launcher3 dump state");
+    }
+
+    @Override
+    public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args) {
+        super.dump(prefix, fd, writer, args);
+        synchronized (sDumpLogs) {
+            writer.println(" ");
+            writer.println("Debug logs: ");
+            for (int i = 0; i < sDumpLogs.size(); i++) {
+                writer.println("  " + sDumpLogs.get(i));
+            }
+        }
+        if (mLauncherCallbacks != null) {
+            mLauncherCallbacks.dump(prefix, fd, writer, args);
+        }
+    }
+
+    public static void dumpDebugLogsToConsole() {
+        if (DEBUG_DUMP_LOG) {
+            synchronized (sDumpLogs) {
+                Log.d(TAG, "");
+                Log.d(TAG, "*********************");
+                Log.d(TAG, "Launcher debug logs: ");
+                for (int i = 0; i < sDumpLogs.size(); i++) {
+                    Log.d(TAG, "  " + sDumpLogs.get(i));
+                }
+                Log.d(TAG, "*********************");
+                Log.d(TAG, "");
+            }
+        }
+    }
+
+    public static void addDumpLog(String tag, String log, boolean debugLog) {
+        addDumpLog(tag, log, null, debugLog);
+    }
+
+    public static void addDumpLog(String tag, String log, Exception e, boolean debugLog) {
+        if (debugLog) {
+            if (e != null) {
+                Log.d(tag, log, e);
+            } else {
+                Log.d(tag, log);
+            }
+        }
+        if (DEBUG_DUMP_LOG) {
+            sDateStamp.setTime(System.currentTimeMillis());
+            synchronized (sDumpLogs) {
+                sDumpLogs.add(sDateFormat.format(sDateStamp) + ": " + tag + ", " + log
+                    + (e == null ? "" : (", Exception: " + e)));
+            }
+        }
+    }
+
+    public static CustomAppWidget getCustomAppWidget(String name) {
+        return sCustomAppWidgets.get(name);
+    }
+
+    public static HashMap<String, CustomAppWidget> getCustomAppWidgets() {
+        return sCustomAppWidgets;
+    }
+
+    public void dumpLogsToLocalData() {
+        if (DEBUG_DUMP_LOG) {
+            new AsyncTask<Void, Void, Void>() {
+                public Void doInBackground(Void ... args) {
+                    boolean success = false;
+                    sDateStamp.setTime(sRunStart);
+                    String FILENAME = sDateStamp.getMonth() + "-"
+                            + sDateStamp.getDay() + "_"
+                            + sDateStamp.getHours() + "-"
+                            + sDateStamp.getMinutes() + "_"
+                            + sDateStamp.getSeconds() + ".txt";
+
+                    FileOutputStream fos = null;
+                    File outFile = null;
+                    try {
+                        outFile = new File(getFilesDir(), FILENAME);
+                        outFile.createNewFile();
+                        fos = new FileOutputStream(outFile);
+                    } catch (Exception e) {
+                        e.printStackTrace();
+                    }
+                    if (fos != null) {
+                        PrintWriter writer = new PrintWriter(fos);
+
+                        writer.println(" ");
+                        writer.println("Debug logs: ");
+                        synchronized (sDumpLogs) {
+                            for (int i = 0; i < sDumpLogs.size(); i++) {
+                                writer.println("  " + sDumpLogs.get(i));
+                            }
+                        }
+                        writer.close();
+                    }
+                    try {
+                        if (fos != null) {
+                            fos.close();
+                            success = true;
+                        }
+                    } catch (IOException e) {
+                        e.printStackTrace();
+                    }
+                    return null;
+                }
+            }.executeOnExecutor(Utilities.THREAD_POOL_EXECUTOR);
+        }
+    }
+
+    public static List<View> getFolderContents(View icon) {
+        if (icon instanceof FolderIcon) {
+            return ((FolderIcon) icon).getFolder().getItemsInReadingOrder();
+        } else {
+            return Collections.EMPTY_LIST;
+        }
+    }
+
+    /**SPRD: Added for unread badge feature.@{**/
+
+    /**
+     * SPRD: Bind component unread information in workspace and all apps list.
+     *
+     * @param component the component name of the app.
+     * @param unreadNum the number of the unread message.
+     */
+    public void bindComponentUnreadChanged(final ComponentName component, final int unreadNum) {
+        if (LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "bindComponentUnreadChanged: component = " + component
+                    + ", unreadNum = " + unreadNum + ", this = " + this);
+        }
+        // Post to message queue to avoid possible ANR.
+        mHandler.post(new Runnable() {
+            public void run() {
+                final long start = System.currentTimeMillis();
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindComponentUnreadChanged begin: component = " + component
+                            + ", unreadNum = " + unreadNum + ", start = " + start);
+                }
+
+                mUnreadLoaderUtils.bindComponentUnreadChanged(component, unreadNum);
+
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindComponentUnreadChanged end: current time = "
+                            + System.currentTimeMillis() + ", time used = "
+                            + (System.currentTimeMillis() - start));
+                }
+            }
+        });
+    }
+
+    /**
+     * SPRD: Bind shortcuts unread number if binding process has finished.
+     */
+    public void bindUnreadInfoIfNeeded() {
+        if (LogUtils.DEBUG_UNREAD) {
+            LogUtils.d(TAG, "bindUnreadInfoIfNeeded: mBindingWorkspaceFinished = "
+                    + mBindingWorkspaceFinished + ", mBindingAppsFinished: "+mBindingAppsFinished +", thread = " + Thread.currentThread());
+        }
+        if (mBindingWorkspaceFinished) {
+            bindWorkspaceUnreadInfo();
+        }
+
+        if (mBindingAppsFinished) {
+            bindAppsUnreadInfo();
+        }
+        mUnreadLoadCompleted = true;
+    }
+
+    /**
+     * SPRD: Bind unread number to shortcuts with data in UnreadLoaderUtils.
+     */
+    private void bindWorkspaceUnreadInfo() {
+        mHandler.post(new Runnable() {
+            public void run() {
+                final long start = System.currentTimeMillis();
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindWorkspaceUnreadInfo begin: start = " + start);
+                }
+                mUnreadLoaderUtils.updateShortcutsAndFoldersUnread();
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindWorkspaceUnreadInfo end: current time = "
+                            + System.currentTimeMillis() + ",time used = "
+                            + (System.currentTimeMillis() - start));
+                }
+            }
+        });
+    }
+
+    /**
+     * SPRD: Bind unread number to shortcuts with data in UnreadLoaderUtils.
+     */
+    private void bindAppsUnreadInfo() {
+        mHandler.post(new Runnable() {
+            public void run() {
+                final long start = System.currentTimeMillis();
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindAppsUnreadInfo begin: start = " + start);
+                }
+              //  mUnreadLoaderUtils.updateAppsUnread(); //Update AllApps Unread if needed.
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindAppsUnreadInfo end: current time = "
+                            + System.currentTimeMillis() + ",time used = "
+                            + (System.currentTimeMillis() - start));
+                }
+            }
+        });
+    }
+    /**@}**/
+
+
+    /**SPRD: Added for dynamic icon feature.@{**/
+
+    /**
+     * SPRD: Bind component draw callback of the dynamic icon in workspace.
+     *
+     * @param component the component name of the app.
+     */
+    public void bindComponentDynamicIconChanged(final ComponentName component) {
+        mHandler.post(new Runnable() {
+            public void run() {
+                final long start = System.currentTimeMillis();
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindComponentDynamicIconChanged begin: component = " + component
+                            + ", start = " + start);
+                }
+
+                if (mDynamicIconUtils != null) {
+                    mDynamicIconUtils.updateComponentDynamicIconChanged(component);
+                }
+
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindComponentDynamicIconChanged end: current time = "
+                            + System.currentTimeMillis() + ", time used = "
+                            + (System.currentTimeMillis() - start));
+                }
+            }
+        });
+    }
+
+    public void bindDynamicIconIfNeeded() {
+        if (LogUtils.DEBUG_DYNAMIC_ICON) {
+            LogUtils.d(TAG, "bindDynamicIconIfNeeded: mBindingWorkspaceCompleted = "
+                    + mBindingWorkspaceCompleted + ", thread = " + Thread.currentThread());
+        }
+        if (mBindingWorkspaceCompleted) {
+            bindWorkspaceDynamicInfo();
+        }
+        if (mBindingAppsCompleted) {
+            // bind dynamic icon info that in the all app container if needed
+        }
+        mDynamicIconLoadCompleted = true;
+    }
+
+    private void bindWorkspaceDynamicInfo() {
+        mHandler.post(new Runnable() {
+            public void run() {
+                final long start = System.currentTimeMillis();
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindWorkspaceDynamicInfo begin: start = " + start);
+                }
+
+                if (mDynamicIconUtils != null) {
+                    mDynamicIconUtils.updateShortcutsAndFoldersDynamicIcon();
+                }
+
+                if (LogUtils.DEBUG_PERFORMANCE) {
+                    LogUtils.d(TAG, "bindWorkspaceDynamicInfo end: current time = "
+                            + System.currentTimeMillis() + ",time used = "
+                            + (System.currentTimeMillis() - start));
+                }
+            }
+        });
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent event) {
+        int sensorType = event.sensor.getType();
+        if (sensorType == Sensor.TYPE_ACCELEROMETER) {
+            long currentUpdateTime = System.currentTimeMillis();
+            long timeInterval = currentUpdateTime - mSensorLastUpdateTime;
+            if(timeInterval < UPTATE_INTERVAL_TIME){
+                return;
+            }
+            mSensorLastUpdateTime = currentUpdateTime;
+            float x = event.values[0];
+            float y = event.values[1];
+            float z = event.values[2];
+            float deltaX = Math.abs(x - lastX);
+            float deltaY = Math.abs(y - lastY);
+            float deltaZ = Math.abs(z - lastZ);
+
+            lastX = x;
+            lastY = y;
+            lastZ = z;
+
+            double speed = deltaX + deltaY + deltaZ;
+            
+            if (mIsFrist) {
+                mIsFrist = false;
+            } else {
+                if (isWorkspaceVisible() && speed > SPEED_SHRESHOLD) {
+                    if (mMotionSound != null) {
+                        mMotionSound.start();
+                        if (LogUtils.DEBUG) LogUtils.d(TAG, "mMotionSound is started");
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
+
+    }
+
+    private void registerListener(){
+        if(mSensorManager != null) {
+            Sensor sensor = mSensorManager.getDefaultSensor( Sensor.TYPE_ACCELEROMETER );
+            if(sensor != null){
+                mSensorManager.registerListener(this, sensor, SensorManager.SENSOR_DELAY_NORMAL);
+            }
+        }
+    }
+
+    private void unRegisterListener() {
+        if (mSensorManager != null)
+            mSensorManager.unregisterListener(this);
+    }
+}
+
+interface DebugIntents {
+    static final String DELETE_DATABASE = "com.android.launcher3.action.DELETE_DATABASE";
+    static final String MIGRATE_DATABASE = "com.android.launcher3.action.MIGRATE_DATABASE";
+}
Index: packages/apps/Launcher3/src/com/android/launcher3/ShortcutAndWidgetContainer.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/ShortcutAndWidgetContainer.java	(revision 182304)
+++ packages/apps/Launcher3/src/com/android/launcher3/ShortcutAndWidgetContainer.java	(revision 182305)
@@ -153,9 +153,6 @@
                 // Otherwise, center the icon
                 int cHeight = getCellContentHeight();
                 int cellPaddingY = (int) Math.max(0, ((lp.height - cHeight) / 2f));
-                if (mIsHotseatLayout && grid.isVerticalBarLayout()) {
-                    cellPaddingY = (int) ((lp.height - cHeight) / 2f);
-                }
                 int cellPaddingX = (int) (grid.edgeMarginPx / 2f);
                 child.setPadding(cellPaddingX, cellPaddingY, cellPaddingX, 0);
             }
Index: packages/apps/Launcher3/src/com/android/launcher3/util/ManagedProfileHeuristic.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/util/ManagedProfileHeuristic.java	(revision 182304)
+++ packages/apps/Launcher3/src/com/android/launcher3/util/ManagedProfileHeuristic.java	(revision 182305)
@@ -35,8 +35,6 @@
 import com.android.launcher3.compat.UserHandleCompat;
 import com.android.launcher3.compat.UserManagerCompat;
 import com.sprd.PlatformHelper;
-import com.sprd.ext.AppCloneUtils;
-import com.sprd.ext.LogUtils;
 
 import java.util.ArrayList;
 import java.util.Collections;
Index: packages/apps/Launcher3/src/com/android/launcher3/util/WallpaperUtils.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/util/WallpaperUtils.java	(revision 182304)
+++ packages/apps/Launcher3/src/com/android/launcher3/util/WallpaperUtils.java	(revision 182305)
@@ -25,7 +25,6 @@
 import android.view.WindowManager;
 
 import com.android.launcher3.Utilities;
-import com.sprd.ext.FeatureOption;
 
 /**
  * Utility methods for wallpaper management.
@@ -123,16 +122,11 @@
         }
         return sDefaultWallpaperSize;
     }
-
-    private static Point sWallpaperSize;
+	private static Point sWallpaperSize;
     private static int sLastWidth;
 
     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
     public static Point getDefaultWallpaperSize(Resources res, WindowManager windowManager, int width) {
-        if (!FeatureOption.SPRD_ADAPTIVE_WALLPAPER_SUPPORT) {
-            return getDefaultWallpaperSize(res, windowManager);
-        }
-
         if (sWallpaperSize == null || width != sLastWidth) {
             sLastWidth = width;
             Point minDims = new Point();
Index: packages/apps/Launcher3/src/com/android/launcher3/Workspace.java
===================================================================
--- packages/apps/Launcher3/src/com/android/launcher3/Workspace.java	(revision 182304)
+++ packages/apps/Launcher3/src/com/android/launcher3/Workspace.java	(revision 182305)
@@ -496,20 +496,7 @@
     void disableLayoutTransitions() {
         setLayoutTransition(null);
     }
-    boolean getCreatingUserFolderOnDrop() {
-        return mCreateUserFolderOnDrop;
-    }
-    void setCreatingUserFolderOnDrop(boolean createFolderOnDrop) {
-        mCreateUserFolderOnDrop = createFolderOnDrop;
-    }
-    boolean getAddingtoExistingFolderOnDrop() {
-        return mAddToExistingFolderOnDrop;
-    }
-    void setAddingtoExistingFolderOnDrop(boolean addingtoExistingFolderOnDrop) {
-        mAddToExistingFolderOnDrop = addingtoExistingFolderOnDrop;
-    }
 
-
     @Override
     public void onChildViewAdded(View parent, View child) {
         if (!(child instanceof CellLayout)) {
@@ -634,6 +621,7 @@
         } else {
             setCurrentPage(getCurrentPage() + 1);
         }
+
     }
 
     public void removeCustomContentPage() {
@@ -640,6 +628,7 @@
         CellLayout customScreen = getScreenWithId(CUSTOM_CONTENT_SCREEN_ID);
         if (customScreen == null) {
             throw new RuntimeException("Expected custom content screen to exist");
+
         }
 
         mWorkspaceScreens.remove(CUSTOM_CONTENT_SCREEN_ID);
@@ -1818,6 +1807,7 @@
             mLauncher.getHotseat().setTranslationX(translationX);
         }
 
+
         if (getPageIndicator() != null) {
             getPageIndicator().setTranslationX(translationX);
         }
Index: packages/apps/Launcher3/res/xml/default_workspace_5x5.xml
===================================================================
--- packages/apps/Launcher3/res/xml/default_workspace_5x5.xml	(revision 182304)
+++ packages/apps/Launcher3/res/xml/default_workspace_5x5.xml	(revision 182305)
@@ -29,7 +29,7 @@
 
     </resolve>
 
-    <resolve
+   <!-- <resolve
         launcher:screen="0"
         launcher:x="1"
         launcher:y="-1" >
@@ -36,7 +36,7 @@
 	    <favorite launcher:uri="#Intent;action=android.intent.action.MAIN;category=android.intent.category.APP_GALLERY;end" />
 	    <favorite launcher:uri="#Intent;type=images/*;end" />
 
-    </resolve>
+    </resolve>-->
 
     <resolve
         launcher:screen="0"
@@ -47,7 +47,7 @@
     </resolve>
 
     <!-- base customization -->
-    <include launcher:workspace="@xml/dw_base_customize" />
+    <!--<include launcher:workspace="@xml/dw_base_customize" />-->
 
     <!-- vendor customization -->
     <include launcher:workspace="@xml/dw_vendor_customize" />
Index: packages/apps/Launcher3/res/values/dimens.xml
===================================================================
--- packages/apps/Launcher3/res/values/dimens.xml	(revision 182304)
+++ packages/apps/Launcher3/res/values/dimens.xml	(revision 182305)
@@ -166,6 +166,4 @@
     <dimen name="pending_widget_min_padding">8dp</dimen>
     <dimen name="pending_widget_elevation">2dp</dimen>
 
-    <!--Add for app title shown in two lines-->
-    <dimen name="adjust_cell_height">0dp</dimen>
 </resources>
Index: packages/apps/Launcher3/res/values/config.xml
===================================================================
--- packages/apps/Launcher3/res/values/config.xml	(revision 182304)
+++ packages/apps/Launcher3/res/values/config.xml	(revision 182305)
@@ -92,6 +92,4 @@
     <item type="id" name="action_move_screen_forwards" />
     <item type="id" name="action_resize" />
 
-    <bool name="config_app_title_single_line">true</bool>
-    <integer name="config_app_title_max_line">1</integer>
 </resources>
Index: vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-hi/strings.xml
===================================================================
--- vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-hi/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-hi/strings.xml	(revision 182305)
@@ -5,4 +5,6 @@
 <string name="copy_fail">"   "</string>
 <string name="delete_success">"  "</string>
 <string name="delete_fail">     </string>
-</resources>
+    <string name="succ_fail">": <xliff:g id="succ">%1$d</xliff:g>, : <xliff:g id="fail">%2$d</xliff:g>"</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-bn-rBD/strings.xml
===================================================================
--- vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-bn-rBD/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-bn-rBD/strings.xml	(revision 182305)
@@ -5,4 +5,6 @@
 <string name="copy_fail">"   "</string>
 <string name="delete_success">"   "</string>
 <string name="delete_fail">  </string>
-</resources>
+    <string name="succ_fail">":<xliff:g id="succ">%1$d</xliff:g>, ":<xliff:g id="fail">%2$d</xliff:g>"</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-kn-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-kn-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-kn-rIN/strings.xml	(revision 182305)
@@ -5,4 +5,6 @@
 <string name="copy_fail">" "</string>
 <string name="delete_success">" "</string>
 <string name="delete_fail">" "</string>
-</resources>
+    <string name="succ_fail">": <xliff:g id="succ">%1$d</xliff:g>, :<xliff:g id="fail">%2$d</xliff:g>"</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-ne-rNP/strings.xml
===================================================================
--- vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-ne-rNP/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-ne-rNP/strings.xml	(revision 182305)
@@ -8,4 +8,6 @@
 <string name="copy_fail">"  "</string>
 <string name="delete_success">"  "</string>
 <string name="delete_fail">" "</string>
-</resources>
+    <string name="succ_fail">" :<xliff:g id="succ">%1$d</xliff:g>,  :<xliff:g id="fail">%2$d</xliff:g>"</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-gu-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-gu-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-gu-rIN/strings.xml	(revision 182305)
@@ -5,4 +5,6 @@
 <string name="copy_fail">" "</string>
 <string name="delete_success">"    "</string>
 <string name="delete_fail">   </string>
-</resources>
+    <string name="succ_fail">":<xliff:g id="succ">%1$d</xliff:g>,  :<xliff:g id="fail">%2$d</xliff:g>"</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-as/strings.xml
===================================================================
--- vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-as/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-as/strings.xml	(revision 182305)
@@ -5,4 +5,6 @@
 <string name="copy_fail">"  "</string>
 <string name="delete_success">"  "</string>
 <string name="delete_fail">"\'  \'"</string>
-</resources>
+    <string name="succ_fail">" :<xliff:g id="succ">%1$d</xliff:g>,  :<xliff:g id="fail">%2$d</xliff:g>"</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-pa-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-pa-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-pa-rIN/strings.xml	(revision 182305)
@@ -5,4 +5,6 @@
 <string name="copy_fail">"   "</string>
 <string name="delete_success">"    "</string>
 <string name="delete_fail"> </string>
-</resources>
+    <string name="succ_fail">":<xliff:g id="succ">%1$d</xliff:g>, :<xliff:g id="fail">%2$d</xliff:g>"</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-ta-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-ta-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-ta-rIN/strings.xml	(revision 182305)
@@ -5,4 +5,6 @@
 <string name="copy_fail">" "</string>
 <string name="delete_success">" "</string>
 <string name="delete_fail"> </string>
-</resources>
+    <string name="succ_fail">":<xliff:g id="succ">%1$d</xliff:g>, :<xliff:g id="fail">%2$d</xliff:g>"</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-te-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-te-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-te-rIN/strings.xml	(revision 182305)
@@ -5,4 +5,6 @@
 <string name="copy_fail">" "</string>
 <string name="delete_success">" "</string>
 <string name="delete_fail"> </string>
-</resources>
+    <string name="succ_fail">":<xliff:g id="succ">%1$d</xliff:g>, : <xliff:g id="fail">%2$d</xliff:g>"</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-ur-rPK/strings.xml
===================================================================
--- vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-ur-rPK/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-ur-rPK/strings.xml	(revision 182305)
@@ -5,4 +5,6 @@
 <string name="copy_fail">" "</string>
 <string name="delete_success">"   "</string>
 <string name="delete_fail">   </string>
-</resources>
+    <string name="succ_fail">"": <xliff:g id="succ">%1$d</xliff:g> :<xliff:g id="fail">%2$d</xliff:g>" "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-ml-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-ml-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-ml-rIN/strings.xml	(revision 182305)
@@ -5,4 +5,6 @@
 <string name="copy_fail">" "</string>
 <string name="delete_success">" "</string>
 <string name="delete_fail">" "</string>
-</resources>
+    <string name="succ_fail">":<xliff:g id="succ">%1$d</xliff:g>, :<xliff:g id="fail">%2$d</xliff:g>"</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-mr-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-mr-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/providers/TelephonyProvider/res/values-mr-rIN/strings.xml	(revision 182305)
@@ -5,4 +5,6 @@
 <string name="copy_fail">" "</string>
 <string name="delete_success">"  "</string>
 <string name="delete_fail">"  "</string>
-</resources>
+    <string name="succ_fail">":<xliff:g id="succ">%1$d</xliff:g>, failed:<xliff:g id="fail">%2$d</xliff:g>"</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/DreamCamera2/src_dream/com/dream/camera/SlidePanelManager.java
===================================================================
--- vendor/sprd/platform/packages/apps/DreamCamera2/src_dream/com/dream/camera/SlidePanelManager.java	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamCamera2/src_dream/com/dream/camera/SlidePanelManager.java	(revision 182305)
@@ -141,4 +141,13 @@
             return slidePanelParent;
         return mActivity.findViewById(R.id.slide_panel_parent);
     }
+
+    @Override
+    public void onModuleChanged(CameraModule module) {
+        if(module instanceof VideoModule){
+            captureText.setText(mActivity.getResources().getString(R.string.slide_panel_capture_video));
+        } else if (module instanceof PhotoModule) {
+            captureText.setText(mActivity.getResources().getString(R.string.slide_panel_capture));
+        }
+    }
 }
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-pa-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-pa-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-pa-rIN/strings.xml	(revision 182305)
@@ -107,4 +107,5 @@
      <string name="airplane_message">"    FM      "</string>
      <string name="delete_title_tip"></string>
      <string name="playmode_title_tip">" "</string>
+    <string name="toast_record_not_saved_tmpfile_deleted">"     ,      "</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-ta-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-ta-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-ta-rIN/strings.xml	(revision 182305)
@@ -126,4 +126,5 @@
      <string name="airplane_message">"  FM    ."</string>
      <string name="delete_title_tip"></string>
      <string name="playmode_title_tip">" "</string>
+    <string name="toast_record_not_saved_tmpfile_deleted">"  , "</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-te-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-te-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-te-rIN/strings.xml	(revision 182305)
@@ -126,4 +126,5 @@
      <string name="airplane_message">"       ."</string>
      <string name="delete_title_tip"></string>
      <string name="playmode_title_tip">" ."</string>
+    <string name="toast_record_not_saved_tmpfile_deleted">"  ,  "</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-zh-rCN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-zh-rCN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-zh-rCN/strings.xml	(revision 182305)
@@ -66,6 +66,8 @@
     <string name="toast_station_renamed" msgid="2185292052267585710">""</string>
     <string name="station_freq">(MHz)</string>
     <string name="change_frequency"></string>
+    <string name="record_amr">amr</string>
+    <string name="record_3gpp">3gpp</string>
     <string name="button_ok"></string>
     <string name="button_cancel"></string>
     <string name="range_error">(87.5MHz-108MHz)</string>
@@ -72,8 +74,8 @@
     <string name="freq_input_info"></string>
     <string name="fm_over_record_format"></string>
     <string name="select_file_type"></string>
-    <string name="storage_phone"></string>
-    <string name="storage_sd"></string>
+    <string name="storage_phone"></string>
+    <string name="storage_sd">SD </string>
     <string name="select_file_path"> </string>
     <string name="record_path"></string>
     <string name="from_current_search"></string>
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/values/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/values/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/values/strings.xml	(revision 182305)
@@ -123,8 +123,8 @@
     <string name="freq_input_info">Please input frequency</string>
     <string name="fm_over_record_format">Record format</string>
     <string name="select_file_type">Please select format</string>
-    <string name="record_amr">amr</string>
-    <string name="record_3gpp">3gpp</string>
+    <string name="record_amr">amr type(low-quality)</string>
+    <string name="record_3gpp">3gpp type(high-quality)</string>
     <string name="storage_phone">Phone</string>
     <string name="storage_sd">SD card</string>
     <string name="select_file_path">Select storage path</string>
@@ -149,11 +149,11 @@
     <!-- new feature,FM new UI @{-->
     <string name="fm_regularly_poweroff">"Scheduled off"</string>
     <string name="cancel_regularly_poweroff">"Cancel timing"</string>
-    <string name="time_10min">"15min"</string>
-    <string name="time_20min">"30min"</string>
-    <string name="time_30min">"60min"</string>
-    <string name="time_60min">"90min"</string>
-    <string name="time_units">"min"</string>
+    <string name="time_10min">"15mins"</string>
+    <string name="time_20min">"30mins"</string>
+    <string name="time_30min">"60mins"</string>
+    <string name="time_60min">"90mins"</string>
+    <string name="time_units">"mins"</string>
     <string name="time_scustom_setting">"Custom setting"</string>
     <string name="fm_record_list">"FMRecord List"</string>
     <string name="search_hint">"Search FMRecord&#8230;"</string>
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/values/dimens.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/values/dimens.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/values/dimens.xml	(revision 182305)
@@ -70,16 +70,16 @@
     <dimen name="fm_main_header_big">320dp</dimen>
 
     <!-- FM main page text size -->
-    <dimen name="text_fm_size">14dp</dimen>
-    <dimen name="station_value_size">88dp</dimen>
-    <dimen name="station_name_size">24dp</dimen>
-    <dimen name="station_rds_size">14dp</dimen>
+    <dimen name="text_fm_size">14sp</dimen>
+    <dimen name="station_value_size">88sp</dimen>
+    <dimen name="station_name_size">24sp</dimen>
+    <dimen name="station_rds_size">14sp</dimen>
 
     <!-- FM station list page -->
-    <dimen name="fm_title">20dp</dimen>
-    <dimen name="fm_station_name">30dp</dimen>
-    <dimen name="fm_station_value">70dp</dimen>
-    <dimen name="fm_station_rds">20dp</dimen>
+    <dimen name="fm_title">20sp</dimen>
+    <dimen name="fm_station_name">30sp</dimen>
+    <dimen name="fm_station_value">70sp</dimen>
+    <dimen name="fm_station_rds">20sp</dimen>
 
     <!-- Station layout padding -->
     <dimen name="fm_station_layout_padding_top">90dp</dimen>
@@ -102,9 +102,9 @@
     <dimen name="fm_list_star_width">24dp</dimen>
     <dimen name="fm_list_star_height">24dp</dimen>
     <dimen name="fm_list_star_touch_width">48dp</dimen>
-    <dimen name="fm_primary_text_size">16dp</dimen>
-    <dimen name="fm_rds_text_size">14dp</dimen>
-    <dimen name="fm_station_searching_tips_size">16dp</dimen>
+    <dimen name="fm_primary_text_size">16sp</dimen>
+    <dimen name="fm_rds_text_size">14sp</dimen>
+    <dimen name="fm_station_searching_tips_size">16sp</dimen>
     <dimen name="fm_list_progress_width">120dp</dimen>
     <dimen name="fm_list_name_margin_right">48dp</dimen>
     <!-- station list page land-->
@@ -111,8 +111,8 @@
     <dimen name="fm_list_item_height_land">72dp</dimen>
 
     <!-- text size -->
-    <dimen name="fm_description_text_size">14dp</dimen>
-    <dimen name="fm_station_rds_text_size">14dp</dimen>
+    <dimen name="fm_description_text_size">14sp</dimen>
+    <dimen name="fm_station_rds_text_size">14sp</dimen>
     <!-- start text size and margin -->
     <dimen name="fm_frequency_text_size_start">88dp</dimen>
     <dimen name="fm_station_name_text_size_start">24dp</dimen>
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-ur-rPK/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-ur-rPK/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-ur-rPK/strings.xml	(revision 182305)
@@ -126,4 +126,6 @@
      <string name="airplane_message">"    FM       "</string>
      <string name="delete_title_tip">" "</string>
      <string name="playmode_title_tip">" "</string>
-</resources>
+    <string name="toast_record_not_saved_tmpfile_deleted">"         "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-zh-rHK/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-zh-rHK/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-zh-rHK/strings.xml	(revision 182305)
@@ -66,6 +66,8 @@
     <string name="toast_station_renamed" msgid="2185292052267585710">""</string>
     <string name="station_freq">(MHz)</string>
     <string name="change_frequency"></string>
+    <string name="record_amr">"amr"</string>
+    <string name="record_3gpp">"3gpp"</string>
     <string name="button_ok"></string>
     <string name="button_cancel"></string>
     <string name="range_error">(87.5MHz-108MHz)</string>
@@ -72,8 +74,8 @@
     <string name="freq_input_info"></string>
     <string name="fm_over_record_format"></string>
     <string name="select_file_type"></string>
-    <string name="storage_phone"></string>
-    <string name="storage_sd"></string>
+    <string name="storage_phone"></string>
+    <string name="storage_sd">SD </string>
     <string name="select_file_path"></string>
     <string name="record_path"></string>
     <string name="from_current_search">""</string>
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/layout/main_header.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/layout/main_header.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/layout/main_header.xml	(revision 182305)
@@ -60,7 +60,7 @@
                 android:alpha="0.87"
                 android:fontFamily="sans-serif-light"
                 android:gravity="start"
-                android:paddingStart="16dip"
+                android:paddingStart="14dip"
                 android:textColor="@color/white_color"
                 android:textSize="@dimen/station_value_size" />
 
@@ -71,7 +71,7 @@
                 android:layout_height="wrap_content"
                 android:layout_toEndOf="@id/station_value"
                 android:fontFamily="sans-serif"
-                android:paddingStart="8dip"
+                android:paddingStart="6dip"
                 android:textColor="@color/text_fm_color"
                 android:textSize="@dimen/text_fm_size" />
             <!-- bug568587, Regularly power off. end-->
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/layout/editstationfreq.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/layout/editstationfreq.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/layout/editstationfreq.xml	(revision 182305)
@@ -35,6 +35,6 @@
         android:inputType="numberDecimal"
         android:maxLength="60"
         android:ellipsize="end"
-        android:textSize="16dp"
+        android:textSize="16sp"
         android:textColor="@color/black_color" />
 </LinearLayout>
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/layout/main_bottom.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/layout/main_bottom.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/layout/main_bottom.xml	(revision 182305)
@@ -41,7 +41,7 @@
             android:gravity="center_vertical"
             android:text="@string/favorites"
             android:textColor="#000000"
-            android:textSize="14dp" />
+            android:textSize="14sp" />
 
         <include layout="@layout/favorite_gridview" />
     </LinearLayout>
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/layout/fm_record_activity.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/layout/fm_record_activity.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/layout/fm_record_activity.xml	(revision 182305)
@@ -122,7 +122,7 @@
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
                 android:layout_marginTop="12dip"
-                android:layout_marginBottom="-2dip"
+                android:layout_marginBottom="0dip"
                 android:layout_marginEnd="24dip"
                 android:visibility="gone"
                 android:orientation="horizontal" >
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/layout/favorite.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/layout/favorite.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/layout/favorite.xml	(revision 182305)
@@ -49,7 +49,8 @@
                 android:gravity="center_vertical"
                 android:text="@string/app_name"
                 android:textColor="@color/black_color"
-                android:textSize="@dimen/fm_primary_text_size" />
+                android:textSize="@dimen/fm_primary_text_size"
+                android:visibility="gone" />
 
             <LinearLayout
                 android:id="@+id/ck_selectAll_container"
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-zh-rTW/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-zh-rTW/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-zh-rTW/strings.xml	(revision 182305)
@@ -64,7 +64,10 @@
     <string name="toast_record_not_saved" msgid="6526674547687611282">""</string>
     <string name="toast_listen" msgid="2014315478895754055">""</string>
     <string name="toast_station_renamed" msgid="2185292052267585710">""</string>
-    <string name="station_freq">(MHz)</string><string name="change_frequency"></string>
+    <string name="station_freq">(MHz)</string>
+    <string name="change_frequency"></string>
+    <string name="record_amr">amr</string>
+    <string name="record_3gpp">3gpp</string>
     <string name="button_ok"></string>
     <string name="button_cancel"></string>
     <string name="range_error">(87.5MHz-108MHz)</string>
@@ -71,8 +74,8 @@
     <string name="freq_input_info"></string>
     <string name="fm_over_record_format"></string>
     <string name="select_file_type"></string>
-    <string name="storage_phone"></string>
-    <string name="storage_sd"></string>
+    <string name="storage_phone"></string>
+    <string name="storage_sd">SD </string>
     <string name="select_file_path"></string>
     <string name="record_path"></string>
     <string name="from_current_search"></string>
@@ -98,7 +101,7 @@
     <string name="time_30min">"60"</string>
     <string name="time_60min">"90"</string>
     <string name="time_units">""</string>
-    <string name="time_scustom_setting">""</string>
+    <string name="time_scustom_setting">""</string>
     <string name="search_hint">"FM&#8230;"</string>
     <string name="fm_record_list">" "</string>
     <string name="favorite_station_tag">""</string>
@@ -131,6 +134,6 @@
     <string name="station_name_exists"></string>
     <string name="station_name_notnull"></string>
 
-    <string name="recording_name_notnull"></string>
-    <string name="recording_name_illegal">\n\\&#058;&#042;&#063;&#034;&#060;&#062;&#124;&#047;</string>
+    <string name="recording_name_notnull"></string>
+    <string name="recording_name_illegal">\n\\&#058;&#042;&#063;&#034;&#060;&#062;&#124;&#047;</string>
 </resources>
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-hi/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-hi/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-hi/strings.xml	(revision 182305)
@@ -126,4 +126,5 @@
      <string name="airplane_message">"    FM      "</string>
      <string name="delete_title_tip"></string>
      <string name="playmode_title_tip">" "</string>
+    <string name="toast_record_not_saved_tmpfile_deleted">"      ,   "</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-bn-rBD/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-bn-rBD/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-bn-rBD/strings.xml	(revision 182305)
@@ -126,4 +126,5 @@
      <string name="airplane_message">"  FM   "</string>
      <string name="delete_title_tip"> </string>
      <string name="playmode_title_tip">" "</string>
+    <string name="toast_record_not_saved_tmpfile_deleted">"   ,  "</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-gu-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-gu-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-gu-rIN/strings.xml	(revision 182305)
@@ -107,4 +107,5 @@
      <string name="airplane_message">"       ."</string>
      <string name="delete_title_tip">""</string>
      <string name="playmode_title_tip">" "</string>
+    <string name="toast_record_not_saved_tmpfile_deleted">"     ,   "</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-as/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-as/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/DreamFMRadio/res/values-as/strings.xml	(revision 182305)
@@ -107,4 +107,5 @@
      <string name="airplane_message">" FM \'   "</string>
      <string name="delete_title_tip">" "</string>
      <string name="playmode_title_tip">" "</string>
+    <string name="toast_record_not_saved_tmpfile_deleted">"   ,    "</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/SprdContacts/res/values-kn-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/SprdContacts/res/values-kn-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/SprdContacts/res/values-kn-rIN/strings.xml	(revision 182305)
@@ -523,4 +523,13 @@
     <string name="contacts_in_conference_reselect">"  ,   ."</string>
      <string name="contacts_in_conference">"   , ."</string>
      <string name="group_insert_error">"  ,  "</string>
+    <string name="new_user_name">" "</string>
+     <string name="editor_data_changed">"  ,  "</string>
+     <string name="replace_data_error">"   "</string>
+     <string name="open_video_calling_switch">"    ,    !"</string>
+     <string name="warn_location_title">""</string>
+     <string name="warn_location_message">"    ?"</string>
+     <string name="sim_disabled">"SIM ,   "</string>
+     <string name="edit_only">"     ."</string>
+     <string name="over_max_join_number">"  ,    (10)   <xliff:g id="count">%d</xliff:g>    ."</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/SprdContacts/res/values-ne-rNP/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/SprdContacts/res/values-ne-rNP/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/SprdContacts/res/values-ne-rNP/strings.xml	(revision 182305)
@@ -522,4 +522,13 @@
      <string name="contacts_in_conference">"   ,   "</string>
      <string name="group_insert_error">"   ,   "</string>
 
+    <string name="new_user_name">" "</string>
+     <string name="editor_data_changed">"   ,  :  "</string>
+     <string name="replace_data_error">"   "</string>
+     <string name="open_video_calling_switch">"    ,    !"</string>
+     <string name="warn_location_title">""</string>
+     <string name="warn_location_message">""        ?"</string>
+     <string name="sim_disabled">"SIM    ,    "</string>
+     <string name="edit_only">"       "</string>
+     <string name="over_max_join_number">"    ,      <xliff:g id="count">%d</xliff:g>       "</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/SprdContacts/res/values-gu-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/SprdContacts/res/values-gu-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/SprdContacts/res/values-gu-rIN/strings.xml	(revision 182305)
@@ -523,4 +523,13 @@
      <string name="contacts_in_conference">"    ,      ."</string>
      <string name="group_insert_error">"   ,     "</string>
 
+    <string name="new_user_name">" "</string>
+     <string name="editor_data_changed">"   ,    "</string>
+     <string name="replace_data_error">"   "</string>
+     <string name="open_video_calling_switch">"   ,     !"</string>
+     <string name="warn_location_title"> </string>
+     <string name="warn_location_message">"        ?"</string>
+     <string name="sim_disabled">"SIM  ,     "</string>
+     <string name="edit_only">"      "</string>
+     <string name="over_max_join_number">"         <xliff:g id="count">%d</xliff:g> ,         (10)."</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/SprdContacts/res/values-as/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/SprdContacts/res/values-as/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/SprdContacts/res/values-as/strings.xml	(revision 182305)
@@ -505,4 +505,13 @@
      <string name="contacts_in_conference_reselect">"    ,     "</string>
      <string name="contacts_in_conference">"    ,    "</string>
      <string name="group_insert_error">"  ,     "</string>
+    <string name="new_user_name">" "</string>
+     <string name="editor_data_changed">"    ,     "</string>
+     <string name="replace_data_error">"   "</string>
+     <string name="open_video_calling_switch">"     ,    !"</string>
+     <string name="warn_location_title">""</string>
+     <string name="warn_location_message">"      ?"</string>
+     <string name="sim_disabled">"SIM   ,     "</string>
+     <string name="edit_only">"       "</string>
+     <string name="over_max_join_number">"    ,    <xliff:g id="count">%d</xliff:g>  ,      (10)"</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/SprdContacts/res/values-pa-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/SprdContacts/res/values-pa-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/SprdContacts/res/values-pa-rIN/strings.xml	(revision 182305)
@@ -523,4 +523,13 @@
      <string name="contacts_in_conference_reselect">"    ,    "</string>
      <string name="contacts_in_conference">"     ,      "</string>
      <string name="group_insert_error">"    ,      "</string>
+    <string name="new_user_name">" "</string>
+     <string name="editor_data_changed">"     ,     "</string>
+     <string name="replace_data_error">"        "</string>
+     <string name="open_video_calling_switch">"     ,       !"</string>
+     <string name="warn_location_title"></string>
+     <string name="warn_location_message">"          ?"</string>
+     <string name="sim_disabled">"SIM  ,       "</string>
+     <string name="edit_only">"         "</string>
+     <string name="over_max_join_number">"     ,  <xliff:g id="count">%d</xliff:g>       ,     (10)    "</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/SprdContacts/res/values-ta-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/SprdContacts/res/values-ta-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/SprdContacts/res/values-ta-rIN/strings.xml	(revision 182305)
@@ -524,4 +524,13 @@
     <string name="contacts_in_conference_reselect">"    ,   ."</string>
      <string name="contacts_in_conference">"     ,   ."</string>
      <string name="group_insert_error">"  ,   "</string>
+    <string name="new_user_name">" "</string>
+     <string name="editor_data_changed">"  ,  "</string>
+     <string name="replace_data_error">"   "</string>
+     <string name="open_video_calling_switch">"   ,    "</string>
+     <string name="warn_location_title"></string>
+     <string name="warn_location_message">"   ?"</string>
+     <string name="sim_disabled">"SIM ,   "</string>
+     <string name="edit_only">"     ."</string>
+     <string name="over_max_join_number">"  ,     (10)  <xliff:g id="count">%d</xliff:g>   ."</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/SprdContacts/res/values-te-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/SprdContacts/res/values-te-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/SprdContacts/res/values-te-rIN/strings.xml	(revision 182305)
@@ -523,4 +523,13 @@
     <string name="contacts_in_conference_reselect">"   ,    ."</string>
      <string name="contacts_in_conference">"   ,  ."</string>
      <string name="group_insert_error">"   ,   "</string>
+    <string name="new_user_name">" "</string>
+     <string name="editor_data_changed">"  ,   "</string>
+     <string name="replace_data_error">"   "</string>
+     <string name="open_video_calling_switch">"    ,   !"</string>
+     <string name="warn_location_title"></string>
+     <string name="warn_location_message">"     ?"</string>
+     <string name="sim_disabled">"  ,   "</string>
+     <string name="edit_only">"     ."</string>
+     <string name="over_max_join_number">"  ,   , ,     (10)."</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/SprdContacts/res/values-ur-rPK/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/SprdContacts/res/values-ur-rPK/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/SprdContacts/res/values-ur-rPK/strings.xml	(revision 182305)
@@ -523,4 +523,13 @@
     <string name="contacts_in_conference_reselect">"         "</string>
      <string name="contacts_in_conference">"              "</string>
      <string name="group_insert_error">"          "</string>
+    <string name="new_user_name">" "</string>
+     <string name="editor_data_changed">"             "</string>
+     <string name="replace_data_error">"       "</string>
+     <string name="open_video_calling_switch">"        !"</string>
+     <string name="warn_location_title"></string>
+     <string name="warn_location_message">"        "</string>
+     <string name="sim_disabled">"          "</string>
+     <string name="edit_only">"          ."</string>
+     <string name="over_max_join_number">"               <xliff:g id="count">%d</xliff:g>           (10)  "</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/SprdContacts/res/values-ml-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/SprdContacts/res/values-ml-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/SprdContacts/res/values-ml-rIN/strings.xml	(revision 182305)
@@ -523,4 +523,13 @@
     <string name="contacts_in_conference_reselect">"   ,     ."</string>
      <string name="contacts_in_conference">"      ."</string>
      <string name="group_insert_error">"  ,   "</string>
+    <string name="new_user_name">" "</string>
+     <string name="editor_data_changed">"    .   "</string>
+     <string name="replace_data_error">"   "</string>
+     <string name="open_video_calling_switch">"   ,    !"</string>
+     <string name="warn_location_title">""</string>
+     <string name="warn_location_message">"     ?"</string>
+     <string name="sim_disabled">"  .    "</string>
+     <string name="edit_only">"      ."</string>
+     <string name="over_max_join_number">"   ,        (10)<xliff:g id="count">%d</xliff:g>    ."</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/SprdContacts/res/values-mr-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/SprdContacts/res/values-mr-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/SprdContacts/res/values-mr-rIN/strings.xml	(revision 182305)
@@ -523,4 +523,13 @@
     <string name="contacts_in_conference_reselect">"  ,    ."</string>
      <string name="contacts_in_conference">"    ,   ( )    ."</string>
      <string name="group_insert_error">"   ,   "</string>
+    <string name="new_user_name">" "</string>
+     <string name="editor_data_changed">""   ,  :  "</string>
+     <string name="replace_data_error">"  : "</string>
+     <string name="open_video_calling_switch">"    ,     !"</string>
+     <string name="warn_location_title">""</string>
+     <string name="warn_location_message">""       ?""</string>
+     <string name="sim_disabled">"SIM   ,     "</string>
+     <string name="edit_only">"        ."</string>
+     <string name="over_max_join_number">"   ,      (10)   <xliff:g id="count">%d</xliff:g>     ."</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/SprdContacts/res/values-hi/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/SprdContacts/res/values-hi/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/SprdContacts/res/values-hi/strings.xml	(revision 182305)
@@ -522,4 +522,13 @@
     <string name="contacts_in_conference_reselect">"    ,   "</string>
      <string name="contacts_in_conference">"     ,     "</string>
      <string name="group_insert_error">"   ,     "</string>
+    <string name="new_user_name">" "</string>
+     <string name="editor_data_changed">"    ,   "</string>
+     <string name="replace_data_error">"     "</string>
+     <string name="open_video_calling_switch">"   ,     !"</string>
+     <string name="warn_location_title">...</string>
+     <string name="warn_location_message">"        ?"</string>
+     <string name="sim_disabled">"SIM  ,     "</string>
+     <string name="edit_only">"         "</string>
+     <string name="over_max_join_number">"    ,  <xliff:g id="count">%d</xliff:g>              (10)"</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/apps/SprdContacts/res/values-bn-rBD/strings.xml
===================================================================
--- vendor/sprd/platform/packages/apps/SprdContacts/res/values-bn-rBD/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/apps/SprdContacts/res/values-bn-rBD/strings.xml	(revision 182305)
@@ -523,4 +523,13 @@
     <string name="contacts_in_conference_reselect">"    ,     "</string>
      <string name="contacts_in_conference">"    ,     "   </string>
      <string name="group_insert_error">"   ,     "</string>
+    <string name="new_user_name">" "</string>
+     <string name="editor_data_changed">"   ,   "</string>
+     <string name="replace_data_error">"   "</string>
+     <string name="open_video_calling_switch">"     ,     !"</string>
+     <string name="warn_location_title">...</string>
+     <string name="warn_location_message">"       ?"</string>
+     <string name="sim_disabled">" ,     "</string>
+     <string name="edit_only">"       "</string>
+     <string name="over_max_join_number">"   ,       <xliff:g id="count">%d</xliff:g>,       (10)""</string>
 </resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-hi/strings_ex.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-hi/strings_ex.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-hi/strings_ex.xml	(revision 182305)
@@ -19,4 +19,11 @@
 <string name="sim_lock_try_later">"    "</string>
 <string name="simlock_unlocked">"Simlock    "</string>
 <string name="vt_resolution_setting">"  "</string>
-</resources>
+    <string name="turn_off_ims_error">"     IMS     ,   WiFi    "</string>
+     <string name="volte_config_notification_title">"VoLTE  "</string>
+     <string name="volte_config_notification_on">"VoLTE "</string>
+     <string name="volte_config_notification_off">"VoLTE "</string>
+     <string name="network_mode_setting_prompt">""           "     "</string>
+     <string name="label_fdn">"  "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-hi/strings.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-hi/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-hi/strings.xml	(revision 182305)
@@ -47,4 +47,7 @@
 </string-array>
 <string name="network_registration_fail_title">"  "</string>
 <string name="network_registration_fail">"  ,      ?"</string>
-</resources>
+    <string name="outgoing_call_not_allowed_user_restriction">"         "</string>
+     <string name="number_limited_message">"    ,   ,     "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-bn-rBD/strings_ex.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-bn-rBD/strings_ex.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-bn-rBD/strings_ex.xml	(revision 182305)
@@ -19,4 +19,11 @@
 <string name="sim_lock_try_later">     </string>
 <string name="simlock_unlocked">"Simlock -   "</string>
 <string name="vt_resolution_setting">"  "</string>
-</resources>
+    <string name="turn_off_ims_error">""         ,      "  "</string>
+     <string name="volte_config_notification_title">"VoLTE "</string>
+     <string name="volte_config_notification_on">"VoLTE "</string>
+     <string name="volte_config_notification_off">"VoLTE "</string>
+     <string name="network_mode_setting_prompt">"   -     ,    "</string>
+     <string name="label_fdn">  </string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-bn-rBD/strings.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-bn-rBD/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-bn-rBD/strings.xml	(revision 182305)
@@ -47,4 +47,7 @@
 </string-array>
 <string name="network_registration_fail_title">"   "</string>
 <string name="network_registration_fail">"   ,     ?"</string>
-</resources>
+    <string name="outgoing_call_not_allowed_user_restriction">"      "</string>
+     <string name="number_limited_message">"    ,  ,    "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-kn-rIN/strings_ex.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-kn-rIN/strings_ex.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-kn-rIN/strings_ex.xml	(revision 182305)
@@ -19,4 +19,11 @@
 <string name="sim_lock_try_later">"     ."</string>
 <string name="simlock_unlocked">"   "</string>
 <string name="vt_resolution_setting">"  "</string>
-</resources>
+    <string name="turn_off_ims_error">"WiFi   IMS   ,   WiFi    ."</string>
+     <string name="volte_config_notification_title">"VoLTE "</string>
+     <string name="volte_config_notification_on">"VoLTE "</string>
+     <string name="volte_config_notification_off">"VoLTE "</string>
+     <string name="network_mode_setting_prompt">"       "</string>
+     <string name="label_fdn">"  "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-kn-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-kn-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-kn-rIN/strings.xml	(revision 182305)
@@ -47,4 +47,7 @@
 </string-array>
 <string name="network_registration_fail_title">"  "</string>
 <string name="network_registration_fail">"  ,   ?"</string>
-</resources>
+    <string name="outgoing_call_not_allowed_user_restriction">"     ."</string>
+     <string name="number_limited_message">"  ,  ,   ."</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-ne-rNP/strings_ex.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-ne-rNP/strings_ex.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-ne-rNP/strings_ex.xml	(revision 182305)
@@ -19,4 +19,11 @@
 <string name="sim_lock_try_later">"   "</string>
 <string name="simlock_unlocked">"Sim     "</string>
 <string name="vt_resolution_setting">"   "</string>
-</resources>
+    <string name="turn_off_ims_error">"WiFi    IMS    ,   WiFi   "</string>
+     <string name="volte_config_notification_title">"VoLTE "</string>
+     <string name="volte_config_notification_on">"VoLTE  "</string>
+     <string name="volte_config_notification_off">"VoLTE  "</string>
+     <string name="network_mode_setting_prompt">"          "</string>
+     <string name="label_fdn">"   "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-ne-rNP/strings.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-ne-rNP/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-ne-rNP/strings.xml	(revision 182305)
@@ -47,4 +47,7 @@
 </string-array>
 <string name="network_registration_fail_title">"   "</string>
 <string name="network_registration_fail">"   ,      ?"</string>
-</resources>
+    <string name="outgoing_call_not_allowed_user_restriction">"      "</string>
+     <string name="number_limited_message">"   ,   ,    "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-gu-rIN/strings_ex.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-gu-rIN/strings_ex.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-gu-rIN/strings_ex.xml	(revision 182305)
@@ -19,4 +19,11 @@
 <string name="sim_lock_try_later">"    ."</string>
 <string name="simlock_unlocked">"Simlock     ." </string>
 <string name="vt_resolution_setting">"   "</string>
-</resources>
+    <string name="turn_off_ims_error">" WIFI     IMS    ,     WiFi   ."</string>
+     <string name="volte_config_notification_title">"VoLTE "</string>
+     <string name="volte_config_notification_on">"VoLTE "</string>
+     <string name="volte_config_notification_off">"VoLTE "</string>
+     <string name="network_mode_setting_prompt">"         ,     "</string>
+     <string name="label_fdn">"  "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-gu-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-gu-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-gu-rIN/strings.xml	(revision 182305)
@@ -47,4 +47,7 @@
 </string-array>
 <string name="network_registration_fail_title">"    "</string>
 <string name="network_registration_fail">"    ,     ?"</string>
-</resources>
+    <string name="outgoing_call_not_allowed_user_restriction">"      ."</string>
+     <string name="number_limited_message">"  ,   ,     ."</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-as/strings_ex.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-as/strings_ex.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-as/strings_ex.xml	(revision 182305)
@@ -19,4 +19,11 @@
 <string name="sim_lock_try_later">"     "</string>
 <string name="simlock_unlocked">"   "</string>
 <string name="vt_resolution_setting">"\'   "</string>
-</resources>
+    <string name="turn_off_ims_error">"WiFi      IMS   ,    WiFi   "</string>
+     <string name="volte_config_notification_title">"VoLTE "</string>
+     <string name="volte_config_notification_on">"VoLTE "</string>
+     <string name="volte_config_notification_off">"VoLTE "</string>
+     <string name="network_mode_setting_prompt">"           "</string>
+     <string name="label_fdn">"  "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-as/strings.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-as/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-as/strings.xml	(revision 182305)
@@ -570,4 +570,7 @@
 </string-array>
 <string name="network_registration_fail_title">"   "</string>
 <string name="network_registration_fail">"   \',     ?"</string>
-</resources>
+    <string name="outgoing_call_not_allowed_user_restriction">"        "</string>
+     <string name="number_limited_message">"    ,  ,     "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-pa-rIN/strings_ex.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-pa-rIN/strings_ex.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-pa-rIN/strings_ex.xml	(revision 182305)
@@ -19,4 +19,11 @@
 <string name="sim_lock_try_later">"      "</string>
 <string name="simlock_unlocked">"Simlock    "</string>
 <string name="vt_resolution_setting">"  "</string>
-</resources>
+    <string name="turn_off_ims_error">"WiFi     \' IMS       ,    WiFi    "</string>
+     <string name="volte_config_notification_title">"VoLTE   "</string>
+     <string name="volte_config_notification_on">"VoLTE   "</string>
+     <string name="volte_config_notification_off">"VoLTE   "</string>
+     <string name="network_mode_setting_prompt">"                  "</string>
+     <string name="label_fdn">"   "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-pa-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-pa-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-pa-rIN/strings.xml	(revision 182305)
@@ -47,4 +47,7 @@
 </string-array>
 <string name="network_registration_fail_title">"  "</string>
 <string name="network_registration_fail">"  ,       ?"</string>
-</resources>
+    <string name="outgoing_call_not_allowed_user_restriction">"          "</string>
+     <string name="number_limited_message">"    ,   ,     "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-ta-rIN/strings_ex.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-ta-rIN/strings_ex.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-ta-rIN/strings_ex.xml	(revision 182305)
@@ -19,4 +19,11 @@
 <string name="sim_lock_try_later">"   "</string>
 <string name="simlock_unlocked">"  ."</string>
 <string name="vt_resolution_setting">"  "</string>
-</resources>
+    <string name="turn_off_ims_error">"WiFi    IMS-   ,  WiFi   ."</string>
+     <string name="volte_config_notification_title">"VoLTE "</string>
+     <string name="volte_config_notification_on">"VoLTE "</string>
+     <string name="volte_config_notification_off">"VoLTE "</string>
+     <string name="network_mode_setting_prompt">"   ,     "</string>
+     <string name="label_fdn">"  "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-ta-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-ta-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-ta-rIN/strings.xml	(revision 182305)
@@ -47,4 +47,7 @@
 </string-array>
 <string name="network_registration_fail_title">"  "</string>
 <string name="network_registration_fail">"  ,    ?"</string>
-</resources>
+    <string name="outgoing_call_not_allowed_user_restriction">"  ,   ."</string>
+     <string name="number_limited_message">"  ,  ,  ."</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-te-rIN/strings_ex.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-te-rIN/strings_ex.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-te-rIN/strings_ex.xml	(revision 182305)
@@ -19,4 +19,11 @@
 <string name="sim_lock_try_later">"   ."</string>
 <string name="simlock_unlocked">"    ."</string>
 <string name="vt_resolution_setting">"  "</string>
-</resources>
+    <string name="turn_off_ims_error">"       ,      ."</string>
+     <string name="volte_config_notification_title">" "</string>
+     <string name="volte_config_notification_on">" "</string>
+     <string name="volte_config_notification_off">" "</string>
+     <string name="network_mode_setting_prompt">"              "</string>
+     <string name="label_fdn">"  "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-te-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-te-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-te-rIN/strings.xml	(revision 182305)
@@ -47,4 +47,7 @@
 </string-array>
 <string name="network_registration_fail_title">"  "</string>
 <string name="network_registration_fail">"  ,    ?"</string>
-</resources>
+    <string name="outgoing_call_not_allowed_user_restriction">"      ."</string>
+     <string name="number_limited_message">"  ,  .  ."</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-ur-rPK/strings_ex.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-ur-rPK/strings_ex.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-ur-rPK/strings_ex.xml	(revision 182305)
@@ -19,4 +19,11 @@
 <string name="sim_lock_try_later">"        "</string>
 <string name="simlock_unlocked">"Simlock       "</string>
 <string name="vt_resolution_setting">"   "</string>
-</resources>
+    <string name="turn_off_ims_error">"      IMS                ."</string>
+     <string name="volte_config_notification_title">"VoLTE  "</string>
+     <string name="volte_config_notification_on">" VoLTE  "</string>
+     <string name="volte_config_notification_off">" VoLTE  "</string>
+     <string name="network_mode_setting_prompt">"                 "</string>
+     <string name="label_fdn">"  "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-ur-rPK/strings.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-ur-rPK/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-ur-rPK/strings.xml	(revision 182305)
@@ -47,4 +47,7 @@
 </string-array>
 <string name="network_registration_fail_title">"   "</string>
 <string name="network_registration_fail">"              "</string>
-</resources>
+    <string name="outgoing_call_not_allowed_user_restriction">"          ."</string>
+     <string name="number_limited_message">"            ."</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-ml-rIN/strings_ex.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-ml-rIN/strings_ex.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-ml-rIN/strings_ex.xml	(revision 182305)
@@ -19,4 +19,11 @@
 <string name="sim_lock_try_later">"   ."</string>
 <string name="simlock_unlocked">"  ."</string>
 <string name="vt_resolution_setting">"   "</string>
-</resources>
+    <string name="turn_off_ims_error">"         .     ."</string>
+     <string name="volte_config_notification_title">"VoLTE "</string>
+     <string name="volte_config_notification_on">"VoLTE "</string>
+     <string name="volte_config_notification_off">"VoLTE "</string>
+     <string name="network_mode_setting_prompt">"    ,      "</string>
+     <string name="label_fdn">"  "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-ml-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-ml-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-ml-rIN/strings.xml	(revision 182305)
@@ -47,4 +47,7 @@
 </string-array>
 <string name="network_registration_fail_title">"  "</string>
 <string name="network_registration_fail">"  ,    ?"</string>
-</resources>
+    <string name="outgoing_call_not_allowed_user_restriction">"     ."</string>
+     <string name="number_limited_message">"  .   .   ."</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-mr-rIN/strings_ex.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-mr-rIN/strings_ex.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-mr-rIN/strings_ex.xml	(revision 182305)
@@ -19,4 +19,11 @@
 <string name="sim_lock_try_later">"   ."</string>
 <string name="simlock_unlocked">"   ."</string>
 <string name="vt_resolution_setting">"  "</string>
-</resources>
+    <string name="turn_off_ims_error">" WiFi     IMS    ,   WiFi   ."</string>
+     <string name="volte_config_notification_title">"VoLTE "</string>
+     <string name="volte_config_notification_on">"VoLTE "</string>
+     <string name="volte_config_notification_off">"VoLTE "</string>
+     <string name="network_mode_setting_prompt">""              "</string>
+     <string name="label_fdn">"   "</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/platform/packages/services/Telephony/res/values-mr-rIN/strings.xml
===================================================================
--- vendor/sprd/platform/packages/services/Telephony/res/values-mr-rIN/strings.xml	(revision 182304)
+++ vendor/sprd/platform/packages/services/Telephony/res/values-mr-rIN/strings.xml	(revision 182305)
@@ -47,4 +47,7 @@
 </string-array>
 <string name="network_registration_fail_title">"  "</string>
 <string name="network_registration_fail">"  ,      ?"</string>
-</resources>
+    <string name="outgoing_call_not_allowed_user_restriction">"       ."</string>
+     <string name="number_limited_message">"   ,   ,    ."</string>
+
+</resources>
\ No newline at end of file
Index: vendor/sprd/modules/libcamera/oem2v0/src/cmr_fd_sprd.c
===================================================================
--- vendor/sprd/modules/libcamera/oem2v0/src/cmr_fd_sprd.c	(revision 182304)
+++ vendor/sprd/modules/libcamera/oem2v0/src/cmr_fd_sprd.c	(revision 182305)
@@ -14,7 +14,8 @@
  * limitations under the License.
  */
 
-#if defined (CONFIG_CAMERA_FACE_DETECT) && defined (CONFIG_CAMERA_FACE_DETECT_SPRD)
+#if defined(CONFIG_CAMERA_FACE_DETECT) &&                                      \
+    defined(CONFIG_CAMERA_FACE_DETECT_SPRD)
 
 #define LOG_TAG "cmr_fd_sprd"
 
@@ -30,851 +31,929 @@
 #include "facealignapi.h"
 #include "faceattributeapi.h"
 
-#define FD_MAX_FACE_NUM         10
-#define FD_RUN_FAR_INTERVAL     6   /* The frame interval to run FAR. For reducing computation cost */
+#define FD_MAX_FACE_NUM 10
+#define FD_RUN_FAR_INTERVAL                                                    \
+    8 /* The frame interval to run FAR. For reducing computation cost */
 
+#ifndef ABS
+#define ABS(x) (((x) > 0) ? (x) : -(x))
+#endif
+
 struct class_faceattr {
-	FA_SHAPE        shape;
-	FAR_ATTRIBUTE   attr;
-	int             face_id;  /* face id gotten from face detection */
+    FA_SHAPE shape;
+    FAR_ATTRIBUTE attr;
+    int face_id; /* face id gotten from face detection */
 };
 
 struct class_faceattr_array {
-	int                     count;                   /* face count      */
-	int                     frame_idx;               /* The frame when the face attributes are updated */
-	struct class_faceattr   face[FD_MAX_FACE_NUM+1]; /* face attricutes */
+    int count;          /* face count      */
+    cmr_uint frame_idx; /* The frame when the face attributes are updated */
+    struct class_faceattr face[FD_MAX_FACE_NUM + 1]; /* face attricutes */
 };
 
 struct class_fd {
-	struct ipm_common               common;
-	cmr_handle                      thread_handle;
-	cmr_uint                        is_busy;
-	cmr_uint                        is_inited;
-	void                            *alloc_addr;
-	cmr_uint                        mem_size;
-	cmr_uint                        frame_cnt;
-	cmr_uint                        frame_total_num;
-	struct ipm_frame_in             frame_in;
-	struct ipm_frame_out            frame_out;
-	ipm_callback                    frame_cb;
-	struct img_size                 fd_img_size;
-	struct img_face_area            face_area_prev;/* The faces detected from the previous frame; It is used to make face detection results more stable */
-	struct class_faceattr_array     faceattr_arr;  /* face attributes */
-	cmr_uint                        curr_frame_idx;
-	cmr_uint                        is_get_result;
-	FD_DETECTOR_HANDLE              hDT;           /* Face Detection Handle */
-	FA_ALIGN_HANDLE                 hFaceAlign;    /* Handle for face alignment */
-	FAR_RECOGNIZER_HANDLE           hFAR;          /* Handle for face attribute recognition */
+    struct ipm_common common;
+    cmr_handle thread_handle;
+    cmr_uint is_busy;
+    cmr_uint is_inited;
+    void *alloc_addr;
+    cmr_uint mem_size;
+    cmr_uint frame_cnt;
+    cmr_uint frame_total_num;
+    struct ipm_frame_in frame_in;
+    struct ipm_frame_out frame_out;
+    ipm_callback frame_cb;
+    struct img_size fd_img_size;
+    struct img_face_area
+        face_area_prev; /* The faces detected from the previous frame; It is
+                           used to make face detection results more stable */
+    struct class_faceattr_array faceattr_arr; /* face attributes */
+    cmr_uint curr_frame_idx;
+    cmr_uint is_get_result;
+    FD_DETECTOR_HANDLE hDT;     /* Face Detection Handle */
+    FA_ALIGN_HANDLE hFaceAlign; /* Handle for face alignment */
+    FAR_RECOGNIZER_HANDLE hFAR; /* Handle for face attribute recognition */
 };
 
-
 struct fd_start_parameter {
-	void                            *frame_data;
-	ipm_callback                    frame_cb;
-	cmr_handle                      caller_handle;
-	void                            *private_data;
+    void *frame_data;
+    ipm_callback frame_cb;
+    cmr_handle caller_handle;
+    void *private_data;
 };
 
-static cmr_int fd_open(cmr_handle ipm_handle, struct ipm_open_in *in, struct ipm_open_out *out,
-				cmr_handle *out_class_handle);
+static cmr_int fd_open(cmr_handle ipm_handle, struct ipm_open_in *in,
+                       struct ipm_open_out *out, cmr_handle *out_class_handle);
 static cmr_int fd_close(cmr_handle class_handle);
-static cmr_int fd_transfer_frame(cmr_handle class_handle,struct ipm_frame_in *in, struct ipm_frame_out *out);
+static cmr_int fd_transfer_frame(cmr_handle class_handle,
+                                 struct ipm_frame_in *in,
+                                 struct ipm_frame_out *out);
 static cmr_int fd_pre_proc(cmr_handle class_handle);
 static cmr_int fd_post_proc(cmr_handle class_handle);
-static cmr_int fd_start(cmr_handle class_handle, struct fd_start_parameter *param);
+static cmr_int fd_start(cmr_handle class_handle,
+                        struct fd_start_parameter *param);
 static cmr_uint check_size_data_invalid(struct img_size *fd_img_size);
-static cmr_int fd_call_init(struct class_fd *class_handle, const struct img_size *fd_img_size);
+static cmr_int fd_call_init(struct class_fd *class_handle,
+                            const struct img_size *fd_img_size);
 static cmr_uint fd_is_busy(struct class_fd *class_handle);
 static void fd_set_busy(struct class_fd *class_handle, cmr_uint is_busy);
 static cmr_int fd_thread_create(struct class_fd *class_handle);
 static cmr_int fd_thread_proc(struct cmr_msg *message, void *private_data);
 
-
 static struct class_ops fd_ops_tab_info = {
-	fd_open,
-	fd_close,
-	fd_transfer_frame,
-	fd_pre_proc,
-	fd_post_proc,
+    fd_open, fd_close, fd_transfer_frame, fd_pre_proc, fd_post_proc,
 };
 
 struct class_tab_t fd_tab_info = {
-	&fd_ops_tab_info,
+    &fd_ops_tab_info,
 };
 
+#define CMR_EVT_FD_START (1 << 16)
+#define CMR_EVT_FD_EXIT (1 << 17)
+#define CMR_EVT_FD_INIT (1 << 18)
+#define CMR__EVT_FD_MASK_BITS                                                  \
+    (cmr_u32)(CMR_EVT_FD_START | CMR_EVT_FD_EXIT | CMR_EVT_FD_INIT)
 
-#define CMR_EVT_FD_START          (1 << 16)
-#define CMR_EVT_FD_EXIT           (1 << 17)
-#define CMR_EVT_FD_INIT           (1 << 18)
-#define CMR__EVT_FD_MASK_BITS     (cmr_u32)(CMR_EVT_FD_START | \
-					CMR_EVT_FD_EXIT | \
-					CMR_EVT_FD_INIT)
+#define CAMERA_FD_MSG_QUEUE_SIZE 5
+#define IMAGE_FORMAT "YVU420_SEMIPLANAR"
 
-#define CAMERA_FD_MSG_QUEUE_SIZE  5
-#define IMAGE_FORMAT              "YVU420_SEMIPLANAR"
+#define CHECK_HANDLE_VALID(handle)                                             \
+    do {                                                                       \
+        if (!handle) {                                                         \
+            return CMR_CAMERA_INVALID_PARAM;                                   \
+        }                                                                      \
+    } while (0)
 
-#define CHECK_HANDLE_VALID(handle) \
-	do { \
-		if (!handle) { \
-			return CMR_CAMERA_INVALID_PARAM; \
-		} \
-	} while(0)
+static cmr_int fd_open(cmr_handle ipm_handle, struct ipm_open_in *in,
+                       struct ipm_open_out *out, cmr_handle *out_class_handle) {
+    cmr_int ret = CMR_CAMERA_SUCCESS;
+    struct class_fd *fd_handle = NULL;
+    struct img_size *fd_img_size;
 
+    if (!out || !in || !ipm_handle || !out_class_handle) {
+        CMR_LOGE("Invalid Param!");
+        return CMR_CAMERA_INVALID_PARAM;
+    }
 
-static cmr_int fd_open(cmr_handle ipm_handle, struct ipm_open_in *in, struct ipm_open_out *out,
-				cmr_handle *out_class_handle)
-{
-	cmr_int              ret        = CMR_CAMERA_SUCCESS;
-	struct class_fd      *fd_handle = NULL;
-	struct img_size      *fd_img_size;
+    fd_handle = (struct class_fd *)malloc(sizeof(struct class_fd));
+    if (!fd_handle) {
+        CMR_LOGE("No mem!");
+        return CMR_CAMERA_NO_MEM;
+    }
 
-	if (!out || !in || !ipm_handle || !out_class_handle) {
-		CMR_LOGE("Invalid Param!");
-		return CMR_CAMERA_INVALID_PARAM;
-	}
+    cmr_bzero(fd_handle, sizeof(struct class_fd));
 
-	fd_handle = (struct class_fd *)malloc(sizeof(struct class_fd));
-	if (!fd_handle) {
-		CMR_LOGE("No mem!");
-		return CMR_CAMERA_NO_MEM;
-	}
+    fd_handle->common.ipm_cxt = (struct ipm_context_t *)ipm_handle;
+    fd_handle->common.class_type = IPM_TYPE_FD;
+    fd_handle->common.ops = &fd_ops_tab_info;
+    fd_handle->frame_cb = in->reg_cb;
+    fd_handle->mem_size =
+        in->frame_size.height * in->frame_size.width; // * 3 / 2;
+    fd_handle->frame_total_num = in->frame_cnt;
+    fd_handle->frame_cnt = 0;
+    fd_handle->fd_img_size = in->frame_size;
+    fd_handle->face_area_prev.face_count = 0;
+    fd_handle->curr_frame_idx = 0;
+    fd_handle->faceattr_arr.count = 0;
 
-	cmr_bzero(fd_handle, sizeof(struct class_fd));
+    CMR_LOGD("mem_size = 0x%ld", fd_handle->mem_size);
+    fd_handle->alloc_addr = malloc(fd_handle->mem_size);
+    if (!fd_handle->alloc_addr) {
+        CMR_LOGE("mem alloc failed");
+        goto free_fd_handle;
+    }
 
-	fd_handle->common.ipm_cxt     = (struct ipm_context_t*)ipm_handle;
-	fd_handle->common.class_type  = IPM_TYPE_FD;
-	fd_handle->common.ops         = &fd_ops_tab_info;
-	fd_handle->frame_cb           = in->reg_cb;
-	fd_handle->mem_size           = in->frame_size.height * in->frame_size.width * 3 / 2;
-	fd_handle->frame_total_num    = in->frame_cnt;
-	fd_handle->frame_cnt          = 0;
-	fd_handle->fd_img_size        = in->frame_size;
-	fd_handle->face_area_prev.face_count = 0;
-	fd_handle->curr_frame_idx     = 0;
-	fd_handle->faceattr_arr.count = 0;
+    ret = fd_thread_create(fd_handle);
+    if (ret) {
+        CMR_LOGE("failed to create thread.");
+        goto free_fd_handle;
+    }
 
-	CMR_LOGD("mem_size = 0x%ld", fd_handle->mem_size);
-	fd_handle->alloc_addr = malloc(fd_handle->mem_size);
-	if (!fd_handle->alloc_addr) {
-		CMR_LOGE("mem alloc failed");
-		goto free_fd_handle;
-	}
+    fd_img_size = &in->frame_size;
+    CMR_LOGI("fd_img_size height = %d, width = %d", fd_img_size->height,
+             fd_img_size->width);
+    ret = fd_call_init(fd_handle, fd_img_size);
+    if (ret) {
+        CMR_LOGE("failed to init fd");
+        fd_close(fd_handle);
+    } else {
+        *out_class_handle = (cmr_handle)fd_handle;
+    }
 
-	ret = fd_thread_create(fd_handle);
-	if (ret) {
-		CMR_LOGE("failed to create thread.");
-		goto free_fd_handle;
-	}
+    return ret;
 
-	fd_img_size = &in->frame_size;
-	CMR_LOGI("fd_img_size height = %d, width = %d", fd_img_size->height, fd_img_size->width);
-	ret = fd_call_init(fd_handle, fd_img_size);
-	if (ret) {
-		CMR_LOGE("failed to init fd");
-		fd_close(fd_handle);
-	} else {
-		*out_class_handle = (cmr_handle )fd_handle;
-	}
-
-	return ret;
-
 free_fd_handle:
-	if (fd_handle->alloc_addr) {
-		free(fd_handle->alloc_addr);
-	}
-	free(fd_handle);
-	return ret;
+    if (fd_handle->alloc_addr) {
+        free(fd_handle->alloc_addr);
+    }
+    free(fd_handle);
+    return ret;
 }
 
-static cmr_int fd_close(cmr_handle class_handle)
-{
-	cmr_int              ret         = CMR_CAMERA_SUCCESS;
-	struct class_fd      *fd_handle  = (struct class_fd *)class_handle;
-	CMR_MSG_INIT(message);
+static cmr_int fd_close(cmr_handle class_handle) {
+    cmr_int ret = CMR_CAMERA_SUCCESS;
+    struct class_fd *fd_handle = (struct class_fd *)class_handle;
+    CMR_MSG_INIT(message);
 
-	CHECK_HANDLE_VALID(fd_handle);
+    CHECK_HANDLE_VALID(fd_handle);
 
-	message.msg_type = CMR_EVT_FD_EXIT;
-	message.sync_flag = CMR_MSG_SYNC_PROCESSED;
-	ret = cmr_thread_msg_send(fd_handle->thread_handle, &message);
-	if (ret) {
-		CMR_LOGE("send msg fail");
-		goto out;
-	}
+    message.msg_type = CMR_EVT_FD_EXIT;
+    message.sync_flag = CMR_MSG_SYNC_PROCESSED;
+    ret = cmr_thread_msg_send(fd_handle->thread_handle, &message);
+    if (ret) {
+        CMR_LOGE("send msg fail");
+        goto out;
+    }
 
-	if (fd_handle->thread_handle) {
-		cmr_thread_destroy(fd_handle->thread_handle);
-		fd_handle->thread_handle = 0;
-		fd_handle->is_inited     = 0;
-	}
+    if (fd_handle->thread_handle) {
+        cmr_thread_destroy(fd_handle->thread_handle);
+        fd_handle->thread_handle = 0;
+        fd_handle->is_inited = 0;
+    }
 
-	if (fd_handle->alloc_addr) {
-		free(fd_handle->alloc_addr);
-	}
+    if (fd_handle->alloc_addr) {
+        free(fd_handle->alloc_addr);
+    }
 
-	free(fd_handle);
+    free(fd_handle);
 
 out:
-	return ret;
+    return ret;
 }
 
-static cmr_int fd_transfer_frame(cmr_handle class_handle,struct ipm_frame_in *in, struct ipm_frame_out *out)
-{
-	cmr_int                   ret         = CMR_CAMERA_SUCCESS;
-	struct class_fd           *fd_handle  = (struct class_fd *)class_handle;
-	cmr_uint                  frame_cnt;
-	cmr_u32                   is_busy     = 0;
-	struct fd_start_parameter param;
+static cmr_int fd_transfer_frame(cmr_handle class_handle,
+                                 struct ipm_frame_in *in,
+                                 struct ipm_frame_out *out) {
+    cmr_int ret = CMR_CAMERA_SUCCESS;
+    struct class_fd *fd_handle = (struct class_fd *)class_handle;
+    cmr_uint frame_cnt;
+    cmr_u32 is_busy = 0;
+    struct fd_start_parameter param;
 
-	if (!in || !class_handle) {
-		CMR_LOGE("Invalid Param!");
-		return CMR_CAMERA_INVALID_PARAM;
-	}
+    if (!in || !class_handle) {
+        CMR_LOGE("Invalid Param!");
+        return CMR_CAMERA_INVALID_PARAM;
+    }
 
-	frame_cnt   = ++fd_handle->frame_cnt;
+    frame_cnt = ++fd_handle->frame_cnt;
 
-	if (frame_cnt < fd_handle->frame_total_num) {
-		CMR_LOGD("This is fd 0x%ld frame. need the 0x%ld frame,",frame_cnt, fd_handle->frame_total_num);
-		return ret;
-	}
+    if (frame_cnt < fd_handle->frame_total_num) {
+        CMR_LOGD("This is fd 0x%ld frame. need the 0x%ld frame,", frame_cnt,
+                 fd_handle->frame_total_num);
+        return ret;
+    }
 
-	fd_handle->curr_frame_idx++;
+    fd_handle->curr_frame_idx++;
 
-	// reduce the frame rate, because the current face detection (tracking mode) is too fast!!
-	{
-		const static cmr_uint DROP_RATE = 2;
-		if ((fd_handle->curr_frame_idx % DROP_RATE) != 0) {
-			return ret;
-		}
-	}
+    // reduce the frame rate, because the current face detection (tracking mode)
+    // is too fast!!
+    {
+        const static cmr_uint DROP_RATE = 2;
+        if ((fd_handle->curr_frame_idx % DROP_RATE) != 0) {
+            return ret;
+        }
+    }
 
-	is_busy = fd_is_busy(fd_handle);
-	// CMR_LOGI("fd is_busy =%d", is_busy);
+    is_busy = fd_is_busy(fd_handle);
+    // CMR_LOGI("fd is_busy =%d", is_busy);
 
-	if (!is_busy) {
-		fd_handle->frame_cnt = 0;
-		fd_handle->frame_in  = *in;
+    if (!is_busy) {
+        fd_handle->frame_cnt = 0;
+        fd_handle->frame_in = *in;
 
-		param.frame_data    = (void *)in->src_frame.addr_phy.addr_y;
-		param.frame_cb      = fd_handle->frame_cb;
-		param.caller_handle = in->caller_handle;
-		param.private_data  = in->private_data;
+        param.frame_data = (void *)in->src_frame.addr_vir.addr_y;
+        param.frame_cb = fd_handle->frame_cb;
+        param.caller_handle = in->caller_handle;
+        param.private_data = in->private_data;
 
-		memcpy(fd_handle->alloc_addr, (void *)in->src_frame.addr_vir.addr_y, fd_handle->mem_size);
+        memcpy(fd_handle->alloc_addr, (void *)in->src_frame.addr_vir.addr_y,
+               fd_handle->mem_size);
 
-		ret = fd_start(class_handle,&param);
-		if (ret) {
-			CMR_LOGE("send msg fail");
-			goto out;
-		}
+        ret = fd_start(class_handle, &param);
+        if (ret) {
+            CMR_LOGE("send msg fail");
+            goto out;
+        }
 
-		if (fd_handle->frame_cb) {
-			if (out != NULL) {
-				cmr_bzero(out,sizeof(struct ipm_frame_out));
-			}
-		} else {
-			if (out != NULL) {
-				out = &fd_handle->frame_out;
-			} else {
-				CMR_LOGE("sync err,out parm can't NULL.");
-			}
-		}
-	} else if(!fd_handle->is_get_result) {
-				/*!!Warning: The following codes are not thread-safe */
-				memcpy(&fd_handle->frame_out.face_area, &fd_handle->face_area_prev, sizeof(struct img_face_area));
-				fd_handle->frame_out.dst_frame.size.width = fd_handle->frame_in.src_frame.size.width;
-				fd_handle->frame_out.dst_frame.size.height = fd_handle->frame_in.src_frame.size.height;
+        if (fd_handle->frame_cb) {
+            if (out != NULL) {
+                cmr_bzero(out, sizeof(struct ipm_frame_out));
+            }
+        } else {
+            if (out != NULL) {
+                out = &fd_handle->frame_out;
+            } else {
+                CMR_LOGE("sync err,out parm can't NULL.");
+            }
+        }
+    } else if (!fd_handle->is_get_result) {
+        /*!!Warning: The following codes are not thread-safe */
+        memcpy(&fd_handle->frame_out.face_area, &fd_handle->face_area_prev,
+               sizeof(struct img_face_area));
+        fd_handle->frame_out.dst_frame.size.width =
+            fd_handle->frame_in.src_frame.size.width;
+        fd_handle->frame_out.dst_frame.size.height =
+            fd_handle->frame_in.src_frame.size.height;
 
-				/*callback*/
-				if (fd_handle->frame_cb) {
-				fd_handle->frame_out.private_data = in->private_data;
-				fd_handle->frame_out.caller_handle = in->caller_handle;
-				fd_handle->frame_cb(IPM_TYPE_FD, &fd_handle->frame_out);
-			}
-			if (fd_handle->frame_cb) {
-				if (out != NULL) {
-					cmr_bzero(out,sizeof(struct ipm_frame_out));
-				}
-			} else {
-				if (out != NULL) {
-					out = &fd_handle->frame_out;
-				} else {
-					CMR_LOGE("sync err,out parm can't NULL.");
-			}
-		}
-	}
+        /*callback*/
+        if (fd_handle->frame_cb) {
+            fd_handle->frame_out.private_data = in->private_data;
+            fd_handle->frame_out.caller_handle = in->caller_handle;
+            fd_handle->frame_cb(IPM_TYPE_FD, &fd_handle->frame_out);
+        }
+        if (fd_handle->frame_cb) {
+            if (out != NULL) {
+                cmr_bzero(out, sizeof(struct ipm_frame_out));
+            }
+        } else {
+            if (out != NULL) {
+                out = &fd_handle->frame_out;
+            } else {
+                CMR_LOGE("sync err,out parm can't NULL.");
+            }
+        }
+    }
 
 out:
-	return ret;
+    return ret;
 }
 
-static cmr_int fd_pre_proc(cmr_handle class_handle)
-{
-	cmr_int              ret = CMR_CAMERA_SUCCESS;
+static cmr_int fd_pre_proc(cmr_handle class_handle) {
+    cmr_int ret = CMR_CAMERA_SUCCESS;
 
-	/*no need to do*/
-	(void)class_handle;
+    /*no need to do*/
+    (void)class_handle;
 
-	return ret;
+    return ret;
 }
 
-static cmr_int fd_post_proc(cmr_handle class_handle)
-{
-	cmr_int              ret = CMR_CAMERA_SUCCESS;
+static cmr_int fd_post_proc(cmr_handle class_handle) {
+    cmr_int ret = CMR_CAMERA_SUCCESS;
 
-	/*no need to do*/
-	(void)class_handle;
+    /*no need to do*/
+    (void)class_handle;
 
-	return ret;
+    return ret;
 }
 
-static cmr_int fd_start(cmr_handle class_handle, struct fd_start_parameter *param)
-{
-	cmr_int              ret         = CMR_CAMERA_SUCCESS;
-	struct class_fd      *fd_handle  = (struct class_fd *)class_handle;
-	cmr_u32              is_busy     = 0;
-	CMR_MSG_INIT(message);
+static cmr_int fd_start(cmr_handle class_handle,
+                        struct fd_start_parameter *param) {
+    cmr_int ret = CMR_CAMERA_SUCCESS;
+    struct class_fd *fd_handle = (struct class_fd *)class_handle;
+    cmr_u32 is_busy = 0;
+    CMR_MSG_INIT(message);
 
-	if (!class_handle || !param) {
-		CMR_LOGE("parameter is NULL. fail");
-		return CMR_CAMERA_INVALID_PARAM;
-	}
+    if (!class_handle || !param) {
+        CMR_LOGE("parameter is NULL. fail");
+        return CMR_CAMERA_INVALID_PARAM;
+    }
 
-	if (!param->frame_data) {
-		CMR_LOGE("frame_data is NULL. fail");
-		return CMR_CAMERA_INVALID_PARAM;
-	}
+    if (!param->frame_data) {
+        CMR_LOGE("frame_data is NULL. fail");
+        return CMR_CAMERA_INVALID_PARAM;
+    }
 
-	message.data = (void *)malloc(sizeof(struct fd_start_parameter));
-	if (NULL == message.data) {
-		CMR_LOGE("NO mem, Fail to alloc memory for msg data");
-		return CMR_CAMERA_NO_MEM;
-	}
+    message.data = (void *)malloc(sizeof(struct fd_start_parameter));
+    if (NULL == message.data) {
+        CMR_LOGE("NO mem, Fail to alloc memory for msg data");
+        return CMR_CAMERA_NO_MEM;
+    }
 
-	memcpy(message.data, param, sizeof(struct fd_start_parameter));
+    memcpy(message.data, param, sizeof(struct fd_start_parameter));
 
-	message.msg_type = CMR_EVT_FD_START;
-	message.alloc_flag = 1;
+    message.msg_type = CMR_EVT_FD_START;
+    message.alloc_flag = 1;
 
-	if (fd_handle->frame_cb) {
-		message.sync_flag = CMR_MSG_SYNC_RECEIVED;
-		//message.sync_flag = CMR_MSG_SYNC_PROCESSED;
-	} else {
-		message.sync_flag = CMR_MSG_SYNC_PROCESSED;
-	}
+    if (fd_handle->frame_cb) {
+        message.sync_flag = CMR_MSG_SYNC_RECEIVED;
+        // message.sync_flag = CMR_MSG_SYNC_PROCESSED;
+    } else {
+        message.sync_flag = CMR_MSG_SYNC_PROCESSED;
+    }
 
-	ret = cmr_thread_msg_send(fd_handle->thread_handle, &message);
-	if (ret) {
-		CMR_LOGE("send msg fail");
-		ret = CMR_CAMERA_FAIL;
-	}
+    ret = cmr_thread_msg_send(fd_handle->thread_handle, &message);
+    if (ret) {
+        CMR_LOGE("send msg fail");
+        ret = CMR_CAMERA_FAIL;
+    }
 
-	return ret;
+    return ret;
 }
 
-static cmr_uint check_size_data_invalid(struct img_size *fd_img_size)
-{
-	cmr_int              ret = -CMR_CAMERA_FAIL;
+static cmr_uint check_size_data_invalid(struct img_size *fd_img_size) {
+    cmr_int ret = -CMR_CAMERA_FAIL;
 
-	if (NULL != fd_img_size) {
-		if ((fd_img_size->width) && (fd_img_size->height)){
-			ret= CMR_CAMERA_SUCCESS;
-		}
-	}
+    if (NULL != fd_img_size) {
+        if ((fd_img_size->width) && (fd_img_size->height)) {
+            ret = CMR_CAMERA_SUCCESS;
+        }
+    }
 
-	return ret;
+    return ret;
 }
 
-static cmr_int fd_call_init(struct class_fd *class_handle, const struct img_size *fd_img_size)
-{
-	cmr_int              ret = CMR_CAMERA_SUCCESS;
-	CMR_MSG_INIT(message);
+static cmr_int fd_call_init(struct class_fd *class_handle,
+                            const struct img_size *fd_img_size) {
+    cmr_int ret = CMR_CAMERA_SUCCESS;
+    CMR_MSG_INIT(message);
 
-	message.data = malloc(sizeof(struct img_size));
-	if (NULL == message.data) {
-		CMR_LOGE("NO mem, Fail to alloc memory for msg data");
-		ret = CMR_CAMERA_NO_MEM;
-		goto out;
-	}
+    message.data = malloc(sizeof(struct img_size));
+    if (NULL == message.data) {
+        CMR_LOGE("NO mem, Fail to alloc memory for msg data");
+        ret = CMR_CAMERA_NO_MEM;
+        goto out;
+    }
 
-	message.alloc_flag = 1;
-	memcpy(message.data, fd_img_size, sizeof(struct img_size));
+    message.alloc_flag = 1;
+    memcpy(message.data, fd_img_size, sizeof(struct img_size));
 
-	message.msg_type = CMR_EVT_FD_INIT;
-	message.sync_flag = CMR_MSG_SYNC_PROCESSED;
-	ret = cmr_thread_msg_send(class_handle->thread_handle, &message);
-	if (CMR_CAMERA_SUCCESS != ret) {
-		CMR_LOGE("msg send fail");
-		ret = CMR_CAMERA_FAIL;
-		goto free_all;
-	}
+    message.msg_type = CMR_EVT_FD_INIT;
+    message.sync_flag = CMR_MSG_SYNC_PROCESSED;
+    ret = cmr_thread_msg_send(class_handle->thread_handle, &message);
+    if (CMR_CAMERA_SUCCESS != ret) {
+        CMR_LOGE("msg send fail");
+        ret = CMR_CAMERA_FAIL;
+        goto free_all;
+    }
 
-	return ret;
+    return ret;
 
 free_all:
-	free(message.data);
+    free(message.data);
 out:
-	return ret;
+    return ret;
 }
 
-static cmr_uint fd_is_busy(struct class_fd *class_handle)
-{
-	cmr_int              is_busy = 0;
+static cmr_uint fd_is_busy(struct class_fd *class_handle) {
+    cmr_int is_busy = 0;
 
-	if (NULL == class_handle) {
-		return is_busy;
-	}
+    if (NULL == class_handle) {
+        return is_busy;
+    }
 
-	is_busy = class_handle->is_busy;
+    is_busy = class_handle->is_busy;
 
-	return is_busy;
+    return is_busy;
 }
 
-static void fd_set_busy(struct class_fd *class_handle, cmr_uint is_busy)
-{
-	if (NULL == class_handle) {
-		return;
-	}
+static void fd_set_busy(struct class_fd *class_handle, cmr_uint is_busy) {
+    if (NULL == class_handle) {
+        return;
+    }
 
-	class_handle->is_busy = is_busy;
+    class_handle->is_busy = is_busy;
 }
 
+static cmr_int fd_thread_create(struct class_fd *class_handle) {
+    cmr_int ret = CMR_CAMERA_SUCCESS;
+    CMR_MSG_INIT(message);
 
-static cmr_int fd_thread_create(struct class_fd *class_handle)
-{
-	cmr_int                 ret = CMR_CAMERA_SUCCESS;
-	CMR_MSG_INIT(message);
+    CHECK_HANDLE_VALID(class_handle);
 
-	CHECK_HANDLE_VALID(class_handle);
+    if (!class_handle->is_inited) {
+        ret = cmr_thread_create(&class_handle->thread_handle,
+                                CAMERA_FD_MSG_QUEUE_SIZE, fd_thread_proc,
+                                (void *)class_handle);
+        if (ret) {
+            CMR_LOGE("send msg failed!");
+            ret = CMR_CAMERA_FAIL;
+            goto end;
+        }
 
-	if (!class_handle->is_inited) {
-		ret = cmr_thread_create(&class_handle->thread_handle,
-					CAMERA_FD_MSG_QUEUE_SIZE,
-					fd_thread_proc,
-					(void*)class_handle);
-		if (ret) {
-			CMR_LOGE("send msg failed!");
-			ret = CMR_CAMERA_FAIL;
-			goto end;
-		}
+        class_handle->is_inited = 1;
+    } else {
+        CMR_LOGI("fd is inited already");
+    }
 
-		class_handle->is_inited = 1;
-	} else {
-		CMR_LOGI("fd is inited already");
-	}
-
 end:
-	return ret;
+    return ret;
 }
 
-static void fd_recognize_face_attribute(FD_DETECTOR_HANDLE hDT,
-                    FA_ALIGN_HANDLE hFaceAlign,
-                    FAR_RECOGNIZER_HANDLE hFAR,
-                    struct class_faceattr_array *io_faceattr_arr,
-                    const cmr_u8 *i_image_data,
-                    struct img_size i_image_size,
-                    const cmr_uint i_curr_frame_idx)
-{
-	cmr_int face_count = 0;
-	cmr_int fd_idx = 0;
-	cmr_int i = 0;
-	struct class_faceattr_array new_attr_array = {0};
-	FA_IMAGE img = {0};
+static void fd_recognize_face_attribute(
+    FD_DETECTOR_HANDLE hDT, FA_ALIGN_HANDLE hFaceAlign,
+    FAR_RECOGNIZER_HANDLE hFAR, struct class_faceattr_array *io_faceattr_arr,
+    const cmr_u8 *i_image_data, struct img_size i_image_size,
+    const cmr_uint i_curr_frame_idx) {
+    cmr_int face_count = 0;
+    cmr_int fd_idx = 0;
+    cmr_int i = 0;
+    struct class_faceattr_array new_attr_array;
+    FA_IMAGE img;
 
-	/* Don't update face attribute, if the frame interval is not enough. For reducing computation cost */
-	if ( (i_curr_frame_idx - io_faceattr_arr->frame_idx) < FD_RUN_FAR_INTERVAL ) {
-		return;
-	}
+    face_count = FdGetFaceCount(hDT);
+    if (face_count <= 0) {
+        return;
+    }
 
-	img.data = (unsigned char *)i_image_data;
-	img.width = i_image_size.width;
-	img.height = i_image_size.height;
-	img.step = img.width;
+    /* Don't update face attribute, if the frame interval is not enough. For
+     * reducing computation cost */
+    if ((io_faceattr_arr->count > 0) &&
+        (i_curr_frame_idx - io_faceattr_arr->frame_idx) < FD_RUN_FAR_INTERVAL) {
+        return;
+    }
 
-	face_count = FdGetFaceCount(hDT);
+    cmr_bzero(&new_attr_array, sizeof(struct class_faceattr_array));
+    cmr_bzero(&img, sizeof(FA_IMAGE));
 
-	for (fd_idx = 0; fd_idx < face_count; fd_idx++) {
-		struct class_faceattr *fattr = &(new_attr_array.face[fd_idx]);
-		FD_FACEINFO info;
-		FdGetFaceInfo(hDT, fd_idx, &info);
+    img.data = (unsigned char *)i_image_data;
+    img.width = i_image_size.width;
+    img.height = i_image_size.height;
+    img.step = img.width;
 
-		/* Assign the same face id with FD */
-		fattr->face_id = info.id;
-		fattr->attr.smile = 0;
-		fattr->attr.eyeClose = 0;
+    // When there are many faces, process every face will be too slow.
+    // Limit face count to 2
+    face_count = MAX(face_count, 2);
 
-		/* Run face alignment */
-		{
-			FA_FACEINFO faface;
-			faface.x = info.x;
-			faface.y = info.y;
-			faface.width = info.width;
-			faface.height = info.height;
-			faface.yawAngle = info.yawAngle;
-			faface.rollAngle = info.rollAngle;
-			FaFaceAlign(hFaceAlign, &img, &faface, &(fattr->shape));
-		}
+    for (fd_idx = 0; fd_idx < face_count; fd_idx++) {
+        struct class_faceattr *fattr = &(new_attr_array.face[fd_idx]);
+        FD_FACEINFO info;
+        FdGetFaceInfo(hDT, fd_idx, &info);
 
-		/* Run face attribute recognition */
-		{
-			FAR_OPTION opt;
-			FAR_FACEINFO farface;
+        /* Assign the same face id with FD */
+        fattr->face_id = info.id;
+        fattr->attr.smile = 0;
+        fattr->attr.eyeClose = 0;
 
-			/* set option: only do smile detection */
-			opt.smileOn = 1;
-			opt.eyeOn = 0;
-			opt.infantOn = 0;
-			opt.genderOn = 0;
+        /* Run face alignment */
+        {
+            FA_FACEINFO faface;
+            faface.x = info.x;
+            faface.y = info.y;
+            faface.width = info.width;
+            faface.height = info.height;
+            faface.yawAngle = info.yawAngle;
+            faface.rollAngle = info.rollAngle;
+            FaFaceAlign(hFaceAlign, &img, &faface, &(fattr->shape));
+        }
 
-			/* Set the eye locations */
-			for (i = 0; i < 7; i++) {
-				farface.landmarks[i].x = fattr->shape.data[i*2];
-				farface.landmarks[i].y = fattr->shape.data[i*2+1];
-			}
+        /* Run face attribute recognition */
+        {
+            FAR_OPTION opt;
+            FAR_FACEINFO farface;
 
-			{
-				int err = FarRecognize(hFAR, (const FAR_IMAGE *)&img, &farface, &opt, &(fattr->attr));
-				// CMR_LOGI("FarRecognize: err=%d, smile=%d", err, fattr->attr.smile);
-			}
-		}
-	}
+            /* set option: only do smile detection */
+            opt.smileOn = 1;
+            opt.eyeOn = 0;
+            opt.infantOn = 0;
+            opt.genderOn = 0;
 
-	new_attr_array.count = face_count;
-	new_attr_array.frame_idx = i_curr_frame_idx;
-	memcpy(io_faceattr_arr, &new_attr_array, sizeof(struct class_faceattr_array));
+            /* Set the eye locations */
+            for (i = 0; i < 7; i++) {
+                farface.landmarks[i].x = fattr->shape.data[i * 2];
+                farface.landmarks[i].y = fattr->shape.data[i * 2 + 1];
+            }
+
+            {
+                int err = FarRecognize(hFAR, (const FAR_IMAGE *)&img, &farface,
+                                       &opt, &(fattr->attr));
+                // CMR_LOGI("FarRecognize: err=%d, smile=%d", err,
+                // fattr->attr.smile);
+            }
+        }
+    }
+
+    new_attr_array.count = face_count;
+    new_attr_array.frame_idx = i_curr_frame_idx;
+    memcpy(io_faceattr_arr, &new_attr_array,
+           sizeof(struct class_faceattr_array));
 }
 
-
 static cmr_int fd_get_face_overlap(const struct face_finder_data *i_face1,
-                                   const struct face_finder_data *i_face2)
-{
-	cmr_int percent = 0;
+                                   const struct face_finder_data *i_face2) {
+    cmr_int percent = 0;
 
-	/* get the overlapped region */
-	cmr_int sx = MAX(i_face1->sx, i_face2->sx);
-	cmr_int ex = MIN(i_face1->ex, i_face2->ex);
-	cmr_int sy = MAX(i_face1->sy, i_face2->sy);
-	cmr_int ey = MIN(i_face1->ey, i_face2->ey);
+    /* get the overlapped region */
+    cmr_int sx = MAX(i_face1->sx, i_face2->sx);
+    cmr_int ex = MIN(i_face1->ex, i_face2->ex);
+    cmr_int sy = MAX(i_face1->sy, i_face2->sy);
+    cmr_int ey = MIN(i_face1->ey, i_face2->ey);
 
-	if (ex >= sx && ey >= sy) {
-		cmr_int overlap_area = (ex - sx + 1) * (ey - sy + 1);
-		cmr_int area1 = (i_face1->ex - i_face1->sx + 1) * (i_face1->ey - i_face1->sy + 1);
-		cmr_int area2 = (i_face2->ex - i_face2->sx + 1) * (i_face2->ey - i_face2->sy + 1);
-		percent = (100 * overlap_area *2) / (area1 + area2);
-	}
+    if (ex >= sx && ey >= sy) {
+        cmr_int overlap_area = (ex - sx + 1) * (ey - sy + 1);
+        cmr_int area1 =
+            (i_face1->ex - i_face1->sx + 1) * (i_face1->ey - i_face1->sy + 1);
+        cmr_int area2 =
+            (i_face2->ex - i_face2->sx + 1) * (i_face2->ey - i_face2->sy + 1);
+        percent = (100 * overlap_area * 2) / (area1 + area2);
+    }
 
-	return percent;
+    return percent;
 }
 
+static void
+fd_smooth_face_rect(const struct img_face_area *i_face_area_prev,
+                    const struct class_faceattr_array *i_faceattr_arr,
+                    struct face_finder_data *io_curr_face) {
+    cmr_int overlap_thr = 0;
+    cmr_uint trust_curr_face = 0;
+    cmr_uint prevIdx = 0;
 
-static void fd_smooth_face_rect(const struct img_face_area *i_face_area_prev,
-                                struct face_finder_data *io_curr_face)
-{
-	const cmr_int overlap_thr = 73; // For reducing face flickering: 85 --> 73. The side effect is: FD is slower to respond face location changes
-	cmr_uint prevIdx = 0;
+    // Try to correct the face rectangle by the face shape which is often more
+    // accurate
+    if (i_faceattr_arr != NULL) {
+        // find the face shape with the same face ID
+        const cmr_int shape_score_thr = 200;
+        const struct class_faceattr *fattr = NULL;
+        cmr_int i = 0;
+        for (i = 0; i < i_faceattr_arr->count; i++) {
+            if (i_faceattr_arr->face[i].face_id == io_curr_face->face_id) {
+                fattr = &(i_faceattr_arr->face[i]);
+                break;
+            }
+        } 
+        
+        // Calculate the new face rectangle according to the face shape
+        if (fattr != NULL && fattr->shape.score >= shape_score_thr) {
+            const int *sdata = (const int *)(fattr->shape.data);
+            cmr_int eye_cx = (sdata[0] + sdata[2] + sdata[4] + sdata[6]) / 4;
+            cmr_int eye_cy = (sdata[1] + sdata[3] + sdata[5] + sdata[7]) / 4;
+            cmr_int mouth_cx = (sdata[10] + sdata[12]) / 2;
+            cmr_int mouth_cy = (sdata[11] + sdata[13]) / 2;
+            cmr_int cx = (eye_cx + mouth_cx) / 2;
+            cmr_int cy = (eye_cy + mouth_cy) / 2;
+            cmr_int curr_cx = (io_curr_face->sx + io_curr_face->ex) / 2;
+            cmr_int curr_cy = (io_curr_face->sy + io_curr_face->ey) / 2;
+            cmr_int x_shift = cx - curr_cx;
+            cmr_int y_shift = cy - curr_cy;
+            cmr_int max_shift = (io_curr_face->ex - io_curr_face->sx) / 4;
 
-	for (prevIdx = 0; prevIdx < i_face_area_prev->face_count; prevIdx++) {
-		const struct face_finder_data *prev_face = &(i_face_area_prev->range[prevIdx]);
-		{
-			cmr_int overlap_percent = fd_get_face_overlap(prev_face, io_curr_face);
-			if (overlap_percent >= overlap_thr) {
-				io_curr_face->sx = prev_face->sx;
-				io_curr_face->sy = prev_face->sy;
-				io_curr_face->srx = prev_face->srx;
-				io_curr_face->sry = prev_face->sry;
-				io_curr_face->elx = prev_face->elx;
-				io_curr_face->ely = prev_face->ely;
-				io_curr_face->ex = prev_face->ex;
-				io_curr_face->ey = prev_face->ey;
-				break;
-			}
-		}
-	}
+            // If the shift calculted by face shape is not too large,
+            // we're very sure the face shape is correct.
+            if ((ABS(x_shift) + ABS(y_shift)) < max_shift) {
+                // only correct the face center; size is not changed.
+                io_curr_face->sx += x_shift;
+                io_curr_face->sy += y_shift;
+                io_curr_face->srx += x_shift;
+                io_curr_face->sry += y_shift;
+                io_curr_face->elx += x_shift;
+                io_curr_face->ely += y_shift;
+                io_curr_face->ex += x_shift;
+                io_curr_face->ey += y_shift;
+
+                trust_curr_face = 1;
+            }
+        }
+    }
+    
+    // Try to keep the face rectangle to be the same with the previous 
+    // frame (for stable looks)
+    overlap_thr = trust_curr_face ? 90 : 80;
+    for (prevIdx = 0; prevIdx < i_face_area_prev->face_count; prevIdx++) {
+        const struct face_finder_data *prev_face =
+            &(i_face_area_prev->range[prevIdx]);
+        cmr_int overlap_percent = fd_get_face_overlap(prev_face, io_curr_face);
+
+        if (overlap_percent >= overlap_thr) {
+            io_curr_face->sx = prev_face->sx;
+            io_curr_face->sy = prev_face->sy;
+            io_curr_face->srx = prev_face->srx;
+            io_curr_face->sry = prev_face->sry;
+            io_curr_face->elx = prev_face->elx;
+            io_curr_face->ely = prev_face->ely;
+            io_curr_face->ex = prev_face->ex;
+            io_curr_face->ey = prev_face->ey;
+            break;
+        }
+    }
 }
 
 static void fd_get_fd_results(FD_DETECTOR_HANDLE hDT,
                               const struct class_faceattr_array *i_faceattr_arr,
-															const struct img_face_area *i_face_area_prev,
+                              const struct img_face_area *i_face_area_prev,
                               struct img_face_area *o_face_area,
-                              struct img_size image_size)
-{
-	cmr_int               face_num = 0;
-	FD_FACEINFO           info;
-	cmr_int               face_idx = 0;
-	cmr_int               ret = FD_OK;
-	cmr_int sx = 0, ex = 0, sy = 0, ey = 0;
-	cmr_int valid_count = 0;
-	struct face_finder_data *face_ptr = NULL;
+                              struct img_size image_size,
+                              const cmr_uint i_curr_frame_idx) {
+    cmr_int face_num = 0;
+    FD_FACEINFO info;
+    cmr_int face_idx = 0;
+    cmr_int ret = FD_OK;
+    cmr_int sx = 0, ex = 0, sy = 0, ey = 0;
+    cmr_int valid_count = 0;
+    struct face_finder_data *face_ptr = NULL;
+    const struct class_faceattr_array *curr_faceattr =
+        (i_curr_frame_idx == i_faceattr_arr->frame_idx) ? i_faceattr_arr : NULL;
 
-	face_num = FdGetFaceCount(hDT);
-	for (face_idx = 0; face_idx < face_num; face_idx++) {
-		/* Gets the detection result for each face */
-		ret = FdGetFaceInfo(hDT, face_idx, &info);
-		if (ret != FD_OK) {
-			CMR_LOGW("FdGetFaceInfo(%d) Error : %d", face_idx, ret);
-			continue;
-		}
+    face_num = FdGetFaceCount(hDT);
+    for (face_idx = 0; face_idx < face_num; face_idx++) {
+        /* Gets the detection result for each face */
+        ret = FdGetFaceInfo(hDT, face_idx, &info);
+        if (ret != FD_OK) {
+            CMR_LOGW("FdGetFaceInfo(%ld) Error : %ld", face_idx, ret);
+            continue;
+        }
 
-		sx = info.x;
-		sy = info.y;
-		ex = info.x + info.width - 1;
-		ey = info.y + info.height - 1;
+        sx = info.x;
+        sy = info.y;
+        ex = info.x + info.width - 1;
+        ey = info.y + info.height - 1;
 
-		/* enlarge face size a little.
-		!TODO: maybe it is also necessary to adjust the face center
-		*/
-		{
-			cmr_int delta = info.width / 20;
-			sx -= delta;
-			sy -= delta;
-			ex += delta;
-			ey += delta;
-		}
+        /* enlarge face size a little.
+        !TODO: maybe it is also necessary to adjust the face center
+        */
+        {
+            cmr_int delta = info.width / 20;
+            sx -= delta;
+            sy -= delta;
+            ex += delta;
+            ey += delta;
+        }
 
-		/* Ensure the face coordinates are in image region */
-		if (sx < 0) sx = 0;
-		if (sy < 0) sy = 0;
-		if (ex >= (cmr_int)image_size.width)  ex = image_size.width - 1;
-		if (ey >= (cmr_int)image_size.height) ey = image_size.height - 1;
+        face_ptr = &(o_face_area->range[valid_count]);
+        valid_count++;
 
-		face_ptr = &(o_face_area->range[valid_count]);
-		valid_count++;
+        face_ptr->sx = sx;
+        face_ptr->sy = sy;
+        face_ptr->srx = ex;
+        face_ptr->sry = sy;
+        face_ptr->elx = sx;
+        face_ptr->ely = ey;
+        face_ptr->ex = ex;
+        face_ptr->ey = ey;
+        face_ptr->face_id = info.id;
+        face_ptr->pose = info.yawAngle;
+        face_ptr->angle = info.rollAngle;
+        face_ptr->score =
+            info.score / 10; /* Make it in [0,100]. HAL1.0 requires so */
+        face_ptr->smile_level = 1;
+        face_ptr->blink_level = 0;
+        face_ptr->brightness = 128;
 
-		face_ptr->sx = sx;
-		face_ptr->sy = sy;
-		face_ptr->srx = ex;
-		face_ptr->sry = sy;
-		face_ptr->elx = sx;
-		face_ptr->ely = ey;
-		face_ptr->ex = ex;
-		face_ptr->ey = ey;
-		face_ptr->face_id = info.id;
-		face_ptr->pose = info.yawAngle;
-		face_ptr->angle = info.rollAngle;
-		face_ptr->score = info.score / 10; /* Make it in [0,100]. HAL1.0 requires so */
-		face_ptr->smile_level = 1;
-		face_ptr->blink_level = 0;
-		face_ptr->brightness = 128;
+        fd_smooth_face_rect(i_face_area_prev, curr_faceattr, face_ptr);
+		
+        /* Ensure the face coordinates are in image region */
+        if (face_ptr->sx < 0)
+            face_ptr->sx = face_ptr->elx = 0;
+        if (face_ptr->sy < 0)
+            face_ptr->sy = face_ptr->sry = 0;
+        if (face_ptr->ex >= (cmr_int)image_size.width)
+            face_ptr->ex = face_ptr->srx = image_size.width - 1;
+        if (face_ptr->ey >= (cmr_int)image_size.height)
+            face_ptr->ey = face_ptr->ely = image_size.height - 1;		
 
-		fd_smooth_face_rect(i_face_area_prev, face_ptr);
+        /* set smile detection result */
+        {
+            const cmr_int app_smile_thr = 30;  // smile threshold in APP
+            const cmr_int algo_smile_thr = 10; // smile threshold by algorithm;
+                                               // it is a tuning parameter, must
+                                               // be in [1, 50]
+            cmr_int i = 0;
+            for (i = 0; i < i_faceattr_arr->count; i++) {
+                const struct class_faceattr *fattr = &(i_faceattr_arr->face[i]);
+                if (fattr->face_id == info.id) {
+                    /* Note: The original smile score is in [-100, 100].
+                       But the Camera APP needs a score in [0, 100], and also
+                       the definitions for smile degree are different
+                       with the algorithm. So, we need to adjust the smile score
+                       to fit the APP.
+                    */
+                    cmr_int smile_score = MAX(0, fattr->attr.smile);
+                    if (smile_score >= algo_smile_thr) {
+                        /* norm_score is in [0, 70] */
+                        cmr_int norm_score = ((smile_score - algo_smile_thr) *
+                                              (100 - app_smile_thr)) /
+                                             (100 - algo_smile_thr);
+                        /* scale the smile score to be in [30, 100] */
+                        smile_score = norm_score + app_smile_thr;
+                    } else {
+                        /* scale the smile score to be in [0, 30) */
+                        smile_score =
+                            (smile_score * app_smile_thr) / algo_smile_thr;
+                    }
 
-		/* set smile detection result */
-		{
-			const cmr_int app_smile_thr = 30;  // smile threshold in APP
-			const cmr_int algo_smile_thr = 10; // smile threshold by algorithm; it is a tuning parameter, must be in [1, 50]
-			cmr_int i = 0;
-			for (i = 0; i < i_faceattr_arr->count; i++) {
-				const struct class_faceattr *fattr = &(i_faceattr_arr->face[i]);
-				if (fattr->face_id == info.id) {
-					/* Note: The original smile score is in [-100, 100].
-					   But the Camera APP needs a score in [0, 100], and also the definitions for smile degree are different
-					   with the algorithm. So, we need to adjust the smile score to fit the APP.
-					*/
-					cmr_int smile_score = MAX(0, fattr->attr.smile);
-					if (smile_score >= algo_smile_thr)
-					{
-						/* norm_score is in [0, 70] */
-						cmr_int norm_score = ((smile_score - algo_smile_thr) * (100 - app_smile_thr)) / (100 - algo_smile_thr);
-						/* scale the smile score to be in [30, 100] */
-						smile_score = norm_score + app_smile_thr;
-					}
-					else
-					{
-						/* scale the smile score to be in [0, 30) */
-						smile_score = (smile_score * app_smile_thr) / algo_smile_thr;
-					}
+                    face_ptr->smile_level = MAX(1, smile_score);
+                    face_ptr->blink_level = MAX(0, fattr->attr.eyeClose);
+                    break;
+                }
+            }
+        }
+    }
 
-					face_ptr->smile_level = MAX(1, smile_score);
-					face_ptr->blink_level = MAX(0, fattr->attr.eyeClose);
-					break;
-				}
-			}
-		}
-	}
-
-	o_face_area->face_count = valid_count;
+    o_face_area->face_count = valid_count;
 }
 
 static cmr_int fd_create_detector(FD_DETECTOR_HANDLE *hDT,
-                                  const struct img_size *fd_img_size)
-{
-	FD_OPTION opt;
+                                  const struct img_size *fd_img_size) {
+    FD_OPTION opt;
 
-	FdInitOption(&opt);
-	CMR_LOGI("SPRD FD version: %s .",FdGetVersion());
-	opt.workMode        = FD_WORKMODE_MOVIE;
-	opt.maxFaceNum      = FACE_DETECT_NUM;
-	opt.minFaceSize     = MIN(fd_img_size->width, fd_img_size->height) / 10;
-	opt.directions      = FD_DIRECTION_ALL;
-	opt.angleFrontal    = FD_ANGLE_RANGE_90;
-	opt.angleHalfProfile= FD_ANGLE_RANGE_30;
-	opt.angleFullProfile= FD_ANGLE_RANGE_30;//FD_ANGLE_NONE; for Bug 636739
-	opt.detectDensity   = 5;
-	opt.scoreThreshold  = 0;
-	opt.initFrames      = 2;
-	opt.detectFrames    = 1;
-	opt.detectInterval  = 3;
-	opt.trackDensity    = 5;
-	opt.lostRetryCount  = 1;
-	opt.lostHoldCount   = 1;
-	opt.holdPositionRate = 10;
-	opt.holdSizeRate    = 6;
-	opt.swapFaceRate    = 200;
-	opt.guessFaceDirection = 1;
+    FdInitOption(&opt);
+    CMR_LOGI("SPRD FD version: %s .", FdGetVersion());
+    opt.workMode = FD_WORKMODE_MOVIE;
+    opt.maxFaceNum = FACE_DETECT_NUM;
+    opt.minFaceSize = MIN(fd_img_size->width, fd_img_size->height) / 12;
+    opt.directions = FD_DIRECTION_ALL;
+    opt.angleFrontal = FD_ANGLE_RANGE_90;
+    opt.angleHalfProfile = FD_ANGLE_RANGE_30;
+    opt.angleFullProfile = FD_ANGLE_RANGE_30; // FD_ANGLE_NONE; for Bug 636739;
+    opt.detectDensity = 5;
+    opt.scoreThreshold = 0;
+    opt.detectInterval = 6;
+    opt.trackDensity = 5;
+    opt.lostRetryCount = 1;
+    opt.lostHoldCount = 1;
+    opt.holdPositionRate = 5;
+    opt.holdSizeRate = 4;
+    opt.swapFaceRate = 200;
+    opt.guessFaceDirection = 1;
 
-  /* For tuning FD parameter: read parameter from file */
-	/*
-	{
-		FILE *fp = fopen("/data/sprd_fd_param.txt", "rt");
-		if (!fp) {
-			CMR_LOGI("failed to open /data/sprd_fd_param.txt");
-		} else {
-			CMR_LOGI("read /data/sprd_fd_param.txt");
-		}
+    /* For tuning FD parameter: read parameter from file */
+    /*
+    {
+            FILE *fp = fopen("/data/sprd_fd_param.txt", "rt");
+            if (!fp) {
+                    CMR_LOGI("failed to open /data/sprd_fd_param.txt");
+            } else {
+                    CMR_LOGI("read /data/sprd_fd_param.txt");
+            }
 
-		if (fp) {
-			unsigned int v[17];
-			int i = 0;
-			for (i = 0; i < 17; i++){
-				fscanf(fp, "%d ", &(v[i]));
-				CMR_LOGI("sprd_fd_param: v[%d]=%d", i, v[i]);
-			}
-			fclose(fp);
+            if (fp) {
+                    unsigned int v[17];
+                    int i = 0;
+                    for (i = 0; i < 17; i++){
+                            fscanf(fp, "%d ", &(v[i]));
+                            CMR_LOGI("sprd_fd_param: v[%d]=%d", i, v[i]);
+                    }
+                    fclose(fp);
 
-			opt.minFaceSize     = MIN(fd_img_size->width, fd_img_size->height) / v[0];
-			opt.directions      = v[1];
-			opt.angleFrontal    = v[2];
-			opt.angleHalfProfile= v[3];
-			opt.angleFullProfile= v[4];
-			opt.detectDensity   = v[5];
-			opt.scoreThreshold  = v[6];
-			opt.initFrames      = v[7];
-			opt.detectFrames    = v[8];
-			opt.detectInterval  = v[9];
-			opt.trackDensity    = v[10];
-			opt.lostRetryCount  = v[11];
-			opt.lostHoldCount   = v[12];
-			opt.holdPositionRate = v[13];
-			opt.holdSizeRate    = v[14];
-			opt.swapFaceRate    = v[15];
-			opt.guessFaceDirection = v[16];
-		}
-	}
-	*/
-	return FdCreateDetector(hDT, &opt);
+                    opt.minFaceSize     = MIN(fd_img_size->width,
+    fd_img_size->height) / v[0];
+                    opt.directions      = v[1];
+                    opt.angleFrontal    = v[2];
+                    opt.angleHalfProfile= v[3];
+                    opt.angleFullProfile= v[4];
+                    opt.detectDensity   = v[5];
+                    opt.scoreThreshold  = v[6];
+                    opt.initFrames      = v[7];
+                    opt.detectFrames    = v[8];
+                    opt.detectInterval  = v[9];
+                    opt.trackDensity    = v[10];
+                    opt.lostRetryCount  = v[11];
+                    opt.lostHoldCount   = v[12];
+                    opt.holdPositionRate = v[13];
+                    opt.holdSizeRate    = v[14];
+                    opt.swapFaceRate    = v[15];
+                    opt.guessFaceDirection = v[16];
+            }
+    }
+    */
+    return FdCreateDetector(hDT, &opt);
 }
 
-static cmr_int fd_thread_proc(struct cmr_msg *message, void *private_data)
-{
-	cmr_int                   ret           = CMR_CAMERA_SUCCESS;
-	struct class_fd           *class_handle = (struct class_fd *)private_data;
-	cmr_int                   evt           = 0;
-	struct fd_start_parameter *start_param = NULL;
-	struct img_size *fd_img_size = NULL;
-	FD_IMAGE fd_img = {0};
-	clock_t start_time, end_time;
-	int duration;
+static cmr_int fd_thread_proc(struct cmr_msg *message, void *private_data) {
+    cmr_int ret = CMR_CAMERA_SUCCESS;
+    struct class_fd *class_handle = (struct class_fd *)private_data;
+    cmr_int evt = 0;
+    struct fd_start_parameter *start_param = NULL;
+    struct img_size *fd_img_size = NULL;
+    FD_IMAGE fd_img;
+    clock_t start_time, end_time;
+    int duration;
+    cmr_bzero(&fd_img, sizeof(fd_img));
+    if (!message || !class_handle) {
+        CMR_LOGE("parameter is fail");
+        return CMR_CAMERA_INVALID_PARAM;
+    }
 
-	if (!message || !class_handle) {
-		CMR_LOGE("parameter is fail");
-		return CMR_CAMERA_INVALID_PARAM;
-	}
+    evt = (cmr_u32)(message->msg_type & CMR__EVT_FD_MASK_BITS);
 
-	evt = (cmr_u32)(message->msg_type & CMR__EVT_FD_MASK_BITS);
+    switch (evt) {
+    case CMR_EVT_FD_INIT:
+        /* Create face alignment and face attribute recognition handle */
+        if (FA_OK != FaCreateAlignHandle(&(class_handle->hFaceAlign))) {
+            CMR_LOGE("FaCreateAlignHandle() Error");
+            break;
+        }
+        if (FAR_OK != FarCreateRecognizerHandle(&(class_handle->hFAR))) {
+            CMR_LOGE("FarCreateRecognizerHandle() Error");
+            break;
+        }
 
-	switch (evt) {
-	case CMR_EVT_FD_INIT:
-		/* Create face alignment and face attribute recognition handle */
-		if (FA_OK != FaCreateAlignHandle(&(class_handle->hFaceAlign))) {
-			CMR_LOGE("FaCreateAlignHandle() Error");
-			break;
-		}
-		if (FAR_OK != FarCreateRecognizerHandle(&(class_handle->hFAR))) {
-			CMR_LOGE("FarCreateRecognizerHandle() Error");
-			break;
-		}
+        /* Creates Face Detection handle */
+        fd_img_size = (struct img_size *)message->data;
+        ret = fd_create_detector(&(class_handle->hDT), fd_img_size);
+        if (ret != FD_OK) {
+            CMR_LOGE("fd_create_detector() Error");
+            break;
+        }
 
-		/* Creates Face Detection handle */
-		fd_img_size = (struct img_size *)message->data;
-		ret = fd_create_detector(&(class_handle->hDT), fd_img_size);
-		if (ret != FD_OK) {
-			CMR_LOGE("fd_create_detector() Error");
-			break;
-		}
+        break;
 
-		break;
+    case CMR_EVT_FD_START:
+        start_param = (struct fd_start_parameter *)message->data;
 
-	case CMR_EVT_FD_START:
-		start_param = (struct fd_start_parameter *)message->data;
+        if (NULL == start_param) {
+            CMR_LOGE("parameter fail");
+            break;
+        }
 
-		if (NULL == start_param) {
-			CMR_LOGE("parameter fail");
-			break;
-		}
+        fd_set_busy(class_handle, 1);
 
-		fd_set_busy(class_handle, 1);
+        /* Executes Face Detection */
+        fd_img.data = (unsigned char *)class_handle->alloc_addr;
+        fd_img.width = class_handle->fd_img_size.width;
+        fd_img.height = class_handle->fd_img_size.height;
+        fd_img.step = fd_img.width;
 
-		/* Executes Face Detection */
-		fd_img.data = (unsigned char *)class_handle->alloc_addr;
-		fd_img.width = class_handle->fd_img_size.width;
-		fd_img.height = class_handle->fd_img_size.height;
-		fd_img.step = fd_img.width;
+        start_time = clock();
+        ret = FdDetectFace(class_handle->hDT, &fd_img);
+        end_time = clock();
 
-		start_time = clock();
-		ret = FdDetectFace(class_handle->hDT, &fd_img);
-		end_time = clock();
+        if (ret != FD_OK) {
+            CMR_LOGE("FdDetectFace() Error : %ld", ret);
+            fd_set_busy(class_handle, 0);
+            break;
+        }
 
-		if (ret != FD_OK) {
-			CMR_LOGE("FdDetectFace() Error : %ld", ret);
-			fd_set_busy(class_handle, 0);
-			break;
-		}
+        /* recognize face attribute (smile detection) */
+        fd_recognize_face_attribute(
+            class_handle->hDT, class_handle->hFaceAlign, class_handle->hFAR,
+            &(class_handle->faceattr_arr), (cmr_u8 *)class_handle->alloc_addr,
+            class_handle->fd_img_size, class_handle->curr_frame_idx);
 
-		/* recognize face attribute (smile detection) */
-		fd_recognize_face_attribute(class_handle->hDT,
-                 class_handle->hFaceAlign,
-                 class_handle->hFAR,
-                 &(class_handle->faceattr_arr),
-                 (cmr_u8*)class_handle->alloc_addr,
-                 class_handle->fd_img_size,
-                 class_handle->curr_frame_idx);
+        class_handle->is_get_result = 1;
+        /* extract face detection results */
+        fd_get_fd_results(class_handle->hDT, &(class_handle->faceattr_arr),
+                          &(class_handle->face_area_prev),
+                          &(class_handle->frame_out.face_area),
+                          class_handle->fd_img_size,
+                          class_handle->curr_frame_idx);
+        /* save a copy for next frame */
+        memcpy(&(class_handle->face_area_prev),
+               &(class_handle->frame_out.face_area),
+               sizeof(struct img_face_area));
 
-		class_handle->is_get_result = 1;
-		/* extract face detection results */
-		fd_get_fd_results(class_handle->hDT, &(class_handle->faceattr_arr), &(class_handle->face_area_prev),
-		                  &(class_handle->frame_out.face_area), class_handle->fd_img_size);
-		/* save a copy for next frame */
-		memcpy(&(class_handle->face_area_prev), &(class_handle->frame_out.face_area), sizeof(struct img_face_area));
+        class_handle->frame_out.dst_frame.size.width =
+            class_handle->frame_in.src_frame.size.width;
+        class_handle->frame_out.dst_frame.size.height =
+            class_handle->frame_in.src_frame.size.height;
 
-		class_handle->frame_out.dst_frame.size.width = class_handle->frame_in.src_frame.size.width;
-		class_handle->frame_out.dst_frame.size.height = class_handle->frame_in.src_frame.size.height;
+        duration = (end_time - start_time) * 1000 / CLOCKS_PER_SEC;
+        CMR_LOGI("%dx%d, face_num=%ld, time=%d ms",
+                 class_handle->frame_in.src_frame.size.width,
+                 class_handle->frame_in.src_frame.size.height,
+                 class_handle->frame_out.face_area.face_count, duration);
+        /*callback*/
+        if (class_handle->frame_cb) {
+            class_handle->frame_out.private_data = start_param->private_data;
+            class_handle->frame_out.caller_handle = start_param->caller_handle;
+            class_handle->frame_cb(IPM_TYPE_FD, &class_handle->frame_out);
+        }
 
-		duration = (end_time - start_time) * 1000 / CLOCKS_PER_SEC;
-		CMR_LOGI("SPRD_FD: frame(%dx%d), face_num=%d, time=%d ms", class_handle->frame_in.src_frame.size.width,
-				class_handle->frame_in.src_frame.size.height, class_handle->frame_out.face_area.face_count, duration);
-		/*callback*/
-		if (class_handle->frame_cb) {
-			class_handle->frame_out.private_data  = start_param->private_data;
-			class_handle->frame_out.caller_handle = start_param->caller_handle;
-			class_handle->frame_cb(IPM_TYPE_FD, &class_handle->frame_out);
-		}
+        fd_set_busy(class_handle, 0);
+        class_handle->is_get_result = 0;
+        break;
 
-		fd_set_busy(class_handle, 0);
-		class_handle->is_get_result = 0;
-		break;
+    case CMR_EVT_FD_EXIT:
+        /* Deletes Face Detection handle */
+        FaDeleteAlignHandle(&(class_handle->hFaceAlign));
+        FarDeleteRecognizerHandle(&(class_handle->hFAR));
+        FdDeleteDetector(&(class_handle->hDT));
+        break;
 
-	case CMR_EVT_FD_EXIT:
-		/* Deletes Face Detection handle */
-		FaDeleteAlignHandle(&(class_handle->hFaceAlign));
-		FarDeleteRecognizerHandle(&(class_handle->hFAR));
-		FdDeleteDetector(&(class_handle->hDT));
-		break;
+    default:
+        break;
+    }
 
-	default:
-		break;
-	}
-
-	return ret;
+    return ret;
 }
 
 #endif
Index: vendor/sprd/modules/libcamera/sensor/sensor_cfg.c
===================================================================
--- vendor/sprd/modules/libcamera/sensor/sensor_cfg.c	(revision 182304)
+++ vendor/sprd/modules/libcamera/sensor/sensor_cfg.c	(revision 182305)
@@ -88,7 +88,6 @@
 extern SENSOR_INFO_T g_ov8825_mipi_raw_info;
 extern SENSOR_INFO_T g_ov8856_mipi_raw_info;
 extern SENSOR_INFO_T g_ov5675_b_55un_mipi_raw_info;
-extern SENSOR_INFO_T g_sp2509_mipi_raw_info;
 extern SENSOR_INFO_T g_ov5675f_mipi_raw_info;
 extern SENSOR_INFO_T g_hi544_mipi_raw_info;
 extern SENSOR_INFO_T g_GC2155_MIPI_yuv_info;
Index: vendor/sprd/modules/libcamera/sensor/Android.mk
===================================================================
--- vendor/sprd/modules/libcamera/sensor/Android.mk	(revision 182304)
+++ vendor/sprd/modules/libcamera/sensor/Android.mk	(revision 182305)
@@ -83,7 +83,6 @@
 		ov5675/sensor_ov5675_mipi_raw.c \
 		ov5675_for_HP/sensor_ov5675f_mipi_raw.c \
                 ov5675_b_55un/sensor_ov5675_b_55un_mipi_raw.c \
-                sp2509_ls50/sensor_sp2509_mipi_raw.c \
 		c2590/sensor_c2590_mipi_raw.c \
                 gc2155/sensor_gc2155_mipi.c \
                 ov8825/sensor_ov8825_mipi_raw.c \
Index: vendor/sprd/modules/libcamera/isp2.0/ae/ae1/ae_sprd_ctrl.c
===================================================================
--- vendor/sprd/modules/libcamera/isp2.0/ae/ae1/ae_sprd_ctrl.c	(revision 182304)
+++ vendor/sprd/modules/libcamera/isp2.0/ae/ae1/ae_sprd_ctrl.c	(revision 182305)
@@ -385,7 +385,7 @@
 	if (debug_print_enable()) {
 		AE_LOGV("cam_id %d, alg id: %\n", cxt->camera_id, cxt->cur_status.alg_id);
 
-		AE_LOGV("frame id %d\r\n", , cxt->cur_status.frame_id);
+		AE_LOGV("frame id %d\r\n", cxt->cur_status.frame_id);
 
 		AE_LOGV("start idx %d   linetime %d\r\n", cxt->cur_status.start_index, cxt->cur_status.line_time);
 
Index: vendor/sprd/modules/libcamera/isp2.0/ae/ae1/inc/ae_com.h
===================================================================
--- vendor/sprd/modules/libcamera/isp2.0/ae/ae1/inc/ae_com.h	(revision 182304)
+++ vendor/sprd/modules/libcamera/isp2.0/ae/ae1/inc/ae_com.h	(revision 182305)
@@ -98,6 +98,7 @@
 	int8_t scene_mode;/* pano sports night */
 	int16_t intelligent_module;/* pano sports night */
 	int8_t af_info;				/*AF trigger info*/
+        uint32_t iso_special_mode;/*0: normal; 1: restrict the max gain*/
 	int8_t reserve_case;
 	uint8_t * reserve_info;/* reserve for future */
 	int16_t reserve_len;/*len for reserve */
