Index: packages/providers/CalendarProvider/AndroidManifest.xml
===================================================================
--- packages/providers/CalendarProvider/AndroidManifest.xml	(revision 168086)
+++ packages/providers/CalendarProvider/AndroidManifest.xml	(revision 168087)
@@ -1,122 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2008 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-        package="com.android.providers.calendar"
-        android:sharedUserId="android.uid.calendar">
-
-    <uses-permission android:name="android.permission.READ_CALENDAR" />
-    <uses-permission android:name="android.permission.WRITE_CALENDAR" />
-    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
-    <uses-permission android:name="com.google.android.googleapps.permission.GOOGLE_AUTH" />
-    <uses-permission android:name="com.google.android.googleapps.permission.GOOGLE_AUTH.cl" />
-    <uses-permission android:name="android.permission.GET_ACCOUNTS" />
-    <uses-permission android:name="android.permission.GET_ACCOUNTS_PRIVILEGED" />
-    <uses-permission android:name="android.permission.USE_CREDENTIALS" />
-    <uses-permission android:name="android.permission.MANAGE_ACCOUNTS" />
-    <uses-permission android:name="android.permission.READ_SYNC_STATS" />
-    <uses-permission android:name="android.permission.READ_SYNC_SETTINGS" />
-    <uses-permission android:name="android.permission.WRITE_SYNC_SETTINGS" />
-    <uses-permission android:name="android.permission.INTERNET" />
-    <uses-permission android:name="android.permission.SUBSCRIBED_FEEDS_READ" />
-    <uses-permission android:name="android.permission.SUBSCRIBED_FEEDS_WRITE" />
-    <uses-permission android:name="android.permission.WAKE_LOCK" />
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
-    <uses-permission android:name="android.permission.UPDATE_APP_OPS_STATS" />
-
-    <application android:label="@string/calendar_storage"
-                 android:allowBackup="false"
-                 android:icon="@drawable/app_icon"
-                 android:usesCleartextTraffic="false">
-        <!-- TODO: Remove dependency of application on the test runner
-             (android.test) library. -->
-        <uses-library android:name="android.test.runner" />
-
-        <provider android:name="CalendarProvider2" android:authorities="com.android.calendar"
-                android:label="@string/provider_label"
-                android:multiprocess="false"
-                android:exported="true"
-                android:readPermission="android.permission.READ_CALENDAR"
-                android:writePermission="android.permission.WRITE_CALENDAR">
-                <!-- SPRD:bug474826  calendar crash when share events -->
-                <grant-uri-permission android:pathPrefix="/events/as_multi_vcal/" />
-                </provider>
-
-        <!-- This is used to keep the provider alive long enough to send update
-             intent broadcasts. -->
-        <service android:name=".EmptyService" />
-        <!-- This is used to keep the provider alive long enough to clean up scheduled
-             alarms after boot. -->
-        <service android:name=".CalendarReceiver$RemoveScheduledAlarmsEmptyService" />
-
-        <activity android:name="CalendarContentProviderTests" android:label="Calendar Content Provider"
-                android:exported="false">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.UNIT_TEST" />
-            </intent-filter>
-        </activity>
-        <receiver android:name="CalendarReceiver">
-            <intent-filter>
-                <action android:name="android.intent.action.BOOT_COMPLETED" />
-            </intent-filter>
-        </receiver>
-
-        <activity android:name="CalendarDebug" android:label="@string/calendar_info">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.DEFAULT" />
-            </intent-filter>
-        </activity>
-        <activity android:name="CalendarDebugActivity" android:label="@string/calendar_info"
-                android:theme="@android:style/Theme.Holo.Dialog">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.DEFAULT" />
-            </intent-filter>
-        </activity>
-        <receiver android:name="CalendarDebugReceiver">
-            <intent-filter>
-                 <action android:name="android.provider.Telephony.SECRET_CODE" />
-                 <data android:scheme="android_secret_code" android:host="225" />
-            </intent-filter>
-       </receiver>
-
-       <!-- Handles database upgrades after OTAs, then disables itself -->
-       <receiver android:name="CalendarUpgradeReceiver">
-           <!-- This broadcast is sent after the core system has finished
-                booting, before the home app is launched or BOOT_COMPLETED
-                is sent. -->
-           <intent-filter>
-               <action android:name="android.intent.action.PRE_BOOT_COMPLETED"/>
-           </intent-filter>
-       </receiver>
-
-        <receiver android:name="CalendarProviderBroadcastReceiver"
-                  android:exported="false">
-            <intent-filter>
-                <action android:name="com.android.providers.calendar.intent.CalendarProvider2"/>
-                <category android:name="com.android.providers.calendar"/>
-            </intent-filter>
-            <intent-filter>
-                <action android:name="android.intent.action.EVENT_REMINDER"/>
-                <data android:scheme="content" />
-            </intent-filter>
-        </receiver>
-        <service android:name="CalendarProviderIntentService"/>
-
-    </application>
-</manifest>
Index: packages/providers/CalendarProvider/maketests.py
===================================================================
--- packages/providers/CalendarProvider/maketests.py	(revision 168086)
+++ packages/providers/CalendarProvider/maketests.py	(revision 168087)
@@ -1,127 +0,0 @@
-#
-# Usage: Fill in the configuration variables.  It will download the feed
-# for it, parse it, and print out test cases to add to the unit test.
-#
-
-EMAIL = "onoratoj@gmail.com"
-PRIVATE_COOKIE = "432802670aefa458daf036597ec8136b"
-START_DATE = ("2006","01","01")
-END_DATE = ("2009","01","01")
-
-
-
-import sys, urllib, re
-from xml.dom import minidom
-
-def fmt(n):
-    if n < 10:
-        return "0" + str(n)
-    else:
-        return str(n)
-
-def makeDate(d):
-    return d[0] + "-" + d[1] + "-" + d[2]
-
-def makeZDate(d):
-    return d[0] + d[1] + d[2] + "T000000Z"
-
-url = "http://www.google.com/calendar/feeds/onoratoj@gmail.com/private-" \
-        + PRIVATE_COOKIE + "/composite?start-min=" + makeDate(START_DATE) \
-        + "&start-max=" + makeDate(END_DATE)
-
-#data = open("out.xml")
-data = urllib.urlopen(url)
-
-DTSTART_TZID = re.compile("DTSTART;TZID=(.*):(.*)")
-DTSTART = re.compile("DTSTART:(.*)")
-DURATION = re.compile("DURATION:(.*)")
-RRULE = re.compile("RRULE:(.*)")
-TIME = re.compile("(....)-(..)-(..)T(..):(..):(..)....([+-])(..):(..)")
-TIMEZ = re.compile("(....)-(..)-(..)T(..):(..):(..)....Z")
-
-def stripTimezone(str):
-    lines = str.split("\n")
-    drop = False
-    result = []
-    for line in lines:
-        if line == "BEGIN:VTIMEZONE":
-            drop = True
-        if not drop:
-            result.append(line)
-        if line == "END:VTIMEZONE":
-            drop = False
-    return result
-
-def fixInstance(s):
-    m = TIME.match(s[0])
-    if m:
-        if m.group(7) == "+":
-            sign = -1
-        else:
-            sign = 1
-        hour = int(m.group(4)) + (sign * int(m.group(8)))
-        return m.group(1) + m.group(2) + m.group(3) + "T" + fmt(hour) \
-                + m.group(5) + m.group(6) + "Z"
-    m = TIMEZ.match(s[0])
-    if m:
-        return m.group(1) + m.group(2) + m.group(3) + "T" + m.group(4) \
-                + m.group(5) + m.group(6) + "Z"
-    return s[0]
-
-dom = minidom.parse(data)
-root = dom.documentElement
-
-entries = root.getElementsByTagName("entry")
-
-for entry in entries:
-    recurrences = entry.getElementsByTagName("gd:recurrence")
-    dtstart = ""
-    tzid = ""
-    duration = ""
-    rrule = ""
-    if len(recurrences) > 0:
-        recurrence = recurrences[0]
-        s = ""
-        for c in recurrence.childNodes:
-            s = s + c.nodeValue
-        lines = stripTimezone(s)
-        for s in lines:
-            re_dtstart = DTSTART_TZID.match(s)
-            if re_dtstart:
-                dtstart = re_dtstart.group(2)
-                tzid = re_dtstart.group(1)
-            re_dtstart = DTSTART.match(s)
-            if re_dtstart:
-                dtstart = re_dtstart.group(1)
-            re_duration = DURATION.match(s)
-            if re_duration:
-                duration = re_duration.group(1)
-            re_rrule = RRULE.match(s)
-            if re_rrule:
-                rrule = re_rrule.group(1)
-    whens = entry.getElementsByTagName("gd:when")
-    instances = []
-    for w in whens:
-        startTime = w.getAttribute("startTime")
-        endTime = w.getAttribute("endTime")
-        instances.append((startTime,endTime))
-
-    instances = map(fixInstance, instances)
-    instances.sort()
-    if dtstart != "":
-        title = ""
-        for c in entry.getElementsByTagName('title')[0].childNodes:
-            title = title + c.nodeValue
-
-        print "            // " + title
-        print "            test(\"" + dtstart + "\","
-        print "                    \"" + rrule + "\","
-        print "                    \"" + makeZDate(START_DATE) \
-                                    + "\", \"" + makeZDate(END_DATE) + "\","
-        print "                    new String[] {"
-        for i in instances:
-            print "                        \"" + i + "\","
-        print "                    });"
-        print
-
-
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarProviderIntentService.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarProviderIntentService.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarProviderIntentService.java	(revision 168087)
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.providers.calendar;
-
-import android.app.IntentService;
-import android.content.Intent;
-import android.provider.CalendarContract;
-import android.util.Log;
-
-public class CalendarProviderIntentService extends IntentService {
-
-    private static final String TAG = CalendarProvider2.TAG;
-
-    public CalendarProviderIntentService() {
-        super("CalendarProviderIntentService");
-    }
-
-    @Override
-    protected void onHandleIntent(Intent intent) {
-        if (Log.isLoggable(TAG, Log.DEBUG)) {
-            Log.d(TAG, "Received Intent: " + intent);
-        }
-        final CalendarProvider2 provider = CalendarProvider2.getInstance();
-        final String action = intent.getAction();
-        if (CalendarAlarmManager.ACTION_CHECK_NEXT_ALARM.equals(action)
-                || CalendarContract.ACTION_EVENT_REMINDER.equals(action)) {
-            // Schedule the next alarm. Please be noted that for ACTION_EVENT_REMINDER broadcast,
-            // we never remove scheduled alarms.
-            final boolean removeAlarms = intent
-                    .getBooleanExtra(CalendarAlarmManager.KEY_REMOVE_ALARMS, false);
-            provider.getOrCreateCalendarAlarmManager().runScheduleNextAlarm(removeAlarms, provider);
-            // Release the wake lock that was set in the Broadcast Receiver
-            provider.getOrCreateCalendarAlarmManager().releaseScheduleNextAlarmWakeLock();
-        } else if (Log.isLoggable(TAG, Log.DEBUG)) {
-            Log.d(TAG, "Invalid Intent action: " + action);
-        }
-    }
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/QueryParameterUtils.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/QueryParameterUtils.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/QueryParameterUtils.java	(revision 168087)
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.calendar;
-
-import android.net.Uri;
-
-public class QueryParameterUtils {
-
-    public static boolean readBooleanQueryParameter(Uri uri, String name,
-            boolean defaultValue) {
-        final String flag = getQueryParameter(uri, name);
-        return flag == null
-                ? defaultValue
-                : (!"false".equals(flag.toLowerCase()) && !"0".equals(flag.toLowerCase()));
-    }
-
-    // Duplicated from ContactsProvider2.
-    /**
-     * A fast re-implementation of {@link android.net.Uri#getQueryParameter}
-     */
-    public static String getQueryParameter(Uri uri, String parameter) {
-        String query = uri.getEncodedQuery();
-        if (query == null) {
-            return null;
-        }
-
-        int queryLength = query.length();
-        int parameterLength = parameter.length();
-
-        String value;
-        int index = 0;
-        while (true) {
-            index = query.indexOf(parameter, index);
-            if (index == -1) {
-                return null;
-            }
-
-            index += parameterLength;
-
-            if (queryLength == index) {
-                return null;
-            }
-
-            if (query.charAt(index) == '=') {
-                index++;
-                break;
-            }
-        }
-
-        int ampIndex = query.indexOf('&', index);
-        if (ampIndex == -1) {
-            value = query.substring(index);
-        } else {
-            value = query.substring(index, ampIndex);
-        }
-
-        return Uri.decode(value);
-    }
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/calendar/VCalendarExportSource.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/calendar/VCalendarExportSource.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/calendar/VCalendarExportSource.java	(revision 168087)
@@ -1,407 +0,0 @@
-/** Create by Spreadst
- *  Add 20141231 of bug385990
- *  */
-/*****************************************************************************/
-/*                                                            Date : 06/2011 */
-
-/*                            PRESENTATION                                   */
-
-/*          Copyright (c) 2011 Thunder Software Technology Co.,Ltd           */
-
-/*****************************************************************************/
-
-/*                                                                           */
-
-/*    This src/com/android/providers/calendar/VCalendarExportSource.java is  */
-
-/*    company confidential, cannot be reproduced in any form without the     */
-
-/*    written permission of Thunder Software Technology Co.,Ltd              */
-
-/*                                                                           */
-
-/*---------------------------------------------------------------------------*/
-
-/*   Author :  ThunderSoft                                                   */
-
-/*   Role   :  CalendarProvider2                                             */
-
-/*   Reference documents : SWD3_Alcatel_Android_vCal_Req_v0.5                */
-
-/*---------------------------------------------------------------------------*/
-
-/*   Comments :                                                              */
-
-/*   File     : src/com/android/providers/calendar/VCalendarExportSource.java*/
-
-/*   Labels   :                                                              */
-
-/*===========================================================================*/
-
-/* Modifications on Features list / Changes Request / Problems Report        */
-
-/*---------------------------------------------------------------------------*/
-
-/* date    | author           | Key                   | comment              */
-
-/*---------|------------------|-----------------------|----------------------*/
-
-/*06/30/11 | ThunderSoft      | FR133636              |export vcalendar      */
-
-/*---------|------------------|-----------------------|----------------------*/
-
-/*---------|------------------|-----------------------|----------------------*/
-/*===========================================================================*/
-
-package com.sprd.providers.calendar;
-
-import java.util.Locale;
-import java.util.TimeZone;
-
-import com.android.calendarcommon2.ICalendar.Component;
-import com.android.calendarcommon2.ICalendar.Property;
-import com.android.calendarcommon2.ICalendar.Parameter;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-
-import android.provider.CalendarContract.Attendees;
-import android.provider.CalendarContract.Events;
-import android.provider.CalendarContract.Reminders;
-import android.text.format.DateFormat;
-import android.text.format.Time;
-// SPRD: bug234161
-import android.util.Log;
-
-/**
- * Calendar content provider. The contract between this provider and
- * applications is defined in {@link android.provider.Calendar}.
- */
-public class VCalendarExportSource {
-
-    private static final String TAG = "VCalendarExportSource";
-
-    public static String exportSource(SQLiteDatabase db, int eventId) {
-        String begin = "BEGIN:VCALENDAR\r\n";
-        String end = "END:VCALENDAR\r\n";
-
-        StringBuffer vcalendarBuffer = new StringBuffer();
-        String sqlEvents = "select * from events where _id = " + eventId + ";";
-        Cursor c = null;
-
-        String sqlReminders = "select * from REMINDERS where event_id = "
-                + eventId + ";";
-
-        String sqlAttendees = "select * from Attendees where event_id = "
-                + eventId + ";";
-
-        Cursor reminderCursor = null;
-        Cursor attendeesCursor = null;
-        try {
-            c = db.rawQuery(sqlEvents, null);
-            reminderCursor = db.rawQuery(sqlReminders, null);
-            attendeesCursor = db.rawQuery(sqlAttendees, null);
-            while (c.moveToNext()) {
-
-                String title = c.getString(c.getColumnIndex(Events.TITLE));
-                String des = c.getString(c.getColumnIndex(Events.DESCRIPTION));
-                long dtStartmillis = c
-                        .getLong(c.getColumnIndex(Events.DTSTART));
-                long dtEndmillis = c.getLong(c.getColumnIndex(Events.DTEND));
-                int allDay = c.getInt(c.getColumnIndex(Events.ALL_DAY));
-                String location = c.getString(c
-                        .getColumnIndex(Events.EVENT_LOCATION));
-                String status = c.getString(c.getColumnIndex(Events.STATUS));
-                String duration = c
-                        .getString(c.getColumnIndex(Events.DURATION));
-                String timezone = c.getString(c
-                        .getColumnIndex(Events.EVENT_TIMEZONE));
-                String rrule = c.getString(c.getColumnIndex(Events.RRULE));
-                String exrule = c.getString(c.getColumnIndex(Events.EXRULE));
-                String rdate = c.getString(c.getColumnIndex(Events.RDATE));
-                String exdate = c.getString(c.getColumnIndex(Events.EXDATE));
-                int has_alarm = c.getInt(c.getColumnIndex(Events.HAS_ALARM));
-
-                // int transparency = c.getInt(c
-                // .getColumnIndex(Events.TRANSPARENCY));
-                int availability = c.getInt(c
-                        .getColumnIndex(Events.AVAILABILITY));
-                // int visibility =
-                // c.getInt(c.getColumnIndex(Events.VISIBILITY));
-                int access_level = c.getInt(c.getColumnIndex(Events.ACCESS_LEVEL));
-                int hasAttendeeData = c.getInt(c
-                        .getColumnIndex(Events.HAS_ATTENDEE_DATA));
-
-                if (title == null)
-                    title = "";
-                if (des == null)
-                    des = "";
-                if (location == null)
-                    location = "";
-                if (timezone == null)
-                    timezone = "";
-                String clazz = "";
-                switch (access_level) {
-                    case 0:
-                        clazz = "DEFAULT";
-                        break;
-                    case 1:
-                        clazz = "CONFIDENTIAL";
-                        break;
-                    case 2:
-                        clazz = "PRIVATE";
-                        break;
-                    case 3:
-                        clazz = "PUBLIC";
-                        break;
-                    default:
-                        clazz = "DEFAULT";
-                        break;
-                }
-
-                String mName = "VEVENT";
-
-                Component component = new Component(mName, null);
-
-                Property ep = new Property("SUMMARY", title);
-                Parameter p = new Parameter("LANGUAGE", getLanguageEnv());
-
-                ep.addParameter(p);
-                component.addProperty(ep);
-
-                ep = new Property("DESCRIPTION", des);
-                component.addProperty(ep);
-
-                ep = new Property("LOCATION", location);
-                component.addProperty(ep);
-
-                java.util.Calendar calStart = java.util.Calendar
-                        .getInstance(TimeZone.getTimeZone(Time.TIMEZONE_UTC));
-                calStart.setTimeInMillis(dtStartmillis);
-                java.util.Calendar newStartCalendar = java.util.Calendar
-                        .getInstance();
-                newStartCalendar.set(java.util.Calendar.SECOND, 0);
-                newStartCalendar.set(java.util.Calendar.MILLISECOND, 0);
-                newStartCalendar.set(calStart.get(java.util.Calendar.YEAR),
-                        calStart.get(java.util.Calendar.MONTH),
-                        calStart.get(java.util.Calendar.DAY_OF_MONTH),
-                        calStart.get(java.util.Calendar.HOUR_OF_DAY),
-                        calStart.get(java.util.Calendar.MINUTE));
-                long startTimezone = newStartCalendar.getTimeInMillis();
-                // SPRD bug 458262. Import schedule, schedule time error
-                String dtStart = (String) DateFormat.format("yyyyMMdd" + "T"
-                        + "HHmmss" + "Z", startTimezone);
-                ep = new Property("DTSTART", dtStart);
-
-                Parameter tip = new Parameter("TZID", timezone);
-                ep.addParameter(tip);
-                component.addProperty(ep);
-
-                /**
-                 * SPRD: bug234161 according to RFC2445, we only need pair of
-                 * DTSTART/DTEND or DTSTART/DURATION, if dtend read from
-                 * database equals 0, that means this event is a repetitive
-                 * event, so we don't need to write DTEND field to VCalendar.
-                 *
-                 * @{
-                 */
-                if (dtEndmillis != 0) {
-                    Log.d(TAG, "repetitive event, no need DTEND field.");
-                    java.util.Calendar calEnd = java.util.Calendar
-                            .getInstance(TimeZone.getTimeZone(Time.TIMEZONE_UTC));
-                    calEnd.setTimeInMillis(dtEndmillis);
-                    java.util.Calendar endTimeCalendar = java.util.Calendar
-                            .getInstance();
-                    endTimeCalendar.set(java.util.Calendar.SECOND, 0);
-                    endTimeCalendar.set(java.util.Calendar.MILLISECOND, 0);
-                    endTimeCalendar.set(calEnd.get(java.util.Calendar.YEAR),
-                            calEnd.get(java.util.Calendar.MONTH),
-                            calEnd.get(java.util.Calendar.DAY_OF_MONTH),
-                            calEnd.get(java.util.Calendar.HOUR_OF_DAY),
-                            calEnd.get(java.util.Calendar.MINUTE));
-
-                    long endTimezone = endTimeCalendar.getTimeInMillis();
-                    // SPRD bug 458262. Import schedule, schedule time error
-                    String dtEnd = (String) DateFormat.format("yyyyMMdd" + "T"
-                            + "HHmmss" + "Z", endTimezone);
-                    ep = new Property("DTEND", dtEnd);
-                    ep.addParameter(tip);
-                    component.addProperty(ep);
-                }
-                /* @} */
-
-                ep = new Property("STARTMILLIA", String.valueOf(dtStartmillis));
-                component.addProperty(ep);
-
-                ep = new Property("ENDMILLIA", String.valueOf(dtEndmillis));
-                component.addProperty(ep);
-
-                ep = new Property("X-ALLDAY", String.valueOf(allDay));
-                component.addProperty(ep);
-
-                if (status != null) {
-                    ep = new Property("STATE", status);
-                    component.addProperty(ep);
-                }
-
-                if (rrule != null) {
-                    ep = new Property("RRULE", rrule);
-                    component.addProperty(ep);
-                }
-
-                if (exrule != null) {
-                    ep = new Property("EXRULE", exrule);
-                    component.addProperty(ep);
-                }
-
-                if (rdate != null) {
-                    ep = new Property("RDATE", rdate);
-                    component.addProperty(ep);
-                }
-
-                if (exdate != null) {
-                    ep = new Property("EXDATE", exdate);
-                    component.addProperty(ep);
-                }
-
-                if (duration != null) {
-                    ep = new Property("DURATION", duration);
-                    component.addProperty(ep);
-                }
-
-                ep = new Property("HAS_ALARM", String.valueOf(has_alarm));
-                component.addProperty(ep);
-
-                ep = new Property("AVAILABILITY", String.valueOf(availability));
-                component.addProperty(ep);
-
-                ep = new Property("CLASS", clazz);
-                component.addProperty(ep);
-
-                ep = new Property("HAS_ATTENDEE",
-                        String.valueOf(hasAttendeeData));
-                component.addProperty(ep);
-
-                while (attendeesCursor.moveToNext()) {
-                    String attendeeName = attendeesCursor
-                            .getString(attendeesCursor
-                                    .getColumnIndex(Attendees.ATTENDEE_NAME));
-                    String attendeeEmail = attendeesCursor
-                            .getString(attendeesCursor
-                                    .getColumnIndex(Attendees.ATTENDEE_EMAIL));
-                    int attendeeStatus = attendeesCursor.getInt(attendeesCursor
-                            .getColumnIndex(Attendees.ATTENDEE_STATUS));
-                    int attendeeRelationship = attendeesCursor
-                            .getInt(attendeesCursor
-                                    .getColumnIndex(Attendees.ATTENDEE_RELATIONSHIP));
-                    int attendeeType = attendeesCursor.getInt(attendeesCursor
-                            .getColumnIndex(Attendees.ATTENDEE_TYPE));
-
-                    String shipAtt = "";
-                    switch (attendeeRelationship) {
-                        case 0:
-                            shipAtt = "NONE";
-                            break;
-                        case 1:
-                            shipAtt = "ATTENDEE";
-                            break;
-                        case 2:
-                            shipAtt = "ORGANIZER";
-                            break;
-                        case 3:
-                            shipAtt = "PERFORMER";
-                            break;
-                        case 4:
-                            shipAtt = "SPEAKER";
-                            break;
-
-                        default:
-                            shipAtt = "NONE";
-                            break;
-                    }
-
-                    String statusAtt = "";
-                    switch (attendeeStatus) {
-                        case 0:
-                            statusAtt = "NONE";
-                            break;
-                        case 1:
-                            statusAtt = "ACCEPTED";
-                            break;
-                        case 2:
-                            statusAtt = "DECLINED";
-                            break;
-                        case 3:
-                            statusAtt = "INVITED";
-                            break;
-                        case 4:
-                            statusAtt = "TENTATIVE";
-                            break;
-
-                        default:
-                            statusAtt = "NONE";
-                            break;
-                    }
-
-                    ep = new Property("ATTENDEE", attendeeEmail);
-                    Parameter attRole = new Parameter("ROLE", shipAtt);
-
-                    ep.addParameter(attRole);
-
-                    Parameter attstatusPar = new Parameter("STATUE", statusAtt);
-                    ep.addParameter(attstatusPar);
-                    component.addProperty(ep);
-                }
-
-                Component componentAlarm = new Component("VALARM", component);
-
-                while (reminderCursor.moveToNext()) {
-                    String minute = reminderCursor.getString(reminderCursor
-                            .getColumnIndex(Reminders.MINUTES));
-                    String method = reminderCursor.getString(reminderCursor
-                            .getColumnIndex(Reminders.METHOD));
-                    ep = new Property("REMINDERS", minute);
-                    componentAlarm.addProperty(ep);
-
-                    ep = new Property("METHOD", method);
-                    componentAlarm.addProperty(ep);
-                }
-                component.addChild(componentAlarm);
-
-                vcalendarBuffer.append(begin);
-                vcalendarBuffer.append(component.toString());
-                vcalendarBuffer.append(end);
-            }
-        } finally {
-            if (c != null) {
-                c.close();
-            }
-            if (reminderCursor != null) {
-                reminderCursor.close();
-            }
-            if (attendeesCursor != null) {
-                attendeesCursor.close();
-            }
-        }
-        return vcalendarBuffer.toString();
-    }
-
-    public static String getLanguageEnv() {
-        Locale l = Locale.getDefault();
-        String language = l.getLanguage();
-        String country = l.getCountry().toLowerCase();
-        if ("zh".equals(language)) {
-            if ("cn".equals(country)) {
-                language = "zh-CN";
-            } else if ("tw".equals(country)) {
-                language = "zh-TW";
-            }
-        } else if ("pt".equals(language)) {
-            if ("br".equals(country)) {
-                language = "pt-BR";
-            } else if ("pt".equals(country)) {
-                language = "pt-PT";
-            }
-        }
-        return language;
-    }
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarProviderBroadcastReceiver.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarProviderBroadcastReceiver.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarProviderBroadcastReceiver.java	(revision 168087)
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.calendar;
-
-import android.app.Activity;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.provider.CalendarContract;
-import android.util.Log;
-
-public class CalendarProviderBroadcastReceiver extends BroadcastReceiver {
-
-    protected static final String TAG = "CalendarProvider2";
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        String action = intent.getAction();
-        Log.d(TAG, "onReceive : action = " + action);
-        if (!CalendarAlarmManager.ACTION_CHECK_NEXT_ALARM.equals(action)
-                && !CalendarContract.ACTION_EVENT_REMINDER.equals(action)) {
-            setResultCode(Activity.RESULT_CANCELED);
-            return;
-        }
-        final CalendarProvider2 provider = CalendarProvider2.getInstance();
-        // Acquire a wake lock that will be released when the launched Service is doing its work
-        provider.getOrCreateCalendarAlarmManager().acquireScheduleNextAlarmWakeLock();
-        // Set the result code
-        setResultCode(Activity.RESULT_OK);
-        // Launch the Service
-        intent.setClass(context, CalendarProviderIntentService.class);
-        context.startService(intent);
-    }
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarCache.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarCache.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarCache.java	(revision 168087)
@@ -1,242 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.calendar;
-
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.util.Log;
-import com.google.common.annotations.VisibleForTesting;
-
-import java.util.TimeZone;
-
-/**
- * Class for managing a persistent Cache of (key, value) pairs. The persistent storage used is
- * a SQLite database.
- */
-public class CalendarCache {
-    private static final String TAG = "CalendarCache";
-
-    public static final String DATABASE_NAME = "CalendarCache";
-
-    public static final String KEY_TIMEZONE_DATABASE_VERSION = "timezoneDatabaseVersion";
-    public static final String DEFAULT_TIMEZONE_DATABASE_VERSION = "2009s";
-
-    public static final String KEY_TIMEZONE_TYPE = "timezoneType";
-    public static final String TIMEZONE_TYPE_AUTO = "auto";
-    public static final String TIMEZONE_TYPE_HOME = "home";
-
-    public static final String KEY_TIMEZONE_INSTANCES = "timezoneInstances";
-    public static final String KEY_TIMEZONE_INSTANCES_PREVIOUS = "timezoneInstancesPrevious";
-
-    public static final String COLUMN_NAME_ID = "_id";
-    public static final String COLUMN_NAME_KEY = "key";
-    public static final String COLUMN_NAME_VALUE = "value";
-
-    private static final String[] sProjection = {
-        COLUMN_NAME_KEY,
-        COLUMN_NAME_VALUE
-    };
-
-    private static final int COLUMN_INDEX_KEY = 0;
-    private static final int COLUMN_INDEX_VALUE = 1;
-
-    private final SQLiteOpenHelper mOpenHelper;
-
-    /**
-     * This exception is thrown when the cache encounter a null key or a null database reference
-     */
-    public static class CacheException extends Exception {
-        public CacheException() {
-        }
-
-        public CacheException(String detailMessage) {
-            super(detailMessage);
-        }
-    }
-
-    public CalendarCache(SQLiteOpenHelper openHelper) {
-        mOpenHelper = openHelper;
-    }
-
-    public void writeTimezoneDatabaseVersion(String timezoneDatabaseVersion) throws CacheException {
-        writeData(KEY_TIMEZONE_DATABASE_VERSION, timezoneDatabaseVersion);
-    }
-
-    public String readTimezoneDatabaseVersion() {
-        try {
-            return readData(KEY_TIMEZONE_DATABASE_VERSION);
-        } catch (CacheException e) {
-            Log.e(TAG, "Could not read timezone database version from CalendarCache");
-        }
-        return null;
-    }
-
-    @VisibleForTesting
-    public void writeTimezoneType(String timezoneType) throws CacheException {
-        writeData(KEY_TIMEZONE_TYPE, timezoneType);
-    }
-
-    public String readTimezoneType() {
-        try {
-            return readData(KEY_TIMEZONE_TYPE);
-        } catch (CacheException e) {
-            Log.e(TAG, "Cannot read timezone type from CalendarCache - using AUTO as default", e);
-        }
-        return TIMEZONE_TYPE_AUTO;
-    }
-
-    public void writeTimezoneInstances(String timezone) {
-        try {
-            writeData(KEY_TIMEZONE_INSTANCES, timezone);
-        } catch (CacheException e) {
-            Log.e(TAG, "Cannot write instances timezone to CalendarCache");
-        }
-    }
-
-    public String readTimezoneInstances() {
-        try {
-            return readData(KEY_TIMEZONE_INSTANCES);
-        } catch (CacheException e) {
-            String localTimezone = TimeZone.getDefault().getID();
-            Log.e(TAG, "Cannot read instances timezone from CalendarCache - using device one: " +
-                    localTimezone, e);
-            return localTimezone;
-        }
-    }
-
-    public void writeTimezoneInstancesPrevious(String timezone) {
-        try {
-            writeData(KEY_TIMEZONE_INSTANCES_PREVIOUS, timezone);
-        } catch (CacheException e) {
-            Log.e(TAG, "Cannot write previous instance timezone to CalendarCache");
-        }
-    }
-
-    public String readTimezoneInstancesPrevious() {
-        try {
-            return readData(KEY_TIMEZONE_INSTANCES_PREVIOUS);
-        } catch (CacheException e) {
-            Log.e(TAG, "Cannot read previous instances timezone from CalendarCache", e);
-        }
-        return null;
-    }
-
-    /**
-     * Write a (key, value) pair in the Cache.
-     *
-     * @param key the key (must not be null)
-     * @param value the value (can be null)
-     * @throws CacheException when key is null
-     */
-    public void writeData(String key, String value) throws CacheException {
-        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
-        db.beginTransaction();
-        try {
-            writeDataLocked(db, key, value);
-            db.setTransactionSuccessful();
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                Log.i(TAG, "Wrote (key, value) = [ " + key + ", " + value + "] ");
-            }
-        } finally {
-            db.endTransaction();
-        }
-    }
-
-    /**
-     * Write a (key, value) pair in the database used by the cache. This method should be called in
-     * a transaction.
-     *
-     * @param db the database (must not be null)
-     * @param key the key (must not be null)
-     * @param value the value
-     * @throws CacheException when key or database are null
-     */
-    protected void writeDataLocked(SQLiteDatabase db, String key, String value)
-            throws CacheException {
-        if (null == db) {
-            throw new CacheException("Database cannot be null");
-        }
-        if (null == key) {
-            throw new CacheException("Cannot use null key for write");
-        }
-
-        /*
-         * Storing the hash code of a String into the _id column carries a (very) small risk
-         * of weird behavior, because we're using it as a unique key, but hash codes aren't
-         * guaranteed to be unique.  CalendarCache has a small set of keys that are known
-         * ahead of time, so we should be okay.
-         */
-        ContentValues values = new ContentValues();
-        values.put(COLUMN_NAME_ID, key.hashCode());
-        values.put(COLUMN_NAME_KEY, key);
-        values.put(COLUMN_NAME_VALUE, value);
-
-        db.replace(DATABASE_NAME, null /* null column hack */, values);
-    }
-
-    /**
-     * Read a value from the database used by the cache and depending on a key.
-     *
-     * @param key the key from which we want the value (must not be null)
-     * @return the value that was found for the key. Can be null if no key has been found
-     * @throws CacheException when key is null
-     */
-    public String readData(String key) throws CacheException {
-        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
-        return readDataLocked(db, key);
-    }
-
-    /**
-     * Read a value from the database used by the cache and depending on a key. The database should
-     * be "readable" at minimum
-     *
-     * @param db the database (must not be null)
-     * @param key the key from which we want the value (must not be null)
-     * @return the value that was found for the key. Can be null if no value has been found for the
-     * key.
-     * @throws CacheException when key or database are null
-     */
-    protected String readDataLocked(SQLiteDatabase db, String key) throws CacheException {
-        if (null == db) {
-            throw new CacheException("Database cannot be null");
-        }
-        if (null == key) {
-            throw new CacheException("Cannot use null key for read");
-        }
-
-        String rowValue = null;
-
-        Cursor cursor = db.query(DATABASE_NAME, sProjection,
-                COLUMN_NAME_KEY + "=?", new String[] { key }, null, null, null);
-        try {
-            if (cursor.moveToNext()) {
-                rowValue = cursor.getString(COLUMN_INDEX_VALUE);
-            }
-            else {
-                if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                    Log.i(TAG, "Could not find key = [ " + key + " ]");
-                }
-            }
-        } finally {
-            cursor.close();
-            cursor = null;
-        }
-        return rowValue;
-    }
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarDebugActivity.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarDebugActivity.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarDebugActivity.java	(revision 168087)
@@ -1,199 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.calendar;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.media.MediaScannerConnection;
-import android.net.Uri;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.os.Environment;
-import android.util.Log;
-import android.view.View;
-import android.view.Window;
-import android.view.View.OnClickListener;
-import android.widget.Button;
-import android.widget.TextView;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipOutputStream;
-
-/**
- * Prompts the user before copying their calendar database to the SD card.
- *
- */
-public class CalendarDebugActivity extends Activity implements OnClickListener {
-    private static String TAG = "CalendarDebugActivity";
-    private Button mConfirmButton;
-    private Button mCancelButton;
-    private Button mDeleteButton;
-    private TextView mTextView;
-
-    private static final String OUT_FILE = "calendar.db.zip";
-    private static final String MIME_TYPE = "application/zip";
-
-    protected void onCreate(Bundle savedInstanceState) {
-        // Be sure to call the super class.
-        super.onCreate(savedInstanceState);
-
-        requestWindowFeature(Window.FEATURE_LEFT_ICON);
-
-        setContentView(R.layout.dialog_activity);
-
-        getWindow().setFeatureDrawableResource(Window.FEATURE_LEFT_ICON,
-                android.R.drawable.ic_dialog_alert);
-
-        mConfirmButton = (Button) findViewById(R.id.confirm);
-        mCancelButton = (Button) findViewById(R.id.cancel);
-        mDeleteButton = (Button) findViewById(R.id.delete);
-        updateDeleteButton();
-    }
-
-    private void updateDeleteButton() {
-        final boolean fileExist =
-            new File(Environment.getExternalStorageDirectory(), OUT_FILE).exists();
-        mDeleteButton.setEnabled(fileExist);
-    }
-
-    @Override
-    public void onClick(View v) {
-        switch (v.getId()) {
-            case R.id.confirm:
-                mConfirmButton.setEnabled(false);
-                mCancelButton.setEnabled(false);
-                new DumpDbTask().execute();
-                break;
-            case R.id.delete:
-                cleanup();
-                updateDeleteButton();
-                break;
-            case R.id.cancel:
-                finish();
-                break;
-        }
-    }
-
-    private void cleanup() {
-        Log.i(TAG, "Deleting " + OUT_FILE);
-        File outFile = new File(Environment.getExternalStorageDirectory(), OUT_FILE);
-        outFile.delete();
-    }
-
-    private class DumpDbTask extends AsyncTask<Void, Void, File> {
-
-        /**
-         * Starts spinner while task is running.
-         */
-        @Override
-        protected void onPreExecute() {
-            setProgressBarIndeterminateVisibility(true);
-        }
-
-        protected File doInBackground(Void... params) {
-            InputStream is = null;
-            ZipOutputStream os = null;
-
-            try {
-                File path = Environment.getExternalStorageDirectory();
-                File outFile = new File(path, OUT_FILE);
-                outFile.delete();
-                Log.i(TAG, "Outfile=" + outFile.getAbsolutePath());
-
-                final File inFile = getDatabasePath("calendar.db");
-                is = new FileInputStream(inFile);
-
-                os = new ZipOutputStream(new FileOutputStream(outFile));
-                os.putNextEntry(new ZipEntry(inFile.getName()));
-
-                byte[] buf = new byte[4096];
-                int totalLen = 0;
-                while (true) {
-                    int len = is.read(buf);
-                    if (len <= 0) {
-                        break;
-                    }
-                    os.write(buf, 0, len);
-                    totalLen += len;
-                }
-                os.closeEntry();
-
-                Log.i(TAG, "bytes read " + totalLen);
-                os.flush();
-                os.close();
-                os = null;
-
-                // Tell the media scanner about the new file so that it is
-                // immediately available to the user.
-                MediaScannerConnection.scanFile(CalendarDebugActivity.this, new String[] {
-                    outFile.toString()
-                }, new String[] {
-                    MIME_TYPE
-                }, null);
-                return outFile;
-
-            } catch (IOException e) {
-                Log.i(TAG, "Error " + e.toString());
-            } finally {
-                try {
-                    if (is != null) {
-                        is.close();
-                    }
-                    if (os != null) {
-                        os.close();
-                    }
-                } catch (IOException e) {
-                    Log.i(TAG, "Error " + e.toString());
-                }
-            }
-            return null;
-        }
-
-        /**
-         * Runs on the UI thread
-         */
-        @Override
-        protected void onPostExecute(File outFile) {
-            if (outFile != null) {
-                emailFile(outFile);
-            }
-        }
-    }
-
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-        updateDeleteButton();
-        mConfirmButton.setEnabled(true);
-        mCancelButton.setEnabled(true);
-    }
-
-    private void emailFile(File file) {
-        Log.i(TAG, "Drafting email to send " + file.getAbsolutePath());
-        Intent intent = new Intent(Intent.ACTION_SEND);
-        intent.putExtra(Intent.EXTRA_SUBJECT, getString(R.string.debug_tool_email_subject));
-        intent.putExtra(Intent.EXTRA_TEXT, getString(R.string.debug_tool_email_body));
-        intent.setType(MIME_TYPE);
-        intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(file));
-        startActivityForResult(Intent.createChooser(intent,
-                getString(R.string.debug_tool_email_sender_picker)), 0);
-    }
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarDatabaseHelper.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarDatabaseHelper.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarDatabaseHelper.java	(revision 168087)
@@ -1,3496 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License
- */
-
-package com.android.providers.calendar;
-
-import android.accounts.Account;
-import android.content.ContentResolver;
-import android.content.ContentValues;
-import android.content.Context;
-import android.database.Cursor;
-import android.database.DatabaseUtils;
-import android.database.SQLException;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteDoneException;
-import android.database.sqlite.SQLiteException;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.os.Bundle;
-import android.provider.CalendarContract;
-import android.provider.CalendarContract.Attendees;
-import android.provider.CalendarContract.Calendars;
-import android.provider.CalendarContract.Colors;
-import android.provider.CalendarContract.Events;
-import android.provider.CalendarContract.Reminders;
-import android.provider.SyncStateContract;
-import android.text.TextUtils;
-import android.text.format.Time;
-import android.util.Log;
-
-import com.android.common.content.SyncStateContentProviderHelper;
-import com.google.common.annotations.VisibleForTesting;
-
-import java.io.UnsupportedEncodingException;
-import java.net.URLDecoder;
-import java.util.TimeZone;
-
-/**
- * Database helper for calendar. Designed as a singleton to make sure that all
- * {@link android.content.ContentProvider} users get the same reference.
- */
-/* package */ class CalendarDatabaseHelper extends SQLiteOpenHelper {
-
-    private static final String TAG = "CalendarDatabaseHelper";
-
-    private static final boolean LOGD = false;
-
-    @VisibleForTesting
-    public boolean mInTestMode = false;
-
-    private static final String DATABASE_NAME = "calendar.db";
-
-    private static final int DAY_IN_SECONDS = 24 * 60 * 60;
-
-    // Note: if you update the version number, you must also update the code
-    // in upgradeDatabase() to modify the database (gracefully, if possible).
-    //
-    //  xx Froyo and prior
-    // 1xx for Gingerbread,
-    // 2xx for Honeycomb
-    // 3xx for ICS
-    // 4xx for JB
-    // 5xx for JB MR1
-    // 6xx for K
-    // Bump this to the next hundred at each major release.
-    static final int DATABASE_VERSION = 600;
-
-    private static final int PRE_FROYO_SYNC_STATE_VERSION = 3;
-
-    // columns used to duplicate an event row
-    private static final String LAST_SYNCED_EVENT_COLUMNS =
-            Events._SYNC_ID + "," +
-            Events.CALENDAR_ID + "," +
-            Events.TITLE + "," +
-            Events.EVENT_LOCATION + "," +
-            Events.DESCRIPTION + "," +
-            Events.EVENT_COLOR + "," +
-            Events.EVENT_COLOR_KEY + "," +
-            Events.STATUS + "," +
-            Events.SELF_ATTENDEE_STATUS + "," +
-            Events.DTSTART + "," +
-            Events.DTEND + "," +
-            Events.EVENT_TIMEZONE + "," +
-            Events.EVENT_END_TIMEZONE + "," +
-            Events.DURATION + "," +
-            Events.ALL_DAY + "," +
-            Events.ACCESS_LEVEL + "," +
-            Events.AVAILABILITY + "," +
-            Events.HAS_ALARM + "," +
-            Events.HAS_EXTENDED_PROPERTIES + "," +
-            Events.RRULE + "," +
-            Events.RDATE + "," +
-            Events.EXRULE + "," +
-            Events.EXDATE + "," +
-            Events.ORIGINAL_SYNC_ID + "," +
-            Events.ORIGINAL_ID + "," +
-            Events.ORIGINAL_INSTANCE_TIME + "," +
-            Events.ORIGINAL_ALL_DAY + "," +
-            Events.LAST_DATE + "," +
-            Events.HAS_ATTENDEE_DATA + "," +
-            Events.GUESTS_CAN_MODIFY + "," +
-            Events.GUESTS_CAN_INVITE_OTHERS + "," +
-            Events.GUESTS_CAN_SEE_GUESTS + "," +
-            Events.ORGANIZER + "," +
-            Events.IS_ORGANIZER + "," +
-            Events.CUSTOM_APP_PACKAGE + "," +
-            Events.CUSTOM_APP_URI + "," +
-            Events.UID_2445;
-
-    // columns used to duplicate a reminder row
-    private static final String LAST_SYNCED_REMINDER_COLUMNS =
-            Reminders.MINUTES + "," +
-            Reminders.METHOD;
-
-    // columns used to duplicate an attendee row
-    private static final String LAST_SYNCED_ATTENDEE_COLUMNS =
-            Attendees.ATTENDEE_NAME + "," +
-            Attendees.ATTENDEE_EMAIL + "," +
-            Attendees.ATTENDEE_STATUS + "," +
-            Attendees.ATTENDEE_RELATIONSHIP + "," +
-            Attendees.ATTENDEE_TYPE + "," +
-            Attendees.ATTENDEE_IDENTITY + "," +
-            Attendees.ATTENDEE_ID_NAMESPACE;
-
-    // columns used to duplicate an extended property row
-    private static final String LAST_SYNCED_EXTENDED_PROPERTY_COLUMNS =
-            CalendarContract.ExtendedProperties.NAME + "," +
-            CalendarContract.ExtendedProperties.VALUE;
-
-    public interface Tables {
-        public static final String CALENDARS = "Calendars";
-        public static final String EVENTS = "Events";
-        public static final String EVENTS_RAW_TIMES = "EventsRawTimes";
-        public static final String INSTANCES = "Instances";
-        public static final String ATTENDEES = "Attendees";
-        public static final String REMINDERS = "Reminders";
-        public static final String CALENDAR_ALERTS = "CalendarAlerts";
-        public static final String EXTENDED_PROPERTIES = "ExtendedProperties";
-        public static final String CALENDAR_META_DATA = "CalendarMetaData";
-        public static final String CALENDAR_CACHE = "CalendarCache";
-        public static final String SYNC_STATE = "_sync_state";
-        public static final String SYNC_STATE_META = "_sync_state_metadata";
-        public static final String COLORS = "Colors";
-    }
-
-    public interface Views {
-        public static final String EVENTS = "view_events";
-    }
-
-    // Copied from SyncStateContentProviderHelper.  Don't really want to make them public there.
-    private static final String SYNC_STATE_META_VERSION_COLUMN = "version";
-
-    // This needs to be done when all the tables are already created
-    private static final String EVENTS_CLEANUP_TRIGGER_SQL =
-            "DELETE FROM " + Tables.INSTANCES +
-                " WHERE "+ CalendarContract.Instances.EVENT_ID + "=" +
-                    "old." + CalendarContract.Events._ID + ";" +
-            "DELETE FROM " + Tables.EVENTS_RAW_TIMES +
-                " WHERE " + CalendarContract.EventsRawTimes.EVENT_ID + "=" +
-                    "old." + CalendarContract.Events._ID + ";" +
-            "DELETE FROM " + Tables.ATTENDEES +
-                " WHERE " + CalendarContract.Attendees.EVENT_ID + "=" +
-                    "old." + CalendarContract.Events._ID + ";" +
-            "DELETE FROM " + Tables.REMINDERS +
-                " WHERE " + CalendarContract.Reminders.EVENT_ID + "=" +
-                    "old." + CalendarContract.Events._ID + ";" +
-            "DELETE FROM " + Tables.CALENDAR_ALERTS +
-                " WHERE " + CalendarContract.CalendarAlerts.EVENT_ID + "=" +
-                    "old." + CalendarContract.Events._ID + ";" +
-            "DELETE FROM " + Tables.EXTENDED_PROPERTIES +
-                " WHERE " + CalendarContract.ExtendedProperties.EVENT_ID + "=" +
-                    "old." + CalendarContract.Events._ID + ";";
-
-    // This ensures any exceptions based on an event get their original_sync_id
-    // column set when an the _sync_id is set.
-    private static final String EVENTS_ORIGINAL_SYNC_TRIGGER_SQL =
-            "UPDATE " + Tables.EVENTS +
-                " SET " + Events.ORIGINAL_SYNC_ID + "=new." + Events._SYNC_ID +
-                " WHERE " + Events.ORIGINAL_ID + "=old." + Events._ID + ";";
-
-    private static final String SYNC_ID_UPDATE_TRIGGER_NAME = "original_sync_update";
-    private static final String CREATE_SYNC_ID_UPDATE_TRIGGER =
-            "CREATE TRIGGER " + SYNC_ID_UPDATE_TRIGGER_NAME + " UPDATE OF " + Events._SYNC_ID +
-            " ON " + Tables.EVENTS +
-            " BEGIN " +
-                EVENTS_ORIGINAL_SYNC_TRIGGER_SQL +
-            " END";
-
-    private static final String CALENDAR_CLEANUP_TRIGGER_SQL = "DELETE FROM " + Tables.EVENTS +
-            " WHERE " + CalendarContract.Events.CALENDAR_ID + "=" +
-                "old." + CalendarContract.Events._ID + ";";
-
-    private static final String CALENDAR_UPDATE_COLOR_TRIGGER_SQL = "UPDATE " + Tables.CALENDARS
-            + " SET calendar_color=(SELECT " + Colors.COLOR + " FROM " + Tables.COLORS + " WHERE "
-            + Colors.ACCOUNT_NAME + "=" + "new." + Calendars.ACCOUNT_NAME + " AND "
-            + Colors.ACCOUNT_TYPE + "=" + "new." + Calendars.ACCOUNT_TYPE + " AND "
-            + Colors.COLOR_KEY + "=" + "new." + Calendars.CALENDAR_COLOR_KEY + " AND "
-            + Colors.COLOR_TYPE + "=" + Colors.TYPE_CALENDAR + ") "
-            + " WHERE " + Calendars._ID + "=" + "old." + Calendars._ID
-            + ";";
-    private static final String CALENDAR_COLOR_UPDATE_TRIGGER_NAME = "calendar_color_update";
-    private static final String CREATE_CALENDAR_COLOR_UPDATE_TRIGGER = "CREATE TRIGGER "
-            + CALENDAR_COLOR_UPDATE_TRIGGER_NAME + " UPDATE OF " + Calendars.CALENDAR_COLOR_KEY
-            + " ON " + Tables.CALENDARS + " WHEN new." + Calendars.CALENDAR_COLOR_KEY
-            + " NOT NULL BEGIN " + CALENDAR_UPDATE_COLOR_TRIGGER_SQL + " END";
-
-    private static final String EVENT_UPDATE_COLOR_TRIGGER_SQL = "UPDATE " + Tables.EVENTS
-            + " SET eventColor=(SELECT " + Colors.COLOR + " FROM " + Tables.COLORS + " WHERE "
-            + Colors.ACCOUNT_NAME + "=" + "(SELECT " + Calendars.ACCOUNT_NAME + " FROM "
-            + Tables.CALENDARS + " WHERE " + Calendars._ID + "=new." + Events.CALENDAR_ID
-            + ") AND " + Colors.ACCOUNT_TYPE + "=" + "(SELECT " + Calendars.ACCOUNT_TYPE + " FROM "
-            + Tables.CALENDARS + " WHERE " + Calendars._ID + "=new." + Events.CALENDAR_ID
-            + ") AND " + Colors.COLOR_KEY + "=" + "new." + Events.EVENT_COLOR_KEY + " AND "
-            + Colors.COLOR_TYPE + "=" + Colors.TYPE_EVENT + ") "
-            + " WHERE " + Events._ID + "=" + "old." + Events._ID + ";";
-    private static final String EVENT_COLOR_UPDATE_TRIGGER_NAME = "event_color_update";
-    private static final String CREATE_EVENT_COLOR_UPDATE_TRIGGER = "CREATE TRIGGER "
-            + EVENT_COLOR_UPDATE_TRIGGER_NAME + " UPDATE OF " + Events.EVENT_COLOR_KEY + " ON "
-            + Tables.EVENTS + " WHEN new." + Events.EVENT_COLOR_KEY + " NOT NULL BEGIN "
-            + EVENT_UPDATE_COLOR_TRIGGER_SQL + " END";
-
-    /** Selects rows from Attendees for which the event_id refers to a nonexistent Event */
-    private static final String WHERE_ATTENDEES_ORPHANS =
-            Attendees.EVENT_ID + " IN (SELECT " + Attendees.EVENT_ID + " FROM " +
-            Tables.ATTENDEES + " LEFT OUTER JOIN " + Tables.EVENTS + " ON " +
-            Attendees.EVENT_ID + "=" + Tables.EVENTS + "." + Events._ID +
-            " WHERE " + Tables.EVENTS + "." + Events._ID + " IS NULL)";
-    /** Selects rows from Reminders for which the event_id refers to a nonexistent Event */
-    private static final String WHERE_REMINDERS_ORPHANS =
-            Reminders.EVENT_ID + " IN (SELECT " + Reminders.EVENT_ID + " FROM " +
-            Tables.REMINDERS + " LEFT OUTER JOIN " + Tables.EVENTS + " ON " +
-            Reminders.EVENT_ID + "=" + Tables.EVENTS + "." + Events._ID +
-            " WHERE " + Tables.EVENTS + "." + Events._ID + " IS NULL)";
-
-    private static final String SCHEMA_HTTPS = "https://";
-    private static final String SCHEMA_HTTP = "http://";
-
-    private final SyncStateContentProviderHelper mSyncState;
-
-    private static CalendarDatabaseHelper sSingleton = null;
-
-    private DatabaseUtils.InsertHelper mCalendarsInserter;
-    private DatabaseUtils.InsertHelper mColorsInserter;
-    private DatabaseUtils.InsertHelper mEventsInserter;
-    private DatabaseUtils.InsertHelper mEventsRawTimesInserter;
-    private DatabaseUtils.InsertHelper mInstancesInserter;
-    private DatabaseUtils.InsertHelper mAttendeesInserter;
-    private DatabaseUtils.InsertHelper mRemindersInserter;
-    private DatabaseUtils.InsertHelper mCalendarAlertsInserter;
-    private DatabaseUtils.InsertHelper mExtendedPropertiesInserter;
-
-    public long calendarsInsert(ContentValues values) {
-        return mCalendarsInserter.insert(values);
-    }
-
-    public long colorsInsert(ContentValues values) {
-        return mColorsInserter.insert(values);
-    }
-
-    public long eventsInsert(ContentValues values) {
-        return mEventsInserter.insert(values);
-    }
-
-    public long eventsRawTimesInsert(ContentValues values) {
-        return mEventsRawTimesInserter.insert(values);
-    }
-
-    public long eventsRawTimesReplace(ContentValues values) {
-        return mEventsRawTimesInserter.replace(values);
-    }
-
-    public long instancesInsert(ContentValues values) {
-        return mInstancesInserter.insert(values);
-    }
-
-    public long instancesReplace(ContentValues values) {
-        return mInstancesInserter.replace(values);
-    }
-
-    public long attendeesInsert(ContentValues values) {
-        return mAttendeesInserter.insert(values);
-    }
-
-    public long remindersInsert(ContentValues values) {
-        return mRemindersInserter.insert(values);
-    }
-
-    public long calendarAlertsInsert(ContentValues values) {
-        return mCalendarAlertsInserter.insert(values);
-    }
-
-    public long extendedPropertiesInsert(ContentValues values) {
-        return mExtendedPropertiesInserter.insert(values);
-    }
-
-    public static synchronized CalendarDatabaseHelper getInstance(Context context) {
-        if (sSingleton == null) {
-            sSingleton = new CalendarDatabaseHelper(context);
-        }
-        return sSingleton;
-    }
-
-    /**
-     * Private constructor, callers except unit tests should obtain an instance through
-     * {@link #getInstance(android.content.Context)} instead.
-     */
-    /* package */ CalendarDatabaseHelper(Context context) {
-        super(context, DATABASE_NAME, null, DATABASE_VERSION);
-        if (LOGD) Log.d(TAG, "Creating OpenHelper");
-
-        mSyncState = new SyncStateContentProviderHelper();
-    }
-
-    @Override
-    public void onOpen(SQLiteDatabase db) {
-        mSyncState.onDatabaseOpened(db);
-
-        mCalendarsInserter = new DatabaseUtils.InsertHelper(db, Tables.CALENDARS);
-        mColorsInserter = new DatabaseUtils.InsertHelper(db, Tables.COLORS);
-        mEventsInserter = new DatabaseUtils.InsertHelper(db, Tables.EVENTS);
-        mEventsRawTimesInserter = new DatabaseUtils.InsertHelper(db, Tables.EVENTS_RAW_TIMES);
-        mInstancesInserter = new DatabaseUtils.InsertHelper(db, Tables.INSTANCES);
-        mAttendeesInserter = new DatabaseUtils.InsertHelper(db, Tables.ATTENDEES);
-        mRemindersInserter = new DatabaseUtils.InsertHelper(db, Tables.REMINDERS);
-        mCalendarAlertsInserter = new DatabaseUtils.InsertHelper(db, Tables.CALENDAR_ALERTS);
-        mExtendedPropertiesInserter =
-                new DatabaseUtils.InsertHelper(db, Tables.EXTENDED_PROPERTIES);
-    }
-
-    /*
-     * Upgrade sync state table if necessary.  Note that the data bundle
-     * in the table is not upgraded.
-     *
-     * The sync state used to be stored with version 3, but now uses the
-     * same sync state code as contacts, which is version 1.  This code
-     * upgrades from 3 to 1 if necessary.  (Yes, the numbers are unfortunately
-     * backwards.)
-     *
-     * This code is only called when upgrading from an old calendar version,
-     * so there is no problem if sync state version 3 gets used again in the
-     * future.
-     */
-    private void upgradeSyncState(SQLiteDatabase db) {
-        long version = DatabaseUtils.longForQuery(db,
-                 "SELECT " + SYNC_STATE_META_VERSION_COLUMN
-                 + " FROM " + Tables.SYNC_STATE_META,
-                 null);
-        if (version == PRE_FROYO_SYNC_STATE_VERSION) {
-            Log.i(TAG, "Upgrading calendar sync state table");
-            db.execSQL("CREATE TEMPORARY TABLE state_backup(_sync_account TEXT, "
-                    + "_sync_account_type TEXT, data TEXT);");
-            db.execSQL("INSERT INTO state_backup SELECT _sync_account, _sync_account_type, data"
-                    + " FROM "
-                    + Tables.SYNC_STATE
-                    + " WHERE _sync_account is not NULL and _sync_account_type is not NULL;");
-            db.execSQL("DROP TABLE " + Tables.SYNC_STATE + ";");
-            mSyncState.onDatabaseOpened(db);
-            db.execSQL("INSERT INTO " + Tables.SYNC_STATE + "("
-                    + SyncStateContract.Columns.ACCOUNT_NAME + ","
-                    + SyncStateContract.Columns.ACCOUNT_TYPE + ","
-                    + SyncStateContract.Columns.DATA
-                    + ") SELECT _sync_account, _sync_account_type, data from state_backup;");
-            db.execSQL("DROP TABLE state_backup;");
-        } else {
-            // Wrong version to upgrade.
-            // Don't need to do anything more here because mSyncState.onDatabaseOpened() will blow
-            // away and recreate  the database (which will result in a resync).
-            Log.w(TAG, "upgradeSyncState: current version is " + version + ", skipping upgrade.");
-        }
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-        bootstrapDB(db);
-    }
-
-    private void bootstrapDB(SQLiteDatabase db) {
-        Log.i(TAG, "Bootstrapping database");
-
-        mSyncState.createDatabase(db);
-
-        createColorsTable(db);
-
-        createCalendarsTable(db);
-
-        createEventsTable(db);
-
-        db.execSQL("CREATE TABLE " + Tables.EVENTS_RAW_TIMES + " (" +
-                CalendarContract.EventsRawTimes._ID + " INTEGER PRIMARY KEY," +
-                CalendarContract.EventsRawTimes.EVENT_ID + " INTEGER NOT NULL," +
-                CalendarContract.EventsRawTimes.DTSTART_2445 + " TEXT," +
-                CalendarContract.EventsRawTimes.DTEND_2445 + " TEXT," +
-                CalendarContract.EventsRawTimes.ORIGINAL_INSTANCE_TIME_2445 + " TEXT," +
-                CalendarContract.EventsRawTimes.LAST_DATE_2445 + " TEXT," +
-                "UNIQUE (" + CalendarContract.EventsRawTimes.EVENT_ID + ")" +
-                ");");
-
-        db.execSQL("CREATE TABLE " + Tables.INSTANCES + " (" +
-                CalendarContract.Instances._ID + " INTEGER PRIMARY KEY," +
-                CalendarContract.Instances.EVENT_ID + " INTEGER," +
-                CalendarContract.Instances.BEGIN + " INTEGER," +         // UTC millis
-                CalendarContract.Instances.END + " INTEGER," +           // UTC millis
-                CalendarContract.Instances.START_DAY + " INTEGER," +      // Julian start day
-                CalendarContract.Instances.END_DAY + " INTEGER," +        // Julian end day
-                CalendarContract.Instances.START_MINUTE + " INTEGER," +   // minutes from midnight
-                CalendarContract.Instances.END_MINUTE + " INTEGER," +     // minutes from midnight
-                "UNIQUE (" +
-                    CalendarContract.Instances.EVENT_ID + ", " +
-                    CalendarContract.Instances.BEGIN + ", " +
-                    CalendarContract.Instances.END + ")" +
-                ");");
-
-        db.execSQL("CREATE INDEX instancesStartDayIndex ON " + Tables.INSTANCES + " (" +
-                CalendarContract.Instances.START_DAY +
-                ");");
-
-        createCalendarMetaDataTable(db);
-
-        createCalendarCacheTable(db, null);
-
-        db.execSQL("CREATE TABLE " + Tables.ATTENDEES + " (" +
-                CalendarContract.Attendees._ID + " INTEGER PRIMARY KEY," +
-                CalendarContract.Attendees.EVENT_ID + " INTEGER," +
-                CalendarContract.Attendees.ATTENDEE_NAME + " TEXT," +
-                CalendarContract.Attendees.ATTENDEE_EMAIL + " TEXT," +
-                CalendarContract.Attendees.ATTENDEE_STATUS + " INTEGER," +
-                CalendarContract.Attendees.ATTENDEE_RELATIONSHIP + " INTEGER," +
-                CalendarContract.Attendees.ATTENDEE_TYPE + " INTEGER," +
-                CalendarContract.Attendees.ATTENDEE_IDENTITY + " TEXT," +
-                CalendarContract.Attendees.ATTENDEE_ID_NAMESPACE + " TEXT" +
-                ");");
-
-        db.execSQL("CREATE INDEX attendeesEventIdIndex ON " + Tables.ATTENDEES + " (" +
-                CalendarContract.Attendees.EVENT_ID +
-                ");");
-
-        db.execSQL("CREATE TABLE " + Tables.REMINDERS + " (" +
-                CalendarContract.Reminders._ID + " INTEGER PRIMARY KEY," +
-                CalendarContract.Reminders.EVENT_ID + " INTEGER," +
-                CalendarContract.Reminders.MINUTES + " INTEGER," +
-                CalendarContract.Reminders.METHOD + " INTEGER NOT NULL" +
-                " DEFAULT " + CalendarContract.Reminders.METHOD_DEFAULT +
-                ");");
-
-        db.execSQL("CREATE INDEX remindersEventIdIndex ON " + Tables.REMINDERS + " (" +
-                CalendarContract.Reminders.EVENT_ID +
-                ");");
-
-         // This table stores the Calendar notifications that have gone off.
-        db.execSQL("CREATE TABLE " + Tables.CALENDAR_ALERTS + " (" +
-                CalendarContract.CalendarAlerts._ID + " INTEGER PRIMARY KEY," +
-                CalendarContract.CalendarAlerts.EVENT_ID + " INTEGER," +
-                CalendarContract.CalendarAlerts.BEGIN + " INTEGER NOT NULL," +      // UTC millis
-                CalendarContract.CalendarAlerts.END + " INTEGER NOT NULL," +        // UTC millis
-                CalendarContract.CalendarAlerts.ALARM_TIME + " INTEGER NOT NULL," + // UTC millis
-                // UTC millis
-                CalendarContract.CalendarAlerts.CREATION_TIME + " INTEGER NOT NULL DEFAULT 0," +
-                // UTC millis
-                CalendarContract.CalendarAlerts.RECEIVED_TIME + " INTEGER NOT NULL DEFAULT 0," +
-                // UTC millis
-                CalendarContract.CalendarAlerts.NOTIFY_TIME + " INTEGER NOT NULL DEFAULT 0," +
-                CalendarContract.CalendarAlerts.STATE + " INTEGER NOT NULL," +
-                CalendarContract.CalendarAlerts.MINUTES + " INTEGER," +
-                "UNIQUE (" +
-                    CalendarContract.CalendarAlerts.ALARM_TIME + ", " +
-                    CalendarContract.CalendarAlerts.BEGIN + ", " +
-                    CalendarContract.CalendarAlerts.EVENT_ID + ")" +
-                ");");
-
-        db.execSQL("CREATE INDEX calendarAlertsEventIdIndex ON " + Tables.CALENDAR_ALERTS + " (" +
-                CalendarContract.CalendarAlerts.EVENT_ID +
-                ");");
-
-        db.execSQL("CREATE TABLE " + Tables.EXTENDED_PROPERTIES + " (" +
-                CalendarContract.ExtendedProperties._ID + " INTEGER PRIMARY KEY," +
-                CalendarContract.ExtendedProperties.EVENT_ID + " INTEGER," +
-                CalendarContract.ExtendedProperties.NAME + " TEXT," +
-                CalendarContract.ExtendedProperties.VALUE + " TEXT" +
-                ");");
-
-        db.execSQL("CREATE INDEX extendedPropertiesEventIdIndex ON " + Tables.EXTENDED_PROPERTIES
-                + " (" +
-                CalendarContract.ExtendedProperties.EVENT_ID +
-                ");");
-
-        createEventsView(db);
-
-        // Trigger to remove data tied to an event when we delete that event.
-        db.execSQL("CREATE TRIGGER events_cleanup_delete DELETE ON " + Tables.EVENTS + " " +
-                "BEGIN " +
-                EVENTS_CLEANUP_TRIGGER_SQL +
-                "END");
-
-        // Triggers to update the color stored in an event or a calendar when
-        // the color_index is changed.
-        createColorsTriggers(db);
-
-        // Trigger to update exceptions when an original event updates its
-        // _sync_id
-        db.execSQL(CREATE_SYNC_ID_UPDATE_TRIGGER);
-        /* SPRD: Add 20150914 of bug 474232 , add local account @{ */
-        createDefaultCalendars(db);
-        /* @} */
-        scheduleSync(null /* all accounts */, false, null);
-    }
-
-    /* SPRD: Add 20150914 of bug 474232, add local account @{ */
-    private void createDefaultCalendars(SQLiteDatabase db) {
-        db.execSQL("insert into "
-                + Tables.CALENDARS
-                + "("
-                + CalendarContract.Calendars.ACCOUNT_NAME
-                + ","
-                + CalendarContract.Calendars.ACCOUNT_TYPE
-                + ","
-                + CalendarContract.Calendars.NAME
-                + ", "
-                + CalendarContract.Calendars.CALENDAR_DISPLAY_NAME
-                + ","
-                + CalendarContract.Calendars.CALENDAR_COLOR
-                + ","
-                + CalendarContract.Calendars.CALENDAR_ACCESS_LEVEL
-                + ","
-                + CalendarContract.Calendars.SYNC_EVENTS
-                + ","
-                + CalendarContract.Calendars.CALENDAR_TIME_ZONE
-                + ","
-                + CalendarContract.Calendars.OWNER_ACCOUNT
-                + ") values "
-                + "('Local Calendar','Local Calendar','Local Calendar','Local Calendar',-14069085,700,1,'Asia/Beijing','Local Calendar')");
-    }
-
-    /* @} */
-
-    private void createEventsTable(SQLiteDatabase db) {
-        // IMPORTANT: when adding new columns, be sure to update ALLOWED_IN_EXCEPTION and
-        // DONT_CLONE_INTO_EXCEPTION in CalendarProvider2.
-        //
-        // TODO: do we need both dtend and duration?
-        // **When updating this be sure to also update LAST_SYNCED_EVENT_COLUMNS
-        db.execSQL("CREATE TABLE " + Tables.EVENTS + " (" +
-                CalendarContract.Events._ID + " INTEGER PRIMARY KEY AUTOINCREMENT," +
-                CalendarContract.Events._SYNC_ID + " TEXT," +
-                CalendarContract.Events.DIRTY + " INTEGER," +
-                CalendarContract.Events.MUTATORS + " TEXT," +
-                CalendarContract.Events.LAST_SYNCED + " INTEGER DEFAULT 0," +
-                CalendarContract.Events.CALENDAR_ID + " INTEGER NOT NULL," +
-                CalendarContract.Events.TITLE + " TEXT," +
-                CalendarContract.Events.EVENT_LOCATION + " TEXT," +
-                CalendarContract.Events.DESCRIPTION + " TEXT," +
-                CalendarContract.Events.EVENT_COLOR + " INTEGER," +
-                CalendarContract.Events.EVENT_COLOR_KEY + " TEXT," +
-                CalendarContract.Events.STATUS + " INTEGER," +
-                CalendarContract.Events.SELF_ATTENDEE_STATUS + " INTEGER NOT NULL DEFAULT 0," +
-                // dtstart in millis since epoch
-                CalendarContract.Events.DTSTART + " INTEGER," +
-                // dtend in millis since epoch
-                CalendarContract.Events.DTEND + " INTEGER," +
-                // timezone for event
-                CalendarContract.Events.EVENT_TIMEZONE + " TEXT," +
-                CalendarContract.Events.DURATION + " TEXT," +
-                CalendarContract.Events.ALL_DAY + " INTEGER NOT NULL DEFAULT 0," +
-                CalendarContract.Events.ACCESS_LEVEL + " INTEGER NOT NULL DEFAULT 0," +
-                CalendarContract.Events.AVAILABILITY + " INTEGER NOT NULL DEFAULT 0," +
-                CalendarContract.Events.HAS_ALARM + " INTEGER NOT NULL DEFAULT 0," +
-                CalendarContract.Events.HAS_EXTENDED_PROPERTIES + " INTEGER NOT NULL DEFAULT 0," +
-                CalendarContract.Events.RRULE + " TEXT," +
-                CalendarContract.Events.RDATE + " TEXT," +
-                CalendarContract.Events.EXRULE + " TEXT," +
-                CalendarContract.Events.EXDATE + " TEXT," +
-                CalendarContract.Events.ORIGINAL_ID + " INTEGER," +
-                // ORIGINAL_SYNC_ID is the _sync_id of recurring event
-                CalendarContract.Events.ORIGINAL_SYNC_ID + " TEXT," +
-                // originalInstanceTime is in millis since epoch
-                CalendarContract.Events.ORIGINAL_INSTANCE_TIME + " INTEGER," +
-                CalendarContract.Events.ORIGINAL_ALL_DAY + " INTEGER," +
-                // lastDate is in millis since epoch
-                CalendarContract.Events.LAST_DATE + " INTEGER," +
-                CalendarContract.Events.HAS_ATTENDEE_DATA + " INTEGER NOT NULL DEFAULT 0," +
-                CalendarContract.Events.GUESTS_CAN_MODIFY + " INTEGER NOT NULL DEFAULT 0," +
-                CalendarContract.Events.GUESTS_CAN_INVITE_OTHERS + " INTEGER NOT NULL DEFAULT 1," +
-                CalendarContract.Events.GUESTS_CAN_SEE_GUESTS + " INTEGER NOT NULL DEFAULT 1," +
-                CalendarContract.Events.ORGANIZER + " STRING," +
-                CalendarContract.Events.IS_ORGANIZER + " INTEGER," +
-                CalendarContract.Events.DELETED + " INTEGER NOT NULL DEFAULT 0," +
-                // timezone for event with allDay events are in local timezone
-                CalendarContract.Events.EVENT_END_TIMEZONE + " TEXT," +
-                CalendarContract.Events.CUSTOM_APP_PACKAGE + " TEXT," +
-                CalendarContract.Events.CUSTOM_APP_URI + " TEXT," +
-                CalendarContract.Events.UID_2445 + " TEXT," +
-                // SYNC_DATAX columns are available for use by sync adapters
-                CalendarContract.Events.SYNC_DATA1 + " TEXT," +
-                CalendarContract.Events.SYNC_DATA2 + " TEXT," +
-                CalendarContract.Events.SYNC_DATA3 + " TEXT," +
-                CalendarContract.Events.SYNC_DATA4 + " TEXT," +
-                CalendarContract.Events.SYNC_DATA5 + " TEXT," +
-                CalendarContract.Events.SYNC_DATA6 + " TEXT," +
-                CalendarContract.Events.SYNC_DATA7 + " TEXT," +
-                CalendarContract.Events.SYNC_DATA8 + " TEXT," +
-                CalendarContract.Events.SYNC_DATA9 + " TEXT," +
-                CalendarContract.Events.SYNC_DATA10 + " TEXT" + ");");
-
-        // **When updating this be sure to also update LAST_SYNCED_EVENT_COLUMNS
-
-        db.execSQL("CREATE INDEX eventsCalendarIdIndex ON " + Tables.EVENTS + " ("
-                + CalendarContract.Events.CALENDAR_ID + ");");
-    }
-
-    private void createEventsTable307(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE Events ("
-                + "_id INTEGER PRIMARY KEY AUTOINCREMENT,"
-                + "_sync_id TEXT,"
-                + "dirty INTEGER,"
-                + "lastSynced INTEGER DEFAULT 0,"
-                + "calendar_id INTEGER NOT NULL,"
-                + "title TEXT,"
-                + "eventLocation TEXT,"
-                + "description TEXT,"
-                + "eventColor INTEGER,"
-                + "eventStatus INTEGER,"
-                + "selfAttendeeStatus INTEGER NOT NULL DEFAULT 0,"
-                // dtstart in millis since epoch
-                + "dtstart INTEGER,"
-                // dtend in millis since epoch
-                + "dtend INTEGER,"
-                // timezone for event
-                + "eventTimezone TEXT,"
-                + "duration TEXT,"
-                + "allDay INTEGER NOT NULL DEFAULT 0,"
-                + "accessLevel INTEGER NOT NULL DEFAULT 0,"
-                + "availability INTEGER NOT NULL DEFAULT 0,"
-                + "hasAlarm INTEGER NOT NULL DEFAULT 0,"
-                + "hasExtendedProperties INTEGER NOT NULL DEFAULT 0,"
-                + "rrule TEXT,"
-                + "rdate TEXT,"
-                + "exrule TEXT,"
-                + "exdate TEXT,"
-                + "original_id INTEGER,"
-                // ORIGINAL_SYNC_ID is the _sync_id of recurring event
-                + "original_sync_id TEXT,"
-                // originalInstanceTime is in millis since epoch
-                + "originalInstanceTime INTEGER,"
-                + "originalAllDay INTEGER,"
-                // lastDate is in millis since epoch
-                + "lastDate INTEGER,"
-                + "hasAttendeeData INTEGER NOT NULL DEFAULT 0,"
-                + "guestsCanModify INTEGER NOT NULL DEFAULT 0,"
-                + "guestsCanInviteOthers INTEGER NOT NULL DEFAULT 1,"
-                + "guestsCanSeeGuests INTEGER NOT NULL DEFAULT 1,"
-                + "organizer STRING,"
-                + "deleted INTEGER NOT NULL DEFAULT 0,"
-                // timezone for event with allDay events are in local timezone
-                + "eventEndTimezone TEXT,"
-                // SYNC_DATAX columns are available for use by sync adapters
-                + "sync_data1 TEXT,"
-                + "sync_data2 TEXT,"
-                + "sync_data3 TEXT,"
-                + "sync_data4 TEXT,"
-                + "sync_data5 TEXT,"
-                + "sync_data6 TEXT,"
-                + "sync_data7 TEXT,"
-                + "sync_data8 TEXT,"
-                + "sync_data9 TEXT,"
-                + "sync_data10 TEXT);");
-
-        // **When updating this be sure to also update LAST_SYNCED_EVENT_COLUMNS
-
-        db.execSQL("CREATE INDEX eventsCalendarIdIndex ON Events (calendar_id);");
-    }
-
-    // TODO Remove this method after merging all ICS upgrades
-    private void createEventsTable300(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE Events (" +
-                "_id INTEGER PRIMARY KEY," +
-                "_sync_id TEXT," +
-                "_sync_version TEXT," +
-                // sync time in UTC
-                "_sync_time TEXT,"  +
-                "_sync_local_id INTEGER," +
-                "dirty INTEGER," +
-                // sync mark to filter out new rows
-                "_sync_mark INTEGER," +
-                "calendar_id INTEGER NOT NULL," +
-                "htmlUri TEXT," +
-                "title TEXT," +
-                "eventLocation TEXT," +
-                "description TEXT," +
-                "eventStatus INTEGER," +
-                "selfAttendeeStatus INTEGER NOT NULL DEFAULT 0," +
-                "commentsUri TEXT," +
-                // dtstart in millis since epoch
-                "dtstart INTEGER," +
-                // dtend in millis since epoch
-                "dtend INTEGER," +
-                // timezone for event
-                "eventTimezone TEXT," +
-                "duration TEXT," +
-                "allDay INTEGER NOT NULL DEFAULT 0," +
-                "accessLevel INTEGER NOT NULL DEFAULT 0," +
-                "availability INTEGER NOT NULL DEFAULT 0," +
-                "hasAlarm INTEGER NOT NULL DEFAULT 0," +
-                "hasExtendedProperties INTEGER NOT NULL DEFAULT 0," +
-                "rrule TEXT," +
-                "rdate TEXT," +
-                "exrule TEXT," +
-                "exdate TEXT," +
-                // originalEvent is the _sync_id of recurring event
-                "original_sync_id TEXT," +
-                // originalInstanceTime is in millis since epoch
-                "originalInstanceTime INTEGER," +
-                "originalAllDay INTEGER," +
-                // lastDate is in millis since epoch
-                "lastDate INTEGER," +
-                "hasAttendeeData INTEGER NOT NULL DEFAULT 0," +
-                "guestsCanModify INTEGER NOT NULL DEFAULT 0," +
-                "guestsCanInviteOthers INTEGER NOT NULL DEFAULT 1," +
-                "guestsCanSeeGuests INTEGER NOT NULL DEFAULT 1," +
-                "organizer STRING," +
-                "deleted INTEGER NOT NULL DEFAULT 0," +
-                // timezone for event with allDay events are in local timezone
-                "eventEndTimezone TEXT," +
-                // syncAdapterData is available for use by sync adapters
-                "sync_data1 TEXT);");
-
-        db.execSQL("CREATE INDEX eventsCalendarIdIndex ON Events (calendar_id);");
-    }
-
-    private void createCalendarsTable303(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE " + Tables.CALENDARS + " (" +
-                "_id INTEGER PRIMARY KEY," +
-                "account_name TEXT," +
-                "account_type TEXT," +
-                "_sync_id TEXT," +
-                "_sync_version TEXT," +
-                "_sync_time TEXT," +  // UTC
-                "dirty INTEGER," +
-                "name TEXT," +
-                "displayName TEXT," +
-                "calendar_color INTEGER," +
-                "access_level INTEGER," +
-                "visible INTEGER NOT NULL DEFAULT 1," +
-                "sync_events INTEGER NOT NULL DEFAULT 0," +
-                "calendar_location TEXT," +
-                "calendar_timezone TEXT," +
-                "ownerAccount TEXT, " +
-                "canOrganizerRespond INTEGER NOT NULL DEFAULT 1," +
-                "canModifyTimeZone INTEGER DEFAULT 1," +
-                "maxReminders INTEGER DEFAULT 5," +
-                "allowedReminders TEXT DEFAULT '0,1'," +
-                "deleted INTEGER NOT NULL DEFAULT 0," +
-                "cal_sync1 TEXT," +
-                "cal_sync2 TEXT," +
-                "cal_sync3 TEXT," +
-                "cal_sync4 TEXT," +
-                "cal_sync5 TEXT," +
-                "cal_sync6 TEXT" +
-                ");");
-
-        // Trigger to remove a calendar's events when we delete the calendar
-        db.execSQL("CREATE TRIGGER calendar_cleanup DELETE ON " + Tables.CALENDARS + " " +
-                "BEGIN " +
-                CALENDAR_CLEANUP_TRIGGER_SQL +
-                "END");
-    }
-
-    private void createColorsTable(SQLiteDatabase db) {
-
-        db.execSQL("CREATE TABLE " + Tables.COLORS + " (" +
-                CalendarContract.Colors._ID + " INTEGER PRIMARY KEY," +
-                CalendarContract.Colors.ACCOUNT_NAME + " TEXT NOT NULL," +
-                CalendarContract.Colors.ACCOUNT_TYPE + " TEXT NOT NULL," +
-                CalendarContract.Colors.DATA + " TEXT," +
-                CalendarContract.Colors.COLOR_TYPE + " INTEGER NOT NULL," +
-                CalendarContract.Colors.COLOR_KEY + " TEXT NOT NULL," +
-                CalendarContract.Colors.COLOR + " INTEGER NOT NULL" +
-                ");");
-    }
-
-    public void createColorsTriggers(SQLiteDatabase db) {
-        db.execSQL(CREATE_EVENT_COLOR_UPDATE_TRIGGER);
-        db.execSQL(CREATE_CALENDAR_COLOR_UPDATE_TRIGGER);
-    }
-
-    private void createCalendarsTable(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE " + Tables.CALENDARS + " (" +
-                Calendars._ID + " INTEGER PRIMARY KEY," +
-                Calendars.ACCOUNT_NAME + " TEXT," +
-                Calendars.ACCOUNT_TYPE + " TEXT," +
-                Calendars._SYNC_ID + " TEXT," +
-                Calendars.DIRTY + " INTEGER," +
-                Calendars.MUTATORS + " TEXT," +
-                Calendars.NAME + " TEXT," +
-                Calendars.CALENDAR_DISPLAY_NAME + " TEXT," +
-                Calendars.CALENDAR_COLOR + " INTEGER," +
-                Calendars.CALENDAR_COLOR_KEY + " TEXT," +
-                Calendars.CALENDAR_ACCESS_LEVEL + " INTEGER," +
-                Calendars.VISIBLE + " INTEGER NOT NULL DEFAULT 1," +
-                Calendars.SYNC_EVENTS + " INTEGER NOT NULL DEFAULT 0," +
-                Calendars.CALENDAR_LOCATION + " TEXT," +
-                Calendars.CALENDAR_TIME_ZONE + " TEXT," +
-                Calendars.OWNER_ACCOUNT + " TEXT, " +
-                Calendars.IS_PRIMARY + " INTEGER, " +
-                Calendars.CAN_ORGANIZER_RESPOND + " INTEGER NOT NULL DEFAULT 1," +
-                Calendars.CAN_MODIFY_TIME_ZONE + " INTEGER DEFAULT 1," +
-                Calendars.CAN_PARTIALLY_UPDATE + " INTEGER DEFAULT 0," +
-                Calendars.MAX_REMINDERS + " INTEGER DEFAULT 5," +
-                Calendars.ALLOWED_REMINDERS + " TEXT DEFAULT '0,1'," +
-                Calendars.ALLOWED_AVAILABILITY + " TEXT DEFAULT '0,1'," +
-                Calendars.ALLOWED_ATTENDEE_TYPES + " TEXT DEFAULT '0,1,2'," +
-                Calendars.DELETED + " INTEGER NOT NULL DEFAULT 0," +
-                Calendars.CAL_SYNC1 + " TEXT," +
-                Calendars.CAL_SYNC2 + " TEXT," +
-                Calendars.CAL_SYNC3 + " TEXT," +
-                Calendars.CAL_SYNC4 + " TEXT," +
-                Calendars.CAL_SYNC5 + " TEXT," +
-                Calendars.CAL_SYNC6 + " TEXT," +
-                Calendars.CAL_SYNC7 + " TEXT," +
-                Calendars.CAL_SYNC8 + " TEXT," +
-                Calendars.CAL_SYNC9 + " TEXT," +
-                Calendars.CAL_SYNC10 + " TEXT" +
-                ");");
-
-        // Trigger to remove a calendar's events when we delete the calendar
-        db.execSQL("CREATE TRIGGER calendar_cleanup DELETE ON " + Tables.CALENDARS + " " +
-                "BEGIN " +
-                CALENDAR_CLEANUP_TRIGGER_SQL +
-                "END");
-    }
-
-    private void createCalendarsTable305(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE Calendars (" +
-                "_id INTEGER PRIMARY KEY," +
-                "account_name TEXT," +
-                "account_type TEXT," +
-                "_sync_id TEXT," +
-                "dirty INTEGER," +
-                "name TEXT," +
-                "calendar_displayName TEXT," +
-                "calendar_color INTEGER," +
-                "calendar_access_level INTEGER," +
-                "visible INTEGER NOT NULL DEFAULT 1," +
-                "sync_events INTEGER NOT NULL DEFAULT 0," +
-                "calendar_location TEXT," +
-                "calendar_timezone TEXT," +
-                "ownerAccount TEXT, " +
-                "canOrganizerRespond INTEGER NOT NULL DEFAULT 1," +
-                "canModifyTimeZone INTEGER DEFAULT 1," +
-                "canPartiallyUpdate INTEGER DEFAULT 0," +
-                "maxReminders INTEGER DEFAULT 5," +
-                "allowedReminders TEXT DEFAULT '0,1'," +
-                "deleted INTEGER NOT NULL DEFAULT 0," +
-                "cal_sync1 TEXT," +
-                "cal_sync2 TEXT," +
-                "cal_sync3 TEXT," +
-                "cal_sync4 TEXT," +
-                "cal_sync5 TEXT," +
-                "cal_sync6 TEXT," +
-                "cal_sync7 TEXT," +
-                "cal_sync8 TEXT," +
-                "cal_sync9 TEXT," +
-                "cal_sync10 TEXT" +
-                ");");
-
-        // Trigger to remove a calendar's events when we delete the calendar
-        db.execSQL("CREATE TRIGGER calendar_cleanup DELETE ON Calendars " +
-                "BEGIN " +
-                "DELETE FROM Events WHERE calendar_id=old._id;" +
-                "END");
-    }
-
-    private void createCalendarsTable300(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE " + Tables.CALENDARS + " (" +
-                "_id INTEGER PRIMARY KEY," +
-                "account_name TEXT," +
-                "account_type TEXT," +
-                "_sync_id TEXT," +
-                "_sync_version TEXT," +
-                "_sync_time TEXT," +  // UTC
-                "dirty INTEGER," +
-                "name TEXT," +
-                "displayName TEXT," +
-                "calendar_color INTEGER," +
-                "access_level INTEGER," +
-                "visible INTEGER NOT NULL DEFAULT 1," +
-                "sync_events INTEGER NOT NULL DEFAULT 0," +
-                "calendar_location TEXT," +
-                "calendar_timezone TEXT," +
-                "ownerAccount TEXT, " +
-                "canOrganizerRespond INTEGER NOT NULL DEFAULT 1," +
-                "canModifyTimeZone INTEGER DEFAULT 1," +
-                "maxReminders INTEGER DEFAULT 5," +
-                "allowedReminders TEXT DEFAULT '0,1,2'," +
-                "deleted INTEGER NOT NULL DEFAULT 0," +
-                "sync1 TEXT," +
-                "sync2 TEXT," +
-                "sync3 TEXT," +
-                "sync4 TEXT," +
-                "sync5 TEXT," +
-                "sync6 TEXT" +
-                ");");
-
-        // Trigger to remove a calendar's events when we delete the calendar
-        db.execSQL("CREATE TRIGGER calendar_cleanup DELETE ON " + Tables.CALENDARS + " " +
-                "BEGIN " +
-                CALENDAR_CLEANUP_TRIGGER_SQL +
-                "END");
-    }
-
-    private void createCalendarsTable205(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE Calendars (" +
-                "_id INTEGER PRIMARY KEY," +
-                "_sync_account TEXT," +
-                "_sync_account_type TEXT," +
-                "_sync_id TEXT," +
-                "_sync_version TEXT," +
-                "_sync_time TEXT," +  // UTC
-                "_sync_dirty INTEGER," +
-                "name TEXT," +
-                "displayName TEXT," +
-                "color INTEGER," +
-                "access_level INTEGER," +
-                "visible INTEGER NOT NULL DEFAULT 1," +
-                "sync_events INTEGER NOT NULL DEFAULT 0," +
-                "location TEXT," +
-                "timezone TEXT," +
-                "ownerAccount TEXT, " +
-                "canOrganizerRespond INTEGER NOT NULL DEFAULT 1," +
-                "canModifyTimeZone INTEGER DEFAULT 1, " +
-                "maxReminders INTEGER DEFAULT 5," +
-                "deleted INTEGER NOT NULL DEFAULT 0," +
-                "sync1 TEXT," +
-                "sync2 TEXT," +
-                "sync3 TEXT," +
-                "sync4 TEXT," +
-                "sync5 TEXT," +
-                "sync6 TEXT" +
-                ");");
-
-        createCalendarsCleanup200(db);
-    }
-
-    private void createCalendarsTable202(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE Calendars (" +
-                "_id INTEGER PRIMARY KEY," +
-                "_sync_account TEXT," +
-                "_sync_account_type TEXT," +
-                "_sync_id TEXT," +
-                "_sync_version TEXT," +
-                "_sync_time TEXT," +  // UTC
-                "_sync_local_id INTEGER," +
-                "_sync_dirty INTEGER," +
-                "_sync_mark INTEGER," + // Used to filter out new rows
-                "name TEXT," +
-                "displayName TEXT," +
-                "color INTEGER," +
-                "access_level INTEGER," +
-                "selected INTEGER NOT NULL DEFAULT 1," +
-                "sync_events INTEGER NOT NULL DEFAULT 0," +
-                "location TEXT," +
-                "timezone TEXT," +
-                "ownerAccount TEXT, " +
-                "organizerCanRespond INTEGER NOT NULL DEFAULT 1," +
-                "deleted INTEGER NOT NULL DEFAULT 0," +
-                "sync1 TEXT," +
-                "sync2 TEXT," +
-                "sync3 TEXT," +
-                "sync4 TEXT," +
-                "sync5 TEXT" +
-                ");");
-
-        createCalendarsCleanup200(db);
-    }
-
-    private void createCalendarsTable200(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE Calendars (" +
-                "_id INTEGER PRIMARY KEY," +
-                "_sync_account TEXT," +
-                "_sync_account_type TEXT," +
-                "_sync_id TEXT," +
-                "_sync_version TEXT," +
-                "_sync_time TEXT," +  // UTC
-                "_sync_local_id INTEGER," +
-                "_sync_dirty INTEGER," +
-                "_sync_mark INTEGER," + // Used to filter out new rows
-                "name TEXT," +
-                "displayName TEXT," +
-                "hidden INTEGER NOT NULL DEFAULT 0," +
-                "color INTEGER," +
-                "access_level INTEGER," +
-                "selected INTEGER NOT NULL DEFAULT 1," +
-                "sync_events INTEGER NOT NULL DEFAULT 0," +
-                "location TEXT," +
-                "timezone TEXT," +
-                "ownerAccount TEXT, " +
-                "organizerCanRespond INTEGER NOT NULL DEFAULT 1," +
-                "deleted INTEGER NOT NULL DEFAULT 0," +
-                "sync1 TEXT," +
-                "sync2 TEXT," +
-                "sync3 TEXT" +
-                ");");
-
-        createCalendarsCleanup200(db);
-    }
-
-    /** Trigger to remove a calendar's events when we delete the calendar */
-    private void createCalendarsCleanup200(SQLiteDatabase db) {
-        db.execSQL("CREATE TRIGGER calendar_cleanup DELETE ON Calendars " +
-                "BEGIN " +
-                "DELETE FROM Events WHERE calendar_id=old._id;" +
-                "END");
-    }
-
-    private void createCalendarMetaDataTable(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE " + Tables.CALENDAR_META_DATA + " (" +
-                CalendarContract.CalendarMetaData._ID + " INTEGER PRIMARY KEY," +
-                CalendarContract.CalendarMetaData.LOCAL_TIMEZONE + " TEXT," +
-                CalendarContract.CalendarMetaData.MIN_INSTANCE + " INTEGER," +      // UTC millis
-                CalendarContract.CalendarMetaData.MAX_INSTANCE + " INTEGER" +       // UTC millis
-                ");");
-    }
-
-    private void createCalendarMetaDataTable59(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE CalendarMetaData (" +
-                "_id INTEGER PRIMARY KEY," +
-                "localTimezone TEXT," +
-                "minInstance INTEGER," +      // UTC millis
-                "maxInstance INTEGER" +       // UTC millis
-                ");");
-    }
-
-    private void createCalendarCacheTable(SQLiteDatabase db, String oldTimezoneDbVersion) {
-        // This is a hack because versioning skipped version number 61 of schema
-        // TODO after version 70 this can be removed
-        db.execSQL("DROP TABLE IF EXISTS " + Tables.CALENDAR_CACHE + ";");
-
-        // IF NOT EXISTS should be normal pattern for table creation
-        db.execSQL("CREATE TABLE IF NOT EXISTS " + Tables.CALENDAR_CACHE + " (" +
-                CalendarCache.COLUMN_NAME_ID + " INTEGER PRIMARY KEY," +
-                CalendarCache.COLUMN_NAME_KEY + " TEXT NOT NULL," +
-                CalendarCache.COLUMN_NAME_VALUE + " TEXT" +
-                ");");
-
-        initCalendarCacheTable(db, oldTimezoneDbVersion);
-        updateCalendarCacheTable(db);
-    }
-
-    private void initCalendarCacheTable(SQLiteDatabase db, String oldTimezoneDbVersion) {
-        String timezoneDbVersion = (oldTimezoneDbVersion != null) ?
-                oldTimezoneDbVersion : CalendarCache.DEFAULT_TIMEZONE_DATABASE_VERSION;
-
-        // Set the default timezone database version
-        db.execSQL("INSERT OR REPLACE INTO " + Tables.CALENDAR_CACHE +
-                " (" + CalendarCache.COLUMN_NAME_ID + ", " +
-                CalendarCache.COLUMN_NAME_KEY + ", " +
-                CalendarCache.COLUMN_NAME_VALUE + ") VALUES (" +
-                CalendarCache.KEY_TIMEZONE_DATABASE_VERSION.hashCode() + "," +
-                "'" + CalendarCache.KEY_TIMEZONE_DATABASE_VERSION + "'," +
-                "'" + timezoneDbVersion + "'" +
-                ");");
-    }
-
-    private void updateCalendarCacheTable(SQLiteDatabase db) {
-        // Define the default timezone type for Instances timezone management
-        db.execSQL("INSERT INTO " + Tables.CALENDAR_CACHE +
-                " (" + CalendarCache.COLUMN_NAME_ID + ", " +
-                CalendarCache.COLUMN_NAME_KEY + ", " +
-                CalendarCache.COLUMN_NAME_VALUE + ") VALUES (" +
-                CalendarCache.KEY_TIMEZONE_TYPE.hashCode() + "," +
-                "'" + CalendarCache.KEY_TIMEZONE_TYPE + "',"  +
-                "'" + CalendarCache.TIMEZONE_TYPE_AUTO + "'" +
-                ");");
-
-        String defaultTimezone = TimeZone.getDefault().getID();
-
-        // Define the default timezone for Instances
-        db.execSQL("INSERT INTO " + Tables.CALENDAR_CACHE +
-                " (" + CalendarCache.COLUMN_NAME_ID + ", " +
-                CalendarCache.COLUMN_NAME_KEY + ", " +
-                CalendarCache.COLUMN_NAME_VALUE + ") VALUES (" +
-                CalendarCache.KEY_TIMEZONE_INSTANCES.hashCode() + "," +
-                "'" + CalendarCache.KEY_TIMEZONE_INSTANCES + "',"  +
-                "'" + defaultTimezone + "'" +
-                ");");
-
-        // Define the default previous timezone for Instances
-        db.execSQL("INSERT INTO " + Tables.CALENDAR_CACHE +
-                " (" + CalendarCache.COLUMN_NAME_ID + ", " +
-                CalendarCache.COLUMN_NAME_KEY + ", " +
-                CalendarCache.COLUMN_NAME_VALUE + ") VALUES (" +
-                CalendarCache.KEY_TIMEZONE_INSTANCES_PREVIOUS.hashCode() + "," +
-                "'" + CalendarCache.KEY_TIMEZONE_INSTANCES_PREVIOUS + "',"  +
-                "'" + defaultTimezone + "'" +
-                ");");
-    }
-
-    private void initCalendarCacheTable203(SQLiteDatabase db, String oldTimezoneDbVersion) {
-        String timezoneDbVersion = (oldTimezoneDbVersion != null) ?
-                oldTimezoneDbVersion : "2009s";
-
-        // Set the default timezone database version
-        db.execSQL("INSERT OR REPLACE INTO CalendarCache" +
-                " (_id, " +
-                "key, " +
-                "value) VALUES (" +
-                "timezoneDatabaseVersion".hashCode() + "," +
-                "'timezoneDatabaseVersion',"  +
-                "'" + timezoneDbVersion + "'" +
-                ");");
-    }
-
-    private void updateCalendarCacheTableTo203(SQLiteDatabase db) {
-        // Define the default timezone type for Instances timezone management
-        db.execSQL("INSERT INTO CalendarCache" +
-                " (_id, key, value) VALUES (" +
-                "timezoneType".hashCode() + "," +
-                "'timezoneType',"  +
-                "'auto'" +
-                ");");
-
-        String defaultTimezone = TimeZone.getDefault().getID();
-
-        // Define the default timezone for Instances
-        db.execSQL("INSERT INTO CalendarCache" +
-                " (_id, key, value) VALUES (" +
-                "timezoneInstances".hashCode() + "," +
-                "'timezoneInstances',"  +
-                "'" + defaultTimezone + "'" +
-                ");");
-
-        // Define the default previous timezone for Instances
-        db.execSQL("INSERT INTO CalendarCache" +
-                " (_id, key, value) VALUES (" +
-                "timezoneInstancesPrevious".hashCode() + "," +
-                "'timezoneInstancesPrevious',"  +
-                "'" + defaultTimezone + "'" +
-                ");");
-    }
-
-    /**
-     * Removes orphaned data from the database.  Specifically:
-     * <ul>
-     * <li>Attendees with an event_id for a nonexistent Event
-     * <li>Reminders with an event_id for a nonexistent Event
-     * </ul>
-     */
-    static void removeOrphans(SQLiteDatabase db) {
-        if (false) {        // debug mode
-            String SELECT_ATTENDEES_ORPHANS = "SELECT " +
-                    Attendees._ID + ", " + Attendees.EVENT_ID + " FROM " + Tables.ATTENDEES +
-                    " WHERE " + WHERE_ATTENDEES_ORPHANS;
-
-            Cursor cursor = null;
-            try {
-                Log.i(TAG, "Attendees orphans:");
-                cursor = db.rawQuery(SELECT_ATTENDEES_ORPHANS, null);
-                DatabaseUtils.dumpCursor(cursor);
-            } finally {
-                if (cursor != null) {
-                    cursor.close();
-                }
-            }
-
-            String SELECT_REMINDERS_ORPHANS = "SELECT " +
-                    Attendees._ID + ", " + Reminders.EVENT_ID + " FROM " + Tables.REMINDERS +
-                    " WHERE " + WHERE_REMINDERS_ORPHANS;
-            cursor = null;
-            try {
-                Log.i(TAG, "Reminders orphans:");
-                cursor = db.rawQuery(SELECT_REMINDERS_ORPHANS, null);
-                DatabaseUtils.dumpCursor(cursor);
-            } finally {
-                if (cursor != null) {
-                    cursor.close();
-                }
-            }
-
-            return;
-        }
-
-        Log.d(TAG, "Checking for orphaned entries");
-        int count;
-
-        count = db.delete(Tables.ATTENDEES, WHERE_ATTENDEES_ORPHANS, null);
-        if (count != 0) {
-            Log.i(TAG, "Deleted " + count + " orphaned Attendees");
-        }
-
-        count = db.delete(Tables.REMINDERS, WHERE_REMINDERS_ORPHANS, null);
-        if (count != 0) {
-            Log.i(TAG, "Deleted " + count + " orphaned Reminders");
-        }
-    }
-
-
-    @Override
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        Log.i(TAG, "Upgrading DB from version " + oldVersion + " to " + newVersion);
-        long startWhen = System.nanoTime();
-
-        if (oldVersion < 49) {
-            dropTables(db);
-            bootstrapDB(db);
-            return;
-        }
-
-        // From schema versions 59 to version 66, the CalendarMetaData table definition had lost
-        // the primary key leading to having the CalendarMetaData with multiple rows instead of
-        // only one. The Instance table was then corrupted (during Instance expansion we are using
-        // the localTimezone, minInstance and maxInstance from CalendarMetaData table.
-        // This boolean helps us tracking the need to recreate the CalendarMetaData table and
-        // clear the Instance table (and thus force an Instance expansion).
-        boolean recreateMetaDataAndInstances = (oldVersion >= 59 && oldVersion <= 66);
-        boolean createEventsView = false;
-
-        try {
-            if (oldVersion < 51) {
-                upgradeToVersion51(db); // From 50 or 51
-                oldVersion = 51;
-            }
-            if (oldVersion == 51) {
-                upgradeToVersion52(db);
-                oldVersion += 1;
-            }
-            if (oldVersion == 52) {
-                upgradeToVersion53(db);
-                oldVersion += 1;
-            }
-            if (oldVersion == 53) {
-                upgradeToVersion54(db);
-                oldVersion += 1;
-            }
-            if (oldVersion == 54) {
-                upgradeToVersion55(db);
-                oldVersion += 1;
-            }
-            if (oldVersion == 55 || oldVersion == 56) {
-                // Both require resync, so just schedule it once
-                upgradeResync(db);
-            }
-            if (oldVersion == 55) {
-                upgradeToVersion56(db);
-                oldVersion += 1;
-            }
-            if (oldVersion == 56) {
-                upgradeToVersion57(db);
-                oldVersion += 1;
-            }
-            if (oldVersion == 57) {
-                // Changes are undone upgrading to 60, so don't do anything.
-                oldVersion += 1;
-            }
-            if (oldVersion == 58) {
-                upgradeToVersion59(db);
-                oldVersion += 1;
-            }
-            if (oldVersion == 59) {
-                upgradeToVersion60(db);
-                createEventsView = true;
-                oldVersion += 1;
-            }
-            if (oldVersion == 60) {
-                upgradeToVersion61(db);
-                oldVersion += 1;
-            }
-            if (oldVersion == 61) {
-                upgradeToVersion62(db);
-                oldVersion += 1;
-            }
-            if (oldVersion == 62) {
-                createEventsView = true;
-                oldVersion += 1;
-            }
-            if (oldVersion == 63) {
-                upgradeToVersion64(db);
-                oldVersion += 1;
-            }
-            if (oldVersion == 64) {
-                createEventsView = true;
-                oldVersion += 1;
-            }
-            if (oldVersion == 65) {
-                upgradeToVersion66(db);
-                oldVersion += 1;
-            }
-            if (oldVersion == 66) {
-                // Changes are done thru recreateMetaDataAndInstances() method
-                oldVersion += 1;
-            }
-            if (recreateMetaDataAndInstances) {
-                recreateMetaDataAndInstances67(db);
-            }
-            if (oldVersion == 67 || oldVersion == 68) {
-                upgradeToVersion69(db);
-                oldVersion = 69;
-            }
-            // 69. 70 are for Froyo/old Gingerbread only and 100s are for Gingerbread only
-            // 70 and 71 have been for Honeycomb but no more used
-            // 72 and 73 and 74 were for Honeycomb only but are considered as obsolete for enabling
-            // room for Froyo version numbers
-            if(oldVersion == 69) {
-                upgradeToVersion200(db);
-                createEventsView = true;
-                oldVersion = 200;
-            }
-            if (oldVersion == 70) {
-                upgradeToVersion200(db);
-                oldVersion = 200;
-            }
-            if (oldVersion == 100) {
-                // note we skip past v101 and v102
-                upgradeToVersion200(db);
-                oldVersion = 200;
-            }
-            boolean need203Update = true;
-            if (oldVersion == 101 || oldVersion == 102) {
-                // v101 is v100 plus updateCalendarCacheTableTo203().
-                // v102 is v101 with Event._id changed to autoincrement.
-                // Upgrade to 200 and skip the 203 update.
-                upgradeToVersion200(db);
-                oldVersion = 200;
-                need203Update = false;
-            }
-            if (oldVersion == 200) {
-                upgradeToVersion201(db);
-                oldVersion += 1;
-            }
-            if (oldVersion == 201) {
-                upgradeToVersion202(db);
-                createEventsView = true;
-                oldVersion += 1;
-            }
-            if (oldVersion == 202) {
-                if (need203Update) {
-                    upgradeToVersion203(db);
-                }
-                oldVersion += 1;
-            }
-            if (oldVersion == 203) {
-                createEventsView = true;
-                oldVersion += 1;
-            }
-            if (oldVersion == 206) {
-                // v206 exists only in HC (change Event._id to autoincrement).  Otherwise
-                // identical to v204, so back it up and let the upgrade path continue.
-                oldVersion -= 2;
-            }
-            if (oldVersion == 204) {
-                // This is an ICS update, all following use 300+ versions.
-                upgradeToVersion205(db);
-                createEventsView = true;
-                oldVersion += 1;
-            }
-            if (oldVersion == 205) {
-                // Move ICS updates to 300 range
-                upgradeToVersion300(db);
-                createEventsView = true;
-                oldVersion = 300;
-            }
-            if (oldVersion == 300) {
-                upgradeToVersion301(db);
-                createEventsView = true;
-                oldVersion++;
-            }
-            if (oldVersion == 301) {
-                upgradeToVersion302(db);
-                oldVersion++;
-            }
-            if (oldVersion == 302) {
-                upgradeToVersion303(db);
-                oldVersion++;
-                createEventsView = true;
-            }
-            if (oldVersion == 303) {
-                upgradeToVersion304(db);
-                oldVersion++;
-                createEventsView = true;
-            }
-            if (oldVersion == 304) {
-                upgradeToVersion305(db);
-                oldVersion++;
-                createEventsView = true;
-            }
-            if (oldVersion == 305) {
-                upgradeToVersion306(db);
-                // force a sync to update edit url and etag
-                scheduleSync(null /* all accounts */, false, null);
-                oldVersion++;
-            }
-            if (oldVersion == 306) {
-                upgradeToVersion307(db);
-                oldVersion++;
-            }
-            if (oldVersion == 307) {
-                upgradeToVersion308(db);
-                oldVersion++;
-                createEventsView = true;
-            }
-            if (oldVersion == 308) {
-                upgradeToVersion400(db);
-                createEventsView = true;
-                oldVersion = 400;
-            }
-            // 309 was changed to 400 since it is the first change of the J release.
-            if (oldVersion == 309 || oldVersion == 400) {
-                upgradeToVersion401(db);
-                createEventsView = true;
-                oldVersion = 401;
-            }
-            if (oldVersion == 401) {
-                upgradeToVersion402(db);
-                createEventsView = true;
-                oldVersion = 402;
-            }
-            if (oldVersion == 402) {
-                upgradeToVersion403(db);
-                createEventsView = true;
-                oldVersion = 403;
-            }
-            if (oldVersion == 403) {
-                upgradeToVersion501(db);
-                createEventsView = true;
-                oldVersion = 501;
-            }
-            if (oldVersion == 501) {
-                upgradeToVersion502(db);
-                createEventsView = true; // This is needed if the calendars or events schema changed
-                oldVersion = 502;
-            }
-            if (oldVersion < 600) {
-                upgradeToVersion600(db);
-                createEventsView = true; // This is needed if the calendars or events schema changed
-                oldVersion = 600;
-            }
-
-            if (createEventsView) {
-                createEventsView(db);
-            }
-            if (oldVersion != DATABASE_VERSION) {
-                Log.e(TAG, "Need to recreate Calendar schema because of "
-                        + "unknown Calendar database version: " + oldVersion);
-                dropTables(db);
-                bootstrapDB(db);
-                oldVersion = DATABASE_VERSION;
-            } else {
-                removeOrphans(db);
-            }
-        } catch (SQLiteException e) {
-            if (mInTestMode) {
-                // We do want to crash if we are in test mode.
-                throw e;
-            }
-            Log.e(TAG, "onUpgrade: SQLiteException, recreating db. ", e);
-            Log.e(TAG, "(oldVersion was " + oldVersion + ")");
-            dropTables(db);
-            bootstrapDB(db);
-            return; // this was lossy
-        }
-
-        long endWhen = System.nanoTime();
-        Log.d(TAG, "Calendar upgrade took " + ((endWhen - startWhen) / 1000000) + "ms");
-
-        /**
-         * db versions < 100 correspond to Froyo and earlier. Gingerbread bumped
-         * the db versioning to 100. Honeycomb bumped it to 200. ICS will begin
-         * in 300. At each major release we should jump to the next
-         * centiversion.
-         */
-    }
-
-    @Override
-    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        Log.i(TAG, "Can't downgrade DB from version " + oldVersion + " to " + newVersion);
-        dropTables(db);
-        bootstrapDB(db);
-        return;
-    }
-
-    /**
-     * If the user_version of the database if between 59 and 66 (those versions has been deployed
-     * with no primary key for the CalendarMetaData table)
-     */
-    private void recreateMetaDataAndInstances67(SQLiteDatabase db) {
-        // Recreate the CalendarMetaData table with correct primary key
-        db.execSQL("DROP TABLE CalendarMetaData;");
-        createCalendarMetaDataTable59(db);
-
-        // Also clean the Instance table as this table may be corrupted
-        db.execSQL("DELETE FROM Instances;");
-    }
-
-    private static boolean fixAllDayTime(Time time, String timezone, Long timeInMillis) {
-        time.set(timeInMillis);
-        if(time.hour != 0 || time.minute != 0 || time.second != 0) {
-            time.hour = 0;
-            time.minute = 0;
-            time.second = 0;
-            return true;
-        }
-        return false;
-    }
-
-    /**********************************************************/
-    /* DO NOT USE CONSTANTS FOR UPGRADES, USE STRING LITERALS */
-    /**********************************************************/
-
-    /**********************************************************/
-    /* 6xx db version is for K release
-    /**********************************************************/
-
-    private void upgradeToVersion600(SQLiteDatabase db) {
-        /*
-         * Changes from version 5xx to 600:
-         * - add mutator columns to Events & calendars
-         */
-        db.execSQL("ALTER TABLE Events ADD COLUMN mutators TEXT;");
-        db.execSQL("ALTER TABLE Calendars ADD COLUMN mutators TEXT;");
-    }
-
-    /**********************************************************/
-    /* 5xx db version is for JB MR1 release
-    /**********************************************************/
-
-    private void upgradeToVersion501(SQLiteDatabase db) {
-        /*
-         * Changes from version 403 to 501:
-         * - add isOrganizer column to Events table
-         * - add isPrimary column to Calendars table
-         */
-        db.execSQL("ALTER TABLE Events ADD COLUMN isOrganizer INTEGER;");
-        db.execSQL("ALTER TABLE Calendars ADD COLUMN isPrimary INTEGER;");
-    }
-
-    private void upgradeToVersion502(SQLiteDatabase db) {
-        /*
-         * Changes from version 501 to 502:
-         * - add UID for events added from the RFC 2445 iCalendar format.
-         */
-        db.execSQL("ALTER TABLE Events ADD COLUMN uid2445 TEXT;");
-    }
-
-    /**********************************************************/
-    /* 4xx db version is for J release
-    /**********************************************************/
-
-    private void upgradeToVersion403(SQLiteDatabase db) {
-        /*
-         * Changes from version 402 to 403:
-         * - add custom app package name and uri Events table
-         */
-        db.execSQL("ALTER TABLE Events ADD COLUMN customAppPackage TEXT;");
-        db.execSQL("ALTER TABLE Events ADD COLUMN customAppUri TEXT;");
-    }
-
-    private void upgradeToVersion402(SQLiteDatabase db) {
-        /*
-         * Changes from version 401 to 402:
-         * - add identity and namespace to Attendees table
-         */
-        db.execSQL("ALTER TABLE Attendees ADD COLUMN attendeeIdentity TEXT;");
-        db.execSQL("ALTER TABLE Attendees ADD COLUMN attendeeIdNamespace TEXT;");
-    }
-
-    /*
-     * Changes from version 309 to 401:
-     * Fix repeating events' exceptions with the wrong original_id
-     */
-    private void upgradeToVersion401(SQLiteDatabase db) {
-        db.execSQL("UPDATE events SET original_id=(SELECT _id FROM events inner_events WHERE " +
-                "inner_events._sync_id=events.original_sync_id AND " +
-                "inner_events.calendar_id=events.calendar_id) WHERE NOT original_id IS NULL AND " +
-                "(SELECT calendar_id FROM events ex_events WHERE " +
-                "ex_events._id=events.original_id) <> calendar_id ");
-    }
-
-    private void upgradeToVersion400(SQLiteDatabase db) {
-        db.execSQL("DROP TRIGGER IF EXISTS calendar_color_update");
-        // CREATE_CALENDAR_COLOR_UPDATE_TRIGGER was inlined
-        db.execSQL("CREATE TRIGGER "
-                + "calendar_color_update" + " UPDATE OF " + Calendars.CALENDAR_COLOR_KEY
-                + " ON " + Tables.CALENDARS + " WHEN new." + Calendars.CALENDAR_COLOR_KEY
-                + " NOT NULL BEGIN " + "UPDATE " + Tables.CALENDARS
-                + " SET calendar_color=(SELECT " + Colors.COLOR + " FROM " + Tables.COLORS
-                + " WHERE " + Colors.ACCOUNT_NAME + "=" + "new." + Calendars.ACCOUNT_NAME + " AND "
-                + Colors.ACCOUNT_TYPE + "=" + "new." + Calendars.ACCOUNT_TYPE + " AND "
-                + Colors.COLOR_KEY + "=" + "new." + Calendars.CALENDAR_COLOR_KEY + " AND "
-                + Colors.COLOR_TYPE + "=" + Colors.TYPE_CALENDAR + ") "
-                + " WHERE " + Calendars._ID + "=" + "old." + Calendars._ID
-                + ";" + " END");
-        db.execSQL("DROP TRIGGER IF EXISTS event_color_update");
-        // CREATE_EVENT_COLOR_UPDATE_TRIGGER was inlined
-        db.execSQL("CREATE TRIGGER "
-                + "event_color_update" + " UPDATE OF " + Events.EVENT_COLOR_KEY + " ON "
-                + Tables.EVENTS + " WHEN new." + Events.EVENT_COLOR_KEY + " NOT NULL BEGIN "
-                + "UPDATE " + Tables.EVENTS
-                + " SET eventColor=(SELECT " + Colors.COLOR + " FROM " + Tables.COLORS + " WHERE "
-                + Colors.ACCOUNT_NAME + "=" + "(SELECT " + Calendars.ACCOUNT_NAME + " FROM "
-                + Tables.CALENDARS + " WHERE " + Calendars._ID + "=new." + Events.CALENDAR_ID
-                + ") AND " + Colors.ACCOUNT_TYPE + "=" + "(SELECT " + Calendars.ACCOUNT_TYPE
-                + " FROM " + Tables.CALENDARS + " WHERE " + Calendars._ID + "=new."
-                + Events.CALENDAR_ID + ") AND " + Colors.COLOR_KEY + "=" + "new."
-                + Events.EVENT_COLOR_KEY + " AND " + Colors.COLOR_TYPE + "="
-                + Colors.TYPE_EVENT + ") "
-                + " WHERE " + Events._ID + "=" + "old." + Events._ID + ";" + " END");
-    }
-
-    private void upgradeToVersion308(SQLiteDatabase db) {
-        /*
-         * Changes from version 307 to 308:
-         * - add Colors table to db
-         * - add eventColor_index to Events table
-         * - add calendar_color_index to Calendars table
-         * - add allowedAttendeeTypes to Calendars table
-         * - add allowedAvailability to Calendars table
-         */
-        createColorsTable(db);
-
-        db.execSQL("ALTER TABLE Calendars ADD COLUMN allowedAvailability TEXT DEFAULT '0,1';");
-        db.execSQL("ALTER TABLE Calendars ADD COLUMN allowedAttendeeTypes TEXT DEFAULT '0,1,2';");
-        db.execSQL("ALTER TABLE Calendars ADD COLUMN calendar_color_index TEXT;");
-        db.execSQL("ALTER TABLE Events ADD COLUMN eventColor_index TEXT;");
-
-        // Default Exchange calendars to be supporting the 'tentative'
-        // availability as well
-        db.execSQL("UPDATE Calendars SET allowedAvailability='0,1,2' WHERE _id IN "
-                + "(SELECT _id FROM Calendars WHERE account_type='com.android.exchange');");
-
-        // Triggers to update the color stored in an event or a calendar when
-        // the color_index is changed.
-        createColorsTriggers(db);
-    }
-
-    private void upgradeToVersion307(SQLiteDatabase db) {
-        /*
-         * Changes from version 306 to 307:
-         * - Changed _id field to AUTOINCREMENT
-         */
-        db.execSQL("ALTER TABLE Events RENAME TO Events_Backup;");
-        db.execSQL("DROP TRIGGER IF EXISTS events_cleanup_delete");
-        db.execSQL("DROP TRIGGER IF EXISTS original_sync_update");
-        db.execSQL("DROP INDEX IF EXISTS eventsCalendarIdIndex");
-        createEventsTable307(db);
-
-        String FIELD_LIST =
-            "_id, " +
-            "_sync_id, " +
-            "dirty, " +
-            "lastSynced," +
-            "calendar_id, " +
-            "title, " +
-            "eventLocation, " +
-            "description, " +
-            "eventColor, " +
-            "eventStatus, " +
-            "selfAttendeeStatus, " +
-            "dtstart, " +
-            "dtend, " +
-            "eventTimezone, " +
-            "duration, " +
-            "allDay, " +
-            "accessLevel, " +
-            "availability, " +
-            "hasAlarm, " +
-            "hasExtendedProperties, " +
-            "rrule, " +
-            "rdate, " +
-            "exrule, " +
-            "exdate, " +
-            "original_id," +
-            "original_sync_id, " +
-            "originalInstanceTime, " +
-            "originalAllDay, " +
-            "lastDate, " +
-            "hasAttendeeData, " +
-            "guestsCanModify, " +
-            "guestsCanInviteOthers, " +
-            "guestsCanSeeGuests, " +
-            "organizer, " +
-            "deleted, " +
-            "eventEndTimezone, " +
-            "sync_data1," +
-            "sync_data2," +
-            "sync_data3," +
-            "sync_data4," +
-            "sync_data5," +
-            "sync_data6," +
-            "sync_data7," +
-            "sync_data8," +
-            "sync_data9," +
-            "sync_data10 ";
-
-        // copy fields from old to new
-        db.execSQL("INSERT INTO Events (" + FIELD_LIST + ") SELECT " + FIELD_LIST +
-                "FROM Events_Backup;");
-
-        db.execSQL("DROP TABLE Events_Backup;");
-
-        // Trigger to remove data tied to an event when we delete that event.
-        db.execSQL("CREATE TRIGGER events_cleanup_delete DELETE ON " + Tables.EVENTS + " " +
-                "BEGIN " + EVENTS_CLEANUP_TRIGGER_SQL + "END");
-
-        // Trigger to update exceptions when an original event updates its
-        // _sync_id
-        db.execSQL(CREATE_SYNC_ID_UPDATE_TRIGGER);
-    }
-
-    private void upgradeToVersion306(SQLiteDatabase db) {
-        /*
-        * The following changes are for google.com accounts only.
-        *
-        * Change event id's from ".../private/full/... to .../events/...
-        * Set Calendars.canPartiallyUpdate to 1 to support partial updates
-        * Nuke sync state so we re-sync with a fresh etag and edit url
-        *
-        * We need to drop the original_sync_update trigger because it fires whenever the
-        * sync_id field is touched, and dramatically slows this operation.
-        */
-        db.execSQL("DROP TRIGGER IF EXISTS original_sync_update");
-        db.execSQL("UPDATE Events SET "
-                + "_sync_id = REPLACE(_sync_id, '/private/full/', '/events/'), "
-                + "original_sync_id = REPLACE(original_sync_id, '/private/full/', '/events/') "
-                + "WHERE _id IN (SELECT Events._id FROM Events "
-                +    "JOIN Calendars ON Events.calendar_id = Calendars._id "
-                +    "WHERE account_type = 'com.google')"
-        );
-        db.execSQL(CREATE_SYNC_ID_UPDATE_TRIGGER);
-
-        db.execSQL("UPDATE Calendars SET canPartiallyUpdate = 1 WHERE account_type = 'com.google'");
-
-        db.execSQL("DELETE FROM _sync_state WHERE account_type = 'com.google'");
-    }
-
-    private void upgradeToVersion305(SQLiteDatabase db) {
-        /*
-         * Changes from version 304 to 305:
-         * -Add CAL_SYNC columns up to 10
-         * -Rename Calendars.access_level to calendar_access_level
-         * -Rename calendars _sync_version to cal_sync7
-         * -Rename calendars _sync_time to cal_sync8
-         * -Rename displayName to calendar_displayName
-         * -Rename _sync_local_id to sync_data2
-         * -Rename htmlUri to sync_data3
-         * -Rename events _sync_version to sync_data4
-         * -Rename events _sync_time to sync_data5
-         * -Rename commentsUri to sync_data6
-         * -Migrate Events _sync_mark to sync_data8
-         * -Change sync_data2 from INTEGER to TEXT
-         * -Change sync_data8 from INTEGER to TEXT
-         * -Add SYNC_DATA columns up to 10
-         * -Add EVENT_COLOR to Events table
-         */
-
-        // rename old table, create new table with updated layout
-        db.execSQL("ALTER TABLE Calendars RENAME TO Calendars_Backup;");
-        db.execSQL("DROP TRIGGER IF EXISTS calendar_cleanup");
-        createCalendarsTable305(db);
-
-        // copy fields from old to new
-        db.execSQL("INSERT INTO Calendars (" +
-                "_id, " +
-                "account_name, " +
-                "account_type, " +
-                "_sync_id, " +
-                "cal_sync7, " +             // rename from _sync_version
-                "cal_sync8, " +             // rename from _sync_time
-                "dirty, " +
-                "name, " +
-                "calendar_displayName, " +  // rename from displayName
-                "calendar_color, " +
-                "calendar_access_level, " + // rename from access_level
-                "visible, " +
-                "sync_events, " +
-                "calendar_location, " +
-                "calendar_timezone, " +
-                "ownerAccount, " +
-                "canOrganizerRespond, " +
-                "canModifyTimeZone, " +
-                "maxReminders, " +
-                "allowedReminders, " +
-                "deleted, " +
-                "canPartiallyUpdate," +
-                "cal_sync1, " +
-                "cal_sync2, " +
-                "cal_sync3, " +
-                "cal_sync4, " +
-                "cal_sync5, " +
-                "cal_sync6) " +
-                "SELECT " +
-                "_id, " +
-                "account_name, " +
-                "account_type, " +
-                "_sync_id, " +
-                "_sync_version, " +
-                "_sync_time, " +
-                "dirty, " +
-                "name, " +
-                "displayName, " +
-                "calendar_color, " +
-                "access_level, " +
-                "visible, " +
-                "sync_events, " +
-                "calendar_location, " +
-                "calendar_timezone, " +
-                "ownerAccount, " +
-                "canOrganizerRespond, " +
-                "canModifyTimeZone, " +
-                "maxReminders, " +
-                "allowedReminders, " +
-                "deleted, " +
-                "canPartiallyUpdate," +
-                "cal_sync1, " +
-                "cal_sync2, " +
-                "cal_sync3, " +
-                "cal_sync4, " +
-                "cal_sync5, " +
-                "cal_sync6 " +
-                "FROM Calendars_Backup;");
-
-        // drop the old table
-        db.execSQL("DROP TABLE Calendars_Backup;");
-
-        db.execSQL("ALTER TABLE Events RENAME TO Events_Backup;");
-        db.execSQL("DROP TRIGGER IF EXISTS events_cleanup_delete");
-        db.execSQL("DROP INDEX IF EXISTS eventsCalendarIdIndex");
-        // 305 and 307 can share the same createEventsTable implementation, because the
-        // addition of "autoincrement" to _ID doesn't affect the upgrade path.  (Note that
-        // much older databases may also already have autoincrement set because the change
-        // was back-ported.)
-        createEventsTable307(db);
-
-        // copy fields from old to new
-        db.execSQL("INSERT INTO Events (" +
-                "_id, " +
-                "_sync_id, " +
-                "sync_data4, " +        // renamed from _sync_version
-                "sync_data5, " +        // renamed from _sync_time
-                "sync_data2, " +        // renamed from _sync_local_id
-                "dirty, " +
-                "sync_data8, " +        // renamed from _sync_mark
-                "calendar_id, " +
-                "sync_data3, " +        // renamed from htmlUri
-                "title, " +
-                "eventLocation, " +
-                "description, " +
-                "eventStatus, " +
-                "selfAttendeeStatus, " +
-                "sync_data6, " +        // renamed from commentsUri
-                "dtstart, " +
-                "dtend, " +
-                "eventTimezone, " +
-                "eventEndTimezone, " +
-                "duration, " +
-                "allDay, " +
-                "accessLevel, " +
-                "availability, " +
-                "hasAlarm, " +
-                "hasExtendedProperties, " +
-                "rrule, " +
-                "rdate, " +
-                "exrule, " +
-                "exdate, " +
-                "original_id," +
-                "original_sync_id, " +
-                "originalInstanceTime, " +
-                "originalAllDay, " +
-                "lastDate, " +
-                "hasAttendeeData, " +
-                "guestsCanModify, " +
-                "guestsCanInviteOthers, " +
-                "guestsCanSeeGuests, " +
-                "organizer, " +
-                "deleted, " +
-                "sync_data7," +
-                "lastSynced," +
-                "sync_data1) " +
-
-                "SELECT " +
-                "_id, " +
-                "_sync_id, " +
-                "_sync_version, " +
-                "_sync_time, " +
-                "_sync_local_id, " +
-                "dirty, " +
-                "_sync_mark, " +
-                "calendar_id, " +
-                "htmlUri, " +
-                "title, " +
-                "eventLocation, " +
-                "description, " +
-                "eventStatus, " +
-                "selfAttendeeStatus, " +
-                "commentsUri, " +
-                "dtstart, " +
-                "dtend, " +
-                "eventTimezone, " +
-                "eventEndTimezone, " +
-                "duration, " +
-                "allDay, " +
-                "accessLevel, " +
-                "availability, " +
-                "hasAlarm, " +
-                "hasExtendedProperties, " +
-                "rrule, " +
-                "rdate, " +
-                "exrule, " +
-                "exdate, " +
-                "original_id," +
-                "original_sync_id, " +
-                "originalInstanceTime, " +
-                "originalAllDay, " +
-                "lastDate, " +
-                "hasAttendeeData, " +
-                "guestsCanModify, " +
-                "guestsCanInviteOthers, " +
-                "guestsCanSeeGuests, " +
-                "organizer, " +
-                "deleted, " +
-                "sync_data7," +
-                "lastSynced," +
-                "sync_data1 " +
-
-                "FROM Events_Backup;"
-        );
-
-        db.execSQL("DROP TABLE Events_Backup;");
-
-        // Trigger to remove data tied to an event when we delete that event.
-        db.execSQL("CREATE TRIGGER events_cleanup_delete DELETE ON " + Tables.EVENTS + " " +
-                "BEGIN " +
-                EVENTS_CLEANUP_TRIGGER_SQL +
-                "END");
-
-        // Trigger to update exceptions when an original event updates its
-        // _sync_id
-        db.execSQL(CREATE_SYNC_ID_UPDATE_TRIGGER);
-    }
-
-    private void upgradeToVersion304(SQLiteDatabase db) {
-        /*
-         * Changes from version 303 to 304:
-         * - add canPartiallyUpdate to Calendars table
-         * - add sync_data7 to Calendars to Events table
-         * - add lastSynced to Calendars to Events table
-         */
-        db.execSQL("ALTER TABLE Calendars ADD COLUMN canPartiallyUpdate INTEGER DEFAULT 0;");
-        db.execSQL("ALTER TABLE Events ADD COLUMN sync_data7 TEXT;");
-        db.execSQL("ALTER TABLE Events ADD COLUMN lastSynced INTEGER DEFAULT 0;");
-    }
-
-    private void upgradeToVersion303(SQLiteDatabase db) {
-        /*
-         * Changes from version 302 to 303:
-         * - change SYNCx columns to CAL_SYNCx
-         */
-
-        // rename old table, create new table with updated layout
-        db.execSQL("ALTER TABLE Calendars RENAME TO Calendars_Backup;");
-        db.execSQL("DROP TRIGGER IF EXISTS calendar_cleanup");
-        createCalendarsTable303(db);
-
-        // copy fields from old to new
-        db.execSQL("INSERT INTO Calendars (" +
-                "_id, " +
-                "account_name, " +
-                "account_type, " +
-                "_sync_id, " +
-                "_sync_version, " +
-                "_sync_time, " +
-                "dirty, " +
-                "name, " +
-                "displayName, " +
-                "calendar_color, " +
-                "access_level, " +
-                "visible, " +
-                "sync_events, " +
-                "calendar_location, " +
-                "calendar_timezone, " +
-                "ownerAccount, " +
-                "canOrganizerRespond, " +
-                "canModifyTimeZone, " +
-                "maxReminders, " +
-                "allowedReminders, " +
-                "deleted, " +
-                "cal_sync1, " +     // rename from sync1
-                "cal_sync2, " +     // rename from sync2
-                "cal_sync3, " +     // rename from sync3
-                "cal_sync4, " +     // rename from sync4
-                "cal_sync5, " +     // rename from sync5
-                "cal_sync6) " +     // rename from sync6
-                "SELECT " +
-                "_id, " +
-                "account_name, " +
-                "account_type, " +
-                "_sync_id, " +
-                "_sync_version, " +
-                "_sync_time, " +
-                "dirty, " +
-                "name, " +
-                "displayName, " +
-                "calendar_color, " +
-                "access_level, " +
-                "visible, " +
-                "sync_events, " +
-                "calendar_location, " +
-                "calendar_timezone, " +
-                "ownerAccount, " +
-                "canOrganizerRespond, " +
-                "canModifyTimeZone, " +
-                "maxReminders, " +
-                "allowedReminders," +
-                "deleted, " +
-                "sync1, " +
-                "sync2, " +
-                "sync3, " +
-                "sync4," +
-                "sync5," +
-                "sync6 " +
-                "FROM Calendars_Backup;"
-        );
-
-        // drop the old table
-        db.execSQL("DROP TABLE Calendars_Backup;");
-    }
-
-    private void upgradeToVersion302(SQLiteDatabase db) {
-        /*
-         * Changes from version 301 to 302
-         * - Move Exchange eventEndTimezone values to SYNC_DATA1
-         */
-        db.execSQL("UPDATE Events SET sync_data1=eventEndTimezone WHERE calendar_id IN "
-                + "(SELECT _id FROM Calendars WHERE account_type='com.android.exchange');");
-
-        db.execSQL("UPDATE Events SET eventEndTimezone=NULL WHERE calendar_id IN "
-                + "(SELECT _id FROM Calendars WHERE account_type='com.android.exchange');");
-    }
-
-    private void upgradeToVersion301(SQLiteDatabase db) {
-        /*
-         * Changes from version 300 to 301
-         * - Added original_id column to Events table
-         * - Added triggers to keep original_id and original_sync_id in sync
-         */
-
-        db.execSQL("DROP TRIGGER IF EXISTS " + SYNC_ID_UPDATE_TRIGGER_NAME + ";");
-
-        db.execSQL("ALTER TABLE Events ADD COLUMN original_id INTEGER;");
-
-        // Fill in the original_id for all events that have an original_sync_id
-        db.execSQL("UPDATE Events set original_id=" +
-                "(SELECT Events2._id FROM Events AS Events2 " +
-                        "WHERE Events2._sync_id=Events.original_sync_id) " +
-                "WHERE Events.original_sync_id NOT NULL");
-        // Trigger to update exceptions when an original event updates its
-        // _sync_id
-        db.execSQL(CREATE_SYNC_ID_UPDATE_TRIGGER);
-    }
-
-    private void upgradeToVersion300(SQLiteDatabase db) {
-
-        /*
-         * Changes from version 205 to 300:
-         * - rename _sync_account to account_name in Calendars table
-         * - remove _sync_account from Events table
-         * - rename _sync_account_type to account_type in Calendars table
-         * - remove _sync_account_type from Events table
-         * - rename _sync_dirty to dirty in Calendars/Events table
-         * - rename color to calendar_color in Calendars table
-         * - rename location to calendar_location in Calendars table
-         * - rename timezone to calendar_timezone in Calendars table
-         * - add allowedReminders in Calendars table
-         * - rename visibility to accessLevel in Events table
-         * - rename transparency to availability in Events table
-         * - rename originalEvent to original_sync_id in Events table
-         * - remove dtstart2 and dtend2 from Events table
-         * - rename syncAdapterData to sync_data1 in Events table
-         */
-
-        // rename old table, create new table with updated layout
-        db.execSQL("ALTER TABLE Calendars RENAME TO Calendars_Backup;");
-        db.execSQL("DROP TRIGGER IF EXISTS calendar_cleanup;");
-        createCalendarsTable300(db);
-
-        // copy fields from old to new
-        db.execSQL("INSERT INTO Calendars (" +
-                "_id, " +
-                "account_name, " +          // rename from _sync_account
-                "account_type, " +          // rename from _sync_account_type
-                "_sync_id, " +
-                "_sync_version, " +
-                "_sync_time, " +
-                "dirty, " +                 // rename from _sync_dirty
-                "name, " +
-                "displayName, " +
-                "calendar_color, " +        // rename from color
-                "access_level, " +
-                "visible, " +
-                "sync_events, " +
-                "calendar_location, " +     // rename from location
-                "calendar_timezone, " +     // rename from timezone
-                "ownerAccount, " +
-                "canOrganizerRespond, " +
-                "canModifyTimeZone, " +
-                "maxReminders, " +
-                "allowedReminders," +
-                "deleted, " +
-                "sync1, " +
-                "sync2, " +
-                "sync3, " +
-                "sync4," +
-                "sync5," +
-                "sync6) " +
-
-                "SELECT " +
-                "_id, " +
-                "_sync_account, " +
-                "_sync_account_type, " +
-                "_sync_id, " +
-                "_sync_version, " +
-                "_sync_time, " +
-                "_sync_dirty, " +
-                "name, " +
-                "displayName, " +
-                "color, " +
-                "access_level, " +
-                "visible, " +
-                "sync_events, " +
-                "location, " +
-                "timezone, " +
-                "ownerAccount, " +
-                "canOrganizerRespond, " +
-                "canModifyTimeZone, " +
-                "maxReminders, " +
-                "'0,1,2,3'," +
-                "deleted, " +
-                "sync1, " +
-                "sync2, " +
-                "sync3, " +
-                "sync4, " +
-                "sync5, " +
-                "sync6 " +
-                "FROM Calendars_Backup;"
-        );
-
-        /* expand the set of allowed reminders for Google calendars to include email */
-        db.execSQL("UPDATE Calendars SET allowedReminders = '0,1,2' " +
-                "WHERE account_type = 'com.google'");
-
-        // drop the old table
-        db.execSQL("DROP TABLE Calendars_Backup;");
-
-        db.execSQL("ALTER TABLE Events RENAME TO Events_Backup;");
-        db.execSQL("DROP TRIGGER IF EXISTS events_insert");
-        db.execSQL("DROP TRIGGER IF EXISTS events_cleanup_delete");
-        db.execSQL("DROP INDEX IF EXISTS eventSyncAccountAndIdIndex");
-        db.execSQL("DROP INDEX IF EXISTS eventsCalendarIdIndex");
-        createEventsTable300(db);
-
-        // copy fields from old to new
-        db.execSQL("INSERT INTO Events (" +
-                "_id, " +
-                "_sync_id, " +
-                "_sync_version, " +
-                "_sync_time, " +
-                "_sync_local_id, " +
-                "dirty, " +                 // renamed from _sync_dirty
-                "_sync_mark, " +
-                "calendar_id, " +
-                "htmlUri, " +
-                "title, " +
-                "eventLocation, " +
-                "description, " +
-                "eventStatus, " +
-                "selfAttendeeStatus, " +
-                "commentsUri, " +
-                "dtstart, " +
-                "dtend, " +
-                "eventTimezone, " +
-                "eventEndTimezone, " +      // renamed from eventTimezone2
-                "duration, " +
-                "allDay, " +
-                "accessLevel, " +           // renamed from visibility
-                "availability, " +          // renamed from transparency
-                "hasAlarm, " +
-                "hasExtendedProperties, " +
-                "rrule, " +
-                "rdate, " +
-                "exrule, " +
-                "exdate, " +
-                "original_sync_id, " +      // renamed from originalEvent
-                "originalInstanceTime, " +
-                "originalAllDay, " +
-                "lastDate, " +
-                "hasAttendeeData, " +
-                "guestsCanModify, " +
-                "guestsCanInviteOthers, " +
-                "guestsCanSeeGuests, " +
-                "organizer, " +
-                "deleted, " +
-                "sync_data1) " +             // renamed from syncAdapterData
-
-                "SELECT " +
-                "_id, " +
-                "_sync_id, " +
-                "_sync_version, " +
-                "_sync_time, " +
-                "_sync_local_id, " +
-                "_sync_dirty, " +
-                "_sync_mark, " +
-                "calendar_id, " +
-                "htmlUri, " +
-                "title, " +
-                "eventLocation, " +
-                "description, " +
-                "eventStatus, " +
-                "selfAttendeeStatus, " +
-                "commentsUri, " +
-                "dtstart, " +
-                "dtend, " +
-                "eventTimezone, " +
-                "eventTimezone2, " +
-                "duration, " +
-                "allDay, " +
-                "visibility, " +
-                "transparency, " +
-                "hasAlarm, " +
-                "hasExtendedProperties, " +
-                "rrule, " +
-                "rdate, " +
-                "exrule, " +
-                "exdate, " +
-                "originalEvent, " +
-                "originalInstanceTime, " +
-                "originalAllDay, " +
-                "lastDate, " +
-                "hasAttendeeData, " +
-                "guestsCanModify, " +
-                "guestsCanInviteOthers, " +
-                "guestsCanSeeGuests, " +
-                "organizer, " +
-                "deleted, " +
-                "syncAdapterData " +
-
-                "FROM Events_Backup;"
-        );
-
-        db.execSQL("DROP TABLE Events_Backup;");
-
-        // Trigger to remove data tied to an event when we delete that event.
-        db.execSQL("CREATE TRIGGER events_cleanup_delete DELETE ON " + Tables.EVENTS + " " +
-                "BEGIN " +
-                EVENTS_CLEANUP_TRIGGER_SQL +
-                "END");
-
-    }
-
-    private void upgradeToVersion205(SQLiteDatabase db) {
-        /*
-         * Changes from version 204 to 205:
-         * - rename+reorder "_sync_mark" to "sync6" (and change type from INTEGER to TEXT)
-         * - rename "selected" to "visible"
-         * - rename "organizerCanRespond" to "canOrganizerRespond"
-         * - add "canModifyTimeZone"
-         * - add "maxReminders"
-         * - remove "_sync_local_id" (a/k/a _SYNC_DATA)
-         */
-
-        // rename old table, create new table with updated layout
-        db.execSQL("ALTER TABLE Calendars RENAME TO Calendars_Backup;");
-        db.execSQL("DROP TRIGGER IF EXISTS calendar_cleanup");
-        createCalendarsTable205(db);
-
-        // copy fields from old to new
-        db.execSQL("INSERT INTO Calendars (" +
-                "_id, " +
-                "_sync_account, " +
-                "_sync_account_type, " +
-                "_sync_id, " +
-                "_sync_version, " +
-                "_sync_time, " +
-                "_sync_dirty, " +
-                "name, " +
-                "displayName, " +
-                "color, " +
-                "access_level, " +
-                "visible, " +                   // rename from "selected"
-                "sync_events, " +
-                "location, " +
-                "timezone, " +
-                "ownerAccount, " +
-                "canOrganizerRespond, " +       // rename from "organizerCanRespond"
-                "canModifyTimeZone, " +
-                "maxReminders, " +
-                "deleted, " +
-                "sync1, " +
-                "sync2, " +
-                "sync3, " +
-                "sync4," +
-                "sync5," +
-                "sync6) " +                     // rename/reorder from _sync_mark
-                "SELECT " +
-                "_id, " +
-                "_sync_account, " +
-                "_sync_account_type, " +
-                "_sync_id, " +
-                "_sync_version, " +
-                "_sync_time, " +
-                "_sync_dirty, " +
-                "name, " +
-                "displayName, " +
-                "color, " +
-                "access_level, " +
-                "selected, " +
-                "sync_events, " +
-                "location, " +
-                "timezone, " +
-                "ownerAccount, " +
-                "organizerCanRespond, " +
-                "1, " +
-                "5, " +
-                "deleted, " +
-                "sync1, " +
-                "sync2, " +
-                "sync3, " +
-                "sync4, " +
-                "sync5, " +
-                "_sync_mark " +
-                "FROM Calendars_Backup;"
-        );
-
-        // set these fields appropriately for Exchange events
-        db.execSQL("UPDATE Calendars SET canModifyTimeZone=0, maxReminders=1 " +
-                "WHERE _sync_account_type='com.android.exchange'");
-
-        // drop the old table
-        db.execSQL("DROP TABLE Calendars_Backup;");
-    }
-
-    private void upgradeToVersion203(SQLiteDatabase db) {
-        // Same as Gingerbread version 100
-        Cursor cursor = db.rawQuery("SELECT value FROM CalendarCache WHERE key=?",
-                new String[] {"timezoneDatabaseVersion"});
-
-        String oldTimezoneDbVersion = null;
-        if (cursor != null) {
-            try {
-                if (cursor.moveToNext()) {
-                    oldTimezoneDbVersion = cursor.getString(0);
-                    cursor.close();
-                    cursor = null;
-                    // Also clean the CalendarCache table
-                    db.execSQL("DELETE FROM CalendarCache;");
-                }
-            } finally {
-                if (cursor != null) {
-                    cursor.close();
-                }
-            }
-        }
-        initCalendarCacheTable203(db, oldTimezoneDbVersion);
-
-        // Same as Gingerbread version 101
-        updateCalendarCacheTableTo203(db);
-    }
-
-    private void upgradeToVersion202(SQLiteDatabase db) {
-        // We will drop the "hidden" column from the calendar schema and add the "sync5" column
-        db.execSQL("ALTER TABLE Calendars RENAME TO Calendars_Backup;");
-
-        db.execSQL("DROP TRIGGER IF EXISTS calendar_cleanup");
-        createCalendarsTable202(db);
-
-        // Populate the new Calendars table and put into the "sync5" column the value of the
-        // old "hidden" column
-        db.execSQL("INSERT INTO Calendars (" +
-                "_id, " +
-                "_sync_account, " +
-                "_sync_account_type, " +
-                "_sync_id, " +
-                "_sync_version, " +
-                "_sync_time, " +
-                "_sync_local_id, " +
-                "_sync_dirty, " +
-                "_sync_mark, " +
-                "name, " +
-                "displayName, " +
-                "color, " +
-                "access_level, " +
-                "selected, " +
-                "sync_events, " +
-                "location, " +
-                "timezone, " +
-                "ownerAccount, " +
-                "organizerCanRespond, " +
-                "deleted, " +
-                "sync1, " +
-                "sync2, " +
-                "sync3, " +
-                "sync4," +
-                "sync5) " +
-                "SELECT " +
-                "_id, " +
-                "_sync_account, " +
-                "_sync_account_type, " +
-                "_sync_id, " +
-                "_sync_version, " +
-                "_sync_time, " +
-                "_sync_local_id, " +
-                "_sync_dirty, " +
-                "_sync_mark, " +
-                "name, " +
-                "displayName, " +
-                "color, " +
-                "access_level, " +
-                "selected, " +
-                "sync_events, " +
-                "location, " +
-                "timezone, " +
-                "ownerAccount, " +
-                "organizerCanRespond, " +
-                "deleted, " +
-                "sync1, " +
-                "sync2, " +
-                "sync3, " +
-                "sync4, " +
-                "hidden " +
-                "FROM Calendars_Backup;"
-        );
-
-        // Drop the backup table
-        db.execSQL("DROP TABLE Calendars_Backup;");
-    }
-
-    private void upgradeToVersion201(SQLiteDatabase db) {
-        db.execSQL("ALTER TABLE Calendars ADD COLUMN sync4 TEXT;");
-    }
-
-    private void upgradeToVersion200(SQLiteDatabase db) {
-        // we cannot use here a Calendar.Calendars,URL constant for "url" as we are trying to make
-        // it disappear so we are keeping the hardcoded name "url" in all the SQLs
-        db.execSQL("ALTER TABLE Calendars RENAME TO Calendars_Backup;");
-
-        db.execSQL("DROP TRIGGER IF EXISTS calendar_cleanup");
-        createCalendarsTable200(db);
-
-        // Populate the new Calendars table except the SYNC2 / SYNC3 columns
-        db.execSQL("INSERT INTO Calendars (" +
-                "_id, " +
-                "_sync_account, " +
-                "_sync_account_type, " +
-                "_sync_id, " +
-                "_sync_version, " +
-                "_sync_time, " +
-                "_sync_local_id, " +
-                "_sync_dirty, " +
-                "_sync_mark, " +
-                "name, " +
-                "displayName, " +
-                "color, " +
-                "access_level, " +
-                "selected, " +
-                "sync_events, " +
-                "location, " +
-                "timezone, " +
-                "ownerAccount, " +
-                "organizerCanRespond, " +
-                "deleted, " +
-                "sync1) " +
-                "SELECT " +
-                "_id, " +
-                "_sync_account, " +
-                "_sync_account_type, " +
-                "_sync_id, " +
-                "_sync_version, " +
-                "_sync_time, " +
-                "_sync_local_id, " +
-                "_sync_dirty, " +
-                "_sync_mark, " +
-                "name, " +
-                "displayName, " +
-                "color, " +
-                "access_level, " +
-                "selected, " +
-                "sync_events, " +
-                "location, " +
-                "timezone, " +
-                "ownerAccount, " +
-                "organizerCanRespond, " +
-                "0, " +
-                "url " +
-                "FROM Calendars_Backup;"
-        );
-
-        // Populate SYNC2 and SYNC3 columns - SYNC1 represent the old "url" column
-        // We will need to iterate over all the "com.google" type of calendars
-        String selectSql = "SELECT _id, url" +
-                " FROM Calendars_Backup" +
-                " WHERE _sync_account_type='com.google'" +
-                " AND url IS NOT NULL;";
-
-        String updateSql = "UPDATE Calendars SET " +
-                "sync2=?, " + // edit Url
-                "sync3=? " + // self Url
-                "WHERE _id=?;";
-
-        Cursor cursor = db.rawQuery(selectSql, null /* selection args */);
-        if (cursor != null) {
-            try {
-                if (cursor.getCount() > 0) {
-                    Object[] bindArgs = new Object[3];
-                    while (cursor.moveToNext()) {
-                        Long id = cursor.getLong(0);
-                        String url = cursor.getString(1);
-                        String selfUrl = getSelfUrlFromEventsUrl(url);
-                        String editUrl = getEditUrlFromEventsUrl(url);
-
-                        bindArgs[0] = editUrl;
-                        bindArgs[1] = selfUrl;
-                        bindArgs[2] = id;
-
-                        db.execSQL(updateSql, bindArgs);
-                    }
-                }
-            } finally {
-                cursor.close();
-            }
-        }
-
-        // Drop the backup table
-        db.execSQL("DROP TABLE Calendars_Backup;");
-    }
-
-    @VisibleForTesting
-    public static void upgradeToVersion69(SQLiteDatabase db) {
-        // Clean up allDay events which could be in an invalid state from an earlier version
-        // Some allDay events had hour, min, sec not set to zero, which throws elsewhere. This
-        // will go through the allDay events and make sure they have proper values and are in the
-        // correct timezone. Verifies that dtstart and dtend are in UTC and at midnight, that
-        // eventTimezone is set to UTC, tries to make sure duration is in days, and that dtstart2
-        // and dtend2 are at midnight in their timezone.
-        final String sql = "SELECT _id, " +
-                "dtstart, " +
-                "dtend, " +
-                "duration, " +
-                "dtstart2, " +
-                "dtend2, " +
-                "eventTimezone, " +
-                "eventTimezone2, " +
-                "rrule " +
-                "FROM Events " +
-                "WHERE allDay=?";
-        Cursor cursor = db.rawQuery(sql, new String[] {"1"});
-        if (cursor != null) {
-            try {
-                String timezone;
-                String timezone2;
-                String duration;
-                Long dtstart;
-                Long dtstart2;
-                Long dtend;
-                Long dtend2;
-                Time time = new Time();
-                Long id;
-                // some things need to be in utc so we call this frequently, cache to make faster
-                final String utc = Time.TIMEZONE_UTC;
-                while (cursor.moveToNext()) {
-                    String rrule = cursor.getString(8);
-                    id = cursor.getLong(0);
-                    dtstart = cursor.getLong(1);
-                    dtstart2 = null;
-                    timezone = cursor.getString(6);
-                    timezone2 = cursor.getString(7);
-                    duration = cursor.getString(3);
-
-                    if (TextUtils.isEmpty(rrule)) {
-                        // For non-recurring events dtstart and dtend should both have values
-                        // and duration should be null.
-                        dtend = cursor.getLong(2);
-                        dtend2 = null;
-                        // Since we made all three of these at the same time if timezone2 exists
-                        // so should dtstart2 and dtend2.
-                        if(!TextUtils.isEmpty(timezone2)) {
-                            dtstart2 = cursor.getLong(4);
-                            dtend2 = cursor.getLong(5);
-                        }
-
-                        boolean update = false;
-                        if (!TextUtils.equals(timezone, utc)) {
-                            update = true;
-                            timezone = utc;
-                        }
-
-                        time.clear(timezone);
-                        update |= fixAllDayTime(time, timezone, dtstart);
-                        dtstart = time.normalize(false);
-
-                        time.clear(timezone);
-                        update |= fixAllDayTime(time, timezone, dtend);
-                        dtend = time.normalize(false);
-
-                        if (dtstart2 != null) {
-                            time.clear(timezone2);
-                            update |= fixAllDayTime(time, timezone2, dtstart2);
-                            dtstart2 = time.normalize(false);
-                        }
-
-                        if (dtend2 != null) {
-                            time.clear(timezone2);
-                            update |= fixAllDayTime(time, timezone2, dtend2);
-                            dtend2 = time.normalize(false);
-                        }
-
-                        if (!TextUtils.isEmpty(duration)) {
-                            update = true;
-                        }
-
-                        if (update) {
-                            // enforce duration being null
-                            db.execSQL("UPDATE Events SET " +
-                                    "dtstart=?, " +
-                                    "dtend=?, " +
-                                    "dtstart2=?, " +
-                                    "dtend2=?, " +
-                                    "duration=?, " +
-                                    "eventTimezone=?, " +
-                                    "eventTimezone2=? " +
-                                    "WHERE _id=?",
-                                    new Object[] {
-                                            dtstart,
-                                            dtend,
-                                            dtstart2,
-                                            dtend2,
-                                            null,
-                                            timezone,
-                                            timezone2,
-                                            id}
-                            );
-                        }
-
-                    } else {
-                        // For recurring events only dtstart and duration should be used.
-                        // We ignore dtend since it will be overwritten if the event changes to a
-                        // non-recurring event and won't be used otherwise.
-                        if(!TextUtils.isEmpty(timezone2)) {
-                            dtstart2 = cursor.getLong(4);
-                        }
-
-                        boolean update = false;
-                        if (!TextUtils.equals(timezone, utc)) {
-                            update = true;
-                            timezone = utc;
-                        }
-
-                        time.clear(timezone);
-                        update |= fixAllDayTime(time, timezone, dtstart);
-                        dtstart = time.normalize(false);
-
-                        if (dtstart2 != null) {
-                            time.clear(timezone2);
-                            update |= fixAllDayTime(time, timezone2, dtstart2);
-                            dtstart2 = time.normalize(false);
-                        }
-
-                        if (TextUtils.isEmpty(duration)) {
-                            // If duration was missing assume a 1 day duration
-                            duration = "P1D";
-                            update = true;
-                        } else {
-                            int len = duration.length();
-                            // TODO fix durations in other formats as well
-                            if (duration.charAt(0) == 'P' &&
-                                    duration.charAt(len - 1) == 'S') {
-                                int seconds = Integer.parseInt(duration.substring(1, len - 1));
-                                int days = (seconds + DAY_IN_SECONDS - 1) / DAY_IN_SECONDS;
-                                duration = "P" + days + "D";
-                                update = true;
-                            }
-                        }
-
-                        if (update) {
-                            // If there were other problems also enforce dtend being null
-                            db.execSQL("UPDATE Events SET " +
-                                    "dtstart=?, " +
-                                    "dtend=?, " +
-                                    "dtstart2=?, " +
-                                    "dtend2=?, " +
-                                    "duration=?," +
-                                    "eventTimezone=?, " +
-                                    "eventTimezone2=? " +
-                                    "WHERE _id=?",
-                                    new Object[] {
-                                            dtstart,
-                                            null,
-                                            dtstart2,
-                                            null,
-                                            duration,
-                                            timezone,
-                                            timezone2,
-                                            id}
-                            );
-                        }
-                    }
-                }
-            } finally {
-                cursor.close();
-            }
-        }
-    }
-
-    private void upgradeToVersion66(SQLiteDatabase db) {
-        // Add a column to indicate whether the event organizer can respond to his own events
-        // The UI should not show attendee status for events in calendars with this column = 0
-        db.execSQL("ALTER TABLE Calendars" +
-                " ADD COLUMN organizerCanRespond INTEGER NOT NULL DEFAULT 1;");
-    }
-
-    private void upgradeToVersion64(SQLiteDatabase db) {
-        // Add a column that may be used by sync adapters
-        db.execSQL("ALTER TABLE Events" +
-                " ADD COLUMN syncAdapterData TEXT;");
-    }
-
-    private void upgradeToVersion62(SQLiteDatabase db) {
-        // New columns are to transition to having allDay events in the local timezone
-        db.execSQL("ALTER TABLE Events" +
-                " ADD COLUMN dtstart2 INTEGER;");
-        db.execSQL("ALTER TABLE Events" +
-                " ADD COLUMN dtend2 INTEGER;");
-        db.execSQL("ALTER TABLE Events" +
-                " ADD COLUMN eventTimezone2 TEXT;");
-
-        String[] allDayBit = new String[] {"0"};
-        // Copy over all the data that isn't an all day event.
-        db.execSQL("UPDATE Events SET " +
-                "dtstart2=dtstart," +
-                "dtend2=dtend," +
-                "eventTimezone2=eventTimezone " +
-                "WHERE allDay=?;",
-                allDayBit /* selection args */);
-
-        // "cursor" iterates over all the calendars
-        allDayBit[0] = "1";
-        Cursor cursor = db.rawQuery("SELECT Events._id," +
-                "dtstart," +
-                "dtend," +
-                "eventTimezone," +
-                "timezone " +
-                "FROM Events INNER JOIN Calendars " +
-                "WHERE Events.calendar_id=Calendars._id" +
-                " AND allDay=?",
-                allDayBit /* selection args */);
-
-        Time oldTime = new Time();
-        Time newTime = new Time();
-        // Update the allday events in the new columns
-        if (cursor != null) {
-            try {
-                String[] newData = new String[4];
-                cursor.moveToPosition(-1);
-                while (cursor.moveToNext()) {
-                    long id = cursor.getLong(0); // Order from query above
-                    long dtstart = cursor.getLong(1);
-                    long dtend = cursor.getLong(2);
-                    String eTz = cursor.getString(3); // current event timezone
-                    String tz = cursor.getString(4); // Calendar timezone
-                    //If there's no timezone for some reason use UTC by default.
-                    if(eTz == null) {
-                        eTz = Time.TIMEZONE_UTC;
-                    }
-
-                    // Convert start time for all day events into the timezone of their calendar
-                    oldTime.clear(eTz);
-                    oldTime.set(dtstart);
-                    newTime.clear(tz);
-                    newTime.set(oldTime.monthDay, oldTime.month, oldTime.year);
-                    newTime.normalize(false);
-                    dtstart = newTime.toMillis(false /*ignoreDst*/);
-
-                    // Convert end time for all day events into the timezone of their calendar
-                    oldTime.clear(eTz);
-                    oldTime.set(dtend);
-                    newTime.clear(tz);
-                    newTime.set(oldTime.monthDay, oldTime.month, oldTime.year);
-                    newTime.normalize(false);
-                    dtend = newTime.toMillis(false /*ignoreDst*/);
-
-                    newData[0] = String.valueOf(dtstart);
-                    newData[1] = String.valueOf(dtend);
-                    newData[2] = tz;
-                    newData[3] = String.valueOf(id);
-                    db.execSQL("UPDATE Events SET " +
-                            "dtstart2=?, " +
-                            "dtend2=?, " +
-                            "eventTimezone2=? " +
-                            "WHERE _id=?",
-                            newData);
-                }
-            } finally {
-                cursor.close();
-            }
-        }
-    }
-
-    private void upgradeToVersion61(SQLiteDatabase db) {
-        db.execSQL("DROP TABLE IF EXISTS CalendarCache;");
-
-        // IF NOT EXISTS should be normal pattern for table creation
-        db.execSQL("CREATE TABLE IF NOT EXISTS CalendarCache (" +
-                "_id INTEGER PRIMARY KEY," +
-                "key TEXT NOT NULL," +
-                "value TEXT" +
-                ");");
-
-        db.execSQL("INSERT INTO CalendarCache (" +
-                "key, " +
-                "value) VALUES (" +
-                "'timezoneDatabaseVersion',"  +
-                "'2009s'" +
-                ");");
-    }
-
-    private void upgradeToVersion60(SQLiteDatabase db) {
-        // Switch to CalendarProvider2
-        upgradeSyncState(db);
-        db.execSQL("DROP TRIGGER IF EXISTS calendar_cleanup");
-        db.execSQL("CREATE TRIGGER calendar_cleanup DELETE ON Calendars " +
-                "BEGIN " +
-                ("DELETE FROM Events" +
-                        " WHERE calendar_id=old._id;") +
-                "END");
-        db.execSQL("ALTER TABLE Events" +
-                " ADD COLUMN deleted INTEGER NOT NULL DEFAULT 0;");
-        db.execSQL("DROP TRIGGER IF EXISTS events_insert");
-        // Trigger to set event's sync_account
-        db.execSQL("CREATE TRIGGER events_insert AFTER INSERT ON Events " +
-                "BEGIN " +
-                "UPDATE Events" +
-                " SET _sync_account=" +
-                " (SELECT _sync_account FROM Calendars" +
-                " WHERE Calendars._id=new.calendar_id)," +
-                "_sync_account_type=" +
-                " (SELECT _sync_account_type FROM Calendars" +
-                " WHERE Calendars._id=new.calendar_id) " +
-                "WHERE Events._id=new._id;" +
-                "END");
-        db.execSQL("DROP TABLE IF EXISTS DeletedEvents;");
-        db.execSQL("DROP TRIGGER IF EXISTS events_cleanup_delete");
-        // Trigger to remove data tied to an event when we delete that event.
-        db.execSQL("CREATE TRIGGER events_cleanup_delete DELETE ON Events " +
-                "BEGIN " +
-                ("DELETE FROM Instances" +
-                    " WHERE event_id=old._id;" +
-                "DELETE FROM EventsRawTimes" +
-                    " WHERE event_id=old._id;" +
-                "DELETE FROM Attendees" +
-                    " WHERE event_id=old._id;" +
-                "DELETE FROM Reminders" +
-                    " WHERE event_id=old._id;" +
-                "DELETE FROM CalendarAlerts" +
-                    " WHERE event_id=old._id;" +
-                "DELETE FROM ExtendedProperties" +
-                    " WHERE event_id=old._id;") +
-                "END");
-        db.execSQL("DROP TRIGGER IF EXISTS attendees_update");
-        db.execSQL("DROP TRIGGER IF EXISTS attendees_insert");
-        db.execSQL("DROP TRIGGER IF EXISTS attendees_delete");
-        db.execSQL("DROP TRIGGER IF EXISTS reminders_update");
-        db.execSQL("DROP TRIGGER IF EXISTS reminders_insert");
-        db.execSQL("DROP TRIGGER IF EXISTS reminders_delete");
-        db.execSQL("DROP TRIGGER IF EXISTS extended_properties_update");
-        db.execSQL("DROP TRIGGER IF EXISTS extended_properties_insert");
-        db.execSQL("DROP TRIGGER IF EXISTS extended_properties_delete");
-    }
-
-    private void upgradeToVersion59(SQLiteDatabase db) {
-        db.execSQL("DROP TABLE IF EXISTS BusyBits;");
-        db.execSQL("CREATE TEMPORARY TABLE CalendarMetaData_Backup(" +
-                "_id," +
-                "localTimezone," +
-                "minInstance," +
-                "maxInstance" +
-                ");");
-        db.execSQL("INSERT INTO CalendarMetaData_Backup " +
-                "SELECT " +
-                "_id," +
-                "localTimezone," +
-                "minInstance," +
-                "maxInstance" +
-                " FROM CalendarMetaData;");
-        db.execSQL("DROP TABLE CalendarMetaData;");
-        createCalendarMetaDataTable59(db);
-        db.execSQL("INSERT INTO CalendarMetaData " +
-                "SELECT " +
-                "_id," +
-                "localTimezone," +
-                "minInstance," +
-                "maxInstance" +
-                " FROM CalendarMetaData_Backup;");
-        db.execSQL("DROP TABLE CalendarMetaData_Backup;");
-    }
-
-    private void upgradeToVersion57(SQLiteDatabase db) {
-        db.execSQL("ALTER TABLE Events" +
-                " ADD COLUMN guestsCanModify" +
-                " INTEGER NOT NULL DEFAULT 0;");
-        db.execSQL("ALTER TABLE Events" +
-                " ADD COLUMN guestsCanInviteOthers" +
-                " INTEGER NOT NULL DEFAULT 1;");
-        db.execSQL("ALTER TABLE Events" +
-                " ADD COLUMN guestsCanSeeGuests" +
-                " INTEGER NOT NULL DEFAULT 1;");
-        db.execSQL("ALTER TABLE Events" +
-                " ADD COLUMN organizer" +
-                " STRING;");
-        db.execSQL("UPDATE Events SET organizer=" +
-                "(SELECT attendeeEmail" +
-                " FROM Attendees"  +
-                " WHERE " +
-                "Attendees.event_id=" +
-                "Events._id" +
-                " AND " +
-                "Attendees.attendeeRelationship=2);");
-    }
-
-    private void upgradeToVersion56(SQLiteDatabase db) {
-        db.execSQL("ALTER TABLE Calendars" +
-                " ADD COLUMN ownerAccount TEXT;");
-        db.execSQL("ALTER TABLE Events" +
-                " ADD COLUMN hasAttendeeData INTEGER NOT NULL DEFAULT 0;");
-
-        // Clear _sync_dirty to avoid a client-to-server sync that could blow away
-        // server attendees.
-        // Clear _sync_version to pull down the server's event (with attendees)
-        // Change the URLs from full-selfattendance to full
-        db.execSQL("UPDATE Events"
-                + " SET _sync_dirty=0, "
-                + "_sync_version=NULL, "
-                + "_sync_id="
-                + "REPLACE(_sync_id, " +
-                    "'/private/full-selfattendance', '/private/full'),"
-                + "commentsUri="
-                + "REPLACE(commentsUri, " +
-                    "'/private/full-selfattendance', '/private/full');");
-
-        db.execSQL("UPDATE Calendars"
-                + " SET url="
-                + "REPLACE(url, '/private/full-selfattendance', '/private/full');");
-
-        // "cursor" iterates over all the calendars
-        Cursor cursor = db.rawQuery("SELECT _id, " +
-                "url FROM Calendars",
-                null /* selection args */);
-        // Add the owner column.
-        if (cursor != null) {
-            try {
-                final String updateSql = "UPDATE Calendars" +
-                        " SET ownerAccount=?" +
-                        " WHERE _id=?";
-                while (cursor.moveToNext()) {
-                    Long id = cursor.getLong(0);
-                    String url = cursor.getString(1);
-                    String owner = calendarEmailAddressFromFeedUrl(url);
-                    db.execSQL(updateSql, new Object[] {owner, id});
-                }
-            } finally {
-                cursor.close();
-            }
-        }
-    }
-
-    private void upgradeResync(SQLiteDatabase db) {
-        // Delete sync state, so all records will be re-synced.
-        db.execSQL("DELETE FROM _sync_state;");
-
-        // "cursor" iterates over all the calendars
-        Cursor cursor = db.rawQuery("SELECT _sync_account," +
-                "_sync_account_type,url FROM Calendars",
-                null /* selection args */);
-        if (cursor != null) {
-            try {
-                while (cursor.moveToNext()) {
-                    String accountName = cursor.getString(0);
-                    String accountType = cursor.getString(1);
-                    final Account account = new Account(accountName, accountType);
-                    String calendarUrl = cursor.getString(2);
-                    scheduleSync(account, false /* two-way sync */, calendarUrl);
-                }
-            } finally {
-                cursor.close();
-            }
-        }
-    }
-
-    private void upgradeToVersion55(SQLiteDatabase db) {
-        db.execSQL("ALTER TABLE Calendars ADD COLUMN " +
-                "_sync_account_type TEXT;");
-        db.execSQL("ALTER TABLE Events ADD COLUMN " +
-                "_sync_account_type TEXT;");
-        db.execSQL("ALTER TABLE DeletedEvents ADD COLUMN _sync_account_type TEXT;");
-        db.execSQL("UPDATE Calendars"
-                + " SET _sync_account_type='com.google'"
-                + " WHERE _sync_account IS NOT NULL");
-        db.execSQL("UPDATE Events"
-                + " SET _sync_account_type='com.google'"
-                + " WHERE _sync_account IS NOT NULL");
-        db.execSQL("UPDATE DeletedEvents"
-                + " SET _sync_account_type='com.google'"
-                + " WHERE _sync_account IS NOT NULL");
-        Log.w(TAG, "re-creating eventSyncAccountAndIdIndex");
-        db.execSQL("DROP INDEX eventSyncAccountAndIdIndex");
-        db.execSQL("CREATE INDEX eventSyncAccountAndIdIndex ON Events ("
-                + "_sync_account_type, "
-                + "_sync_account, "
-                + "_sync_id);");
-    }
-
-    private void upgradeToVersion54(SQLiteDatabase db) {
-        Log.w(TAG, "adding eventSyncAccountAndIdIndex");
-        db.execSQL("CREATE INDEX eventSyncAccountAndIdIndex ON Events ("
-                + "_sync_account, _sync_id);");
-    }
-
-    private void upgradeToVersion53(SQLiteDatabase db) {
-        Log.w(TAG, "Upgrading CalendarAlerts table");
-        db.execSQL("ALTER TABLE CalendarAlerts ADD COLUMN " +
-                "creationTime INTEGER NOT NULL DEFAULT 0;");
-        db.execSQL("ALTER TABLE CalendarAlerts ADD COLUMN " +
-                "receivedTime INTEGER NOT NULL DEFAULT 0;");
-        db.execSQL("ALTER TABLE CalendarAlerts ADD COLUMN " +
-                "notifyTime INTEGER NOT NULL DEFAULT 0;");
-    }
-
-    private void upgradeToVersion52(SQLiteDatabase db) {
-        // We added "originalAllDay" to the Events table to keep track of
-        // the allDay status of the original recurring event for entries
-        // that are exceptions to that recurring event.  We need this so
-        // that we can format the date correctly for the "originalInstanceTime"
-        // column when we make a change to the recurrence exception and
-        // send it to the server.
-        db.execSQL("ALTER TABLE Events ADD COLUMN " +
-                "originalAllDay INTEGER;");
-
-        // Iterate through the Events table and for each recurrence
-        // exception, fill in the correct value for "originalAllDay",
-        // if possible.  The only times where this might not be possible
-        // are (1) the original recurring event no longer exists, or
-        // (2) the original recurring event does not yet have a _sync_id
-        // because it was created on the phone and hasn't been synced to the
-        // server yet.  In both cases the originalAllDay field will be set
-        // to null.  In the first case we don't care because the recurrence
-        // exception will not be displayed and we won't be able to make
-        // any changes to it (and even if we did, the server should ignore
-        // them, right?).  In the second case, the calendar client already
-        // disallows making changes to an instance of a recurring event
-        // until the recurring event has been synced to the server so the
-        // second case should never occur.
-
-        // "cursor" iterates over all the recurrences exceptions.
-        Cursor cursor = db.rawQuery("SELECT _id," +
-                "originalEvent" +
-                " FROM Events" +
-                " WHERE originalEvent IS NOT NULL",
-                null /* selection args */);
-        if (cursor != null) {
-            try {
-                while (cursor.moveToNext()) {
-                    long id = cursor.getLong(0);
-                    String originalEvent = cursor.getString(1);
-
-                    // Find the original recurring event (if it exists)
-                    Cursor recur = db.rawQuery("SELECT allDay" +
-                            " FROM Events" +
-                            " WHERE _sync_id=?",
-                            new String[] {originalEvent});
-                    if (recur == null) {
-                        continue;
-                    }
-
-                    try {
-                        // Fill in the "originalAllDay" field of the
-                        // recurrence exception with the "allDay" value
-                        // from the recurring event.
-                        if (recur.moveToNext()) {
-                            int allDay = recur.getInt(0);
-                            db.execSQL("UPDATE Events" +
-                                    " SET originalAllDay=" + allDay +
-                                    " WHERE _id="+id);
-                        }
-                    } finally {
-                        recur.close();
-                    }
-                }
-            } finally {
-                cursor.close();
-            }
-        }
-    }
-
-    private void upgradeToVersion51(SQLiteDatabase db) {
-        Log.w(TAG, "Upgrading DeletedEvents table");
-
-        // We don't have enough information to fill in the correct
-        // value of the calendar_id for old rows in the DeletedEvents
-        // table, but rows in that table are transient so it is unlikely
-        // that there are any rows.  Plus, the calendar_id is used only
-        // when deleting a calendar, which is a rare event.  All new rows
-        // will have the correct calendar_id.
-        db.execSQL("ALTER TABLE DeletedEvents ADD COLUMN calendar_id INTEGER;");
-
-        // Trigger to remove a calendar's events when we delete the calendar
-        db.execSQL("DROP TRIGGER IF EXISTS calendar_cleanup");
-        db.execSQL("CREATE TRIGGER calendar_cleanup DELETE ON Calendars " +
-                "BEGIN " +
-                "DELETE FROM Events WHERE calendar_id=" +
-                    "old._id;" +
-                "DELETE FROM DeletedEvents WHERE calendar_id = old._id;" +
-                "END");
-        db.execSQL("DROP TRIGGER IF EXISTS event_to_deleted");
-    }
-
-    private void dropTables(SQLiteDatabase db) {
-        Log.i(TAG, "Clearing database");
-
-        String[] columns = {
-                "type", "name"
-        };
-        Cursor cursor = db.query("sqlite_master", columns, null, null, null, null, null);
-        if (cursor == null) {
-            return;
-        }
-        try {
-            while (cursor.moveToNext()) {
-                final String name = cursor.getString(1);
-                if (!name.startsWith("sqlite_")) {
-                    // If it's not a SQL-controlled entity, drop it
-                    final String sql = "DROP " + cursor.getString(0) + " IF EXISTS " + name;
-                    try {
-                        db.execSQL(sql);
-                    } catch (SQLException e) {
-                        Log.e(TAG, "Error executing " + sql + " " + e.toString());
-                    }
-                }
-            }
-        } finally {
-            cursor.close();
-        }
-    }
-
-    @Override
-    public synchronized SQLiteDatabase getWritableDatabase() {
-        SQLiteDatabase db = super.getWritableDatabase();
-        return db;
-    }
-
-    public SyncStateContentProviderHelper getSyncState() {
-        return mSyncState;
-    }
-
-    /**
-     * Schedule a calendar sync for the account.
-     * @param account the account for which to schedule a sync
-     * @param uploadChangesOnly if set, specify that the sync should only send
-     *   up local changes.  This is typically used for a local sync, a user override of
-     *   too many deletions, or a sync after a calendar is unselected.
-     * @param url the url feed for the calendar to sync (may be null, in which case a poll of
-     *   all feeds is done.)
-     */
-    void scheduleSync(Account account, boolean uploadChangesOnly, String url) {
-        Bundle extras = new Bundle();
-        if (uploadChangesOnly) {
-            extras.putBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD, uploadChangesOnly);
-        }
-        if (url != null) {
-            extras.putString("feed", url);
-        }
-        ContentResolver.requestSync(account, Calendars.CONTENT_URI.getAuthority(),
-                extras);
-    }
-
-    private static void createEventsView(SQLiteDatabase db) {
-        db.execSQL("DROP VIEW IF EXISTS " + Views.EVENTS + ";");
-        String eventsSelect = "SELECT "
-                + Tables.EVENTS + "." + CalendarContract.Events._ID
-                        + " AS " + CalendarContract.Events._ID + ","
-                + CalendarContract.Events.TITLE + ","
-                + CalendarContract.Events.DESCRIPTION + ","
-                + CalendarContract.Events.EVENT_LOCATION + ","
-                + CalendarContract.Events.EVENT_COLOR + ","
-                + CalendarContract.Events.EVENT_COLOR_KEY + ","
-                + CalendarContract.Events.STATUS + ","
-                + CalendarContract.Events.SELF_ATTENDEE_STATUS + ","
-                + CalendarContract.Events.DTSTART + ","
-                + CalendarContract.Events.DTEND + ","
-                + CalendarContract.Events.DURATION + ","
-                + CalendarContract.Events.EVENT_TIMEZONE + ","
-                + CalendarContract.Events.EVENT_END_TIMEZONE + ","
-                + CalendarContract.Events.ALL_DAY + ","
-                + CalendarContract.Events.ACCESS_LEVEL + ","
-                + CalendarContract.Events.AVAILABILITY + ","
-                + CalendarContract.Events.HAS_ALARM + ","
-                + CalendarContract.Events.HAS_EXTENDED_PROPERTIES + ","
-                + CalendarContract.Events.RRULE + ","
-                + CalendarContract.Events.RDATE + ","
-                + CalendarContract.Events.EXRULE + ","
-                + CalendarContract.Events.EXDATE + ","
-                + CalendarContract.Events.ORIGINAL_SYNC_ID + ","
-                + CalendarContract.Events.ORIGINAL_ID + ","
-                + CalendarContract.Events.ORIGINAL_INSTANCE_TIME + ","
-                + CalendarContract.Events.ORIGINAL_ALL_DAY + ","
-                + CalendarContract.Events.LAST_DATE + ","
-                + CalendarContract.Events.HAS_ATTENDEE_DATA + ","
-                + CalendarContract.Events.CALENDAR_ID + ","
-                + CalendarContract.Events.GUESTS_CAN_INVITE_OTHERS + ","
-                + CalendarContract.Events.GUESTS_CAN_MODIFY + ","
-                + CalendarContract.Events.GUESTS_CAN_SEE_GUESTS + ","
-                + CalendarContract.Events.ORGANIZER + ","
-                + "COALESCE("
-                + Events.IS_ORGANIZER + ", " + Events.ORGANIZER + " = " + Calendars.OWNER_ACCOUNT
-                + ") AS " + Events.IS_ORGANIZER + ","
-                + CalendarContract.Events.CUSTOM_APP_PACKAGE + ","
-                + CalendarContract.Events.CUSTOM_APP_URI + ","
-                + CalendarContract.Events.UID_2445 + ","
-                + CalendarContract.Events.SYNC_DATA1 + ","
-                + CalendarContract.Events.SYNC_DATA2 + ","
-                + CalendarContract.Events.SYNC_DATA3 + ","
-                + CalendarContract.Events.SYNC_DATA4 + ","
-                + CalendarContract.Events.SYNC_DATA5 + ","
-                + CalendarContract.Events.SYNC_DATA6 + ","
-                + CalendarContract.Events.SYNC_DATA7 + ","
-                + CalendarContract.Events.SYNC_DATA8 + ","
-                + CalendarContract.Events.SYNC_DATA9 + ","
-                + CalendarContract.Events.SYNC_DATA10 + ","
-                + Tables.EVENTS + "." + CalendarContract.Events.DELETED
-                + " AS " + CalendarContract.Events.DELETED + ","
-                + Tables.EVENTS + "." + CalendarContract.Events._SYNC_ID
-                + " AS " + CalendarContract.Events._SYNC_ID + ","
-                + Tables.EVENTS + "." + CalendarContract.Events.DIRTY
-                + " AS " + CalendarContract.Events.DIRTY + ","
-                + Tables.EVENTS + "." + Events.MUTATORS
-                + " AS " + Events.MUTATORS + ","
-                + CalendarContract.Events.LAST_SYNCED + ","
-                + Tables.CALENDARS + "." + Calendars.ACCOUNT_NAME
-                + " AS " + CalendarContract.Events.ACCOUNT_NAME + ","
-                + Tables.CALENDARS + "." + Calendars.ACCOUNT_TYPE
-                + " AS " + CalendarContract.Events.ACCOUNT_TYPE + ","
-                + Calendars.CALENDAR_TIME_ZONE + ","
-                + Calendars.CALENDAR_DISPLAY_NAME + ","
-                + Calendars.CALENDAR_LOCATION + ","
-                + Calendars.VISIBLE + ","
-                + Calendars.CALENDAR_COLOR + ","
-                + Calendars.CALENDAR_COLOR_KEY + ","
-                + Calendars.CALENDAR_ACCESS_LEVEL + ","
-                + Calendars.MAX_REMINDERS + ","
-                + Calendars.ALLOWED_REMINDERS + ","
-                + Calendars.ALLOWED_ATTENDEE_TYPES + ","
-                + Calendars.ALLOWED_AVAILABILITY + ","
-                + Calendars.CAN_ORGANIZER_RESPOND + ","
-                + Calendars.CAN_MODIFY_TIME_ZONE + ","
-                + Calendars.CAN_PARTIALLY_UPDATE + ","
-                + Calendars.CAL_SYNC1 + ","
-                + Calendars.CAL_SYNC2 + ","
-                + Calendars.CAL_SYNC3 + ","
-                + Calendars.CAL_SYNC4 + ","
-                + Calendars.CAL_SYNC5 + ","
-                + Calendars.CAL_SYNC6 + ","
-                + Calendars.CAL_SYNC7 + ","
-                + Calendars.CAL_SYNC8 + ","
-                + Calendars.CAL_SYNC9 + ","
-                + Calendars.CAL_SYNC10 + ","
-                + Calendars.OWNER_ACCOUNT + ","
-                + Calendars.SYNC_EVENTS  + ","
-                + "ifnull(" + Events.EVENT_COLOR + "," + Calendars.CALENDAR_COLOR + ") AS "
-                + Events.DISPLAY_COLOR
-                + " FROM " + Tables.EVENTS + " JOIN " + Tables.CALENDARS
-                + " ON (" + Tables.EVENTS + "." + Events.CALENDAR_ID
-                + "=" + Tables.CALENDARS + "." + Calendars._ID
-                + ")";
-
-        db.execSQL("CREATE VIEW " + Views.EVENTS + " AS " + eventsSelect);
-    }
-
-    /**
-     * Extracts the calendar email from a calendar feed url.
-     * @param feed the calendar feed url
-     * @return the calendar email that is in the feed url or null if it can't
-     * find the email address.
-     * TODO: this is duplicated in CalendarSyncAdapter; move to a library
-     */
-    public static String calendarEmailAddressFromFeedUrl(String feed) {
-        // Example feed url:
-        // https://www.google.com/calendar/feeds/foo%40gmail.com/private/full-noattendees
-        String[] pathComponents = feed.split("/");
-        if (pathComponents.length > 5 && "feeds".equals(pathComponents[4])) {
-            try {
-                return URLDecoder.decode(pathComponents[5], "UTF-8");
-            } catch (UnsupportedEncodingException e) {
-                Log.e(TAG, "unable to url decode the email address in calendar " + feed);
-                return null;
-            }
-        }
-
-        Log.e(TAG, "unable to find the email address in calendar " + feed);
-        return null;
-    }
-
-    /**
-     * Get a "allcalendars" url from a "private/full" or "private/free-busy" url
-     * @param url
-     * @return the rewritten Url
-     *
-     * For example:
-     *
-     *      http://www.google.com/calendar/feeds/joe%40joe.com/private/full
-     *      http://www.google.com/calendar/feeds/joe%40joe.com/private/free-busy
-     *
-     * will be rewriten into:
-     *
-     *      http://www.google.com/calendar/feeds/default/allcalendars/full/joe%40joe.com
-     *      http://www.google.com/calendar/feeds/default/allcalendars/full/joe%40joe.com
-     */
-    private static String getAllCalendarsUrlFromEventsUrl(String url) {
-        if (url == null) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Cannot get AllCalendars url from a NULL url");
-            }
-            return null;
-        }
-        if (url.contains("/private/full")) {
-            return url.replace("/private/full", "").
-                    replace("/calendar/feeds", "/calendar/feeds/default/allcalendars/full");
-        }
-        if (url.contains("/private/free-busy")) {
-            return url.replace("/private/free-busy", "").
-                    replace("/calendar/feeds", "/calendar/feeds/default/allcalendars/full");
-        }
-        // Just log as we dont recognize the provided Url
-        if (Log.isLoggable(TAG, Log.DEBUG)) {
-            Log.d(TAG, "Cannot get AllCalendars url from the following url: " + url);
-        }
-        return null;
-    }
-
-    /**
-     * Get "selfUrl" from "events url"
-     * @param url the Events url (either "private/full" or "private/free-busy"
-     * @return the corresponding allcalendar url
-     */
-    private static String getSelfUrlFromEventsUrl(String url) {
-        return rewriteUrlFromHttpToHttps(getAllCalendarsUrlFromEventsUrl(url));
-    }
-
-    /**
-     * Get "editUrl" from "events url"
-     * @param url the Events url (either "private/full" or "private/free-busy"
-     * @return the corresponding allcalendar url
-     */
-    private static String getEditUrlFromEventsUrl(String url) {
-        return rewriteUrlFromHttpToHttps(getAllCalendarsUrlFromEventsUrl(url));
-    }
-
-    /**
-     * Rewrite the url from "http" to "https" scheme
-     * @param url the url to rewrite
-     * @return the rewritten URL
-     */
-    private static String rewriteUrlFromHttpToHttps(String url) {
-        if (url == null) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Cannot rewrite a NULL url");
-            }
-            return null;
-        }
-        if (url.startsWith(SCHEMA_HTTPS)) {
-            return url;
-        }
-        if (!url.startsWith(SCHEMA_HTTP)) {
-            throw new IllegalArgumentException("invalid url parameter, unknown scheme: " + url);
-        }
-        return SCHEMA_HTTPS + url.substring(SCHEMA_HTTP.length());
-    }
-
-    /**
-     * Duplicates an event and its associated tables (Attendees, Reminders, ExtendedProperties).
-     * <p>
-     * Does not create a duplicate if the Calendar's "canPartiallyUpdate" is 0 or the Event's
-     * "dirty" is 1 (so we don't create more than one duplicate).
-     *
-     * @param id The _id of the event to duplicate.
-     */
-    protected void duplicateEvent(final long id) {
-        final SQLiteDatabase db = getWritableDatabase();
-        /* SPRD: Add for Bug499531, add SQLiteDoneException. @{*/
-        try {
-            final long canPartiallyUpdate = DatabaseUtils.longForQuery(db,
-                    "SELECT " + Calendars.CAN_PARTIALLY_UPDATE + " FROM "
-                            + Views.EVENTS + " WHERE " + Events._ID + " = ?",
-                    new String[] { String.valueOf(id) });
-            if (canPartiallyUpdate == 0) {
-                return;
-            }
-        } catch (SQLiteDoneException e) {
-            return;
-        }
-
-        db.execSQL("INSERT INTO " + CalendarDatabaseHelper.Tables.EVENTS
-                + "  (" + LAST_SYNCED_EVENT_COLUMNS + ","
-                +         Events.DIRTY + "," + Events.LAST_SYNCED + ")"
-                + " SELECT " + LAST_SYNCED_EVENT_COLUMNS + ", 0, 1"
-                + " FROM " + Tables.EVENTS
-                + " WHERE "  + Events._ID + " = ? AND " + Events.DIRTY + " = ?",
-                new Object[]{
-                        id,
-                        0, // Events.DIRTY
-                });
-        final long newId = DatabaseUtils.longForQuery(
-                db, "SELECT CASE changes() WHEN 0 THEN -1 ELSE last_insert_rowid() END", null);
-        if (newId < 0) {
-            return;
-        }
-
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "Duplicating event " + id + " into new event " + newId);
-        }
-
-        copyEventRelatedTables(db, newId, id);
-    }
-
-    /**
-     * Makes a copy of the Attendees, Reminders, and ExtendedProperties rows associated with
-     * a specific event.
-     *
-     * @param db The database.
-     * @param newId The ID of the new event.
-     * @param id The ID of the old event.
-     */
-    static void copyEventRelatedTables(SQLiteDatabase db, long newId, long id) {
-        db.execSQL("INSERT INTO " + Tables.REMINDERS
-                + " ( "  + CalendarContract.Reminders.EVENT_ID + ", "
-                        + LAST_SYNCED_REMINDER_COLUMNS + ") "
-                + "SELECT ?," + LAST_SYNCED_REMINDER_COLUMNS
-                + " FROM " + Tables.REMINDERS
-                + " WHERE " + CalendarContract.Reminders.EVENT_ID + " = ?",
-                new Object[] {newId, id});
-        db.execSQL("INSERT INTO "
-                + Tables.ATTENDEES
-                + " (" + CalendarContract.Attendees.EVENT_ID + ","
-                        + LAST_SYNCED_ATTENDEE_COLUMNS + ") "
-                + "SELECT ?," + LAST_SYNCED_ATTENDEE_COLUMNS + " FROM " + Tables.ATTENDEES
-                + " WHERE " + CalendarContract.Attendees.EVENT_ID + " = ?",
-                new Object[] {newId, id});
-        db.execSQL("INSERT INTO " + Tables.EXTENDED_PROPERTIES
-                + " (" + CalendarContract.ExtendedProperties.EVENT_ID + ","
-                + LAST_SYNCED_EXTENDED_PROPERTY_COLUMNS + ") "
-                + "SELECT ?, " + LAST_SYNCED_EXTENDED_PROPERTY_COLUMNS
-                + " FROM " + Tables.EXTENDED_PROPERTIES
-                + " WHERE " + CalendarContract.ExtendedProperties.EVENT_ID + " = ?",
-                new Object[]{newId, id});
-    }
-
-    protected void removeDuplicateEvent(final long id) {
-        final SQLiteDatabase db = getWritableDatabase();
-        final Cursor cursor = db.rawQuery("SELECT " + Events._ID + " FROM " + Tables.EVENTS
-                + " WHERE " + Events._SYNC_ID
-                + " = (SELECT " + Events._SYNC_ID
-                + " FROM " + Tables.EVENTS
-                + " WHERE " + Events._ID + " = ?) "
-                + "AND " + Events.LAST_SYNCED + " = ?",
-                new String[]{
-                        String.valueOf(id),
-                        "1", // Events.LAST_SYNCED
-                });
-        try {
-            // there should only be at most one but this can't hurt
-            if (cursor.moveToNext()) {
-                final long dupId = cursor.getLong(0);
-
-                if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                    Log.v(TAG, "Removing duplicate event " + dupId + " of original event " + id);
-                }
-                // triggers will clean up related tables.
-                db.execSQL("DELETE FROM Events WHERE " + Events._ID + " = ?", new Object[]{dupId});
-            }
-        } finally {
-          cursor.close();
-        }
-    }
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarReceiver.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarReceiver.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarReceiver.java	(revision 168087)
@@ -1,84 +0,0 @@
-/*
-** Copyright 2006, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** See the License for the specific language governing permissions and
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** limitations under the License.
-*/
-
-package com.android.providers.calendar;
-
-import android.content.BroadcastReceiver;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.Intent;
-import android.os.PowerManager;
-import android.util.Log;
-
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-/**
- * This IntentReceiver executes when the boot completes and ensures that
- * the Calendar provider has started and then initializes the alarm
- * scheduler for the Calendar provider.  This needs to be done after
- * the boot completes because the alarm manager may not have been started
- * yet.
- */
-public class CalendarReceiver extends BroadcastReceiver {
-    private static final String TAG = "CalendarReceiver";
-
-    private final ExecutorService executor = Executors.newCachedThreadPool();
-    private PowerManager.WakeLock mWakeLock;
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        if (mWakeLock == null) {
-            PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
-            mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "CalendarReceiver_Provider");
-            mWakeLock.setReferenceCounted(true);
-        }
-        mWakeLock.acquire();
-
-        final String action = intent.getAction();
-        final ContentResolver cr = context.getContentResolver();
-        final PendingResult result = goAsync();
-        executor.submit(new Runnable() {
-            @Override
-            public void run() {
-                if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {
-                    removeScheduledAlarms(cr);
-                }
-                result.finish();
-                mWakeLock.release();
-            }
-        });
-    }
-
-    /*
-     * Remove alarms from the CalendarAlerts table that have been marked
-     * as "scheduled" but not fired yet.  We do this because the
-     * AlarmManagerService loses all information about alarms when the
-     * power turns off but we store the information in a database table
-     * that persists across reboots. See the documentation for
-     * scheduleNextAlarmLocked() for more information.
-     *
-     * We don't expect this to be called more than once.  If it were, we would have to
-     * worry about serializing the use of the service.
-     */
-    private void removeScheduledAlarms(ContentResolver resolver) {
-        if (Log.isLoggable(TAG, Log.DEBUG)) {
-            Log.d(TAG, "Removing scheduled alarms");
-        }
-        resolver.update(CalendarAlarmManager.SCHEDULE_ALARM_REMOVE_URI, null /* values */,
-                null /* where */, null /* selectionArgs */);
-    }
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarDebugReceiver.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarDebugReceiver.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarDebugReceiver.java	(revision 168087)
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.calendar;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-
-
-public class CalendarDebugReceiver extends BroadcastReceiver {
-
-    public CalendarDebugReceiver() {
-    }
-
-    /**
-     * Receives android.provider.Telephony.Intents.SECRET_CODE_ACTION and
-     * displays debugging information.
-     */
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        Intent i = new Intent(Intent.ACTION_MAIN);
-        i.setClass(context, CalendarDebug.class);
-        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        context.startActivity(i);
-    }
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarProvider2.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarProvider2.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarProvider2.java	(revision 168087)
@@ -1,5295 +0,0 @@
-/*
-**
-** Copyright 2006, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** See the License for the specific language governing permissions and
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** limitations under the License.
-*/
-
-package com.android.providers.calendar;
-
-import android.accounts.Account;
-import android.accounts.AccountManager;
-import android.accounts.OnAccountsUpdateListener;
-import android.app.AppOpsManager;
-import android.content.BroadcastReceiver;
-import android.content.ContentResolver;
-import android.content.ContentUris;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.UriMatcher;
-import android.content.pm.PackageManager;
-import android.database.Cursor;
-import android.database.DatabaseUtils;
-import android.database.SQLException;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteQueryBuilder;
-import android.net.Uri;
-import android.os.Binder;
-import android.os.Handler;
-import android.os.Message;
-import android.os.Process;
-import android.provider.BaseColumns;
-import android.provider.CalendarContract;
-import android.provider.CalendarContract.Attendees;
-import android.provider.CalendarContract.CalendarAlerts;
-import android.provider.CalendarContract.Calendars;
-import android.provider.CalendarContract.Colors;
-import android.provider.CalendarContract.Events;
-import android.provider.CalendarContract.Instances;
-import android.provider.CalendarContract.Reminders;
-import android.provider.CalendarContract.SyncState;
-import android.text.TextUtils;
-import android.text.format.DateUtils;
-import android.text.format.Time;
-import android.util.Log;
-import android.util.TimeFormatException;
-import android.util.TimeUtils;
-
-import com.android.calendarcommon2.DateException;
-import com.android.calendarcommon2.Duration;
-import com.android.calendarcommon2.EventRecurrence;
-import com.android.calendarcommon2.RecurrenceProcessor;
-import com.android.calendarcommon2.RecurrenceSet;
-import com.android.providers.calendar.CalendarDatabaseHelper.Tables;
-import com.android.providers.calendar.CalendarDatabaseHelper.Views;
-import com.google.android.collect.Sets;
-import com.google.common.annotations.VisibleForTesting;
-
-import java.io.File;
-import java.lang.reflect.Array;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import java.util.TimeZone;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import android.content.res.AssetFileDescriptor;
-import android.os.ParcelFileDescriptor;
-import android.provider.OpenableColumns;
-import com.sprd.providers.calendar.VCalendarExportSource;
-/**
- * Calendar content provider. The contract between this provider and applications
- * is defined in {@link android.provider.CalendarContract}.
- */
-public class CalendarProvider2 extends SQLiteContentProvider implements OnAccountsUpdateListener {
-
-
-    protected static final String TAG = "CalendarProvider2";
-    // Turn on for b/22449592
-    static final boolean DEBUG_INSTANCES = Log.isLoggable(TAG, Log.DEBUG);
-
-    private static final String TIMEZONE_GMT = "GMT";
-    private static final String ACCOUNT_SELECTION_PREFIX = Calendars.ACCOUNT_NAME + "=? AND "
-            + Calendars.ACCOUNT_TYPE + "=?";
-
-    protected static final boolean PROFILE = false;
-    private static final boolean MULTIPLE_ATTENDEES_PER_EVENT = true;
-
-    private static final String[] ID_ONLY_PROJECTION =
-            new String[] {Events._ID};
-
-    private static final String[] EVENTS_PROJECTION = new String[] {
-            Events._SYNC_ID,
-            Events.RRULE,
-            Events.RDATE,
-            Events.ORIGINAL_ID,
-            Events.ORIGINAL_SYNC_ID,
-    };
-
-    private static final int EVENTS_SYNC_ID_INDEX = 0;
-    private static final int EVENTS_RRULE_INDEX = 1;
-    private static final int EVENTS_RDATE_INDEX = 2;
-    private static final int EVENTS_ORIGINAL_ID_INDEX = 3;
-    private static final int EVENTS_ORIGINAL_SYNC_ID_INDEX = 4;
-
-    private static final String[] COLORS_PROJECTION = new String[] {
-        Colors.ACCOUNT_NAME,
-        Colors.ACCOUNT_TYPE,
-        Colors.COLOR_TYPE,
-        Colors.COLOR_KEY,
-        Colors.COLOR,
-    };
-    private static final int COLORS_ACCOUNT_NAME_INDEX = 0;
-    private static final int COLORS_ACCOUNT_TYPE_INDEX = 1;
-    private static final int COLORS_COLOR_TYPE_INDEX = 2;
-    private static final int COLORS_COLOR_INDEX_INDEX = 3;
-    private static final int COLORS_COLOR_INDEX = 4;
-
-    private static final String COLOR_FULL_SELECTION = Colors.ACCOUNT_NAME + "=? AND "
-            + Colors.ACCOUNT_TYPE + "=? AND " + Colors.COLOR_TYPE + "=? AND " + Colors.COLOR_KEY
-            + "=?";
-
-    private static final String GENERIC_ACCOUNT_NAME = Calendars.ACCOUNT_NAME;
-    private static final String GENERIC_ACCOUNT_TYPE = Calendars.ACCOUNT_TYPE;
-    private static final String[] ACCOUNT_PROJECTION = new String[] {
-        GENERIC_ACCOUNT_NAME,
-        GENERIC_ACCOUNT_TYPE,
-    };
-    private static final int ACCOUNT_NAME_INDEX = 0;
-    private static final int ACCOUNT_TYPE_INDEX = 1;
-
-    // many tables have _id and event_id; pick a representative version to use as our generic
-    private static final String GENERIC_ID = Attendees._ID;
-    private static final String GENERIC_EVENT_ID = Attendees.EVENT_ID;
-
-    private static final String[] ID_PROJECTION = new String[] {
-            GENERIC_ID,
-            GENERIC_EVENT_ID,
-    };
-    private static final int ID_INDEX = 0;
-    private static final int EVENT_ID_INDEX = 1;
-
-    /**
-     * Projection to query for correcting times in allDay events.
-     */
-    private static final String[] ALLDAY_TIME_PROJECTION = new String[] {
-        Events._ID,
-        Events.DTSTART,
-        Events.DTEND,
-        Events.DURATION
-    };
-    private static final int ALLDAY_ID_INDEX = 0;
-    private static final int ALLDAY_DTSTART_INDEX = 1;
-    private static final int ALLDAY_DTEND_INDEX = 2;
-    private static final int ALLDAY_DURATION_INDEX = 3;
-
-    private static final int DAY_IN_SECONDS = 24 * 60 * 60;
-
-    /* SPRD: Add 20150916 of bug 474826, vcalendar issue @{ */
-    private static final int CALENDAR_AS_VCAL = 1010;
-    private static final int CALENDAR_AS_MULTI_VCAL = 1011;
-    private static final String CALENDAR_MEMORY_FILE_NAME = "calendarAssetFile";
-    private static final HashMap<String, String> sVCalendarProjectionMap;
-    /* @} */
-
-    /**
-     * The cached copy of the CalendarMetaData database table.
-     * Make this "package private" instead of "private" so that test code
-     * can access it.
-     */
-    MetaData mMetaData;
-    CalendarCache mCalendarCache;
-
-    private CalendarDatabaseHelper mDbHelper;
-    private CalendarInstancesHelper mInstancesHelper;
-
-    private static final String SQL_SELECT_EVENTSRAWTIMES = "SELECT " +
-            CalendarContract.EventsRawTimes.EVENT_ID + ", " +
-            CalendarContract.EventsRawTimes.DTSTART_2445 + ", " +
-            CalendarContract.EventsRawTimes.DTEND_2445 + ", " +
-            Events.EVENT_TIMEZONE +
-            " FROM " +
-            Tables.EVENTS_RAW_TIMES + ", " +
-            Tables.EVENTS +
-            " WHERE " +
-            CalendarContract.EventsRawTimes.EVENT_ID + " = " + Tables.EVENTS + "." + Events._ID;
-
-    private static final String SQL_UPDATE_EVENT_SET_DIRTY_AND_MUTATORS = "UPDATE " +
-            Tables.EVENTS + " SET " +
-            Events.DIRTY + "=1," +
-            Events.MUTATORS + "=? " +
-            " WHERE " + Events._ID + "=?";
-
-    private static final String SQL_QUERY_EVENT_MUTATORS = "SELECT " + Events.MUTATORS +
-            " FROM " + Tables.EVENTS +
-            " WHERE " + Events._ID + "=?";
-
-    private static final String SQL_WHERE_CALENDAR_COLOR = Calendars.ACCOUNT_NAME + "=? AND "
-            + Calendars.ACCOUNT_TYPE + "=? AND " + Calendars.CALENDAR_COLOR_KEY + "=?";
-
-    private static final String SQL_WHERE_EVENT_COLOR = "calendar_id in (SELECT _id from "
-            + Tables.CALENDARS + " WHERE " + Events.ACCOUNT_NAME + "=? AND " + Events.ACCOUNT_TYPE
-            + "=?) AND " + Events.EVENT_COLOR_KEY + "=?";
-
-    protected static final String SQL_WHERE_ID = GENERIC_ID + "=?";
-    private static final String SQL_WHERE_EVENT_ID = GENERIC_EVENT_ID + "=?";
-    private static final String SQL_WHERE_ORIGINAL_ID = Events.ORIGINAL_ID + "=?";
-    private static final String SQL_WHERE_ORIGINAL_ID_NO_SYNC_ID = Events.ORIGINAL_ID +
-            "=? AND " + Events._SYNC_ID + " IS NULL";
-
-    private static final String SQL_WHERE_ATTENDEE_BASE =
-            Tables.EVENTS + "." + Events._ID + "=" + Tables.ATTENDEES + "." + Attendees.EVENT_ID
-            + " AND " +
-            Tables.EVENTS + "." + Events.CALENDAR_ID + "=" + Tables.CALENDARS + "." + Calendars._ID;
-
-    private static final String SQL_WHERE_ATTENDEES_ID =
-            Tables.ATTENDEES + "." + Attendees._ID + "=? AND " + SQL_WHERE_ATTENDEE_BASE;
-
-    private static final String SQL_WHERE_REMINDERS_ID =
-            Tables.REMINDERS + "." + Reminders._ID + "=? AND " +
-            Tables.EVENTS + "." + Events._ID + "=" + Tables.REMINDERS + "." + Reminders.EVENT_ID +
-            " AND " +
-            Tables.EVENTS + "." + Events.CALENDAR_ID + "=" + Tables.CALENDARS + "." + Calendars._ID;
-
-    private static final String SQL_WHERE_CALENDAR_ALERT =
-            Views.EVENTS + "." + Events._ID + "=" +
-                    Tables.CALENDAR_ALERTS + "." + CalendarAlerts.EVENT_ID;
-
-    private static final String SQL_WHERE_CALENDAR_ALERT_ID =
-            Views.EVENTS + "." + Events._ID + "=" +
-                    Tables.CALENDAR_ALERTS + "." + CalendarAlerts.EVENT_ID +
-            " AND " +
-            Tables.CALENDAR_ALERTS + "." + CalendarAlerts._ID + "=?";
-
-    private static final String SQL_WHERE_EXTENDED_PROPERTIES_ID =
-            Tables.EXTENDED_PROPERTIES + "." + CalendarContract.ExtendedProperties._ID + "=?";
-
-    private static final String SQL_DELETE_FROM_CALENDARS = "DELETE FROM " + Tables.CALENDARS +
-                " WHERE " + Calendars.ACCOUNT_NAME + "=? AND " +
-                    Calendars.ACCOUNT_TYPE + "=?";
-
-    private static final String SQL_DELETE_FROM_COLORS = "DELETE FROM " + Tables.COLORS + " WHERE "
-            + Calendars.ACCOUNT_NAME + "=? AND " + Calendars.ACCOUNT_TYPE + "=?";
-
-    private static final String SQL_SELECT_COUNT_FOR_SYNC_ID =
-            "SELECT COUNT(*) FROM " + Tables.EVENTS + " WHERE " + Events._SYNC_ID + "=?";
-
-    // Make sure we load at least two months worth of data.
-    // Client apps can load more data in a background thread.
-    private static final long MINIMUM_EXPANSION_SPAN =
-            2L * 31 * 24 * 60 * 60 * 1000;
-
-    private static final String[] sCalendarsIdProjection = new String[] { Calendars._ID };
-    private static final int CALENDARS_INDEX_ID = 0;
-
-    private static final String INSTANCE_QUERY_TABLES =
-        CalendarDatabaseHelper.Tables.INSTANCES + " INNER JOIN " +
-        CalendarDatabaseHelper.Views.EVENTS + " AS " +
-        CalendarDatabaseHelper.Tables.EVENTS +
-        " ON (" + CalendarDatabaseHelper.Tables.INSTANCES + "."
-        + CalendarContract.Instances.EVENT_ID + "=" +
-        CalendarDatabaseHelper.Tables.EVENTS + "."
-        + CalendarContract.Events._ID + ")";
-
-    private static final String INSTANCE_SEARCH_QUERY_TABLES = "(" +
-        CalendarDatabaseHelper.Tables.INSTANCES + " INNER JOIN " +
-        CalendarDatabaseHelper.Views.EVENTS + " AS " +
-        CalendarDatabaseHelper.Tables.EVENTS +
-        " ON (" + CalendarDatabaseHelper.Tables.INSTANCES + "."
-        + CalendarContract.Instances.EVENT_ID + "=" +
-        CalendarDatabaseHelper.Tables.EVENTS + "."
-        + CalendarContract.Events._ID + ")" + ") LEFT OUTER JOIN " +
-        CalendarDatabaseHelper.Tables.ATTENDEES +
-        " ON (" + CalendarDatabaseHelper.Tables.ATTENDEES + "."
-        + CalendarContract.Attendees.EVENT_ID + "=" +
-        CalendarDatabaseHelper.Tables.EVENTS + "."
-        + CalendarContract.Events._ID + ")";
-
-    private static final String SQL_WHERE_INSTANCES_BETWEEN_DAY =
-        CalendarContract.Instances.START_DAY + "<=? AND " +
-        CalendarContract.Instances.END_DAY + ">=?";
-
-    private static final String SQL_WHERE_INSTANCES_BETWEEN =
-        CalendarContract.Instances.BEGIN + "<=? AND " +
-        CalendarContract.Instances.END + ">=?";
-
-    private static final int INSTANCES_INDEX_START_DAY = 0;
-    private static final int INSTANCES_INDEX_END_DAY = 1;
-    private static final int INSTANCES_INDEX_START_MINUTE = 2;
-    private static final int INSTANCES_INDEX_END_MINUTE = 3;
-    private static final int INSTANCES_INDEX_ALL_DAY = 4;
-
-    /**
-     * The sort order is: events with an earlier start time occur first and if
-     * the start times are the same, then events with a later end time occur
-     * first. The later end time is ordered first so that long-running events in
-     * the calendar views appear first. If the start and end times of two events
-     * are the same then we sort alphabetically on the title. This isn't
-     * required for correctness, it just adds a nice touch.
-     */
-    public static final String SORT_CALENDAR_VIEW = "begin ASC, end DESC, title ASC";
-
-    /**
-     * A regex for describing how we split search queries into tokens. Keeps
-     * quoted phrases as one token. "one \"two three\"" ==> ["one" "two three"]
-     */
-    private static final Pattern SEARCH_TOKEN_PATTERN =
-        Pattern.compile("[^\\s\"'.?!,]+|" // first part matches unquoted words
-                      + "\"([^\"]*)\"");  // second part matches quoted phrases
-    /**
-     * A special character that was use to escape potentially problematic
-     * characters in search queries.
-     *
-     * Note: do not use backslash for this, as it interferes with the regex
-     * escaping mechanism.
-     */
-    private static final String SEARCH_ESCAPE_CHAR = "#";
-
-    /**
-     * A regex for matching any characters in an incoming search query that we
-     * need to escape with {@link #SEARCH_ESCAPE_CHAR}, including the escape
-     * character itself.
-     */
-    private static final Pattern SEARCH_ESCAPE_PATTERN =
-        Pattern.compile("([%_" + SEARCH_ESCAPE_CHAR + "])");
-
-    /**
-     * Alias used for aggregate concatenation of attendee e-mails when grouping
-     * attendees by instance.
-     */
-    private static final String ATTENDEES_EMAIL_CONCAT =
-        "group_concat(" + CalendarContract.Attendees.ATTENDEE_EMAIL + ")";
-
-    /**
-     * Alias used for aggregate concatenation of attendee names when grouping
-     * attendees by instance.
-     */
-    private static final String ATTENDEES_NAME_CONCAT =
-        "group_concat(" + CalendarContract.Attendees.ATTENDEE_NAME + ")";
-
-    private static final String[] SEARCH_COLUMNS = new String[] {
-        CalendarContract.Events.TITLE,
-        CalendarContract.Events.DESCRIPTION,
-        CalendarContract.Events.EVENT_LOCATION,
-        ATTENDEES_EMAIL_CONCAT,
-        ATTENDEES_NAME_CONCAT
-    };
-
-    /**
-     * Arbitrary integer that we assign to the messages that we send to this
-     * thread's handler, indicating that these are requests to send an update
-     * notification intent.
-     */
-    private static final int UPDATE_BROADCAST_MSG = 1;
-
-    /**
-     * Any requests to send a PROVIDER_CHANGED intent will be collapsed over
-     * this window, to prevent spamming too many intents at once.
-     */
-    private static final long UPDATE_BROADCAST_TIMEOUT_MILLIS =
-        DateUtils.SECOND_IN_MILLIS;
-
-    private static final long SYNC_UPDATE_BROADCAST_TIMEOUT_MILLIS =
-        30 * DateUtils.SECOND_IN_MILLIS;
-
-    private static final HashSet<String> ALLOWED_URI_PARAMETERS = Sets.newHashSet(
-            CalendarContract.CALLER_IS_SYNCADAPTER,
-            CalendarContract.EventsEntity.ACCOUNT_NAME,
-            CalendarContract.EventsEntity.ACCOUNT_TYPE);
-
-    /** Set of columns allowed to be altered when creating an exception to a recurring event. */
-    private static final HashSet<String> ALLOWED_IN_EXCEPTION = new HashSet<String>();
-    static {
-        // _id, _sync_account, _sync_account_type, dirty, _sync_mark, calendar_id
-        ALLOWED_IN_EXCEPTION.add(Events._SYNC_ID);
-        ALLOWED_IN_EXCEPTION.add(Events.SYNC_DATA1);
-        ALLOWED_IN_EXCEPTION.add(Events.SYNC_DATA7);
-        ALLOWED_IN_EXCEPTION.add(Events.SYNC_DATA3);
-        ALLOWED_IN_EXCEPTION.add(Events.TITLE);
-        ALLOWED_IN_EXCEPTION.add(Events.EVENT_LOCATION);
-        ALLOWED_IN_EXCEPTION.add(Events.DESCRIPTION);
-        ALLOWED_IN_EXCEPTION.add(Events.EVENT_COLOR);
-        ALLOWED_IN_EXCEPTION.add(Events.EVENT_COLOR_KEY);
-        ALLOWED_IN_EXCEPTION.add(Events.STATUS);
-        ALLOWED_IN_EXCEPTION.add(Events.SELF_ATTENDEE_STATUS);
-        ALLOWED_IN_EXCEPTION.add(Events.SYNC_DATA6);
-        ALLOWED_IN_EXCEPTION.add(Events.DTSTART);
-        // dtend -- set from duration as part of creating the exception
-        ALLOWED_IN_EXCEPTION.add(Events.EVENT_TIMEZONE);
-        ALLOWED_IN_EXCEPTION.add(Events.EVENT_END_TIMEZONE);
-        ALLOWED_IN_EXCEPTION.add(Events.DURATION);
-        ALLOWED_IN_EXCEPTION.add(Events.ALL_DAY);
-        ALLOWED_IN_EXCEPTION.add(Events.ACCESS_LEVEL);
-        ALLOWED_IN_EXCEPTION.add(Events.AVAILABILITY);
-        ALLOWED_IN_EXCEPTION.add(Events.HAS_ALARM);
-        ALLOWED_IN_EXCEPTION.add(Events.HAS_EXTENDED_PROPERTIES);
-        ALLOWED_IN_EXCEPTION.add(Events.RRULE);
-        ALLOWED_IN_EXCEPTION.add(Events.RDATE);
-        ALLOWED_IN_EXCEPTION.add(Events.EXRULE);
-        ALLOWED_IN_EXCEPTION.add(Events.EXDATE);
-        ALLOWED_IN_EXCEPTION.add(Events.ORIGINAL_SYNC_ID);
-        ALLOWED_IN_EXCEPTION.add(Events.ORIGINAL_INSTANCE_TIME);
-        // originalAllDay, lastDate
-        ALLOWED_IN_EXCEPTION.add(Events.HAS_ATTENDEE_DATA);
-        ALLOWED_IN_EXCEPTION.add(Events.GUESTS_CAN_MODIFY);
-        ALLOWED_IN_EXCEPTION.add(Events.GUESTS_CAN_INVITE_OTHERS);
-        ALLOWED_IN_EXCEPTION.add(Events.GUESTS_CAN_SEE_GUESTS);
-        ALLOWED_IN_EXCEPTION.add(Events.ORGANIZER);
-        ALLOWED_IN_EXCEPTION.add(Events.CUSTOM_APP_PACKAGE);
-        ALLOWED_IN_EXCEPTION.add(Events.CUSTOM_APP_URI);
-        ALLOWED_IN_EXCEPTION.add(Events.UID_2445);
-        // deleted, original_id, alerts
-    }
-
-    /** Don't clone these from the base event into the exception event. */
-    private static final String[] DONT_CLONE_INTO_EXCEPTION = {
-        Events._SYNC_ID,
-        Events.SYNC_DATA1,
-        Events.SYNC_DATA2,
-        Events.SYNC_DATA3,
-        Events.SYNC_DATA4,
-        Events.SYNC_DATA5,
-        Events.SYNC_DATA6,
-        Events.SYNC_DATA7,
-        Events.SYNC_DATA8,
-        Events.SYNC_DATA9,
-        Events.SYNC_DATA10,
-    };
-
-    /** set to 'true' to enable debug logging for recurrence exception code */
-    private static final boolean DEBUG_EXCEPTION = false;
-
-    private final ThreadLocal<Boolean> mCallingPackageErrorLogged = new ThreadLocal<Boolean>();
-
-    private Context mContext;
-    private ContentResolver mContentResolver;
-
-    private static CalendarProvider2 mInstance;
-
-    @VisibleForTesting
-    protected CalendarAlarmManager mCalendarAlarm;
-
-    private final Handler mBroadcastHandler = new Handler() {
-        @Override
-        public void handleMessage(Message msg) {
-            Context context = CalendarProvider2.this.mContext;
-            if (msg.what == UPDATE_BROADCAST_MSG) {
-                // Broadcast a provider changed intent
-                doSendUpdateNotification();
-                // Because the handler does not guarantee message delivery in
-                // the case that the provider is killed, we need to make sure
-                // that the provider stays alive long enough to deliver the
-                // notification. This empty service is sufficient to "wedge" the
-                // process until we stop it here.
-                context.stopService(new Intent(context, EmptyService.class));
-            }
-        }
-    };
-
-    /**
-     * Listens for timezone changes and disk-no-longer-full events
-     */
-    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            String action = intent.getAction();
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "onReceive() " + action);
-            }
-            if (Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
-                updateTimezoneDependentFields();
-                mCalendarAlarm.checkNextAlarm(false /* do not remove alarms */);
-            } else if (Intent.ACTION_DEVICE_STORAGE_OK.equals(action)) {
-                // Try to clean up if things were screwy due to a full disk
-                updateTimezoneDependentFields();
-                mCalendarAlarm.checkNextAlarm(false /* do not remove alarms */);
-            } else if (Intent.ACTION_TIME_CHANGED.equals(action)) {
-                mCalendarAlarm.checkNextAlarm(false /* do not remove alarms */);
-            }
-        }
-    };
-
-    /* Visible for testing */
-    @Override
-    protected CalendarDatabaseHelper getDatabaseHelper(final Context context) {
-        return CalendarDatabaseHelper.getInstance(context);
-    }
-
-    protected static CalendarProvider2 getInstance() {
-        return mInstance;
-    }
-
-    @Override
-    public void shutdown() {
-        if (mDbHelper != null) {
-            mDbHelper.close();
-            mDbHelper = null;
-            mDb = null;
-        }
-    }
-
-    @Override
-    public boolean onCreate() {
-        super.onCreate();
-        Log.d(TAG, "onCreate");
-        setAppOps(AppOpsManager.OP_READ_CALENDAR, AppOpsManager.OP_WRITE_CALENDAR);
-        try {
-            return initialize();
-        } catch (RuntimeException e) {
-            if (Log.isLoggable(TAG, Log.ERROR)) {
-                Log.e(TAG, "Cannot start provider", e);
-            }
-            return false;
-        }
-    }
-
-    private boolean initialize() {
-        mInstance = this;
-
-        mContext = getContext();
-        mContentResolver = mContext.getContentResolver();
-
-        mDbHelper = (CalendarDatabaseHelper)getDatabaseHelper();
-        mDb = mDbHelper.getWritableDatabase();
-
-        mMetaData = new MetaData(mDbHelper);
-        mInstancesHelper = new CalendarInstancesHelper(mDbHelper, mMetaData);
-
-        // Register for Intent broadcasts
-        IntentFilter filter = new IntentFilter();
-
-        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
-        filter.addAction(Intent.ACTION_DEVICE_STORAGE_OK);
-        filter.addAction(Intent.ACTION_TIME_CHANGED);
-
-        // We don't ever unregister this because this thread always wants
-        // to receive notifications, even in the background.  And if this
-        // thread is killed then the whole process will be killed and the
-        // memory resources will be reclaimed.
-        mContext.registerReceiver(mIntentReceiver, filter);
-
-        mCalendarCache = new CalendarCache(mDbHelper);
-
-        // This is pulled out for testing
-        initCalendarAlarm();
-
-        postInitialize();
-
-        return true;
-    }
-
-    protected void initCalendarAlarm() {
-        mCalendarAlarm = getOrCreateCalendarAlarmManager();
-    }
-
-    synchronized CalendarAlarmManager getOrCreateCalendarAlarmManager() {
-        if (mCalendarAlarm == null) {
-            mCalendarAlarm = new CalendarAlarmManager(mContext);
-            Log.i(TAG, "Created " + mCalendarAlarm + "(" + this + ")");
-        }
-        return mCalendarAlarm;
-    }
-
-    protected void postInitialize() {
-        Thread thread = new PostInitializeThread();
-        thread.start();
-    }
-
-    private class PostInitializeThread extends Thread {
-        @Override
-        public void run() {
-            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
-
-            verifyAccounts();
-
-            try {
-                doUpdateTimezoneDependentFields();
-            } catch (IllegalStateException e) {
-                // Added this because tests would fail if the provider is
-                // closed by the time this is executed
-
-                // Nothing actionable here anyways.
-            }
-        }
-    }
-
-    private void verifyAccounts() {
-        AccountManager.get(getContext()).addOnAccountsUpdatedListener(this, null, false);
-        removeStaleAccounts(AccountManager.get(getContext()).getAccounts());
-    }
-
-
-    /**
-     * This creates a background thread to check the timezone and update
-     * the timezone dependent fields in the Instances table if the timezone
-     * has changed.
-     */
-    protected void updateTimezoneDependentFields() {
-        Thread thread = new TimezoneCheckerThread();
-        thread.start();
-    }
-
-    private class TimezoneCheckerThread extends Thread {
-        @Override
-        public void run() {
-            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
-            doUpdateTimezoneDependentFields();
-        }
-    }
-
-    /**
-     * Check if we are in the same time zone
-     */
-    private boolean isLocalSameAsInstancesTimezone() {
-        String localTimezone = TimeZone.getDefault().getID();
-        return TextUtils.equals(mCalendarCache.readTimezoneInstances(), localTimezone);
-    }
-
-    /**
-     * This method runs in a background thread.  If the timezone has changed
-     * then the Instances table will be regenerated.
-     */
-    protected void doUpdateTimezoneDependentFields() {
-        try {
-            String timezoneType = mCalendarCache.readTimezoneType();
-            // Nothing to do if we have the "home" timezone type (timezone is sticky)
-            if (timezoneType != null && timezoneType.equals(CalendarCache.TIMEZONE_TYPE_HOME)) {
-                return;
-            }
-            // We are here in "auto" mode, the timezone is coming from the device
-            if (! isSameTimezoneDatabaseVersion()) {
-                String localTimezone = TimeZone.getDefault().getID();
-                doProcessEventRawTimes(localTimezone, TimeUtils.getTimeZoneDatabaseVersion());
-            }
-            if (isLocalSameAsInstancesTimezone()) {
-                // Even if the timezone hasn't changed, check for missed alarms.
-                // This code executes when the CalendarProvider2 is created and
-                // helps to catch missed alarms when the Calendar process is
-                // killed (because of low-memory conditions) and then restarted.
-                mCalendarAlarm.rescheduleMissedAlarms();
-            }
-        } catch (SQLException e) {
-            if (Log.isLoggable(TAG, Log.ERROR)) {
-                Log.e(TAG, "doUpdateTimezoneDependentFields() failed", e);
-            }
-            try {
-                // Clear at least the in-memory data (and if possible the
-                // database fields) to force a re-computation of Instances.
-                mMetaData.clearInstanceRange();
-            } catch (SQLException e2) {
-                if (Log.isLoggable(TAG, Log.ERROR)) {
-                    Log.e(TAG, "clearInstanceRange() also failed: " + e2);
-                }
-            }
-        }
-    }
-
-    protected void doProcessEventRawTimes(String localTimezone, String timeZoneDatabaseVersion) {
-        mDb.beginTransaction();
-        try {
-            updateEventsStartEndFromEventRawTimesLocked();
-            updateTimezoneDatabaseVersion(timeZoneDatabaseVersion);
-            mCalendarCache.writeTimezoneInstances(localTimezone);
-            regenerateInstancesTable();
-            mDb.setTransactionSuccessful();
-        } finally {
-            mDb.endTransaction();
-        }
-    }
-
-    private void updateEventsStartEndFromEventRawTimesLocked() {
-        Cursor cursor = mDb.rawQuery(SQL_SELECT_EVENTSRAWTIMES, null /* selection args */);
-        try {
-            while (cursor.moveToNext()) {
-                long eventId = cursor.getLong(0);
-                String dtStart2445 = cursor.getString(1);
-                String dtEnd2445 = cursor.getString(2);
-                String eventTimezone = cursor.getString(3);
-                if (dtStart2445 == null && dtEnd2445 == null) {
-                    if (Log.isLoggable(TAG, Log.ERROR)) {
-                        Log.e(TAG, "Event " + eventId + " has dtStart2445 and dtEnd2445 null "
-                                + "at the same time in EventsRawTimes!");
-                    }
-                    continue;
-                }
-                updateEventsStartEndLocked(eventId,
-                        eventTimezone,
-                        dtStart2445,
-                        dtEnd2445);
-            }
-        } finally {
-            cursor.close();
-            cursor = null;
-        }
-    }
-
-    private long get2445ToMillis(String timezone, String dt2445) {
-        if (null == dt2445) {
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                Log.v(TAG, "Cannot parse null RFC2445 date");
-            }
-            return 0;
-        }
-        Time time = (timezone != null) ? new Time(timezone) : new Time();
-        try {
-            time.parse(dt2445);
-        } catch (TimeFormatException e) {
-            if (Log.isLoggable(TAG, Log.ERROR)) {
-                Log.e(TAG, "Cannot parse RFC2445 date " + dt2445);
-            }
-            return 0;
-        }
-        return time.toMillis(true /* ignore DST */);
-    }
-
-    private void updateEventsStartEndLocked(long eventId,
-            String timezone, String dtStart2445, String dtEnd2445) {
-
-        ContentValues values = new ContentValues();
-        values.put(Events.DTSTART, get2445ToMillis(timezone, dtStart2445));
-        values.put(Events.DTEND, get2445ToMillis(timezone, dtEnd2445));
-
-        int result = mDb.update(Tables.EVENTS, values, SQL_WHERE_ID,
-                new String[] {String.valueOf(eventId)});
-        if (0 == result) {
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                Log.v(TAG, "Could not update Events table with values " + values);
-            }
-        }
-    }
-
-    private void updateTimezoneDatabaseVersion(String timeZoneDatabaseVersion) {
-        try {
-            mCalendarCache.writeTimezoneDatabaseVersion(timeZoneDatabaseVersion);
-        } catch (CalendarCache.CacheException e) {
-            if (Log.isLoggable(TAG, Log.ERROR)) {
-                Log.e(TAG, "Could not write timezone database version in the cache");
-            }
-        }
-    }
-
-    /**
-     * Check if the time zone database version is the same as the cached one
-     */
-    protected boolean isSameTimezoneDatabaseVersion() {
-        String timezoneDatabaseVersion = mCalendarCache.readTimezoneDatabaseVersion();
-        if (timezoneDatabaseVersion == null) {
-            return false;
-        }
-        return TextUtils.equals(timezoneDatabaseVersion, TimeUtils.getTimeZoneDatabaseVersion());
-    }
-
-    @VisibleForTesting
-    protected String getTimezoneDatabaseVersion() {
-        String timezoneDatabaseVersion = mCalendarCache.readTimezoneDatabaseVersion();
-        if (timezoneDatabaseVersion == null) {
-            return "";
-        }
-        if (Log.isLoggable(TAG, Log.INFO)) {
-            Log.i(TAG, "timezoneDatabaseVersion = " + timezoneDatabaseVersion);
-        }
-        return timezoneDatabaseVersion;
-    }
-
-    private boolean isHomeTimezone() {
-        final String type = mCalendarCache.readTimezoneType();
-        return CalendarCache.TIMEZONE_TYPE_HOME.equals(type);
-    }
-
-    private void regenerateInstancesTable() {
-        // The database timezone is different from the current timezone.
-        // Regenerate the Instances table for this month.  Include events
-        // starting at the beginning of this month.
-        long now = System.currentTimeMillis();
-        String instancesTimezone = mCalendarCache.readTimezoneInstances();
-        Time time = new Time(instancesTimezone);
-        time.set(now);
-        time.monthDay = 1;
-        time.hour = 0;
-        time.minute = 0;
-        time.second = 0;
-
-        long begin = time.normalize(true);
-        long end = begin + MINIMUM_EXPANSION_SPAN;
-
-        Cursor cursor = null;
-        try {
-            cursor = handleInstanceQuery(new SQLiteQueryBuilder(),
-                    begin, end,
-                    new String[] { Instances._ID },
-                    null /* selection */, null,
-                    null /* sort */,
-                    false /* searchByDayInsteadOfMillis */,
-                    true /* force Instances deletion and expansion */,
-                    instancesTimezone, isHomeTimezone());
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-
-        mCalendarAlarm.rescheduleMissedAlarms();
-    }
-
-
-    @Override
-    protected void notifyChange(boolean syncToNetwork) {
-        // Note that semantics are changed: notification is for CONTENT_URI, not the specific
-        // Uri that was modified.
-        mContentResolver.notifyChange(CalendarContract.CONTENT_URI, null, syncToNetwork);
-    }
-
-    /**
-     * ALERT table is maintained locally so don't request a sync for changes in it
-     */
-    @Override
-    protected boolean shouldSyncFor(Uri uri) {
-        final int match = sUriMatcher.match(uri);
-        return !(match == CALENDAR_ALERTS ||
-                match == CALENDAR_ALERTS_ID ||
-                match == CALENDAR_ALERTS_BY_INSTANCE);
-    }
-
-    @Override
-    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
-            String sortOrder) {
-        final long identity = clearCallingIdentityInternal();
-        try {
-            return queryInternal(uri, projection, selection, selectionArgs, sortOrder);
-        } finally {
-            restoreCallingIdentityInternal(identity);
-        }
-    }
-
-    private Cursor queryInternal(Uri uri, String[] projection, String selection,
-            String[] selectionArgs, String sortOrder) {
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "query uri - " + uri);
-        }
-        validateUriParameters(uri.getQueryParameterNames());
-        final SQLiteDatabase db = mDbHelper.getReadableDatabase();
-
-        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
-        String groupBy = null;
-        String limit = null; // Not currently implemented
-        String instancesTimezone;
-
-        final int match = sUriMatcher.match(uri);
-        switch (match) {
-            case SYNCSTATE:
-                return mDbHelper.getSyncState().query(db, projection, selection, selectionArgs,
-                        sortOrder);
-            case SYNCSTATE_ID:
-                String selectionWithId = (SyncState._ID + "=?")
-                    + (selection == null ? "" : " AND (" + selection + ")");
-                // Prepend id to selectionArgs
-                selectionArgs = insertSelectionArg(selectionArgs,
-                        String.valueOf(ContentUris.parseId(uri)));
-                return mDbHelper.getSyncState().query(db, projection, selectionWithId,
-                        selectionArgs, sortOrder);
-
-            case EVENTS:
-                qb.setTables(CalendarDatabaseHelper.Views.EVENTS);
-                qb.setProjectionMap(sEventsProjectionMap);
-                selection = appendAccountToSelection(uri, selection, Calendars.ACCOUNT_NAME,
-                        Calendars.ACCOUNT_TYPE);
-                selection = appendLastSyncedColumnToSelection(selection, uri);
-                break;
-            case EVENTS_ID:
-                qb.setTables(CalendarDatabaseHelper.Views.EVENTS);
-                qb.setProjectionMap(sEventsProjectionMap);
-                selectionArgs = insertSelectionArg(selectionArgs, uri.getPathSegments().get(1));
-                qb.appendWhere(SQL_WHERE_ID);
-                break;
-
-            case EVENT_ENTITIES:
-                qb.setTables(CalendarDatabaseHelper.Views.EVENTS);
-                qb.setProjectionMap(sEventEntitiesProjectionMap);
-                selection = appendAccountToSelection(uri, selection, Calendars.ACCOUNT_NAME,
-                        Calendars.ACCOUNT_TYPE);
-                selection = appendLastSyncedColumnToSelection(selection, uri);
-                break;
-            case EVENT_ENTITIES_ID:
-                qb.setTables(CalendarDatabaseHelper.Views.EVENTS);
-                qb.setProjectionMap(sEventEntitiesProjectionMap);
-                selectionArgs = insertSelectionArg(selectionArgs, uri.getPathSegments().get(1));
-                qb.appendWhere(SQL_WHERE_ID);
-                break;
-
-            case COLORS:
-                qb.setTables(Tables.COLORS);
-                qb.setProjectionMap(sColorsProjectionMap);
-                selection = appendAccountToSelection(uri, selection, Calendars.ACCOUNT_NAME,
-                        Calendars.ACCOUNT_TYPE);
-                break;
-
-            case CALENDARS:
-            case CALENDAR_ENTITIES:
-                qb.setTables(Tables.CALENDARS);
-                qb.setProjectionMap(sCalendarsProjectionMap);
-                selection = appendAccountToSelection(uri, selection, Calendars.ACCOUNT_NAME,
-                        Calendars.ACCOUNT_TYPE);
-                break;
-            case CALENDARS_ID:
-            case CALENDAR_ENTITIES_ID:
-                qb.setTables(Tables.CALENDARS);
-                qb.setProjectionMap(sCalendarsProjectionMap);
-                selectionArgs = insertSelectionArg(selectionArgs, uri.getPathSegments().get(1));
-                qb.appendWhere(SQL_WHERE_ID);
-                break;
-            case INSTANCES:
-            case INSTANCES_BY_DAY:
-                long begin;
-                long end;
-                try {
-                    begin = Long.valueOf(uri.getPathSegments().get(2));
-                } catch (NumberFormatException nfe) {
-                    throw new IllegalArgumentException("Cannot parse begin "
-                            + uri.getPathSegments().get(2));
-                }
-                try {
-                    end = Long.valueOf(uri.getPathSegments().get(3));
-                } catch (NumberFormatException nfe) {
-                    throw new IllegalArgumentException("Cannot parse end "
-                            + uri.getPathSegments().get(3));
-                }
-                instancesTimezone = mCalendarCache.readTimezoneInstances();
-                return handleInstanceQuery(qb, begin, end, projection, selection, selectionArgs,
-                        sortOrder, match == INSTANCES_BY_DAY, false /* don't force an expansion */,
-                        instancesTimezone, isHomeTimezone());
-            case INSTANCES_SEARCH:
-            case INSTANCES_SEARCH_BY_DAY:
-                try {
-                    begin = Long.valueOf(uri.getPathSegments().get(2));
-                } catch (NumberFormatException nfe) {
-                    throw new IllegalArgumentException("Cannot parse begin "
-                            + uri.getPathSegments().get(2));
-                }
-                try {
-                    end = Long.valueOf(uri.getPathSegments().get(3));
-                } catch (NumberFormatException nfe) {
-                    throw new IllegalArgumentException("Cannot parse end "
-                            + uri.getPathSegments().get(3));
-                }
-                instancesTimezone = mCalendarCache.readTimezoneInstances();
-                // this is already decoded
-                String query = uri.getPathSegments().get(4);
-                return handleInstanceSearchQuery(qb, begin, end, query, projection, selection,
-                        selectionArgs, sortOrder, match == INSTANCES_SEARCH_BY_DAY,
-                        instancesTimezone, isHomeTimezone());
-            case EVENT_DAYS:
-                int startDay;
-                int endDay;
-                try {
-                    startDay = Integer.parseInt(uri.getPathSegments().get(2));
-                } catch (NumberFormatException nfe) {
-                    throw new IllegalArgumentException("Cannot parse start day "
-                            + uri.getPathSegments().get(2));
-                }
-                try {
-                    endDay = Integer.parseInt(uri.getPathSegments().get(3));
-                } catch (NumberFormatException nfe) {
-                    throw new IllegalArgumentException("Cannot parse end day "
-                            + uri.getPathSegments().get(3));
-                }
-                instancesTimezone = mCalendarCache.readTimezoneInstances();
-                return handleEventDayQuery(qb, startDay, endDay, projection, selection,
-                        instancesTimezone, isHomeTimezone());
-            case ATTENDEES:
-                qb.setTables(Tables.ATTENDEES + ", " + Tables.EVENTS + ", " + Tables.CALENDARS);
-                qb.setProjectionMap(sAttendeesProjectionMap);
-                qb.appendWhere(SQL_WHERE_ATTENDEE_BASE);
-                break;
-            case ATTENDEES_ID:
-                qb.setTables(Tables.ATTENDEES + ", " + Tables.EVENTS + ", " + Tables.CALENDARS);
-                qb.setProjectionMap(sAttendeesProjectionMap);
-                selectionArgs = insertSelectionArg(selectionArgs, uri.getPathSegments().get(1));
-                qb.appendWhere(SQL_WHERE_ATTENDEES_ID);
-                break;
-            case REMINDERS:
-                qb.setTables(Tables.REMINDERS);
-                break;
-            case REMINDERS_ID:
-                qb.setTables(Tables.REMINDERS + ", " + Tables.EVENTS + ", " + Tables.CALENDARS);
-                qb.setProjectionMap(sRemindersProjectionMap);
-                selectionArgs = insertSelectionArg(selectionArgs, uri.getLastPathSegment());
-                qb.appendWhere(SQL_WHERE_REMINDERS_ID);
-                break;
-            case CALENDAR_ALERTS:
-                qb.setTables(Tables.CALENDAR_ALERTS + ", " + CalendarDatabaseHelper.Views.EVENTS);
-                qb.setProjectionMap(sCalendarAlertsProjectionMap);
-                qb.appendWhere(SQL_WHERE_CALENDAR_ALERT);
-                break;
-            case CALENDAR_ALERTS_BY_INSTANCE:
-                qb.setTables(Tables.CALENDAR_ALERTS + ", " + CalendarDatabaseHelper.Views.EVENTS);
-                qb.setProjectionMap(sCalendarAlertsProjectionMap);
-                qb.appendWhere(SQL_WHERE_CALENDAR_ALERT);
-                groupBy = CalendarAlerts.EVENT_ID + "," + CalendarAlerts.BEGIN;
-                break;
-            case CALENDAR_ALERTS_ID:
-                qb.setTables(Tables.CALENDAR_ALERTS + ", " + CalendarDatabaseHelper.Views.EVENTS);
-                qb.setProjectionMap(sCalendarAlertsProjectionMap);
-                selectionArgs = insertSelectionArg(selectionArgs, uri.getLastPathSegment());
-                qb.appendWhere(SQL_WHERE_CALENDAR_ALERT_ID);
-                break;
-            case EXTENDED_PROPERTIES:
-                qb.setTables(Tables.EXTENDED_PROPERTIES);
-                break;
-            case EXTENDED_PROPERTIES_ID:
-                qb.setTables(Tables.EXTENDED_PROPERTIES);
-                selectionArgs = insertSelectionArg(selectionArgs, uri.getPathSegments().get(1));
-                qb.appendWhere(SQL_WHERE_EXTENDED_PROPERTIES_ID);
-                break;
-            case PROVIDER_PROPERTIES:
-                qb.setTables(Tables.CALENDAR_CACHE);
-                qb.setProjectionMap(sCalendarCacheProjectionMap);
-                break;
-        /* SPRD:Modify 20150916 of bug 474826, vcalendar issue @{ */
-        case CALENDAR_AS_VCAL:
-            final String event_id = uri.getPathSegments().get(2);
-            qb.setTables("Events, Calendars");
-            qb.setProjectionMap(sVCalendarProjectionMap);
-            qb.appendWhere("Events.calendar_id=Calendars._id");
-            qb.appendWhere(" AND Events._id=");
-            qb.appendWhere(event_id);
-            break;
-        case CALENDAR_AS_MULTI_VCAL:
-            String eventId = uri.getPathSegments().get(2);
-            return db.rawQuery("SELECT" + " ? || '.vcs' AS "
-                    + OpenableColumns.DISPLAY_NAME + "," + " NULL AS "
-                    + OpenableColumns.SIZE,
-                    new String[] { vCalTitleString(eventId) });
-            /* @} */
-            default:
-                throw new IllegalArgumentException("Unknown URL " + uri);
-        }
-
-        // run the query
-        return query(db, qb, projection, selection, selectionArgs, sortOrder, groupBy, limit);
-    }
-
-    private void validateUriParameters(Set<String> queryParameterNames) {
-        final Set<String> parameterNames = queryParameterNames;
-        for (String parameterName : parameterNames) {
-            if (!ALLOWED_URI_PARAMETERS.contains(parameterName)) {
-                throw new IllegalArgumentException("Invalid URI parameter: " + parameterName);
-            }
-        }
-    }
-
-    private Cursor query(final SQLiteDatabase db, SQLiteQueryBuilder qb, String[] projection,
-            String selection, String[] selectionArgs, String sortOrder, String groupBy,
-            String limit) {
-
-        if (projection != null && projection.length == 1
-                && BaseColumns._COUNT.equals(projection[0])) {
-            qb.setProjectionMap(sCountProjectionMap);
-        }
-
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "query sql - projection: " + Arrays.toString(projection) +
-                    " selection: " + selection +
-                    " selectionArgs: " + Arrays.toString(selectionArgs) +
-                    " sortOrder: " + sortOrder +
-                    " groupBy: " + groupBy +
-                    " limit: " + limit);
-        }
-        final Cursor c = qb.query(db, projection, selection, selectionArgs, groupBy, null,
-                sortOrder, limit);
-        if (c != null) {
-            // TODO: is this the right notification Uri?
-            c.setNotificationUri(mContentResolver, CalendarContract.Events.CONTENT_URI);
-        }
-        return c;
-    }
-
-    /*
-     * Fills the Instances table, if necessary, for the given range and then
-     * queries the Instances table.
-     *
-     * @param qb The query
-     * @param rangeBegin start of range (Julian days or ms)
-     * @param rangeEnd end of range (Julian days or ms)
-     * @param projection The projection
-     * @param selection The selection
-     * @param sort How to sort
-     * @param searchByDay if true, range is in Julian days, if false, range is in ms
-     * @param forceExpansion force the Instance deletion and expansion if set to true
-     * @param instancesTimezone timezone we need to use for computing the instances
-     * @param isHomeTimezone if true, we are in the "home" timezone
-     * @return
-     */
-    private Cursor handleInstanceQuery(SQLiteQueryBuilder qb, long rangeBegin,
-            long rangeEnd, String[] projection, String selection, String[] selectionArgs,
-            String sort, boolean searchByDay, boolean forceExpansion,
-            String instancesTimezone, boolean isHomeTimezone) {
-        mDb = mDbHelper.getWritableDatabase();
-        qb.setTables(INSTANCE_QUERY_TABLES);
-        qb.setProjectionMap(sInstancesProjectionMap);
-        if (searchByDay) {
-            // Convert the first and last Julian day range to a range that uses
-            // UTC milliseconds.
-            Time time = new Time(instancesTimezone);
-            long beginMs = time.setJulianDay((int) rangeBegin);
-            // We add one to lastDay because the time is set to 12am on the given
-            // Julian day and we want to include all the events on the last day.
-            long endMs = time.setJulianDay((int) rangeEnd + 1);
-            // will lock the database.
-            acquireInstanceRange(beginMs, endMs, true /* use minimum expansion window */,
-                    forceExpansion, instancesTimezone, isHomeTimezone);
-            qb.appendWhere(SQL_WHERE_INSTANCES_BETWEEN_DAY);
-        } else {
-            // will lock the database.
-            acquireInstanceRange(rangeBegin, rangeEnd, true /* use minimum expansion window */,
-                    forceExpansion, instancesTimezone, isHomeTimezone);
-            qb.appendWhere(SQL_WHERE_INSTANCES_BETWEEN);
-        }
-
-        String[] newSelectionArgs = new String[] {String.valueOf(rangeEnd),
-                String.valueOf(rangeBegin)};
-        if (selectionArgs == null) {
-            selectionArgs = newSelectionArgs;
-        } else {
-            selectionArgs = combine(newSelectionArgs, selectionArgs);
-        }
-        return qb.query(mDb, projection, selection, selectionArgs, null /* groupBy */,
-                null /* having */, sort);
-    }
-
-    /**
-     * Combine a set of arrays in the order they are passed in. All arrays must
-     * be of the same type.
-     */
-    private static <T> T[] combine(T[]... arrays) {
-        if (arrays.length == 0) {
-            throw new IllegalArgumentException("Must supply at least 1 array to combine");
-        }
-
-        int totalSize = 0;
-        for (T[] array : arrays) {
-            totalSize += array.length;
-        }
-
-        T[] finalArray = (T[]) (Array.newInstance(arrays[0].getClass().getComponentType(),
-                totalSize));
-
-        int currentPos = 0;
-        for (T[] array : arrays) {
-            int length = array.length;
-            System.arraycopy(array, 0, finalArray, currentPos, length);
-            currentPos += array.length;
-        }
-        return finalArray;
-    }
-
-    /**
-     * Escape any special characters in the search token
-     * @param token the token to escape
-     * @return the escaped token
-     */
-    @VisibleForTesting
-    String escapeSearchToken(String token) {
-        Matcher matcher = SEARCH_ESCAPE_PATTERN.matcher(token);
-        return matcher.replaceAll(SEARCH_ESCAPE_CHAR + "$1");
-    }
-
-    /**
-     * Splits the search query into individual search tokens based on whitespace
-     * and punctuation. Leaves both single quoted and double quoted strings
-     * intact.
-     *
-     * @param query the search query
-     * @return an array of tokens from the search query
-     */
-    @VisibleForTesting
-    String[] tokenizeSearchQuery(String query) {
-        List<String> matchList = new ArrayList<String>();
-        Matcher matcher = SEARCH_TOKEN_PATTERN.matcher(query);
-        String token;
-        while (matcher.find()) {
-            if (matcher.group(1) != null) {
-                // double quoted string
-                token = matcher.group(1);
-            } else {
-                // unquoted token
-                token = matcher.group();
-            }
-            matchList.add(escapeSearchToken(token));
-        }
-        return matchList.toArray(new String[matchList.size()]);
-    }
-
-    /**
-     * In order to support what most people would consider a reasonable
-     * search behavior, we have to do some interesting things here. We
-     * assume that when a user searches for something like "lunch meeting",
-     * they really want any event that matches both "lunch" and "meeting",
-     * not events that match the string "lunch meeting" itself. In order to
-     * do this across multiple columns, we have to construct a WHERE clause
-     * that looks like:
-     * <code>
-     *   WHERE (title LIKE "%lunch%"
-     *      OR description LIKE "%lunch%"
-     *      OR eventLocation LIKE "%lunch%")
-     *     AND (title LIKE "%meeting%"
-     *      OR description LIKE "%meeting%"
-     *      OR eventLocation LIKE "%meeting%")
-     * </code>
-     * This "product of clauses" is a bit ugly, but produced a fairly good
-     * approximation of full-text search across multiple columns.  The set
-     * of columns is specified by the SEARCH_COLUMNS constant.
-     * <p>
-     * Note the "WHERE" token isn't part of the returned string.  The value
-     * may be passed into a query as the "HAVING" clause.
-     */
-    @VisibleForTesting
-    String constructSearchWhere(String[] tokens) {
-        if (tokens.length == 0) {
-            return "";
-        }
-        StringBuilder sb = new StringBuilder();
-        String column, token;
-        for (int j = 0; j < tokens.length; j++) {
-            sb.append("(");
-            for (int i = 0; i < SEARCH_COLUMNS.length; i++) {
-                sb.append(SEARCH_COLUMNS[i]);
-                sb.append(" LIKE ? ESCAPE \"");
-                sb.append(SEARCH_ESCAPE_CHAR);
-                sb.append("\" ");
-                if (i < SEARCH_COLUMNS.length - 1) {
-                    sb.append("OR ");
-                }
-            }
-            sb.append(")");
-            if (j < tokens.length - 1) {
-                sb.append(" AND ");
-            }
-        }
-        return sb.toString();
-    }
-
-    @VisibleForTesting
-    String[] constructSearchArgs(String[] tokens) {
-        int numCols = SEARCH_COLUMNS.length;
-        int numArgs = tokens.length * numCols;
-        String[] selectionArgs = new String[numArgs];
-        for (int j = 0; j < tokens.length; j++) {
-            int start = numCols * j;
-            for (int i = start; i < start + numCols; i++) {
-                selectionArgs[i] = "%" + tokens[j] + "%";
-            }
-        }
-        return selectionArgs;
-    }
-
-    private Cursor handleInstanceSearchQuery(SQLiteQueryBuilder qb,
-            long rangeBegin, long rangeEnd, String query, String[] projection,
-            String selection, String[] selectionArgs, String sort, boolean searchByDay,
-            String instancesTimezone, boolean isHomeTimezone) {
-        mDb = mDbHelper.getWritableDatabase();
-        qb.setTables(INSTANCE_SEARCH_QUERY_TABLES);
-        qb.setProjectionMap(sInstancesProjectionMap);
-
-        String[] tokens = tokenizeSearchQuery(query);
-        String[] searchArgs = constructSearchArgs(tokens);
-        String[] timeRange = new String[] {String.valueOf(rangeEnd), String.valueOf(rangeBegin)};
-        if (selectionArgs == null) {
-            selectionArgs = combine(timeRange, searchArgs);
-        } else {
-            // where clause comes first, so put selectionArgs before searchArgs.
-            selectionArgs = combine(timeRange, selectionArgs, searchArgs);
-        }
-        // we pass this in as a HAVING instead of a WHERE so the filtering
-        // happens after the grouping
-        String searchWhere = constructSearchWhere(tokens);
-
-        if (searchByDay) {
-            // Convert the first and last Julian day range to a range that uses
-            // UTC milliseconds.
-            Time time = new Time(instancesTimezone);
-            long beginMs = time.setJulianDay((int) rangeBegin);
-            // We add one to lastDay because the time is set to 12am on the given
-            // Julian day and we want to include all the events on the last day.
-            long endMs = time.setJulianDay((int) rangeEnd + 1);
-            // will lock the database.
-            // we expand the instances here because we might be searching over
-            // a range where instance expansion has not occurred yet
-            acquireInstanceRange(beginMs, endMs,
-                    true /* use minimum expansion window */,
-                    false /* do not force Instances deletion and expansion */,
-                    instancesTimezone,
-                    isHomeTimezone
-            );
-            qb.appendWhere(SQL_WHERE_INSTANCES_BETWEEN_DAY);
-        } else {
-            // will lock the database.
-            // we expand the instances here because we might be searching over
-            // a range where instance expansion has not occurred yet
-            acquireInstanceRange(rangeBegin, rangeEnd,
-                    true /* use minimum expansion window */,
-                    false /* do not force Instances deletion and expansion */,
-                    instancesTimezone,
-                    isHomeTimezone
-            );
-            qb.appendWhere(SQL_WHERE_INSTANCES_BETWEEN);
-        }
-        return qb.query(mDb, projection, selection, selectionArgs,
-                Tables.INSTANCES + "." + Instances._ID /* groupBy */,
-                searchWhere /* having */, sort);
-    }
-
-    private Cursor handleEventDayQuery(SQLiteQueryBuilder qb, int begin, int end,
-            String[] projection, String selection, String instancesTimezone,
-            boolean isHomeTimezone) {
-        mDb = mDbHelper.getWritableDatabase();
-        qb.setTables(INSTANCE_QUERY_TABLES);
-        qb.setProjectionMap(sInstancesProjectionMap);
-        // Convert the first and last Julian day range to a range that uses
-        // UTC milliseconds.
-        Time time = new Time(instancesTimezone);
-        long beginMs = time.setJulianDay(begin);
-        // We add one to lastDay because the time is set to 12am on the given
-        // Julian day and we want to include all the events on the last day.
-        long endMs = time.setJulianDay(end + 1);
-
-        acquireInstanceRange(beginMs, endMs, true,
-                false /* do not force Instances expansion */, instancesTimezone, isHomeTimezone);
-        qb.appendWhere(SQL_WHERE_INSTANCES_BETWEEN_DAY);
-        String selectionArgs[] = new String[] {String.valueOf(end), String.valueOf(begin)};
-
-        return qb.query(mDb, projection, selection, selectionArgs,
-                Instances.START_DAY /* groupBy */, null /* having */, null);
-    }
-
-    /**
-     * Ensure that the date range given has all elements in the instance
-     * table.  Acquires the database lock and calls
-     * {@link #acquireInstanceRangeLocked(long, long, boolean, boolean, String, boolean)}.
-     *
-     * @param begin start of range (ms)
-     * @param end end of range (ms)
-     * @param useMinimumExpansionWindow expand by at least MINIMUM_EXPANSION_SPAN
-     * @param forceExpansion force the Instance deletion and expansion if set to true
-     * @param instancesTimezone timezone we need to use for computing the instances
-     * @param isHomeTimezone if true, we are in the "home" timezone
-     */
-    private void acquireInstanceRange(final long begin, final long end,
-            final boolean useMinimumExpansionWindow, final boolean forceExpansion,
-            final String instancesTimezone, final boolean isHomeTimezone) {
-        mDb.beginTransaction();
-        try {
-            acquireInstanceRangeLocked(begin, end, useMinimumExpansionWindow,
-                    forceExpansion, instancesTimezone, isHomeTimezone);
-            mDb.setTransactionSuccessful();
-        } finally {
-            mDb.endTransaction();
-        }
-    }
-
-    /**
-     * Ensure that the date range given has all elements in the instance
-     * table.  The database lock must be held when calling this method.
-     *
-     * @param begin start of range (ms)
-     * @param end end of range (ms)
-     * @param useMinimumExpansionWindow expand by at least MINIMUM_EXPANSION_SPAN
-     * @param forceExpansion force the Instance deletion and expansion if set to true
-     * @param instancesTimezone timezone we need to use for computing the instances
-     * @param isHomeTimezone if true, we are in the "home" timezone
-     */
-    void acquireInstanceRangeLocked(long begin, long end, boolean useMinimumExpansionWindow,
-            boolean forceExpansion, String instancesTimezone, boolean isHomeTimezone) {
-        long expandBegin = begin;
-        long expandEnd = end;
-
-        if (DEBUG_INSTANCES) {
-            Log.d(TAG + "-i", "acquireInstanceRange begin=" + begin + " end=" + end +
-                    " useMin=" + useMinimumExpansionWindow + " force=" + forceExpansion);
-        }
-
-        if (instancesTimezone == null) {
-            Log.e(TAG, "Cannot run acquireInstanceRangeLocked() because instancesTimezone is null");
-            return;
-        }
-
-        if (useMinimumExpansionWindow) {
-            // if we end up having to expand events into the instances table, expand
-            // events for a minimal amount of time, so we do not have to perform
-            // expansions frequently.
-            long span = end - begin;
-            if (span < MINIMUM_EXPANSION_SPAN) {
-                long additionalRange = (MINIMUM_EXPANSION_SPAN - span) / 2;
-                expandBegin -= additionalRange;
-                expandEnd += additionalRange;
-            }
-            // SPRD bug 463264 if expandEnd Larger than max value, cause to delete error
-            expandEnd = expandEnd > CalendarInstancesHelper.END_DAY_MAX ? CalendarInstancesHelper.END_DAY_MAX : expandEnd;
-        }
-
-        // Check if the timezone has changed.
-        // We do this check here because the database is locked and we can
-        // safely delete all the entries in the Instances table.
-        MetaData.Fields fields = mMetaData.getFieldsLocked();
-        long maxInstance = fields.maxInstance;
-        long minInstance = fields.minInstance;
-        boolean timezoneChanged;
-        if (isHomeTimezone) {
-            String previousTimezone = mCalendarCache.readTimezoneInstancesPrevious();
-            timezoneChanged = !instancesTimezone.equals(previousTimezone);
-        } else {
-            String localTimezone = TimeZone.getDefault().getID();
-            timezoneChanged = !instancesTimezone.equals(localTimezone);
-            // if we're in auto make sure we are using the device time zone
-            if (timezoneChanged) {
-                instancesTimezone = localTimezone;
-            }
-        }
-        // if "home", then timezoneChanged only if current != previous
-        // if "auto", then timezoneChanged, if !instancesTimezone.equals(localTimezone);
-        if (maxInstance == 0 || timezoneChanged || forceExpansion) {
-            if (DEBUG_INSTANCES) {
-                Log.d(TAG + "-i", "Wiping instances and expanding from scratch");
-            }
-
-            // Empty the Instances table and expand from scratch.
-            mDb.execSQL("DELETE FROM " + Tables.INSTANCES + ";");
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                Log.v(TAG, "acquireInstanceRangeLocked() deleted Instances,"
-                        + " timezone changed: " + timezoneChanged);
-            }
-            mInstancesHelper.expandInstanceRangeLocked(expandBegin, expandEnd, instancesTimezone);
-
-            mMetaData.writeLocked(instancesTimezone, expandBegin, expandEnd);
-
-            final String timezoneType = mCalendarCache.readTimezoneType();
-            // This may cause some double writes but guarantees the time zone in
-            // the db and the time zone the instances are in is the same, which
-            // future changes may affect.
-            mCalendarCache.writeTimezoneInstances(instancesTimezone);
-
-            // If we're in auto check if we need to fix the previous tz value
-            if (CalendarCache.TIMEZONE_TYPE_AUTO.equals(timezoneType)) {
-                String prevTZ = mCalendarCache.readTimezoneInstancesPrevious();
-                if (TextUtils.equals(TIMEZONE_GMT, prevTZ)) {
-                    mCalendarCache.writeTimezoneInstancesPrevious(instancesTimezone);
-                }
-            }
-            return;
-        }
-
-        // If the desired range [begin, end] has already been
-        // expanded, then simply return.  The range is inclusive, that is,
-        // events that touch either endpoint are included in the expansion.
-        // This means that a zero-duration event that starts and ends at
-        // the endpoint will be included.
-        // We use [begin, end] here and not [expandBegin, expandEnd] for
-        // checking the range because a common case is for the client to
-        // request successive days or weeks, for example.  If we checked
-        // that the expanded range [expandBegin, expandEnd] then we would
-        // always be expanding because there would always be one more day
-        // or week that hasn't been expanded.
-        if ((begin >= minInstance) && (end <= maxInstance)) {
-            if (DEBUG_INSTANCES) {
-                Log.d(TAG + "-i", "instances are already expanded");
-            }
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                Log.v(TAG, "Canceled instance query (" + expandBegin + ", " + expandEnd
-                        + ") falls within previously expanded range.");
-            }
-            return;
-        }
-
-        // If the requested begin point has not been expanded, then include
-        // more events than requested in the expansion (use "expandBegin").
-        if (begin < minInstance) {
-            mInstancesHelper.expandInstanceRangeLocked(expandBegin, minInstance, instancesTimezone);
-            minInstance = expandBegin;
-        }
-
-        // If the requested end point has not been expanded, then include
-        // more events than requested in the expansion (use "expandEnd").
-        if (end > maxInstance) {
-            mInstancesHelper.expandInstanceRangeLocked(maxInstance, expandEnd, instancesTimezone);
-            maxInstance = expandEnd;
-        }
-
-        // Update the bounds on the Instances table.
-        mMetaData.writeLocked(instancesTimezone, minInstance, maxInstance);
-    }
-
-    @Override
-    public String getType(Uri url) {
-        int match = sUriMatcher.match(url);
-        switch (match) {
-            case EVENTS:
-                return "vnd.android.cursor.dir/event";
-            case EVENTS_ID:
-                return "vnd.android.cursor.item/event";
-            case REMINDERS:
-                return "vnd.android.cursor.dir/reminder";
-            case REMINDERS_ID:
-                return "vnd.android.cursor.item/reminder";
-            case CALENDAR_ALERTS:
-                return "vnd.android.cursor.dir/calendar-alert";
-            case CALENDAR_ALERTS_BY_INSTANCE:
-                return "vnd.android.cursor.dir/calendar-alert-by-instance";
-            case CALENDAR_ALERTS_ID:
-                return "vnd.android.cursor.item/calendar-alert";
-            case INSTANCES:
-            case INSTANCES_BY_DAY:
-            case EVENT_DAYS:
-                return "vnd.android.cursor.dir/event-instance";
-            case TIME:
-                return "time/epoch";
-            case PROVIDER_PROPERTIES:
-                return "vnd.android.cursor.dir/property";
-            /* SPRD: Modify 20150916 of bug 474826, vcalendar issue @{ */
-            case CALENDAR_AS_VCAL:
-            case CALENDAR_AS_MULTI_VCAL:
-            return "text/x-vcalendar";
-            /* @} */
-            default:
-                throw new IllegalArgumentException("Unknown URL " + url);
-        }
-    }
-
-    /**
-     * Determines if the event is recurrent, based on the provided values.
-     */
-    public static boolean isRecurrenceEvent(String rrule, String rdate, String originalId,
-            String originalSyncId) {
-        return (!TextUtils.isEmpty(rrule) ||
-                !TextUtils.isEmpty(rdate) ||
-                !TextUtils.isEmpty(originalId) ||
-                !TextUtils.isEmpty(originalSyncId));
-    }
-
-    /**
-     * Takes an event and corrects the hrs, mins, secs if it is an allDay event.
-     * <p>
-     * AllDay events should have hrs, mins, secs set to zero. This checks if this is true and
-     * corrects the fields DTSTART, DTEND, and DURATION if necessary.
-     *
-     * @param values The values to check and correct
-     * @param modValues Any updates will be stored here.  This may be the same object as
-     *   <strong>values</strong>.
-     * @return Returns true if a correction was necessary, false otherwise
-     */
-    private boolean fixAllDayTime(ContentValues values, ContentValues modValues) {
-        Integer allDayObj = values.getAsInteger(Events.ALL_DAY);
-        if (allDayObj == null || allDayObj == 0) {
-            return false;
-        }
-
-        boolean neededCorrection = false;
-
-        Long dtstart = values.getAsLong(Events.DTSTART);
-        Long dtend = values.getAsLong(Events.DTEND);
-        String duration = values.getAsString(Events.DURATION);
-        Time time = new Time();
-        String tempValue;
-
-        // Change dtstart so h,m,s are 0 if necessary.
-        time.clear(Time.TIMEZONE_UTC);
-        time.set(dtstart.longValue());
-        if (time.hour != 0 || time.minute != 0 || time.second != 0) {
-            time.hour = 0;
-            time.minute = 0;
-            time.second = 0;
-            modValues.put(Events.DTSTART, time.toMillis(true));
-            neededCorrection = true;
-        }
-
-        // If dtend exists for this event make sure it's h,m,s are 0.
-        if (dtend != null) {
-            time.clear(Time.TIMEZONE_UTC);
-            time.set(dtend.longValue());
-            if (time.hour != 0 || time.minute != 0 || time.second != 0) {
-                time.hour = 0;
-                time.minute = 0;
-                time.second = 0;
-                dtend = time.toMillis(true);
-                modValues.put(Events.DTEND, dtend);
-                neededCorrection = true;
-            }
-        }
-
-        if (duration != null) {
-            int len = duration.length();
-            /* duration is stored as either "P<seconds>S" or "P<days>D". This checks if it's
-             * in the seconds format, and if so converts it to days.
-             */
-            if (len == 0) {
-                duration = null;
-            } else if (duration.charAt(0) == 'P' &&
-                    duration.charAt(len - 1) == 'S') {
-                int seconds = Integer.parseInt(duration.substring(1, len - 1));
-                int days = (seconds + DAY_IN_SECONDS - 1) / DAY_IN_SECONDS;
-                duration = "P" + days + "D";
-                modValues.put(Events.DURATION, duration);
-                neededCorrection = true;
-            }
-        }
-
-        return neededCorrection;
-    }
-
-
-    /**
-     * Determines whether the strings in the set name columns that may be overridden
-     * when creating a recurring event exception.
-     * <p>
-     * This uses a white list because it screens out unknown columns and is a bit safer to
-     * maintain than a black list.
-     */
-    private void checkAllowedInException(Set<String> keys) {
-        for (String str : keys) {
-            if (!ALLOWED_IN_EXCEPTION.contains(str.intern())) {
-                throw new IllegalArgumentException("Exceptions can't overwrite " + str);
-            }
-        }
-    }
-
-    /**
-     * Splits a recurrent event at a specified instance.  This is useful when modifying "this
-     * and all future events".
-     *<p>
-     * If the recurrence rule has a COUNT specified, we need to split that at the point of the
-     * exception.  If the exception is instance N (0-based), the original COUNT is reduced
-     * to N, and the exception's COUNT is set to (COUNT - N).
-     *<p>
-     * If the recurrence doesn't have a COUNT, we need to update or introduce an UNTIL value,
-     * so that the original recurrence will end just before the exception instance.  (Note
-     * that UNTIL dates are inclusive.)
-     *<p>
-     * This should not be used to update the first instance ("update all events" action).
-     *
-     * @param values The original event values; must include EVENT_TIMEZONE and DTSTART.
-     *        The RRULE value may be modified (with the expectation that this will propagate
-     *        into the exception event).
-     * @param endTimeMillis The time before which the event must end (i.e. the start time of the
-     *        exception event instance).
-     * @return Values to apply to the original event.
-     */
-    private static ContentValues setRecurrenceEnd(ContentValues values, long endTimeMillis) {
-        boolean origAllDay = values.getAsBoolean(Events.ALL_DAY);
-        String origRrule = values.getAsString(Events.RRULE);
-
-        EventRecurrence origRecurrence = new EventRecurrence();
-        origRecurrence.parse(origRrule);
-
-        // Get the start time of the first instance in the original recurrence.
-        long startTimeMillis = values.getAsLong(Events.DTSTART);
-        Time dtstart = new Time();
-        dtstart.timezone = values.getAsString(Events.EVENT_TIMEZONE);
-        dtstart.set(startTimeMillis);
-
-        ContentValues updateValues = new ContentValues();
-
-        if (origRecurrence.count > 0) {
-            /*
-             * Generate the full set of instances for this recurrence, from the first to the
-             * one just before endTimeMillis.  The list should never be empty, because this method
-             * should not be called for the first instance.  All we're really interested in is
-             * the *number* of instances found.
-             */
-            RecurrenceSet recurSet = new RecurrenceSet(values);
-            RecurrenceProcessor recurProc = new RecurrenceProcessor();
-            long[] recurrences;
-            try {
-                recurrences = recurProc.expand(dtstart, recurSet, startTimeMillis, endTimeMillis);
-            } catch (DateException de) {
-                throw new RuntimeException(de);
-            }
-
-            if (recurrences.length == 0) {
-                throw new RuntimeException("can't use this method on first instance");
-            }
-
-            EventRecurrence excepRecurrence = new EventRecurrence();
-            excepRecurrence.parse(origRrule); // TODO: add/use a copy constructor to EventRecurrence
-            excepRecurrence.count -= recurrences.length;
-            values.put(Events.RRULE, excepRecurrence.toString());
-
-            origRecurrence.count = recurrences.length;
-
-        } else {
-            Time untilTime = new Time();
-
-            // The "until" time must be in UTC time in order for Google calendar
-            // to display it properly. For all-day events, the "until" time string
-            // must include just the date field, and not the time field. The
-            // repeating events repeat up to and including the "until" time.
-            untilTime.timezone = Time.TIMEZONE_UTC;
-
-            // Subtract one second from the exception begin time to get the "until" time.
-            untilTime.set(endTimeMillis - 1000); // subtract one second (1000 millis)
-            if (origAllDay) {
-                untilTime.hour = untilTime.minute = untilTime.second = 0;
-                untilTime.allDay = true;
-                untilTime.normalize(false);
-
-                // This should no longer be necessary -- DTSTART should already be in the correct
-                // format for an all-day event.
-                dtstart.hour = dtstart.minute = dtstart.second = 0;
-                dtstart.allDay = true;
-                dtstart.timezone = Time.TIMEZONE_UTC;
-            }
-            origRecurrence.until = untilTime.format2445();
-        }
-
-        updateValues.put(Events.RRULE, origRecurrence.toString());
-        updateValues.put(Events.DTSTART, dtstart.normalize(true));
-        return updateValues;
-    }
-
-    /**
-     * Handles insertion of an exception to a recurring event.
-     * <p>
-     * There are two modes, selected based on the presence of "rrule" in modValues:
-     * <ol>
-     * <li> Create a single instance exception ("modify current event only").
-     * <li> Cap the original event, and create a new recurring event ("modify this and all
-     * future events").
-     * </ol>
-     * This may be used for "modify all instances of the event" by simply selecting the
-     * very first instance as the exception target.  In that case, the ID of the "new"
-     * exception event will be the same as the originalEventId.
-     *
-     * @param originalEventId The _id of the event to be modified
-     * @param modValues Event columns to update
-     * @param callerIsSyncAdapter Set if the content provider client is the sync adapter
-     * @return the ID of the new "exception" event, or -1 on failure
-     */
-    private long handleInsertException(long originalEventId, ContentValues modValues,
-            boolean callerIsSyncAdapter) {
-        if (DEBUG_EXCEPTION) {
-            Log.i(TAG, "RE: values: " + modValues.toString());
-        }
-
-        // Make sure they have specified an instance via originalInstanceTime.
-        Long originalInstanceTime = modValues.getAsLong(Events.ORIGINAL_INSTANCE_TIME);
-        if (originalInstanceTime == null) {
-            throw new IllegalArgumentException("Exceptions must specify " +
-                    Events.ORIGINAL_INSTANCE_TIME);
-        }
-
-        // Check for attempts to override values that shouldn't be touched.
-        checkAllowedInException(modValues.keySet());
-
-        // If this isn't the sync adapter, set the "dirty" flag in any Event we modify.
-        if (!callerIsSyncAdapter) {
-            modValues.put(Events.DIRTY, true);
-            addMutator(modValues, Events.MUTATORS);
-        }
-
-        // Wrap all database accesses in a transaction.
-        mDb.beginTransaction();
-        Cursor cursor = null;
-        try {
-            // TODO: verify that there's an instance corresponding to the specified time
-            //       (does this matter? it's weird, but not fatal?)
-
-            // Grab the full set of columns for this event.
-            cursor = mDb.query(Tables.EVENTS, null /* columns */,
-                    SQL_WHERE_ID, new String[] { String.valueOf(originalEventId) },
-                    null /* groupBy */, null /* having */, null /* sortOrder */);
-            if (cursor.getCount() != 1) {
-                Log.e(TAG, "Original event ID " + originalEventId + " lookup failed (count is " +
-                        cursor.getCount() + ")");
-                return -1;
-            }
-            //DatabaseUtils.dumpCursor(cursor);
-
-            // If there's a color index check that it's valid
-            String color_index = modValues.getAsString(Events.EVENT_COLOR_KEY);
-            if (!TextUtils.isEmpty(color_index)) {
-                int calIdCol = cursor.getColumnIndex(Events.CALENDAR_ID);
-                Long calId = cursor.getLong(calIdCol);
-                String accountName = null;
-                String accountType = null;
-                if (calId != null) {
-                    Account account = getAccount(calId);
-                    if (account != null) {
-                        accountName = account.name;
-                        accountType = account.type;
-                    }
-                }
-                verifyColorExists(accountName, accountType, color_index, Colors.TYPE_EVENT);
-            }
-
-            /*
-             * Verify that the original event is in fact a recurring event by checking for the
-             * presence of an RRULE.  If it's there, we assume that the event is otherwise
-             * properly constructed (e.g. no DTEND).
-             */
-            cursor.moveToFirst();
-            int rruleCol = cursor.getColumnIndex(Events.RRULE);
-            if (TextUtils.isEmpty(cursor.getString(rruleCol))) {
-                Log.e(TAG, "Original event has no rrule");
-                return -1;
-            }
-            if (DEBUG_EXCEPTION) {
-                Log.d(TAG, "RE: old RRULE is " + cursor.getString(rruleCol));
-            }
-
-            // Verify that the original event is not itself a (single-instance) exception.
-            int originalIdCol = cursor.getColumnIndex(Events.ORIGINAL_ID);
-            if (!TextUtils.isEmpty(cursor.getString(originalIdCol))) {
-                Log.e(TAG, "Original event is an exception");
-                return -1;
-            }
-
-            boolean createSingleException = TextUtils.isEmpty(modValues.getAsString(Events.RRULE));
-
-            // TODO: check for the presence of an existing exception on this event+instance?
-            //       The caller should be modifying that, not creating another exception.
-            //       (Alternatively, we could do that for them.)
-
-            // Create a new ContentValues for the new event.  Start with the original event,
-            // and drop in the new caller-supplied values.  This will set originalInstanceTime.
-            ContentValues values = new ContentValues();
-            DatabaseUtils.cursorRowToContentValues(cursor, values);
-            cursor.close();
-            cursor = null;
-
-            // TODO: if we're changing this to an all-day event, we should ensure that
-            //       hours/mins/secs on DTSTART are zeroed out (before computing DTEND).
-            //       See fixAllDayTime().
-
-            boolean createNewEvent = true;
-            if (createSingleException) {
-                /*
-                 * Save a copy of a few fields that will migrate to new places.
-                 */
-                String _id = values.getAsString(Events._ID);
-                String _sync_id = values.getAsString(Events._SYNC_ID);
-                boolean allDay = values.getAsBoolean(Events.ALL_DAY);
-
-                /*
-                 * Wipe out some fields that we don't want to clone into the exception event.
-                 */
-                for (String str : DONT_CLONE_INTO_EXCEPTION) {
-                    values.remove(str);
-                }
-
-                /*
-                 * Merge the new values on top of the existing values.  Note this sets
-                 * originalInstanceTime.
-                 */
-                values.putAll(modValues);
-
-                /*
-                 * Copy some fields to their "original" counterparts:
-                 *   _id --> original_id
-                 *   _sync_id --> original_sync_id
-                 *   allDay --> originalAllDay
-                 *
-                 * If this event hasn't been sync'ed with the server yet, the _sync_id field will
-                 * be null.  We will need to fill original_sync_id in later.  (May not be able to
-                 * do it right when our own _sync_id field gets populated, because the order of
-                 * events from the server may not be what we want -- could update the exception
-                 * before updating the original event.)
-                 *
-                 * _id is removed later (right before we write the event).
-                 */
-                values.put(Events.ORIGINAL_ID, _id);
-                values.put(Events.ORIGINAL_SYNC_ID, _sync_id);
-                values.put(Events.ORIGINAL_ALL_DAY, allDay);
-
-                // Mark the exception event status as "tentative", unless the caller has some
-                // other value in mind (like STATUS_CANCELED).
-                if (!values.containsKey(Events.STATUS)) {
-                    values.put(Events.STATUS, Events.STATUS_TENTATIVE);
-                }
-
-                // We're converting from recurring to non-recurring.
-                // Clear out RRULE, RDATE, EXRULE & EXDATE
-                // Replace DURATION with DTEND.
-                values.remove(Events.RRULE);
-                values.remove(Events.RDATE);
-                values.remove(Events.EXRULE);
-                values.remove(Events.EXDATE);
-
-                Duration duration = new Duration();
-                String durationStr = values.getAsString(Events.DURATION);
-                try {
-                    duration.parse(durationStr);
-                } catch (Exception ex) {
-                    // NullPointerException if the original event had no duration.
-                    // DateException if the duration was malformed.
-                    Log.w(TAG, "Bad duration in recurring event: " + durationStr, ex);
-                    return -1;
-                }
-
-                /*
-                 * We want to compute DTEND as an offset from the start time of the instance.
-                 * If the caller specified a new value for DTSTART, we want to use that; if not,
-                 * the DTSTART in "values" will be the start time of the first instance in the
-                 * recurrence, so we want to replace it with ORIGINAL_INSTANCE_TIME.
-                 */
-                long start;
-                if (modValues.containsKey(Events.DTSTART)) {
-                    start = values.getAsLong(Events.DTSTART);
-                } else {
-                    start = values.getAsLong(Events.ORIGINAL_INSTANCE_TIME);
-                    values.put(Events.DTSTART, start);
-                }
-                values.put(Events.DTEND, start + duration.getMillis());
-                if (DEBUG_EXCEPTION) {
-                    Log.d(TAG, "RE: ORIG_INST_TIME=" + start +
-                            ", duration=" + duration.getMillis() +
-                            ", generated DTEND=" + values.getAsLong(Events.DTEND));
-                }
-                values.remove(Events.DURATION);
-            } else {
-                /*
-                 * We're going to "split" the recurring event, making the old one stop before
-                 * this instance, and creating a new recurring event that starts here.
-                 *
-                 * No need to fill out the "original" fields -- the new event is not tied to
-                 * the previous event in any way.
-                 *
-                 * If this is the first event in the series, we can just update the existing
-                 * event with the values.
-                 */
-                boolean canceling = (values.getAsInteger(Events.STATUS) == Events.STATUS_CANCELED);
-
-                if (originalInstanceTime.equals(values.getAsLong(Events.DTSTART))) {
-                    /*
-                     * Update fields in the existing event.  Rather than use the merged data
-                     * from the cursor, we just do the update with the new value set after
-                     * removing the ORIGINAL_INSTANCE_TIME entry.
-                     */
-                    if (canceling) {
-                        // TODO: should we just call deleteEventInternal?
-                        Log.d(TAG, "Note: canceling entire event via exception call");
-                    }
-                    if (DEBUG_EXCEPTION) {
-                        Log.d(TAG, "RE: updating full event");
-                    }
-                    if (!validateRecurrenceRule(modValues)) {
-                        throw new IllegalArgumentException("Invalid recurrence rule: " +
-                                values.getAsString(Events.RRULE));
-                    }
-                    modValues.remove(Events.ORIGINAL_INSTANCE_TIME);
-                    mDb.update(Tables.EVENTS, modValues, SQL_WHERE_ID,
-                            new String[] { Long.toString(originalEventId) });
-                    createNewEvent = false; // skip event creation and related-table cloning
-                } else {
-                    if (DEBUG_EXCEPTION) {
-                        Log.d(TAG, "RE: splitting event");
-                    }
-
-                    /*
-                     * Cap the original event so it ends just before the target instance.  In
-                     * some cases (nonzero COUNT) this will also update the RRULE in "values",
-                     * so that the exception we're creating terminates appropriately.  If a
-                     * new RRULE was specified by the caller, the new rule will overwrite our
-                     * changes when we merge the new values in below (which is the desired
-                     * behavior).
-                     */
-                    ContentValues splitValues = setRecurrenceEnd(values, originalInstanceTime);
-                    mDb.update(Tables.EVENTS, splitValues, SQL_WHERE_ID,
-                            new String[] { Long.toString(originalEventId) });
-
-                    /*
-                     * Prepare the new event.  We remove originalInstanceTime, because we're now
-                     * creating a new event rather than an exception.
-                     *
-                     * We're always cloning a non-exception event (we tested to make sure the
-                     * event doesn't specify original_id, and we don't allow original_id in the
-                     * modValues), so we shouldn't end up creating a new event that looks like
-                     * an exception.
-                     */
-                    values.putAll(modValues);
-                    values.remove(Events.ORIGINAL_INSTANCE_TIME);
-                }
-            }
-
-            long newEventId;
-            if (createNewEvent) {
-                values.remove(Events._ID);      // don't try to set this explicitly
-                if (callerIsSyncAdapter) {
-                    scrubEventData(values, null);
-                } else {
-                    validateEventData(values);
-                }
-
-                newEventId = mDb.insert(Tables.EVENTS, null, values);
-                if (newEventId < 0) {
-                    Log.w(TAG, "Unable to add exception to recurring event");
-                    Log.w(TAG, "Values: " + values);
-                    return -1;
-                }
-                if (DEBUG_EXCEPTION) {
-                    Log.d(TAG, "RE: new ID is " + newEventId);
-                }
-
-                // TODO: do we need to do something like this?
-                //updateEventRawTimesLocked(id, updatedValues);
-
-                /*
-                 * Force re-computation of the Instances associated with the recurrence event.
-                 */
-                mInstancesHelper.updateInstancesLocked(values, newEventId, true, mDb);
-
-                /*
-                 * Some of the other tables (Attendees, Reminders, ExtendedProperties) reference
-                 * the Event ID.  We need to copy the entries from the old event, filling in the
-                 * new event ID, so that somebody doing a SELECT on those tables will find
-                 * matching entries.
-                 */
-                CalendarDatabaseHelper.copyEventRelatedTables(mDb, newEventId, originalEventId);
-
-                /*
-                 * If we modified Event.selfAttendeeStatus, we need to keep the corresponding
-                 * entry in the Attendees table in sync.
-                 */
-                if (modValues.containsKey(Events.SELF_ATTENDEE_STATUS)) {
-                    /*
-                     * Each Attendee is identified by email address.  To find the entry that
-                     * corresponds to "self", we want to compare that address to the owner of
-                     * the Calendar.  We're expecting to find one matching entry in Attendees.
-                     */
-                    long calendarId = values.getAsLong(Events.CALENDAR_ID);
-                    String accountName = getOwner(calendarId);
-
-                    if (accountName != null) {
-                        ContentValues attValues = new ContentValues();
-                        attValues.put(Attendees.ATTENDEE_STATUS,
-                                modValues.getAsString(Events.SELF_ATTENDEE_STATUS));
-
-                        if (DEBUG_EXCEPTION) {
-                            Log.d(TAG, "Updating attendee status for event=" + newEventId +
-                                    " name=" + accountName + " to " +
-                                    attValues.getAsString(Attendees.ATTENDEE_STATUS));
-                        }
-                        int count = mDb.update(Tables.ATTENDEES, attValues,
-                                Attendees.EVENT_ID + "=? AND " + Attendees.ATTENDEE_EMAIL + "=?",
-                                new String[] { String.valueOf(newEventId), accountName });
-                        if (count != 1 && count != 2) {
-                            // We're only expecting one matching entry.  We might briefly see
-                            // two during a server sync.
-                            Log.e(TAG, "Attendee status update on event=" + newEventId
-                                    + " touched " + count + " rows. Expected one or two rows.");
-                            if (false) {
-                                // This dumps PII in the log, don't ship with it enabled.
-                                Cursor debugCursor = mDb.query(Tables.ATTENDEES, null,
-                                        Attendees.EVENT_ID + "=? AND " +
-                                            Attendees.ATTENDEE_EMAIL + "=?",
-                                        new String[] { String.valueOf(newEventId), accountName },
-                                        null, null, null);
-                                DatabaseUtils.dumpCursor(debugCursor);
-                                if (debugCursor != null) {
-                                    debugCursor.close();
-                                }
-                            }
-                            throw new RuntimeException("Status update WTF");
-                        }
-                    }
-                }
-            } else {
-                /*
-                 * Update any Instances changed by the update to this Event.
-                 */
-                mInstancesHelper.updateInstancesLocked(values, originalEventId, false, mDb);
-                newEventId = originalEventId;
-            }
-
-            mDb.setTransactionSuccessful();
-            return newEventId;
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-            mDb.endTransaction();
-        }
-    }
-
-    /**
-     * Fills in the originalId column for previously-created exceptions to this event.  If
-     * this event is not recurring or does not have a _sync_id, this does nothing.
-     * <p>
-     * The server might send exceptions before the event they refer to.  When
-     * this happens, the originalId field will not have been set in the
-     * exception events (it's the recurrence events' _id field, so it can't be
-     * known until the recurrence event is created).  When we add a recurrence
-     * event with a non-empty _sync_id field, we write that event's _id to the
-     * originalId field of any events whose originalSyncId matches _sync_id.
-     * <p>
-     * Note _sync_id is only expected to be unique within a particular calendar.
-     *
-     * @param id The ID of the Event
-     * @param values Values for the Event being inserted
-     */
-    private void backfillExceptionOriginalIds(long id, ContentValues values) {
-        String syncId = values.getAsString(Events._SYNC_ID);
-        String rrule = values.getAsString(Events.RRULE);
-        String rdate = values.getAsString(Events.RDATE);
-        String calendarId = values.getAsString(Events.CALENDAR_ID);
-
-        if (TextUtils.isEmpty(syncId) || TextUtils.isEmpty(calendarId) ||
-                (TextUtils.isEmpty(rrule) && TextUtils.isEmpty(rdate))) {
-            // Not a recurring event, or doesn't have a server-provided sync ID.
-            return;
-        }
-
-        ContentValues originalValues = new ContentValues();
-        originalValues.put(Events.ORIGINAL_ID, id);
-        mDb.update(Tables.EVENTS, originalValues,
-                Events.ORIGINAL_SYNC_ID + "=? AND " + Events.CALENDAR_ID + "=?",
-                new String[] { syncId, calendarId });
-    }
-
-    @Override
-    protected Uri insertInTransaction(Uri uri, ContentValues values, boolean callerIsSyncAdapter) {
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "insertInTransaction: " + uri);
-        }
-        validateUriParameters(uri.getQueryParameterNames());
-        final int match = sUriMatcher.match(uri);
-        verifyTransactionAllowed(TRANSACTION_INSERT, uri, values, callerIsSyncAdapter, match,
-                null /* selection */, null /* selection args */);
-        mDb = mDbHelper.getWritableDatabase();
-
-        long id = 0;
-
-        switch (match) {
-            case SYNCSTATE:
-                id = mDbHelper.getSyncState().insert(mDb, values);
-                break;
-            case EVENTS:
-                if (!callerIsSyncAdapter) {
-                    values.put(Events.DIRTY, 1);
-                    addMutator(values, Events.MUTATORS);
-                }
-                if (!values.containsKey(Events.DTSTART)) {
-                    if (values.containsKey(Events.ORIGINAL_SYNC_ID)
-                            && values.containsKey(Events.ORIGINAL_INSTANCE_TIME)
-                            && Events.STATUS_CANCELED == values.getAsInteger(Events.STATUS)) {
-                        // event is a canceled instance of a recurring event, it doesn't these
-                        // values but lets fake some to satisfy curious consumers.
-                        final long origStart = values.getAsLong(Events.ORIGINAL_INSTANCE_TIME);
-                        values.put(Events.DTSTART, origStart);
-                        values.put(Events.DTEND, origStart);
-                        values.put(Events.EVENT_TIMEZONE, Time.TIMEZONE_UTC);
-                    } else {
-                        throw new RuntimeException("DTSTART field missing from event");
-                    }
-                }
-                // TODO: do we really need to make a copy?
-                ContentValues updatedValues = new ContentValues(values);
-                if (callerIsSyncAdapter) {
-                    scrubEventData(updatedValues, null);
-                } else {
-                    validateEventData(updatedValues);
-                }
-                // updateLastDate must be after validation, to ensure proper last date computation
-                updatedValues = updateLastDate(updatedValues);
-                if (updatedValues == null) {
-                    throw new RuntimeException("Could not insert event.");
-                    // return null;
-                }
-                Long calendar_id = updatedValues.getAsLong(Events.CALENDAR_ID);
-                if (calendar_id == null) {
-                    // validateEventData checks this for non-sync adapter
-                    // inserts
-                    throw new IllegalArgumentException("New events must specify a calendar id");
-                }
-                // Verify the color is valid if it is being set
-                String color_id = updatedValues.getAsString(Events.EVENT_COLOR_KEY);
-                if (!TextUtils.isEmpty(color_id)) {
-                    Account account = getAccount(calendar_id);
-                    String accountName = null;
-                    String accountType = null;
-                    if (account != null) {
-                        accountName = account.name;
-                        accountType = account.type;
-                    }
-                    int color = verifyColorExists(accountName, accountType, color_id,
-                            Colors.TYPE_EVENT);
-                    updatedValues.put(Events.EVENT_COLOR, color);
-                }
-                String owner = null;
-                if (!updatedValues.containsKey(Events.ORGANIZER)) {
-                    owner = getOwner(calendar_id);
-                    // TODO: This isn't entirely correct.  If a guest is adding a recurrence
-                    // exception to an event, the organizer should stay the original organizer.
-                    // This value doesn't go to the server and it will get fixed on sync,
-                    // so it shouldn't really matter.
-                    if (owner != null) {
-                        updatedValues.put(Events.ORGANIZER, owner);
-                    }
-                }
-                if (updatedValues.containsKey(Events.ORIGINAL_SYNC_ID)
-                        && !updatedValues.containsKey(Events.ORIGINAL_ID)) {
-                    long originalId = getOriginalId(updatedValues
-                            .getAsString(Events.ORIGINAL_SYNC_ID),
-                            updatedValues.getAsString(Events.CALENDAR_ID));
-                    if (originalId != -1) {
-                        updatedValues.put(Events.ORIGINAL_ID, originalId);
-                    }
-                } else if (!updatedValues.containsKey(Events.ORIGINAL_SYNC_ID)
-                        && updatedValues.containsKey(Events.ORIGINAL_ID)) {
-                    String originalSyncId = getOriginalSyncId(updatedValues
-                            .getAsLong(Events.ORIGINAL_ID));
-                    if (!TextUtils.isEmpty(originalSyncId)) {
-                        updatedValues.put(Events.ORIGINAL_SYNC_ID, originalSyncId);
-                    }
-                }
-                if (fixAllDayTime(updatedValues, updatedValues)) {
-                    if (Log.isLoggable(TAG, Log.WARN)) {
-                        Log.w(TAG, "insertInTransaction: " +
-                                "allDay is true but sec, min, hour were not 0.");
-                    }
-                }
-                updatedValues.remove(Events.HAS_ALARM);     // should not be set by caller
-                // Insert the row
-                id = mDbHelper.eventsInsert(updatedValues);
-                if (id != -1) {
-                    updateEventRawTimesLocked(id, updatedValues);
-                    mInstancesHelper.updateInstancesLocked(updatedValues, id,
-                            true /* new event */, mDb);
-
-                    // If we inserted a new event that specified the self-attendee
-                    // status, then we need to add an entry to the attendees table.
-                    if (values.containsKey(Events.SELF_ATTENDEE_STATUS)) {
-                        int status = values.getAsInteger(Events.SELF_ATTENDEE_STATUS);
-                        if (owner == null) {
-                            owner = getOwner(calendar_id);
-                        }
-                        createAttendeeEntry(id, status, owner);
-                    }
-
-                    backfillExceptionOriginalIds(id, values);
-
-                    sendUpdateNotification(id, callerIsSyncAdapter);
-                }
-                break;
-            case EXCEPTION_ID:
-                long originalEventId = ContentUris.parseId(uri);
-                id = handleInsertException(originalEventId, values, callerIsSyncAdapter);
-                break;
-            case CALENDARS:
-                // TODO: verify that all required fields are present
-                Integer syncEvents = values.getAsInteger(Calendars.SYNC_EVENTS);
-                if (syncEvents != null && syncEvents == 1) {
-                    String accountName = values.getAsString(Calendars.ACCOUNT_NAME);
-                    String accountType = values.getAsString(
-                            Calendars.ACCOUNT_TYPE);
-                    final Account account = new Account(accountName, accountType);
-                    String eventsUrl = values.getAsString(Calendars.CAL_SYNC1);
-                    mDbHelper.scheduleSync(account, false /* two-way sync */, eventsUrl);
-                }
-                String cal_color_id = values.getAsString(Calendars.CALENDAR_COLOR_KEY);
-                if (!TextUtils.isEmpty(cal_color_id)) {
-                    String accountName = values.getAsString(Calendars.ACCOUNT_NAME);
-                    String accountType = values.getAsString(Calendars.ACCOUNT_TYPE);
-                    int color = verifyColorExists(accountName, accountType, cal_color_id,
-                            Colors.TYPE_CALENDAR);
-                    values.put(Calendars.CALENDAR_COLOR, color);
-                }
-                id = mDbHelper.calendarsInsert(values);
-                sendUpdateNotification(id, callerIsSyncAdapter);
-                break;
-            case COLORS:
-                // verifyTransactionAllowed requires this be from a sync
-                // adapter, all of the required fields are marked NOT NULL in
-                // the db. TODO Do we need explicit checks here or should we
-                // just let sqlite throw if something isn't specified?
-                String accountName = uri.getQueryParameter(Colors.ACCOUNT_NAME);
-                String accountType = uri.getQueryParameter(Colors.ACCOUNT_TYPE);
-                String colorIndex = values.getAsString(Colors.COLOR_KEY);
-                if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {
-                    throw new IllegalArgumentException("Account name and type must be non"
-                            + " empty parameters for " + uri);
-                }
-                if (TextUtils.isEmpty(colorIndex)) {
-                    throw new IllegalArgumentException("COLOR_INDEX must be non empty for " + uri);
-                }
-                if (!values.containsKey(Colors.COLOR_TYPE) || !values.containsKey(Colors.COLOR)) {
-                    throw new IllegalArgumentException(
-                            "New colors must contain COLOR_TYPE and COLOR");
-                }
-                // Make sure the account we're inserting for is the same one the
-                // adapter is claiming to be. TODO should we throw if they
-                // aren't the same?
-                values.put(Colors.ACCOUNT_NAME, accountName);
-                values.put(Colors.ACCOUNT_TYPE, accountType);
-
-                // Verify the color doesn't already exist
-                Cursor c = null;
-                try {
-                    final long colorType = values.getAsLong(Colors.COLOR_TYPE);
-                    c = getColorByTypeIndex(accountName, accountType, colorType, colorIndex);
-                    if (c.getCount() != 0) {
-                        throw new IllegalArgumentException("color type " + colorType
-                                + " and index " + colorIndex
-                                + " already exists for account and type provided");
-                    }
-                } finally {
-                    if (c != null)
-                        c.close();
-                }
-                id = mDbHelper.colorsInsert(values);
-                break;
-            case ATTENDEES: {
-                if (!values.containsKey(Attendees.EVENT_ID)) {
-                    throw new IllegalArgumentException("Attendees values must "
-                            + "contain an event_id");
-                }
-                Long eventIdObj = values.getAsLong(Reminders.EVENT_ID);
-                if (!doesEventExist(eventIdObj)) {
-                    Log.i(TAG, "Trying to insert a attendee to a non-existent event");
-                    return null;
-                }
-                if (!callerIsSyncAdapter) {
-                    final Long eventId = values.getAsLong(Attendees.EVENT_ID);
-                    mDbHelper.duplicateEvent(eventId);
-                    setEventDirty(eventId);
-                }
-                id = mDbHelper.attendeesInsert(values);
-
-                // Copy the attendee status value to the Events table.
-                updateEventAttendeeStatus(mDb, values);
-                break;
-            }
-            case REMINDERS: {
-                Long eventIdObj = values.getAsLong(Reminders.EVENT_ID);
-                if (eventIdObj == null) {
-                    throw new IllegalArgumentException("Reminders values must "
-                            + "contain a numeric event_id");
-                }
-                if (!doesEventExist(eventIdObj)) {
-                    Log.i(TAG, "Trying to insert a reminder to a non-existent event");
-                    return null;
-                }
-
-                if (!callerIsSyncAdapter) {
-                    mDbHelper.duplicateEvent(eventIdObj);
-                    setEventDirty(eventIdObj);
-                }
-                id = mDbHelper.remindersInsert(values);
-
-                // We know this event has at least one reminder, so make sure "hasAlarm" is 1.
-                setHasAlarm(eventIdObj, 1);
-
-                // Schedule another event alarm, if necessary
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "insertInternal() changing reminder");
-                }
-                mCalendarAlarm.checkNextAlarm(false /* do not remove alarms */);
-                break;
-            }
-            case CALENDAR_ALERTS: {
-                Long eventIdObj = values.getAsLong(Reminders.EVENT_ID);
-                if (eventIdObj == null) {
-                    throw new IllegalArgumentException("CalendarAlerts values must "
-                            + "contain a numeric event_id");
-                }
-                if (!doesEventExist(eventIdObj)) {
-                    Log.i(TAG, "Trying to insert an alert to a non-existent event");
-                    return null;
-                }
-                id = mDbHelper.calendarAlertsInsert(values);
-                // Note: dirty bit is not set for Alerts because it is not synced.
-                // It is generated from Reminders, which is synced.
-                break;
-            }
-            case EXTENDED_PROPERTIES: {
-                Long eventIdObj = values.getAsLong(Reminders.EVENT_ID);
-                if (eventIdObj == null) {
-                    throw new IllegalArgumentException("ExtendedProperties values must "
-                            + "contain a numeric event_id");
-                }
-                if (!doesEventExist(eventIdObj)) {
-                    Log.i(TAG, "Trying to insert extended properties to a non-existent event id = "
-                            + eventIdObj);
-                    return null;
-                }
-                if (!callerIsSyncAdapter) {
-                    final Long eventId = values
-                            .getAsLong(CalendarContract.ExtendedProperties.EVENT_ID);
-                    mDbHelper.duplicateEvent(eventId);
-                    setEventDirty(eventId);
-                }
-                id = mDbHelper.extendedPropertiesInsert(values);
-                break;
-            }
-            case EMMA:
-                // Special target used during code-coverage evaluation.
-                handleEmmaRequest(values);
-                break;
-            case EVENTS_ID:
-            case REMINDERS_ID:
-            case CALENDAR_ALERTS_ID:
-            case EXTENDED_PROPERTIES_ID:
-            case INSTANCES:
-            case INSTANCES_BY_DAY:
-            case EVENT_DAYS:
-            case PROVIDER_PROPERTIES:
-                throw new UnsupportedOperationException("Cannot insert into that URL: " + uri);
-            default:
-                throw new IllegalArgumentException("Unknown URL " + uri);
-        }
-
-        if (id < 0) {
-            return null;
-        }
-        return ContentUris.withAppendedId(uri, id);
-    }
-
-    private boolean doesEventExist(long eventId) {
-        return DatabaseUtils.queryNumEntries(mDb, Tables.EVENTS, Events._ID + "=?",
-                new String[]{String.valueOf(eventId)}) > 0;
-    }
-
-    /**
-     * Handles special commands related to EMMA code-coverage testing.
-     *
-     * @param values Parameters from the caller.
-     */
-    private static void handleEmmaRequest(ContentValues values) {
-        /*
-         * This is not part of the public API, so we can't share constants with the CTS
-         * test code.
-         *
-         * Bad requests, or attempting to request EMMA coverage data when the coverage libs
-         * aren't linked in, will cause an exception.
-         */
-        String cmd = values.getAsString("cmd");
-        if (cmd.equals("start")) {
-            // We'd like to reset the coverage data, but according to FAQ item 3.14 at
-            // http://emma.sourceforge.net/faq.html, this isn't possible in 2.0.
-            Log.d(TAG, "Emma coverage testing started");
-        } else if (cmd.equals("stop")) {
-            // Call com.vladium.emma.rt.RT.dumpCoverageData() to cause a data dump.  We
-            // may not have been built with EMMA, so we need to do this through reflection.
-            String filename = values.getAsString("outputFileName");
-
-            File coverageFile = new File(filename);
-            try {
-                Class<?> emmaRTClass = Class.forName("com.vladium.emma.rt.RT");
-                Method dumpCoverageMethod = emmaRTClass.getMethod("dumpCoverageData",
-                        coverageFile.getClass(), boolean.class, boolean.class);
-
-                dumpCoverageMethod.invoke(null, coverageFile, false /*merge*/,
-                        false /*stopDataCollection*/);
-                Log.d(TAG, "Emma coverage data written to " + filename);
-            } catch (Exception e) {
-                throw new RuntimeException("Emma coverage dump failed", e);
-            }
-        }
-    }
-
-    /**
-     * Validates the recurrence rule, if any.  We allow single- and multi-rule RRULEs.
-     * <p>
-     * TODO: Validate RDATE, EXRULE, EXDATE (possibly passing in an indication of whether we
-     * believe we have the full set, so we can reject EXRULE when not accompanied by RRULE).
-     *
-     * @return A boolean indicating successful validation.
-     */
-    private boolean validateRecurrenceRule(ContentValues values) {
-        String rrule = values.getAsString(Events.RRULE);
-
-        if (!TextUtils.isEmpty(rrule)) {
-            String[] ruleList = rrule.split("\n");
-            for (String recur : ruleList) {
-                EventRecurrence er = new EventRecurrence();
-                try {
-                    er.parse(recur);
-                } catch (EventRecurrence.InvalidFormatException ife) {
-                    Log.w(TAG, "Invalid recurrence rule: " + recur);
-                    dumpEventNoPII(values);
-                    return false;
-                }
-            }
-        }
-
-        return true;
-    }
-
-    private void dumpEventNoPII(ContentValues values) {
-        if (values == null) {
-            return;
-        }
-
-        StringBuilder bob = new StringBuilder();
-        bob.append("dtStart:       ").append(values.getAsLong(Events.DTSTART));
-        bob.append("\ndtEnd:         ").append(values.getAsLong(Events.DTEND));
-        bob.append("\nall_day:       ").append(values.getAsInteger(Events.ALL_DAY));
-        bob.append("\ntz:            ").append(values.getAsString(Events.EVENT_TIMEZONE));
-        bob.append("\ndur:           ").append(values.getAsString(Events.DURATION));
-        bob.append("\nrrule:         ").append(values.getAsString(Events.RRULE));
-        bob.append("\nrdate:         ").append(values.getAsString(Events.RDATE));
-        bob.append("\nlast_date:     ").append(values.getAsLong(Events.LAST_DATE));
-
-        bob.append("\nid:            ").append(values.getAsLong(Events._ID));
-        bob.append("\nsync_id:       ").append(values.getAsString(Events._SYNC_ID));
-        bob.append("\nori_id:        ").append(values.getAsLong(Events.ORIGINAL_ID));
-        bob.append("\nori_sync_id:   ").append(values.getAsString(Events.ORIGINAL_SYNC_ID));
-        bob.append("\nori_inst_time: ").append(values.getAsLong(Events.ORIGINAL_INSTANCE_TIME));
-        bob.append("\nori_all_day:   ").append(values.getAsInteger(Events.ORIGINAL_ALL_DAY));
-
-        Log.i(TAG, bob.toString());
-    }
-
-    /**
-     * Do some scrubbing on event data before inserting or updating. In particular make
-     * dtend, duration, etc make sense for the type of event (regular, recurrence, exception).
-     * Remove any unexpected fields.
-     *
-     * @param values the ContentValues to insert.
-     * @param modValues if non-null, explicit null entries will be added here whenever something
-     *   is removed from <strong>values</strong>.
-     */
-    private void scrubEventData(ContentValues values, ContentValues modValues) {
-        boolean hasDtend = values.getAsLong(Events.DTEND) != null;
-        boolean hasDuration = !TextUtils.isEmpty(values.getAsString(Events.DURATION));
-        boolean hasRrule = !TextUtils.isEmpty(values.getAsString(Events.RRULE));
-        boolean hasRdate = !TextUtils.isEmpty(values.getAsString(Events.RDATE));
-        boolean hasOriginalEvent = !TextUtils.isEmpty(values.getAsString(Events.ORIGINAL_SYNC_ID));
-        boolean hasOriginalInstanceTime = values.getAsLong(Events.ORIGINAL_INSTANCE_TIME) != null;
-        if (hasRrule || hasRdate) {
-            // Recurrence:
-            // dtstart is start time of first event
-            // dtend is null
-            // duration is the duration of the event
-            // rrule is a valid recurrence rule
-            // lastDate is the end of the last event or null if it repeats forever
-            // originalEvent is null
-            // originalInstanceTime is null
-            if (!validateRecurrenceRule(values)) {
-                throw new IllegalArgumentException("Invalid recurrence rule: " +
-                        values.getAsString(Events.RRULE));
-            }
-            if (hasDtend || !hasDuration || hasOriginalEvent || hasOriginalInstanceTime) {
-                Log.d(TAG, "Scrubbing DTEND, ORIGINAL_SYNC_ID, ORIGINAL_INSTANCE_TIME");
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "Invalid values for recurrence: " + values);
-                }
-                values.remove(Events.DTEND);
-                values.remove(Events.ORIGINAL_SYNC_ID);
-                values.remove(Events.ORIGINAL_INSTANCE_TIME);
-                if (modValues != null) {
-                    modValues.putNull(Events.DTEND);
-                    modValues.putNull(Events.ORIGINAL_SYNC_ID);
-                    modValues.putNull(Events.ORIGINAL_INSTANCE_TIME);
-                }
-            }
-        } else if (hasOriginalEvent || hasOriginalInstanceTime) {
-            // Recurrence exception
-            // dtstart is start time of exception event
-            // dtend is end time of exception event
-            // duration is null
-            // rrule is null
-            // lastdate is same as dtend
-            // originalEvent is the _sync_id of the recurrence
-            // originalInstanceTime is the start time of the event being replaced
-            if (!hasDtend || hasDuration || !hasOriginalEvent || !hasOriginalInstanceTime) {
-                Log.d(TAG, "Scrubbing DURATION");
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "Invalid values for recurrence exception: " + values);
-                }
-                values.remove(Events.DURATION);
-                if (modValues != null) {
-                    modValues.putNull(Events.DURATION);
-                }
-            }
-        } else {
-            // Regular event
-            // dtstart is the start time
-            // dtend is the end time
-            // duration is null
-            // rrule is null
-            // lastDate is the same as dtend
-            // originalEvent is null
-            // originalInstanceTime is null
-            if (!hasDtend || hasDuration) {
-                Log.d(TAG, "Scrubbing DURATION");
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "Invalid values for event: " + values);
-                }
-                values.remove(Events.DURATION);
-                if (modValues != null) {
-                    modValues.putNull(Events.DURATION);
-                }
-            }
-        }
-    }
-
-    /**
-     * Validates event data.  Pass in the full set of values for the event (i.e. not just
-     * a part that's being updated).
-     *
-     * @param values Event data.
-     * @throws IllegalArgumentException if bad data is found.
-     */
-    private void validateEventData(ContentValues values) {
-        if (TextUtils.isEmpty(values.getAsString(Events.CALENDAR_ID))) {
-            throw new IllegalArgumentException("Event values must include a calendar_id");
-        }
-        if (TextUtils.isEmpty(values.getAsString(Events.EVENT_TIMEZONE))) {
-            throw new IllegalArgumentException("Event values must include an eventTimezone");
-        }
-
-        boolean hasDtstart = values.getAsLong(Events.DTSTART) != null;
-        boolean hasDtend = values.getAsLong(Events.DTEND) != null;
-        boolean hasDuration = !TextUtils.isEmpty(values.getAsString(Events.DURATION));
-        boolean hasRrule = !TextUtils.isEmpty(values.getAsString(Events.RRULE));
-        boolean hasRdate = !TextUtils.isEmpty(values.getAsString(Events.RDATE));
-        if (hasRrule || hasRdate) {
-            if (!validateRecurrenceRule(values)) {
-                throw new IllegalArgumentException("Invalid recurrence rule: " +
-                        values.getAsString(Events.RRULE));
-            }
-        }
-
-        if (!hasDtstart) {
-            dumpEventNoPII(values);
-            throw new IllegalArgumentException("DTSTART cannot be empty.");
-        }
-        if (!hasDuration && !hasDtend) {
-            dumpEventNoPII(values);
-            throw new IllegalArgumentException("DTEND and DURATION cannot both be null for " +
-                    "an event.");
-        }
-        if (hasDuration && hasDtend) {
-            dumpEventNoPII(values);
-            throw new IllegalArgumentException("Cannot have both DTEND and DURATION in an event");
-        }
-    }
-
-    private void setEventDirty(long eventId) {
-        final String mutators = DatabaseUtils.stringForQuery(
-                mDb,
-                SQL_QUERY_EVENT_MUTATORS,
-                new String[]{String.valueOf(eventId)});
-        final String packageName = getCallingPackageName();
-        final String newMutators;
-        if (TextUtils.isEmpty(mutators)) {
-            newMutators = packageName;
-        } else  {
-            final String[] strings = mutators.split(",");
-            boolean found = false;
-            for (String string : strings) {
-                if (string.equals(packageName)) {
-                    found = true;
-                    break;
-                }
-            }
-            if (!found) {
-                newMutators = mutators + "," + packageName;
-            } else {
-                newMutators = mutators;
-            }
-        }
-        mDb.execSQL(SQL_UPDATE_EVENT_SET_DIRTY_AND_MUTATORS,
-                new Object[] {newMutators, eventId});
-    }
-
-    private long getOriginalId(String originalSyncId, String calendarId) {
-        if (TextUtils.isEmpty(originalSyncId) || TextUtils.isEmpty(calendarId)) {
-            return -1;
-        }
-        // Get the original id for this event
-        long originalId = -1;
-        Cursor c = null;
-        try {
-            c = query(Events.CONTENT_URI, ID_ONLY_PROJECTION,
-                    Events._SYNC_ID + "=?"  + " AND " + Events.CALENDAR_ID + "=?",
-                    new String[] {originalSyncId, calendarId}, null);
-            if (c != null && c.moveToFirst()) {
-                originalId = c.getLong(0);
-            }
-        } finally {
-            if (c != null) {
-                c.close();
-            }
-        }
-        return originalId;
-    }
-
-    private String getOriginalSyncId(long originalId) {
-        if (originalId == -1) {
-            return null;
-        }
-        // Get the original id for this event
-        String originalSyncId = null;
-        Cursor c = null;
-        try {
-            c = query(Events.CONTENT_URI, new String[] {Events._SYNC_ID},
-                    Events._ID + "=?", new String[] {Long.toString(originalId)}, null);
-            if (c != null && c.moveToFirst()) {
-                originalSyncId = c.getString(0);
-            }
-        } finally {
-            if (c != null) {
-                c.close();
-            }
-        }
-        return originalSyncId;
-    }
-
-    private Cursor getColorByTypeIndex(String accountName, String accountType, long colorType,
-            String colorIndex) {
-        return mDb.query(Tables.COLORS, COLORS_PROJECTION, COLOR_FULL_SELECTION, new String[] {
-                accountName, accountType, Long.toString(colorType), colorIndex
-        }, null, null, null);
-    }
-
-    /**
-     * Gets a calendar's "owner account", i.e. the e-mail address of the owner of the calendar.
-     *
-     * @param calId The calendar ID.
-     * @return email of owner or null
-     */
-    private String getOwner(long calId) {
-        if (calId < 0) {
-            if (Log.isLoggable(TAG, Log.ERROR)) {
-                Log.e(TAG, "Calendar Id is not valid: " + calId);
-            }
-            return null;
-        }
-        // Get the email address of this user from this Calendar
-        String emailAddress = null;
-        Cursor cursor = null;
-        try {
-            cursor = query(ContentUris.withAppendedId(Calendars.CONTENT_URI, calId),
-                    new String[] { Calendars.OWNER_ACCOUNT },
-                    null /* selection */,
-                    null /* selectionArgs */,
-                    null /* sort */);
-            if (cursor == null || !cursor.moveToFirst()) {
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "Couldn't find " + calId + " in Calendars table");
-                }
-                return null;
-            }
-            emailAddress = cursor.getString(0);
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-        return emailAddress;
-    }
-
-    private Account getAccount(long calId) {
-        Account account = null;
-        Cursor cursor = null;
-        try {
-            cursor = query(ContentUris.withAppendedId(Calendars.CONTENT_URI, calId),
-                    ACCOUNT_PROJECTION, null /* selection */, null /* selectionArgs */,
-                    null /* sort */);
-            if (cursor == null || !cursor.moveToFirst()) {
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "Couldn't find " + calId + " in Calendars table");
-                }
-                return null;
-            }
-            account = new Account(cursor.getString(ACCOUNT_NAME_INDEX),
-                    cursor.getString(ACCOUNT_TYPE_INDEX));
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-        return account;
-    }
-
-    /**
-     * Creates an entry in the Attendees table that refers to the given event
-     * and that has the given response status.
-     *
-     * @param eventId the event id that the new entry in the Attendees table
-     * should refer to
-     * @param status the response status
-     * @param emailAddress the email of the attendee
-     */
-    private void createAttendeeEntry(long eventId, int status, String emailAddress) {
-        ContentValues values = new ContentValues();
-        values.put(Attendees.EVENT_ID, eventId);
-        values.put(Attendees.ATTENDEE_STATUS, status);
-        values.put(Attendees.ATTENDEE_TYPE, Attendees.TYPE_NONE);
-        // TODO: The relationship could actually be ORGANIZER, but it will get straightened out
-        // on sync.
-        values.put(Attendees.ATTENDEE_RELATIONSHIP,
-                Attendees.RELATIONSHIP_ATTENDEE);
-        values.put(Attendees.ATTENDEE_EMAIL, emailAddress);
-
-        // We don't know the ATTENDEE_NAME but that will be filled in by the
-        // server and sent back to us.
-        mDbHelper.attendeesInsert(values);
-    }
-
-    /**
-     * Updates the attendee status in the Events table to be consistent with
-     * the value in the Attendees table.
-     *
-     * @param db the database
-     * @param attendeeValues the column values for one row in the Attendees table.
-     */
-    private void updateEventAttendeeStatus(SQLiteDatabase db, ContentValues attendeeValues) {
-        // Get the event id for this attendee
-        Long eventIdObj = attendeeValues.getAsLong(Attendees.EVENT_ID);
-        if (eventIdObj == null) {
-            Log.w(TAG, "Attendee update values don't include an event_id");
-            return;
-        }
-        long eventId = eventIdObj;
-
-        if (MULTIPLE_ATTENDEES_PER_EVENT) {
-            // Get the calendar id for this event
-            Cursor cursor = null;
-            long calId;
-            try {
-                cursor = query(ContentUris.withAppendedId(Events.CONTENT_URI, eventId),
-                        new String[] { Events.CALENDAR_ID },
-                        null /* selection */,
-                        null /* selectionArgs */,
-                        null /* sort */);
-                if (cursor == null || !cursor.moveToFirst()) {
-                    if (Log.isLoggable(TAG, Log.DEBUG)) {
-                        Log.d(TAG, "Couldn't find " + eventId + " in Events table");
-                    }
-                    return;
-                }
-                calId = cursor.getLong(0);
-            } finally {
-                if (cursor != null) {
-                    cursor.close();
-                }
-            }
-
-            // Get the owner email for this Calendar
-            String calendarEmail = null;
-            cursor = null;
-            try {
-                cursor = query(ContentUris.withAppendedId(Calendars.CONTENT_URI, calId),
-                        new String[] { Calendars.OWNER_ACCOUNT },
-                        null /* selection */,
-                        null /* selectionArgs */,
-                        null /* sort */);
-                if (cursor == null || !cursor.moveToFirst()) {
-                    if (Log.isLoggable(TAG, Log.DEBUG)) {
-                        Log.d(TAG, "Couldn't find " + calId + " in Calendars table");
-                    }
-                    return;
-                }
-                calendarEmail = cursor.getString(0);
-            } finally {
-                if (cursor != null) {
-                    cursor.close();
-                }
-            }
-
-            if (calendarEmail == null) {
-                return;
-            }
-
-            // Get the email address for this attendee
-            String attendeeEmail = null;
-            if (attendeeValues.containsKey(Attendees.ATTENDEE_EMAIL)) {
-                attendeeEmail = attendeeValues.getAsString(Attendees.ATTENDEE_EMAIL);
-            }
-
-            // If the attendee email does not match the calendar email, then this
-            // attendee is not the owner of this calendar so we don't update the
-            // selfAttendeeStatus in the event.
-            if (!calendarEmail.equals(attendeeEmail)) {
-                return;
-            }
-        }
-
-        // Select a default value for "status" based on the relationship.
-        int status = Attendees.ATTENDEE_STATUS_NONE;
-        Integer relationObj = attendeeValues.getAsInteger(Attendees.ATTENDEE_RELATIONSHIP);
-        if (relationObj != null) {
-            int rel = relationObj;
-            if (rel == Attendees.RELATIONSHIP_ORGANIZER) {
-                status = Attendees.ATTENDEE_STATUS_ACCEPTED;
-            }
-        }
-
-        // If the status is specified, use that.
-        Integer statusObj = attendeeValues.getAsInteger(Attendees.ATTENDEE_STATUS);
-        if (statusObj != null) {
-            status = statusObj;
-        }
-
-        ContentValues values = new ContentValues();
-        values.put(Events.SELF_ATTENDEE_STATUS, status);
-        db.update(Tables.EVENTS, values, SQL_WHERE_ID,
-                new String[] {String.valueOf(eventId)});
-    }
-
-    /**
-     * Set the "hasAlarm" column in the database.
-     *
-     * @param eventId The _id of the Event to update.
-     * @param val The value to set it to (0 or 1).
-     */
-    private void setHasAlarm(long eventId, int val) {
-        ContentValues values = new ContentValues();
-        values.put(Events.HAS_ALARM, val);
-        int count = mDb.update(Tables.EVENTS, values, SQL_WHERE_ID,
-                new String[] { String.valueOf(eventId) });
-        if (count != 1) {
-            Log.w(TAG, "setHasAlarm on event " + eventId + " updated " + count +
-                    " rows (expected 1)");
-        }
-    }
-
-    /**
-     * Calculates the "last date" of the event.  For a regular event this is the start time
-     * plus the duration.  For a recurring event this is the start date of the last event in
-     * the recurrence, plus the duration.  The event recurs forever, this returns -1.  If
-     * the recurrence rule can't be parsed, this returns -1.
-     *
-     * @param values
-     * @return the date, in milliseconds, since the start of the epoch (UTC), or -1 if an
-     *   exceptional condition exists.
-     * @throws DateException
-     */
-    long calculateLastDate(ContentValues values)
-            throws DateException {
-        // Allow updates to some event fields like the title or hasAlarm
-        // without requiring DTSTART.
-        if (!values.containsKey(Events.DTSTART)) {
-            if (values.containsKey(Events.DTEND) || values.containsKey(Events.RRULE)
-                    || values.containsKey(Events.DURATION)
-                    || values.containsKey(Events.EVENT_TIMEZONE)
-                    || values.containsKey(Events.RDATE)
-                    || values.containsKey(Events.EXRULE)
-                    || values.containsKey(Events.EXDATE)) {
-                throw new RuntimeException("DTSTART field missing from event");
-            }
-            return -1;
-        }
-        long dtstartMillis = values.getAsLong(Events.DTSTART);
-        long lastMillis = -1;
-
-        // Can we use dtend with a repeating event?  What does that even
-        // mean?
-        // NOTE: if the repeating event has a dtend, we convert it to a
-        // duration during event processing, so this situation should not
-        // occur.
-        Long dtEnd = values.getAsLong(Events.DTEND);
-        if (dtEnd != null) {
-            lastMillis = dtEnd;
-        } else {
-            // find out how long it is
-            Duration duration = new Duration();
-            String durationStr = values.getAsString(Events.DURATION);
-            if (durationStr != null) {
-                duration.parse(durationStr);
-            }
-
-            RecurrenceSet recur = null;
-            try {
-                recur = new RecurrenceSet(values);
-            } catch (EventRecurrence.InvalidFormatException e) {
-                if (Log.isLoggable(TAG, Log.WARN)) {
-                    Log.w(TAG, "Could not parse RRULE recurrence string: " +
-                            values.get(CalendarContract.Events.RRULE), e);
-                }
-                // TODO: this should throw an exception or return a distinct error code
-                return lastMillis; // -1
-            }
-
-            if (null != recur && recur.hasRecurrence()) {
-                // the event is repeating, so find the last date it
-                // could appear on
-
-                String tz = values.getAsString(Events.EVENT_TIMEZONE);
-
-                if (TextUtils.isEmpty(tz)) {
-                    // floating timezone
-                    tz = Time.TIMEZONE_UTC;
-                }
-                Time dtstartLocal = new Time(tz);
-
-                dtstartLocal.set(dtstartMillis);
-
-                RecurrenceProcessor rp = new RecurrenceProcessor();
-                lastMillis = rp.getLastOccurence(dtstartLocal, recur);
-                if (lastMillis == -1) {
-                    // repeats forever
-                    return lastMillis;  // -1
-                }
-            } else {
-                // the event is not repeating, just use dtstartMillis
-                lastMillis = dtstartMillis;
-            }
-
-            // that was the beginning of the event.  this is the end.
-            lastMillis = duration.addTo(lastMillis);
-        }
-        return lastMillis;
-    }
-
-    /**
-     * Add LAST_DATE to values.
-     * @param values the ContentValues (in/out); must include DTSTART and, if the event is
-     *   recurring, the columns necessary to process a recurrence rule (RRULE, DURATION,
-     *   EVENT_TIMEZONE, etc).
-     * @return values on success, null on failure
-     */
-    private ContentValues updateLastDate(ContentValues values) {
-        try {
-            long last = calculateLastDate(values);
-            if (last != -1) {
-                values.put(Events.LAST_DATE, last);
-            }
-
-            return values;
-        } catch (DateException e) {
-            // don't add it if there was an error
-            if (Log.isLoggable(TAG, Log.WARN)) {
-                Log.w(TAG, "Could not calculate last date.", e);
-            }
-            return null;
-        }
-    }
-
-    /**
-     * Creates or updates an entry in the EventsRawTimes table.
-     *
-     * @param eventId The ID of the event that was just created or is being updated.
-     * @param values For a new event, the full set of event values; for an updated event,
-     *   the set of values that are being changed.
-     */
-    private void updateEventRawTimesLocked(long eventId, ContentValues values) {
-        ContentValues rawValues = new ContentValues();
-
-        rawValues.put(CalendarContract.EventsRawTimes.EVENT_ID, eventId);
-
-        String timezone = values.getAsString(Events.EVENT_TIMEZONE);
-
-        boolean allDay = false;
-        Integer allDayInteger = values.getAsInteger(Events.ALL_DAY);
-        if (allDayInteger != null) {
-            allDay = allDayInteger != 0;
-        }
-
-        if (allDay || TextUtils.isEmpty(timezone)) {
-            // floating timezone
-            timezone = Time.TIMEZONE_UTC;
-        }
-
-        Time time = new Time(timezone);
-        time.allDay = allDay;
-        Long dtstartMillis = values.getAsLong(Events.DTSTART);
-        if (dtstartMillis != null) {
-            time.set(dtstartMillis);
-            rawValues.put(CalendarContract.EventsRawTimes.DTSTART_2445, time.format2445());
-        }
-
-        Long dtendMillis = values.getAsLong(Events.DTEND);
-        if (dtendMillis != null) {
-            time.set(dtendMillis);
-            rawValues.put(CalendarContract.EventsRawTimes.DTEND_2445, time.format2445());
-        }
-
-        Long originalInstanceMillis = values.getAsLong(Events.ORIGINAL_INSTANCE_TIME);
-        if (originalInstanceMillis != null) {
-            // This is a recurrence exception so we need to get the all-day
-            // status of the original recurring event in order to format the
-            // date correctly.
-            allDayInteger = values.getAsInteger(Events.ORIGINAL_ALL_DAY);
-            if (allDayInteger != null) {
-                time.allDay = allDayInteger != 0;
-            }
-            time.set(originalInstanceMillis);
-            rawValues.put(CalendarContract.EventsRawTimes.ORIGINAL_INSTANCE_TIME_2445,
-                    time.format2445());
-        }
-
-        Long lastDateMillis = values.getAsLong(Events.LAST_DATE);
-        if (lastDateMillis != null) {
-            time.allDay = allDay;
-            time.set(lastDateMillis);
-            rawValues.put(CalendarContract.EventsRawTimes.LAST_DATE_2445, time.format2445());
-        }
-
-        mDbHelper.eventsRawTimesReplace(rawValues);
-    }
-
-    @Override
-    protected int deleteInTransaction(Uri uri, String selection, String[] selectionArgs,
-            boolean callerIsSyncAdapter) {
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "deleteInTransaction: " + uri);
-        }
-        validateUriParameters(uri.getQueryParameterNames());
-        final int match = sUriMatcher.match(uri);
-        verifyTransactionAllowed(TRANSACTION_DELETE, uri, null, callerIsSyncAdapter, match,
-                selection, selectionArgs);
-        mDb = mDbHelper.getWritableDatabase();
-
-        switch (match) {
-            case SYNCSTATE:
-                return mDbHelper.getSyncState().delete(mDb, selection, selectionArgs);
-
-            case SYNCSTATE_ID:
-                String selectionWithId = (SyncState._ID + "=?")
-                        + (selection == null ? "" : " AND (" + selection + ")");
-                // Prepend id to selectionArgs
-                selectionArgs = insertSelectionArg(selectionArgs,
-                        String.valueOf(ContentUris.parseId(uri)));
-                return mDbHelper.getSyncState().delete(mDb, selectionWithId,
-                        selectionArgs);
-
-            case COLORS:
-                return deleteMatchingColors(appendAccountToSelection(uri, selection,
-                        Calendars.ACCOUNT_NAME, Calendars.ACCOUNT_TYPE),
-                        selectionArgs);
-
-            case EVENTS:
-            {
-                int result = 0;
-                selection = appendAccountToSelection(
-                        uri, selection, Events.ACCOUNT_NAME, Events.ACCOUNT_TYPE);
-
-                // Query this event to get the ids to delete.
-                Cursor cursor = mDb.query(Views.EVENTS, ID_ONLY_PROJECTION,
-                        selection, selectionArgs, null /* groupBy */,
-                        null /* having */, null /* sortOrder */);
-                try {
-                    while (cursor.moveToNext()) {
-                        long id = cursor.getLong(0);
-                        result += deleteEventInternal(id, callerIsSyncAdapter, true /* isBatch */);
-                    }
-                    mCalendarAlarm.checkNextAlarm(false /* do not remove alarms */);
-                    sendUpdateNotification(callerIsSyncAdapter);
-                } finally {
-                    cursor.close();
-                    cursor = null;
-                }
-                return result;
-            }
-            case EVENTS_ID:
-            {
-                long id = ContentUris.parseId(uri);
-                return deleteEventInternal(id, callerIsSyncAdapter, false /* isBatch */);
-            }
-            case EXCEPTION_ID2:
-            {
-                // This will throw NumberFormatException on missing or malformed input.
-                List<String> segments = uri.getPathSegments();
-                long eventId = Long.parseLong(segments.get(1));
-                long excepId = Long.parseLong(segments.get(2));
-                // TODO: verify that this is an exception instance (has an ORIGINAL_ID field
-                //       that matches the supplied eventId)
-                return deleteEventInternal(excepId, callerIsSyncAdapter, false /* isBatch */);
-            }
-            case ATTENDEES:
-            {
-                if (callerIsSyncAdapter) {
-                    return mDb.delete(Tables.ATTENDEES, selection, selectionArgs);
-                } else {
-                    return deleteFromEventRelatedTable(Tables.ATTENDEES, uri, selection,
-                            selectionArgs);
-                }
-            }
-            case ATTENDEES_ID:
-            {
-                if (callerIsSyncAdapter) {
-                    long id = ContentUris.parseId(uri);
-                    return mDb.delete(Tables.ATTENDEES, SQL_WHERE_ID,
-                            new String[] {String.valueOf(id)});
-                } else {
-                    return deleteFromEventRelatedTable(Tables.ATTENDEES, uri, null /* selection */,
-                                           null /* selectionArgs */);
-                }
-            }
-            case REMINDERS:
-            {
-                return deleteReminders(uri, false, selection, selectionArgs, callerIsSyncAdapter);
-            }
-            case REMINDERS_ID:
-            {
-                return deleteReminders(uri, true, null /*selection*/, null /*selectionArgs*/,
-                        callerIsSyncAdapter);
-            }
-            case EXTENDED_PROPERTIES:
-            {
-                if (callerIsSyncAdapter) {
-                    return mDb.delete(Tables.EXTENDED_PROPERTIES, selection, selectionArgs);
-                } else {
-                    return deleteFromEventRelatedTable(Tables.EXTENDED_PROPERTIES, uri, selection,
-                            selectionArgs);
-                }
-            }
-            case EXTENDED_PROPERTIES_ID:
-            {
-                if (callerIsSyncAdapter) {
-                    long id = ContentUris.parseId(uri);
-                    return mDb.delete(Tables.EXTENDED_PROPERTIES, SQL_WHERE_ID,
-                            new String[] {String.valueOf(id)});
-                } else {
-                    return deleteFromEventRelatedTable(Tables.EXTENDED_PROPERTIES, uri,
-                            null /* selection */, null /* selectionArgs */);
-                }
-            }
-            case CALENDAR_ALERTS:
-            {
-                if (callerIsSyncAdapter) {
-                    return mDb.delete(Tables.CALENDAR_ALERTS, selection, selectionArgs);
-                } else {
-                    return deleteFromEventRelatedTable(Tables.CALENDAR_ALERTS, uri, selection,
-                            selectionArgs);
-                }
-            }
-            case CALENDAR_ALERTS_ID:
-            {
-                // Note: dirty bit is not set for Alerts because it is not synced.
-                // It is generated from Reminders, which is synced.
-                long id = ContentUris.parseId(uri);
-                return mDb.delete(Tables.CALENDAR_ALERTS, SQL_WHERE_ID,
-                        new String[] {String.valueOf(id)});
-            }
-            case CALENDARS_ID:
-                StringBuilder selectionSb = new StringBuilder(Calendars._ID + "=");
-                selectionSb.append(uri.getPathSegments().get(1));
-                if (!TextUtils.isEmpty(selection)) {
-                    selectionSb.append(" AND (");
-                    selectionSb.append(selection);
-                    selectionSb.append(')');
-                }
-                selection = selectionSb.toString();
-                // $FALL-THROUGH$ - fall through to CALENDARS for the actual delete
-            case CALENDARS:
-                selection = appendAccountToSelection(uri, selection, Calendars.ACCOUNT_NAME,
-                        Calendars.ACCOUNT_TYPE);
-                return deleteMatchingCalendars(selection, selectionArgs);
-            case INSTANCES:
-            case INSTANCES_BY_DAY:
-            case EVENT_DAYS:
-            case PROVIDER_PROPERTIES:
-                throw new UnsupportedOperationException("Cannot delete that URL");
-            default:
-                throw new IllegalArgumentException("Unknown URL " + uri);
-        }
-    }
-
-    private int deleteEventInternal(long id, boolean callerIsSyncAdapter, boolean isBatch) {
-        int result = 0;
-        String selectionArgs[] = new String[] {String.valueOf(id)};
-
-        // Query this event to get the fields needed for deleting.
-        Cursor cursor = mDb.query(Tables.EVENTS, EVENTS_PROJECTION,
-                SQL_WHERE_ID, selectionArgs,
-                null /* groupBy */,
-                null /* having */, null /* sortOrder */);
-        try {
-            if (cursor.moveToNext()) {
-                result = 1;
-                String syncId = cursor.getString(EVENTS_SYNC_ID_INDEX);
-                boolean emptySyncId = TextUtils.isEmpty(syncId);
-
-                // If this was a recurring event or a recurrence
-                // exception, then force a recalculation of the
-                // instances.
-                String rrule = cursor.getString(EVENTS_RRULE_INDEX);
-                String rdate = cursor.getString(EVENTS_RDATE_INDEX);
-                String origId = cursor.getString(EVENTS_ORIGINAL_ID_INDEX);
-                String origSyncId = cursor.getString(EVENTS_ORIGINAL_SYNC_ID_INDEX);
-                if (isRecurrenceEvent(rrule, rdate, origId, origSyncId)) {
-                    mMetaData.clearInstanceRange();
-                }
-                boolean isRecurrence = !TextUtils.isEmpty(rrule) || !TextUtils.isEmpty(rdate);
-
-                // we clean the Events and Attendees table if the caller is CalendarSyncAdapter
-                // or if the event is local (no syncId)
-                //
-                // The EVENTS_CLEANUP_TRIGGER_SQL trigger will remove all associated data
-                // (Attendees, Instances, Reminders, etc).
-                if (callerIsSyncAdapter || emptySyncId) {
-                    mDb.delete(Tables.EVENTS, SQL_WHERE_ID, selectionArgs);
-
-                    // If this is a recurrence, and the event was never synced with the server,
-                    // we want to delete any exceptions as well.  (If it has been to the server,
-                    // we'll let the sync adapter delete the events explicitly.)  We assume that,
-                    // if the recurrence hasn't been synced, the exceptions haven't either.
-                    if (isRecurrence && emptySyncId) {
-                        mDb.delete(Tables.EVENTS, SQL_WHERE_ORIGINAL_ID, selectionArgs);
-                    }
-                } else {
-                    // Event is on the server, so we "soft delete", i.e. mark as deleted so that
-                    // the sync adapter has a chance to tell the server about the deletion.  After
-                    // the server sees the change, the sync adapter will do the "hard delete"
-                    // (above).
-                    ContentValues values = new ContentValues();
-                    values.put(Events.DELETED, 1);
-                    values.put(Events.DIRTY, 1);
-                    addMutator(values, Events.MUTATORS);
-                    mDb.update(Tables.EVENTS, values, SQL_WHERE_ID, selectionArgs);
-
-                    // Exceptions that have been synced shouldn't be deleted -- the sync
-                    // adapter will take care of that -- but we want to "soft delete" them so
-                    // that they will be removed from the instances list.
-                    // TODO: this seems to confuse the sync adapter, and leaves you with an
-                    //       invisible "ghost" event after the server sync.  Maybe we can fix
-                    //       this by making instance generation smarter?  Not vital, since the
-                    //       exception instances disappear after the server sync.
-                    //mDb.update(Tables.EVENTS, values, SQL_WHERE_ORIGINAL_ID_HAS_SYNC_ID,
-                    //        selectionArgs);
-
-                    // It's possible for the original event to be on the server but have
-                    // exceptions that aren't.  We want to remove all events with a matching
-                    // original_id and an empty _sync_id.
-                    mDb.delete(Tables.EVENTS, SQL_WHERE_ORIGINAL_ID_NO_SYNC_ID,
-                            selectionArgs);
-
-                    // Delete associated data; attendees, however, are deleted with the actual event
-                    //  so that the sync adapter is able to notify attendees of the cancellation.
-                    mDb.delete(Tables.INSTANCES, SQL_WHERE_EVENT_ID, selectionArgs);
-                    mDb.delete(Tables.EVENTS_RAW_TIMES, SQL_WHERE_EVENT_ID, selectionArgs);
-                    mDb.delete(Tables.REMINDERS, SQL_WHERE_EVENT_ID, selectionArgs);
-                    mDb.delete(Tables.CALENDAR_ALERTS, SQL_WHERE_EVENT_ID, selectionArgs);
-                    mDb.delete(Tables.EXTENDED_PROPERTIES, SQL_WHERE_EVENT_ID,
-                            selectionArgs);
-                }
-            }
-        } finally {
-            cursor.close();
-            cursor = null;
-        }
-
-        if (!isBatch) {
-            mCalendarAlarm.checkNextAlarm(false /* do not remove alarms */);
-            sendUpdateNotification(callerIsSyncAdapter);
-        }
-        return result;
-    }
-
-    /**
-     * Delete rows from an Event-related table (e.g. Attendees) and mark corresponding events
-     * as dirty.
-     *
-     * @param table The table to delete from
-     * @param uri The URI specifying the rows
-     * @param selection for the query
-     * @param selectionArgs for the query
-     */
-    private int deleteFromEventRelatedTable(String table, Uri uri, String selection,
-            String[] selectionArgs) {
-        if (table.equals(Tables.EVENTS)) {
-            throw new IllegalArgumentException("Don't delete Events with this method "
-                    + "(use deleteEventInternal)");
-        }
-
-        ContentValues dirtyValues = new ContentValues();
-        dirtyValues.put(Events.DIRTY, "1");
-        addMutator(dirtyValues, Events.MUTATORS);
-
-        /*
-         * Re-issue the delete URI as a query.  Note that, if this is a by-ID request, the ID
-         * will be in the URI, not selection/selectionArgs.
-         *
-         * Note that the query will return data according to the access restrictions,
-         * so we don't need to worry about deleting data we don't have permission to read.
-         */
-        Cursor c = query(uri, ID_PROJECTION, selection, selectionArgs, GENERIC_EVENT_ID);
-        int count = 0;
-        try {
-            long prevEventId = -1;
-            while (c.moveToNext()) {
-                long id = c.getLong(ID_INDEX);
-                long eventId = c.getLong(EVENT_ID_INDEX);
-                // Duplicate the event.  As a minor optimization, don't try to duplicate an
-                // event that we just duplicated on the previous iteration.
-                if (eventId != prevEventId) {
-                    mDbHelper.duplicateEvent(eventId);
-                }
-                mDb.delete(table, SQL_WHERE_ID, new String[]{String.valueOf(id)});
-                if (eventId != prevEventId) {
-                    mDb.update(Tables.EVENTS, dirtyValues, SQL_WHERE_ID,
-                            new String[] { String.valueOf(eventId)} );
-                }
-                prevEventId = eventId;
-                count++;
-            }
-        } finally {
-            c.close();
-        }
-        return count;
-    }
-
-    /**
-     * Deletes rows from the Reminders table and marks the corresponding events as dirty.
-     * Ensures the hasAlarm column in the Event is updated.
-     *
-     * @return The number of rows deleted.
-     */
-    private int deleteReminders(Uri uri, boolean byId, String selection, String[] selectionArgs,
-            boolean callerIsSyncAdapter) {
-        /*
-         * If this is a by-ID URI, make sure we have a good ID.  Also, confirm that the
-         * selection is null, since we will be ignoring it.
-         */
-        long rowId = -1;
-        if (byId) {
-            if (!TextUtils.isEmpty(selection)) {
-                throw new UnsupportedOperationException("Selection not allowed for " + uri);
-            }
-            rowId = ContentUris.parseId(uri);
-            if (rowId < 0) {
-                throw new IllegalArgumentException("ID expected but not found in " + uri);
-            }
-        }
-
-        /*
-         * Determine the set of events affected by this operation.  There can be multiple
-         * reminders with the same event_id, so to avoid beating up the database with "how many
-         * reminders are left" and "duplicate this event" requests, we want to generate a list
-         * of affected event IDs and work off that.
-         *
-         * TODO: use GROUP BY to reduce the number of rows returned in the cursor.  (The content
-         * provider query() doesn't take it as an argument.)
-         */
-        HashSet<Long> eventIdSet = new HashSet<Long>();
-        Cursor c = query(uri, new String[] { Attendees.EVENT_ID }, selection, selectionArgs, null);
-        try {
-            while (c.moveToNext()) {
-                eventIdSet.add(c.getLong(0));
-            }
-        } finally {
-            c.close();
-        }
-
-        /*
-         * If this isn't a sync adapter, duplicate each event (along with its associated tables),
-         * and mark each as "dirty".  This is for the benefit of partial-update sync.
-         */
-        if (!callerIsSyncAdapter) {
-            ContentValues dirtyValues = new ContentValues();
-            dirtyValues.put(Events.DIRTY, "1");
-            addMutator(dirtyValues, Events.MUTATORS);
-
-            Iterator<Long> iter = eventIdSet.iterator();
-            while (iter.hasNext()) {
-                long eventId = iter.next();
-                mDbHelper.duplicateEvent(eventId);
-                mDb.update(Tables.EVENTS, dirtyValues, SQL_WHERE_ID,
-                        new String[] { String.valueOf(eventId) });
-            }
-        }
-
-        /*
-         * Issue the original deletion request.  If we were called with a by-ID URI, generate
-         * a selection.
-         */
-        if (byId) {
-            selection = SQL_WHERE_ID;
-            selectionArgs = new String[] { String.valueOf(rowId) };
-        }
-        int delCount = mDb.delete(Tables.REMINDERS, selection, selectionArgs);
-
-        /*
-         * For each event, set "hasAlarm" to zero if we've deleted the last of the reminders.
-         * (If the event still has reminders, hasAlarm should already be 1.)  Because we're
-         * executing in an exclusive transaction there's no risk of racing against other
-         * database updates.
-         */
-        ContentValues noAlarmValues = new ContentValues();
-        noAlarmValues.put(Events.HAS_ALARM, 0);
-        Iterator<Long> iter = eventIdSet.iterator();
-        while (iter.hasNext()) {
-            long eventId = iter.next();
-
-            // Count up the number of reminders still associated with this event.
-            Cursor reminders = mDb.query(Tables.REMINDERS, new String[] { GENERIC_ID },
-                    SQL_WHERE_EVENT_ID, new String[] { String.valueOf(eventId) },
-                    null, null, null);
-            int reminderCount = reminders.getCount();
-            reminders.close();
-
-            if (reminderCount == 0) {
-                mDb.update(Tables.EVENTS, noAlarmValues, SQL_WHERE_ID,
-                        new String[] { String.valueOf(eventId) });
-            }
-        }
-
-        return delCount;
-    }
-
-    /**
-     * Update rows in a table and, if this is a non-sync-adapter update, mark the corresponding
-     * events as dirty.
-     * <p>
-     * This only works for tables that are associated with an event.  It is assumed that the
-     * link to the Event row is a numeric identifier in a column called "event_id".
-     *
-     * @param uri The original request URI.
-     * @param byId Set to true if the URI is expected to include an ID.
-     * @param updateValues The new values to apply.  Not all columns need be represented.
-     * @param selection For non-by-ID operations, the "where" clause to use.
-     * @param selectionArgs For non-by-ID operations, arguments to apply to the "where" clause.
-     * @param callerIsSyncAdapter Set to true if the caller is a sync adapter.
-     * @return The number of rows updated.
-     */
-    private int updateEventRelatedTable(Uri uri, String table, boolean byId,
-            ContentValues updateValues, String selection, String[] selectionArgs,
-            boolean callerIsSyncAdapter)
-    {
-        /*
-         * Confirm that the request has either an ID or a selection, but not both.  It's not
-         * actually "wrong" to have both, but it's not useful, and having neither is likely
-         * a mistake.
-         *
-         * If they provided an ID in the URI, convert it to an ID selection.
-         */
-        if (byId) {
-            if (!TextUtils.isEmpty(selection)) {
-                throw new UnsupportedOperationException("Selection not allowed for " + uri);
-            }
-            long rowId = ContentUris.parseId(uri);
-            if (rowId < 0) {
-                throw new IllegalArgumentException("ID expected but not found in " + uri);
-            }
-            selection = SQL_WHERE_ID;
-            selectionArgs = new String[] { String.valueOf(rowId) };
-        } else {
-            if (TextUtils.isEmpty(selection)) {
-                throw new UnsupportedOperationException("Selection is required for " + uri);
-            }
-        }
-
-        /*
-         * Query the events to update.  We want all the columns from the table, so we us a
-         * null projection.
-         */
-        Cursor c = mDb.query(table, null /*projection*/, selection, selectionArgs,
-                null, null, null);
-        int count = 0;
-        try {
-            if (c.getCount() == 0) {
-                Log.d(TAG, "No query results for " + uri + ", selection=" + selection +
-                        " selectionArgs=" + Arrays.toString(selectionArgs));
-                return 0;
-            }
-
-            ContentValues dirtyValues = null;
-            if (!callerIsSyncAdapter) {
-                dirtyValues = new ContentValues();
-                dirtyValues.put(Events.DIRTY, "1");
-                addMutator(dirtyValues, Events.MUTATORS);
-            }
-
-            final int idIndex = c.getColumnIndex(GENERIC_ID);
-            final int eventIdIndex = c.getColumnIndex(GENERIC_EVENT_ID);
-            if (idIndex < 0 || eventIdIndex < 0) {
-                throw new RuntimeException("Lookup on _id/event_id failed for " + uri);
-            }
-
-            /*
-             * For each row found:
-             * - merge original values with update values
-             * - update database
-             * - if not sync adapter, set "dirty" flag in corresponding event to 1
-             * - update Event attendee status
-             */
-            while (c.moveToNext()) {
-                /* copy the original values into a ContentValues, then merge the changes in */
-                ContentValues values = new ContentValues();
-                DatabaseUtils.cursorRowToContentValues(c, values);
-                values.putAll(updateValues);
-
-                long id = c.getLong(idIndex);
-                long eventId = c.getLong(eventIdIndex);
-                if (!callerIsSyncAdapter) {
-                    // Make a copy of the original, so partial-update code can see diff.
-                    mDbHelper.duplicateEvent(eventId);
-                }
-                mDb.update(table, values, SQL_WHERE_ID, new String[] { String.valueOf(id) });
-                if (!callerIsSyncAdapter) {
-                    mDb.update(Tables.EVENTS, dirtyValues, SQL_WHERE_ID,
-                            new String[] { String.valueOf(eventId) });
-                }
-                count++;
-
-                /*
-                 * The Events table has a "selfAttendeeStatus" field that usually mirrors the
-                 * "attendeeStatus" column of one row in the Attendees table.  It's the provider's
-                 * job to keep these in sync, so we have to check for changes here.  (We have
-                 * to do it way down here because this is the only point where we have the
-                 * merged Attendees values.)
-                 *
-                 * It's possible, but not expected, to have multiple Attendees entries with
-                 * matching attendeeEmail.  The behavior in this case is not defined.
-                 *
-                 * We could do this more efficiently for "bulk" updates by caching the Calendar
-                 * owner email and checking it here.
-                 */
-                if (table.equals(Tables.ATTENDEES)) {
-                    updateEventAttendeeStatus(mDb, values);
-                    sendUpdateNotification(eventId, callerIsSyncAdapter);
-                }
-            }
-        } finally {
-            c.close();
-        }
-        return count;
-    }
-
-    private int deleteMatchingColors(String selection, String[] selectionArgs) {
-        // query to find all the colors that match, for each
-        // - verify no one references it
-        // - delete color
-        Cursor c = mDb.query(Tables.COLORS, COLORS_PROJECTION, selection, selectionArgs, null,
-                null, null);
-        if (c == null) {
-            return 0;
-        }
-        try {
-            Cursor c2 = null;
-            while (c.moveToNext()) {
-                String index = c.getString(COLORS_COLOR_INDEX_INDEX);
-                String accountName = c.getString(COLORS_ACCOUNT_NAME_INDEX);
-                String accountType = c.getString(COLORS_ACCOUNT_TYPE_INDEX);
-                boolean isCalendarColor = c.getInt(COLORS_COLOR_TYPE_INDEX) == Colors.TYPE_CALENDAR;
-                try {
-                    if (isCalendarColor) {
-                        c2 = mDb.query(Tables.CALENDARS, ID_ONLY_PROJECTION,
-                                SQL_WHERE_CALENDAR_COLOR, new String[] {
-                                        accountName, accountType, index
-                                }, null, null, null);
-                        if (c2.getCount() != 0) {
-                            throw new UnsupportedOperationException("Cannot delete color " + index
-                                    + ". Referenced by " + c2.getCount() + " calendars.");
-
-                        }
-                    } else {
-                        c2 = query(Events.CONTENT_URI, ID_ONLY_PROJECTION, SQL_WHERE_EVENT_COLOR,
-                                new String[] {accountName, accountType, index}, null);
-                        if (c2.getCount() != 0) {
-                            throw new UnsupportedOperationException("Cannot delete color " + index
-                                    + ". Referenced by " + c2.getCount() + " events.");
-
-                        }
-                    }
-                } finally {
-                    if (c2 != null) {
-                        c2.close();
-                    }
-                }
-            }
-        } finally {
-            if (c != null) {
-                c.close();
-            }
-        }
-        return mDb.delete(Tables.COLORS, selection, selectionArgs);
-    }
-
-    private int deleteMatchingCalendars(String selection, String[] selectionArgs) {
-        // query to find all the calendars that match, for each
-        // - delete calendar subscription
-        // - delete calendar
-        Cursor c = mDb.query(Tables.CALENDARS, sCalendarsIdProjection, selection,
-                selectionArgs,
-                null /* groupBy */,
-                null /* having */,
-                null /* sortOrder */);
-        if (c == null) {
-            return 0;
-        }
-        try {
-            while (c.moveToNext()) {
-                long id = c.getLong(CALENDARS_INDEX_ID);
-                modifyCalendarSubscription(id, false /* not selected */);
-            }
-        } finally {
-            c.close();
-        }
-        return mDb.delete(Tables.CALENDARS, selection, selectionArgs);
-    }
-
-    private boolean doesEventExistForSyncId(String syncId) {
-        if (syncId == null) {
-            if (Log.isLoggable(TAG, Log.WARN)) {
-                Log.w(TAG, "SyncID cannot be null: " + syncId);
-            }
-            return false;
-        }
-        long count = DatabaseUtils.longForQuery(mDb, SQL_SELECT_COUNT_FOR_SYNC_ID,
-                new String[] { syncId });
-        return (count > 0);
-    }
-
-    // Check if an UPDATE with STATUS_CANCEL means that we will need to do an Update (instead of
-    // a Deletion)
-    //
-    // Deletion will be done only and only if:
-    // - event status = canceled
-    // - event is a recurrence exception that does not have its original (parent) event anymore
-    //
-    // This is due to the Server semantics that generate STATUS_CANCELED for both creation
-    // and deletion of a recurrence exception
-    // See bug #3218104
-    private boolean doesStatusCancelUpdateMeanUpdate(ContentValues values,
-            ContentValues modValues) {
-        boolean isStatusCanceled = modValues.containsKey(Events.STATUS) &&
-                (modValues.getAsInteger(Events.STATUS) == Events.STATUS_CANCELED);
-        if (isStatusCanceled) {
-            String originalSyncId = values.getAsString(Events.ORIGINAL_SYNC_ID);
-
-            if (!TextUtils.isEmpty(originalSyncId)) {
-                // This event is an exception.  See if the recurring event still exists.
-                return doesEventExistForSyncId(originalSyncId);
-            }
-        }
-        // This is the normal case, we just want an UPDATE
-        return true;
-    }
-
-    private int handleUpdateColors(ContentValues values, String selection, String[] selectionArgs) {
-        Cursor c = null;
-        int result = mDb.update(Tables.COLORS, values, selection, selectionArgs);
-        if (values.containsKey(Colors.COLOR)) {
-            try {
-                c = mDb.query(Tables.COLORS, COLORS_PROJECTION, selection, selectionArgs,
-                        null /* groupBy */, null /* having */, null /* orderBy */);
-                while (c.moveToNext()) {
-                    boolean calendarColor =
-                            c.getInt(COLORS_COLOR_TYPE_INDEX) == Colors.TYPE_CALENDAR;
-                    int color = c.getInt(COLORS_COLOR_INDEX);
-                    String[] args = {
-                            c.getString(COLORS_ACCOUNT_NAME_INDEX),
-                            c.getString(COLORS_ACCOUNT_TYPE_INDEX),
-                            c.getString(COLORS_COLOR_INDEX_INDEX)
-                    };
-                    ContentValues colorValue = new ContentValues();
-                    if (calendarColor) {
-                        colorValue.put(Calendars.CALENDAR_COLOR, color);
-                        mDb.update(Tables.CALENDARS, colorValue, SQL_WHERE_CALENDAR_COLOR, args);
-                    } else {
-                        colorValue.put(Events.EVENT_COLOR, color);
-                        mDb.update(Tables.EVENTS, colorValue, SQL_WHERE_EVENT_COLOR, args);
-                    }
-                }
-            } finally {
-                if (c != null) {
-                    c.close();
-                }
-            }
-        }
-        return result;
-    }
-
-
-    /**
-     * Handles a request to update one or more events.
-     * <p>
-     * The original event(s) will be loaded from the database, merged with the new values,
-     * and the result checked for validity.  In some cases this will alter the supplied
-     * arguments (e.g. zeroing out the times on all-day events), change additional fields (e.g.
-     * update LAST_DATE when DTSTART changes), or cause modifications to other tables (e.g. reset
-     * Instances when a recurrence rule changes).
-     *
-     * @param cursor The set of events to update.
-     * @param updateValues The changes to apply to each event.
-     * @param callerIsSyncAdapter Indicates if the request comes from the sync adapter.
-     * @return the number of rows updated
-     */
-    private int handleUpdateEvents(Cursor cursor, ContentValues updateValues,
-            boolean callerIsSyncAdapter) {
-        /*
-         * This field is considered read-only.  It should not be modified by applications or
-         * by the sync adapter.
-         */
-        updateValues.remove(Events.HAS_ALARM);
-
-        /*
-         * For a single event, we can just load the event, merge modValues in, perform any
-         * fix-ups (putting changes into modValues), check validity, and then update().  We have
-         * to be careful that our fix-ups don't confuse the sync adapter.
-         *
-         * For multiple events, we need to load, merge, and validate each event individually.
-         * If no single-event-specific changes need to be made, we could just issue the original
-         * bulk update, which would be more efficient than a series of individual updates.
-         * However, doing so would prevent us from taking advantage of the partial-update
-         * mechanism.
-         */
-        if (cursor.getCount() > 1) {
-            if (Log.isLoggable(TAG, Log.DEBUG)) {
-                Log.d(TAG, "Performing update on " + cursor.getCount() + " events");
-            }
-        }
-        while (cursor.moveToNext()) {
-            // Make a copy of updateValues so we can make some local changes.
-            ContentValues modValues = new ContentValues(updateValues);
-
-            // Load the event into a ContentValues object.
-            ContentValues values = new ContentValues();
-            DatabaseUtils.cursorRowToContentValues(cursor, values);
-            boolean doValidate = false;
-            if (!callerIsSyncAdapter) {
-                try {
-                    // Check to see if the data in the database is valid.  If not, we will skip
-                    // validation of the update, so that we don't blow up on attempts to
-                    // modify existing badly-formed events.
-                    validateEventData(values);
-                    doValidate = true;
-                } catch (IllegalArgumentException iae) {
-                    Log.d(TAG, "Event " + values.getAsString(Events._ID) +
-                            " malformed, not validating update (" +
-                            iae.getMessage() + ")");
-                }
-            }
-
-            // Merge the modifications in.
-            values.putAll(modValues);
-
-            // If a color_index is being set make sure it's valid
-            String color_id = modValues.getAsString(Events.EVENT_COLOR_KEY);
-            if (!TextUtils.isEmpty(color_id)) {
-                String accountName = null;
-                String accountType = null;
-                Cursor c = mDb.query(Tables.CALENDARS, ACCOUNT_PROJECTION, SQL_WHERE_ID,
-                        new String[] { values.getAsString(Events.CALENDAR_ID) }, null, null, null);
-                try {
-                    if (c.moveToFirst()) {
-                        accountName = c.getString(ACCOUNT_NAME_INDEX);
-                        accountType = c.getString(ACCOUNT_TYPE_INDEX);
-                    }
-                } finally {
-                    if (c != null) {
-                        c.close();
-                    }
-                }
-                verifyColorExists(accountName, accountType, color_id, Colors.TYPE_EVENT);
-            }
-
-            // Scrub and/or validate the combined event.
-            if (callerIsSyncAdapter) {
-                scrubEventData(values, modValues);
-            }
-            if (doValidate) {
-                validateEventData(values);
-            }
-
-            // Look for any updates that could affect LAST_DATE.  It's defined as the end of
-            // the last meeting, so we need to pay attention to DURATION.
-            if (modValues.containsKey(Events.DTSTART) ||
-                    modValues.containsKey(Events.DTEND) ||
-                    modValues.containsKey(Events.DURATION) ||
-                    modValues.containsKey(Events.EVENT_TIMEZONE) ||
-                    modValues.containsKey(Events.RRULE) ||
-                    modValues.containsKey(Events.RDATE) ||
-                    modValues.containsKey(Events.EXRULE) ||
-                    modValues.containsKey(Events.EXDATE)) {
-                long newLastDate;
-                try {
-                    newLastDate = calculateLastDate(values);
-                } catch (DateException de) {
-                    throw new IllegalArgumentException("Unable to compute LAST_DATE", de);
-                }
-                Long oldLastDateObj = values.getAsLong(Events.LAST_DATE);
-                long oldLastDate = (oldLastDateObj == null) ? -1 : oldLastDateObj;
-                if (oldLastDate != newLastDate) {
-                    // This overwrites any caller-supplied LAST_DATE.  This is okay, because the
-                    // caller isn't supposed to be messing with the LAST_DATE field.
-                    if (newLastDate < 0) {
-                        modValues.putNull(Events.LAST_DATE);
-                    } else {
-                        modValues.put(Events.LAST_DATE, newLastDate);
-                    }
-                }
-            }
-
-            if (!callerIsSyncAdapter) {
-                modValues.put(Events.DIRTY, 1);
-                addMutator(modValues, Events.MUTATORS);
-            }
-
-            // Disallow updating the attendee status in the Events
-            // table.  In the future, we could support this but we
-            // would have to query and update the attendees table
-            // to keep the values consistent.
-            if (modValues.containsKey(Events.SELF_ATTENDEE_STATUS)) {
-                throw new IllegalArgumentException("Updating "
-                        + Events.SELF_ATTENDEE_STATUS
-                        + " in Events table is not allowed.");
-            }
-
-            if (fixAllDayTime(values, modValues)) {
-                if (Log.isLoggable(TAG, Log.WARN)) {
-                    Log.w(TAG, "handleUpdateEvents: " +
-                            "allDay is true but sec, min, hour were not 0.");
-                }
-            }
-
-            // For taking care about recurrences exceptions cancelations, check if this needs
-            //  to be an UPDATE or a DELETE
-            boolean isUpdate = doesStatusCancelUpdateMeanUpdate(values, modValues);
-
-            long id = values.getAsLong(Events._ID);
-
-            if (isUpdate) {
-                // If a user made a change, possibly duplicate the event so we can do a partial
-                // update. If a sync adapter made a change and that change marks an event as
-                // un-dirty, remove any duplicates that may have been created earlier.
-                if (!callerIsSyncAdapter) {
-                    mDbHelper.duplicateEvent(id);
-                } else {
-                    if (modValues.containsKey(Events.DIRTY)
-                            && modValues.getAsInteger(Events.DIRTY) == 0) {
-                        modValues.put(Events.MUTATORS, (String) null);
-                        mDbHelper.removeDuplicateEvent(id);
-                    }
-                }
-                int result = mDb.update(Tables.EVENTS, modValues, SQL_WHERE_ID,
-                        new String[] { String.valueOf(id) });
-                if (result > 0) {
-                    updateEventRawTimesLocked(id, modValues);
-                    mInstancesHelper.updateInstancesLocked(modValues, id,
-                            false /* not a new event */, mDb);
-
-                    // XXX: should we also be doing this when RRULE changes (e.g. instances
-                    //      are introduced or removed?)
-                    if (modValues.containsKey(Events.DTSTART) ||
-                            modValues.containsKey(Events.STATUS)) {
-                        // If this is a cancellation knock it out
-                        // of the instances table
-                        if (modValues.containsKey(Events.STATUS) &&
-                                modValues.getAsInteger(Events.STATUS) == Events.STATUS_CANCELED) {
-                            String[] args = new String[] {String.valueOf(id)};
-                            mDb.delete(Tables.INSTANCES, SQL_WHERE_EVENT_ID, args);
-                        }
-
-                        // The start time or status of the event changed, so run the
-                        // event alarm scheduler.
-                        if (Log.isLoggable(TAG, Log.DEBUG)) {
-                            Log.d(TAG, "updateInternal() changing event");
-                        }
-                        mCalendarAlarm.checkNextAlarm(false /* do not remove alarms */);
-                    }
-
-                    sendUpdateNotification(id, callerIsSyncAdapter);
-                }
-            } else {
-                deleteEventInternal(id, callerIsSyncAdapter, true /* isBatch */);
-                mCalendarAlarm.checkNextAlarm(false /* do not remove alarms */);
-                sendUpdateNotification(callerIsSyncAdapter);
-            }
-        }
-
-        return cursor.getCount();
-    }
-
-    @Override
-    protected int updateInTransaction(Uri uri, ContentValues values, String selection,
-            String[] selectionArgs, boolean callerIsSyncAdapter) {
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "updateInTransaction: " + uri);
-        }
-        validateUriParameters(uri.getQueryParameterNames());
-        final int match = sUriMatcher.match(uri);
-        verifyTransactionAllowed(TRANSACTION_UPDATE, uri, values, callerIsSyncAdapter, match,
-                selection, selectionArgs);
-        mDb = mDbHelper.getWritableDatabase();
-
-        switch (match) {
-            case SYNCSTATE:
-                return mDbHelper.getSyncState().update(mDb, values,
-                        appendAccountToSelection(uri, selection, Calendars.ACCOUNT_NAME,
-                                Calendars.ACCOUNT_TYPE), selectionArgs);
-
-            case SYNCSTATE_ID: {
-                selection = appendAccountToSelection(uri, selection, Calendars.ACCOUNT_NAME,
-                        Calendars.ACCOUNT_TYPE);
-                String selectionWithId = (SyncState._ID + "=?")
-                        + (selection == null ? "" : " AND (" + selection + ")");
-                // Prepend id to selectionArgs
-                selectionArgs = insertSelectionArg(selectionArgs,
-                        String.valueOf(ContentUris.parseId(uri)));
-                return mDbHelper.getSyncState().update(mDb, values, selectionWithId, selectionArgs);
-            }
-
-            /* Sprd: Added for bug473564, add backup info @{ */
-            case CALENDAR_EVENTS_UNIQUE: {
-                return uniqueEvents(mDb);
-            }
-            /* @} */
-            case COLORS:
-                int validValues = 0;
-                if (values.getAsInteger(Colors.COLOR) != null) {
-                    validValues++;
-                }
-                if (values.getAsString(Colors.DATA) != null) {
-                    validValues++;
-                }
-
-                if (values.size() != validValues) {
-                    throw new UnsupportedOperationException("You may only change the COLOR and"
-                            + " DATA columns for an existing Colors entry.");
-                }
-                return handleUpdateColors(values, appendAccountToSelection(uri, selection,
-                        Calendars.ACCOUNT_NAME, Calendars.ACCOUNT_TYPE),
-                        selectionArgs);
-
-            case CALENDARS:
-            case CALENDARS_ID:
-            {
-                long id;
-                if (match == CALENDARS_ID) {
-                    id = ContentUris.parseId(uri);
-                } else {
-                    // TODO: for supporting other sync adapters, we will need to
-                    // be able to deal with the following cases:
-                    // 1) selection to "_id=?" and pass in a selectionArgs
-                    // 2) selection to "_id IN (1, 2, 3)"
-                    // 3) selection to "delete=0 AND _id=1"
-                    if (selection != null && TextUtils.equals(selection,"_id=?")) {
-                        id = Long.parseLong(selectionArgs[0]);
-                    } else if (selection != null && selection.startsWith("_id=")) {
-                        // The ContentProviderOperation generates an _id=n string instead of
-                        // adding the id to the URL, so parse that out here.
-                        id = Long.parseLong(selection.substring(4));
-                    } else {
-                        return mDb.update(Tables.CALENDARS, values, selection, selectionArgs);
-                    }
-                }
-                if (!callerIsSyncAdapter) {
-                    values.put(Calendars.DIRTY, 1);
-                    addMutator(values, Calendars.MUTATORS);
-                } else {
-                    if (values.containsKey(Calendars.DIRTY)
-                            && values.getAsInteger(Calendars.DIRTY) == 0) {
-                        values.put(Calendars.MUTATORS, (String) null);
-                    }
-                }
-                Integer syncEvents = values.getAsInteger(Calendars.SYNC_EVENTS);
-                if (syncEvents != null) {
-                    modifyCalendarSubscription(id, syncEvents == 1);
-                }
-                String color_id = values.getAsString(Calendars.CALENDAR_COLOR_KEY);
-                if (!TextUtils.isEmpty(color_id)) {
-                    String accountName = values.getAsString(Calendars.ACCOUNT_NAME);
-                    String accountType = values.getAsString(Calendars.ACCOUNT_TYPE);
-                    if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {
-                        Account account = getAccount(id);
-                        if (account != null) {
-                            accountName = account.name;
-                            accountType = account.type;
-                        }
-                    }
-                    verifyColorExists(accountName, accountType, color_id, Colors.TYPE_CALENDAR);
-                }
-
-                int result = mDb.update(Tables.CALENDARS, values, SQL_WHERE_ID,
-                        new String[] {String.valueOf(id)});
-
-                if (result > 0) {
-                    // if visibility was toggled, we need to update alarms
-                    if (values.containsKey(Calendars.VISIBLE)) {
-                        // pass false for removeAlarms since the call to
-                        // scheduleNextAlarmLocked will remove any alarms for
-                        // non-visible events anyways. removeScheduledAlarmsLocked
-                        // does not actually have the effect we want
-                        mCalendarAlarm.checkNextAlarm(false);
-                    }
-                    // update the widget
-                    sendUpdateNotification(callerIsSyncAdapter);
-                }
-
-                return result;
-            }
-            case EVENTS:
-            case EVENTS_ID:
-            {
-                Cursor events = null;
-
-                // Grab the full set of columns for each selected event.
-                // TODO: define a projection with just the data we need (e.g. we don't need to
-                //       validate the SYNC_* columns)
-
-                try {
-                    if (match == EVENTS_ID) {
-                        // Single event, identified by ID.
-                        long id = ContentUris.parseId(uri);
-                        events = mDb.query(Tables.EVENTS, null /* columns */,
-                                SQL_WHERE_ID, new String[] { String.valueOf(id) },
-                                null /* groupBy */, null /* having */, null /* sortOrder */);
-                    } else {
-                        // One or more events, identified by the selection / selectionArgs.
-                        events = mDb.query(Tables.EVENTS, null /* columns */,
-                                selection, selectionArgs,
-                                null /* groupBy */, null /* having */, null /* sortOrder */);
-                    }
-
-                    if (events.getCount() == 0) {
-                        Log.i(TAG, "No events to update: uri=" + uri + " selection=" + selection +
-                                " selectionArgs=" + Arrays.toString(selectionArgs));
-                        return 0;
-                    }
-
-                    return handleUpdateEvents(events, values, callerIsSyncAdapter);
-                } finally {
-                    if (events != null) {
-                        events.close();
-                    }
-                }
-            }
-            case ATTENDEES:
-                return updateEventRelatedTable(uri, Tables.ATTENDEES, false, values, selection,
-                        selectionArgs, callerIsSyncAdapter);
-            case ATTENDEES_ID:
-                return updateEventRelatedTable(uri, Tables.ATTENDEES, true, values, null, null,
-                        callerIsSyncAdapter);
-
-            case CALENDAR_ALERTS_ID: {
-                // Note: dirty bit is not set for Alerts because it is not synced.
-                // It is generated from Reminders, which is synced.
-                long id = ContentUris.parseId(uri);
-                return mDb.update(Tables.CALENDAR_ALERTS, values, SQL_WHERE_ID,
-                        new String[] {String.valueOf(id)});
-            }
-            case CALENDAR_ALERTS: {
-                // Note: dirty bit is not set for Alerts because it is not synced.
-                // It is generated from Reminders, which is synced.
-                return mDb.update(Tables.CALENDAR_ALERTS, values, selection, selectionArgs);
-            }
-
-            case REMINDERS:
-                return updateEventRelatedTable(uri, Tables.REMINDERS, false, values, selection,
-                        selectionArgs, callerIsSyncAdapter);
-            case REMINDERS_ID: {
-                int count = updateEventRelatedTable(uri, Tables.REMINDERS, true, values, null, null,
-                        callerIsSyncAdapter);
-
-                // Reschedule the event alarms because the
-                // "minutes" field may have changed.
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "updateInternal() changing reminder");
-                }
-                mCalendarAlarm.checkNextAlarm(false /* do not remove alarms */);
-                return count;
-            }
-
-            case EXTENDED_PROPERTIES_ID:
-                return updateEventRelatedTable(uri, Tables.EXTENDED_PROPERTIES, true, values,
-                        null, null, callerIsSyncAdapter);
-            case SCHEDULE_ALARM_REMOVE: {
-                mCalendarAlarm.checkNextAlarm(true);
-                return 0;
-            }
-
-            case PROVIDER_PROPERTIES: {
-                if (!selection.equals("key=?")) {
-                    throw new UnsupportedOperationException("Selection should be key=? for " + uri);
-                }
-
-                List<String> list = Arrays.asList(selectionArgs);
-
-                if (list.contains(CalendarCache.KEY_TIMEZONE_INSTANCES_PREVIOUS)) {
-                    throw new UnsupportedOperationException("Invalid selection key: " +
-                            CalendarCache.KEY_TIMEZONE_INSTANCES_PREVIOUS + " for " + uri);
-                }
-
-                // Before it may be changed, save current Instances timezone for later use
-                String timezoneInstancesBeforeUpdate = mCalendarCache.readTimezoneInstances();
-
-                // Update the database with the provided values (this call may change the value
-                // of timezone Instances)
-                int result = mDb.update(Tables.CALENDAR_CACHE, values, selection, selectionArgs);
-
-                // if successful, do some house cleaning:
-                // if the timezone type is set to "home", set the Instances
-                // timezone to the previous
-                // if the timezone type is set to "auto", set the Instances
-                // timezone to the current
-                // device one
-                // if the timezone Instances is set AND if we are in "home"
-                // timezone type, then save the timezone Instance into
-                // "previous" too
-                if (result > 0) {
-                    // If we are changing timezone type...
-                    if (list.contains(CalendarCache.KEY_TIMEZONE_TYPE)) {
-                        String value = values.getAsString(CalendarCache.COLUMN_NAME_VALUE);
-                        if (value != null) {
-                            // if we are setting timezone type to "home"
-                            if (value.equals(CalendarCache.TIMEZONE_TYPE_HOME)) {
-                                String previousTimezone =
-                                        mCalendarCache.readTimezoneInstancesPrevious();
-                                if (previousTimezone != null) {
-                                    mCalendarCache.writeTimezoneInstances(previousTimezone);
-                                }
-                                // Regenerate Instances if the "home" timezone has changed
-                                // and notify widgets
-                                if (!timezoneInstancesBeforeUpdate.equals(previousTimezone) ) {
-                                    regenerateInstancesTable();
-                                    sendUpdateNotification(callerIsSyncAdapter);
-                                }
-                            }
-                            // if we are setting timezone type to "auto"
-                            else if (value.equals(CalendarCache.TIMEZONE_TYPE_AUTO)) {
-                                String localTimezone = TimeZone.getDefault().getID();
-                                mCalendarCache.writeTimezoneInstances(localTimezone);
-                                if (!timezoneInstancesBeforeUpdate.equals(localTimezone)) {
-                                    regenerateInstancesTable();
-                                    sendUpdateNotification(callerIsSyncAdapter);
-                                }
-                            }
-                        }
-                    }
-                    // If we are changing timezone Instances...
-                    else if (list.contains(CalendarCache.KEY_TIMEZONE_INSTANCES)) {
-                        // if we are in "home" timezone type...
-                        if (isHomeTimezone()) {
-                            String timezoneInstances = mCalendarCache.readTimezoneInstances();
-                            // Update the previous value
-                            mCalendarCache.writeTimezoneInstancesPrevious(timezoneInstances);
-                            // Recompute Instances if the "home" timezone has changed
-                            // and send notifications to any widgets
-                            if (timezoneInstancesBeforeUpdate != null &&
-                                    !timezoneInstancesBeforeUpdate.equals(timezoneInstances)) {
-                                regenerateInstancesTable();
-                                sendUpdateNotification(callerIsSyncAdapter);
-                            }
-                        }
-                    }
-                }
-                return result;
-            }
-
-            default:
-                throw new IllegalArgumentException("Unknown URL " + uri);
-        }
-    }
-
-    /**
-     * Verifies that a color with the given index exists for the given Calendar
-     * entry.
-     *
-     * @param accountName The email of the account the color is for
-     * @param accountType The type of account the color is for
-     * @param colorIndex The color_index being set for the calendar
-     * @param colorType The type of color expected (Calendar/Event)
-     * @return The color specified by the index
-     */
-    private int verifyColorExists(String accountName, String accountType, String colorIndex,
-            int colorType) {
-        if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {
-            throw new IllegalArgumentException("Cannot set color. A valid account does"
-                    + " not exist for this calendar.");
-        }
-        int color;
-        Cursor c = null;
-        try {
-            c = getColorByTypeIndex(accountName, accountType, colorType, colorIndex);
-            if (!c.moveToFirst()) {
-                throw new IllegalArgumentException("Color type: " + colorType + " and index "
-                        + colorIndex + " does not exist for account.");
-            }
-            color = c.getInt(COLORS_COLOR_INDEX);
-        } finally {
-            if (c != null) {
-                c.close();
-            }
-        }
-        return color;
-    }
-
-    private String appendLastSyncedColumnToSelection(String selection, Uri uri) {
-        if (getIsCallerSyncAdapter(uri)) {
-            return selection;
-        }
-        final StringBuilder sb = new StringBuilder();
-        sb.append(CalendarContract.Events.LAST_SYNCED).append(" = 0");
-        return appendSelection(sb, selection);
-    }
-
-    private String appendAccountToSelection(
-            Uri uri,
-            String selection,
-            String accountNameColumn,
-            String accountTypeColumn) {
-        final String accountName = QueryParameterUtils.getQueryParameter(uri,
-                CalendarContract.EventsEntity.ACCOUNT_NAME);
-        final String accountType = QueryParameterUtils.getQueryParameter(uri,
-                CalendarContract.EventsEntity.ACCOUNT_TYPE);
-        if (!TextUtils.isEmpty(accountName)) {
-            final StringBuilder sb = new StringBuilder()
-                    .append(accountNameColumn)
-                    .append("=")
-                    .append(DatabaseUtils.sqlEscapeString(accountName))
-                    .append(" AND ")
-                    .append(accountTypeColumn)
-                    .append("=")
-                    .append(DatabaseUtils.sqlEscapeString(accountType));
-            return appendSelection(sb, selection);
-        } else {
-            return selection;
-        }
-    }
-
-    private String appendSelection(StringBuilder sb, String selection) {
-        if (!TextUtils.isEmpty(selection)) {
-            sb.append(" AND (");
-            sb.append(selection);
-            sb.append(')');
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Verifies that the operation is allowed and throws an exception if it
-     * isn't. This defines the limits of a sync adapter call vs an app call.
-     * <p>
-     * Also rejects calls that have a selection but shouldn't, or that don't have a selection
-     * but should.
-     *
-     * @param type The type of call, {@link #TRANSACTION_QUERY},
-     *            {@link #TRANSACTION_INSERT}, {@link #TRANSACTION_UPDATE}, or
-     *            {@link #TRANSACTION_DELETE}
-     * @param uri
-     * @param values
-     * @param isSyncAdapter
-     */
-    private void verifyTransactionAllowed(int type, Uri uri, ContentValues values,
-            boolean isSyncAdapter, int uriMatch, String selection, String[] selectionArgs) {
-        // Queries are never restricted to app- or sync-adapter-only, and we don't
-        // restrict the set of columns that may be accessed.
-        if (type == TRANSACTION_QUERY) {
-            return;
-        }
-
-        if (type == TRANSACTION_UPDATE || type == TRANSACTION_DELETE) {
-            // TODO review this list, document in contract.
-            if (!TextUtils.isEmpty(selection)) {
-                // Only allow selections for the URIs that can reasonably use them.
-                // Whitelist of URIs allowed selections
-                switch (uriMatch) {
-                    case SYNCSTATE:
-                    case CALENDARS:
-                    case EVENTS:
-                    case ATTENDEES:
-                    case CALENDAR_ALERTS:
-                    case REMINDERS:
-                    case EXTENDED_PROPERTIES:
-                    case PROVIDER_PROPERTIES:
-                    case COLORS:
-                        break;
-                    default:
-                        throw new IllegalArgumentException("Selection not permitted for " + uri);
-                }
-            } else {
-                // Disallow empty selections for some URIs.
-                // Blacklist of URIs _not_ allowed empty selections
-                switch (uriMatch) {
-                    //SPRD: Add for bug535085, delete all events
-                    //case EVENTS:
-                    case ATTENDEES:
-                    case REMINDERS:
-                    case PROVIDER_PROPERTIES:
-                        throw new IllegalArgumentException("Selection must be specified for "
-                                + uri);
-                    default:
-                        break;
-                }
-            }
-        }
-
-        // Only the sync adapter can use these to make changes.
-        if (!isSyncAdapter) {
-            switch (uriMatch) {
-                case SYNCSTATE:
-                case SYNCSTATE_ID:
-                case EXTENDED_PROPERTIES:
-                case EXTENDED_PROPERTIES_ID:
-                case COLORS:
-                    throw new IllegalArgumentException("Only sync adapters may write using " + uri);
-                default:
-                    break;
-            }
-        }
-
-        switch (type) {
-            case TRANSACTION_INSERT:
-                if (uriMatch == INSTANCES) {
-                    throw new UnsupportedOperationException(
-                            "Inserting into instances not supported");
-                }
-                // Check there are no columns restricted to the provider
-                verifyColumns(values, uriMatch);
-                if (isSyncAdapter) {
-                    // check that account and account type are specified
-                    verifyHasAccount(uri, selection, selectionArgs);
-                } else {
-                    // check that sync only columns aren't included
-                    verifyNoSyncColumns(values, uriMatch);
-                }
-                return;
-            case TRANSACTION_UPDATE:
-                if (uriMatch == INSTANCES) {
-                    throw new UnsupportedOperationException("Updating instances not supported");
-                }
-                // Check there are no columns restricted to the provider
-                verifyColumns(values, uriMatch);
-                if (isSyncAdapter) {
-                    // check that account and account type are specified
-                    verifyHasAccount(uri, selection, selectionArgs);
-                } else {
-                    // check that sync only columns aren't included
-                    verifyNoSyncColumns(values, uriMatch);
-                }
-                return;
-            case TRANSACTION_DELETE:
-                if (uriMatch == INSTANCES) {
-                    throw new UnsupportedOperationException("Deleting instances not supported");
-                }
-                if (isSyncAdapter) {
-                    // check that account and account type are specified
-                    verifyHasAccount(uri, selection, selectionArgs);
-                }
-                return;
-        }
-    }
-
-    private void verifyHasAccount(Uri uri, String selection, String[] selectionArgs) {
-        String accountName = QueryParameterUtils.getQueryParameter(uri, Calendars.ACCOUNT_NAME);
-        String accountType = QueryParameterUtils.getQueryParameter(uri,
-                Calendars.ACCOUNT_TYPE);
-        if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {
-            if (selection != null && selection.startsWith(ACCOUNT_SELECTION_PREFIX)) {
-                accountName = selectionArgs[0];
-                accountType = selectionArgs[1];
-            }
-        }
-        if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) {
-            throw new IllegalArgumentException(
-                    "Sync adapters must specify an account and account type: " + uri);
-        }
-    }
-
-    private void verifyColumns(ContentValues values, int uriMatch) {
-        if (values == null || values.size() == 0) {
-            return;
-        }
-        String[] columns;
-        switch (uriMatch) {
-            case EVENTS:
-            case EVENTS_ID:
-            case EVENT_ENTITIES:
-            case EVENT_ENTITIES_ID:
-                columns = Events.PROVIDER_WRITABLE_COLUMNS;
-                break;
-            default:
-                columns = PROVIDER_WRITABLE_DEFAULT_COLUMNS;
-                break;
-        }
-
-        for (int i = 0; i < columns.length; i++) {
-            if (values.containsKey(columns[i])) {
-                throw new IllegalArgumentException("Only the provider may write to " + columns[i]);
-            }
-        }
-    }
-
-    private void verifyNoSyncColumns(ContentValues values, int uriMatch) {
-        if (values == null || values.size() == 0) {
-            return;
-        }
-        String[] syncColumns;
-        switch (uriMatch) {
-            case CALENDARS:
-            case CALENDARS_ID:
-            case CALENDAR_ENTITIES:
-            case CALENDAR_ENTITIES_ID:
-                syncColumns = Calendars.SYNC_WRITABLE_COLUMNS;
-                break;
-            case EVENTS:
-            case EVENTS_ID:
-            case EVENT_ENTITIES:
-            case EVENT_ENTITIES_ID:
-                syncColumns = Events.SYNC_WRITABLE_COLUMNS;
-                break;
-            default:
-                syncColumns = SYNC_WRITABLE_DEFAULT_COLUMNS;
-                break;
-
-        }
-        for (int i = 0; i < syncColumns.length; i++) {
-            if (values.containsKey(syncColumns[i])) {
-                throw new IllegalArgumentException("Only sync adapters may write to "
-                        + syncColumns[i]);
-            }
-        }
-    }
-
-    private void modifyCalendarSubscription(long id, boolean syncEvents) {
-        // get the account, url, and current selected state
-        // for this calendar.
-        Cursor cursor = query(ContentUris.withAppendedId(Calendars.CONTENT_URI, id),
-                new String[] {Calendars.ACCOUNT_NAME, Calendars.ACCOUNT_TYPE,
-                        Calendars.CAL_SYNC1, Calendars.SYNC_EVENTS},
-                null /* selection */,
-                null /* selectionArgs */,
-                null /* sort */);
-
-        Account account = null;
-        String calendarUrl = null;
-        boolean oldSyncEvents = false;
-        if (cursor != null) {
-            try {
-                if (cursor.moveToFirst()) {
-                    final String accountName = cursor.getString(0);
-                    final String accountType = cursor.getString(1);
-                    account = new Account(accountName, accountType);
-                    calendarUrl = cursor.getString(2);
-                    oldSyncEvents = (cursor.getInt(3) != 0);
-                }
-            } finally {
-                if (cursor != null)
-                    cursor.close();
-            }
-        }
-
-        if (account == null) {
-            // should not happen?
-            if (Log.isLoggable(TAG, Log.WARN)) {
-                Log.w(TAG, "Cannot update subscription because account "
-                        + "is empty -- should not happen.");
-            }
-            return;
-        }
-
-        if (TextUtils.isEmpty(calendarUrl)) {
-            // Passing in a null Url will cause it to not add any extras
-            // Should only happen for non-google calendars.
-            calendarUrl = null;
-        }
-
-        if (oldSyncEvents == syncEvents) {
-            // nothing to do
-            return;
-        }
-
-        // If the calendar is not selected for syncing, then don't download
-        // events.
-        mDbHelper.scheduleSync(account, !syncEvents, calendarUrl);
-    }
-
-    /**
-     * Call this to trigger a broadcast of the ACTION_PROVIDER_CHANGED intent.
-     * This also provides a timeout, so any calls to this method will be batched
-     * over a period of BROADCAST_TIMEOUT_MILLIS defined in this class.
-     *
-     * @param callerIsSyncAdapter whether or not the update is being triggered by a sync
-     */
-    private void sendUpdateNotification(boolean callerIsSyncAdapter) {
-        // We use -1 to represent an update to all events
-        sendUpdateNotification(-1, callerIsSyncAdapter);
-    }
-
-    /**
-     * Call this to trigger a broadcast of the ACTION_PROVIDER_CHANGED intent.
-     * This also provides a timeout, so any calls to this method will be batched
-     * over a period of BROADCAST_TIMEOUT_MILLIS defined in this class.  The
-     * actual sending of the intent is done in
-     * {@link #doSendUpdateNotification()}.
-     *
-     * TODO add support for eventId
-     *
-     * @param eventId the ID of the event that changed, or -1 for no specific event
-     * @param callerIsSyncAdapter whether or not the update is being triggered by a sync
-     */
-    private void sendUpdateNotification(long eventId,
-            boolean callerIsSyncAdapter) {
-        // Are there any pending broadcast requests?
-        if (mBroadcastHandler.hasMessages(UPDATE_BROADCAST_MSG)) {
-            // Delete any pending requests, before requeuing a fresh one
-            mBroadcastHandler.removeMessages(UPDATE_BROADCAST_MSG);
-        } else {
-            // Because the handler does not guarantee message delivery in
-            // the case that the provider is killed, we need to make sure
-            // that the provider stays alive long enough to deliver the
-            // notification. This empty service is sufficient to "wedge" the
-            // process until we stop it here.
-            mContext.startService(new Intent(mContext, EmptyService.class));
-        }
-        // We use a much longer delay for sync-related updates, to prevent any
-        // receivers from slowing down the sync
-        long delay = callerIsSyncAdapter ?
-                SYNC_UPDATE_BROADCAST_TIMEOUT_MILLIS :
-                UPDATE_BROADCAST_TIMEOUT_MILLIS;
-        // Despite the fact that we actually only ever use one message at a time
-        // for now, it is really important to call obtainMessage() to get a
-        // clean instance.  This avoids potentially infinite loops resulting
-        // adding the same instance to the message queue twice, since the
-        // message queue implements its linked list using a field from Message.
-        Message msg = mBroadcastHandler.obtainMessage(UPDATE_BROADCAST_MSG);
-        mBroadcastHandler.sendMessageDelayed(msg, delay);
-    }
-
-    /**
-     * This method should not ever be called directly, to prevent sending too
-     * many potentially expensive broadcasts.  Instead, call
-     * {@link #sendUpdateNotification(boolean)} instead.
-     *
-     * @see #sendUpdateNotification(boolean)
-     */
-    private void doSendUpdateNotification() {
-        Intent intent = new Intent(Intent.ACTION_PROVIDER_CHANGED,
-                CalendarContract.CONTENT_URI);
-        intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
-        if (Log.isLoggable(TAG, Log.INFO)) {
-            Log.i(TAG, "Sending notification intent: " + intent);
-        }
-        mContext.sendBroadcast(intent, null);
-    }
-
-    private static final int TRANSACTION_QUERY = 0;
-    private static final int TRANSACTION_INSERT = 1;
-    private static final int TRANSACTION_UPDATE = 2;
-    private static final int TRANSACTION_DELETE = 3;
-
-    // @formatter:off
-    private static final String[] SYNC_WRITABLE_DEFAULT_COLUMNS = new String[] {
-        CalendarContract.Calendars.DIRTY,
-        CalendarContract.Calendars._SYNC_ID
-    };
-    private static final String[] PROVIDER_WRITABLE_DEFAULT_COLUMNS = new String[] {
-    };
-    // @formatter:on
-
-    private static final int EVENTS = 1;
-    private static final int EVENTS_ID = 2;
-    private static final int INSTANCES = 3;
-    private static final int CALENDARS = 4;
-    private static final int CALENDARS_ID = 5;
-    private static final int ATTENDEES = 6;
-    private static final int ATTENDEES_ID = 7;
-    private static final int REMINDERS = 8;
-    private static final int REMINDERS_ID = 9;
-    private static final int EXTENDED_PROPERTIES = 10;
-    private static final int EXTENDED_PROPERTIES_ID = 11;
-    private static final int CALENDAR_ALERTS = 12;
-    private static final int CALENDAR_ALERTS_ID = 13;
-    private static final int CALENDAR_ALERTS_BY_INSTANCE = 14;
-    private static final int INSTANCES_BY_DAY = 15;
-    private static final int SYNCSTATE = 16;
-    private static final int SYNCSTATE_ID = 17;
-    private static final int EVENT_ENTITIES = 18;
-    private static final int EVENT_ENTITIES_ID = 19;
-    private static final int EVENT_DAYS = 20;
-    private static final int SCHEDULE_ALARM_REMOVE = 22;
-    private static final int TIME = 23;
-    private static final int CALENDAR_ENTITIES = 24;
-    private static final int CALENDAR_ENTITIES_ID = 25;
-    private static final int INSTANCES_SEARCH = 26;
-    private static final int INSTANCES_SEARCH_BY_DAY = 27;
-    private static final int PROVIDER_PROPERTIES = 28;
-    private static final int EXCEPTION_ID = 29;
-    private static final int EXCEPTION_ID2 = 30;
-    private static final int EMMA = 31;
-    private static final int COLORS = 32;
-    /* Sprd: Added for bug473564, add backup info @{ */
-    private static final int CALENDAR_EVENTS_UNIQUE = 33;
-    /* @} */
-
-    private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
-    private static final HashMap<String, String> sInstancesProjectionMap;
-    private static final HashMap<String, String> sColorsProjectionMap;
-    protected static final HashMap<String, String> sCalendarsProjectionMap;
-    protected static final HashMap<String, String> sEventsProjectionMap;
-    private static final HashMap<String, String> sEventEntitiesProjectionMap;
-    private static final HashMap<String, String> sAttendeesProjectionMap;
-    private static final HashMap<String, String> sRemindersProjectionMap;
-    private static final HashMap<String, String> sCalendarAlertsProjectionMap;
-    private static final HashMap<String, String> sCalendarCacheProjectionMap;
-    private static final HashMap<String, String> sCountProjectionMap;
-
-    static {
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "instances/when/*/*", INSTANCES);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "instances/whenbyday/*/*", INSTANCES_BY_DAY);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "instances/search/*/*/*", INSTANCES_SEARCH);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "instances/searchbyday/*/*/*",
-                INSTANCES_SEARCH_BY_DAY);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "instances/groupbyday/*/*", EVENT_DAYS);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "events", EVENTS);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "events/#", EVENTS_ID);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "event_entities", EVENT_ENTITIES);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "event_entities/#", EVENT_ENTITIES_ID);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "calendars", CALENDARS);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "calendars/#", CALENDARS_ID);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "calendar_entities", CALENDAR_ENTITIES);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "calendar_entities/#", CALENDAR_ENTITIES_ID);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "attendees", ATTENDEES);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "attendees/#", ATTENDEES_ID);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "reminders", REMINDERS);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "reminders/#", REMINDERS_ID);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "extendedproperties", EXTENDED_PROPERTIES);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "extendedproperties/#",
-                EXTENDED_PROPERTIES_ID);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "calendar_alerts", CALENDAR_ALERTS);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "calendar_alerts/#", CALENDAR_ALERTS_ID);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "calendar_alerts/by_instance",
-                           CALENDAR_ALERTS_BY_INSTANCE);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "syncstate", SYNCSTATE);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "syncstate/#", SYNCSTATE_ID);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY,
-                CalendarAlarmManager.SCHEDULE_ALARM_REMOVE_PATH, SCHEDULE_ALARM_REMOVE);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "time/#", TIME);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "time", TIME);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "properties", PROVIDER_PROPERTIES);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "exception/#", EXCEPTION_ID);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "exception/#/#", EXCEPTION_ID2);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "emma", EMMA);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "colors", COLORS);
-        /* SPRD: Modify 20150916 of bug 474826, vcalendar issue @{ */
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "events/as_vcal/*",
-                CALENDAR_AS_VCAL);
-        sUriMatcher.addURI(CalendarContract.AUTHORITY,
-                "events/as_multi_vcal/*", CALENDAR_AS_MULTI_VCAL);
-        /* @} */
-        /* Sprd: Added for bug473564, add backup info @{ */
-        sUriMatcher.addURI(CalendarContract.AUTHORITY, "events/unique", CALENDAR_EVENTS_UNIQUE);
-        /* @} */
-        /** Contains just BaseColumns._COUNT */
-        sCountProjectionMap = new HashMap<String, String>();
-        sCountProjectionMap.put(BaseColumns._COUNT, "COUNT(*) AS " + BaseColumns._COUNT);
-
-        sColorsProjectionMap = new HashMap<String, String>();
-        sColorsProjectionMap.put(Colors._ID, Colors._ID);
-        sColorsProjectionMap.put(Colors.DATA, Colors.DATA);
-        sColorsProjectionMap.put(Colors.ACCOUNT_NAME, Colors.ACCOUNT_NAME);
-        sColorsProjectionMap.put(Colors.ACCOUNT_TYPE, Colors.ACCOUNT_TYPE);
-        sColorsProjectionMap.put(Colors.COLOR_KEY, Colors.COLOR_KEY);
-        sColorsProjectionMap.put(Colors.COLOR_TYPE, Colors.COLOR_TYPE);
-        sColorsProjectionMap.put(Colors.COLOR, Colors.COLOR);
-
-        sCalendarsProjectionMap = new HashMap<String, String>();
-        sCalendarsProjectionMap.put(Calendars._ID, Calendars._ID);
-        sCalendarsProjectionMap.put(Calendars.ACCOUNT_NAME, Calendars.ACCOUNT_NAME);
-        sCalendarsProjectionMap.put(Calendars.ACCOUNT_TYPE, Calendars.ACCOUNT_TYPE);
-        sCalendarsProjectionMap.put(Calendars._SYNC_ID, Calendars._SYNC_ID);
-        sCalendarsProjectionMap.put(Calendars.DIRTY, Calendars.DIRTY);
-        sCalendarsProjectionMap.put(Calendars.MUTATORS, Calendars.MUTATORS);
-        sCalendarsProjectionMap.put(Calendars.NAME, Calendars.NAME);
-        sCalendarsProjectionMap.put(
-                Calendars.CALENDAR_DISPLAY_NAME, Calendars.CALENDAR_DISPLAY_NAME);
-        sCalendarsProjectionMap.put(Calendars.CALENDAR_COLOR, Calendars.CALENDAR_COLOR);
-        sCalendarsProjectionMap.put(Calendars.CALENDAR_COLOR_KEY, Calendars.CALENDAR_COLOR_KEY);
-        sCalendarsProjectionMap.put(Calendars.CALENDAR_ACCESS_LEVEL,
-                Calendars.CALENDAR_ACCESS_LEVEL);
-        sCalendarsProjectionMap.put(Calendars.VISIBLE, Calendars.VISIBLE);
-        sCalendarsProjectionMap.put(Calendars.SYNC_EVENTS, Calendars.SYNC_EVENTS);
-        sCalendarsProjectionMap.put(Calendars.CALENDAR_LOCATION, Calendars.CALENDAR_LOCATION);
-        sCalendarsProjectionMap.put(Calendars.CALENDAR_TIME_ZONE, Calendars.CALENDAR_TIME_ZONE);
-        sCalendarsProjectionMap.put(Calendars.OWNER_ACCOUNT, Calendars.OWNER_ACCOUNT);
-        sCalendarsProjectionMap.put(Calendars.IS_PRIMARY,
-                "COALESCE(" + Events.IS_PRIMARY + ", "
-                        + Calendars.OWNER_ACCOUNT + " = " + Calendars.ACCOUNT_NAME + ") AS "
-                        + Calendars.IS_PRIMARY);
-        sCalendarsProjectionMap.put(Calendars.CAN_ORGANIZER_RESPOND,
-                Calendars.CAN_ORGANIZER_RESPOND);
-        sCalendarsProjectionMap.put(Calendars.CAN_MODIFY_TIME_ZONE, Calendars.CAN_MODIFY_TIME_ZONE);
-        sCalendarsProjectionMap.put(Calendars.CAN_PARTIALLY_UPDATE, Calendars.CAN_PARTIALLY_UPDATE);
-        sCalendarsProjectionMap.put(Calendars.MAX_REMINDERS, Calendars.MAX_REMINDERS);
-        sCalendarsProjectionMap.put(Calendars.ALLOWED_REMINDERS, Calendars.ALLOWED_REMINDERS);
-        sCalendarsProjectionMap.put(Calendars.ALLOWED_AVAILABILITY, Calendars.ALLOWED_AVAILABILITY);
-        sCalendarsProjectionMap.put(Calendars.ALLOWED_ATTENDEE_TYPES,
-                Calendars.ALLOWED_ATTENDEE_TYPES);
-        sCalendarsProjectionMap.put(Calendars.DELETED, Calendars.DELETED);
-        sCalendarsProjectionMap.put(Calendars.CAL_SYNC1, Calendars.CAL_SYNC1);
-        sCalendarsProjectionMap.put(Calendars.CAL_SYNC2, Calendars.CAL_SYNC2);
-        sCalendarsProjectionMap.put(Calendars.CAL_SYNC3, Calendars.CAL_SYNC3);
-        sCalendarsProjectionMap.put(Calendars.CAL_SYNC4, Calendars.CAL_SYNC4);
-        sCalendarsProjectionMap.put(Calendars.CAL_SYNC5, Calendars.CAL_SYNC5);
-        sCalendarsProjectionMap.put(Calendars.CAL_SYNC6, Calendars.CAL_SYNC6);
-        sCalendarsProjectionMap.put(Calendars.CAL_SYNC7, Calendars.CAL_SYNC7);
-        sCalendarsProjectionMap.put(Calendars.CAL_SYNC8, Calendars.CAL_SYNC8);
-        sCalendarsProjectionMap.put(Calendars.CAL_SYNC9, Calendars.CAL_SYNC9);
-        sCalendarsProjectionMap.put(Calendars.CAL_SYNC10, Calendars.CAL_SYNC10);
-
-        sEventsProjectionMap = new HashMap<String, String>();
-        // Events columns
-        sEventsProjectionMap.put(Events.ACCOUNT_NAME, Events.ACCOUNT_NAME);
-        sEventsProjectionMap.put(Events.ACCOUNT_TYPE, Events.ACCOUNT_TYPE);
-        sEventsProjectionMap.put(Events.TITLE, Events.TITLE);
-        sEventsProjectionMap.put(Events.EVENT_LOCATION, Events.EVENT_LOCATION);
-        sEventsProjectionMap.put(Events.DESCRIPTION, Events.DESCRIPTION);
-        sEventsProjectionMap.put(Events.STATUS, Events.STATUS);
-        sEventsProjectionMap.put(Events.EVENT_COLOR, Events.EVENT_COLOR);
-        sEventsProjectionMap.put(Events.EVENT_COLOR_KEY, Events.EVENT_COLOR_KEY);
-        sEventsProjectionMap.put(Events.SELF_ATTENDEE_STATUS, Events.SELF_ATTENDEE_STATUS);
-        sEventsProjectionMap.put(Events.DTSTART, Events.DTSTART);
-        sEventsProjectionMap.put(Events.DTEND, Events.DTEND);
-        sEventsProjectionMap.put(Events.EVENT_TIMEZONE, Events.EVENT_TIMEZONE);
-        sEventsProjectionMap.put(Events.EVENT_END_TIMEZONE, Events.EVENT_END_TIMEZONE);
-        sEventsProjectionMap.put(Events.DURATION, Events.DURATION);
-        sEventsProjectionMap.put(Events.ALL_DAY, Events.ALL_DAY);
-        sEventsProjectionMap.put(Events.ACCESS_LEVEL, Events.ACCESS_LEVEL);
-        sEventsProjectionMap.put(Events.AVAILABILITY, Events.AVAILABILITY);
-        sEventsProjectionMap.put(Events.HAS_ALARM, Events.HAS_ALARM);
-        sEventsProjectionMap.put(Events.HAS_EXTENDED_PROPERTIES, Events.HAS_EXTENDED_PROPERTIES);
-        sEventsProjectionMap.put(Events.RRULE, Events.RRULE);
-        sEventsProjectionMap.put(Events.RDATE, Events.RDATE);
-        sEventsProjectionMap.put(Events.EXRULE, Events.EXRULE);
-        sEventsProjectionMap.put(Events.EXDATE, Events.EXDATE);
-        sEventsProjectionMap.put(Events.ORIGINAL_SYNC_ID, Events.ORIGINAL_SYNC_ID);
-        sEventsProjectionMap.put(Events.ORIGINAL_ID, Events.ORIGINAL_ID);
-        sEventsProjectionMap.put(Events.ORIGINAL_INSTANCE_TIME, Events.ORIGINAL_INSTANCE_TIME);
-        sEventsProjectionMap.put(Events.ORIGINAL_ALL_DAY, Events.ORIGINAL_ALL_DAY);
-        sEventsProjectionMap.put(Events.LAST_DATE, Events.LAST_DATE);
-        sEventsProjectionMap.put(Events.HAS_ATTENDEE_DATA, Events.HAS_ATTENDEE_DATA);
-        sEventsProjectionMap.put(Events.CALENDAR_ID, Events.CALENDAR_ID);
-        sEventsProjectionMap.put(Events.GUESTS_CAN_INVITE_OTHERS, Events.GUESTS_CAN_INVITE_OTHERS);
-        sEventsProjectionMap.put(Events.GUESTS_CAN_MODIFY, Events.GUESTS_CAN_MODIFY);
-        sEventsProjectionMap.put(Events.GUESTS_CAN_SEE_GUESTS, Events.GUESTS_CAN_SEE_GUESTS);
-        sEventsProjectionMap.put(Events.ORGANIZER, Events.ORGANIZER);
-        sEventsProjectionMap.put(Events.IS_ORGANIZER, Events.IS_ORGANIZER);
-        sEventsProjectionMap.put(Events.CUSTOM_APP_PACKAGE, Events.CUSTOM_APP_PACKAGE);
-        sEventsProjectionMap.put(Events.CUSTOM_APP_URI, Events.CUSTOM_APP_URI);
-        sEventsProjectionMap.put(Events.UID_2445, Events.UID_2445);
-        sEventsProjectionMap.put(Events.DELETED, Events.DELETED);
-        sEventsProjectionMap.put(Events._SYNC_ID, Events._SYNC_ID);
-
-        // Put the shared items into the Attendees, Reminders projection map
-        sAttendeesProjectionMap = new HashMap<String, String>(sEventsProjectionMap);
-        sRemindersProjectionMap = new HashMap<String, String>(sEventsProjectionMap);
-
-        // Calendar columns
-        sEventsProjectionMap.put(Calendars.CALENDAR_COLOR, Calendars.CALENDAR_COLOR);
-        sEventsProjectionMap.put(Calendars.CALENDAR_COLOR_KEY, Calendars.CALENDAR_COLOR_KEY);
-        sEventsProjectionMap.put(Calendars.CALENDAR_ACCESS_LEVEL, Calendars.CALENDAR_ACCESS_LEVEL);
-        sEventsProjectionMap.put(Calendars.VISIBLE, Calendars.VISIBLE);
-        sEventsProjectionMap.put(Calendars.CALENDAR_TIME_ZONE, Calendars.CALENDAR_TIME_ZONE);
-        sEventsProjectionMap.put(Calendars.OWNER_ACCOUNT, Calendars.OWNER_ACCOUNT);
-        sEventsProjectionMap.put(Calendars.CALENDAR_DISPLAY_NAME, Calendars.CALENDAR_DISPLAY_NAME);
-        sEventsProjectionMap.put(Calendars.ALLOWED_REMINDERS, Calendars.ALLOWED_REMINDERS);
-        sEventsProjectionMap
-                .put(Calendars.ALLOWED_ATTENDEE_TYPES, Calendars.ALLOWED_ATTENDEE_TYPES);
-        sEventsProjectionMap.put(Calendars.ALLOWED_AVAILABILITY, Calendars.ALLOWED_AVAILABILITY);
-        sEventsProjectionMap.put(Calendars.MAX_REMINDERS, Calendars.MAX_REMINDERS);
-        sEventsProjectionMap.put(Calendars.CAN_ORGANIZER_RESPOND, Calendars.CAN_ORGANIZER_RESPOND);
-        sEventsProjectionMap.put(Calendars.CAN_MODIFY_TIME_ZONE, Calendars.CAN_MODIFY_TIME_ZONE);
-        sEventsProjectionMap.put(Events.DISPLAY_COLOR, Events.DISPLAY_COLOR);
-
-        // Put the shared items into the Instances projection map
-        // The Instances and CalendarAlerts are joined with Calendars, so the projections include
-        // the above Calendar columns.
-        sInstancesProjectionMap = new HashMap<String, String>(sEventsProjectionMap);
-        sCalendarAlertsProjectionMap = new HashMap<String, String>(sEventsProjectionMap);
-
-        sEventsProjectionMap.put(Events._ID, Events._ID);
-        sEventsProjectionMap.put(Events.SYNC_DATA1, Events.SYNC_DATA1);
-        sEventsProjectionMap.put(Events.SYNC_DATA2, Events.SYNC_DATA2);
-        sEventsProjectionMap.put(Events.SYNC_DATA3, Events.SYNC_DATA3);
-        sEventsProjectionMap.put(Events.SYNC_DATA4, Events.SYNC_DATA4);
-        sEventsProjectionMap.put(Events.SYNC_DATA5, Events.SYNC_DATA5);
-        sEventsProjectionMap.put(Events.SYNC_DATA6, Events.SYNC_DATA6);
-        sEventsProjectionMap.put(Events.SYNC_DATA7, Events.SYNC_DATA7);
-        sEventsProjectionMap.put(Events.SYNC_DATA8, Events.SYNC_DATA8);
-        sEventsProjectionMap.put(Events.SYNC_DATA9, Events.SYNC_DATA9);
-        sEventsProjectionMap.put(Events.SYNC_DATA10, Events.SYNC_DATA10);
-        sEventsProjectionMap.put(Calendars.CAL_SYNC1, Calendars.CAL_SYNC1);
-        sEventsProjectionMap.put(Calendars.CAL_SYNC2, Calendars.CAL_SYNC2);
-        sEventsProjectionMap.put(Calendars.CAL_SYNC3, Calendars.CAL_SYNC3);
-        sEventsProjectionMap.put(Calendars.CAL_SYNC4, Calendars.CAL_SYNC4);
-        sEventsProjectionMap.put(Calendars.CAL_SYNC5, Calendars.CAL_SYNC5);
-        sEventsProjectionMap.put(Calendars.CAL_SYNC6, Calendars.CAL_SYNC6);
-        sEventsProjectionMap.put(Calendars.CAL_SYNC7, Calendars.CAL_SYNC7);
-        sEventsProjectionMap.put(Calendars.CAL_SYNC8, Calendars.CAL_SYNC8);
-        sEventsProjectionMap.put(Calendars.CAL_SYNC9, Calendars.CAL_SYNC9);
-        sEventsProjectionMap.put(Calendars.CAL_SYNC10, Calendars.CAL_SYNC10);
-        sEventsProjectionMap.put(Events.DIRTY, Events.DIRTY);
-        sEventsProjectionMap.put(Events.MUTATORS, Events.MUTATORS);
-        sEventsProjectionMap.put(Events.LAST_SYNCED, Events.LAST_SYNCED);
-
-        sEventEntitiesProjectionMap = new HashMap<String, String>();
-        sEventEntitiesProjectionMap.put(Events.TITLE, Events.TITLE);
-        sEventEntitiesProjectionMap.put(Events.EVENT_LOCATION, Events.EVENT_LOCATION);
-        sEventEntitiesProjectionMap.put(Events.DESCRIPTION, Events.DESCRIPTION);
-        sEventEntitiesProjectionMap.put(Events.STATUS, Events.STATUS);
-        sEventEntitiesProjectionMap.put(Events.EVENT_COLOR, Events.EVENT_COLOR);
-        sEventEntitiesProjectionMap.put(Events.EVENT_COLOR_KEY, Events.EVENT_COLOR_KEY);
-        sEventEntitiesProjectionMap.put(Events.SELF_ATTENDEE_STATUS, Events.SELF_ATTENDEE_STATUS);
-        sEventEntitiesProjectionMap.put(Events.DTSTART, Events.DTSTART);
-        sEventEntitiesProjectionMap.put(Events.DTEND, Events.DTEND);
-        sEventEntitiesProjectionMap.put(Events.EVENT_TIMEZONE, Events.EVENT_TIMEZONE);
-        sEventEntitiesProjectionMap.put(Events.EVENT_END_TIMEZONE, Events.EVENT_END_TIMEZONE);
-        sEventEntitiesProjectionMap.put(Events.DURATION, Events.DURATION);
-        sEventEntitiesProjectionMap.put(Events.ALL_DAY, Events.ALL_DAY);
-        sEventEntitiesProjectionMap.put(Events.ACCESS_LEVEL, Events.ACCESS_LEVEL);
-        sEventEntitiesProjectionMap.put(Events.AVAILABILITY, Events.AVAILABILITY);
-        sEventEntitiesProjectionMap.put(Events.HAS_ALARM, Events.HAS_ALARM);
-        sEventEntitiesProjectionMap.put(Events.HAS_EXTENDED_PROPERTIES,
-                Events.HAS_EXTENDED_PROPERTIES);
-        sEventEntitiesProjectionMap.put(Events.RRULE, Events.RRULE);
-        sEventEntitiesProjectionMap.put(Events.RDATE, Events.RDATE);
-        sEventEntitiesProjectionMap.put(Events.EXRULE, Events.EXRULE);
-        sEventEntitiesProjectionMap.put(Events.EXDATE, Events.EXDATE);
-        sEventEntitiesProjectionMap.put(Events.ORIGINAL_SYNC_ID, Events.ORIGINAL_SYNC_ID);
-        sEventEntitiesProjectionMap.put(Events.ORIGINAL_ID, Events.ORIGINAL_ID);
-        sEventEntitiesProjectionMap.put(Events.ORIGINAL_INSTANCE_TIME,
-                Events.ORIGINAL_INSTANCE_TIME);
-        sEventEntitiesProjectionMap.put(Events.ORIGINAL_ALL_DAY, Events.ORIGINAL_ALL_DAY);
-        sEventEntitiesProjectionMap.put(Events.LAST_DATE, Events.LAST_DATE);
-        sEventEntitiesProjectionMap.put(Events.HAS_ATTENDEE_DATA, Events.HAS_ATTENDEE_DATA);
-        sEventEntitiesProjectionMap.put(Events.CALENDAR_ID, Events.CALENDAR_ID);
-        sEventEntitiesProjectionMap.put(Events.GUESTS_CAN_INVITE_OTHERS,
-                Events.GUESTS_CAN_INVITE_OTHERS);
-        sEventEntitiesProjectionMap.put(Events.GUESTS_CAN_MODIFY, Events.GUESTS_CAN_MODIFY);
-        sEventEntitiesProjectionMap.put(Events.GUESTS_CAN_SEE_GUESTS, Events.GUESTS_CAN_SEE_GUESTS);
-        sEventEntitiesProjectionMap.put(Events.ORGANIZER, Events.ORGANIZER);
-        sEventEntitiesProjectionMap.put(Events.IS_ORGANIZER, Events.IS_ORGANIZER);
-        sEventEntitiesProjectionMap.put(Events.CUSTOM_APP_PACKAGE, Events.CUSTOM_APP_PACKAGE);
-        sEventEntitiesProjectionMap.put(Events.CUSTOM_APP_URI, Events.CUSTOM_APP_URI);
-        sEventEntitiesProjectionMap.put(Events.UID_2445, Events.UID_2445);
-        sEventEntitiesProjectionMap.put(Events.DELETED, Events.DELETED);
-        sEventEntitiesProjectionMap.put(Events._ID, Events._ID);
-        sEventEntitiesProjectionMap.put(Events._SYNC_ID, Events._SYNC_ID);
-        sEventEntitiesProjectionMap.put(Events.SYNC_DATA1, Events.SYNC_DATA1);
-        sEventEntitiesProjectionMap.put(Events.SYNC_DATA2, Events.SYNC_DATA2);
-        sEventEntitiesProjectionMap.put(Events.SYNC_DATA3, Events.SYNC_DATA3);
-        sEventEntitiesProjectionMap.put(Events.SYNC_DATA4, Events.SYNC_DATA4);
-        sEventEntitiesProjectionMap.put(Events.SYNC_DATA5, Events.SYNC_DATA5);
-        sEventEntitiesProjectionMap.put(Events.SYNC_DATA6, Events.SYNC_DATA6);
-        sEventEntitiesProjectionMap.put(Events.SYNC_DATA7, Events.SYNC_DATA7);
-        sEventEntitiesProjectionMap.put(Events.SYNC_DATA8, Events.SYNC_DATA8);
-        sEventEntitiesProjectionMap.put(Events.SYNC_DATA9, Events.SYNC_DATA9);
-        sEventEntitiesProjectionMap.put(Events.SYNC_DATA10, Events.SYNC_DATA10);
-        sEventEntitiesProjectionMap.put(Events.DIRTY, Events.DIRTY);
-        sEventEntitiesProjectionMap.put(Events.MUTATORS, Events.MUTATORS);
-        sEventEntitiesProjectionMap.put(Events.LAST_SYNCED, Events.LAST_SYNCED);
-        sEventEntitiesProjectionMap.put(Calendars.CAL_SYNC1, Calendars.CAL_SYNC1);
-        sEventEntitiesProjectionMap.put(Calendars.CAL_SYNC2, Calendars.CAL_SYNC2);
-        sEventEntitiesProjectionMap.put(Calendars.CAL_SYNC3, Calendars.CAL_SYNC3);
-        sEventEntitiesProjectionMap.put(Calendars.CAL_SYNC4, Calendars.CAL_SYNC4);
-        sEventEntitiesProjectionMap.put(Calendars.CAL_SYNC5, Calendars.CAL_SYNC5);
-        sEventEntitiesProjectionMap.put(Calendars.CAL_SYNC6, Calendars.CAL_SYNC6);
-        sEventEntitiesProjectionMap.put(Calendars.CAL_SYNC7, Calendars.CAL_SYNC7);
-        sEventEntitiesProjectionMap.put(Calendars.CAL_SYNC8, Calendars.CAL_SYNC8);
-        sEventEntitiesProjectionMap.put(Calendars.CAL_SYNC9, Calendars.CAL_SYNC9);
-        sEventEntitiesProjectionMap.put(Calendars.CAL_SYNC10, Calendars.CAL_SYNC10);
-
-        // Instances columns
-        sInstancesProjectionMap.put(Events.DELETED, "Events.deleted as deleted");
-        sInstancesProjectionMap.put(Instances.BEGIN, "begin");
-        sInstancesProjectionMap.put(Instances.END, "end");
-        sInstancesProjectionMap.put(Instances.EVENT_ID, "Instances.event_id AS event_id");
-        sInstancesProjectionMap.put(Instances._ID, "Instances._id AS _id");
-        sInstancesProjectionMap.put(Instances.START_DAY, "startDay");
-        sInstancesProjectionMap.put(Instances.END_DAY, "endDay");
-        sInstancesProjectionMap.put(Instances.START_MINUTE, "startMinute");
-        sInstancesProjectionMap.put(Instances.END_MINUTE, "endMinute");
-
-        // Attendees columns
-        sAttendeesProjectionMap.put(Attendees.EVENT_ID, "event_id");
-        sAttendeesProjectionMap.put(Attendees._ID, "Attendees._id AS _id");
-        sAttendeesProjectionMap.put(Attendees.ATTENDEE_NAME, "attendeeName");
-        sAttendeesProjectionMap.put(Attendees.ATTENDEE_EMAIL, "attendeeEmail");
-        sAttendeesProjectionMap.put(Attendees.ATTENDEE_STATUS, "attendeeStatus");
-        sAttendeesProjectionMap.put(Attendees.ATTENDEE_RELATIONSHIP, "attendeeRelationship");
-        sAttendeesProjectionMap.put(Attendees.ATTENDEE_TYPE, "attendeeType");
-        sAttendeesProjectionMap.put(Attendees.ATTENDEE_IDENTITY, "attendeeIdentity");
-        sAttendeesProjectionMap.put(Attendees.ATTENDEE_ID_NAMESPACE, "attendeeIdNamespace");
-        sAttendeesProjectionMap.put(Events.DELETED, "Events.deleted AS deleted");
-        sAttendeesProjectionMap.put(Events._SYNC_ID, "Events._sync_id AS _sync_id");
-
-        // Reminders columns
-        sRemindersProjectionMap.put(Reminders.EVENT_ID, "event_id");
-        sRemindersProjectionMap.put(Reminders._ID, "Reminders._id AS _id");
-        sRemindersProjectionMap.put(Reminders.MINUTES, "minutes");
-        sRemindersProjectionMap.put(Reminders.METHOD, "method");
-        sRemindersProjectionMap.put(Events.DELETED, "Events.deleted AS deleted");
-        sRemindersProjectionMap.put(Events._SYNC_ID, "Events._sync_id AS _sync_id");
-
-        // CalendarAlerts columns
-        sCalendarAlertsProjectionMap.put(CalendarAlerts.EVENT_ID, "event_id");
-        sCalendarAlertsProjectionMap.put(CalendarAlerts._ID, "CalendarAlerts._id AS _id");
-        sCalendarAlertsProjectionMap.put(CalendarAlerts.BEGIN, "begin");
-        sCalendarAlertsProjectionMap.put(CalendarAlerts.END, "end");
-        sCalendarAlertsProjectionMap.put(CalendarAlerts.ALARM_TIME, "alarmTime");
-        sCalendarAlertsProjectionMap.put(CalendarAlerts.NOTIFY_TIME, "notifyTime");
-        sCalendarAlertsProjectionMap.put(CalendarAlerts.STATE, "state");
-        sCalendarAlertsProjectionMap.put(CalendarAlerts.MINUTES, "minutes");
-
-        // CalendarCache columns
-        sCalendarCacheProjectionMap = new HashMap<String, String>();
-        sCalendarCacheProjectionMap.put(CalendarCache.COLUMN_NAME_KEY, "key");
-        sCalendarCacheProjectionMap.put(CalendarCache.COLUMN_NAME_VALUE, "value");
-
-        /* SPRD: Modify 20150916 of bug 474826, vcalendar issue @{ */
-        sVCalendarProjectionMap = new HashMap<String, String>(
-                sEventsProjectionMap);
-        sVCalendarProjectionMap.put(Events._ID, "Events._id AS _id");
-        sVCalendarProjectionMap.put(Events._SYNC_ID,
-                "Events._sync_id AS _sync_id");
-        sVCalendarProjectionMap.put(OpenableColumns.DISPLAY_NAME, Events.TITLE
-                + " || '.vcs' AS " + OpenableColumns.DISPLAY_NAME);
-        sVCalendarProjectionMap.put(OpenableColumns.SIZE, "NULL AS "
-                + OpenableColumns.SIZE);
-        /* @} */
-    }
-
-
-    /**
-     * This is called by AccountManager when the set of accounts is updated.
-     * <p>
-     * We are overriding this since we need to delete from the
-     * Calendars table, which is not syncable, which has triggers that
-     * will delete from the Events and  tables, which are
-     * syncable.  TODO: update comment, make sure deletes don't get synced.
-     *
-     * @param accounts The list of currently active accounts.
-     */
-    @Override
-    public void onAccountsUpdated(Account[] accounts) {
-        Thread thread = new AccountsUpdatedThread(accounts);
-        thread.start();
-    }
-
-    private class AccountsUpdatedThread extends Thread {
-        private Account[] mAccounts;
-
-        AccountsUpdatedThread(Account[] accounts) {
-            mAccounts = accounts;
-        }
-
-        @Override
-        public void run() {
-            // The process could be killed while the thread runs.  Right now that isn't a problem,
-            // because we'll just call removeStaleAccounts() again when the provider restarts, but
-            // if we want to do additional actions we may need to use a service (e.g. start
-            // EmptyService in onAccountsUpdated() and stop it when we finish here).
-
-            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
-            removeStaleAccounts(mAccounts);
-        }
-    }
-
-    /**
-     * Makes sure there are no entries for accounts that no longer exist.
-     */
-    private void removeStaleAccounts(Account[] accounts) {
-        mDb = mDbHelper.getWritableDatabase();
-        if (mDb == null) {
-            return;
-        }
-
-        HashSet<Account> validAccounts = new HashSet<Account>();
-        /* SPRD: Add 20150914 of bug 474232, add local account @{ */
-        validAccounts.add(getLocalAccount());
-        /* @} */
-        for (Account account : accounts) {
-            validAccounts.add(new Account(account.name, account.type));
-        }
-        ArrayList<Account> accountsToDelete = new ArrayList<Account>();
-
-        mDb.beginTransaction();
-        Cursor c = null;
-        try {
-
-            for (String table : new String[]{Tables.CALENDARS, Tables.COLORS}) {
-                // Find all the accounts the calendar DB knows about, mark the ones that aren't
-                // in the valid set for deletion.
-                c = mDb.rawQuery("SELECT DISTINCT " +
-                                            Calendars.ACCOUNT_NAME +
-                                            "," +
-                                            Calendars.ACCOUNT_TYPE +
-                                        " FROM " + table, null);
-                while (c.moveToNext()) {
-                    // ACCOUNT_TYPE_LOCAL is to store calendars not associated
-                    // with a system account. Typically, a calendar must be
-                    // associated with an account on the device or it will be
-                    // deleted.
-                    if (c.getString(0) != null
-                            && c.getString(1) != null
-                            && !TextUtils.equals(c.getString(1),
-                                    CalendarContract.ACCOUNT_TYPE_LOCAL)) {
-                        Account currAccount = new Account(c.getString(0), c.getString(1));
-                        if (!validAccounts.contains(currAccount)) {
-                            accountsToDelete.add(currAccount);
-                        }
-                    }
-                }
-                c.close();
-                c = null;
-            }
-
-            for (Account account : accountsToDelete) {
-                if (Log.isLoggable(TAG, Log.DEBUG)) {
-                    Log.d(TAG, "removing data for removed account " + account);
-                }
-                String[] params = new String[]{account.name, account.type};
-                mDb.execSQL(SQL_DELETE_FROM_CALENDARS, params);
-                // This will be a no-op for accounts without a color palette.
-                mDb.execSQL(SQL_DELETE_FROM_COLORS, params);
-            }
-            mDbHelper.getSyncState().onAccountsChanged(mDb, accounts);
-            mDb.setTransactionSuccessful();
-        } finally {
-            if (c != null) {
-                c.close();
-            }
-            mDb.endTransaction();
-        }
-
-        // make sure the widget reflects the account changes
-        sendUpdateNotification(false);
-    }
-
-    /**
-     * Inserts an argument at the beginning of the selection arg list.
-     *
-     * The {@link android.database.sqlite.SQLiteQueryBuilder}'s where clause is
-     * prepended to the user's where clause (combined with 'AND') to generate
-     * the final where close, so arguments associated with the QueryBuilder are
-     * prepended before any user selection args to keep them in the right order.
-     */
-    private String[] insertSelectionArg(String[] selectionArgs, String arg) {
-        if (selectionArgs == null) {
-            return new String[] {arg};
-        } else {
-            int newLength = selectionArgs.length + 1;
-            String[] newSelectionArgs = new String[newLength];
-            newSelectionArgs[0] = arg;
-            System.arraycopy(selectionArgs, 0, newSelectionArgs, 1, selectionArgs.length);
-            return newSelectionArgs;
-        }
-    }
-
-    private String getCallingPackageName() {
-        if (getCachedCallingPackage() != null) {
-            // If the calling package is null, use the best available as a fallback.
-            return getCachedCallingPackage();
-        }
-        if (!Boolean.TRUE.equals(mCallingPackageErrorLogged.get())) {
-            Log.e(TAG, "Failed to get the cached calling package.", new Throwable());
-            mCallingPackageErrorLogged.set(Boolean.TRUE);
-        }
-        final PackageManager pm = getContext().getPackageManager();
-        final int uid = Binder.getCallingUid();
-        final String[] packages = pm.getPackagesForUid(uid);
-        if (packages != null && packages.length == 1) {
-            return packages[0];
-        }
-        final String name = pm.getNameForUid(uid);
-        if (name != null) {
-            return name;
-        }
-        return String.valueOf(uid);
-    }
-
-    private void addMutator(ContentValues values, String columnName) {
-        final String packageName = getCallingPackageName();
-        final String mutators = values.getAsString(columnName);
-        if (TextUtils.isEmpty(mutators)) {
-            values.put(columnName, packageName);
-        } else {
-            values.put(columnName, mutators + "," + packageName);
-        }
-    }
-
-    /* SPRD: Add 20150914 of bug 474232, add local account @{ */
-    private Account getLocalAccount() {
-        return new Account("Local Calendar", "Local Calendar");
-    }
-    /* @} */
-
-    /* SPRD: Modify 20150916 of bug 474826, vcalendar issue @{ */
-    /**
-     * FR133636-TS Get vcalendar file name
-     *
-     * @param eventId
-     * @return
-     */
-    private String vCalTitleString(String eventId) {
-        String sql = "select title from events where _id = " + eventId + ";";
-        String name = "";
-        Cursor cursor = null;
-        try {
-            cursor = mDb.rawQuery(sql, null);
-
-            cursor.moveToFirst();
-            name = cursor.getString(cursor.getColumnIndex(Events.TITLE));
-
-            if (name == null || name.length() == 0) {
-                name = getContext().getResources().getString(
-                        R.string.no_title_label);
-            } else if (name.length() > 8) {
-                name = name.substring(0, 6) + "~1";
-            }
-
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-        return name;
-    }
-
-    @Override
-    public AssetFileDescriptor openAssetFile(Uri uri, String mode)
-            throws FileNotFoundException {
-        Log.d("lihl", "uri:" + uri);
-        int match = sUriMatcher.match(uri);
-        Log.d("lihl", "match:" + match);
-        switch (match) {
-        case CALENDAR_AS_VCAL:
-        case CALENDAR_AS_MULTI_VCAL:
-            final String event_id = uri.getPathSegments().get(2);
-            String bodyStr = VCalendarExportSource.exportSource(mDb,
-                    Integer.parseInt(event_id));
-            return buildAssetFileDescriptor(bodyStr);
-
-        default:
-            throw new FileNotFoundException("No file at: " + uri);
-        }
-    }
-
-    /**
-     * Returns an {@link AssetFileDescriptor} backed by the contents of the
-     * given {@link bodyStr}.
-     */
-    private AssetFileDescriptor buildAssetFileDescriptor(String bodyStr) {
-        try {
-            // stream.flush();
-            // final byte[] byteData = stream.toByteArray();
-            final byte[] byteData = bodyStr.getBytes();
-            return makeAssetFileDescriptor(
-                    ParcelFileDescriptor.fromData(byteData, CALENDAR_MEMORY_FILE_NAME),
-                    byteData.length);
-        } catch (IOException e) {
-            Log.w(TAG, "Problem writing stream into an ParcelFileDescriptor: " + e.toString());
-            return null;
-        }
-    }
-
-    private AssetFileDescriptor makeAssetFileDescriptor(ParcelFileDescriptor fd) {
-        return makeAssetFileDescriptor(fd, AssetFileDescriptor.UNKNOWN_LENGTH);
-    }
-
-    private AssetFileDescriptor makeAssetFileDescriptor(
-            ParcelFileDescriptor fd, long length) {
-        return fd != null ? new AssetFileDescriptor(fd, 0, length) : null;
-    }
-    /* @} */
-    /* Sprd: Added for bug473564, add backup info @{ */
-    private int uniqueEvents(SQLiteDatabase db) {
-        Cursor cursor = db
-                .rawQuery(
-                        "select _id from events where _id not in (select _id from (" +
-                        "select _id,title,description,eventLocation,dtstart,dtend,allDay,availability,accessLevel " +
-                        "from events group by title,description,eventLocation,dtstart,dtend,allDay,availability,accessLevel));"
-                        , null);
-
-        int ret = 0;
-        try {
-            if (cursor != null && cursor.moveToFirst()) {
-                do {
-                    ret++;
-                    long eventId = cursor.getLong(0);
-                    Log.i(TAG, "delete events _id = " + eventId);
-                    mContext.getContentResolver().delete(Events.CONTENT_URI, Events._ID+"="+eventId, null);
-                } while (cursor.moveToNext());
-            }
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-                cursor = null;
-            }
-        }
-        return ret;
-    }
-    /* @} */
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarUpgradeReceiver.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarUpgradeReceiver.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarUpgradeReceiver.java	(revision 168087)
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License
- */
-
-package com.android.providers.calendar;
-
-import android.app.ActivityManagerNative;
-import android.content.BroadcastReceiver;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.pm.PackageManager;
-import android.os.RemoteException;
-import android.util.EventLog;
-import android.util.Log;
-
-/**
- * This will be launched during system boot, after the core system has
- * been brought up but before any non-persistent processes have been
- * started.  It is launched in a special state, with no content provider
- * or custom application class associated with the process running.
- *
- * It's job is to prime the calendar database. Either create it
- * if it doesn't exist, or open it and force any necessary upgrades.
- * All of this heavy lifting happens before the boot animation ends.
- */
-public class CalendarUpgradeReceiver extends BroadcastReceiver {
-    static final String TAG = "CalendarUpgradeReceiver";
-    static final String PREF_DB_VERSION = "db_version";
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        // We are now running with the system up, but no apps started,
-        // so can do whatever cleanup after an upgrade that we want.
-
-        try {
-            long startTime = System.currentTimeMillis();
-
-            // Lookup the last known database version
-            SharedPreferences prefs = context.getSharedPreferences(TAG, Context.MODE_PRIVATE);
-            int prefVersion = prefs.getInt(PREF_DB_VERSION, 0);
-
-            // If the version is old go ahead and attempt to create or upgrade the database.
-            if (prefVersion != CalendarDatabaseHelper.DATABASE_VERSION) {
-                // Store the current version so this receiver isn't run again until the database
-                // version number changes. This is intentionally done even before the upgrade path
-                // is attempted to be conservative. If the upgrade fails for some reason and we
-                // crash and burn we don't want to get into a loop doing so.
-                prefs.edit().putInt(PREF_DB_VERSION, CalendarDatabaseHelper.DATABASE_VERSION).commit();
-
-                // Ask for a reference to the database to force the helper to either
-                // create the database or open it up, performing any necessary upgrades
-                // in the process.
-                CalendarDatabaseHelper helper = CalendarDatabaseHelper.getInstance(context);
-                if (context.getDatabasePath(helper.getDatabaseName()).exists()) {
-                    Log.i(TAG, "Creating or opening calendar database");
-                    helper.getWritableDatabase();
-                }
-                //SPRD BUG 604492
-//                helper.close();
-
-                // Log the total time taken for the receiver to perform the operation
-                EventLogTags.writeCalendarUpgradeReceiver(System.currentTimeMillis() - startTime);
-            }
-        } catch (Throwable t) {
-            // Something has gone terribly wrong. Disable this receiver for good so we can't
-            // possibly end up in a reboot loop.
-            Log.wtf(TAG, "Error during upgrade attempt. Disabling receiver.", t);
-            context.getPackageManager().setComponentEnabledSetting(
-                    new ComponentName(context, getClass()),
-                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
-                    PackageManager.DONT_KILL_APP);
-        }
-    }
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/SQLiteContentProvider.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/SQLiteContentProvider.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/SQLiteContentProvider.java	(revision 168087)
@@ -1,332 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License
- */
-
-package com.android.providers.calendar;
-
-import android.content.ContentProvider;
-import android.content.ContentProviderOperation;
-import android.content.ContentProviderResult;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.OperationApplicationException;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.database.sqlite.SQLiteTransactionListener;
-import android.net.Uri;
-import android.os.Binder;
-import android.os.Process;
-import android.provider.CalendarContract;
-import android.util.Log;
-
-import java.util.ArrayList;
-
-/**
- * General purpose {@link ContentProvider} base class that uses SQLiteDatabase for storage.
- */
-public abstract class SQLiteContentProvider extends ContentProvider
-        implements SQLiteTransactionListener {
-
-    private static final String TAG = "SQLiteContentProvider";
-
-    private SQLiteOpenHelper mOpenHelper;
-    private volatile boolean mNotifyChange;
-    protected SQLiteDatabase mDb;
-
-    private final ThreadLocal<Boolean> mApplyingBatch = new ThreadLocal<Boolean>();
-    private static final int SLEEP_AFTER_YIELD_DELAY = 4000;
-
-    private Boolean mIsCallerSyncAdapter;
-
-    @Override
-    public boolean onCreate() {
-        Context context = getContext();
-        mOpenHelper = getDatabaseHelper(context);
-        return true;
-    }
-
-    protected abstract SQLiteOpenHelper getDatabaseHelper(Context context);
-
-    /**
-     * The equivalent of the {@link #insert} method, but invoked within a transaction.
-     */
-    protected abstract Uri insertInTransaction(Uri uri, ContentValues values,
-            boolean callerIsSyncAdapter);
-
-    /**
-     * The equivalent of the {@link #update} method, but invoked within a transaction.
-     */
-    protected abstract int updateInTransaction(Uri uri, ContentValues values, String selection,
-            String[] selectionArgs, boolean callerIsSyncAdapter);
-
-    /**
-     * The equivalent of the {@link #delete} method, but invoked within a transaction.
-     */
-    protected abstract int deleteInTransaction(Uri uri, String selection, String[] selectionArgs,
-            boolean callerIsSyncAdapter);
-
-    protected abstract void notifyChange(boolean syncToNetwork);
-
-    protected SQLiteOpenHelper getDatabaseHelper() {
-        return mOpenHelper;
-    }
-
-    private boolean applyingBatch() {
-        return mApplyingBatch.get() != null && mApplyingBatch.get();
-    }
-
-    @Override
-    public Uri insert(Uri uri, ContentValues values) {
-        Uri result = null;
-        boolean applyingBatch = applyingBatch();
-        boolean isCallerSyncAdapter = getIsCallerSyncAdapter(uri);
-        if (!applyingBatch) {
-            mDb = mOpenHelper.getWritableDatabase();
-            mDb.beginTransactionWithListener(this);
-            final long identity = clearCallingIdentityInternal();
-            try {
-                result = insertInTransaction(uri, values, isCallerSyncAdapter);
-                if (result != null) {
-                    mNotifyChange = true;
-                }
-                mDb.setTransactionSuccessful();
-            } finally {
-                restoreCallingIdentityInternal(identity);
-                mDb.endTransaction();
-            }
-
-            onEndTransaction(!isCallerSyncAdapter && shouldSyncFor(uri));
-        } else {
-            result = insertInTransaction(uri, values, isCallerSyncAdapter);
-            if (result != null) {
-                mNotifyChange = true;
-            }
-        }
-        return result;
-    }
-
-    @Override
-    public int bulkInsert(Uri uri, ContentValues[] values) {
-        int numValues = values.length;
-        boolean isCallerSyncAdapter = getIsCallerSyncAdapter(uri);
-        mDb = mOpenHelper.getWritableDatabase();
-        mDb.beginTransactionWithListener(this);
-        final long identity = clearCallingIdentityInternal();
-        try {
-            for (int i = 0; i < numValues; i++) {
-                Uri result = insertInTransaction(uri, values[i], isCallerSyncAdapter);
-                if (result != null) {
-                    mNotifyChange = true;
-                }
-                mDb.yieldIfContendedSafely();
-            }
-            mDb.setTransactionSuccessful();
-        } finally {
-            restoreCallingIdentityInternal(identity);
-            mDb.endTransaction();
-        }
-
-        onEndTransaction(!isCallerSyncAdapter);
-        return numValues;
-    }
-
-    @Override
-    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
-        int count = 0;
-        boolean applyingBatch = applyingBatch();
-        boolean isCallerSyncAdapter = getIsCallerSyncAdapter(uri);
-        if (!applyingBatch) {
-            mDb = mOpenHelper.getWritableDatabase();
-            mDb.beginTransactionWithListener(this);
-            final long identity = clearCallingIdentityInternal();
-            try {
-                count = updateInTransaction(uri, values, selection, selectionArgs,
-                            isCallerSyncAdapter);
-                if (count > 0) {
-                    mNotifyChange = true;
-                }
-                mDb.setTransactionSuccessful();
-            } finally {
-                restoreCallingIdentityInternal(identity);
-                mDb.endTransaction();
-            }
-
-            onEndTransaction(!isCallerSyncAdapter && shouldSyncFor(uri));
-        } else {
-            count = updateInTransaction(uri, values, selection, selectionArgs,
-                        isCallerSyncAdapter);
-            if (count > 0) {
-                mNotifyChange = true;
-            }
-        }
-
-        return count;
-    }
-
-    @Override
-    public int delete(Uri uri, String selection, String[] selectionArgs) {
-        int count = 0;
-        boolean applyingBatch = applyingBatch();
-        boolean isCallerSyncAdapter = getIsCallerSyncAdapter(uri);
-        if (!applyingBatch) {
-            mDb = mOpenHelper.getWritableDatabase();
-            mDb.beginTransactionWithListener(this);
-            final long identity = clearCallingIdentityInternal();
-            try {
-                count = deleteInTransaction(uri, selection, selectionArgs, isCallerSyncAdapter);
-                if (count > 0) {
-                    mNotifyChange = true;
-                }
-                mDb.setTransactionSuccessful();
-            } finally {
-                restoreCallingIdentityInternal(identity);
-                mDb.endTransaction();
-            }
-
-            onEndTransaction(!isCallerSyncAdapter && shouldSyncFor(uri));
-        } else {
-            count = deleteInTransaction(uri, selection, selectionArgs, isCallerSyncAdapter);
-            if (count > 0) {
-                mNotifyChange = true;
-            }
-        }
-        return count;
-    }
-
-    protected boolean getIsCallerSyncAdapter(Uri uri) {
-        boolean isCurrentSyncAdapter = QueryParameterUtils.readBooleanQueryParameter(uri,
-                CalendarContract.CALLER_IS_SYNCADAPTER, false);
-        if (mIsCallerSyncAdapter == null || mIsCallerSyncAdapter) {
-            mIsCallerSyncAdapter = isCurrentSyncAdapter;
-        }
-        return isCurrentSyncAdapter;
-    }
-
-    @Override
-    public ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation> operations)
-            throws OperationApplicationException {
-        final int numOperations = operations.size();
-        if (numOperations == 0) {
-            return new ContentProviderResult[0];
-        }
-        mDb = mOpenHelper.getWritableDatabase();
-        mDb.beginTransactionWithListener(this);
-        final boolean isCallerSyncAdapter = getIsCallerSyncAdapter(operations.get(0).getUri());
-        final long identity = clearCallingIdentityInternal();
-        try {
-            mApplyingBatch.set(true);
-            final ContentProviderResult[] results = new ContentProviderResult[numOperations];
-            for (int i = 0; i < numOperations; i++) {
-                final ContentProviderOperation operation = operations.get(i);
-                if (i > 0 && operation.isYieldAllowed()) {
-                    mDb.yieldIfContendedSafely(SLEEP_AFTER_YIELD_DELAY);
-                }
-                results[i] = operation.apply(this, results, i);
-            }
-            mDb.setTransactionSuccessful();
-            return results;
-        } finally {
-            mApplyingBatch.set(false);
-            mDb.endTransaction();
-            onEndTransaction(!isCallerSyncAdapter);
-            restoreCallingIdentityInternal(identity);
-        }
-    }
-
-    public void onBegin() {
-        mIsCallerSyncAdapter = null;
-        onBeginTransaction();
-    }
-
-    public void onCommit() {
-        beforeTransactionCommit();
-    }
-
-    public void onRollback() {
-        // not used
-    }
-
-    protected void onBeginTransaction() {
-    }
-
-    protected void beforeTransactionCommit() {
-    }
-
-    protected void onEndTransaction(boolean syncToNetwork) {
-        if (mNotifyChange) {
-            mNotifyChange = false;
-            // We sync to network if the caller was not the sync adapter
-            notifyChange(syncToNetwork);
-        }
-    }
-
-    /**
-     * Some URI's are maintained locally so we should not request a sync for them
-     */
-    protected abstract boolean shouldSyncFor(Uri uri);
-
-    /** The package to most recently query(), not including further internally recursive calls. */
-    private final ThreadLocal<String> mCallingPackage = new ThreadLocal<String>();
-
-    /**
-     * The calling Uid when a calling package is cached, so we know when the stack of any
-     * recursive calls to clearCallingIdentity and restoreCallingIdentity is complete.
-     */
-    private final ThreadLocal<Integer> mOriginalCallingUid = new ThreadLocal<Integer>();
-
-
-    protected String getCachedCallingPackage() {
-        return mCallingPackage.get();
-    }
-
-    /**
-     * Call {@link android.os.Binder#clearCallingIdentity()}, while caching the calling package
-     * name, so that it can be saved if this is part of an event mutation.
-     */
-    protected long clearCallingIdentityInternal() {
-        // Only set the calling package if the calling UID is not our own.
-        int uid = Process.myUid();
-        int callingUid = Binder.getCallingUid();
-        if (uid != callingUid) {
-            try {
-                mOriginalCallingUid.set(callingUid);
-                String callingPackage = getCallingPackage();
-                mCallingPackage.set(callingPackage);
-            } catch (SecurityException e) {
-                Log.e(TAG, "Error getting the calling package.", e);
-            }
-        }
-
-        return Binder.clearCallingIdentity();
-    }
-
-    /**
-     * Call {@link Binder#restoreCallingIdentity(long)}.
-     * </p>
-     * If this is the last restore on the stack of calls to
-     * {@link android.os.Binder#clearCallingIdentity()}, then the cached calling package will also
-     * be cleared.
-     * @param identity
-     */
-    protected void restoreCallingIdentityInternal(long identity) {
-        Binder.restoreCallingIdentity(identity);
-
-        int callingUid = Binder.getCallingUid();
-        if (mOriginalCallingUid.get() != null && mOriginalCallingUid.get() == callingUid) {
-            mCallingPackage.set(null);
-            mOriginalCallingUid.set(null);
-        }
-    }
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/EmptyService.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/EmptyService.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/EmptyService.java	(revision 168087)
@@ -1,32 +0,0 @@
-package com.android.providers.calendar;
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import android.app.Service;
-import android.content.Intent;
-import android.os.IBinder;
-
-/**
- * Background {@link Service} that is used to keep our process alive long enough
- * for background threads to finish. Started and stopped directly by specific
- * background tasks when needed.
- */
-public class EmptyService extends Service {
-    @Override
-    public IBinder onBind(Intent intent) {
-        return null;
-    }
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarDebug.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarDebug.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarDebug.java	(revision 168087)
@@ -1,192 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.calendar;
-
-import android.app.ListActivity;
-import android.content.ContentResolver;
-import android.database.Cursor;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.os.Handler;
-import android.provider.CalendarContract;
-import android.widget.ListAdapter;
-import android.widget.SimpleAdapter;
-import android.view.Window;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Displays info about all the user's calendars, for debugging.
- *
- * The info is displayed as a ListActivity, where each entry has the calendar name
- * followed by information about the calendar.
- */
-public class CalendarDebug extends ListActivity {
-    private static final String[] CALENDARS_PROJECTION = new String[]{
-            CalendarContract.Calendars._ID,
-            CalendarContract.Calendars.CALENDAR_DISPLAY_NAME,
-    };
-    private static final int INDEX_ID = 0;
-    private static final int INDEX_DISPLAY_NAME = 1;
-
-    private static final String[] EVENTS_PROJECTION = new String[]{
-            CalendarContract.Events._ID,
-    };
-    private static final String KEY_TITLE = "title";
-    private static final String KEY_TEXT = "text";
-
-    private ContentResolver mContentResolver;
-    private ListActivity mActivity;
-
-    /**
-     *  Task to fetch info from the database and display as a ListActivity.
-     */
-    private class FetchInfoTask extends AsyncTask<Void, Void, List<Map<String, String>>> {
-        /**
-         * Starts spinner while task is running.
-         *
-         * @see #onPostExecute
-         * @see #doInBackground
-         */
-        @Override
-        protected void onPreExecute() {
-              setProgressBarIndeterminateVisibility(true);
-        }
-
-        /**
-         * Fetches debugging info from the database
-         * @param params Void
-         * @return a Map for each calendar
-         */
-        @Override
-        protected List<Map<String, String>> doInBackground(Void... params) {
-            Cursor cursor = null;
-            // items is the list of items to display in the list.
-            List<Map<String, String>> items = new ArrayList<Map<String, String>>();
-            try {
-                cursor = mContentResolver.query(CalendarContract.Calendars.CONTENT_URI,
-                        CALENDARS_PROJECTION,
-                        null, null /* selectionArgs */,
-                        CalendarContract.Calendars.DEFAULT_SORT_ORDER);
-                if (cursor == null) {
-                    addItem(items, mActivity.getString(R.string.calendar_info_error), "");
-                } else {
-                    while (cursor.moveToNext()) {
-                        // Process each calendar
-                        int id = cursor.getInt(INDEX_ID);
-                        int eventCount = -1;
-                        int dirtyCount = -1;
-                        String displayName = cursor.getString(INDEX_DISPLAY_NAME);
-
-                        // Compute number of events in the calendar
-                        String where = CalendarContract.Events.CALENDAR_ID + "=" + id;
-                        Cursor eventCursor = mContentResolver.query(
-                                CalendarContract.Events.CONTENT_URI, EVENTS_PROJECTION, where,
-                                null, null);
-                        try {
-                            eventCount = eventCursor.getCount();
-                        } finally {
-                            eventCursor.close();
-                        }
-
-                        // Compute number of dirty events in the calendar
-                        String dirtyWhere = CalendarContract.Events.CALENDAR_ID + "=" + id
-                                + " AND " + CalendarContract.Events.DIRTY + "=1";
-                        Cursor dirtyCursor = mContentResolver.query(
-                                CalendarContract.Events.CONTENT_URI, EVENTS_PROJECTION, dirtyWhere,
-                                null, null);
-                        try {
-                            dirtyCount = dirtyCursor.getCount();
-                        } finally {
-                            dirtyCursor.close();
-                        }
-
-                        // Format the output
-                        String text;
-                        if (dirtyCount == 0) {
-                            text = mActivity.getString(R.string.calendar_info_events,
-                                    eventCount);
-                        } else {
-                            text = mActivity.getString(R.string.calendar_info_events_dirty,
-                                    eventCount, dirtyCount);
-                        }
-
-                        addItem(items, displayName, text);
-                    }
-                }
-            } catch (Exception e) {
-                // Want to catch all exceptions.  The point of this code is to debug
-                // when something bad is happening.
-                addItem(items, mActivity.getString(R.string.calendar_info_error), e.toString());
-            } finally {
-                if (cursor != null) {
-                    cursor.close();
-                }
-            }
-
-            if (items.size() == 0) {
-                addItem(items, mActivity.getString(R.string.calendar_info_no_calendars), "");
-            }
-            return items;
-        }
-
-        /**
-         * Runs on the UI thread to display the debugging info.
-         *
-         * @param items The info items to display.
-         * @see #onPreExecute
-         * @see #doInBackground
-         */
-        @Override
-        protected void onPostExecute(List<Map<String, String>> items) {
-            setProgressBarIndeterminateVisibility(false);
-            ListAdapter adapter = new SimpleAdapter(mActivity, items,
-                    android.R.layout.simple_list_item_2, new String[]{KEY_TITLE, KEY_TEXT},
-                    new int[]{android.R.id.text1, android.R.id.text2});
-
-            // Bind to our new adapter.
-            setListAdapter(adapter);
-        }
-    }
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
-        mActivity = this;
-        mContentResolver = getContentResolver();
-        getListView(); // Instantiate, for spinner
-        new FetchInfoTask().execute();
-
-    }
-
-    /**
-     * Adds an item to the item map
-     * @param items The item map to update
-     * @param title Title of the item
-     * @param text Text of the item
-     */
-    protected void addItem(List<Map<String, String>> items, String title, String text) {
-        Map<String, String> itemMap = new HashMap<String, String>();
-        itemMap.put(KEY_TITLE, title);
-        itemMap.put(KEY_TEXT, text);
-        items.add(itemMap);
-    }
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/MetaData.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/MetaData.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/MetaData.java	(revision 168087)
@@ -1,251 +0,0 @@
-/*
-**
-** Copyright 2008, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** See the License for the specific language governing permissions and
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** limitations under the License.
-*/
-
-package com.android.providers.calendar;
-
-
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.provider.CalendarContract.CalendarMetaData;
-
-/**
- * The global meta-data used for expanding the Instances table is stored in one
- * row of the "CalendarMetaData" table.  This class is used for caching those
- * values to avoid repeatedly banging on the database.  It is also used
- * for writing the values back to the database, while maintaining the
- * consistency of the cache.
- * <p>
- * TODO: there must be only one of these active within CalendarProvider.  Enforce this.
- */
-public class MetaData {
-    /**
-     * These fields are updated atomically with the database.
-     * If fields are added or removed from the CalendarMetaData table, those
-     * changes must also be reflected here.
-     */
-    public class Fields {
-        public String timezone;     // local timezone used for Instance expansion
-        public long minInstance;    // UTC millis
-        public long maxInstance;    // UTC millis
-    }
-
-    /**
-     * The cached copy of the meta-data fields from the database.
-     */
-    private Fields mFields = new Fields();
-
-    private final SQLiteOpenHelper mOpenHelper;
-    private boolean mInitialized;
-
-    // SPRD for bug 456870 avoid year 2038 problem
-    private static final long MAX_TIME_VALUE = 2145888000000L; //maximum valid millisecond is 2037-12-31 24:00
-    /**
-     * The column names in the CalendarMetaData table.  This projection
-     * must contain all of the columns.
-     */
-    private static final String[] sCalendarMetaDataProjection = {
-        CalendarMetaData.LOCAL_TIMEZONE,
-        CalendarMetaData.MIN_INSTANCE,
-        CalendarMetaData.MAX_INSTANCE};
-
-    private static final int METADATA_INDEX_LOCAL_TIMEZONE = 0;
-    private static final int METADATA_INDEX_MIN_INSTANCE = 1;
-    private static final int METADATA_INDEX_MAX_INSTANCE = 2;
-
-    public MetaData(SQLiteOpenHelper openHelper) {
-        mOpenHelper = openHelper;
-    }
-
-    /**
-     * Returns a copy of all the MetaData fields.  This method grabs a
-     * database lock to read all the fields atomically.
-     *
-     * @return a copy of all the MetaData fields.
-     */
-    public Fields getFields() {
-        Fields fields = new Fields();
-        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
-        db.beginTransaction();
-        try {
-            // If the fields have not been initialized from the database,
-            // then read the database.
-            if (!mInitialized) {
-                readLocked(db);
-            }
-            fields.timezone = mFields.timezone;
-            fields.minInstance = mFields.minInstance;
-            fields.maxInstance = mFields.maxInstance;
-            db.setTransactionSuccessful();
-        } finally {
-            db.endTransaction();
-        }
-        return fields;
-    }
-
-    /**
-     * This method must be called only while holding a database lock.
-     *
-     * <p>
-     * Returns a copy of all the MetaData fields.  This method assumes
-     * the database lock has already been acquired.
-     * </p>
-     *
-     * @return a copy of all the MetaData fields.
-     */
-    public Fields getFieldsLocked() {
-        Fields fields = new Fields();
-
-        // If the fields have not been initialized from the database,
-        // then read the database.
-        if (!mInitialized) {
-            SQLiteDatabase db = mOpenHelper.getReadableDatabase();
-            readLocked(db);
-        }
-        fields.timezone = mFields.timezone;
-        fields.minInstance = mFields.minInstance;
-        fields.maxInstance = mFields.maxInstance;
-        return fields;
-    }
-
-    /**
-     * Reads the meta-data for the CalendarProvider from the database and
-     * updates the member variables.  This method executes while the database
-     * lock is held.  If there were no exceptions reading the database,
-     * mInitialized is set to true.
-     */
-    private void readLocked(SQLiteDatabase db) {
-        String timezone = null;
-        long minInstance = 0, maxInstance = 0;
-
-        // Read the database directly.  We only do this once to initialize
-        // the members of this class.
-        Cursor cursor = db.query("CalendarMetaData", sCalendarMetaDataProjection,
-                null, null, null, null, null);
-        try {
-            if (cursor.moveToNext()) {
-                timezone = cursor.getString(METADATA_INDEX_LOCAL_TIMEZONE);
-                minInstance = cursor.getLong(METADATA_INDEX_MIN_INSTANCE);
-                maxInstance = cursor.getLong(METADATA_INDEX_MAX_INSTANCE);
-            }
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-
-        // Cache the result of reading the database
-        mFields.timezone = timezone;
-        mFields.minInstance = minInstance;
-        mFields.maxInstance = maxInstance;
-
-        // Mark the fields as initialized
-        mInitialized = true;
-    }
-
-    /**
-     * Writes the meta-data for the CalendarProvider.  The values to write are
-     * passed in as parameters.  All of the values are updated atomically,
-     * including the cached copy of the meta-data.
-     *
-     * @param timezone the local timezone used for Instance expansion
-     * @param begin the start of the Instance expansion in UTC milliseconds
-     * @param end the end of the Instance expansion in UTC milliseconds
-     * @param startDay the start of the BusyBit expansion (the start Julian day)
-     * @param endDay the end of the BusyBit expansion (the end Julian day)
-     */
-    public void write(String timezone, long begin, long end, int startDay, int endDay) {
-        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
-        db.beginTransaction();
-        try {
-            writeLocked(timezone, begin, end);
-            db.setTransactionSuccessful();
-        } finally {
-            db.endTransaction();
-        }
-    }
-
-    /**
-     * This method must be called only while holding a database lock.
-     *
-     * <p>
-     * Writes the meta-data for the CalendarProvider.  The values to write are
-     * passed in as parameters.  All of the values are updated atomically,
-     * including the cached copy of the meta-data.
-     * </p>
-     *
-     * @param timezone the local timezone used for Instance expansion
-     * @param begin the start of the Instance expansion in UTC milliseconds
-     * @param end the end of the Instance expansion in UTC milliseconds
-     */
-    public void writeLocked(String timezone, long begin, long end) {
-        /* SPRD for bug 456870 avoid year 2038 problem @{ */
-        // if we use "end" large than MAX_TIME_VALUE, it maybe cause
-        // Time.set(end) less than Time.set(begin), and recurrence event can not
-        // be inserted to Instances table, and won't show in Calendar.
-        if (end > MAX_TIME_VALUE) {
-            end = MAX_TIME_VALUE;
-        }
-        /* @} */
-        ContentValues values = new ContentValues();
-        values.put("_id", 1);
-        values.put(CalendarMetaData.LOCAL_TIMEZONE, timezone);
-        values.put(CalendarMetaData.MIN_INSTANCE, begin);
-        values.put(CalendarMetaData.MAX_INSTANCE, end);
-
-        // Atomically update the database and the cached members.
-        try {
-            SQLiteDatabase db = mOpenHelper.getWritableDatabase();
-            db.replace("CalendarMetaData", null, values);
-        } catch (RuntimeException e) {
-            // Failed: zero the in-memory fields to force recomputation.
-            mFields.timezone = null;
-            mFields.minInstance = mFields.maxInstance = 0;
-            throw e;
-        }
-
-        // Update the cached members last in case the database update fails
-        mFields.timezone = timezone;
-        mFields.minInstance = begin;
-        mFields.maxInstance = end;
-    }
-
-    /**
-     * Clears the time range for the Instances table.  The rows in the
-     * Instances table will be deleted (and regenerated) the next time
-     * that the Instances table is queried.
-     *
-     * Also clears the time range for the BusyBits table because that depends
-     * on the Instances table.
-     */
-    public void clearInstanceRange() {
-        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
-        db.beginTransaction();
-        try {
-            // If the fields have not been initialized from the database,
-            // then read the database.
-            if (!mInitialized) {
-                readLocked(db);
-            }
-            writeLocked(mFields.timezone, 0 /* begin */, 0 /* end */);
-            db.setTransactionSuccessful();
-        } finally {
-            db.endTransaction();
-        }
-    }
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/EventLogTags.logtags
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/EventLogTags.logtags	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/EventLogTags.logtags	(revision 168087)
@@ -1,5 +0,0 @@
-# See system/core/logcat/event.logtags for a description of the format of this file.
-
-option java_package com.android.providers.calendar;
-
-4000 calendar_upgrade_receiver (time|2|3)
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarInstancesHelper.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarInstancesHelper.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarInstancesHelper.java	(revision 168087)
@@ -1,953 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.calendar;
-
-import com.android.calendarcommon2.DateException;
-import com.android.calendarcommon2.Duration;
-import com.android.calendarcommon2.EventRecurrence;
-import com.android.calendarcommon2.RecurrenceProcessor;
-import com.android.calendarcommon2.RecurrenceSet;
-import com.android.providers.calendar.CalendarDatabaseHelper.Tables;
-
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.database.DatabaseUtils;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteQueryBuilder;
-import android.os.Debug;
-import android.provider.CalendarContract.Calendars;
-import android.provider.CalendarContract.Events;
-import android.provider.CalendarContract.Instances;
-import android.text.TextUtils;
-import android.text.format.Time;
-import android.util.Log;
-import android.util.TimeFormatException;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Set;
-
-public class CalendarInstancesHelper {
-    public static final class EventInstancesMap extends
-            HashMap<String, CalendarInstancesHelper.InstancesList> {
-        public void add(String syncIdKey, ContentValues values) {
-            CalendarInstancesHelper.InstancesList instances = get(syncIdKey);
-            if (instances == null) {
-                instances = new CalendarInstancesHelper.InstancesList();
-                put(syncIdKey, instances);
-            }
-            instances.add(values);
-        }
-    }
-
-    public static final class InstancesList extends ArrayList<ContentValues> {
-    }
-
-    private static final String TAG = "CalInstances";
-    private CalendarDatabaseHelper mDbHelper;
-    private MetaData mMetaData;
-    private CalendarCache mCalendarCache;
-
-    private static final String SQL_WHERE_GET_EVENTS_ENTRIES =
-            "((" + Events.DTSTART + " <= ? AND "
-                    + "(" + Events.LAST_DATE + " IS NULL OR " + Events.LAST_DATE + " >= ?)) OR "
-            + "(" + Events.ORIGINAL_INSTANCE_TIME + " IS NOT NULL AND "
-                    + Events.ORIGINAL_INSTANCE_TIME
-                    + " <= ? AND " + Events.ORIGINAL_INSTANCE_TIME + " >= ?)) AND "
-            + "(" + Calendars.SYNC_EVENTS + " != ?) AND "
-            + "(" + Events.LAST_SYNCED + " = ?)";
-
-    /**
-     * Determines the set of Events where the _id matches the first query argument, or the
-     * originalId matches the second argument.  Returns the _id field from the set of
-     * Instances whose event_id field matches one of those events.
-     */
-    private static final String SQL_WHERE_ID_FROM_INSTANCES_NOT_SYNCED =
-            Instances._ID + " IN " +
-            "(SELECT " + Tables.INSTANCES + "." + Instances._ID + " as _id" +
-            " FROM " + Tables.INSTANCES +
-            " INNER JOIN " + Tables.EVENTS +
-            " ON (" +
-            Tables.EVENTS + "." + Events._ID + "=" + Tables.INSTANCES + "." + Instances.EVENT_ID +
-            ")" +
-            " WHERE " + Tables.EVENTS + "." + Events._ID + "=? OR " +
-                    Tables.EVENTS + "." + Events.ORIGINAL_ID + "=?)";
-
-    /**
-     * Determines the set of Events where the _sync_id matches the first query argument, or the
-     * originalSyncId matches the second argument.  Returns the _id field from the set of
-     * Instances whose event_id field matches one of those events.
-     */
-    private static final String SQL_WHERE_ID_FROM_INSTANCES_SYNCED =
-            Instances._ID + " IN " +
-            "(SELECT " + Tables.INSTANCES + "." + Instances._ID + " as _id" +
-            " FROM " + Tables.INSTANCES +
-            " INNER JOIN " + Tables.EVENTS +
-            " ON (" +
-            Tables.EVENTS + "." + Events._ID + "=" + Tables.INSTANCES + "." + Instances.EVENT_ID +
-            ")" +
-            " WHERE " + Tables.EVENTS + "." + Events._SYNC_ID + "=?" + " OR " +
-                    Tables.EVENTS + "." + Events.ORIGINAL_SYNC_ID + "=?)";
-
-    private static final String[] EXPAND_COLUMNS = new String[] {
-            Events._ID,
-            Events._SYNC_ID,
-            Events.STATUS,
-            Events.DTSTART,
-            Events.DTEND,
-            Events.EVENT_TIMEZONE,
-            Events.RRULE,
-            Events.RDATE,
-            Events.EXRULE,
-            Events.EXDATE,
-            Events.DURATION,
-            Events.ALL_DAY,
-            Events.ORIGINAL_SYNC_ID,
-            Events.ORIGINAL_INSTANCE_TIME,
-            Events.CALENDAR_ID,
-            Events.DELETED
-    };
-
-    // To determine if a recurrence exception originally overlapped the
-    // window, we need to assume a maximum duration, since we only know
-    // the original start time.
-    private static final int MAX_ASSUMED_DURATION = 7 * 24 * 60 * 60 * 1000;
-
-    // Bug #463264, 488364 if expandEnd Larger than max value, cause to delete error
-    // Add 20150710 of bug 450177 and 488896,Date super bound,cannot insert database
-    public static final long END_DAY_MAX = 2145888000000L; //the maximum millisecond value for 2037.12.31
-    public static final long END_DAY_MAX_ALLDAY = 2145916800000L; //max millis for 2037-12-31 allday
-
-    public CalendarInstancesHelper(CalendarDatabaseHelper calendarDbHelper, MetaData metaData) {
-        mDbHelper = calendarDbHelper;
-        mMetaData = metaData;
-        mCalendarCache = new CalendarCache(mDbHelper);
-    }
-
-    /**
-     * Extract the value from the specifed row and column of the Events table.
-     *
-     * @param db The database to access.
-     * @param rowId The Event's _id.
-     * @param columnName The name of the column to access.
-     * @return The value in string form.
-     */
-    private static String getEventValue(SQLiteDatabase db, long rowId, String columnName) {
-        String where = "SELECT " + columnName + " FROM " + Tables.EVENTS +
-            " WHERE " + Events._ID + "=?";
-        return DatabaseUtils.stringForQuery(db, where,
-                new String[] { String.valueOf(rowId) });
-    }
-
-    /**
-     * Perform instance expansion on the given entries.
-     *
-     * @param begin Window start (ms).
-     * @param end Window end (ms).
-     * @param localTimezone
-     * @param entries The entries to process.
-     */
-    protected void performInstanceExpansion(long begin, long end, String localTimezone,
-            Cursor entries) {
-        // TODO: this only knows how to work with events that have been synced with the server
-        RecurrenceProcessor rp = new RecurrenceProcessor();
-
-        // Key into the instance values to hold the original event concatenated
-        // with calendar id.
-        final String ORIGINAL_EVENT_AND_CALENDAR = "ORIGINAL_EVENT_AND_CALENDAR";
-
-        int statusColumn = entries.getColumnIndex(Events.STATUS);
-        int dtstartColumn = entries.getColumnIndex(Events.DTSTART);
-        int dtendColumn = entries.getColumnIndex(Events.DTEND);
-        int eventTimezoneColumn = entries.getColumnIndex(Events.EVENT_TIMEZONE);
-        int durationColumn = entries.getColumnIndex(Events.DURATION);
-        int rruleColumn = entries.getColumnIndex(Events.RRULE);
-        int rdateColumn = entries.getColumnIndex(Events.RDATE);
-        int exruleColumn = entries.getColumnIndex(Events.EXRULE);
-        int exdateColumn = entries.getColumnIndex(Events.EXDATE);
-        int allDayColumn = entries.getColumnIndex(Events.ALL_DAY);
-        int idColumn = entries.getColumnIndex(Events._ID);
-        int syncIdColumn = entries.getColumnIndex(Events._SYNC_ID);
-        int originalEventColumn = entries.getColumnIndex(Events.ORIGINAL_SYNC_ID);
-        int originalInstanceTimeColumn = entries.getColumnIndex(Events.ORIGINAL_INSTANCE_TIME);
-        int calendarIdColumn = entries.getColumnIndex(Events.CALENDAR_ID);
-        int deletedColumn = entries.getColumnIndex(Events.DELETED);
-
-        ContentValues initialValues;
-        CalendarInstancesHelper.EventInstancesMap instancesMap =
-            new CalendarInstancesHelper.EventInstancesMap();
-
-        Duration duration = new Duration();
-        Time eventTime = new Time();
-
-        // Invariant: entries contains all events that affect the current
-        // window.  It consists of:
-        // a) Individual events that fall in the window.  These will be
-        //    displayed.
-        // b) Recurrences that included the window.  These will be displayed
-        //    if not canceled.
-        // c) Recurrence exceptions that fall in the window.  These will be
-        //    displayed if not cancellations.
-        // d) Recurrence exceptions that modify an instance inside the
-        //    window (subject to 1 week assumption above), but are outside
-        //    the window.  These will not be displayed.  Cases c and d are
-        //    distinguished by the start / end time.
-
-        while (entries.moveToNext()) {
-            try {
-                initialValues = null;
-
-                boolean allDay = entries.getInt(allDayColumn) != 0;
-
-                String eventTimezone = entries.getString(eventTimezoneColumn);
-                if (allDay || TextUtils.isEmpty(eventTimezone)) {
-                    // in the events table, allDay events start at midnight.
-                    // this forces them to stay at midnight for all day events
-                    // TODO: check that this actually does the right thing.
-                    eventTimezone = Time.TIMEZONE_UTC;
-                }
-
-                long dtstartMillis = entries.getLong(dtstartColumn);
-                Long eventId = Long.valueOf(entries.getLong(idColumn));
-
-                String durationStr = entries.getString(durationColumn);
-                if (durationStr != null) {
-                    try {
-                        duration.parse(durationStr);
-                    }
-                    catch (DateException e) {
-                        if (Log.isLoggable(CalendarProvider2.TAG, Log.ERROR)) {
-                            Log.w(CalendarProvider2.TAG, "error parsing duration for event "
-                                    + eventId + "'" + durationStr + "'", e);
-                        }
-                        duration.sign = 1;
-                        duration.weeks = 0;
-                        duration.days = 0;
-                        duration.hours = 0;
-                        duration.minutes = 0;
-                        duration.seconds = 0;
-                        durationStr = "+P0S";
-                    }
-                }
-
-                String syncId = entries.getString(syncIdColumn);
-                String originalEvent = entries.getString(originalEventColumn);
-
-                long originalInstanceTimeMillis = -1;
-                if (!entries.isNull(originalInstanceTimeColumn)) {
-                    originalInstanceTimeMillis= entries.getLong(originalInstanceTimeColumn);
-                }
-                int status = entries.getInt(statusColumn);
-                boolean deleted = (entries.getInt(deletedColumn) != 0);
-
-                String rruleStr = entries.getString(rruleColumn);
-                String rdateStr = entries.getString(rdateColumn);
-                String exruleStr = entries.getString(exruleColumn);
-                String exdateStr = entries.getString(exdateColumn);
-                long calendarId = entries.getLong(calendarIdColumn);
-                // key into instancesMap
-                String syncIdKey = CalendarInstancesHelper.getSyncIdKey(syncId, calendarId);
-
-                RecurrenceSet recur = null;
-                try {
-                    recur = new RecurrenceSet(rruleStr, rdateStr, exruleStr, exdateStr);
-                } catch (EventRecurrence.InvalidFormatException e) {
-                    if (Log.isLoggable(CalendarProvider2.TAG, Log.ERROR)) {
-                        Log.w(CalendarProvider2.TAG, "Could not parse RRULE recurrence string: "
-                                + rruleStr, e);
-                    }
-                    continue;
-                }
-
-                if (null != recur && recur.hasRecurrence()) {
-                    // the event is repeating
-
-                    if (status == Events.STATUS_CANCELED) {
-                        // should not happen!
-                        if (Log.isLoggable(CalendarProvider2.TAG, Log.ERROR)) {
-                            Log.e(CalendarProvider2.TAG, "Found canceled recurring event in "
-                                    + "Events table.  Ignoring.");
-                        }
-                        continue;
-                    }
-                    if (deleted) {
-                        if (Log.isLoggable(CalendarProvider2.TAG, Log.DEBUG)) {
-                            Log.d(CalendarProvider2.TAG, "Found deleted recurring event in "
-                                    + "Events table.  Ignoring.");
-                        }
-                        continue;
-                    }
-
-                    // need to parse the event into a local calendar.
-                    eventTime.timezone = eventTimezone;
-                    eventTime.set(dtstartMillis);
-                    eventTime.allDay = allDay;
-
-                    if (durationStr == null) {
-                        // should not happen.
-                        if (Log.isLoggable(CalendarProvider2.TAG, Log.ERROR)) {
-                            Log.e(CalendarProvider2.TAG, "Repeating event has no duration -- "
-                                    + "should not happen.");
-                        }
-                        if (allDay) {
-                            // set to one day.
-                            duration.sign = 1;
-                            duration.weeks = 0;
-                            duration.days = 1;
-                            duration.hours = 0;
-                            duration.minutes = 0;
-                            duration.seconds = 0;
-                            durationStr = "+P1D";
-                        } else {
-                            // compute the duration from dtend, if we can.
-                            // otherwise, use 0s.
-                            duration.sign = 1;
-                            duration.weeks = 0;
-                            duration.days = 0;
-                            duration.hours = 0;
-                            duration.minutes = 0;
-                            if (!entries.isNull(dtendColumn)) {
-                                long dtendMillis = entries.getLong(dtendColumn);
-                                duration.seconds = (int) ((dtendMillis - dtstartMillis) / 1000);
-                                durationStr = "+P" + duration.seconds + "S";
-                            } else {
-                                duration.seconds = 0;
-                                durationStr = "+P0S";
-                            }
-                        }
-                    }
-
-                    long[] dates;
-                    dates = rp.expand(eventTime, recur, begin, end);
-
-                    // Initialize the "eventTime" timezone outside the loop.
-                    // This is used in computeTimezoneDependentFields().
-                    if (allDay) {
-                        eventTime.timezone = Time.TIMEZONE_UTC;
-                    } else {
-                        eventTime.timezone = localTimezone;
-                    }
-
-                    long durationMillis = duration.getMillis();
-                    for (long date : dates) {
-                        initialValues = new ContentValues();
-                        initialValues.put(Instances.EVENT_ID, eventId);
-
-                        initialValues.put(Instances.BEGIN, date);
-                        long dtendMillis = date + durationMillis;
-                        initialValues.put(Instances.END, dtendMillis);
-
-                        CalendarInstancesHelper.computeTimezoneDependentFields(date, dtendMillis,
-                                eventTime, initialValues);
-
-                        /*
-                         * SPRD: Add 20150710 of bug 450177 and 488896 ,Date super
-                         * bound,cannot insert database @{
-                         */
-                        boolean overBound = allDay ? (dtendMillis > END_DAY_MAX_ALLDAY) : (dtendMillis >= END_DAY_MAX);
-
-                        if (overBound || dtendMillis == -1) {
-                            Log.w(CalendarProvider2.TAG, "Date super bound,cannot insert database");
-                        }else{
-                            instancesMap.add(syncIdKey, initialValues);
-                        }
-
-                        /* @} */
-                    }
-                } else {
-                    // the event is not repeating
-                    initialValues = new ContentValues();
-
-                    // if this event has an "original" field, then record
-                    // that we need to cancel the original event (we can't
-                    // do that here because the order of this loop isn't
-                    // defined)
-                    if (originalEvent != null && originalInstanceTimeMillis != -1) {
-                        // The ORIGINAL_EVENT_AND_CALENDAR holds the
-                        // calendar id concatenated with the ORIGINAL_EVENT to form
-                        // a unique key, matching the keys for instancesMap.
-                        initialValues.put(ORIGINAL_EVENT_AND_CALENDAR,
-                                CalendarInstancesHelper.getSyncIdKey(originalEvent, calendarId));
-                        initialValues.put(Events.ORIGINAL_INSTANCE_TIME,
-                                originalInstanceTimeMillis);
-                        initialValues.put(Events.STATUS, status);
-                    }
-
-                    long dtendMillis = dtstartMillis;
-                    if (durationStr == null) {
-                        if (!entries.isNull(dtendColumn)) {
-                            dtendMillis = entries.getLong(dtendColumn);
-                        }
-                    } else {
-                        dtendMillis = duration.addTo(dtstartMillis);
-                    }
-
-                    // this non-recurring event might be a recurrence exception that doesn't
-                    // actually fall within our expansion window, but instead was selected
-                    // so we can correctly cancel expanded recurrence instances below.  do not
-                    // add events to the instances map if they don't actually fall within our
-                    // expansion window.
-                    if ((dtendMillis < begin) || (dtstartMillis > end)) {
-                        if (originalEvent != null && originalInstanceTimeMillis != -1) {
-                            initialValues.put(Events.STATUS, Events.STATUS_CANCELED);
-                        } else {
-                            if (Log.isLoggable(CalendarProvider2.TAG, Log.ERROR)) {
-                                Log.w(CalendarProvider2.TAG, "Unexpected event outside window: "
-                                        + syncId);
-                            }
-                            continue;
-                        }
-                    }
-
-                    initialValues.put(Instances.EVENT_ID, eventId);
-
-                    initialValues.put(Instances.BEGIN, dtstartMillis);
-                    initialValues.put(Instances.END, dtendMillis);
-
-                    // we temporarily store the DELETED status (will be cleaned later)
-                    initialValues.put(Events.DELETED, deleted);
-
-                    if (allDay) {
-                        eventTime.timezone = Time.TIMEZONE_UTC;
-                    } else {
-                        eventTime.timezone = localTimezone;
-                    }
-                    CalendarInstancesHelper.computeTimezoneDependentFields(dtstartMillis,
-                            dtendMillis, eventTime, initialValues);
-
-                    /*
-                     * SPRD: Add 20150710 of bug 450177 and 488896,Date super
-                     * bound,cannot insert database @{
-                     */
-                    boolean overBound = allDay ? (dtendMillis > END_DAY_MAX_ALLDAY) : (dtendMillis >= END_DAY_MAX);
-
-                    if (overBound || dtendMillis == -1) {
-                        Log.w(CalendarProvider2.TAG, "Date super bound,cannot insert database");
-                    }else{
-                        instancesMap.add(syncIdKey, initialValues);
-                    }
-                    /* @} */
-                }
-            } catch (DateException e) {
-                if (Log.isLoggable(CalendarProvider2.TAG, Log.ERROR)) {
-                    Log.w(CalendarProvider2.TAG, "RecurrenceProcessor error ", e);
-                }
-            } catch (TimeFormatException e) {
-                if (Log.isLoggable(CalendarProvider2.TAG, Log.ERROR)) {
-                    Log.w(CalendarProvider2.TAG, "RecurrenceProcessor error ", e);
-                }
-            }
-        }
-
-        // Invariant: instancesMap contains all instances that affect the
-        // window, indexed by original sync id concatenated with calendar id.
-        // It consists of:
-        // a) Individual events that fall in the window.  They have:
-        //   EVENT_ID, BEGIN, END
-        // b) Instances of recurrences that fall in the window.  They may
-        //   be subject to exceptions.  They have:
-        //   EVENT_ID, BEGIN, END
-        // c) Exceptions that fall in the window.  They have:
-        //   ORIGINAL_EVENT_AND_CALENDAR, ORIGINAL_INSTANCE_TIME, STATUS (since they can
-        //   be a modification or cancellation), EVENT_ID, BEGIN, END
-        // d) Recurrence exceptions that modify an instance inside the
-        //   window but fall outside the window.  They have:
-        //   ORIGINAL_EVENT_AND_CALENDAR, ORIGINAL_INSTANCE_TIME, STATUS =
-        //   STATUS_CANCELED, EVENT_ID, BEGIN, END
-
-        // First, delete the original instances corresponding to recurrence
-        // exceptions.  We do this by iterating over the list and for each
-        // recurrence exception, we search the list for an instance with a
-        // matching "original instance time".  If we find such an instance,
-        // we remove it from the list.  If we don't find such an instance
-        // then we cancel the recurrence exception.
-        Set<String> keys = instancesMap.keySet();
-        for (String syncIdKey : keys) {
-            CalendarInstancesHelper.InstancesList list = instancesMap.get(syncIdKey);
-            for (ContentValues values : list) {
-
-                // If this instance is not a recurrence exception, then
-                // skip it.
-                if (!values.containsKey(ORIGINAL_EVENT_AND_CALENDAR)) {
-                    continue;
-                }
-
-                String originalEventPlusCalendar = values.getAsString(ORIGINAL_EVENT_AND_CALENDAR);
-                long originalTime = values.getAsLong(Events.ORIGINAL_INSTANCE_TIME);
-                CalendarInstancesHelper.InstancesList originalList = instancesMap
-                        .get(originalEventPlusCalendar);
-                if (originalList == null) {
-                    // The original recurrence is not present, so don't try canceling it.
-                    continue;
-                }
-
-                // Search the original event for a matching original
-                // instance time.  If there is a matching one, then remove
-                // the original one.  We do this both for exceptions that
-                // change the original instance as well as for exceptions
-                // that delete the original instance.
-                for (int num = originalList.size() - 1; num >= 0; num--) {
-                    ContentValues originalValues = originalList.get(num);
-                    long beginTime = originalValues.getAsLong(Instances.BEGIN);
-                    if (beginTime == originalTime) {
-                        // We found the original instance, so remove it.
-                        originalList.remove(num);
-                    }
-                }
-            }
-        }
-
-        // Invariant: instancesMap contains filtered instances.
-        // It consists of:
-        // a) Individual events that fall in the window.
-        // b) Instances of recurrences that fall in the window and have not
-        //   been subject to exceptions.
-        // c) Exceptions that fall in the window.  They will have
-        //   STATUS_CANCELED if they are cancellations.
-        // d) Recurrence exceptions that modify an instance inside the
-        //   window but fall outside the window.  These are STATUS_CANCELED.
-
-        // Now do the inserts.  Since the db lock is held when this method is executed,
-        // this will be done in a transaction.
-        // NOTE: if there is lock contention (e.g., a sync is trying to merge into the db
-        // while the calendar app is trying to query the db (expanding instances)), we will
-        // not be "polite" and yield the lock until we're done.  This will favor local query
-        // operations over sync/write operations.
-        for (String syncIdKey : keys) {
-            CalendarInstancesHelper.InstancesList list = instancesMap.get(syncIdKey);
-            for (ContentValues values : list) {
-
-                // If this instance was cancelled or deleted then don't create a new
-                // instance.
-                Integer status = values.getAsInteger(Events.STATUS);
-                boolean deleted = values.containsKey(Events.DELETED) ?
-                        values.getAsBoolean(Events.DELETED) : false;
-                if ((status != null && status == Events.STATUS_CANCELED) || deleted) {
-                    continue;
-                }
-
-                // We remove this useless key (not valid in the context of Instances table)
-                values.remove(Events.DELETED);
-
-                // Remove these fields before inserting a new instance
-                values.remove(ORIGINAL_EVENT_AND_CALENDAR);
-                values.remove(Events.ORIGINAL_INSTANCE_TIME);
-                values.remove(Events.STATUS);
-
-                mDbHelper.instancesReplace(values);
-            }
-        }
-    }
-
-    /**
-     * Make instances for the given range.
-     */
-    protected void expandInstanceRangeLocked(long begin, long end, String localTimezone) {
-
-        if (CalendarProvider2.PROFILE) {
-            Debug.startMethodTracing("expandInstanceRangeLocked");
-        }
-
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "Expanding events between " + begin + " and " + end);
-        }
-
-        Cursor entries = getEntries(begin, end);
-        try {
-            performInstanceExpansion(begin, end, localTimezone, entries);
-        } finally {
-            if (entries != null) {
-                entries.close();
-            }
-        }
-        if (CalendarProvider2.PROFILE) {
-            Debug.stopMethodTracing();
-        }
-    }
-
-    /**
-     * Get all entries affecting the given window.
-     *
-     * @param begin Window start (ms).
-     * @param end Window end (ms).
-     * @return Cursor for the entries; caller must close it.
-     */
-    private Cursor getEntries(long begin, long end) {
-        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
-        qb.setTables(CalendarDatabaseHelper.Views.EVENTS);
-        qb.setProjectionMap(CalendarProvider2.sEventsProjectionMap);
-
-        String beginString = String.valueOf(begin);
-        String endString = String.valueOf(end);
-
-        // grab recurrence exceptions that fall outside our expansion window but
-        // modify
-        // recurrences that do fall within our window. we won't insert these
-        // into the output
-        // set of instances, but instead will just add them to our cancellations
-        // list, so we
-        // can cancel the correct recurrence expansion instances.
-        // we don't have originalInstanceDuration or end time. for now, assume
-        // the original
-        // instance lasts no longer than 1 week.
-        // also filter with syncable state (we dont want the entries from a non
-        // syncable account)
-        // also filter with last_synced=0 so we don't expand events that were
-        // dup'ed for partial updates.
-        // TODO: compute the originalInstanceEndTime or get this from the
-        // server.
-        qb.appendWhere(SQL_WHERE_GET_EVENTS_ENTRIES);
-        String selectionArgs[] = new String[] {
-                endString,
-                beginString,
-                endString,
-                String.valueOf(begin - MAX_ASSUMED_DURATION),
-                "0", // Calendars.SYNC_EVENTS
-                "0", // Events.LAST_SYNCED
-        };
-        final SQLiteDatabase db = mDbHelper.getReadableDatabase();
-        Cursor c = qb.query(db, EXPAND_COLUMNS, null /* selection */, selectionArgs,
-                null /* groupBy */, null /* having */, null /* sortOrder */);
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "Instance expansion:  got " + c.getCount() + " entries");
-        }
-        return c;
-    }
-
-    /**
-     * Updates the instances table when an event is added or updated.
-     *
-     * @param values The new values of the event.
-     * @param rowId The database row id of the event.
-     * @param newEvent true if the event is new.
-     * @param db The database
-     */
-    public void updateInstancesLocked(ContentValues values, long rowId, boolean newEvent,
-            SQLiteDatabase db) {
-        /*
-         * This may be a recurring event (has an RRULE or RDATE), an exception to a recurring
-         * event (has ORIGINAL_ID or ORIGINAL_SYNC_ID), or a regular event.  Recurring events
-         * and exceptions require additional handling.
-         *
-         * If this is not a new event, it may already have entries in Instances, so we want
-         * to delete those before we do any additional work.
-         */
-
-        // If there are no expanded Instances, then return.
-        MetaData.Fields fields = mMetaData.getFieldsLocked();
-        if (fields.maxInstance == 0) {
-            return;
-        }
-
-        Long dtstartMillis = values.getAsLong(Events.DTSTART);
-        if (dtstartMillis == null) {
-            if (newEvent) {
-                // must be present for a new event.
-                throw new RuntimeException("DTSTART missing.");
-            }
-            if (Log.isLoggable(TAG, Log.VERBOSE)) {
-                Log.v(TAG, "Missing DTSTART.  No need to update instance.");
-            }
-            return;
-        }
-
-        if (!newEvent) {
-            // Want to do this for regular event, recurrence, or exception.
-            // For recurrence or exception, more deletion may happen below if we
-            // do an instance expansion. This deletion will suffice if the
-            // exception
-            // is moved outside the window, for instance.
-            db.delete(Tables.INSTANCES, Instances.EVENT_ID + "=?", new String[] {
-                String.valueOf(rowId)
-            });
-        }
-
-        String rrule = values.getAsString(Events.RRULE);
-        String rdate = values.getAsString(Events.RDATE);
-        String originalId = values.getAsString(Events.ORIGINAL_ID);
-        String originalSyncId = values.getAsString(Events.ORIGINAL_SYNC_ID);
-        if (CalendarProvider2.isRecurrenceEvent(rrule, rdate, originalId, originalSyncId)) {
-            Long lastDateMillis = values.getAsLong(Events.LAST_DATE);
-            Long originalInstanceTime = values.getAsLong(Events.ORIGINAL_INSTANCE_TIME);
-
-            // The recurrence or exception needs to be (re-)expanded if:
-            // a) Exception or recurrence that falls inside window
-            boolean insideWindow = dtstartMillis <= fields.maxInstance
-                    && (lastDateMillis == null || lastDateMillis >= fields.minInstance);
-            // b) Exception that affects instance inside window
-            // These conditions match the query in getEntries
-            // See getEntries comment for explanation of subtracting 1 week.
-            boolean affectsWindow = originalInstanceTime != null
-                    && originalInstanceTime <= fields.maxInstance
-                    && originalInstanceTime >= fields.minInstance - MAX_ASSUMED_DURATION;
-            if (CalendarProvider2.DEBUG_INSTANCES) {
-                Log.d(TAG + "-i", "Recurrence: inside=" + insideWindow +
-                        ", affects=" + affectsWindow);
-            }
-            if (insideWindow || affectsWindow) {
-                updateRecurrenceInstancesLocked(values, rowId, db);
-            }
-            // TODO: an exception creation or update could be optimized by
-            // updating just the affected instances, instead of regenerating
-            // the recurrence.
-            return;
-        }
-
-        Long dtendMillis = values.getAsLong(Events.DTEND);
-        if (dtendMillis == null) {
-            dtendMillis = dtstartMillis;
-        }
-
-        // if the event is in the expanded range, insert
-        // into the instances table.
-        // TODO: deal with durations. currently, durations are only used in
-        // recurrences.
-
-        if (dtstartMillis <= fields.maxInstance && dtendMillis >= fields.minInstance) {
-            ContentValues instanceValues = new ContentValues();
-            instanceValues.put(Instances.EVENT_ID, rowId);
-            instanceValues.put(Instances.BEGIN, dtstartMillis);
-            instanceValues.put(Instances.END, dtendMillis);
-
-            boolean allDay = false;
-            Integer allDayInteger = values.getAsInteger(Events.ALL_DAY);
-            if (allDayInteger != null) {
-                allDay = allDayInteger != 0;
-            }
-
-            // Update the timezone-dependent fields.
-            Time local = new Time();
-            if (allDay) {
-                local.timezone = Time.TIMEZONE_UTC;
-            } else {
-                local.timezone = fields.timezone;
-            }
-
-            CalendarInstancesHelper.computeTimezoneDependentFields(dtstartMillis, dtendMillis,
-                    local, instanceValues);
-            mDbHelper.instancesInsert(instanceValues);
-        }
-    }
-
-    /**
-     * Do incremental Instances update of a recurrence or recurrence exception.
-     * This method does performInstanceExpansion on just the modified
-     * recurrence, to avoid the overhead of recomputing the entire instance
-     * table.
-     *
-     * @param values The new values of the event.
-     * @param rowId The database row id of the event.
-     * @param db The database
-     */
-    private void updateRecurrenceInstancesLocked(ContentValues values, long rowId,
-            SQLiteDatabase db) {
-        /*
-         *  There are two categories of event that "rowId" may refer to:
-         *  (1) Recurrence event.
-         *  (2) Exception to recurrence event.  Has non-empty originalId (if it originated
-         *      locally), originalSyncId (if it originated from the server), or both (if
-         *      it's fully synchronized).
-         *
-         * Exceptions may arrive from the server before the recurrence event, which means:
-         *  - We could find an originalSyncId but a lookup on originalSyncId could fail (in
-         *    which case we can just ignore the exception for now).
-         *  - There may be a brief period between the time we receive a recurrence and the
-         *    time we set originalId in related exceptions where originalSyncId is the only
-         *    way to find exceptions for a recurrence.  Thus, an empty originalId field may
-         *    not be used to decide if an event is an exception.
-         */
-
-        MetaData.Fields fields = mMetaData.getFieldsLocked();
-        String instancesTimezone = mCalendarCache.readTimezoneInstances();
-
-        // Get the originalSyncId.  If it's not in "values", check the database.
-        String originalSyncId = values.getAsString(Events.ORIGINAL_SYNC_ID);
-        if (originalSyncId == null) {
-            originalSyncId = getEventValue(db, rowId, Events.ORIGINAL_SYNC_ID);
-        }
-
-        String recurrenceSyncId;
-        if (originalSyncId != null) {
-            // This event is an exception; set recurrenceSyncId to the original.
-            recurrenceSyncId = originalSyncId;
-        } else {
-            // This could be a recurrence or an exception.  If it has been synced with the
-            // server we can get the _sync_id and know for certain that it's a recurrence.
-            // If not, we'll deal with it below.
-            recurrenceSyncId = values.getAsString(Events._SYNC_ID);
-            if (recurrenceSyncId == null) {
-                // Not in "values", check the database.
-                recurrenceSyncId = getEventValue(db, rowId, Events._SYNC_ID);
-            }
-        }
-
-        // Clear out old instances
-        int delCount;
-        if (recurrenceSyncId == null) {
-            // We're creating or updating a recurrence or exception that hasn't been to the
-            // server.  If this is a recurrence event, the event ID is simply the rowId.  If
-            // it's an exception, we will find the value in the originalId field.
-            String originalId = values.getAsString(Events.ORIGINAL_ID);
-            if (originalId == null) {
-                // Not in "values", check the database.
-                originalId = getEventValue(db, rowId, Events.ORIGINAL_ID);
-            }
-            String recurrenceId;
-            if (originalId != null) {
-                // This event is an exception; set recurrenceId to the original.
-                recurrenceId = originalId;
-            } else {
-                // This event is a recurrence, so we just use the ID that was passed in.
-                recurrenceId = String.valueOf(rowId);
-            }
-
-            // Delete Instances entries for this Event (_id == recurrenceId) and for exceptions
-            // to this Event (originalId == recurrenceId).
-            String where = SQL_WHERE_ID_FROM_INSTANCES_NOT_SYNCED;
-            delCount = db.delete(Tables.INSTANCES, where, new String[] {
-                    recurrenceId, recurrenceId
-            });
-        } else {
-            // We're creating or updating a recurrence or exception that has been synced with
-            // the server.  Delete Instances entries for this Event (_sync_id == recurrenceSyncId)
-            // and for exceptions to this Event (originalSyncId == recurrenceSyncId).
-            String where = SQL_WHERE_ID_FROM_INSTANCES_SYNCED;
-            delCount = db.delete(Tables.INSTANCES, where, new String[] {
-                    recurrenceSyncId, recurrenceSyncId
-            });
-        }
-
-        //Log.d(TAG, "Recurrence: deleted " + delCount + " instances");
-        //dumpInstancesTable(db);
-
-        // Now do instance expansion
-        // TODO: passing "rowId" is wrong if this is an exception - need originalId then
-        Cursor entries = getRelevantRecurrenceEntries(recurrenceSyncId, rowId);
-        try {
-            performInstanceExpansion(fields.minInstance, fields.maxInstance,
-                    instancesTimezone, entries);
-        } finally {
-            if (entries != null) {
-                entries.close();
-            }
-        }
-    }
-
-    /**
-     * Determines the recurrence entries associated with a particular
-     * recurrence. This set is the base recurrence and any exception. Normally
-     * the entries are indicated by the sync id of the base recurrence (which is
-     * the originalSyncId in the exceptions). However, a complication is that a
-     * recurrence may not yet have a sync id. In that case, the recurrence is
-     * specified by the rowId.
-     *
-     * @param recurrenceSyncId The sync id of the base recurrence, or null.
-     * @param rowId The row id of the base recurrence.
-     * @return the relevant entries.
-     */
-    private Cursor getRelevantRecurrenceEntries(String recurrenceSyncId, long rowId) {
-        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
-
-        qb.setTables(CalendarDatabaseHelper.Views.EVENTS);
-        qb.setProjectionMap(CalendarProvider2.sEventsProjectionMap);
-        String selectionArgs[];
-        if (recurrenceSyncId == null) {
-            String where = CalendarProvider2.SQL_WHERE_ID;
-            qb.appendWhere(where);
-            selectionArgs = new String[] {
-                String.valueOf(rowId)
-            };
-        } else {
-            // don't expand events that were dup'ed for partial updates
-            String where = "(" + Events._SYNC_ID + "=? OR " + Events.ORIGINAL_SYNC_ID + "=?) AND "
-                    + Events.LAST_SYNCED + " = ?";
-            qb.appendWhere(where);
-            selectionArgs = new String[] {
-                    recurrenceSyncId,
-                    recurrenceSyncId,
-                    "0", // Events.LAST_SYNCED
-            };
-        }
-        if (Log.isLoggable(TAG, Log.VERBOSE)) {
-            Log.v(TAG, "Retrieving events to expand: " + qb.toString());
-        }
-
-        final SQLiteDatabase db = mDbHelper.getReadableDatabase();
-        return qb.query(db, EXPAND_COLUMNS, null /* selection */, selectionArgs,
-                null /* groupBy */, null /* having */, null /* sortOrder */);
-    }
-
-    /**
-     * Generates a unique key from the syncId and calendarId. The purpose of
-     * this is to prevent collisions if two different calendars use the same
-     * sync id. This can happen if a Google calendar is accessed by two
-     * different accounts, or with Exchange, where ids are not unique between
-     * calendars.
-     *
-     * @param syncId Id for the event
-     * @param calendarId Id for the calendar
-     * @return key
-     */
-    static String getSyncIdKey(String syncId, long calendarId) {
-        return calendarId + ":" + syncId;
-    }
-
-    /**
-     * Computes the timezone-dependent fields of an instance of an event and
-     * updates the "values" map to contain those fields.
-     *
-     * @param begin the start time of the instance (in UTC milliseconds)
-     * @param end the end time of the instance (in UTC milliseconds)
-     * @param local a Time object with the timezone set to the local timezone
-     * @param values a map that will contain the timezone-dependent fields
-     */
-    static void computeTimezoneDependentFields(long begin, long end,
-            Time local, ContentValues values) {
-        local.set(begin);
-        int startDay = Time.getJulianDay(begin, local.gmtoff);
-        int startMinute = local.hour * 60 + local.minute;
-
-        local.set(end);
-        int endDay = Time.getJulianDay(end, local.gmtoff);
-        int endMinute = local.hour * 60 + local.minute;
-
-        // Special case for midnight, which has endMinute == 0.  Change
-        // that to +24 hours on the previous day to make everything simpler.
-        // Exception: if start and end minute are both 0 on the same day,
-        // then leave endMinute alone.
-        if (endMinute == 0 && endDay > startDay) {
-            endMinute = 24 * 60;
-            endDay -= 1;
-        }
-
-        values.put(Instances.START_DAY, startDay);
-        values.put(Instances.END_DAY, endDay);
-        values.put(Instances.START_MINUTE, startMinute);
-        values.put(Instances.END_MINUTE, endMinute);
-    }
-
-    /**
-     * Dumps the contents of the Instances table to the log file.
-     */
-    private static void dumpInstancesTable(SQLiteDatabase db) {
-        Cursor cursor = db.query(Tables.INSTANCES, null, null, null, null, null, null);
-        DatabaseUtils.dumpCursor(cursor);
-        if (cursor != null) {
-            cursor.close();
-        }
-    }
-}
Index: packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarAlarmManager.java
===================================================================
--- packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarAlarmManager.java	(revision 168086)
+++ packages/providers/CalendarProvider/src/com/android/providers/calendar/CalendarAlarmManager.java	(revision 168087)
@@ -1,558 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.calendar;
-
-import com.android.providers.calendar.CalendarDatabaseHelper.Tables;
-import com.android.providers.calendar.CalendarDatabaseHelper.Views;
-import com.google.common.annotations.VisibleForTesting;
-
-import android.app.AlarmManager;
-import android.app.PendingIntent;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.Intent;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.net.Uri;
-import android.os.Build;
-import android.os.PowerManager;
-import android.os.PowerManager.WakeLock;
-import android.os.SystemClock;
-import android.provider.CalendarContract;
-import android.provider.CalendarContract.CalendarAlerts;
-import android.provider.CalendarContract.Calendars;
-import android.provider.CalendarContract.Events;
-import android.provider.CalendarContract.Instances;
-import android.provider.CalendarContract.Reminders;
-import android.text.format.DateUtils;
-import android.text.format.Time;
-import android.util.Log;
-
-import java.util.concurrent.atomic.AtomicBoolean;
-
-/**
- * We are using the CalendarAlertManager to be able to mock the AlarmManager as the AlarmManager
- * cannot be extended.
- *
- * CalendarAlertManager is delegating its calls to the real AlarmService.
- */
-public class CalendarAlarmManager {
-    protected static final String TAG = "CalendarAlarmManager";
-
-    // SCHEDULE_ALARM_URI runs scheduleNextAlarm(false)
-    // SCHEDULE_ALARM_REMOVE_URI runs scheduleNextAlarm(true)
-    // TODO: use a service to schedule alarms rather than private URI
-    /* package */static final String SCHEDULE_ALARM_PATH = "schedule_alarms";
-    /* package */static final String SCHEDULE_ALARM_REMOVE_PATH = "schedule_alarms_remove";
-    /* package */static final String KEY_REMOVE_ALARMS = "removeAlarms";
-    /* package */static final Uri SCHEDULE_ALARM_REMOVE_URI = Uri.withAppendedPath(
-            CalendarContract.CONTENT_URI, SCHEDULE_ALARM_REMOVE_PATH);
-    /* package */static final Uri SCHEDULE_ALARM_URI = Uri.withAppendedPath(
-            CalendarContract.CONTENT_URI, SCHEDULE_ALARM_PATH);
-
-    /**
-     * If no alarms are scheduled in the next 24h, check for future alarms again after this period
-     * has passed. Scheduling the check 15 minutes earlier than 24h to prevent the scheduler alarm
-     * from using up the alarms quota for reminders during dozing.
-     *
-     * @see AlarmManager#setExactAndAllowWhileIdle
-     */
-    private static final long ALARM_CHECK_WHEN_NO_ALARM_IS_SCHEDULED_INTERVAL_MILLIS =
-            DateUtils.DAY_IN_MILLIS - (15 * DateUtils.MINUTE_IN_MILLIS);
-
-    static final String INVALID_CALENDARALERTS_SELECTOR =
-    "_id IN (SELECT ca." + CalendarAlerts._ID + " FROM "
-            + Tables.CALENDAR_ALERTS + " AS ca"
-            + " LEFT OUTER JOIN " + Tables.INSTANCES
-            + " USING (" + Instances.EVENT_ID + ","
-            + Instances.BEGIN + "," + Instances.END + ")"
-            + " LEFT OUTER JOIN " + Tables.REMINDERS + " AS r ON"
-            + " (ca." + CalendarAlerts.EVENT_ID + "=r." + Reminders.EVENT_ID
-            + " AND ca." + CalendarAlerts.MINUTES + "=r." + Reminders.MINUTES + ")"
-            + " LEFT OUTER JOIN " + Views.EVENTS + " AS e ON"
-            + " (ca." + CalendarAlerts.EVENT_ID + "=e." + Events._ID + ")"
-            + " WHERE " + Tables.INSTANCES + "." + Instances.BEGIN + " ISNULL"
-            + "   OR ca." + CalendarAlerts.ALARM_TIME + "<?"
-            + "   OR (r." + Reminders.MINUTES + " ISNULL"
-            + "       AND ca." + CalendarAlerts.MINUTES + "<>0)"
-            + "   OR e." + Calendars.VISIBLE + "=0)";
-
-    /**
-     * We search backward in time for event reminders that we may have missed
-     * and schedule them if the event has not yet expired. The amount in the
-     * past to search backwards is controlled by this constant. It should be at
-     * least a few minutes to allow for an event that was recently created on
-     * the web to make its way to the phone. Two hours might seem like overkill,
-     * but it is useful in the case where the user just crossed into a new
-     * timezone and might have just missed an alarm.
-     */
-    private static final long SCHEDULE_ALARM_SLACK = 2 * DateUtils.HOUR_IN_MILLIS;
-    /**
-     * Alarms older than this threshold will be deleted from the CalendarAlerts
-     * table. This should be at least a day because if the timezone is wrong and
-     * the user corrects it we might delete good alarms that appear to be old
-     * because the device time was incorrectly in the future. This threshold
-     * must also be larger than SCHEDULE_ALARM_SLACK. We add the
-     * SCHEDULE_ALARM_SLACK to ensure this. To make it easier to find and debug
-     * problems with missed reminders, set this to something greater than a day.
-     */
-    private static final long CLEAR_OLD_ALARM_THRESHOLD = 7 * DateUtils.DAY_IN_MILLIS
-            + SCHEDULE_ALARM_SLACK;
-    private static final String SCHEDULE_NEXT_ALARM_WAKE_LOCK = "ScheduleNextAlarmWakeLock";
-    protected static final String ACTION_CHECK_NEXT_ALARM =
-            "com.android.providers.calendar.intent.CalendarProvider2";
-    static final int ALARM_CHECK_DELAY_MILLIS = 5000;
-
-    /**
-     * Used for tracking if the next alarm is already scheduled
-     */
-    @VisibleForTesting
-    protected AtomicBoolean mNextAlarmCheckScheduled;
-    /**
-     * Used for synchronization
-     */
-    @VisibleForTesting
-    protected Object mAlarmLock;
-    /**
-     * Used to keep the process from getting killed while scheduling alarms
-     */
-    private final WakeLock mScheduleNextAlarmWakeLock;
-
-    @VisibleForTesting
-    protected Context mContext;
-    private AlarmManager mAlarmManager;
-
-    public CalendarAlarmManager(Context context) {
-        initializeWithContext(context);
-
-        PowerManager powerManager = (PowerManager) mContext.getSystemService(
-                Context.POWER_SERVICE);
-        // Create a wake lock that will be used when we are actually
-        // scheduling the next alarm
-        mScheduleNextAlarmWakeLock = powerManager.newWakeLock(
-                PowerManager.PARTIAL_WAKE_LOCK, SCHEDULE_NEXT_ALARM_WAKE_LOCK);
-        // We want the Wake Lock to be reference counted (so that we dont
-        // need to take care
-        // about its reference counting)
-        mScheduleNextAlarmWakeLock.setReferenceCounted(true);
-    }
-
-    protected void initializeWithContext(Context context) {
-        mContext = context;
-        mAlarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
-        mNextAlarmCheckScheduled = new AtomicBoolean(false);
-        mAlarmLock = new Object();
-    }
-
-    private Intent getCheckNextAlarmIntent(boolean removeAlarms) {
-        Intent intent = new Intent(CalendarAlarmManager.ACTION_CHECK_NEXT_ALARM);
-        intent.setClass(mContext, CalendarProviderBroadcastReceiver.class);
-        intent.putExtra(KEY_REMOVE_ALARMS, removeAlarms);
-        return intent;
-    }
-
-    /**
-     * Called by CalendarProvider to check the next alarm. A small delay is added before the real
-     * checking happens in order to batch the requests.
-     *
-     * @param removeAlarms Remove scheduled alarms or not. See @{link
-     *                     #removeScheduledAlarmsLocked} for details.
-     */
-    void checkNextAlarm(boolean removeAlarms) {
-        // We must always run the following when 'removeAlarms' is true.  Previously it
-        // was possible to have a race condition on startup between TIME_CHANGED and
-        // BOOT_COMPLETED broadcast actions.  This resulted in alarms being
-        // missed (Bug 7221716) when the TIME_CHANGED broadcast ('removeAlarms' = false)
-        // happened right before the BOOT_COMPLETED ('removeAlarms' = true), and the
-        // BOOT_COMPLETED action was skipped since there was concurrent scheduling in progress.
-        if (!mNextAlarmCheckScheduled.getAndSet(true) || removeAlarms) {
-            if (Log.isLoggable(CalendarProvider2.TAG, Log.DEBUG)) {
-                Log.d(CalendarProvider2.TAG, "Scheduling check of next Alarm");
-            }
-            Intent intent = getCheckNextAlarmIntent(removeAlarms);
-            PendingIntent pending = PendingIntent.getBroadcast(mContext, 0 /* ignored */, intent,
-                    PendingIntent.FLAG_NO_CREATE);
-            if (pending != null) {
-                // Cancel any previous Alarm check requests
-                cancel(pending);
-            }
-            pending = PendingIntent.getBroadcast(mContext, 0 /* ignored */, intent,
-                    PendingIntent.FLAG_CANCEL_CURRENT);
-
-            // Trigger the check in 5s from now, so that we can have batch processing.
-            long triggerAtTime = SystemClock.elapsedRealtime() + ALARM_CHECK_DELAY_MILLIS;
-            // Given to the short delay, we just use setExact here.
-            setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pending);
-        }
-    }
-
-    /**
-     * Similar to {@link #checkNextAlarm}, but schedule the checking at specific {@code
-     * triggerTime}. In general, we do not need an alarm for scheduling. Instead we set the next
-     * alarm check immediately when a reminder is shown. The only use case for this
-     * is to schedule the next alarm check when there is no reminder within 1 day.
-     *
-     * @param triggerTimeMillis Time to run the next alarm check, in milliseconds.
-     */
-    void scheduleNextAlarmCheck(long triggerTimeMillis) {
-        Intent intent = getCheckNextAlarmIntent(false /* removeAlarms*/);
-        PendingIntent pending = PendingIntent.getBroadcast(
-                mContext, 0, intent, PendingIntent.FLAG_NO_CREATE);
-        if (pending != null) {
-            // Cancel any previous alarms that do the same thing.
-            cancel(pending);
-        }
-        pending = PendingIntent.getBroadcast(
-                mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT);
-
-        if (Log.isLoggable(CalendarProvider2.TAG, Log.DEBUG)) {
-            Time time = new Time();
-            time.set(triggerTimeMillis);
-            String timeStr = time.format(" %a, %b %d, %Y %I:%M%P");
-            Log.d(CalendarProvider2.TAG,
-                    "scheduleNextAlarmCheck at: " + triggerTimeMillis + timeStr);
-        }
-        setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerTimeMillis, pending);
-    }
-
-    PowerManager.WakeLock getScheduleNextAlarmWakeLock() {
-        return mScheduleNextAlarmWakeLock;
-    }
-
-    void acquireScheduleNextAlarmWakeLock() {
-        getScheduleNextAlarmWakeLock().acquire();
-    }
-
-    void releaseScheduleNextAlarmWakeLock() {
-        try {
-            getScheduleNextAlarmWakeLock().release();
-        } catch (RuntimeException e) {
-            if (!e.getMessage().startsWith("WakeLock under-locked ")) {
-              throw e;
-            }
-            Log.w(TAG, "WakeLock under-locked ignored.");
-        }
-    }
-
-    void rescheduleMissedAlarms() {
-        rescheduleMissedAlarms(mContext.getContentResolver());
-    }
-
-    /**
-     * This method runs in a background thread and schedules an alarm for the
-     * next calendar event, if necessary.
-     *
-     * @param removeAlarms
-     * @param cp2
-     */
-    void runScheduleNextAlarm(boolean removeAlarms, CalendarProvider2 cp2) {
-        Log.d(TAG, "runScheduleNextAlarm");
-        SQLiteDatabase db = cp2.mDb;
-        //SPRD: Add for bug594795, java.lang.IllegalStateException: attempt to re-open an already-closed SQLiteDatabase
-        if (db == null || !db.isOpen()) {
-            return;
-        }
-
-        // Reset so that we can accept other schedules of next alarm
-        mNextAlarmCheckScheduled.set(false);
-        db.beginTransaction();
-        try {
-            if (removeAlarms) {
-                removeScheduledAlarmsLocked(db);
-            }
-            scheduleNextAlarmLocked(db, cp2);
-            db.setTransactionSuccessful();
-        } finally {
-            db.endTransaction();
-        }
-    }
-
-    /**
-     * This method looks at the 24-hour window from now for any events that it
-     * needs to schedule. This method runs within a database transaction. It
-     * also runs in a background thread. The CalendarProvider2 keeps track of
-     * which alarms it has already scheduled to avoid scheduling them more than
-     * once and for debugging problems with alarms. It stores this knowledge in
-     * a database table called CalendarAlerts which persists across reboots. But
-     * the actual alarm list is in memory and disappears if the phone loses
-     * power. To avoid missing an alarm, we clear the entries in the
-     * CalendarAlerts table when we start up the CalendarProvider2. Scheduling
-     * an alarm multiple times is not tragic -- we filter out the extra ones
-     * when we receive them. But we still need to keep track of the scheduled
-     * alarms. The main reason is that we need to prevent multiple notifications
-     * for the same alarm (on the receive side) in case we accidentally schedule
-     * the same alarm multiple times. We don't have visibility into the system's
-     * alarm list so we can never know for sure if we have already scheduled an
-     * alarm and it's better to err on scheduling an alarm twice rather than
-     * missing an alarm. Another reason we keep track of scheduled alarms in a
-     * database table is that it makes it easy to run an SQL query to find the
-     * next reminder that we haven't scheduled.
-     *
-     * @param db the database
-     * @param cp2 TODO
-     */
-    private void scheduleNextAlarmLocked(SQLiteDatabase db, CalendarProvider2 cp2) {
-        Time time = new Time();
-
-        final long currentMillis = System.currentTimeMillis();
-        final long start = currentMillis - SCHEDULE_ALARM_SLACK;
-        final long end = start + (24 * 60 * 60 * 1000);
-        if (Log.isLoggable(CalendarProvider2.TAG, Log.DEBUG)) {
-            time.set(start);
-            String startTimeStr = time.format(" %a, %b %d, %Y %I:%M%P");
-            Log.d(CalendarProvider2.TAG, "runScheduleNextAlarm() start search: " + startTimeStr);
-        }
-
-        // Delete rows in CalendarAlert where the corresponding Instance or
-        // Reminder no longer exist.
-        // Also clear old alarms but keep alarms around for a while to prevent
-        // multiple alerts for the same reminder. The "clearUpToTime'
-        // should be further in the past than the point in time where
-        // we start searching for events (the "start" variable defined above).
-        String selectArg[] = new String[] { Long.toString(
-                currentMillis - CLEAR_OLD_ALARM_THRESHOLD) };
-
-        int rowsDeleted = db.delete(
-                CalendarAlerts.TABLE_NAME, INVALID_CALENDARALERTS_SELECTOR, selectArg);
-
-        long nextAlarmTime = end;
-        final ContentResolver resolver = mContext.getContentResolver();
-        final long tmpAlarmTime = CalendarAlerts.findNextAlarmTime(resolver, currentMillis);
-        if (tmpAlarmTime != -1 && tmpAlarmTime < nextAlarmTime) {
-            nextAlarmTime = tmpAlarmTime;
-        }
-
-        // Extract events from the database sorted by alarm time. The
-        // alarm times are computed from Instances.begin (whose units
-        // are milliseconds) and Reminders.minutes (whose units are
-        // minutes).
-        //
-        // Also, ignore events whose end time is already in the past.
-        // Also, ignore events alarms that we have already scheduled.
-        //
-        // Note 1: we can add support for the case where Reminders.minutes
-        // equals -1 to mean use Calendars.minutes by adding a UNION for
-        // that case where the two halves restrict the WHERE clause on
-        // Reminders.minutes != -1 and Reminders.minutes = 1, respectively.
-        //
-        // Note 2: we have to name "myAlarmTime" different from the
-        // "alarmTime" column in CalendarAlerts because otherwise the
-        // query won't find multiple alarms for the same event.
-        //
-        // The CAST is needed in the query because otherwise the expression
-        // will be untyped and sqlite3's manifest typing will not convert the
-        // string query parameter to an int in myAlarmtime>=?, so the comparison
-        // will fail. This could be simplified if bug 2464440 is resolved.
-
-        time.setToNow();
-        time.normalize(false);
-        long localOffset = time.gmtoff * 1000;
-
-        String allDayOffset = " -(" + localOffset + ") ";
-        String subQueryPrefix = "SELECT " + Instances.BEGIN;
-        String subQuerySuffix = " -(" + Reminders.MINUTES + "*" + +DateUtils.MINUTE_IN_MILLIS + ")"
-                + " AS myAlarmTime" + "," + Tables.INSTANCES + "." + Instances.EVENT_ID
-                + " AS eventId" + "," + Instances.BEGIN + "," + Instances.END + ","
-                + Instances.TITLE + "," + Instances.ALL_DAY + "," + Reminders.METHOD + ","
-                + Reminders.MINUTES + " FROM " + Tables.INSTANCES + " INNER JOIN " + Views.EVENTS
-                + " ON (" + Views.EVENTS + "." + Events._ID + "=" + Tables.INSTANCES + "."
-                + Instances.EVENT_ID + ")" + " INNER JOIN " + Tables.REMINDERS + " ON ("
-                + Tables.INSTANCES + "." + Instances.EVENT_ID + "=" + Tables.REMINDERS + "."
-                + Reminders.EVENT_ID + ")" + " WHERE " + Calendars.VISIBLE + "=1"
-                + " AND myAlarmTime>=CAST(? AS INT)" + " AND myAlarmTime<=CAST(? AS INT)" + " AND "
-                + Instances.END + ">=?" + " AND " + Reminders.METHOD + "=" + Reminders.METHOD_ALERT;
-
-        // we query separately for all day events to convert to local time from
-        // UTC
-        // we need to /subtract/ the offset to get the correct resulting local
-        // time
-        String allDayQuery = subQueryPrefix + allDayOffset + subQuerySuffix + " AND "
-                + Instances.ALL_DAY + "=1";
-        String nonAllDayQuery = subQueryPrefix + subQuerySuffix + " AND " + Instances.ALL_DAY
-                + "=0";
-
-        // we use UNION ALL because we are guaranteed to have no dupes between
-        // the two queries, and it is less expensive
-        String query = "SELECT *" + " FROM (" + allDayQuery + " UNION ALL " + nonAllDayQuery + ")"
-        // avoid rescheduling existing alarms
-                + " WHERE 0=(SELECT count(*) FROM " + Tables.CALENDAR_ALERTS + " CA" + " WHERE CA."
-                + CalendarAlerts.EVENT_ID + "=eventId" + " AND CA." + CalendarAlerts.BEGIN + "="
-                + Instances.BEGIN + " AND CA." + CalendarAlerts.ALARM_TIME + "=myAlarmTime)"
-                + " ORDER BY myAlarmTime," + Instances.BEGIN + "," + Instances.TITLE;
-
-        String queryParams[] = new String[] { String.valueOf(start), String.valueOf(nextAlarmTime),
-                String.valueOf(currentMillis), String.valueOf(start), String.valueOf(nextAlarmTime),
-                String.valueOf(currentMillis) };
-
-        String instancesTimezone = cp2.mCalendarCache.readTimezoneInstances();
-        final String timezoneType = cp2.mCalendarCache.readTimezoneType();
-        boolean isHomeTimezone = CalendarCache.TIMEZONE_TYPE_HOME.equals(timezoneType);
-        // expand this range by a day on either end to account for all day
-        // events
-        cp2.acquireInstanceRangeLocked(
-                start - DateUtils.DAY_IN_MILLIS, end + DateUtils.DAY_IN_MILLIS, false /*
-                                                                                       * don't
-                                                                                       * use
-                                                                                       * minimum
-                                                                                       * expansion
-                                                                                       * windows
-                                                                                       */,
-                false /* do not force Instances deletion and expansion */, instancesTimezone,
-                isHomeTimezone);
-        Cursor cursor = null;
-        try {
-            cursor = db.rawQuery(query, queryParams);
-
-            final int beginIndex = cursor.getColumnIndex(Instances.BEGIN);
-            final int endIndex = cursor.getColumnIndex(Instances.END);
-            final int eventIdIndex = cursor.getColumnIndex("eventId");
-            final int alarmTimeIndex = cursor.getColumnIndex("myAlarmTime");
-            final int minutesIndex = cursor.getColumnIndex(Reminders.MINUTES);
-
-            if (Log.isLoggable(CalendarProvider2.TAG, Log.DEBUG)) {
-                time.set(nextAlarmTime);
-                String alarmTimeStr = time.format(" %a, %b %d, %Y %I:%M%P");
-                Log.d(CalendarProvider2.TAG,
-                        "cursor results: " + cursor.getCount() + " nextAlarmTime: " + alarmTimeStr);
-            }
-
-            while (cursor.moveToNext()) {
-                // Schedule all alarms whose alarm time is as early as any
-                // scheduled alarm. For example, if the earliest alarm is at
-                // 1pm, then we will schedule all alarms that occur at 1pm
-                // but no alarms that occur later than 1pm.
-                // Actually, we allow alarms up to a minute later to also
-                // be scheduled so that we don't have to check immediately
-                // again after an event alarm goes off.
-                final long alarmTime = cursor.getLong(alarmTimeIndex);
-                final long eventId = cursor.getLong(eventIdIndex);
-                final int minutes = cursor.getInt(minutesIndex);
-                final long startTime = cursor.getLong(beginIndex);
-                final long endTime = cursor.getLong(endIndex);
-
-                if (Log.isLoggable(CalendarProvider2.TAG, Log.DEBUG)) {
-                    time.set(alarmTime);
-                    String schedTime = time.format(" %a, %b %d, %Y %I:%M%P");
-                    time.set(startTime);
-                    String startTimeStr = time.format(" %a, %b %d, %Y %I:%M%P");
-
-                    Log.d(CalendarProvider2.TAG,
-                            "  looking at id: " + eventId + " " + startTime + startTimeStr
-                                    + " alarm: " + alarmTime + schedTime);
-                }
-
-                if (alarmTime < nextAlarmTime) {
-                    nextAlarmTime = alarmTime;
-                } else if (alarmTime > nextAlarmTime + DateUtils.MINUTE_IN_MILLIS) {
-                    // This event alarm (and all later ones) will be scheduled
-                    // later.
-                    if (Log.isLoggable(CalendarProvider2.TAG, Log.DEBUG)) {
-                        Log.d(CalendarProvider2.TAG,
-                                "This event alarm (and all later ones) will be scheduled later");
-                    }
-                    break;
-                }
-
-                // Avoid an SQLiteContraintException by checking if this alarm
-                // already exists in the table.
-                if (CalendarAlerts.alarmExists(resolver, eventId, startTime, alarmTime)) {
-                    if (Log.isLoggable(CalendarProvider2.TAG, Log.DEBUG)) {
-                        int titleIndex = cursor.getColumnIndex(Events.TITLE);
-                        String title = cursor.getString(titleIndex);
-                        Log.d(CalendarProvider2.TAG,
-                                "  alarm exists for id: " + eventId + " " + title);
-                    }
-                    continue;
-                }
-
-                // Insert this alarm into the CalendarAlerts table
-                Uri uri = CalendarAlerts.insert(
-                        resolver, eventId, startTime, endTime, alarmTime, minutes);
-                if (uri == null) {
-                    if (Log.isLoggable(CalendarProvider2.TAG, Log.ERROR)) {
-                        Log.e(CalendarProvider2.TAG, "runScheduleNextAlarm() insert into "
-                                + "CalendarAlerts table failed");
-                    }
-                    continue;
-                }
-
-                scheduleAlarm(alarmTime);
-            }
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-
-        // Refresh notification bar
-        if (rowsDeleted > 0) {
-            scheduleAlarm(currentMillis);
-        }
-
-        // No event alarm is scheduled, check again in 24 hours. If a new
-        // event is inserted before the next alarm check, then this method
-        // will be run again when the new event is inserted.
-        if (nextAlarmTime == Long.MAX_VALUE) {
-            scheduleNextAlarmCheck(
-                    currentMillis + ALARM_CHECK_WHEN_NO_ALARM_IS_SCHEDULED_INTERVAL_MILLIS);
-        }
-    }
-
-    /**
-     * Removes the entries in the CalendarAlerts table for alarms that we have
-     * scheduled but that have not fired yet. We do this to ensure that we don't
-     * miss an alarm. The CalendarAlerts table keeps track of the alarms that we
-     * have scheduled but the actual alarm list is in memory and will be cleared
-     * if the phone reboots. We don't need to remove entries that have already
-     * fired, and in fact we should not remove them because we need to display
-     * the notifications until the user dismisses them. We could remove entries
-     * that have fired and been dismissed, but we leave them around for a while
-     * because it makes it easier to debug problems. Entries that are old enough
-     * will be cleaned up later when we schedule new alarms.
-     */
-    private static void removeScheduledAlarmsLocked(SQLiteDatabase db) {
-        if (Log.isLoggable(CalendarProvider2.TAG, Log.DEBUG)) {
-            Log.d(CalendarProvider2.TAG, "removing scheduled alarms");
-        }
-        db.delete(CalendarAlerts.TABLE_NAME, CalendarAlerts.STATE + "="
-                + CalendarAlerts.STATE_SCHEDULED, null /* whereArgs */);
-    }
-
-    public void setExact(int type, long triggerAtTime, PendingIntent operation) {
-        mAlarmManager.setExact(type, triggerAtTime, operation);
-    }
-
-    public void setExactAndAllowWhileIdle(int type, long triggerAtTime, PendingIntent operation) {
-        mAlarmManager.setExactAndAllowWhileIdle(type, triggerAtTime, operation);
-    }
-
-    public void cancel(PendingIntent operation) {
-        mAlarmManager.cancel(operation);
-    }
-
-    public void scheduleAlarm(long alarmTime) {
-        // Debug log for investigating dozing related bugs, remove it once we confirm it is stable.
-        if (Build.IS_DEBUGGABLE) {
-            Log.d(TAG, "schedule reminder alarm fired at " + alarmTime);
-        }
-        CalendarContract.CalendarAlerts.scheduleAlarm(mContext, mAlarmManager, alarmTime);
-    }
-
-    public void rescheduleMissedAlarms(ContentResolver cr) {
-        CalendarContract.CalendarAlerts.rescheduleMissedAlarms(cr, mContext, mAlarmManager);
-    }
-}
Index: packages/providers/CalendarProvider/res/values-in/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-in/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-in/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Penyimpanan Kalender"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Default"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Info kalender"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Kesalahan"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Tak ada kalender"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Acara: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Acara: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Tak disimpan: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalender"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Hapus sekarang"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Mulai"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Anda akan 1) membuat salinan dari basis data kalender ke kartu SD/penyimpanan USB yang mudah dibaca oleh semua apl, dan 2) mengirimkannya lewat email. Ingatlah untuk segera menghapusnya setelah Anda berhasil menyalin dari perangkat atau menerima emailnya."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Pilih program untuk mengirim file Anda"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Db Kalender terlampir"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Terlampir adalah basis data kalender saya beserta semua janji dan informasi pribadi. Harap tangani dengan benar."</string>
-    <string name="no_title_label">"(Tanpa judul)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-es/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-es/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-es/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Almacenamiento en el calendario"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Predeterminado"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Información de calendario"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Error"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"No hay calendarios."</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Eventos: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Eventos: <xliff:g id="EVENTS_0">%1$d</xliff:g>; no guardados: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Calendario"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Eliminar ahora"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Iniciar"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Vas a 1) hacer una copia de tu base de datos de calendario en la tarjeta SD o en el almacenamiento USB a la que puede acceder cualquier aplicación y a 2) enviarla por correo electrónico. Recuerda eliminarla en cuanto se haya copiado correctamente fuera del dispositivo o se haya recibido el mensaje."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Seleccionar un programa para enviar el archivo"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Base de datos de calendario adjunta"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Mi base de datos de calendario con todas mis citas y mi información personal va adjunta a este mensaje. Utiliza esta información con cuidado."</string>
-    <string name="no_title_label">"(Sin título)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-fr-rCA/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-fr-rCA/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-fr-rCA/strings.xml	(revision 168087)
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Stockage de l\'agenda"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Par défaut"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Infos Agenda"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Erreur"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Pas d\'agenda"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Événements : <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Événements :<xliff:g id="EVENTS_0">%1$d</xliff:g>, non sauvegardés :<xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Agenda"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Supprimer maintenant"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Démarrer"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Vous êtes sur le point de 1) copier la base de données de votre agenda sur la carte SD ou la mémoire de stockage USB, la rendant ainsi lisible par n\'importe quelle application, et 2) l\'envoyer par courriel. N\'oubliez pas de la supprimer une fois son transfert depuis l\'appareil terminé ou dès réception du courriel."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Choisissez un programme pour envoyer vos fichiers"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Base de données Agenda ci-jointe"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Veuillez trouver ci-joint la base de données de mon agenda contenant tous mes rendez-vous et informations personnelles. Merci de l\'utiliser avec précaution."</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-it/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-it/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-it/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Archiviazione calendario"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Predefinito"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Info calendario"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Errore"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Nessun calendario"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Eventi: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Eventi: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Non salvati: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Calendario"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Elimina adesso"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Inizia"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Stai per 1) creare una copia del database di calendario sulla scheda SD o sull\'archivio USB che è leggibile da qualsiasi applicazione e 2) inviare tale copia tramite email. Ricorda di eliminare la copia subito dopo aver effettuato la copia dal dispositivo o subito dopo la ricezione dell\'email."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Scegli un programma per inviare il file"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Db calendario allegato"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"In allegato è presente il mio database dell\'applicazione Calendario con tutti i miei appuntamenti e le mie informazioni personali. Trattare con cura."</string>
-    <string name="no_title_label">"(Senza titolo)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-iw/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-iw/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-iw/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"אחסון יומן"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"ברירת מחדל"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"פרטי יומן"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"שגיאה"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"אין יומנים"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"אירועים: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"אירועים: <xliff:g id="EVENTS_0">%1$d</xliff:g>, לא שמורים: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"יומן"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"מחק כעת"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"התחל"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"‏אתה עומד 1) ליצור עותק של מסד הנתונים של לוח השנה בכרטיס SD/התקן USB, הניתן לקריאה על ידי כל יישום ו-2) לשלוח אותו באימייל. זכור למחוק עותק זה מהמכשיר מיד לאחר שהעתקת אותו בהצלחה או לאחר שהאימייל התקבל."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"בחר תכנית לשליחת הקובץ"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"מצורף מסד נתונים של יומן"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"מצורף מסד הנתונים של לוח השנה שלי, עם כל הפגישות והמידע האישי שלי. שמור עליו היטב."</string>
-    <string name="no_title_label">"(אין כותרת)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-uk/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-uk/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-uk/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Пам\'ять календаря"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"За умовч."</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Інфо про календ."</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Помилка"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Немає календ."</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Події: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Події: <xliff:g id="EVENTS_0">%1$d</xliff:g>. Не збереж.: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Календар"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Видалити зараз"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Розпочати"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Ви збираєтеся 1) зробити копію бази даних свого календаря на карті SD або на носії USB, які можуть читатися будь-якою програмою, і 2) надіслати базу даних електронною поштою. Не забудьте видалити базу даних, коли скопіюєте її з пристрою або отримаєте електронним листом."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Виберіть програму для надсилання файлу"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Базу даних календаря вкладено"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"У вкладенні – база даних моєї програми Календар з усіма запланованими подіями й особистою інформацією. Обережно працюйте з нею."</string>
-    <string name="no_title_label">"(Без назви)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-fa/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-fa/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-fa/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"حافظه تقویم"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"پیش‌فرض"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"اطلاعات تقویم"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"خطا"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"تقویمی موجود نیست"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"رویدادها: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"رویدادها: <xliff:g id="EVENTS_0">%1$d</xliff:g>، ذخیره نشده: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"تقویم"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"اکنون حذف کنید"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"شروع"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"‏شما در حال 1) ایجاد یک کپی از پایگاه داده تقویم خود در کارت SD/حافظهٔ USB که توسط هر برنامه‌ای قابل خواندن است و 2) ایمیل کردن آن هستید. به خاطر داشته باشید که بلافاصله پس از کپی کردن آن از دستگاه یا دریافت ایمیل، آن را حذف کنید."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"یک برنامه را برای ارسال فایل خود انتخاب کنید"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"پایگاه داده تقویم پیوست شد"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"پایگاه داده تقویم من همراه با تمام قرارها و اطلاعات شخصی من پیوست شده است. از آن به دقت استفاده کنید."</string>
-    <string name="no_title_label">"(بدون عنوان)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-pa-rIN/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-pa-rIN/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-pa-rIN/strings.xml	(revision 168087)
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-<string name="calendar_storage">ਕੈਲੇਂਡਰ ਸਟੋਰੇਜ</string>
-<string name="calendar_default_name">ਡਿਫੌਲਟ</string>
-<string name="calendar_info">ਕੈਲੇਂਡਰ ਜਾਣਕਾਰੀ</string>
-<string name="calendar_info_error">"ਅਸ਼ੁੱਧੀ"</string>
-<string name="calendar_info_no_calendars">ਕੋਈ ਕਲੈਂਡਰ ਨਹੀਂ</string>
-<string name="calendar_info_events">"ਇਵੈਂਟਾਂ: <xliff:g id = "events">%1$d</xliff:g>"</string>
-<string name="calendar_info_events_dirty">"ਇਵੈਂਟਾਂ: <xliff:g id = "events">%1$d</xliff:g>, ਅਸੁਰੱਖਿਅਤ: <xliff:g id = "dirty events">%2$d</xliff:g>"</string>
-<string name="provider_label">"ਕੈਲੰਡਰ"</string>
-<string name="debug_tool_delete_button">ਹੁਣ ਮਿਟਾਓ</string>
-<string name="debug_tool_start_button">ਸ਼ੁਰੂ ਕਰੋ</string>
-<string name="debug_tool_message">ਤੁਸੀਂ ਇਹ ਕਰਨ ਵਾਲੇ ਹੋ 1) SD ਕਾਰਡ/USB ਸਟੋਰੇਜ ਤੇ ਤੁਹਾਡੇ ਕੈਲੰਡਰ ਡੇਟਾਬੇਸ ਦੀ ਕਾਪੀ ਬਣਾਉਣਾ, ਜੋ ਕਿਸੇ ਵੀ ਅਨੁਪ੍ਰਯੋਗ ਵੱਲੋਂ ਪੜ੍ਹਨਯੋਗ ਹੈ, ਅਤੇ 2) ਇਸਨੂੰ ਈਮੇਲ ਕਰਨਾ। ਜਿਵੇਂ ਹੀ ਤੁਸੀਂ ਇਸਨੂੰ ਸਫਲਤਾਪੂਰਵਕ ਕਾਪੀ ਕਰ ਲਓ ਜਾਂ ਈਮੇਲ ਪ੍ਰਾਪਤ ਹੋ ਜਾਵੇ, ਤਾਂ ਕਾਪੀ ਨੂੰ ਡਿਵਾਈਸ ਤੋਂ ਮਿਟਾਉਣਾ ਯਾਦ ਰੱਖੋ।</string>
-<string name="debug_tool_email_sender_picker">ਤੁਹਾਡੀ ਫਾਈਲ ਭੇਜਣ ਲਈ ਇੱਕ ਪ੍ਰੋਗਰਾਮ ਚੁਣੋ</string>
-<string name="debug_tool_email_subject">ਕੈਲੰਡਰ Db ਅਟੈਚ ਕੀਤਾ</string>
-<string name="debug_tool_email_body">ਅਟੈਚ ਕੀਤਾ ਮੇਰੀਆਂ ਸਾਰੀਆਂ ਨਿਰਧਾਰਿਤ ਮੁਲਾਕਾਤਾਂ ਅਤੇ ਨਿਜੀ ਜਾਣਕਾਰੀ ਵਾਲਾ ਮੇਰਾ ਕੈਲੰਡਰ ਡੇਟਾਬੇਸ ਹੈ। ਸਾਵਧਾਨੀ ਨਾਲ ਸੰਭਾਲੋ।</string>
-<string name="no_title_label">(ਕੋਈ ਸਿਰਲੇਖ ਨਹੀਂ)</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-pt-rPT/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-pt-rPT/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-pt-rPT/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Armazenamento do Calendário"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Predefinido"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Informação do calendário"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Erro"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Sem calendários"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Eventos: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Eventos: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Não guardados: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Calendário"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Eliminar agora"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Iniciar"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Está prestes a 1) fazer uma cópia da base de dados do calendário para o cartão SD/armazenamento USB que pode ser lida por qualquer aplicação e 2) a enviá-la por e-mail. Não se esqueça de a eliminar assim que a cópia a partir do aparelho tiver terminado ou tiver recebido o e-mail."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Escolha um programa para enviar o ficheiro"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Base de dados do calendário anexada"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Em anexo segue a base de dados do meu Calendário com todos os compromissos e informações pessoais. Utilize-a com cuidado."</string>
-    <string name="no_title_label">"(Sem título)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-bg/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-bg/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-bg/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Съхранение в Календар"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Основен"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Информация за календар"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Грешка"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Няма календари"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Събития: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Събития: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Незапазени: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Календар"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Изтриване сега"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Стартиране"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"На път сте 1) да направите копие на базата от данни на календара си в SD картата/USB хранилището, което може да се чете от всяко приложение, и 2) да го изпратите по имейл. Не забравяйте да го изтриете веднага след като го копирате успешно от устройството или когато имейлът е получен."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Изберете програма, за да изпратите файла си"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Базата от данни на календара е прикачена"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Прикачена Ви изпращам базата от данни на календара си, заедно с всички мои срещи и лична информация. Бъдете внимателни."</string>
-    <string name="no_title_label">"(Без заглавие)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-ta-rIN/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-ta-rIN/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-ta-rIN/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"கேலெண்டர் சேமிப்பகம்"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"இயல்பு"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"கேலெண்டர் தகவல்"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"பிழை"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"கேலெண்டர்கள் இல்லை"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"நிகழ்வுகள்: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"நிகழ்வுகள்: <xliff:g id="EVENTS_0">%1$d</xliff:g>, சேமிக்கப்படாதவை: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"கேலெண்டர்"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"இப்போது நீக்கு"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"தொடங்கு"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"பின்வருவதைச் செய்ய உள்ளீர்கள் 1) உங்கள் கேலெண்டர் தரவுத்தளத்தை, எந்தப் பயன்பாடும் படிக்கக்கூடிய SD கார்டு/USB சேமிப்பகத்தில் நகலெடுத்தல் மற்றும் 2) இதை மின்னஞ்சல் செய்தல். நீங்கள் இதைச் சாதனத்தில் வெற்றிகரமாக நகலெடுத்தப் பின்னர் அல்லது மின்னஞ்சலைப் பெற்ற பின்னர் விரைவாக நகலை நீக்குவதற்கு மறக்க வேண்டாம்."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"உங்கள் கோப்பை அனுப்ப நிரலைத் தேர்வுசெய்யவும்"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"கேலெண்டர் Db இணைக்கப்பட்டது"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"எனது எல்லா சந்திப்புகள் மற்றும் தனிப்பட்ட தகவல் அடங்கிய எனது கேலெண்டர் தரவுத்தளம் இணைக்கப்பட்டுள்ளது. அதைக் கவனமாக கையாளவும்."</string>
-    <string name="no_title_label">"(தலைப்பு இல்லை)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-ja/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-ja/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-ja/strings.xml	(revision 168087)
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"カレンダーの保存"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"既定"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"カレンダー情報"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"エラー"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"カレンダーがありません"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"予定: <xliff:g id="EVENTS">%1$d</xliff:g>件"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"予定: <xliff:g id="EVENTS_0">%1$d</xliff:g>、未保存: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"カレンダー"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"今すぐ削除"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"開始"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"1）任意のアプリで読み取れるSDカード/USBストレージにカレンダーデータベースをコピーし、2）メールで送信しようとしています。デバイスからコピーを終えたら、またはメールが受信されたらすぐに、忘れずに削除してください。"</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"ファイルを送信するプログラムを選択"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"カレンダー データベースを添付"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"添付されているのは、私のすべての予定と個人情報を含むカレンダーデータベースです。取り扱いにご注意ください。"</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-hy-rAM/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-hy-rAM/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-hy-rAM/strings.xml	(revision 168087)
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Օրացույցի պահուստ"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Լռելյայն"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Օրացույցի տեղեկություններ"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Սխալ"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Օրացույցներ չկան"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Իրադարձություններ՝ <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Իրադարձություններ՝ <xliff:g id="EVENTS_0">%1$d</xliff:g>, Չպահված՝ <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Օրացույց"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Ջնջել հիմա"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Մեկնարկել"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Դուք պատրաստվում եք 1) պատճենել ձեր օրացույցի տվյալների շտեմարանը SD քարտում/USB կրիչում, որն ընթեռնելի է ցանկացած հավելվածի կողմից և 2) էլփոստով ուղարկել այն: Հիշեք ջնջել պատճենը անմիջապես` սարքից պատճենումը հաջողությամբ ավարտելուց կամ էլփոստով ուղարկելուց հետո:"</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Ընտրեք ծրագիրը՝ ձեր ֆայլն ուղարկելու համար"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Օրացույցի ՏՇ-ն կցված է"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Հաղորդագրությանը կցված է իմ օրացույցի տվյալների շտեմարանը՝ բոլոր հանդիպումներով և անձնական տեղեկություններով: Վերաբերվեք խնամքով:"</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-fi/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-fi/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-fi/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Kalenterin tallennus"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Oletus"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Kalenteritiedot"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Virhe"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Ei kalentereita"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Tapahtumat: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Tapahtumia: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Tallentamatta: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalenteri"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Poista nyt"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Aloita"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Olet 1) tekemässä kopiota kalenteritietokannastasi SD-kortille/USB-tallennusvälineelle, joka on kaikkien sovelluksien luettavissa, ja 2) lähettämässä tietokantaa sähköpostitse. Muista poistaa tietokanta kopioituasi sen laitteelta tai saatuasi sähköpostin."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Valitse ohjelma tiedoston lähettämiseen"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Kalenterin vianetsintä liitteenä"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Liitteenä kalenteritietokantani, joka sisältää kaikki tapaamiseni ja henkilötietoni. Käsiteltävä varoen."</string>
-    <string name="no_title_label">"(Ei otsikkoa)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-te-rIN/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-te-rIN/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-te-rIN/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"క్యాలెండర్ నిల్వ"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"డిఫాల్ట్"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"క్యాలెండర్ సమాచారం"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"లోపం"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"క్యాలెండర్‌లు లేవు"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"ఈవెంట్‌లు: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"ఈవెంట్‌లు: <xliff:g id="EVENTS_0">%1$d</xliff:g>, సేవ్ చేయనివి: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"క్యాలెండర్"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"ఇప్పుడే తొలగించు"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"ప్రారంభించండి"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"మీరు 1) మీ క్యాలెండర్ డేటాబేస్ యొక్క కాపీని SD కార్డ్/USB నిల్వలో ఉంచుతున్నారు, దీన్ని ఎటువంటి అనువర్తనం ద్వారా అయినా చదవవచ్చు మరియు 2) దీన్ని ఇమెయిల్ చేస్తున్నారు. మీరు పరికరం నుండి విజయవంతంగా కాపీ చేసిన లేదా ఇమెయిల్‌ను స్వీకరించిన వెంటనే కాపీని తొలగించడం మర్చిపోవద్దు."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"మీ పైల్‌ను పంపడానికి ప్రోగ్రామ్‌ను ఎంచుకోండి"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"క్యాలెండర్ Db జోడించబడింది"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"జోడించిన జోడింపు నా అన్ని అపాయింట్‌మెంట్‌లను మరియు వ్యక్తిగత సమాచారాన్ని కలిగి ఉన్న నా క్యాలెండర్ డేటాబేస్. జాగ్రత్తగా వ్యవహరించండి."</string>
-    <string name="no_title_label">"(విషయం లేదు)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-nb/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-nb/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-nb/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Kalenderlagring"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Standard"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Kalenderinfo"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Feil"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Ingen kalendere"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Aktiviteter: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Hendelser: <xliff:g id="EVENTS_0">%1$d</xliff:g>, ulagrede: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalender"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Slett nå"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Start"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Du er i ferd med å 1) lage en kopi av kalenderdatabasen på SD-kortet eller USB-lagringen som kan leses av alle apper, og 2) sende den per e-post. Husk å slette den så snart du har kopiert den fra enheten, eller når e-posten er mottatt."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Velg et program for å sende filen"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Kalenderdatabase vedlagt"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Vedlagt er kalenderdatabasen min med alle avtalene mine og personlig informasjon. Vær forsiktig med opplysningene."</string>
-    <string name="no_title_label">"(Ingen tittel)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-zh-rCN/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-zh-rCN/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-zh-rCN/strings.xml	(revision 168087)
@@ -1,36 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"日历存储"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"默认日历"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"日历信息"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"错误"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"没有日历"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"活动：<xliff:g id="EVENTS">%1$d</xliff:g>项"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"活动数：<xliff:g id="EVENTS_0">%1$d</xliff:g>。未保存的活动数：<xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"日历"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"立即删除"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"开始"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"您需要执行以下操作：1) 在任意应用都可读取的 SD 卡/USB 存储设备中，创建日历数据库的副本；2) 通过电子邮件发送该副本。在成功从设备中复制该副本或开发者收到相关电子邮件后，请务必将该副本及时删除。"</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"选择用于发送文件的程序"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"日历调试工具已附加"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"附件是我的日历数据库，其中包含我的全部约会和个人信息，因此请谨慎处理。"</string>
-
-    <!-- SPRD: Add 20141231 of bug474826, vcalendar issue @{ -->
-    <string name="no_title_label">"（无标题）"</string>
-</resources>
Index: packages/providers/CalendarProvider/res/xml/syncadapter.xml
===================================================================
--- packages/providers/CalendarProvider/res/xml/syncadapter.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/xml/syncadapter.xml	(revision 168087)
@@ -1,26 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-/**
- * Copyright (c) 2009, The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
--->
-
-<!-- The attributes in this XML file provide configuration information -->
-<!-- for the SyncAdapter. -->
-
-<sync-adapter xmlns:android="http://schemas.android.com/apk/res/android"
-    android:contentAuthority="com.android.calendar"
-    android:accountType="com.google"
-/>
Index: packages/providers/CalendarProvider/res/values-ka-rGE/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-ka-rGE/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-ka-rGE/strings.xml	(revision 168087)
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"კალენდრის მეხსიერება"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"ნაგულისხმევი"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"კალენდრის ინფო"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"შეცდომა"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"კალენდრები არ არის"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"ღონისძიებები: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"ღონისძიებები: <xliff:g id="EVENTS_0">%1$d</xliff:g>, შესანახი: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"კალენდარი"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"წაიშალოს ახლა"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"დაწყება"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"რამდენიმე ნაბიჯიც და თქვენ 1) შექმნით კალენდრის ისეთ მონაცემთა ბაზას SD ბარათზე/USB მეხსიერებაში, რომელიც კითხვადი იქნება ნებისმიერი აპის მიერ და 2) ელფოსტით გააგზავნით მას. გახსოვდეთ, რომ წაშალოთ ასლი მაშინვე, როგორც კი მას წარმატებით ამოაკოპირებთ მოწყობილობიდან ან მიიღებთ ელფოსტით."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"თქვენი ფაილის გასაგზავნად პროგრამის შერჩევა"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"კალენდრის Db თან ერთვის"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"თან ერთვის ჩემი კალენდრის მონაცემთა ბაზა ყველა დანიშნული შეხვედრითა და პირადი ინფორმაციით. მოეკიდეთ სიფრთხილით."</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-fr/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-fr/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-fr/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Stockage de l\'agenda"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Par défaut"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Infos Agenda"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Erreur"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Aucun agenda"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Événements : <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Événements : <xliff:g id="EVENTS_0">%1$d</xliff:g> ; non sauvegardés : <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Agenda"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Supprimer maintenant"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Démarrer"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Vous êtes sur le point de 1) copier la base de données de votre agenda sur la carte SD ou la mémoire de stockage USB, la rendant ainsi lisible par n\'importe quelle application, et 2) l\'envoyer par e-mail. N\'oubliez pas de la supprimer une fois son transfert depuis l\'appareil terminé ou dès réception de l\'e-mail."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Sélectionnez un programme pour envoyer votre fichier"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Base de données Agenda ci-jointe"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Veuillez trouver ci-joint la base de données de mon agenda contenant tous mes rendez-vous et informations personnelles. Merci de l\'utiliser avec précaution."</string>
-    <string name="no_title_label">"(Sans titre)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-nl/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-nl/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-nl/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Agenda-opslag"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Standaard"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Agendagegevens"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Fout"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Geen agenda\'s"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Afspraken: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Afspraken: <xliff:g id="EVENTS_0">%1$d</xliff:g>, niet-opgeslagen: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Agenda"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Nu verwijderen"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Starten"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Je staat op het punt 1) een kopie van je agenda-database te maken op de SD-kaart/USB-opslag die kan worden gelezen via een app en 2) deze te e-mailen. Verwijder de kopie zodra je deze van het apparaat hebt gekopieerd of de e-mail is ontvangen."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Selecteer een programma om je bestand te verzenden"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Database voor Agenda bijgevoegd"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Bijgevoegd vindt u mijn Agenda-database met al mijn afspraken en persoonlijke gegevens. Gelieve hier zorgvuldig mee om te gaan."</string>
-    <string name="no_title_label">"(Geen titel)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/drawable-mdpi/app_icon.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/providers/CalendarProvider/res/values-vi/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-vi/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-vi/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Dung lượng Lịch"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Mặc định"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Thông tin lịch"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Lỗi"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Không có lịch."</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Sự kiện: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Sự kiện: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Chưa lưu: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Lịch"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Xóa ngay bây giờ"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Bắt đầu"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Bạn sắp 1) sao chép cơ sở dữ liệu lịch của mình vào thẻ SD/bộ nhớ USB mà bất kỳ ứng dụng nào cũng có thể đọc và 2) gửi email bản sao đó. Hãy nhớ xóa bản sao đó khỏi thiết bị ngay khi bạn đã sao chép thành công hoặc email đã được nhận."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Chọn chương trình để gửi tệp của bạn"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Lịch Db được đính kèm"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Phần đính kèm là cơ sở dữ liệu lịch của tôi với tất cả các cuộc hẹn và thông tin cá nhân. Hãy cẩn trọng khi xử lý."</string>
-    <string name="no_title_label">"(Không có tiêu đề)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-ro/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-ro/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-ro/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Stocarea calendarului"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Prestabilit"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Informaţii despre calendar"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Eroare"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Niciun calendar"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Evenimente: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Evenimente: <xliff:g id="EVENTS_0">%1$d</xliff:g>. Nesalvate: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Calendar"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Ștergeţi acum"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Începeţi"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Sunteţi pe cale 1) să faceţi o copie a bazei de date a calendarului dvs. pe cardul SD/stocarea USB, care poate fi citită de orice aplicaţie şi 2) să expediaţi această copie prin e-mail. Amintiţi-vă să ştergeţi copia bazei de date după ce aţi copiat-o de pe respectivul dispozitiv sau aţi primit e-mailul."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Alegeţi un program pentru a trimite fişierul"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Baza de date a calendarului a fost ataşată"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Vă trimit ataşată baza de date a calendarului, cu toate întâlnirile şi informaţiile mele personale. Vă rog să o gestionaţi cu atenţie."</string>
-    <string name="no_title_label">"(Fără titlu)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-ur-rPK/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-ur-rPK/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-ur-rPK/strings.xml	(revision 168087)
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-<string name="calendar_storage">کیلنڈر کا ذخیرہ</string>
-<string name="calendar_default_name">ڈیفالٹ </string>
-<string name="calendar_info">کیلنڈر کی معلومات</string>
-<string name="calendar_info_error">"خرابی"</string>
-<string name="calendar_info_no_calendars">کیلنڈرنھیں ھے</string>
-<string name="calendar_info_events">"پروگرام: <xliff:g id = "events">%1$d</xliff:g>"</string>
-<string name="calendar_info_events_dirty">"پروگرام: <xliff:g id = "events">%1$d</xliff:g>, غیر محفوظ کردہ: <xliff:g id = "dirty events">%2$d</xliff:g>"</string>
-<string name="provider_label">"کیلنڈر"</string>
-<string name="debug_tool_delete_button">"ابھی حذف کریں"</string>
-<string name="debug_tool_start_button">"شروع کریں"</string>
-<string name="debug_tool_message">آپ 1 کے بارے میں) اپنےکیلنڈرکےکوائف بیس کی ایک کاپیSD/USB ذخیرہ میں بنائیں،,  جوکسی ایپلی کیشن کی طرف سے پڑھنے کے قابل ہو، اور اور 2) اسے ای میل کریں.   یاد رکھیں آپ نے کامیابی سے اسے آلاسے کاپی کیا ہے یاجیسے ہی ای میل موصول ہوئی، نقل کو حذف کرنا یاد رکھیں.</string>
-<string name="debug_tool_email_sender_picker">"اپنی فائل بھیجنے کیلئے کوئی پروگرام منتخب کریں"</string>
-<string name="debug_tool_email_subject">کیلنڈر Db منسلک کردیا ہے</string>
-<string name="debug_tool_email_body">اپنے تمام تقرریوں اور ذاتی معلومات کے ساتھ اپنے کیلنڈرکوائف بیس منسلک ہے. احتیاط کے ساتھ سنبھال لینا.</string>
-<string name="no_title_label">(کوئی عنوان نہیں)</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-et-rEE/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-et-rEE/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-et-rEE/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Kalendri mälumaht"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Vaikimisi"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Kalendri teave"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Viga"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Kalendrid puuduvad"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Sündmused: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Sündmused: <xliff:g id="EVENTS_0">%1$d</xliff:g>, salvestamata: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalender"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Kustuta kohe"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Alusta"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Teete 1) koopiat oma kalendri andmebaasist SD-kaardile/USB-salvestusruumi, mida saavad lugeda kõik rakendused, ja 2) meilite selle. Kustutage koopia kindlasti pärast seadmelt kopeerimist või kui meil on kätte saadud."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Valige programm faili saatmiseks"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Kalendri Db on lisatud"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Lisatud on minu kalendri andmebaas koos kõigi kohtumiste ja isikliku teabega. Käsitlege neid ettevaatlikult."</string>
-    <string name="no_title_label">"(Pealkiri puudub)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-ca/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-ca/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-ca/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Emmagatzematge del calendari"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Predeterminat"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Informació del calendari"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Error"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"No hi ha cap calendari"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Esdeveniments: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Esdeveniments: <xliff:g id="EVENTS_0">%1$d</xliff:g>, no desats: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Calendari"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Suprimeix ara"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Inicia"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Estàs a punt de 1) fer una còpia de la base de dades del teu calendari a l\'emmagatzematge USB/targeta SD, llegible per qualsevol aplicació, i 2) d\'enviar-la per correu electrònic. Recorda suprimir-la tan bon punt l\'hagis copiat correctament al dispositiu o s\'hagi rebut el correu electrònic."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Selecciona un programa per enviar el fitxer"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Calendari Db adjunt"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"La base de dades del meu calendari amb totes les meves cites i informació personal es troba adjunta. Tracta-la amb cura."</string>
-    <string name="no_title_label">"(Sense títol)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-ru/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-ru/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-ru/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Память календаря"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"По умолчанию"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Сведения о календаре"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Ошибка"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Нет календарей"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Мероприятий: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Мероприятий: <xliff:g id="EVENTS_0">%1$d</xliff:g>; не сохранено: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Календарь"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Удалить сейчас"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Начать"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Вы собираетесь 1) скопировать базу данных календаря на SD-карту/USB-накопитель, которые доступны для чтения всем приложениям, и 2) отправить ее по электронной почте. Не забудьте удалить копию после того, как она будет перенесена с устройства или получена по электронной почте."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Выберите приложение"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"БД Календаря прилагается"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"К сообщению приложена база данных календаря со всеми встречами и личной информацией. Обращайтесь с ней осторожно."</string>
-    <string name="no_title_label">"(Нет заголовка)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-ce/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-ce/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-ce/strings.xml	(revision 168087)
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-<string name="calendar_storage">Imbakan sa kalendaryo</string>
-<string name="calendar_default_name">Default</string>
-<string name="calendar_info">Impormasyon sa kalendaryo</string>
-<string name="calendar_info_error">"Sayop"</string>
-<string name="calendar_info_no_calendars">"Walay mga kalendaryo"</string>
-<string name="calendar_info_events">Mga panghitabo: <xliff:g id = "events">%1$d</xliff:g></string>
-<string name="calendar_info_events_dirty">Mga panghitabo: <xliff:g id = "events">%1$d</xliff:g>, Wala nasave: <xliff:g id = "dirty events">%2$d</xliff:g></string>
-<string name="provider_label">"kalendaryo"</string>
-<string name="debug_tool_delete_button">I-delete karon</string>
-<string name="debug_tool_start_button">sugod</string>
-<string name="debug_tool_message">"Ikaw kay hapit na 1) maghimo ug kopya sa imong kalendaryo nga imbakan ngadto sa SD kard/USB imbakan, nga mabasa lamang pinaagi sa bisag unsa nga app, ug 2) magemail ani. Ayaw kalimti sa pagpanas sa kopya pagkahuman nimo nga malapuson sa pagkopya sa debays o ang email kay nadawat."</string>
-<string name="debug_tool_email_sender_picker">"Pili ug programa sa pagpadala sa imong payl"</string>
-<string name="debug_tool_email_subject">Db sa Kalendaryo nauban</string>
-<string name="debug_tool_email_body">"Naglakip ang akong Kalendaryo nga imbakan kauban sa akong mga pakigkita ug personal nga impormasyon. Ampingi pagdala."</string>
-<string name="no_title_label">"(Walay titulo)"</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-en-rAU/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-en-rAU/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-en-rAU/strings.xml	(revision 168087)
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Calendar Storage"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Default"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Calendar info"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Error"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"No calendars"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Events: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Events: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Unsaved: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Calendar"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Delete now"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Start"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"You are about to 1) make a copy of your calendar database to the SD card/USB storage, which is readable by any app, and 2) email it. Remember to delete the copy as soon as you have successfully copied it off the device or the email is received."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Select a programme to send your file"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Calendar Db attached"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Attached is my calendar database with all my appointments and personal information. Please handle with care."</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-en-rIN/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-en-rIN/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-en-rIN/strings.xml	(revision 168087)
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Calendar Storage"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Default"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Calendar info"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Error"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"No calendars"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Events: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Events: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Unsaved: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Calendar"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Delete now"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Start"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"You are about to 1) make a copy of your calendar database to the SD card/USB storage, which is readable by any app, and 2) email it. Remember to delete the copy as soon as you have successfully copied it off the device or the email is received."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Select a programme to send your file"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Calendar Db attached"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Attached is my calendar database with all my appointments and personal information. Please handle with care."</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-km-rKH/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-km-rKH/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-km-rKH/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"ឧបករណ៍​ផ្ទុក​ប្រតិទិន"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"លំនាំដើម"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"ព័ត៌មាន​ប្រតិទិន"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"កំហុស"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"មិន​មាន​ប្រតិទិន"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"ព្រឹត្តិការណ៍៖ <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"ព្រឹត្តិការណ៍៖ <xliff:g id="EVENTS_0">%1$d</xliff:g>, មិន​បាន​រក្សាទុក៖ <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"ប្រតិទិន"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"លុប​ឥឡូវ"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"ចាប់ផ្ដើម"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"អ្នក​ហៀបនឹង ១) ចម្លង​មូលដ្ឋាន​ទិន្នន័យ​ប្រតិទិន​របស់​អ្នក​ទៅកាន់​កាត​អេសឌី/ឧបករណ៍​ផ្ទុក​យូអេសប៊ី​ដែល​អាច​អាន​បាន​ដោយ​កម្មវិធី​ណាមួយ ២) ផ្ញើ​អ៊ីមែល​វា។ ចងចាំ​ថា​អ្នក​ត្រូវ​លុប​ច្បាប់​ចម្លង​ភ្លាមៗ បន្ទាប់ពី​បាន​ចម្លង​ចេញពី​ឧបករណ៍ ឬ​បាន​ទទួល​អ៊ីមែល។"</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"ជ្រើស​កម្មវិធី​ដើម្បី​ផ្ញើ​ឯកសារ​របស់​អ្នក"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"បាន​ភ្ជាប់​មូលដ្ឋាន​ទិន្នន័យ​ប្រតិទិន"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"ឯកសារ​ភ្ជាប់​គឺជា​មូលដ្ឋាន​ទិន្នន័យ​ប្រតិទិន​ជាមួយ​ការ​ណាត់​ជួប​ទាំងអស់ និង​ព័ត៌មាន​ផ្ទាល់ខ្លួន​របស់​ខ្ញុំ។ ប្រើ​ដោយ​ប្រុងប្រយ័ត្ន។"</string>
-    <string name="no_title_label">"(គ្មាន​ចំណងជើង)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/drawable-xhdpi/app_icon.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/providers/CalendarProvider/res/values-ml-rIN/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-ml-rIN/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-ml-rIN/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"കലണ്ടർ സംഭരണം"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"സ്ഥിരമായത്"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"കലണ്ടർ വിവരങ്ങൾ"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"പിശക്"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"കലണ്ടറുകളൊന്നുമില്ല"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"ഇവന്റുകൾ: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"ഇവന്റുകൾ: <xliff:g id="EVENTS_0">%1$d</xliff:g>, സംരക്ഷിക്കാത്തവ: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"കലണ്ടർ"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"ഇപ്പോൾ ഇല്ലാതാക്കുക"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"ആരംഭിക്കുക"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"നിങ്ങൾ ഇവ ചെയ്യാൻ പോകുന്നു 1) ഏതൊരു അപ്ലിക്കേഷനും വായനാപ്രദമായരീതിയിൽ, SD കാർഡ്/USB സംഭരണി എന്നിവയിൽ നിങ്ങളുടെ കലണ്ടർ ഡാറ്റാബേസിന്റെ ഒരു പകർപ്പെടുക്കുക, തുടർന്ന് 2) അത് ഇമെയിൽ ചെയ്യുക. ഉപകരണത്തിൽ നിന്ന് അത് പകർത്തുകയോ ഇമെയിൽ ലഭിക്കുകയോ ചെയ്‌തുകഴിഞ്ഞാൽ ഉടൻ തന്നെ പകർപ്പ് ഇല്ലാതാക്കാൻ ഓർമ്മിക്കുക."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"നിങ്ങളുടെ ഫയൽ അയയ്‌ക്കുന്നതിന് ഒരു പ്രോഗ്രാം തിരഞ്ഞെടുക്കുക"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"കലണ്ടർ Db അറ്റാച്ചുചെയ്തിരിക്കുന്നു"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"അറ്റാച്ചുചെയ്തിരിക്കുന്നത് എന്റെ എല്ലാ കൂടിക്കാഴ്ചകളും വ്യക്തിഗത വിവരങ്ങളും അടങ്ങിയ കലണ്ടർ ഡാറ്റാബേസ് ആണ്. സൂക്ഷിച്ച് കൈകാര്യം ചെയ്യുക."</string>
-    <string name="no_title_label">"(ശീര്‍ഷകമില്ല)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-mk-rMK/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-mk-rMK/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-mk-rMK/strings.xml	(revision 168087)
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-<string name="calendar_storage">Меморија на календар</string>
-<string name="calendar_default_name">Стандардни опции</string>
-<string name="calendar_info">Информации за календарот</string>
-<string name="calendar_info_error">Грешка</string>
-<string name="calendar_info_no_calendars">Нема календари</string>
-<string name="calendar_info_events">Настани: <xliff:g id = "events">%1$d</xliff:g></string>
-<string name="calendar_info_events_dirty">Настани: <xliff:g id = "events">%1$d</xliff:g>, Незачувани: <xliff:g id = "dirty events">%2$d</xliff:g></string>
-<string name="provider_label">Календар</string>
-<string name="debug_tool_delete_button">Избришете сега</string>
-<string name="debug_tool_start_button">Старт</string>
-<string name="debug_tool_message">Вие сте на прагот да 1) направите копија од базата на податоци од вашиот календар на вашата SD картичка/ USB меморија, која може да биде прочитана од која било апликација и 2) да ја пратите по електронска пошта. Запомнете да ја избришете копијата веднаш штом успешно сте ја копирале од уредот или веднаш штом електронската пошта е примена.</string>
-<string name="debug_tool_email_sender_picker">Изберете програма со која ќе ја испратите папката</string>
-<string name="debug_tool_email_subject">Прикачена е базата на податоци на календарот</string>
-<string name="debug_tool_email_body">Базата на податоци на мојот календар со моите состаноци и лични информации е прикачена. Однесувајте се грижливо со неа.</string>
-<string name="no_title_label">(Нема наслов)</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-es-rES/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-es-rES/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-es-rES/strings.xml	(revision 168087)
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-<string name="calendar_storage">"Almacenamiento de calendario"</string>
-<string name="calendar_default_name">"Predeterminado"</string>
-<string name="calendar_info">"Información de calendario"</string>
-<string name="calendar_info_error">"Error"</string>
-<string name="calendar_info_no_calendars">"No hay calendarios"</string>
-<string name="calendar_info_events">"Eventos: <xliff:g id = "events">%1$d</xliff:g>"</string>
-<string name="calendar_info_events_dirty">"Eventos: <xliff:g id = "events">%1$d</xliff:g>,Sin guardar: <xliff:g id = "dirty events">%2$d</xliff:g>"</string>
-<string name="provider_label">"Calendario"</string>
-<string name="debug_tool_delete_button">"Eliminar ahora"</string>
-<string name="debug_tool_start_button">"Iniciar"</string>
-<string name="debug_tool_message">"Está a punto de 1) hacer una copia de su base de datos de calendario en la tarjeta SD o en el almacenamiento USB, que puede leerse desde cualquier aplicación y 2) enviarla por correo. Recuerde que debe eliminarla inmediatamente después de haberla copiado con éxito del dispositivo o de haber recibido el correo electrónico."</string>
-<string name="debug_tool_email_sender_picker">"Elija un programa para enviar el archivo."</string>
-<string name="debug_tool_email_subject">"Base de datos de calendario adjunta"</string>
-<string name="debug_tool_email_body">"Adjunto está mi base de datos de calendario con todas mis citas y mi información personal. Tratar con cuidado."</string>
-<string name="no_title_label">"(Sin título)"</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-zu/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-zu/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-zu/strings.xml	(revision 168087)
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Isitoreji sekhalenda"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Okuzenzakalelayo"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Ulwazi lekhalenda"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Iphutha"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Awekho amakhalenda"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Izenzakalo: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Imicimbi:<xliff:g id="EVENTS_0">%1$d</xliff:g>, Okungagciniwe:<xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Ikhalenda"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Susa manje"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Qala"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Usuzo 1) kwenza ikhophi yemininingo egciniwe yekhalenda esilondweni se-sd/usb eqashelwa yinoma iluphi uhlelo bese 2) uyayi-imeyila. Khumbula ukulisusa ngokushesha ngemva kokulikopisha ngokuphumelelayo edivayisini noma uma i-imeyili isitholiwe."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Khetha uhlelo ozothumela kulo ifayela yakho"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"i-Db yekhalenda inamathelisiwe"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Okunamathelisiwe iminingo egciniwe yekhalenda lami enawo wonke ama-aphoyintimenti ami nokwazisa komuntu siqu. Ngicela uphathe ngokukhathalela."</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-eu-rES/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-eu-rES/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-eu-rES/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Egutegian biltegiratzea"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Lehenetsia"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Egutegiaren informazioa"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Errorea"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Ez dago egutegirik"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Gertaerak: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Gertaerak: <xliff:g id="EVENTS_0">%1$d</xliff:g>. Gorde gabe: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Egutegia"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Ezabatu"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Hasi"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Orain 1) egutegiaren datu-basearen kopia bat egingo duzu SD txartelean edo USB memorian, aplikazioek irakur dezaketena, eta 2) posta elektronikoz bidaliko duzu. Kopia gailutik kanpo kopiatu ostean edo hartzaileak kopiaren mezua jaso ostean, ezabatu zure kopia."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Aukeratu fitxategia bidaltzeko erabili nahi duzun programa"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Google Calendar-eko datu-basea erantsita"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Erantsita doakizu nire Google Calendar zerbitzuko datu-basea, hitzordu eta datu pertsonal guztiekin. Erabili kontu handiz."</string>
-    <string name="no_title_label">(Izenbururik ez)</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values/strings.xml	(revision 168087)
@@ -1,63 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-
-    <!-- Title for the Calendar Storage process. -->
-    <string name="calendar_storage">Calendar Storage</string>
-
-    <!-- Temporary Calendar name to use before we have the calendar name from the server -->
-    <string name="calendar_default_name">Default</string>
-
-    <!-- Caption on secret calendar info -->
-    <string name="calendar_info">Calendar info</string>
-
-    <!-- Error message for secret calendar info -->
-    <string name="calendar_info_error">Error</string>
-
-    <!-- No calendars message for secret calendar info -->
-    <string name="calendar_info_no_calendars">No calendars</string>
-
-    <!-- Event count message for secret calendar info -->
-    <string name="calendar_info_events">Events: <xliff:g id = "events">%1$d</xliff:g></string>
-
-    <!-- Event and dirty event count message for secret calendar info -->
-    <string name="calendar_info_events_dirty">Events: <xliff:g id = "events">%1$d</xliff:g>, Unsaved: <xliff:g id = "dirty events">%2$d</xliff:g></string>
-
-    <!-- What to show in messaging that refers to this provider, e.g. AccountSyncSettings -->
-    <string name="provider_label">Calendar</string>
-
-    <!-- Debug tool - dialog - delete file now [CHAR LIMIT=NONE] -->
-    <string name="debug_tool_delete_button">Delete now</string>
-
-    <!-- Debug tool - dialog - start copying [CHAR LIMIT=NONE] -->
-    <string name="debug_tool_start_button">Start</string>
-    
-    <!-- Debug tool - Main message shown to the user when starting up the debug tool [CHAR LIMIT=NONE] -->
-    <string name="debug_tool_message">You are about to 1) make a copy of your calendar database to the SD card/USB storage, which is readable by any app, and 2) email it. Remember to delete the copy as soon as you have successfully copied it off the device or the email is received.</string>
-
-    <!-- Debug tool - email subject [CHAR LIMIT=NONE] -->
-    <string name="debug_tool_email_sender_picker">Choose a program to send your file</string>
-
-    <!-- Debug tool - email subject [CHAR LIMIT=NONE] -->
-    <string name="debug_tool_email_subject">Calendar Db attached</string>
-
-    <!-- Debug tool - email body [CHAR LIMIT=NONE] -->
-    <string name="debug_tool_email_body">Attached is my Calendar database with all my appointments and personal information. Handle with care.</string>
-
-    <!-- SPRD: Add 20141231 of bug474826, vcalendar issue @{ -->
-    <string name="no_title_label">(No title)</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-zh-rHK/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-zh-rHK/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-zh-rHK/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"日曆儲存空間"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"預設"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"日曆資訊"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"錯誤"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"沒有日曆"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"活動數：<xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"活動數：<xliff:g id="EVENTS_0">%1$d</xliff:g>；未儲存活動數：<xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"日曆"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"立即刪除"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"開始"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"您即將 1) 在 SD 記憶卡或 USB 儲存裝置中儲存任何應用程式均可讀取的日曆資料庫副本，並且 2) 以電郵傳送日曆資料庫。請緊記，待成功從裝置複製日曆資料庫或收到電郵後，請隨即刪除日曆資料庫。"</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"選擇要傳送檔案的程式"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"內含日曆偵錯附件"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"附上我的日曆資料庫，其中包含我所有的約會和個人資料，請謹慎處理。"</string>
-    <string name="no_title_label">"(無標題)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-az-rAZ/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-az-rAZ/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-az-rAZ/strings.xml	(revision 168087)
@@ -1,34 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Təqvim Yaddaşı"</string>
-    <string name="upgrade_msg" msgid="2792831029435070926">"Təqvim bazası təkmilləşdirilir."</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Defolt"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Təqvim məlumatı"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Xəta"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Təqvim yoxdur"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Tədbirlər: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Tədbirlər: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Yadda saxlanılmamış: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Təqvim"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"İndi sil"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Başlat"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Siz 1) hər hansı bir tədbiq tərəfindən oxuna bilən təqvim bazasının nüsxəsini SD karta/USB yaddaşa çıxartmaq və 2) onu e-poçtla göndərmək üzrəsiniz. Cihazdan kopyaladıqdan və ya e-poçtu aldıqdan sonra nüsxəni silməyi unutmayın."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Faylınızı göndərmək üçün proqram seçin"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Təqvim Db qoşulub"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Qoşmada bütün görüşlərim və şəxsi məlumatlarımla birlikdə mənim Təqvim bazam var. Diqqətli olun."</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-mn-rMN/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-mn-rMN/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-mn-rMN/strings.xml	(revision 168087)
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Календарийн сан"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Үндсэн"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Календарийн мэдээлэл"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Алдаа"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Календарь байхгүй"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Үйл явдал: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Үйл явдал: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Хадгалагдаагүй: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Календарь"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Одоо устгах"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Эхлэх"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Та 1) дурын апп-с уншиж болох SD карт/USB сан руу өөрийн календарийн өгөгдлийг хуулах 2) имэйлээр илгээх гэж байна. Төхөөрөмжөөс амжилттай хуулж авсан, эсхүл имэйлээ хүлээж авсны дараа хуулбарыг устгахаа мартуузай."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Өөрийн файлыг илгээх програмыг сонгоно уу"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Календарийн Db хавсрагдсан"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Хавсралтанд миний бүх уулзалт, хувийн мэдээллийг агуулсан Календарийн өгөгдөл байгаа. Болгоомжтой хандана уу."</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-mr-rIN/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-mr-rIN/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-mr-rIN/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"कॅलेंडर संचयन"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"डीफॉल्ट"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"कॅलेंडर माहिती"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"त्रुटी"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"कोणतेही कॅलेंडर नाहीत"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"इव्हेंट: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"इव्हेंट: <xliff:g id="EVENTS_0">%1$d</xliff:g>, जतन न केलेले: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"कॅलेंडर"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"आता हटवा"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"प्रारंभ"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"आपण 1) SD कार्ड/USB संचयनासाठी आपल्या कॅलेंडर डेटाबेसची एक प्रत बनवणार आहात, जी कोणत्याही अॅपद्वारे वाचनीय असते आणि 2) ती मेल करणार आहात. आपण प्रत डिव्हाइसवरून यशस्वीरित्या कॉपी केल्यावर किंवा ईमेल प्राप्त केल्यावर लगेच ती हटविण्याचे लक्षात ठेवा."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"आपली फाईल पाठविण्‍यासाठी एक प्रोग्राम निवडा"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"कॅलेंडर डेटाबेस संलग्न"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"सर्व माझ्या नियोजित भेटी असलेला आणि वैयक्तिक माहिती असलेला माझा कॅलेंडर डेटाबेस संलग्न केलेला आहे. काळजीपूर्वक हाताळणी करा."</string>
-    <string name="no_title_label">"(शीर्षक नाही)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-cs/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-cs/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-cs/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Úložiště Kalendáře"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Výchozí"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Informace o kalendáři"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Chyba"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Žádné kalendáře"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Události: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Události: <xliff:g id="EVENTS_0">%1$d</xliff:g>, neuložené: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalendář"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Smazat"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Spustit"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Chystáte se 1) vytvořit na kartě SD nebo v úložišti USB kopii databáze kalendáře, která bude čitelná pomocí libovolné aplikace, a 2) poslat ji e-mailem. Po úspěšném zkopírování ze zařízení nebo přijetí e-mailu ji nezapomeňte ihned smazat."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Vyberte program pro odeslání souboru"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Přiložena je databáze Kalendáře"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Přiložena je databáze Kalendáře se všemi mými schůzkami a osobními informacemi. Zacházejte s ní prosím opatrně."</string>
-    <string name="no_title_label">"(bez názvu)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/drawable-hdpi/app_icon.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/providers/CalendarProvider/res/values-is-rIS/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-is-rIS/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-is-rIS/strings.xml	(revision 168087)
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Dagatalsgeymsla"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Sjálfgefið"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Upplýsingar um dagatal"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Villa"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Engin dagatöl"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Viðburðir: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Viðburðir: <xliff:g id="EVENTS_0">%1$d</xliff:g>, óvistaðir: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Dagatal"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Eyða núna"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Byrja"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Þú ert að fara að 1) afrita gagnagrunn dagatalsins þíns yfir á minniskort/USB-drif sem hvaða forrit sem er getur lesið og 2) senda hann með tölvupósti. Mundu að eyða afritinu um leið og þú hefur afritað það úr tækinu eða þegar tölvupósturinn hefur verið móttekinn."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Veldu forrit til að senda skrána"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Gagnagrunnur dagatals hengdur við"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Meðfylgjandi er gagnagrunnur dagatalsins míns sem inniheldur upplýsingar um alla fundina mína og persónulegar upplýsingar. Sýndu aðgát."</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-pt-rBR/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-pt-rBR/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-pt-rBR/strings.xml	(revision 168087)
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-<string name="calendar_storage">"Guarda de Calendário"</string>
-<string name="calendar_default_name">"Padrão"</string>
-<string name="calendar_info">"Info de calendário"</string>
-<string name="calendar_info_error">"Erro"</string>
-<string name="calendar_info_no_calendars">"Nenhum calendário"</string>
-<string name="calendar_info_events">"Eventos: <xliff:g id = "events">%1$d</xliff:g>"</string>
-<string name="calendar_info_events_dirty">"Eventos: <xliff:g id = "eventos">%1$d</xliff:g>, Não guardado: <xliff:g id ="obscenos eventos">%2$d</xliff:g>"</string>
-<string name="provider_label">"Agenda"</string>
-<string name="debug_tool_delete_button">"Excluir agora"</string>
-<string name="debug_tool_start_button">"Iniciar"</string>
-<string name="debug_tool_message">"Você é sobre para 1) fazer uma cópia de dados de base do seu calendário para o SD cartão/USB guarda, que é legível por qualquer aplicação, e 2) email-o. Lembrar a deletar a cópia assim que você tenha com sucesso copiado fora de aparelho ou o email é recebido."</string>
-<string name="debug_tool_email_sender_picker">"Escolha um programa para enviar o arquivo"</string>
-<string name="debug_tool_email_subject">"Db de calendário anexado"</string>
-<string name="debug_tool_email_body">"Anexado é database do meu Calendário com todos os meus compromissos e informação pessoal. Trate-o com cuidado."</string>
-<string name="no_title_label">"(Sem título)"</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-ko/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-ko/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-ko/strings.xml	(revision 168087)
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"캘린더 저장"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"기본값"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"캘린더 정보"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"오류"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"캘린더 없음"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"일정: <xliff:g id="EVENTS">%1$d</xliff:g>개"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"일정: <xliff:g id="EVENTS_0">%1$d</xliff:g>개, 저장되지 않은 일정: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>개"</string>
-    <string name="provider_label" msgid="2306513350843464739">"캘린더"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"지금 삭제"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"시작"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"모든 앱에서 읽을 수 있는 SD 카드/USB 저장소에 캘린더 데이터베이스의 1) 사본을 만들고 2) 이메일로 보내려고 합니다. 기기 이외의 장소에 사본을 만들거나 사본의 이메일 수신이 완료된 후에는 해당 사본을 즉시 삭제하시기 바랍니다."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"파일을 전송할 프로그램을 선택하세요."</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"캘린더 DB 첨부"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"모든 일정이 담긴 캘린더 데이터베이스와 개인 정보가 첨부되어 있습니다. 신중하게 처리해 주세요."</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-sk/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-sk/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-sk/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Úložisko kalendára"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Predvolené"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Informácie o kalendári"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Chyba"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Žiadne kalendáre"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Udalosti: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Udalosti: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Neuložené: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalendár"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Odstrániť"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Spustiť"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Chystáte sa 1) vytvoriť na karte SD alebo v úložisku USB kópiu databázy kalendára, ktorá bude čitateľná pre všetky aplikácie a 2) poslať ju e-mailom. Po skopírovaní zo zariadenia alebo prijatí e-mailom ju nezabudnite ihneď odstrániť."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Vyberte program na odoslanie súboru"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Pripojený ladiaci nástroj Kalendára"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"V prílohe je moja databáza kalendára so všetkými stretnutiami a osobnými informáciami. Zaobchádzajte s ňou opatrne."</string>
-    <string name="no_title_label">"(Bez názvu)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-sl/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-sl/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-sl/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Pomnilnik koledarja"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Privzeto"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Podatki o koledarju"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Napaka"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Ni koledarjev"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Dogodki: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Dogodki: <xliff:g id="EVENTS_0">%1$d</xliff:g>, neshranjeno: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Koledar"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Izbriši"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Začetek"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"1) Na kartico SD/disk USB boste kopirali zbirko podatkov koledarja, ki jo bo lahko bral vsak program, in 2) jo poslali po e-pošti. Ne pozabite je izbrisati, takoj ko jo uspešno kopirate iz naprave ali dobite e-pošto."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Izberite program, s katerim želite poslati datoteko"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Zb. podatkov koledarja priložena"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Pripeta je zbirka podatkov koledarja z vsemi mojimi sestanki in osebnimi podatki. Z njo ravnajte previdno."</string>
-    <string name="no_title_label">"(Brez naslova)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-es-rUS/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-es-rUS/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-es-rUS/strings.xml	(revision 168087)
@@ -1,34 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="no_title_label">"(Sin título)"</string>
-    <string name="calendar_storage" msgid="5387668002987562770">"Almacenamiento de calendario"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Predeterminado"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Información de calendario"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Error"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"No hay calendarios"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Eventos: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Eventos: <xliff:g id="EVENTS_0">%1$d</xliff:g>. No guardados: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Calendario"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Eliminar ahora"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Iniciar"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Estás a punto de 1) hacer una copia de tu base de datos de calendario en la tarjeta SD o en el almacenamiento USB, que puede leerse desde cualquier aplicación y 2) enviarla por correo. Recuerda que debes eliminarla inmediatamente después de haberla copiado con éxito del dispositivo o de haber recibido el correo."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Elige un programa para enviar el archivo."</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Base de datos de calendario adjunta"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Adjunto mi base de datos de calendario con todas mis citas y mi información personal. Tratar con cuidado."</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-my-rMM/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-my-rMM/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-my-rMM/strings.xml	(revision 168087)
@@ -1,34 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"ပြက္ခဒိန် သိုလှောင်ရန်"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"ပုံသေ"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"ပြက္ခဒိန် အင်ဖို"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"အမှား"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"ပြက္ခဒိန်များ မရှိ"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"ဖြစ်ရပ်များ: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"ဖြစ်ရပ်များ: <xliff:g id="EVENTS_0">%1$d</xliff:g>၊ Unsaved: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"ပြက္ခဒိန်"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"ယခု ဖျက်ပါ"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"စတင်ရန်"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"သင်သည် ၁) သင်၏ ပြက္ခဒိန် ဒေတာဘေ့စ်ကို SD ကဒ်/USB သိုလှောင်ခန်းသို့ ကူးယူတော့မည်၊  ၎င်းကို မည်သည့် app မဆို ဖတ်နိုင်သည်၊ ပြီးတော့ ၂) ၎င်းကို အီးမေးလ် ပို့နိုင်သည်။ ၎င်းကို သင်သည် ကိရိယာ အပြင်မှာ ကူးယူလိုက်သည် သို့မဟုတ် အီးမေးလ်ကို ရရှိလိုက်သည်နှင့် ကော်ပီကို ဖျက်ပစ်ရန် မမေ့ပါနှင့်။"</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"သင့်ဖိုင်ကို ပို့ရန် ပရိုဂရမ် ရွေးပါ"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"ပြက္ခဒိန် Db ပူးတွဲထား"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"ပူးတွဲချက်မှာ ကျွန်ုပ်၏ ရက်ချိန်းများ နှင့် ကိုယ်ရေး အချက်အလက်များ အားလုံး ပါဝင်သည့် ကျွန်ုပ်၏ ပြက္ခဒိန် ဒေတာဘေ့စ် ဖြစ်သည်။ သတိထား ကိုင်တွယ်ပါ။"</string>
-    <string name="no_title_label">"(ေခါင္းစဥ္မပါ)"</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-ms-rMY/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-ms-rMY/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-ms-rMY/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Storan Kalendar"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Lalai"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Maklumat kalendar"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Ralat"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Tiada kalendar"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Acara: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Acara: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Tidak disimpan: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalendar"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Padam sekarang"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Mula"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Anda akan 1) membuat salinan pangkalan data kalendar anda ke kad SD/storan USB yang boleh dibaca oleh sebarang apl dan 2) menghantarnya melalui e-mel. Jangan lupa untuk memadamkan salinan itu sebaik sahaja anda berjaya menyalinnya dari peranti atau selepas e-mel diterima."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Pilih program untuk menghantar fail anda"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Db Kalendar dilampirkan"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Dilampirkan pangkalan data Kalendar saya dengan semua janji temu dan maklumat peribadi. Sila gunakan dengan cermat."</string>
-    <string name="no_title_label">"(Tiada tajuk)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-da/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-da/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-da/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Kalenderlagring"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Standard"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Kalenderoplysninger"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Fejl"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Der er ingen kalendere"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Begivenheder: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Begivenheder: <xliff:g id="EVENTS_0">%1$d</xliff:g>, ikke gemte: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalender"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Slet nu"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Start"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Du er ved at 1) lave en kopi af din kalenderdatabase til SD-kortet/USB-lageret, som kan læses af alle apps og 2) sende den via e-mail. Husk at slette den, så snart du har kopieret den fra enheden, eller e-mailen er modtaget."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Vælg et program, for at sende din fil"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Kalender Db er vedlagt"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Min kalenderdatabase med alle mine aftaler og personlige oplysninger er vedhæftet. Brug den med omhu."</string>
-    <string name="no_title_label">"(Ingen titel)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-sr/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-sr/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-sr/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Складиштење календара"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Подразумевано"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Информације о календару"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Грешка"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Нема календара"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Догађаји: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Догађаји: <xliff:g id="EVENTS_0">%1$d</xliff:g>, несачувани: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Календар"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Избриши сада"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Започни"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Овим ћете 1) направити копију базе података календара на SD картици/USB меморији коју свака апликација може да прочита и 2) послаћете је имејлом. Обавезно избришите копију одмах након копирања на уређај или пријема имејла."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Изаберите програм за слање датотеке"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Приложена је алатка за уклањање грешака у Календару"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"У прилогу се налази база података мог календара са свим заказаним обавезама и личним подацима. Поступајте пажљиво."</string>
-    <string name="no_title_label">"(Без наслова)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-ha/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-ha/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-ha/strings.xml	(revision 168087)
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-<string name="calendar_storage">"Ma\'ajiyar kalanda"</string>
-<string name="calendar_default_name">na asali</string>
-<string name="calendar_info">"Labarin kalanda"</string>
-<string name="calendar_info_error">"Kuskure"</string>
-<string name="calendar_info_no_calendars">"Babu kalandoji"</string>
-<string name="calendar_info_events">"Sha\'ani: <xliff:g id = "events">%1$d</xliff:g>"</string>
-<string name="calendar_info_events_dirty">"Sha\'ani: <xliff:g id = "events">%1$d</xliff:g>, wanda ba a ajiye ba: <xliff:g id = "dirty events">%2$d</xliff:g>"</string>
-<string name="provider_label">"kalanda"</string>
-<string name="debug_tool_delete_button">"Share yanzu"</string>
-<string name="debug_tool_start_button">"Fara"</string>
-<string name="debug_tool_message">"Kana gab da 1) kwafar rumbun kalandarka zuwa ma\'adanar katin SD/USB, wadda kowane shiri kan iya karantawa, sannan kuma 2) ka aika shi ta imel.Tuna ka goge kwafin da zarar ka yi nasarar kwafarsa daga jikin na\'urar ko in an karbi imel din."</string>
-<string name="debug_tool_email_sender_picker">"Zabi wani tsari da za ka aika bayanan kan ka"</string>
-<string name="debug_tool_email_subject">"An lika Db na kalanda"</string>
-<string name="debug_tool_email_body">"A like rumbun Kalanda ta ne tare da duk alkawuran ganawata da bayanan kashin kaina. Ka rike da lura."</string>
-<string name="no_title_label">"(Babu take)"</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-de/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-de/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-de/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Kalenderspeicher"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Standard"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Kalenderinformationen"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Fehler"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Keine Kalender"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Termine: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Termine: <xliff:g id="EVENTS_0">%1$d</xliff:g>, nicht gespeichert: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalender"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Jetzt löschen"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Starten"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Sie sind im Begriff, 1) eine Kopie Ihrer Kalenderdatenbank auf der SD-Karte bzw. dem USB-Speicher zu speichern, die von jeder App gelesen werden kann, und sie 2) per E-Mail zu versenden. Löschen Sie die Kopie unbedingt, sobald sie vom Gerät kopiert oder die E-Mail erhalten wurde."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Wählen Sie ein Programm zum Senden Ihrer Datei aus."</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Kalender-Debug angehängt"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Beigefügt ist meine Kalenderdatenbank mit allen meinen Terminen und personenbezogenen Daten. Bitte gehen Sie sorgfältig damit um."</string>
-    <string name="no_title_label">"(Kein Titel)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-sv/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-sv/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-sv/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Kalender"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Standardinställning"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Kalenderinfo"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Fel"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Inga kalendrar"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Händelser: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Händelser: <xliff:g id="EVENTS_0">%1$d</xliff:g>, ej sparade: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalender"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Ta bort nu"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Börja"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Du kommer att 1) göra en kopia av din kalenderdatabas på SD-kortet/USB-minnet som kan läsas av alla appar och (2) skicka den via e-post. Kom ihåg att ta bort den så snart den har kopierats från enheten eller så snart e-postmeddelandet har tagits emot."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Välj ett program för att skicka filen"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Kalenderdatabas bifogad"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Jag bifogar min kalenderdatabas med alla mina möten och personliga uppgifter. Hantera dem varsamt."</string>
-    <string name="no_title_label">"(Ingen titel)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-sw/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-sw/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-sw/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Hifadhi ya Kalenda"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Chaguo-msingi"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Maelezo ya kalenda"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Hitilafu"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Hakuna kalenda"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Matukio: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Matukio: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Hayajahifadhiwa: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalenda"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Futa sasa"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Anza"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Uko karibu 1) kutengeneza nakala ya hifadhidata ya kalenda yako kwa kadi ya SD/hifadhi ya USB ambayo inaweza kusomwa na programu yoyote, na 2) kuituma kwa barua pepe. Kumbuka kufuta nakala pindi tu unapofaulu kuinakili kwenye kifaa hicho au barua pepe imepokewa."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Chagua programu ili kutuma faili yako"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Hifadhidata ya Kalenda imeambatishwa"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Kilichoambatishwa ni hifadhidata yangu ya kalenda iliyo na miadi yangu yote na maelezo ya kibinafsi. Shughulikia kwa uangalifu."</string>
-    <string name="no_title_label">"(Hakuna kichwa)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-zh-rTW/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-zh-rTW/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-zh-rTW/strings.xml	(revision 168087)
@@ -1,36 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"日曆儲存空間"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"預設"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"日曆資訊"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"錯誤"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"沒有日曆"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"活動數：<xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"活動數：<xliff:g id="EVENTS_0">%1$d</xliff:g>；未儲存活動數：<xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"日曆"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"立即刪除"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"開始"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"您即將 1) 在任何應用程式均可讀取的 SD 卡或 USB 儲存裝置中儲存您的日曆資料庫副本，並且 2) 以電子郵件傳送日曆資料庫。提醒您，在您成功將日曆資料庫複製到卸除式裝置或確認我們收到電子郵件後，請立即刪除日曆資料庫副本。"</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"選擇要傳送檔案的程式"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"內含日曆偵錯附件"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"附件是我的日曆資料庫，其中包含我所有的約會和個人資訊，請謹慎處理。"</string>
-     <!-- SPRD: Add 20141231 of bug474826, vcalendar issue @{ -->
-    <string name="no_title_label">"(無標題)"</string>
-    <!-- @} -->
-</resources>
Index: packages/providers/CalendarProvider/res/values-hi/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-hi/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-hi/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"कैलेंडर मेमोरी"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"सामान्य"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"कैलेंडर जानकारी"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"त्रुटि"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"कोई कैलेंडर नहीं"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"ईवेंट: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"ईवेंट: <xliff:g id="EVENTS_0">%1$d</xliff:g>, सहेजे नहीं गए: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"कैलेंडर"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"अभी हटाएं"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"प्रारंभ करें"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"अब आप 1) अपने कैलेंडर डेटाबेस की प्रति SD कार्ड/USB मेमोरी पर बनाने वाले हैं जो किसी भी ऐप्स  द्वारा पढ़ी जा सकती है और 2) उसे ईमेल करने वाले हैं. जैसे ही आप डिवाइस से सफलतापूर्वक इसकी प्रति बना लेते हैं या ईमेल प्राप्त हो जाती है तो इस प्रति को अवश्य हटा दें."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"अपनी फ़ाइल भेजने के लिए कोई प्रोग्राम चुनें"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"कैलेंडर डेटाबेस अटैचमेंट"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"यह अटैचमेंट मेरा कैलेंडर डेटाबेस है जिसमें मेरे सभी अपॉइंटमेंट और व्यक्तिगत जानकारी है. सावधानी से कार्य करें."</string>
-    <string name="no_title_label">(कोई शीर्षक नहीं)</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-si-rLK/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-si-rLK/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-si-rLK/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"දින දර්ශන ආචයනය"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"සුපුරුදු"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"දින දර්ශනයේ තොරතුරු"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"දෝෂය"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"දින දර්ශන නොමැත"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"සිදුවීම්: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"සිදුවීම්: <xliff:g id="EVENTS_0">%1$d</xliff:g>, සුරකින නොලද: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"දින දර්ශනය"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"දැන් මකන්න"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"ආරම්භ කරන්න"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"ඔබ 1) ඔබගේ දින දර්ශන දත්ත සමුහයේ පිටපතක් SD කාඩ් පත/USB ආචයනයට සෑදීමට යයි, එය ඕනෑම යෙදුමකින් කියවිය හැක, සහ 2) ඊ-තැපැල් කිරීමට යයි. එය සාර්ථකව උපාංගයෙන් පිටතට පිටපත් කරගත් පසුව හෝ ඊ-තැපෑල ලද වහාම පිටපත මකා දැමීමට මතක තබාගන්න."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"ඔබගේ ගොනුව යැවීමට ක්‍රමලේඛයක් තෝරන්න"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"දිනදර්ශන Db අමුණා ඇත"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"අමුණා ඇත්තේ මගේ සියලුම වේලා වෙන්කර ගැනීම් සහ පෞද්ගලික තොරතුරු සහිත මාගේ දින දර්ශන දත්ත සමුහයයි. ප්‍රවේශමෙන් පරිහරණය කරන්න."</string>
-    <string name="no_title_label">"(නමක් නොමැත)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-bn-rBD/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-bn-rBD/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-bn-rBD/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"ক্যালেন্ডার সঞ্চয়স্থান"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"ডিফল্ট"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"ক্যালেন্ডারের তথ্য"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"ত্রুটি"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"কোনো ক্যালেন্ডার নেই"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"ইভেন্ট: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"ইভেন্ট: <xliff:g id="EVENTS_0">%1$d</xliff:g>, অসংরক্ষিত: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"ক্যালেন্ডার"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"এখনই মুছে দিন"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"আরম্ভ"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"আপনি ১) SD কার্ড/USB সঞ্চয়স্থানে যেকোনো অ্যাপ্লিকেশানে চলার যোগ্য আপনার ক্যালেন্ডার ডেটাবেসের একটি অনুলিপি তৈরি করতে, এবং ২) সেটিকে ইমেলের মাধ্যমে পাঠাতে চলেছেন৷ আপনার দ্বারা ডিভাইস থেকে সফলভাবে এর অনুলিপি করে নেবার পর অথবা ইমেলটি পেয়ে যাবার পর সাথে সাথেই অনুলিপিটি মুছে ফেলার কথা মনে রাখবেন৷"</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"আপনার ফাইল পাঠানোর জন্য একটি প্রোগ্রাম চয়ন করুন"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"ক্যালেন্ডার Db সংযুক্ত করা হয়েছে"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"আমার সমস্ত অ্যাপোয়েন্টমেন্ট ও ব্যক্তিগত তথ্য সহ আমার ক্যালেন্ডার ডেটাবেস সংযুক্ত করা হয়েছে৷ সাবধানে ব্যবহার করবেন৷"</string>
-    <string name="no_title_label">"(কোনো শীর্ষক নেই)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-hr/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-hr/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-hr/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Pohrana kalendara"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Zadano"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Informacije o kalendaru"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Pogreška"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Nema kalendara"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Događaji: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Događaji: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Nespremljeno: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalendar"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Izbriši sada"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Započni"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Spremate se 1) napraviti kopiju baze podataka kalendara na SD karticu/USB pohranu koju može čitati bilo koja aplikacija i 2) poslati je e-poštom. Ne zaboravite ju izbrisati čim ju uspješno kopirate s uređaja ili čim stigne e-pošta."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Odaberite program za slanje datoteke"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Baza podataka kalendara u privitku"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"U prilogu je moja baza podataka kalendara sa svim mojim obvezama i osobnim podacima. Oprezno rukujte s njom."</string>
-    <string name="no_title_label">"(bez naslova)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-en-rGB/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-en-rGB/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-en-rGB/strings.xml	(revision 168087)
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Calendar Storage"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Default"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Calendar info"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Error"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"No calendars"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Events: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Events: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Unsaved: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Calendar"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Delete now"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Start"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"You are about to 1) make a copy of your calendar database to the SD card/USB storage, which is readable by any app, and 2) email it. Remember to delete the copy as soon as you have successfully copied it off the device or the email is received."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Select a programme to send your file"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Calendar Db attached"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Attached is my calendar database with all my appointments and personal information. Please handle with care."</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-pl/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-pl/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-pl/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Pamięć kalendarza"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Domyślny"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Informacje o kalendarzu"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Błąd"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Brak kalendarzy"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Liczba wydarzeń: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Liczba wydarzeń: <xliff:g id="EVENTS_0">%1$d</xliff:g>, liczba niezapisanych: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalendarz"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Usuń teraz"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Rozpocznij"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Za chwilę wykonasz następujące czynności: 1) skopiujesz bazę danych kalendarza na kartę SD lub nośnik USB, gdzie będzie dostępna dla wszystkich aplikacji, a następnie 2) wyślesz ją e-mailem. Pamiętaj o usunięciu bazy danych, gdy pomyślnie skopiujesz ją z urządzenia lub otrzymasz już wiadomość e-mail."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Wybierz program, którego użyjesz do wysłania pliku."</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Załączono bazę danych Kalendarza"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"W załączniku przesyłam bazę danych swojego kalendarza, zawierającą wszystkie moje informacje o spotkaniach i dane osobiste. Proszę zachować ostrożność."</string>
-    <string name="no_title_label">"(Bez tytułu)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-th/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-th/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-th/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"การจัดเก็บปฏิทิน"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"เริ่มต้น"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"ข้อมูลปฏิทิน"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"ข้อผิดพลาด"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"ไม่มีปฏิทิน"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"กิจกรรม: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"กิจกรรม: <xliff:g id="EVENTS_0">%1$d</xliff:g>, ไม่ได้บันทึก: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"ปฏิทิน"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"ลบเดี๋ยวนี้"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"เริ่ม"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"คุณกำลังจะ 1) ทำสำเนาของฐานข้อมูลปฏิทินของคุณลงในการ์ด SD/ที่จัดเก็บข้อมูล USB ที่ทุกแอปพลิเคชันสามารถอ่านได้ และ 2) ส่งอีเมล จำไว้ว่าให้ลบข้อมูลออกจากอุปกรณ์ทันทีที่คุณได้คัดลอกไว้เรียบร้อยแล้วหรือเมื่อผู้รับได้รับอีเมลแล้ว"</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"เลือกโปรแกรมเพื่อส่งไฟล์ของคุณ"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"ฐานข้อมูลปฏิทินถูกแนบอยู่"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"ที่แนบอยู่นี้เป็นฐานข้อมูลปฏิทินซึ่งมีกำหนดนัดหมายและข้อมูลส่วนบุคคลของฉันทั้งหมด จัดการด้วยความระมัดระวัง"</string>
-    <string name="no_title_label">"(ไม่มีชื่อ)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-hu/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-hu/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-hu/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Naptár tárolása"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Alapértelmezett"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Naptárinfó"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Hiba"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Nincs naptár"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Események: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Események: <xliff:g id="EVENTS_0">%1$d</xliff:g>, nem mentett események: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Naptár"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Törlés most"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Indítás"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Arra készül, hogy 1) másolatot készítsen a naptár adatbázisáról a bármilyen alkalmazás által olvasható SD-kártyára/USB-tárhelyre, és 2) e-mailben elküldje. Ne felejtse el azonnal törölni a másolatot, amint sikeresen átmásolta a készülékről, vagy miután az e-mail megérkezett."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Válasszon programot a fájl elküldéséhez"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Naptár-adatbázis mellékelve"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Csatolva van a naptáram adatbázisa az összes találkozómmal és személyes adataimmal. Kérem, legyenek elővigyázatosak."</string>
-    <string name="no_title_label">"(Nincs cím)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-tl/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-tl/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-tl/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Imbakan ng Kalendaryo"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Default"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Impormasyon ng kalendaryo"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Error"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Walang mga kalendaryo"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Mga Kaganapan: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Mga kaganapan: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Hindi na-save: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalendaryo"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Tanggalin ngayon"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Magsimula"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Ikaw ay 1) gagawa ng kopya ng iyong database ng kalendaryo sa SD card/USB storage, na nababasa ng anumang app, at 2) i-e-email ito. Tandaang tanggalin ang kopya sa sandaling matagumpay mo itong nakopya mula sa device o natanggap ang email."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Pumili ng programa upang ipadala ang iyong file"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Naka-attach ang Calendar Db"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Naka-attach ang aking database ng Kalendaryo kasama ang lahat ng aking appointment at personal na impormasyon. Pangasiwaan nang may pag-iingat."</string>
-    <string name="no_title_label">"(Walang pamagat)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-lt/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-lt/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-lt/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Kalendoriaus saugykla"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Numatytasis"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Kalendoriaus informacija"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Klaida"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Nėra kalendorių"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Įvykiai: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Įvykiai: <xliff:g id="EVENTS_0">%1$d</xliff:g>; neišsaugota: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalendorius"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Dabar ištrinti"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Pradėti"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Ketinate: 1) sukurti kalendoriaus duomenų kopiją SD kortelėje ir (arba) USB atmintyje, kurią galima skaityti naudojant bet kurią programą, ir 2) išsiųsti ją el. paštu. Būtinai ją ištrinkite iš karto, kai sėkmingai nukopijuosite iš įrenginio ar gausite el. laišką."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Pasirinkite programą, kad galėtumėte išsiųsti failą"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Kalendoriaus duomenys pridėti"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Pridedami kalendoriaus duomenys su visa susitikimų ir asmenine informacija. Elkitės atsargiai."</string>
-    <string name="no_title_label">"(Nėra pavadinimo)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/layout/dialog_activity.xml
===================================================================
--- packages/providers/CalendarProvider/res/layout/dialog_activity.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/layout/dialog_activity.xml	(revision 168087)
@@ -1,72 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2011 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-  
-          http://www.apache.org/licenses/LICENSE-2.0
-  
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<LinearLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:orientation="vertical"
-    android:padding="4dp"
-    android:gravity="center_horizontal">
-
-    <!-- Message to show to use. -->
-    <ScrollView
-        android:layout_width="match_parent"
-        android:layout_height="0dip"
-        android:gravity="center_vertical|left"
-        android:layout_weight="1">
-        <TextView
-            android:id="@+id/text"
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:padding="16dp"
-            android:text="@string/debug_tool_message"
-            android:textAppearance="?android:attr/textAppearanceMedium" />
-    </ScrollView>
-
-    <!-- Alert dialog style buttons along the bottom. -->
-    <LinearLayout
-        style="?android:attr/buttonBarStyle"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:measureWithLargestChild="true">
-        <Button
-            style="?android:attr/buttonBarButtonStyle"
-            android:id="@+id/confirm"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_weight="1"
-            android:onClick="onClick"
-            android:text="@string/debug_tool_start_button" />
-        <Button
-            style="?android:attr/buttonBarButtonStyle"
-            android:id="@+id/delete"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_weight="1"
-            android:onClick="onClick"
-            android:text="@string/debug_tool_delete_button"
-            android:enabled="false" />
-        <Button
-            style="?android:attr/buttonBarButtonStyle"
-            android:id="@+id/cancel"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_weight="1"
-            android:onClick="onClick"
-            android:text="@android:string/no" />
-    </LinearLayout>
-</LinearLayout>
\ No newline at end of file
Index: packages/providers/CalendarProvider/res/values-lv/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-lv/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-lv/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Kalendāra krātuve"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Noklusējums"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Kalendāra dati"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Kļūda"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Nav kalendāru"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Pasākumi: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Pasākumi: <xliff:g id="EVENTS_0">%1$d</xliff:g>, nesaglabāti: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalendārs"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Dzēst tagad"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Sākt"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Jūs gatavojaties 1) SD kartē/USB atmiņā izveidot kalendāra datu bāzes kopiju, kuru var nolasīt jebkura lietotne, un 2) nosūtīt to pa e-pastu. Tiklīdz būsiet to veiksmīgi pārkopējis no ierīces vai būsiet saņēmis e-pasta ziņojumu, neaizmirstiet izdzēst šo kopiju."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Izvēlieties programmu faila nosūtīšanai"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Kalendāra datu bāze ir pievienota"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Pielikumā ir mana kalendāra datu bāze ar visiem tikšanās ierakstiem un personas informāciju. Izmantojiet to uzmanīgi!"</string>
-    <string name="no_title_label">"(Nav nosaukuma)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-pt/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-pt/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-pt/strings.xml	(revision 168087)
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Armazenamento de agenda"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Padrão"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Informações da agenda"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Erro"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Nenhuma agenda disponível"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Eventos: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Eventos: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Não salvos: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Agenda"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Excluir agora"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Início"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Você está prestes a 1) fazer uma cópia de seu banco de dados da agenda para o cartão SD/armazenamento USB, que pode ser lido por qualquer app e 2) enviá-lo por e-mail. Lembre-se de excluir o banco de dados após tê-lo copiado ou ter recebido o e-mail."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Selecione um programa para enviar seu arquivo"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"O banco de dados da agenda foi anexado"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"O banco de dados da minha agenda está anexado, contendo todos os meus compromissos e informações pessoais. Use-o com cuidado."</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-tr/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-tr/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-tr/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Takvim Deposu"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Varsayılan"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Takvim bilgileri"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Hata"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Takvim yok"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Etkinlikler: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Etkinlikler: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Kaydedilmemiş: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Takvim"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Şimdi sil"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Başlat"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Takvim veritabanınızı 1) tüm uygulamaların okuyabileceği sd kart/usb belleğe kopyalamak ve 2) bunu e-postayla göndermek üzeresiniz. Bu veritabanını başarılı bir şekilde kopyaladıktan veya e-posta alındıktan sonra, kopyayı cihazdan hemen silmeyi unutmayın."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Dosyanızı göndermek için bir program seçin"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Takvim Veritabanı ekte"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Tüm randevularımı ve kişisel bilgilerimi içeren takvim veritabanımı ekte bulabilirsiniz. Lütfen kullanırken dikkatli olun."</string>
-    <string name="no_title_label">"(Başlıksız)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-lo-rLA/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-lo-rLA/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-lo-rLA/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"ບ່ອນຈັດເກັບຂໍ້ມູນປະຕິທິນ"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"ມາດຕະຖານ"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"ຂໍ້ມູນປະຕິທິນ"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"ຜິດພາດ"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"ບໍ່ມີປະຕິທິນ"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"ນັດໝາຍ: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"ນັດໝາຍ: <xliff:g id="EVENTS_0">%1$d</xliff:g>, ຍັງບໍ່ໄດ້ບັນທຶກ: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"ປະຕິທິນ"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"ລຶບດຽວນີ້"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"ເລີ່ມ"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"ທ່ານກຳລັງຈະ 1) ສຳເນົາຖານຂໍ້ມູນປະຕິທິນຂອງທ່ານ ໃສ່ໃນ SD card/ບ່ອນຈັດເກັບຂໍ້ມູນ USB, ທີ່ສາມາດອ່ານໂດຍແອັບຯໃດໆກໍໄດ້, ແລະ 2) ສົ່ງອີເມວຂໍ້ມູນດັ່ງກ່າວ. ຈົ່ງຢ່າລືມລຶບສຳເນົາເກົ່ານີ້ ຫຼັງຈາກທີ່ທ່ານໄດ້ທຳການສຳເນົາໄວ້ ຫຼືສົ່ງອີເມວສຳເລັດແລ້ວ."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"ເລືອກໂປຣແກຣມທີ່ໃຊ້ຈະສົ່ງໄຟລ໌ຂອງທ່ານ"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"ແນບໄຟລ໌ Db ຂອງປະຕິທິນແລ້ວ"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"ໄຟລ໌ທີ່ແນບມານີ້ ແມ່ນຖານຂໍ້ມູນປະຕິທິນຂອງຂ້ອຍທີ່ມີການນັດໝາຍ ແລະ ຂໍ້ມູນສ່ວນໂຕທັງໝົດ. ຈົ່ງໃຊ້ຢ່າງລະມັດລະວັງ."</string>
-    <string name="no_title_label">"(ບໍ່ມີຫົວຂໍ້)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-af/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-af/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-af/strings.xml	(revision 168087)
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Kalender-berging"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Verstek"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Kalender-inligting"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Fout"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Geen kalenders nie"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Gebeure: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Gebeurtenisse: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Ongestoor: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Kalender"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Vee nou uit"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Begin"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Jy gaan nou 1) \'n kopie van jou kalenderdatabasis na die SD-kaart / USB-geheue stoor, wat deur enige program gelees kan word, en 2) dit e-pos. Onthou om die kopie te skrap sodra jy dit suksesvol van die toestel af gekopieer het of sodra die e-pos ontvang is."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Kies \'n program om jou lêer te stuur"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Kalenderdatabasis aangeheg"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Aangeheg is my Kalender-databasis met al my afsprake en persoonlike inligting. Hanteer versigtig."</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-gl-rES/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-gl-rES/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-gl-rES/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Almacenamento de calendarios"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Predeterminado"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Información do calendario"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Erro"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Non hai calendarios"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Eventos: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Eventos: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Non gardados: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Calendario"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Eliminar agora"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Iniciar"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Estás a punto de 1) crear unha copia da base de datos do teu calendario no almacenamento USB/tarxeta SD á que pode acceder calquera aplicación e 2) enviala por correo electrónico. Non esquezas eliminar a copia en canto se copie correctamente no dispositivo ou en canto se reciba o correo electrónico."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Escoller un programa para enviar o ficheiro"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Base de datos do calendario"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"A base de datos do meu calendario con todos os meus compromisos e información persoal está no anexo. Utilízaa con coidado."</string>
-    <string name="no_title_label">(Sen título)</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-am/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-am/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-am/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"የቀንመቁጠሪያማከማቻ"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"ነባሪ"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"የቀን መቁጠሪያመረጃ"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"ስህተት"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"ምንም ቀንመቁጠሪያ ዎች የለዎትም"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"ዝግጅቶች: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"ክስተቶች፡<xliff:g id="EVENTS_0">%1$d</xliff:g>፣ አልተቀመጡም፡<xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"ቀን መቁጠሪያ"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"አሁን ሰርዝ"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"ጀምር"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"አሁን 1 ) የቀን መቁጠሪያህን የውሂብ ጎታዎች ወደ sd ካርድ/usb ማከማቻ በማንኛውም ትግበራ እንዲነበብ ልትገለብጥ  እና2) ኢሜይል ልታደርግ ነው። ከመሣሪያው ላይ በተሳካ ከገለበጥክ በኋላወይም ኢሜይል ከተቀበልክ በኋላ መሰረዝ አትርሳ።"</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"ፋይልህን ለመላክ ፕሮግራም ምረጥ"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"የቀን መቁጠሪያ ውሂብ ጎታ አባሪ ተደርጓል"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"የቀን መቁጠሪያዬ ውሂብ ጎታ ከቀጠሮዎቼ እና የግል መረጃዎች ጋር አባሪ ተደርጓል። በደንብ ይጠበቅ።"</string>
-    <string name="no_title_label">"(አርእስት አልባ)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-kn-rIN/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-kn-rIN/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-kn-rIN/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"ಕ್ಯಾಲೆಂಡರ್ ಸಂಗ್ರಹಣೆ"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"ಡೀಫಾಲ್ಟ್"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"ಕ್ಯಾಲೆಂಡರ್ ಮಾಹಿತಿ"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"ದೋಷ"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"ಯಾವುದೇ ಕ್ಯಾಲೆಂಡರ್‌ಗಳಿಲ್ಲ"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"ಈವೆಂಟ್‌ಗಳು: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"ಈವೆಂಟ್‌ಗಳು: <xliff:g id="EVENTS_0">%1$d</xliff:g>,ಉಳಿಸಲಾಗದವು: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"ಕ್ಯಾಲೆಂಡರ್‌"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"ಈಗ ಅಳಿಸು"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"ಪ್ರಾರಂಭ"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"ನೀವು 1) ನಿಮ್ಮ ಕ್ಯಾಲೆಂಡರ್ ಡೇಟಾಬೇಸ್‌ ಅನ್ನು ಯಾವುದೇ ಅಪ್ಲಿಕೇಶನ್‌ಗಳು ಓದಬಲ್ಲ SD ಕಾರ್ಡ್/USB ಸಂಗ್ರಹಣೆಗೆ ನಕಲು ಮಾಡಲಿರುವಿರಿ, ಮತ್ತು 2) ಅದನ್ನು ಇಮೇಲ್ ಮಾಡಲಿರುವಿರಿ. ನೀವು ಅದನ್ನು ಯಶಸ್ವಿಯಾಗಿ ನಕಲು ಮಾಡಿದ ನಂತರ ಅಥವಾ ಇಮೇಲ್ ಸ್ವೀಕರಿಸಿದ ನಂತರ ಸಾಧನದಲ್ಲಿರುವ ಪ್ರತಿಯನ್ನು ತಪ್ಪದೇ ಅಳಿಸಿ."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"ನಿಮ್ಮ ಫೈಲ್ ಕಳುಹಿಸಲು ಪ್ರೋಗ್ರಾಂ ಒಂದನ್ನು ಆಯ್ಕೆ ಮಾಡಿ"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"ಕ್ಯಾಲೆಂಡರ್ Db ಲಗತ್ತಿಸಲಾಗಿದೆ"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"ನನ್ನ ಎಲ್ಲ ಅಪಾಯಿಂಟ್‌ಮೆಂಟ್‌ಗಳು ಮತ್ತು ವೈಯಕ್ತಿಕ ಮಾಹಿತಿಗಳನ್ನು ಒಳಗೊಂಡ ನನ್ನ ಕ್ಯಾಲೆಂಡರ್ ಡೇಟಾಬೇಸ್ ಲಗತ್ತಿಸಲಾಗಿದೆ. ಎಚ್ಚರಿಕೆಯಿಂದ ನಿಭಾಯಿಸಿ."</string>
-    <string name="no_title_label">"(ತಲೆಬರಹ ಇಲ್ಲ)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-ne-rNP/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-ne-rNP/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-ne-rNP/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"पात्रो भण्डारण"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"पूर्वनिर्धारित"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"पात्रो जानकारी"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"त्रुटि"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"कुनै पनि पात्राहरू छैनन्"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"घटनाहरू: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"घटनाहरू: <xliff:g id="EVENTS_0">%1$d</xliff:g>, असुरक्षित: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"पात्रो"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"अहिले हटाउनुहोस्"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"सुरु"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"तपाईँ : १) SD कार्ड/USB भण्डारणमा तपाईँको पात्रो डेटाबेसको प्रतिलिपि  बनाउन लाग्नु भएको छ, जुन कुनै पनि अनुप्रयोगद्वारा पढ्न मिल्छ र २) त्यसलाई इमेल गर्न लाग्नु भएको छ। तपाईँले उपकरणमा प्रतिलिपि बनाइसकेपछि अथवा इमेल प्राप्त भइसकेपछि प्रतिलिपिलाई मेटाउन सम्झनुहोला।"</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"तपाईँको फाइल पठाउन कुनै प्रोग्राम छान्नुहोस्"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"पात्रो Db संलग्न छ"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"मेरो भेटघाट र व्यक्तिगत जानकारी सहितको पात्रो डेटाबेस संलग्न छ। होशियारीका साथ चलाउनुहोस्।"</string>
-    <string name="no_title_label">"(शीर्षक छैन)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-sq-rAL/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-sq-rAL/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-sq-rAL/strings.xml	(revision 168087)
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-<string name="calendar_storage">Memoria e kalendarit</string>
-<string name="calendar_default_name">standarde</string>
-<string name="calendar_info">Informacione kalendari</string>
-<string name="calendar_info_error">Gabim</string>
-<string name="calendar_info_no_calendars">Asnjë kalendar</string>
-<string name="calendar_info_events">"Eventet: <xliff:g id = "events">%1$d</xliff:g>"</string>
-<string name="calendar_info_events_dirty">"Eventet: <xliff:g id = "events">%1$d</xliff:g>, Të paruajtur: <xliff:g id = "dirty events">%2$d</xliff:g>"</string>
-<string name="provider_label">Kalendari</string>
-<string name="debug_tool_delete_button">Fshi tani</string>
-<string name="debug_tool_start_button">Fillo</string>
-<string name="debug_tool_message">Je duke 1) bërë një kopje të databazës të kalendarit tënd në kartën SD/memories USB, e cila është e lexueshme nga çdo aplikacion, dhe 2) duke e dërguar me email. Mos harro ta fshish këtë kopje sapo ta kesh kopjuar nga pajisja ose të jetë marrë email-i.</string>
-<string name="debug_tool_email_sender_picker">Zgjidh një program për të dërguar skedarin tënd.</string>
-<string name="debug_tool_email_subject">Kalendari Db janë bashkëlidhur</string>
-<string name="debug_tool_email_body">Bashkëngjitur gjendet databaza e kalendarit tim, së bashku me të gjitha të dhënat e kontaktit. Përdore me kujdes.  </string>
-<string name="no_title_label">(Pa titull)</string>
-</resources>
Index: packages/providers/CalendarProvider/res/values-el/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-el/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-el/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"Αποθηκευτικός χώρος ημερολογίου"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"Προεπιλογή"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"Πληροφορίες ημερολογίου"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"Σφάλμα"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"Δεν υπάρχουν ημερολόγια"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"Συμβάντα: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"Συμβάντα: <xliff:g id="EVENTS_0">%1$d</xliff:g>, Μη αποθηκευμένα: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"Ημερολόγιο"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"Διαγραφή τώρα"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"Έναρξη"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"Πρόκειται να προβείτε σε 1) δημιουργία ενός αντιγράφου της βάσης δεδομένων του ημερολογίου σας στην κάρτα SD/στον αποθηκευτικό χώρο USB, το οποίο θα είναι αναγνώσιμο από οποιαδήποτε εφαρμογή και 2) αποστολή του μέσω ηλεκτρονικού ταχυδρομείου. Θυμηθείτε να το διαγράψετε μόλις το έχετε αντιγράψει επιτυχώς από τη συσκευή ή μόλις λάβετε το μήνυμα ηλεκτρονικού ταχυδρομείου."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"Επιλέξτε ένα πρόγραμμα για να στείλετε το αρχείο σας"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"Επισυνάπτεται βάση δεδομένων ημερολογίου"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"Επισυνάπτεται η βάση δεδομένων του ημερολογίου μου με όλα τα ραντεβού και τις προσωπικές πληροφορίες μου. Ο χειρισμός της πρέπει να είναι προσεκτικός."</string>
-    <string name="no_title_label">"(Χωρίς τίτλο)"</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-gu-rIN/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-gu-rIN/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-gu-rIN/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"કેલેન્ડર સંગ્રહણ"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"ડિફોલ્ટ"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"કેલેન્ડર માહિતી"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"ભૂલ"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"કોઈ કેલેન્ડર્સ નથી"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"ઇવેન્ટ્સ: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"ઇવેન્ટ્સ: <xliff:g id="EVENTS_0">%1$d</xliff:g>, વણસાચવેલ: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"કેલેન્ડર"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"હમણાં કાઢી નાખો"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"#__start__"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"તમે 1) SD કાર્ડ/USB સ્ટોરેજ પર તમાર કેલેન્ડર ડેટાબેસની કૉપિ બનાવવામાં છો, જે કોઈપણ એપ્લિકેશન દ્વારા વાંચવા યોગ્ય છે અને 2) તેને ઇમેઇલ કરવાના છો. તમે સફળતાપૂર્વક કૉપિ કરી લો તે પછી તેને ઉપકરણ પરથી કૉપિને અથવા પ્રાપ્ત થયેલી ઇમેઇલને કાઢી નાખવાનું યાદ રાખો."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"તમારી ફાઇલ મોકલવા માટે એક પ્રોગ્રામ પસંદ કરો"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"કેલેન્ડર Db જોડ્યો"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"જોડેલ છે તે મારી બધી એપોઇન્ટમેન્ટ્સ અને વ્યક્તિગત માહિતી સાથેનો મારો કેલેન્ડર ડેટાબેસ છે. સાવધાનીથી રાખો."</string>
-    <string name="no_title_label">(કોઇ શીર્ષક નહીં)</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-ar/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-ar/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-ar/strings.xml	(revision 168087)
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="calendar_storage" msgid="5387668002987562770">"تخزين التقويم"</string>
-    <string name="calendar_default_name" msgid="6924293766625167275">"افتراضي"</string>
-    <string name="calendar_info" msgid="6687678621418059281">"معلومات التقويم"</string>
-    <string name="calendar_info_error" msgid="5575162446528419982">"خطأ"</string>
-    <string name="calendar_info_no_calendars" msgid="4287534468186704433">"بلا تقاويم"</string>
-    <string name="calendar_info_events" msgid="1805502308105103803">"الأحداث: <xliff:g id="EVENTS">%1$d</xliff:g>"</string>
-    <string name="calendar_info_events_dirty" msgid="8879392112564499515">"الأحداث: <xliff:g id="EVENTS_0">%1$d</xliff:g>، غير المحفوظة: <xliff:g id="DIRTY_EVENTS">%2$d</xliff:g>"</string>
-    <string name="provider_label" msgid="2306513350843464739">"التقويم"</string>
-    <string name="debug_tool_delete_button" msgid="5052706251268452090">"حذف الآن"</string>
-    <string name="debug_tool_start_button" msgid="5384780896342913563">"بدء"</string>
-    <string name="debug_tool_message" msgid="4862486669932821937">"‏أنت على وشك 1) إجراء نسخة من قاعدة بيانات التقويم إلى وحدة تخزين بطاقة SD أو USB والتي يمكن قراءتها بواسطة أي تطبيق و2) إرسالها في رسالة إلكترونية. وتذكر حذفها بمجرد نسخها إلى الجهاز أو تلقيها بنجاح."</string>
-    <string name="debug_tool_email_sender_picker" msgid="2000311987477419397">"اختر أحد البرامج لإرسال الملف"</string>
-    <string name="debug_tool_email_subject" msgid="2403590332256471194">"تم إرفاق قاعدة بيانات التقويم"</string>
-    <string name="debug_tool_email_body" msgid="4835949635324134017">"تم إرفاق قاعدة بيانات التقويم وبها جميع المواعيد والمعلومات الشخصية. تعامل معها بحذر."</string>
-    <string name="no_title_label">(بلا عنوان)</string>
-
-</resources>
Index: packages/providers/CalendarProvider/res/values-as/strings.xml
===================================================================
--- packages/providers/CalendarProvider/res/values-as/strings.xml	(revision 168086)
+++ packages/providers/CalendarProvider/res/values-as/strings.xml	(revision 168087)
@@ -1,18 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-<string name="calendar_storage">"কেলেণ্ডাৰ ষ্টোৰেজ"</string>
-<string name="calendar_default_name">ডিফল্ট</string>
-<string name="calendar_info">"কেলেণ্ডাৰ তথ্য"</string>
-<string name="calendar_info_error">"অটো"</string>
-<string name="calendar_info_no_calendars">"কোনো কেলেণ্ডাৰ নাই"</string>
-<string name="calendar_info_events">"ঘটনাবোৰ : <xliff:g id ="events">%1$d</xliff:g>"</string>
-<string name="calendar_info_events_dirty">"ঘটনাবোৰ : <xliff:g id ="events">%1$d</xliff:g>, অসঞ্চিত: <xliff:g id ="dirty events">%2$d</xliff:g>"</string>
-<string name="provider_label">"কেলেণ্ডাৰ"</string>
-<string name="debug_tool_delete_button">"এতিয়া বিলোপ কৰক"</string>
-<string name="debug_tool_start_button">"স্টাৰ্ট"</string>
-<string name="debug_tool_message">"আপুনি এতিয়া 1) আপোনাৰ কেলেণ্ডাৰ ডাটাবেছ SD কাৰ্ড/USB ষ্টোৰেজলৈ প্ৰতিলিপি কৰিব ওলাইছে, যাক এপ্পে পঢ়িব পাৰে, আৰু 2) আৰু ইয়াক ইমেইল কৰিব ওলাইছে। আপুনি ইয়াক সফলতাৰে ডিভাইছৰ পৰা প্ৰতিলিপি কৰাৰ বাৰ ইমেইল প্ৰাপ্ত কৰাৰ পিছতে ইয়াক বিলোপ কৰিবলৈ নাপাহৰিব।"</string>
-<string name="debug_tool_email_sender_picker">"আপোনাৰ ফাইল প্ৰেৰণ কৰিবলৈ প্ৰ’গ্ৰাম এটা বাছনি কৰক"</string>
-<string name="debug_tool_email_subject">"কেলেণ্ডাৰ Db সংলগ্ন হৈছে"</string>
-<string name="debug_tool_email_body">"মোৰ সকলো এপইণ্টমেণ্ট আৰু ব্যক্তিগত তথ্য সহ মোৰ কেলেণ্ডাৰ ডাটাবেছ সংলগ্ন কৰা হৈছে। সাৱধানে সঞ্চালন কৰিব।"</string>
-<string name="no_title_label">"(কোনো শিৰোনাম নাই)"</string>
-</resources>
Index: packages/providers/CalendarProvider/NOTICE
===================================================================
--- packages/providers/CalendarProvider/NOTICE	(revision 168086)
+++ packages/providers/CalendarProvider/NOTICE	(revision 168087)
@@ -1,190 +0,0 @@
-
-   Copyright (c) 2005-2008, The Android Open Source Project
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
-
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
Index: packages/providers/CalendarProvider/tests/EMMA_README
===================================================================
--- packages/providers/CalendarProvider/tests/EMMA_README	(revision 168086)
+++ packages/providers/CalendarProvider/tests/EMMA_README	(revision 168087)
@@ -1,93 +0,0 @@
-# This defines a shell function called run_emma_calp() that rebuilds
-# the Calendar provider with EMMA coverage, executes the Calendar CTS
-# tests, and generates results into ~/emmaReport/.  The previous emmaReport
-# directory, if any, will be removed.
-#
-# This expects that ". build/envsetup.sh" and an appropriate "lunch"
-# command have already been issued.
-#
-# Also, since we're doing this "the hard way", it's necessary to have
-# /system/framework/emma.jar in BOOTCLASSPATH.  Basic steps:
-# - edit system/core/rootdir/init.rc
-# - insert "/system/framework/emma.jar" right before framework.jar
-# - mmm -j8 external/emma
-# - make -j8
-# - adb reboot-bootloader
-# - fastboot flashall
-#
-# This also defines a no_emma_calp() function that rebuilds the provider
-# without emma.
-#
-# NOTE: interrupting execution may leave you in a different directory
-
-function run_emma_calp()
-{
-    # rebuild provider with emma coverage
-    _build_install_calp true
-    if [ $? -ne 0 ]; then
-        echo Build failed.
-        return 1
-    fi
-
-    # run the CTS tests; note we can't get success/failure result in $?
-    adb shell am instrument -w -e coverage true \
-        -e class android.provider.cts.CalendarTest \
-        -w 'com.android.cts.provider/android.provider.cts.CalendarTest\$CalendarEmmaTestRunner'
-
-    # this path is hard-coded into the CalendarEmmaTestRunner
-    output=/sdcard/calendar-provider.ec
-
-    # extract and generate the report
-    rm -rf ~/emmaReport
-    mkdir ~/emmaReport
-    pushd ~/emmaReport
-    adb pull $output coverage.ec
-    adb shell rm $output
-    java -cp ${ANDROID_BUILD_TOP}/external/emma/lib/emma.jar \
-        emma report -r html -in coverage.ec \
-        -sp ${ANDROID_BUILD_TOP}/packages/providers/CalendarProvider/src \
-        -in ${ANDROID_BUILD_TOP}/out/target/common/obj/APPS/CalendarProvider_intermediates/coverage.em
-    popd
-
-    echo "Report is in $HOME/emmaReport"
-
-    return 0
-}
-
-function no_emma_calp()
-{
-    # rebuild provider without emma coverage
-    _build_install_calp false
-}
-
-function _build_install_calp()
-{
-    emma=$1
-
-    # switch to root on userdebug builds - this may take a second to finish
-    adb root
-
-    pushd $ANDROID_BUILD_TOP
-
-    # force rebuild
-    rm -rf out/target/common/obj/APPS/CalendarProvider_intermediates
-    ##rm -rf out/target/common/obj/APPS/CalendarProviderTests_intermediates
-    rm -rf out/target/common/obj/APPS/CtsProviderTestCases_intermediates
-    EMMA_INSTRUMENT=$emma mmm -j4 packages/providers/CalendarProvider \
-        && EMMA_INSTRUMENT=$emma mmm -j4 cts/tests/tests/provider
-    if [ $? -ne 0 ]; then
-        popd
-        return 1
-    fi
-
-    # copy the instrumented APKs to the device
-    adb remount
-    adb push ${ANDROID_PRODUCT_OUT}/system/app/CalendarProvider.apk /system/app/
-    ##adb push ${ANDROID_PRODUCT_OUT}/data/app/CalendarProviderTests.apk /data/app/
-    adb push ${ANDROID_PRODUCT_OUT}/data/app/CtsProviderTestCases.apk /data/app/
-    popd
-
-    # give the device a couple of seconds to install the packages
-    sleep 2
-}
-
Index: packages/providers/CalendarProvider/tests/Android.mk
===================================================================
--- packages/providers/CalendarProvider/tests/Android.mk	(revision 168086)
+++ packages/providers/CalendarProvider/tests/Android.mk	(revision 168087)
@@ -1,18 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-# We only want this apk build for tests.
-LOCAL_MODULE_TAGS := tests
-
-# Include all test java files.
-LOCAL_SRC_FILES := $(call all-java-files-under, src)
-
-LOCAL_PACKAGE_NAME := CalendarProviderTests
-
-LOCAL_STATIC_JAVA_LIBRARIES := calendar-common
-
-LOCAL_JAVA_LIBRARIES := ext android.test.runner
-
-LOCAL_INSTRUMENTATION_FOR := CalendarProvider
-
-include $(BUILD_PACKAGE)
Index: packages/providers/CalendarProvider/tests/AndroidManifest.xml
===================================================================
--- packages/providers/CalendarProvider/tests/AndroidManifest.xml	(revision 168086)
+++ packages/providers/CalendarProvider/tests/AndroidManifest.xml	(revision 168087)
@@ -1,42 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2008 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<!-- package name must be unique so suffix with "tests" so package loader doesn't ignore us -->
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.android.providers.calendar.tests">
-
-    <application>
-        <uses-library android:name="android.test.runner" />
-    </application>
-
-    <uses-permission android:name="android.permission.READ_CALENDAR" />
-    <uses-permission android:name="android.permission.WRITE_CALENDAR" />
-
-    <!--
-    The test declared in this instrumentation will be run along with tests declared by
-    all other applications via the command: "adb shell itr".
-    The "itr" command will find all tests declared by all applications. If you want to run just these
-    tests on their own then use the command:
-    "adb shell am instrument -w com.android.providers.calendar.tests/android.test.InstrumentationTestRunner"
-
-    To test db upgrade:
-    adb shell am instrument -w -e class com.android.providers.calendar.CalendarDatabaseHelperTest#testSchemasEqualForAllTables com.android.providers.calendar.tests/android.test.InstrumentationTestRunner
-    -->
-    <instrumentation android:name="android.test.InstrumentationTestRunner"
-                     android:targetPackage="com.android.providers.calendar"
-                     android:label="calendar provider tests"/>
-
-</manifest>
Index: packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/ICalendarTest.java
===================================================================
--- packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/ICalendarTest.java	(revision 168086)
+++ packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/ICalendarTest.java	(revision 168087)
@@ -1,316 +0,0 @@
-// Copyright 2007 The Android Open Source Project
-package com.android.providers.calendar;
-
-import com.android.calendarcommon2.ICalendar;
-
-import android.test.suitebuilder.annotation.SmallTest;
-import junit.framework.TestCase;
-
-import java.util.List;
-
-public class ICalendarTest extends TestCase {
-
-    @SmallTest
-    public void testAddParameter() throws Exception {
-        ICalendar.Property prop = new ICalendar.Property("prop1", "value1");
-        assertEquals(0, prop.getParameterNames().size());
-        prop.addParameter(new ICalendar.Parameter("param1", "foo"));
-        assertEquals(1, prop.getParameterNames().size());
-        prop.addParameter(new ICalendar.Parameter("param1", "bar"));
-        assertEquals(1, prop.getParameterNames().size());
-        prop.addParameter(new ICalendar.Parameter("param2", "baaz"));
-        assertEquals(2, prop.getParameterNames().size());
-        prop.addParameter(new ICalendar.Parameter("param1", "quux"));
-        assertEquals(2, prop.getParameterNames().size());
-        prop.addParameter(new ICalendar.Parameter("param3", "accent"));
-        assertEquals(3, prop.getParameterNames().size());
-        assertEquals("prop1;param1=foo;param1=bar;param1=quux;"
-                + "param2=baaz;param3=accent:value1", prop.toString());
-    }
-
-    @SmallTest
-    public void testAddProperty() throws Exception {
-        String text = "BEGIN:DUMMY\n" +
-                "prop2:value3\n" +
-                "prop1:value1\n" +
-                "prop1:value2\n" +
-                "END:DUMMY\n";
-
-        ICalendar.Component component = new ICalendar.Component("DUMMY", null);
-        // properties should be listed in insertion order, by property name.
-        component.addProperty(new ICalendar.Property("prop2", "value3"));
-        component.addProperty(new ICalendar.Property("prop1", "value1"));
-        component.addProperty(new ICalendar.Property("prop1", "value2"));
-        assertEquals(text, component.toString());
-    }
-
-    @SmallTest
-    public void testAddComponent() throws Exception {
-        String text = "BEGIN:DUMMY\n" +
-                "prop1:value1\n" +
-                "prop1:value12\n" +
-                "BEGIN:DUMMY2\n" +
-                "prop2:value2\n" +
-                "END:DUMMY2\n" +
-                "END:DUMMY\n";
-
-        ICalendar.Component parent = new ICalendar.Component("DUMMY", null);
-        // properties should precede components
-        ICalendar.Component child = new ICalendar.Component("DUMMY2", parent);
-        child.addProperty(new ICalendar.Property("prop2", "value2"));
-        parent.addChild(child);
-        parent.addProperty(new ICalendar.Property("prop1", "value1"));
-        parent.addProperty(new ICalendar.Property("prop1", "value12"));
-        assertEquals(text, parent.toString());
-    }
-
-    @SmallTest
-    public void testParseBasicComponent() throws Exception {
-        String text = "BEGIN:DUMMY\n" +
-                "PROP1;PARAM1=foo;PARAM2=bar:VALUE1\n" +
-                "PROP1;PARAM1=baaz;PARAM1=quux:VALUE2\n" +
-                "PROP2:VALUE3\n" +
-                "END:DUMMY\n";
-
-        ICalendar.Component component = ICalendar.parseComponent(text);
-        
-        assertEquals("DUMMY", component.getName());
-        assertNull(component.getComponents());
-        assertEquals(2, component.getPropertyNames().size());
-        ICalendar.Property prop1 = component.getFirstProperty("PROP1");
-        assertEquals(2, prop1.getParameterNames().size());
-        assertEquals("foo", prop1.getFirstParameter("PARAM1").value);
-        assertEquals("bar", prop1.getFirstParameter("PARAM2").value);
-        List<ICalendar.Property> props = component.getProperties("PROP1");
-        assertEquals(2, props.size());
-        List<ICalendar.Parameter> params = props.get(1).getParameters("PARAM1");
-        assertEquals("baaz", params.get(0).value);
-        assertEquals("quux", params.get(1).value);
-    }
-
-    @SmallTest
-    public void testParseQuotedParam() throws Exception {
-        ICalendar.Component component
-                = new ICalendar.Component("DUMMY", null /* parent */);
-        ICalendar.parseComponent(
-                component,
-                "DTSTART;TZID=\"GMT+03:00\";TEST=test1;TEST=\"test2\":20101221T090000");
-        ICalendar.Property property = component.getFirstProperty("DTSTART");
-        assertEquals(2, property.getParameterNames().size());
-        assertEquals("GMT+03:00", property.getFirstParameter("TZID").value);
-        final List<ICalendar.Parameter> testParameters = property.getParameters("TEST");
-        assertEquals(2, testParameters.size());
-        assertEquals("test1", testParameters.get(0).value);
-        assertEquals("test2", testParameters.get(1).value);
-        assertEquals("20101221T090000", component.getFirstProperty("DTSTART").getValue());
-    }
-
-    @SmallTest
-    public void testParseBadQuotedParam() throws Exception {
-        ICalendar.Component component
-                = new ICalendar.Component("DUMMY", null /* parent */);
-
-        ICalendar.parseComponent(
-                component,
-                "FOO;PARAM1=\"param1\"\";PARAM=quote-before-param:value");
-        assertNull("Invalid quote before param value", component.getFirstProperty("FOO"));
-
-        ICalendar.parseComponent(
-                component,
-                "FOO;PARAM\"=expected-equal:value");
-        assertNull("Expected equal in param", component.getFirstProperty("FOO"));
-
-        ICalendar.parseComponent(
-                component,
-                "FOO;PARAM=text-not-allowed\"before-quote:value");
-        assertNull("Invalid quote in param value", component.getFirstProperty("FOO"));
-
-        ICalendar.parseComponent(
-                component,
-                "FOO;PARAM=\"missing-end-quote:value");
-        assertNull("missing-end-quote", component.getFirstProperty("FOO"));
-    }
-
-    @SmallTest
-    public void testParseChildComponent() throws Exception {
-        String childText = "BEGIN:CHILD\n" +
-                "PROP1;PARAM1=foo;PARAM2=bar:VALUE1\n" +
-                "PROP1;PARAM1=baaz;PARAM1=quux:VALUE2\n" +
-                "PROP2:VALUE3\n" +
-                "END:CHILD\n";
-
-        String completeText = "BEGIN:DUMMY\n" +
-                childText +
-                "END:DUMMY\n";
-
-        ICalendar.Component component = new ICalendar.Component("DUMMY", null);
-        component = ICalendar.parseComponent(component, childText);
-        assertEquals("DUMMY", component.getName());
-        assertEquals(1, component.getComponents().size());
-        assertEquals(completeText, component.toString());
-    }
-
-    @SmallTest
-    public void testParseBareEvent() throws Exception {
-        String text = "BEGIN:VEVENT\nEND:VEVENT\n";
-        ICalendar.Component event = ICalendar.parseEvent(text);
-
-        assertEquals("VEVENT", event.getName());
-        assertNull(event.getComponents());
-        assertEquals(0, event.getPropertyNames().size());
-    }
-
-    @SmallTest
-    public void testParseEvent1() throws Exception {
-        String text = "BEGIN:VEVENT\n" +
-                "DTSTART:19970714T170000Z\n" +
-                "DTEND:19970715T035959Z\n" +
-                "SUMMARY:Bastille Day Party\n" +
-                "END:VEVENT\n";
-
-        ICalendar.Component event = ICalendar.parseEvent(text);
-
-        assertEquals("VEVENT", event.getName());
-        assertNull(event.getComponents());
-        assertEquals(3, event.getPropertyNames().size());
-        assertEquals(1, event.getProperties("DTSTART").size());
-        assertEquals("19970714T170000Z", event.getFirstProperty("DTSTART").getValue());
-        assertEquals(0, event.getFirstProperty("DTSTART").getParameterNames().size());
-        assertEquals(1, event.getProperties("DTEND").size());
-        assertEquals(0, event.getFirstProperty("DTEND").getParameterNames().size());
-        assertEquals("19970715T035959Z", event.getFirstProperty("DTEND").getValue());
-        assertEquals(1, event.getProperties("SUMMARY").size());
-        assertEquals(0, event.getFirstProperty("SUMMARY").getParameterNames().size());
-        assertEquals("Bastille Day Party", event.getFirstProperty("SUMMARY").getValue());
-    }
-
-    @SmallTest
-    public void testParseEvent2() throws Exception {
-        String text = "BEGIN:VEVENT\n" +
-                "DTSTART;TZID=America/Los_Angeles:19970714T170000\n" +
-                "DURATION:+P3600S\n" +
-                "SUMMARY;FOO=1;BAR=2:Bastille Day Party\n" +
-                "END:VEVENT\n";
-
-        ICalendar.Component event = ICalendar.parseEvent(text);
-
-        assertEquals("VEVENT", event.getName());
-        assertNull(event.getComponents());
-        assertEquals(3, event.getPropertyNames().size());
-        assertEquals(1, event.getProperties("DTSTART").size());
-        assertEquals("19970714T170000", event.getFirstProperty("DTSTART").getValue());
-        assertEquals(1, event.getFirstProperty("DTSTART").getParameterNames().size());
-        assertEquals(1, event.getProperties("SUMMARY").size());
-    }
-
-    @SmallTest
-    public void testParseInvalidProperty() throws Exception {
-        String text = "BEGIN:VEVENT\n" +
-                "FOO;BAR\n" + // invalid line
-                "END:VEVENT\n";
-
-        ICalendar.Component event = ICalendar.parseEvent(text);
-
-        assertEquals("VEVENT", event.getName());
-        assertNull(event.getComponents());
-        assertEquals(0, event.getPropertyNames().size());
-    }
-
-    @SmallTest
-    public void testParseEventDoesNotStartWithBegin() throws Exception {
-        String text = "NOTBEGIN:DUMMY\n" +
-                "END:DUMMY\n";
-
-        try {
-            ICalendar.parseEvent(text);
-            fail("expected exception not thrown");
-        } catch (ICalendar.FormatException e) {
-            assertEquals("Expected " + ICalendar.Component.VEVENT, e.getMessage());
-        }
-    }
-
-    @SmallTest
-    public void testParseCalendarDoesNotStartWithBegin() throws Exception {
-        String text = "NOTBEGIN:DUMMY\n" +
-                "END:DUMMY\n";
-
-        try {
-            ICalendar.parseCalendar(text);
-            fail("expected exception not thrown");
-        } catch (ICalendar.FormatException e) {
-            assertEquals("Expected " + ICalendar.Component.VCALENDAR, e.getMessage());
-        }
-    }
-
-    @SmallTest
-    public void testParseComponentDoesNotStartWithBegin() throws Exception {
-        String text = "NOTBEGIN:DUMMY\n" +
-                "END:DUMMY\n";
-
-        ICalendar.Component component = ICalendar.parseComponent(text);
-        assertNull(component);
-    }
-    
-    @SmallTest
-    public void testParseUnexpectedEndComponent() throws Exception {
-        String text = "BEGIN:PARENT\n" +
-                "END:BADPARENT\n";
-
-        ICalendar.Component component = ICalendar.parseComponent(text);
-        assertNotNull(component);
-    }
-
-    @SmallTest
-    public void testParseNoEndComponent() throws Exception {
-        String text = "BEGIN:DUMMY\n" +
-                "END:\n";
-
-        ICalendar.Component component = ICalendar.parseComponent(text);
-        assertNotNull(component);
-    }
-
-    @SmallTest
-    public void testNormalize() throws Exception {
-        String text = "BEGIN:VEVENT\n" +
-                "RRULE:FREQ=SECONDLY;BYSECOND=0,1,2,\r\n 3,4,5\r\n ,6,7,8\r\n" +
-                "END:VEVENT\n";
-
-        ICalendar.Component event = ICalendar.parseEvent(text);
-
-        assertEquals("VEVENT", event.getName());
-        assertNull(event.getComponents());
-        assertEquals(1, event.getPropertyNames().size());
-        assertEquals(1, event.getProperties("RRULE").size());
-        assertEquals("FREQ=SECONDLY;BYSECOND=0,1,2,3,4,5,6,7,8", event.getFirstProperty("RRULE").getValue());
-
-    }
-
-    @SmallTest
-    public void testNormalizeBadSep() throws Exception {
-        String text = "BEGIN:VEVENT\n" +
-                "RRULE:FREQ=SECONDLY;BYSECOND=0,1,2,\n 3,4,5\n ,6,7,8\n" +
-                "END:VEVENT\n";
-
-        ICalendar.Component event = ICalendar.parseEvent(text);
-
-        assertEquals("VEVENT", event.getName());
-        assertNull(event.getComponents());
-        assertEquals(1, event.getPropertyNames().size());
-        assertEquals(1, event.getProperties("RRULE").size());
-        assertEquals("FREQ=SECONDLY;BYSECOND=0,1,2,3,4,5,6,7,8", event.getFirstProperty("RRULE").getValue());
-    }
-
-
-    @SmallTest
-    public void testBad() throws Exception {
-        String text = "BEGIN:VEVENT\n" +
-                "RRULE=foo\n" +
-                "END:VEVENT\n";
-
-        ICalendar.Component event = ICalendar.parseEvent(text);
-
-        // Note that parseEvent doesn't throw the FormatException you might expect because
-        // ICalendar.parseComponentImpl catches the exception due to misformatted GData.
-        // TODO: update this test after cleaning up the ICalendar behavior
-    }
-}
Index: packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/CalendarProvider2Test.java
===================================================================
--- packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/CalendarProvider2Test.java	(revision 168086)
+++ packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/CalendarProvider2Test.java	(revision 168087)
@@ -1,3127 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.calendar;
-
-import android.content.ComponentName;
-import android.content.ContentProvider;
-import android.content.ContentResolver;
-import android.content.ContentUris;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ProviderInfo;
-import android.content.res.Resources;
-import android.database.Cursor;
-import android.database.MatrixCursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.net.Uri;
-import android.provider.BaseColumns;
-import android.provider.CalendarContract;
-import android.provider.CalendarContract.Calendars;
-import android.provider.CalendarContract.Colors;
-import android.provider.CalendarContract.Events;
-import android.provider.CalendarContract.Instances;
-import android.test.AndroidTestCase;
-import android.test.IsolatedContext;
-import android.test.RenamingDelegatingContext;
-import android.test.mock.MockContentResolver;
-import android.test.mock.MockContext;
-import android.test.suitebuilder.annotation.SmallTest;
-import android.test.suitebuilder.annotation.Smoke;
-import android.test.suitebuilder.annotation.Suppress;
-import android.text.TextUtils;
-import android.text.format.DateUtils;
-import android.text.format.Time;
-import android.util.Log;
-
-import java.io.File;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-import java.util.TimeZone;
-
-/**
- * Runs various tests on an isolated Calendar provider with its own database.
- *
- * You can run the tests with the following command line:
- *
- * adb shell am instrument
- * -e debug false
- * -w
- * -e class com.android.providers.calendar.CalendarProvider2Test
- * com.android.providers.calendar.tests/android.test.InstrumentationTestRunner
- *
- * This test no longer extends ProviderTestCase2 because it actually doesn't
- * allow you to inject a custom context (which we needed to mock out the calls
- * to start a service). We the next best thing, which is copy the relevant code
- * from PTC2 and extend AndroidTestCase instead.
- */
-// flaky test, add back to LargeTest when fixed - bug 2395696
-// @LargeTest
-public class CalendarProvider2Test extends AndroidTestCase {
-    static final String TAG = "calendar";
-
-    private static final String DEFAULT_ACCOUNT_TYPE = "com.google";
-    private static final String DEFAULT_ACCOUNT = "joe@joe.com";
-
-
-    private static final String WHERE_CALENDARS_SELECTED = Calendars.VISIBLE + "=?";
-    private static final String[] WHERE_CALENDARS_ARGS = {
-        "1"
-    };
-    private static final String WHERE_COLOR_ACCOUNT_AND_INDEX = Colors.ACCOUNT_NAME + "=? AND "
-            + Colors.ACCOUNT_TYPE + "=? AND " + Colors.COLOR_KEY + "=?";
-    private static final String DEFAULT_SORT_ORDER = "begin ASC";
-
-    private CalendarProvider2ForTesting mProvider;
-    private SQLiteDatabase mDb;
-    private MetaData mMetaData;
-    private Context mContext;
-    private MockContentResolver mResolver;
-    private Uri mEventsUri = Events.CONTENT_URI;
-    private Uri mCalendarsUri = Calendars.CONTENT_URI;
-    private int mCalendarId;
-
-    protected boolean mWipe = false;
-    protected boolean mForceDtend = false;
-
-    // We need a unique id to put in the _sync_id field so that we can create
-    // recurrence exceptions that refer to recurring events.
-    private int mGlobalSyncId = 1000;
-    private static final String CALENDAR_URL =
-            "http://www.google.com/calendar/feeds/joe%40joe.com/private/full";
-
-    private static final String TIME_ZONE_AMERICA_ANCHORAGE = "America/Anchorage";
-    private static final String TIME_ZONE_AMERICA_LOS_ANGELES = "America/Los_Angeles";
-    private static final String DEFAULT_TIMEZONE = TIME_ZONE_AMERICA_LOS_ANGELES;
-
-    private static final String MOCK_TIME_ZONE_DATABASE_VERSION = "2010a";
-
-    private static final long ONE_MINUTE_MILLIS = 60*1000;
-    private static final long ONE_HOUR_MILLIS = 3600*1000;
-    private static final long ONE_WEEK_MILLIS = 7 * 24 * 3600 * 1000;
-
-    /**
-     * We need a few more stub methods so that our tests can run
-     */
-    protected class MockContext2 extends MockContext {
-
-        @Override
-        public String getPackageName() {
-            return getContext().getPackageName();
-        }
-
-        @Override
-        public Resources getResources() {
-            return getContext().getResources();
-        }
-
-        @Override
-        public File getDir(String name, int mode) {
-            // name the directory so the directory will be seperated from
-            // one created through the regular Context
-            return getContext().getDir("mockcontext2_" + name, mode);
-        }
-
-        @Override
-        public ComponentName startService(Intent service) {
-            return null;
-        }
-
-        @Override
-        public boolean stopService(Intent service) {
-            return false;
-        }
-
-        @Override
-        public PackageManager getPackageManager() {
-            return getContext().getPackageManager();
-        }
-    }
-
-    /**
-     * KeyValue is a simple class that stores a pair of strings representing
-     * a (key, value) pair.  This is used for updating events.
-     */
-    private class KeyValue {
-        String key;
-        String value;
-
-        public KeyValue(String key, String value) {
-            this.key = key;
-            this.value = value;
-        }
-    }
-
-    /**
-     * A generic command interface.  This is used to support a sequence of
-     * commands that can create events, delete or update events, and then
-     * check that the state of the database is as expected.
-     */
-    private interface Command {
-        public void execute();
-    }
-
-    /**
-     * This is used to insert a new event into the database.  The event is
-     * specified by its name (or "title").  All of the event fields (the
-     * start and end time, whether it is an all-day event, and so on) are
-     * stored in a separate table (the "mEvents" table).
-     */
-    private class Insert implements Command {
-        EventInfo eventInfo;
-
-        public Insert(String eventName) {
-            eventInfo = findEvent(eventName);
-        }
-
-        public void execute() {
-            Log.i(TAG, "insert " + eventInfo.mTitle);
-            insertEvent(mCalendarId, eventInfo);
-        }
-    }
-
-    /**
-     * This is used to delete an event, specified by the event name.
-     */
-    private class Delete implements Command {
-        String eventName;
-        String account;
-        String accountType;
-        int expected;
-
-        public Delete(String eventName, int expected, String account, String accountType) {
-            this.eventName = eventName;
-            this.expected = expected;
-            this.account = account;
-            this.accountType = accountType;
-        }
-
-        public void execute() {
-            Log.i(TAG, "delete " + eventName);
-            int rows = deleteMatchingEvents(eventName, account, accountType);
-            assertEquals(expected, rows);
-        }
-    }
-
-    /**
-     * This is used to update an event.  The values to update are specified
-     * with an array of (key, value) pairs.  Both the key and value are
-     * specified as strings.  Event fields that are not really strings (such
-     * as DTSTART which is a long) should be converted to the appropriate type
-     * but that isn't supported yet.  When needed, that can be added here
-     * by checking for specific keys and converting the associated values.
-     */
-    private class Update implements Command {
-        String eventName;
-        KeyValue[] pairs;
-
-        public Update(String eventName, KeyValue[] pairs) {
-            this.eventName = eventName;
-            this.pairs = pairs;
-        }
-
-        public void execute() {
-            Log.i(TAG, "update " + eventName);
-            if (mWipe) {
-                // Wipe instance table so it will be regenerated
-                mMetaData.clearInstanceRange();
-            }
-            ContentValues map = new ContentValues();
-            for (KeyValue pair : pairs) {
-                String value = pair.value;
-                if (CalendarContract.Events.STATUS.equals(pair.key)) {
-                    // Do type conversion for STATUS
-                    map.put(pair.key, Integer.parseInt(value));
-                } else {
-                    map.put(pair.key, value);
-                }
-            }
-            if (map.size() == 1 && map.containsKey(Events.STATUS)) {
-                updateMatchingEventsStatusOnly(eventName, map);
-            } else {
-                updateMatchingEvents(eventName, map);
-            }
-        }
-    }
-
-    /**
-     * This command queries the number of events and compares it to the given
-     * expected value.
-     */
-    private class QueryNumEvents implements Command {
-        int expected;
-
-        public QueryNumEvents(int expected) {
-            this.expected = expected;
-        }
-
-        public void execute() {
-            Cursor cursor = mResolver.query(mEventsUri, null, null, null, null);
-            assertEquals(expected, cursor.getCount());
-            cursor.close();
-        }
-    }
-
-
-    /**
-     * This command dumps the list of events to the log for debugging.
-     */
-    private class DumpEvents implements Command {
-
-        public DumpEvents() {
-        }
-
-        public void execute() {
-            Cursor cursor = mResolver.query(mEventsUri, null, null, null, null);
-            dumpCursor(cursor);
-            cursor.close();
-        }
-    }
-
-    /**
-     * This command dumps the list of instances to the log for debugging.
-     */
-    private class DumpInstances implements Command {
-        long begin;
-        long end;
-
-        public DumpInstances(String startDate, String endDate) {
-            Time time = new Time(DEFAULT_TIMEZONE);
-            time.parse3339(startDate);
-            begin = time.toMillis(false /* use isDst */);
-            time.parse3339(endDate);
-            end = time.toMillis(false /* use isDst */);
-        }
-
-        public void execute() {
-            Cursor cursor = queryInstances(begin, end);
-            dumpCursor(cursor);
-            cursor.close();
-        }
-    }
-
-    /**
-     * This command queries the number of instances and compares it to the given
-     * expected value.
-     */
-    private class QueryNumInstances implements Command {
-        int expected;
-        long begin;
-        long end;
-
-        public QueryNumInstances(String startDate, String endDate, int expected) {
-            Time time = new Time(DEFAULT_TIMEZONE);
-            time.parse3339(startDate);
-            begin = time.toMillis(false /* use isDst */);
-            time.parse3339(endDate);
-            end = time.toMillis(false /* use isDst */);
-            this.expected = expected;
-        }
-
-        public void execute() {
-            Cursor cursor = queryInstances(begin, end);
-            assertEquals(expected, cursor.getCount());
-            cursor.close();
-        }
-    }
-
-    /**
-     * When this command runs it verifies that all of the instances in the
-     * given range match the expected instances (each instance is specified by
-     * a start date).
-     * If you just want to verify that an instance exists in a given date
-     * range, use {@link VerifyInstance} instead.
-     */
-    private class VerifyAllInstances implements Command {
-        long[] instances;
-        long begin;
-        long end;
-
-        public VerifyAllInstances(String startDate, String endDate, String[] dates) {
-            Time time = new Time(DEFAULT_TIMEZONE);
-            time.parse3339(startDate);
-            begin = time.toMillis(false /* use isDst */);
-            time.parse3339(endDate);
-            end = time.toMillis(false /* use isDst */);
-
-            if (dates == null) {
-                return;
-            }
-
-            // Convert all the instance date strings to UTC milliseconds
-            int len = dates.length;
-            this.instances = new long[len];
-            int index = 0;
-            for (String instance : dates) {
-                time.parse3339(instance);
-                this.instances[index++] = time.toMillis(false /* use isDst */);
-            }
-        }
-
-        public void execute() {
-            Cursor cursor = queryInstances(begin, end);
-            int len = 0;
-            if (instances != null) {
-                len = instances.length;
-            }
-            if (len != cursor.getCount()) {
-                dumpCursor(cursor);
-            }
-            assertEquals("number of instances don't match", len, cursor.getCount());
-
-            if (instances == null) {
-                return;
-            }
-
-            int beginColumn = cursor.getColumnIndex(Instances.BEGIN);
-            while (cursor.moveToNext()) {
-                long begin = cursor.getLong(beginColumn);
-
-                // Search the list of expected instances for a matching start
-                // time.
-                boolean found = false;
-                for (long instance : instances) {
-                    if (instance == begin) {
-                        found = true;
-                        break;
-                    }
-                }
-                if (!found) {
-                    int titleColumn = cursor.getColumnIndex(Events.TITLE);
-                    int allDayColumn = cursor.getColumnIndex(Events.ALL_DAY);
-
-                    String title = cursor.getString(titleColumn);
-                    boolean allDay = cursor.getInt(allDayColumn) != 0;
-                    int flags = DateUtils.FORMAT_SHOW_DATE | DateUtils.FORMAT_NUMERIC_DATE |
-                            DateUtils.FORMAT_24HOUR;
-                    if (allDay) {
-                        flags |= DateUtils.FORMAT_UTC;
-                    } else {
-                        flags |= DateUtils.FORMAT_SHOW_TIME;
-                    }
-                    String date = DateUtils.formatDateRange(mContext, begin, begin, flags);
-                    String mesg = String.format("Test failed!"
-                            + " unexpected instance (\"%s\") at %s",
-                            title, date);
-                    Log.e(TAG, mesg);
-                }
-                if (!found) {
-                    dumpCursor(cursor);
-                }
-                assertTrue(found);
-            }
-            cursor.close();
-        }
-    }
-
-    /**
-     * When this command runs it verifies that the given instance exists in
-     * the given date range.
-     */
-    private class VerifyInstance implements Command {
-        long instance;
-        boolean allDay;
-        long begin;
-        long end;
-
-        /**
-         * Creates a command to check that the given range [startDate,endDate]
-         * contains a specific instance of an event (specified by "date").
-         *
-         * @param startDate the beginning of the date range
-         * @param endDate the end of the date range
-         * @param date the date or date-time string of an event instance
-         */
-        public VerifyInstance(String startDate, String endDate, String date) {
-            Time time = new Time(DEFAULT_TIMEZONE);
-            time.parse3339(startDate);
-            begin = time.toMillis(false /* use isDst */);
-            time.parse3339(endDate);
-            end = time.toMillis(false /* use isDst */);
-
-            // Convert the instance date string to UTC milliseconds
-            time.parse3339(date);
-            allDay = time.allDay;
-            instance = time.toMillis(false /* use isDst */);
-        }
-
-        public void execute() {
-            Cursor cursor = queryInstances(begin, end);
-            int beginColumn = cursor.getColumnIndex(Instances.BEGIN);
-            boolean found = false;
-            while (cursor.moveToNext()) {
-                long begin = cursor.getLong(beginColumn);
-
-                if (instance == begin) {
-                    found = true;
-                    break;
-                }
-            }
-            if (!found) {
-                int flags = DateUtils.FORMAT_SHOW_DATE | DateUtils.FORMAT_NUMERIC_DATE;
-                if (allDay) {
-                    flags |= DateUtils.FORMAT_UTC;
-                } else {
-                    flags |= DateUtils.FORMAT_SHOW_TIME;
-                }
-                String date = DateUtils.formatDateRange(mContext, instance, instance, flags);
-                String mesg = String.format("Test failed!"
-                        + " cannot find instance at %s",
-                        date);
-                Log.e(TAG, mesg);
-            }
-            assertTrue(found);
-            cursor.close();
-        }
-    }
-
-    /**
-     * This class stores all the useful information about an event.
-     */
-    private class EventInfo {
-        String mTitle;
-        String mDescription;
-        String mTimezone;
-        boolean mAllDay;
-        long mDtstart;
-        long mDtend;
-        String mRrule;
-        String mDuration;
-        String mOriginalTitle;
-        long mOriginalInstance;
-        int mSyncId;
-        String mCustomAppPackage;
-        String mCustomAppUri;
-        String mUid2445;
-
-        // Constructor for normal events, using the default timezone
-        public EventInfo(String title, String startDate, String endDate,
-                boolean allDay) {
-            init(title, startDate, endDate, allDay, DEFAULT_TIMEZONE);
-        }
-
-        // Constructor for normal events, specifying the timezone
-        public EventInfo(String title, String startDate, String endDate,
-                boolean allDay, String timezone) {
-            init(title, startDate, endDate, allDay, timezone);
-        }
-
-        public void init(String title, String startDate, String endDate,
-                boolean allDay, String timezone) {
-            mTitle = title;
-            Time time = new Time();
-            if (allDay) {
-                time.timezone = Time.TIMEZONE_UTC;
-            } else if (timezone != null) {
-                time.timezone = timezone;
-            }
-            mTimezone = time.timezone;
-            time.parse3339(startDate);
-            mDtstart = time.toMillis(false /* use isDst */);
-            time.parse3339(endDate);
-            mDtend = time.toMillis(false /* use isDst */);
-            mDuration = null;
-            mRrule = null;
-            mAllDay = allDay;
-            mCustomAppPackage = "CustomAppPackage-" + mTitle;
-            mCustomAppUri = "CustomAppUri-" + mTitle;
-            mUid2445 = null;
-        }
-
-        // Constructor for repeating events, using the default timezone
-        public EventInfo(String title, String description, String startDate, String endDate,
-                String rrule, boolean allDay) {
-            init(title, description, startDate, endDate, rrule, allDay, DEFAULT_TIMEZONE);
-        }
-
-        // Constructor for repeating events, specifying the timezone
-        public EventInfo(String title, String description, String startDate, String endDate,
-                String rrule, boolean allDay, String timezone) {
-            init(title, description, startDate, endDate, rrule, allDay, timezone);
-        }
-
-        public void init(String title, String description, String startDate, String endDate,
-                String rrule, boolean allDay, String timezone) {
-            mTitle = title;
-            mDescription = description;
-            Time time = new Time();
-            if (allDay) {
-                time.timezone = Time.TIMEZONE_UTC;
-            } else if (timezone != null) {
-                time.timezone = timezone;
-            }
-            mTimezone = time.timezone;
-            time.parse3339(startDate);
-            mDtstart = time.toMillis(false /* use isDst */);
-            if (endDate != null) {
-                time.parse3339(endDate);
-                mDtend = time.toMillis(false /* use isDst */);
-            }
-            if (allDay) {
-                long days = 1;
-                if (endDate != null) {
-                    days = (mDtend - mDtstart) / DateUtils.DAY_IN_MILLIS;
-                }
-                mDuration = "P" + days + "D";
-            } else {
-                long seconds = (mDtend - mDtstart) / DateUtils.SECOND_IN_MILLIS;
-                mDuration = "P" + seconds + "S";
-            }
-            mRrule = rrule;
-            mAllDay = allDay;
-        }
-
-        // Constructor for recurrence exceptions, using the default timezone
-        public EventInfo(String originalTitle, String originalInstance, String title,
-                String description, String startDate, String endDate, boolean allDay,
-                String customPackageName, String customPackageUri, String mUid2445) {
-            init(originalTitle, originalInstance,
-                    title, description, startDate, endDate, allDay, DEFAULT_TIMEZONE,
-                    customPackageName, customPackageUri, mUid2445);
-        }
-
-        public void init(String originalTitle, String originalInstance,
-                String title, String description, String startDate, String endDate,
-                boolean allDay, String timezone, String customPackageName,
-                String customPackageUri, String uid2445) {
-            mOriginalTitle = originalTitle;
-            Time time = new Time(timezone);
-            time.parse3339(originalInstance);
-            mOriginalInstance = time.toMillis(false /* use isDst */);
-            mCustomAppPackage = customPackageName;
-            mCustomAppUri = customPackageUri;
-            mUid2445 = uid2445;
-            init(title, description, startDate, endDate, null /* rrule */, allDay, timezone);
-        }
-    }
-
-    private class InstanceInfo {
-        EventInfo mEvent;
-        long mBegin;
-        long mEnd;
-        int mExpectedOccurrences;
-
-        public InstanceInfo(String eventName, String startDate, String endDate, int expected) {
-            // Find the test index that contains the given event name
-            mEvent = findEvent(eventName);
-            Time time = new Time(mEvent.mTimezone);
-            time.parse3339(startDate);
-            mBegin = time.toMillis(false /* use isDst */);
-            time.parse3339(endDate);
-            mEnd = time.toMillis(false /* use isDst */);
-            mExpectedOccurrences = expected;
-        }
-    }
-
-    /**
-     * This is the main table of events.  The events in this table are
-     * referred to by name in other places.
-     */
-    private EventInfo[] mEvents = {
-            new EventInfo("normal0", "2008-05-01T00:00:00", "2008-05-02T00:00:00", false),
-            new EventInfo("normal1", "2008-05-26T08:30:00", "2008-05-26T09:30:00", false),
-            new EventInfo("normal2", "2008-05-26T14:30:00", "2008-05-26T15:30:00", false),
-            new EventInfo("allday0", "2008-05-02T00:00:00", "2008-05-03T00:00:00", true),
-            new EventInfo("allday1", "2008-05-02T00:00:00", "2008-05-31T00:00:00", true),
-            new EventInfo("daily0", "daily from 5/1/2008 12am to 1am",
-                    "2008-05-01T00:00:00", "2008-05-01T01:00:00",
-                    "FREQ=DAILY;WKST=SU", false),
-            new EventInfo("daily1", "daily from 5/1/2008 8:30am to 9:30am until 5/3/2008 8am",
-                    "2008-05-01T08:30:00", "2008-05-01T09:30:00",
-                    "FREQ=DAILY;UNTIL=20080503T150000Z;WKST=SU", false),
-            new EventInfo("daily2", "daily from 5/1/2008 8:45am to 9:15am until 5/3/2008 10am",
-                    "2008-05-01T08:45:00", "2008-05-01T09:15:00",
-                    "FREQ=DAILY;UNTIL=20080503T170000Z;WKST=SU", false),
-            new EventInfo("allday daily0", "all-day daily from 5/1/2008",
-                    "2008-05-01", null,
-                    "FREQ=DAILY;WKST=SU", true),
-            new EventInfo("allday daily1", "all-day daily from 5/1/2008 until 5/3/2008",
-                    "2008-05-01", null,
-                    "FREQ=DAILY;UNTIL=20080503T000000Z;WKST=SU", true),
-            new EventInfo("allday weekly0", "all-day weekly from 5/1/2008",
-                    "2008-05-01", null,
-                    "FREQ=WEEKLY;WKST=SU", true),
-            new EventInfo("allday weekly1", "all-day for 2 days weekly from 5/1/2008",
-                    "2008-05-01", "2008-05-03",
-                    "FREQ=WEEKLY;WKST=SU", true),
-            new EventInfo("allday yearly0", "all-day yearly on 5/1/2008",
-                    "2008-05-01T", null,
-                    "FREQ=YEARLY;WKST=SU", true),
-            new EventInfo("weekly0", "weekly from 5/6/2008 on Tue 1pm to 2pm",
-                    "2008-05-06T13:00:00", "2008-05-06T14:00:00",
-                    "FREQ=WEEKLY;BYDAY=TU;WKST=MO", false),
-            new EventInfo("weekly1", "every 2 weeks from 5/6/2008 on Tue from 2:30pm to 3:30pm",
-                    "2008-05-06T14:30:00", "2008-05-06T15:30:00",
-                    "FREQ=WEEKLY;INTERVAL=2;BYDAY=TU;WKST=MO", false),
-            new EventInfo("monthly0", "monthly from 5/20/2008 on the 3rd Tues from 3pm to 4pm",
-                    "2008-05-20T15:00:00", "2008-05-20T16:00:00",
-                    "FREQ=MONTHLY;BYDAY=3TU;WKST=SU", false),
-            new EventInfo("monthly1", "monthly from 5/1/2008 on the 1st from 12:00am to 12:10am",
-                    "2008-05-01T00:00:00", "2008-05-01T00:10:00",
-                    "FREQ=MONTHLY;WKST=SU;BYMONTHDAY=1", false),
-            new EventInfo("monthly2", "monthly from 5/31/2008 on the 31st 11pm to midnight",
-                    "2008-05-31T23:00:00", "2008-06-01T00:00:00",
-                    "FREQ=MONTHLY;WKST=SU;BYMONTHDAY=31", false),
-            new EventInfo("daily0", "2008-05-01T00:00:00",
-                    "except0", "daily0 exception for 5/1/2008 12am, change to 5/1/2008 2am to 3am",
-                    "2008-05-01T02:00:00", "2008-05-01T01:03:00", false, "AppPkg1", "AppUri1",
-                    "uid2445-1"),
-            new EventInfo("daily0", "2008-05-03T00:00:00",
-                    "except1", "daily0 exception for 5/3/2008 12am, change to 5/3/2008 2am to 3am",
-                    "2008-05-03T02:00:00", "2008-05-03T01:03:00", false, "AppPkg2", "AppUri2",
-                    null),
-            new EventInfo("daily0", "2008-05-02T00:00:00",
-                    "except2", "daily0 exception for 5/2/2008 12am, change to 1/2/2008",
-                    "2008-01-02T00:00:00", "2008-01-02T01:00:00", false, "AppPkg3", "AppUri3",
-                    "12345@uid2445"),
-            new EventInfo("weekly0", "2008-05-13T13:00:00",
-                    "except3", "daily0 exception for 5/11/2008 1pm, change to 12/11/2008 1pm",
-                    "2008-12-11T13:00:00", "2008-12-11T14:00:00", false, "AppPkg4", "AppUri4",
-                    null),
-            new EventInfo("weekly0", "2008-05-13T13:00:00",
-                    "cancel0", "weekly0 exception for 5/13/2008 1pm",
-                    "2008-05-13T13:00:00", "2008-05-13T14:00:00", false, "AppPkg5", "AppUri5",
-                    null),
-            new EventInfo("yearly0", "yearly on 5/1/2008 from 1pm to 2pm",
-                    "2008-05-01T13:00:00", "2008-05-01T14:00:00",
-                    "FREQ=YEARLY;WKST=SU", false),
-    };
-
-    /**
-     * This table is used to verify the events generated by mEvents.  It checks that the
-     * number of instances within a given range matches the expected number
-     * of instances.
-     */
-    private InstanceInfo[] mInstanceRanges = {
-            new InstanceInfo("daily0", "2008-05-01T00:00:00", "2008-05-01T00:01:00", 1),
-            new InstanceInfo("daily0", "2008-05-01T00:00:00", "2008-05-01T01:00:00", 1),
-            new InstanceInfo("daily0", "2008-05-01T00:00:00", "2008-05-02T00:00:00", 2),
-            new InstanceInfo("daily0", "2008-05-01T00:00:00", "2008-05-02T23:59:00", 2),
-            new InstanceInfo("daily0", "2008-05-02T00:00:00", "2008-05-02T00:01:00", 1),
-            new InstanceInfo("daily0", "2008-05-02T00:00:00", "2008-05-02T01:00:00", 1),
-            new InstanceInfo("daily0", "2008-05-02T00:00:00", "2008-05-03T00:00:00", 2),
-            new InstanceInfo("daily0", "2008-05-01T00:00:00", "2008-05-31T23:59:00", 31),
-            new InstanceInfo("daily0", "2008-05-01T00:00:00", "2008-06-01T23:59:00", 32),
-
-            new InstanceInfo("daily1", "2008-05-01T00:00:00", "2008-05-02T00:00:00", 1),
-            new InstanceInfo("daily1", "2008-05-01T00:00:00", "2008-05-31T23:59:00", 2),
-
-            new InstanceInfo("daily2", "2008-05-01T00:00:00", "2008-05-02T00:00:00", 1),
-            new InstanceInfo("daily2", "2008-05-01T00:00:00", "2008-05-31T23:59:00", 3),
-
-            new InstanceInfo("allday daily0", "2008-05-01", "2008-05-07", 7),
-            new InstanceInfo("allday daily1", "2008-05-01", "2008-05-07", 3),
-            new InstanceInfo("allday weekly0", "2008-05-01", "2008-05-07", 1),
-            new InstanceInfo("allday weekly0", "2008-05-01", "2008-05-08", 2),
-            new InstanceInfo("allday weekly0", "2008-05-01", "2008-05-31", 5),
-            new InstanceInfo("allday weekly1", "2008-05-01", "2008-05-31", 5),
-            new InstanceInfo("allday yearly0", "2008-05-01", "2009-04-30", 1),
-            new InstanceInfo("allday yearly0", "2008-05-01", "2009-05-02", 2),
-
-            new InstanceInfo("weekly0", "2008-05-01T00:00:00", "2008-05-02T00:00:00", 0),
-            new InstanceInfo("weekly0", "2008-05-06T00:00:00", "2008-05-07T00:00:00", 1),
-            new InstanceInfo("weekly0", "2008-05-01T00:00:00", "2008-05-31T00:00:00", 4),
-            new InstanceInfo("weekly0", "2008-05-01T00:00:00", "2008-06-30T00:00:00", 8),
-
-            new InstanceInfo("weekly1", "2008-05-01T00:00:00", "2008-05-02T00:00:00", 0),
-            new InstanceInfo("weekly1", "2008-05-06T00:00:00", "2008-05-07T00:00:00", 1),
-            new InstanceInfo("weekly1", "2008-05-01T00:00:00", "2008-05-31T00:00:00", 2),
-            new InstanceInfo("weekly1", "2008-05-01T00:00:00", "2008-06-30T00:00:00", 4),
-
-            new InstanceInfo("monthly0", "2008-05-01T00:00:00", "2008-05-20T13:00:00", 0),
-            new InstanceInfo("monthly0", "2008-05-01T00:00:00", "2008-05-20T15:00:00", 1),
-            new InstanceInfo("monthly0", "2008-05-20T16:01:00", "2008-05-31T00:00:00", 0),
-            new InstanceInfo("monthly0", "2008-05-20T16:01:00", "2008-06-17T14:59:00", 0),
-            new InstanceInfo("monthly0", "2008-05-20T16:01:00", "2008-06-17T15:00:00", 1),
-            new InstanceInfo("monthly0", "2008-05-01T00:00:00", "2008-05-31T00:00:00", 1),
-            new InstanceInfo("monthly0", "2008-05-01T00:00:00", "2008-06-30T00:00:00", 2),
-
-            new InstanceInfo("monthly1", "2008-05-01T00:00:00", "2008-05-01T01:00:00", 1),
-            new InstanceInfo("monthly1", "2008-05-01T00:00:00", "2008-05-31T00:00:00", 1),
-            new InstanceInfo("monthly1", "2008-05-01T00:10:00", "2008-05-31T23:59:00", 1),
-            new InstanceInfo("monthly1", "2008-05-01T00:11:00", "2008-05-31T23:59:00", 0),
-            new InstanceInfo("monthly1", "2008-05-01T00:00:00", "2008-06-01T00:00:00", 2),
-
-            new InstanceInfo("monthly2", "2008-05-01T00:00:00", "2008-05-31T00:00:00", 0),
-            new InstanceInfo("monthly2", "2008-05-01T00:10:00", "2008-05-31T23:00:00", 1),
-            new InstanceInfo("monthly2", "2008-05-01T00:00:00", "2008-07-01T00:00:00", 1),
-            new InstanceInfo("monthly2", "2008-05-01T00:00:00", "2008-08-01T00:00:00", 2),
-
-            new InstanceInfo("yearly0", "2008-05-01", "2009-04-30", 1),
-            new InstanceInfo("yearly0", "2008-05-01", "2009-05-02", 2),
-    };
-
-    /**
-     * This sequence of commands inserts and deletes some events.
-     */
-    private Command[] mNormalInsertDelete = {
-            new Insert("normal0"),
-            new Insert("normal1"),
-            new Insert("normal2"),
-            new QueryNumInstances("2008-05-01T00:00:00", "2008-05-31T00:01:00", 3),
-            new Delete("normal1", 1, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE),
-            new QueryNumEvents(2),
-            new QueryNumInstances("2008-05-01T00:00:00", "2008-05-31T00:01:00", 2),
-            new Delete("normal1", 0, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE),
-            new Delete("normal2", 1, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE),
-            new QueryNumEvents(1),
-            new Delete("normal0", 1, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE),
-            new QueryNumEvents(0),
-    };
-
-    /**
-     * This sequence of commands inserts and deletes some all-day events.
-     */
-    private Command[] mAlldayInsertDelete = {
-            new Insert("allday0"),
-            new Insert("allday1"),
-            new QueryNumEvents(2),
-            new QueryNumInstances("2008-05-01T00:00:00", "2008-05-01T00:01:00", 0),
-            new QueryNumInstances("2008-05-02T00:00:00", "2008-05-02T00:01:00", 2),
-            new QueryNumInstances("2008-05-03T00:00:00", "2008-05-03T00:01:00", 1),
-            new Delete("allday0", 1, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE),
-            new QueryNumEvents(1),
-            new QueryNumInstances("2008-05-02T00:00:00", "2008-05-02T00:01:00", 1),
-            new QueryNumInstances("2008-05-03T00:00:00", "2008-05-03T00:01:00", 1),
-            new Delete("allday1", 1, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE),
-            new QueryNumEvents(0),
-    };
-
-    /**
-     * This sequence of commands inserts and deletes some repeating events.
-     */
-    private Command[] mRecurringInsertDelete = {
-            new Insert("daily0"),
-            new Insert("daily1"),
-            new QueryNumEvents(2),
-            new QueryNumInstances("2008-05-01T00:00:00", "2008-05-02T00:01:00", 3),
-            new QueryNumInstances("2008-05-01T01:01:00", "2008-05-02T00:01:00", 2),
-            new QueryNumInstances("2008-05-01T00:00:00", "2008-05-04T00:01:00", 6),
-            new Delete("daily1", 1, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE),
-            new QueryNumEvents(1),
-            new QueryNumInstances("2008-05-01T00:00:00", "2008-05-02T00:01:00", 2),
-            new QueryNumInstances("2008-05-01T00:00:00", "2008-05-04T00:01:00", 4),
-            new Delete("daily0", 1, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE),
-            new QueryNumEvents(0),
-    };
-
-    /**
-     * This sequence of commands creates a recurring event with a recurrence
-     * exception that moves an event outside the expansion window.  It checks that the
-     * recurrence exception does not occur in the Instances database table.
-     * Bug 1642665
-     */
-    private Command[] mExceptionWithMovedRecurrence = {
-            new Insert("daily0"),
-            new VerifyAllInstances("2008-05-01T00:00:00", "2008-05-03T00:01:00",
-                    new String[] {"2008-05-01T00:00:00", "2008-05-02T00:00:00",
-                            "2008-05-03T00:00:00", }),
-            new Insert("except2"),
-            new VerifyAllInstances("2008-05-01T00:00:00", "2008-05-03T00:01:00",
-                    new String[] {"2008-05-01T00:00:00", "2008-05-03T00:00:00"}),
-    };
-
-    /**
-     * This sequence of commands deletes (cancels) one instance of a recurrence.
-     */
-    private Command[] mCancelInstance = {
-            new Insert("weekly0"),
-            new VerifyAllInstances("2008-05-01T00:00:00", "2008-05-22T00:01:00",
-                    new String[] {"2008-05-06T13:00:00", "2008-05-13T13:00:00",
-                            "2008-05-20T13:00:00", }),
-            new Insert("cancel0"),
-            new Update("cancel0", new KeyValue[] {
-                    new KeyValue(CalendarContract.Events.STATUS,
-                        Integer.toString(CalendarContract.Events.STATUS_CANCELED)),
-            }),
-            new VerifyAllInstances("2008-05-01T00:00:00", "2008-05-22T00:01:00",
-                    new String[] {"2008-05-06T13:00:00",
-                            "2008-05-20T13:00:00", }),
-    };
-    /**
-     * This sequence of commands creates a recurring event with a recurrence
-     * exception that moves an event from outside the expansion window into the
-     * expansion window.
-     */
-    private Command[] mExceptionWithMovedRecurrence2 = {
-            new Insert("weekly0"),
-            new VerifyAllInstances("2008-12-01T00:00:00", "2008-12-22T00:01:00",
-                    new String[] {"2008-12-02T13:00:00", "2008-12-09T13:00:00",
-                            "2008-12-16T13:00:00", }),
-            new Insert("except3"),
-            new VerifyAllInstances("2008-12-01T00:00:00", "2008-12-22T00:01:00",
-                    new String[] {"2008-12-02T13:00:00", "2008-12-09T13:00:00",
-                            "2008-12-11T13:00:00", "2008-12-16T13:00:00", }),
-    };
-    /**
-     * This sequence of commands creates a recurring event with a recurrence
-     * exception and then changes the end time of the recurring event.  It then
-     * checks that the recurrence exception does not occur in the Instances
-     * database table.
-     */
-    private Command[]
-            mExceptionWithTruncatedRecurrence = {
-            new Insert("daily0"),
-            // Verify 4 occurrences of the "daily0" repeating event
-            new VerifyAllInstances("2008-05-01T00:00:00", "2008-05-04T00:01:00",
-                    new String[] {"2008-05-01T00:00:00", "2008-05-02T00:00:00",
-                            "2008-05-03T00:00:00", "2008-05-04T00:00:00"}),
-            new Insert("except1"),
-            new QueryNumEvents(2),
-
-            // Verify that one of the 4 occurrences has its start time changed
-            // so that it now matches the recurrence exception.
-            new VerifyAllInstances("2008-05-01T00:00:00", "2008-05-04T00:01:00",
-                    new String[] {"2008-05-01T00:00:00", "2008-05-02T00:00:00",
-                            "2008-05-03T02:00:00", "2008-05-04T00:00:00"}),
-
-            // Change the end time of "daily0" but it still includes the
-            // recurrence exception.
-            new Update("daily0", new KeyValue[] {
-                    new KeyValue(Events.RRULE, "FREQ=DAILY;UNTIL=20080505T150000Z;WKST=SU"),
-            }),
-
-            // Verify that the recurrence exception is still there
-            new VerifyAllInstances("2008-05-01T00:00:00", "2008-05-04T00:01:00",
-                    new String[] {"2008-05-01T00:00:00", "2008-05-02T00:00:00",
-                            "2008-05-03T02:00:00", "2008-05-04T00:00:00"}),
-            // This time change the end time of "daily0" so that it excludes
-            // the recurrence exception.
-            new Update("daily0", new KeyValue[] {
-                    new KeyValue(Events.RRULE, "FREQ=DAILY;UNTIL=20080502T150000Z;WKST=SU"),
-            }),
-            // The server will cancel the out-of-range exception.
-            // It would be nice for the provider to handle this automatically,
-            // but for now simulate the server-side cancel.
-            new Update("except1", new KeyValue[] {
-                new KeyValue(CalendarContract.Events.STATUS,
-                        Integer.toString(CalendarContract.Events.STATUS_CANCELED)),
-            }),
-            // Verify that the recurrence exception does not appear.
-            new VerifyAllInstances("2008-05-01T00:00:00", "2008-05-04T00:01:00",
-                    new String[] {"2008-05-01T00:00:00", "2008-05-02T00:00:00"}),
-    };
-
-    /**
-     * Bug 135848.  Ensure that a recurrence exception is displayed even if the recurrence
-     * is not present.
-     */
-    private Command[] mExceptionWithNoRecurrence = {
-            new Insert("except0"),
-            new QueryNumEvents(1),
-            new VerifyAllInstances("2008-05-01T00:00:00", "2008-05-03T00:01:00",
-                    new String[] {"2008-05-01T02:00:00"}),
-    };
-
-    private EventInfo findEvent(String name) {
-        int len = mEvents.length;
-        for (int ii = 0; ii < len; ii++) {
-            EventInfo event = mEvents[ii];
-            if (name.equals(event.mTitle)) {
-                return event;
-            }
-        }
-        return null;
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        // This code here is the code that was originally in ProviderTestCase2
-        mResolver = new MockContentResolver();
-
-        final String filenamePrefix = "test.";
-        RenamingDelegatingContext targetContextWrapper = new RenamingDelegatingContext(
-                new MockContext2(), // The context that most methods are delegated to
-                getContext(), // The context that file methods are delegated to
-                filenamePrefix);
-        mContext = new IsolatedContext(mResolver, targetContextWrapper) {
-            @Override
-            public Object getSystemService(String name) {
-                // for accessing wakelock.
-                if (Context.POWER_SERVICE.equals(name)) {
-                    return getContext().getSystemService(name);
-                }
-                return super.getSystemService(name);
-            }
-        };
-
-        mProvider = new CalendarProvider2ForTesting();
-        ProviderInfo info = new ProviderInfo();
-        info.authority = CalendarContract.AUTHORITY;
-        mProvider.attachInfoForTesting(mContext, info);
-
-        mResolver.addProvider(CalendarContract.AUTHORITY, mProvider);
-        mResolver.addProvider("subscribedfeeds", new MockProvider("subscribedfeeds"));
-        mResolver.addProvider("sync", new MockProvider("sync"));
-
-        mMetaData = getProvider().mMetaData;
-        mForceDtend = false;
-
-        CalendarDatabaseHelper helper = (CalendarDatabaseHelper) getProvider().getDatabaseHelper();
-        mDb = helper.getWritableDatabase();
-        wipeAndInitData(helper, mDb);
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        try {
-            mDb.close();
-            mDb = null;
-            getProvider().getDatabaseHelper().close();
-        } catch (IllegalStateException e) {
-            e.printStackTrace();
-        }
-        super.tearDown();
-    }
-
-    public void wipeAndInitData(SQLiteOpenHelper helper, SQLiteDatabase db)
-            throws CalendarCache.CacheException {
-        db.beginTransaction();
-
-        // Clean tables
-        db.delete("Calendars", null, null);
-        db.delete("Events", null, null);
-        db.delete("EventsRawTimes", null, null);
-        db.delete("Instances", null, null);
-        db.delete("CalendarMetaData", null, null);
-        db.delete("CalendarCache", null, null);
-        db.delete("Attendees", null, null);
-        db.delete("Reminders", null, null);
-        db.delete("CalendarAlerts", null, null);
-        db.delete("ExtendedProperties", null, null);
-
-        // Set CalendarCache data
-        initCalendarCacheLocked(helper, db);
-
-        // set CalendarMetaData data
-        long now = System.currentTimeMillis();
-        ContentValues values = new ContentValues();
-        values.put("localTimezone", "America/Los_Angeles");
-        values.put("minInstance", 1207008000000L); // 1st April 2008
-        values.put("maxInstance", now + ONE_WEEK_MILLIS);
-        db.insert("CalendarMetaData", null, values);
-
-        db.setTransactionSuccessful();
-        db.endTransaction();
-    }
-
-    private void initCalendarCacheLocked(SQLiteOpenHelper helper, SQLiteDatabase db)
-            throws CalendarCache.CacheException {
-        CalendarCache cache = new CalendarCache(helper);
-
-        String localTimezone = TimeZone.getDefault().getID();
-
-        // Set initial values
-        cache.writeDataLocked(db, CalendarCache.KEY_TIMEZONE_DATABASE_VERSION, "2010k");
-        cache.writeDataLocked(db, CalendarCache.KEY_TIMEZONE_TYPE, CalendarCache.TIMEZONE_TYPE_AUTO);
-        cache.writeDataLocked(db, CalendarCache.KEY_TIMEZONE_INSTANCES, localTimezone);
-        cache.writeDataLocked(db, CalendarCache.KEY_TIMEZONE_INSTANCES_PREVIOUS, localTimezone);
-    }
-
-    protected CalendarProvider2ForTesting getProvider() {
-        return mProvider;
-    }
-
-    /**
-     * Dumps the contents of the given cursor to the log.  For debugging.
-     * @param cursor the database cursor
-     */
-    private void dumpCursor(Cursor cursor) {
-        cursor.moveToPosition(-1);
-        String[] cols = cursor.getColumnNames();
-
-        Log.i(TAG, "dumpCursor() count: " + cursor.getCount());
-        int index = 0;
-        while (cursor.moveToNext()) {
-            Log.i(TAG, index + " {");
-            for (int i = 0; i < cols.length; i++) {
-                Log.i(TAG, "    " + cols[i] + '=' + cursor.getString(i));
-            }
-            Log.i(TAG, "}");
-            index += 1;
-        }
-        cursor.moveToPosition(-1);
-    }
-
-    private int insertCal(String name, String timezone) {
-        return insertCal(name, timezone, DEFAULT_ACCOUNT);
-    }
-
-    /**
-     * Creates a new calendar, with the provided name, time zone, and account name.
-     *
-     * @return the new calendar's _ID value
-     */
-    private int insertCal(String name, String timezone, String account) {
-        ContentValues m = new ContentValues();
-        m.put(Calendars.NAME, name);
-        m.put(Calendars.CALENDAR_DISPLAY_NAME, name);
-        m.put(Calendars.CALENDAR_COLOR, 0xff123456);
-        m.put(Calendars.CALENDAR_TIME_ZONE, timezone);
-        m.put(Calendars.VISIBLE, 1);
-        m.put(Calendars.CAL_SYNC1, CALENDAR_URL);
-        m.put(Calendars.OWNER_ACCOUNT, account);
-        m.put(Calendars.ACCOUNT_NAME,  account);
-        m.put(Calendars.ACCOUNT_TYPE, DEFAULT_ACCOUNT_TYPE);
-        m.put(Calendars.SYNC_EVENTS,  1);
-
-        Uri url = mResolver.insert(
-                addSyncQueryParams(mCalendarsUri, account, DEFAULT_ACCOUNT_TYPE), m);
-        String id = url.getLastPathSegment();
-        return Integer.parseInt(id);
-    }
-
-    private String obsToString(Object... objs) {
-        StringBuilder bob = new StringBuilder();
-
-        for (Object obj : objs) {
-            bob.append(obj.toString());
-            bob.append('#');
-        }
-
-        return bob.toString();
-    }
-
-    private Uri insertColor(long colorType, String colorKey, long color) {
-        ContentValues m = new ContentValues();
-        m.put(Colors.ACCOUNT_NAME, DEFAULT_ACCOUNT);
-        m.put(Colors.ACCOUNT_TYPE, DEFAULT_ACCOUNT_TYPE);
-        m.put(Colors.DATA, obsToString(colorType, colorKey, color));
-        m.put(Colors.COLOR_TYPE, colorType);
-        m.put(Colors.COLOR_KEY, colorKey);
-        m.put(Colors.COLOR, color);
-
-        Uri uri = CalendarContract.Colors.CONTENT_URI;
-
-        return mResolver.insert(addSyncQueryParams(uri, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE), m);
-    }
-
-    private void updateAndCheckColor(long colorId, long colorType, String colorKey, long color) {
-
-        Uri uri = CalendarContract.Colors.CONTENT_URI;
-
-        final String where = Colors.ACCOUNT_NAME + "=? AND " + Colors.ACCOUNT_TYPE + "=? AND "
-                + Colors.COLOR_TYPE + "=? AND " + Colors.COLOR_KEY + "=?";
-
-        String[] selectionArgs = new String[] {
-                DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE, Long.toString(colorType), colorKey
-        };
-
-        ContentValues cv = new ContentValues();
-        cv.put(Colors.COLOR, color);
-        cv.put(Colors.DATA, obsToString(colorType, colorKey, color));
-
-        int count = mResolver.update(
-                addSyncQueryParams(uri, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE), cv, where,
-                selectionArgs);
-
-        checkColor(colorId, colorType, colorKey, color);
-
-        assertEquals(1, count);
-    }
-
-    /**
-     * Constructs a URI from a base URI (e.g. "content://com.android.calendar/calendars"),
-     * an account name, and an account type.
-     */
-    private Uri addSyncQueryParams(Uri uri, String account, String accountType) {
-        return uri.buildUpon().appendQueryParameter(CalendarContract.CALLER_IS_SYNCADAPTER, "true")
-                .appendQueryParameter(Calendars.ACCOUNT_NAME, account)
-                .appendQueryParameter(Calendars.ACCOUNT_TYPE, accountType).build();
-    }
-
-    private int deleteMatchingCalendars(String selection, String[] selectionArgs) {
-        return mResolver.delete(mCalendarsUri, selection, selectionArgs);
-    }
-
-    private Uri insertEvent(int calId, EventInfo event) {
-        return insertEvent(calId, event, null);
-    }
-
-    private Uri insertEvent(int calId, EventInfo event, ContentValues cv) {
-        if (mWipe) {
-            // Wipe instance table so it will be regenerated
-            mMetaData.clearInstanceRange();
-        }
-
-        if (cv == null) {
-            cv = eventInfoToContentValues(calId, event);
-        }
-
-        Uri url = mResolver.insert(mEventsUri, cv);
-
-        // Create a fake _sync_id and add it to the event.  Update the database
-        // directly so that we don't trigger any validation checks in the
-        // CalendarProvider.
-        long id = ContentUris.parseId(url);
-        mDb.execSQL("UPDATE Events SET _sync_id=" + mGlobalSyncId + " WHERE _id=" + id);
-        event.mSyncId = mGlobalSyncId;
-        mGlobalSyncId += 1;
-
-        return url;
-    }
-
-    private ContentValues eventInfoToContentValues(int calId, EventInfo event) {
-        ContentValues m = new ContentValues();
-        m.put(Events.CALENDAR_ID, calId);
-        m.put(Events.TITLE, event.mTitle);
-        m.put(Events.DTSTART, event.mDtstart);
-        m.put(Events.ALL_DAY, event.mAllDay ? 1 : 0);
-
-        if (event.mRrule == null || mForceDtend) {
-            // This is a normal event
-            m.put(Events.DTEND, event.mDtend);
-            m.remove(Events.DURATION);
-        }
-        if (event.mRrule != null) {
-            // This is a repeating event
-            m.put(Events.RRULE, event.mRrule);
-            m.put(Events.DURATION, event.mDuration);
-            m.remove(Events.DTEND);
-        }
-
-        if (event.mDescription != null) {
-            m.put(Events.DESCRIPTION, event.mDescription);
-        }
-        if (event.mTimezone != null) {
-            m.put(Events.EVENT_TIMEZONE, event.mTimezone);
-        }
-        if (event.mCustomAppPackage != null) {
-            m.put(Events.CUSTOM_APP_PACKAGE, event.mCustomAppPackage);
-        }
-        if (event.mCustomAppUri != null) {
-            m.put(Events.CUSTOM_APP_URI, event.mCustomAppUri);
-        }
-        if (event.mUid2445 != null) {
-            m.put(Events.UID_2445, event.mUid2445);
-        }
-
-        if (event.mOriginalTitle != null) {
-            // This is a recurrence exception.
-            EventInfo recur = findEvent(event.mOriginalTitle);
-            assertNotNull(recur);
-            String syncId = String.format("%d", recur.mSyncId);
-            m.put(Events.ORIGINAL_SYNC_ID, syncId);
-            m.put(Events.ORIGINAL_ALL_DAY, recur.mAllDay ? 1 : 0);
-            m.put(Events.ORIGINAL_INSTANCE_TIME, event.mOriginalInstance);
-        }
-        return m;
-    }
-
-    /**
-     * Deletes all the events that match the given title.
-     * @param title the given title to match events on
-     * @return the number of rows deleted
-     */
-    private int deleteMatchingEvents(String title, String account, String accountType) {
-        Cursor cursor = mResolver.query(mEventsUri, new String[] { Events._ID },
-                "title=?", new String[] { title }, null);
-        int numRows = 0;
-        while (cursor.moveToNext()) {
-            long id = cursor.getLong(0);
-            // Do delete as a sync adapter so event is really deleted, not just marked
-            // as deleted.
-            Uri uri = updatedUri(ContentUris.withAppendedId(Events.CONTENT_URI, id), true, account,
-                    accountType);
-            numRows += mResolver.delete(uri, null, null);
-        }
-        cursor.close();
-        return numRows;
-    }
-
-    /**
-     * Updates all the events that match the given title.
-     * @param title the given title to match events on
-     * @return the number of rows updated
-     */
-    private int updateMatchingEvents(String title, ContentValues values) {
-        String[] projection = new String[] {
-                Events._ID,
-                Events.DTSTART,
-                Events.DTEND,
-                Events.DURATION,
-                Events.ALL_DAY,
-                Events.RRULE,
-                Events.EVENT_TIMEZONE,
-                Events.ORIGINAL_SYNC_ID,
-        };
-        Cursor cursor = mResolver.query(mEventsUri, projection,
-                "title=?", new String[] { title }, null);
-        int numRows = 0;
-        while (cursor.moveToNext()) {
-            long id = cursor.getLong(0);
-
-            // If any of the following fields are being changed, then we need
-            // to include all of them.
-            if (values.containsKey(Events.DTSTART) || values.containsKey(Events.DTEND)
-                    || values.containsKey(Events.DURATION) || values.containsKey(Events.ALL_DAY)
-                    || values.containsKey(Events.RRULE)
-                    || values.containsKey(Events.EVENT_TIMEZONE)
-                    || values.containsKey(CalendarContract.Events.STATUS)) {
-                long dtstart = cursor.getLong(1);
-                long dtend = cursor.getLong(2);
-                String duration = cursor.getString(3);
-                boolean allDay = cursor.getInt(4) != 0;
-                String rrule = cursor.getString(5);
-                String timezone = cursor.getString(6);
-                String originalEvent = cursor.getString(7);
-
-                if (!values.containsKey(Events.DTSTART)) {
-                    values.put(Events.DTSTART, dtstart);
-                }
-                // Don't add DTEND for repeating events
-                if (!values.containsKey(Events.DTEND) && rrule == null) {
-                    values.put(Events.DTEND, dtend);
-                }
-                if (!values.containsKey(Events.DURATION) && duration != null) {
-                    values.put(Events.DURATION, duration);
-                }
-                if (!values.containsKey(Events.ALL_DAY)) {
-                    values.put(Events.ALL_DAY, allDay ? 1 : 0);
-                }
-                if (!values.containsKey(Events.RRULE) && rrule != null) {
-                    values.put(Events.RRULE, rrule);
-                }
-                if (!values.containsKey(Events.EVENT_TIMEZONE) && timezone != null) {
-                    values.put(Events.EVENT_TIMEZONE, timezone);
-                }
-                if (!values.containsKey(Events.ORIGINAL_SYNC_ID) && originalEvent != null) {
-                    values.put(Events.ORIGINAL_SYNC_ID, originalEvent);
-                }
-            }
-
-            Uri uri = ContentUris.withAppendedId(Events.CONTENT_URI, id);
-            numRows += mResolver.update(uri, values, null, null);
-        }
-        cursor.close();
-        return numRows;
-    }
-
-    /**
-     * Updates the status of all the events that match the given title.
-     * @param title the given title to match events on
-     * @return the number of rows updated
-     */
-    private int updateMatchingEventsStatusOnly(String title, ContentValues values) {
-        String[] projection = new String[] {
-                Events._ID,
-        };
-        if (values.size() != 1 && !values.containsKey(Events.STATUS)) {
-            return 0;
-        }
-        Cursor cursor = mResolver.query(mEventsUri, projection,
-                "title=?", new String[] { title }, null);
-        int numRows = 0;
-        while (cursor.moveToNext()) {
-            long id = cursor.getLong(0);
-
-            Uri uri = ContentUris.withAppendedId(Events.CONTENT_URI, id);
-            numRows += mResolver.update(uri, values, null, null);
-        }
-        cursor.close();
-        return numRows;
-    }
-
-
-    private void deleteAllEvents() {
-        mDb.execSQL("DELETE FROM Events;");
-        mMetaData.clearInstanceRange();
-    }
-
-    /**
-     * Creates an updated URI that includes query parameters that identify the source as a
-     * sync adapter.
-     */
-    static Uri asSyncAdapter(Uri uri, String account, String accountType) {
-        return uri.buildUpon()
-                .appendQueryParameter(android.provider.CalendarContract.CALLER_IS_SYNCADAPTER,
-                        "true")
-                .appendQueryParameter(Calendars.ACCOUNT_NAME, account)
-                .appendQueryParameter(Calendars.ACCOUNT_TYPE, accountType).build();
-    }
-
-    public void testInsertUpdateDeleteColor() throws Exception {
-        // Calendar Color
-        long colorType = Colors.TYPE_CALENDAR;
-        String colorKey = "123";
-        long colorValue = 11;
-        long colorId = insertAndCheckColor(colorType, colorKey, colorValue);
-
-        try {
-            insertAndCheckColor(colorType, colorKey, colorValue);
-            fail("Expected to fail with duplicate insertion");
-        } catch (IllegalArgumentException iae) {
-            // good
-        }
-
-        // Test Update
-        colorValue += 11;
-        updateAndCheckColor(colorId, colorType, colorKey, colorValue);
-
-        // Event Color
-        colorType = Colors.TYPE_EVENT;
-        colorValue += 11;
-        colorId = insertAndCheckColor(colorType, colorKey, colorValue);
-        try {
-            insertAndCheckColor(colorType, colorKey, colorValue);
-            fail("Expected to fail with duplicate insertion");
-        } catch (IllegalArgumentException iae) {
-            // good
-        }
-
-        // Create an event with the old color value.
-        int calendarId0 = insertCal("Calendar0", DEFAULT_TIMEZONE);
-        String title = "colorTest";
-        ContentValues cv = this.eventInfoToContentValues(calendarId0, mEvents[0]);
-        cv.put(Events.EVENT_COLOR_KEY, colorKey);
-        cv.put(Events.TITLE, title);
-        Uri uri = insertEvent(calendarId0, mEvents[0], cv);
-        Cursor c = mResolver.query(uri, new String[] {Events.EVENT_COLOR},  null, null, null);
-        try {
-            // Confirm the color is set.
-            c.moveToFirst();
-            assertEquals(colorValue, c.getInt(0));
-        } finally {
-            if (c != null) {
-                c.close();
-            }
-        }
-
-        // Test Update
-        colorValue += 11;
-        updateAndCheckColor(colorId, colorType, colorKey, colorValue);
-
-        // Check if color was updated in event.
-        c = mResolver.query(uri, new String[] {Events.EVENT_COLOR}, null, null, null);
-        try {
-            c.moveToFirst();
-            assertEquals(colorValue, c.getInt(0));
-        } finally {
-            if (c != null) {
-                c.close();
-            }
-        }
-
-        // Test Delete
-        Uri colSyncUri = asSyncAdapter(Colors.CONTENT_URI, DEFAULT_ACCOUNT,
-                DEFAULT_ACCOUNT_TYPE);
-        try {
-            // Delete should fail if color referenced by an event.
-            mResolver.delete(colSyncUri, WHERE_COLOR_ACCOUNT_AND_INDEX,
-                    new String[] {DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE, colorKey});
-            fail("Should not allow deleting referenced color");
-        } catch (UnsupportedOperationException e) {
-            // Exception expected.
-        }
-        Cursor cursor = mResolver.query(Colors.CONTENT_URI, new String[] {Colors.COLOR_KEY},
-                Colors.COLOR_KEY + "=? AND " + Colors.COLOR_TYPE + "=?",
-                new String[] {colorKey, Long.toString(colorType)}, null);
-        assertEquals(1, cursor.getCount());
-
-        // Try again, by deleting the event, then the color.
-        assertEquals(1, deleteMatchingEvents(title, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE));
-        mResolver.delete(colSyncUri, WHERE_COLOR_ACCOUNT_AND_INDEX,
-                new String[] {DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE, colorKey});
-        cursor = mResolver.query(Colors.CONTENT_URI, new String[] {Colors.COLOR_KEY},
-                Colors.COLOR_KEY + "=? AND " + Colors.COLOR_TYPE + "=?",
-                new String[] {colorKey, Long.toString(colorType)}, null);
-        assertEquals(0, cursor.getCount());
-    }
-
-    private void checkColor(long colorId, long colorType, String colorKey, long color) {
-        String[] projection = new String[] {
-                Colors.ACCOUNT_NAME, // 0
-                Colors.ACCOUNT_TYPE, // 1
-                Colors.COLOR_TYPE,   // 2
-                Colors.COLOR_KEY,    // 3
-                Colors.COLOR,        // 4
-                Colors._ID,          // 5
-                Colors.DATA,         // 6
-        };
-        Cursor cursor = mResolver.query(Colors.CONTENT_URI, projection, Colors.COLOR_KEY
-                + "=? AND " + Colors.COLOR_TYPE + "=?", new String[] {
-                colorKey, Long.toString(colorType)
-        }, null /* sortOrder */);
-
-        assertEquals(1, cursor.getCount());
-
-        assertTrue(cursor.moveToFirst());
-        assertEquals(DEFAULT_ACCOUNT, cursor.getString(0));
-        assertEquals(DEFAULT_ACCOUNT_TYPE, cursor.getString(1));
-        assertEquals(colorType, cursor.getLong(2));
-        assertEquals(colorKey, cursor.getString(3));
-        assertEquals(color, cursor.getLong(4));
-        assertEquals(colorId, cursor.getLong(5));
-        assertEquals(obsToString(colorType, colorKey, color), cursor.getString(6));
-        cursor.close();
-    }
-
-    private long insertAndCheckColor(long colorType, String colorKey, long color) {
-        Uri uri = insertColor(colorType, colorKey, color);
-        long id = Long.parseLong(uri.getLastPathSegment());
-
-        checkColor(id, colorType, colorKey, color);
-        return id;
-    }
-
-    public void testInsertNormalEvents() throws Exception {
-        final int calId = insertCal("Calendar0", DEFAULT_TIMEZONE);
-        Cursor cursor = mResolver.query(mEventsUri, null, null, null, null);
-        assertEquals(0, cursor.getCount());
-        cursor.close();
-
-        // Keep track of the number of normal events
-        int numOfInserts = 0;
-
-        // "begin" is the earliest start time of all the normal events,
-        // and "end" is the latest end time of all the normal events.
-        long begin = 0, end = 0;
-
-        int len = mEvents.length;
-        Uri[] uris = new Uri[len];
-        ContentValues[] cvs = new ContentValues[len];
-        for (int ii = 0; ii < len; ii++) {
-            EventInfo event = mEvents[ii];
-            // Skip repeating events and recurrence exceptions
-            if (event.mRrule != null || event.mOriginalTitle != null) {
-                continue;
-            }
-            if (numOfInserts == 0) {
-                begin = event.mDtstart;
-                end = event.mDtend;
-            } else {
-                if (begin > event.mDtstart) {
-                    begin = event.mDtstart;
-                }
-                if (end < event.mDtend) {
-                    end = event.mDtend;
-                }
-            }
-
-            cvs[ii] = eventInfoToContentValues(calId, event);
-            uris[ii] = insertEvent(calId, event, cvs[ii]);
-            numOfInserts += 1;
-        }
-
-        // Verify
-        for (int i = 0; i < len; i++) {
-            if (cvs[i] == null) continue;
-            assertNotNull(uris[i]);
-            cursor = mResolver.query(uris[i], null, null, null, null);
-            assertEquals("Item " + i + " not found", 1, cursor.getCount());
-            verifyContentValueAgainstCursor(cvs[i], cvs[i].keySet(), cursor);
-            cursor.close();
-        }
-
-        // query all
-        cursor = mResolver.query(mEventsUri, null, null, null, null);
-        assertEquals(numOfInserts, cursor.getCount());
-        cursor.close();
-
-        // Check that the Instances table has one instance of each of the
-        // normal events.
-        cursor = queryInstances(begin, end);
-        assertEquals(numOfInserts, cursor.getCount());
-        cursor.close();
-    }
-
-    public void testInsertRepeatingEvents() throws Exception {
-        Cursor cursor;
-        Uri url = null;
-
-        int calId = insertCal("Calendar0", "America/Los_Angeles");
-
-        cursor = mResolver.query(mEventsUri, null, null, null, null);
-        assertEquals(0, cursor.getCount());
-        cursor.close();
-
-        // Keep track of the number of repeating events
-        int numOfInserts = 0;
-
-        int len = mEvents.length;
-        Uri[] uris = new Uri[len];
-        ContentValues[] cvs = new ContentValues[len];
-        for (int ii = 0; ii < len; ii++) {
-            EventInfo event = mEvents[ii];
-            // Skip normal events
-            if (event.mRrule == null) {
-                continue;
-            }
-            cvs[ii] = eventInfoToContentValues(calId, event);
-            uris[ii] = insertEvent(calId, event, cvs[ii]);
-            numOfInserts += 1;
-        }
-
-        // Verify
-        for (int i = 0; i < len; i++) {
-            if (cvs[i] == null) continue;
-            assertNotNull(uris[i]);
-            cursor = mResolver.query(uris[i], null, null, null, null);
-            assertEquals("Item " + i + " not found", 1, cursor.getCount());
-            verifyContentValueAgainstCursor(cvs[i], cvs[i].keySet(), cursor);
-            cursor.close();
-        }
-
-        // query all
-        cursor = mResolver.query(mEventsUri, null, null, null, null);
-        assertEquals(numOfInserts, cursor.getCount());
-        cursor.close();
-    }
-
-    // Force a dtend value to be set and make sure instance expansion still works
-    public void testInstanceRangeDtend() throws Exception {
-        mForceDtend = true;
-        testInstanceRange();
-    }
-
-    public void testInstanceRange() throws Exception {
-        Cursor cursor;
-        Uri url = null;
-
-        int calId = insertCal("Calendar0", "America/Los_Angeles");
-
-        cursor = mResolver.query(mEventsUri, null, null, null, null);
-        assertEquals(0, cursor.getCount());
-        cursor.close();
-
-        int len = mInstanceRanges.length;
-        for (int ii = 0; ii < len; ii++) {
-            InstanceInfo instance = mInstanceRanges[ii];
-            EventInfo event = instance.mEvent;
-            url = insertEvent(calId, event);
-            cursor = queryInstances(instance.mBegin, instance.mEnd);
-            if (instance.mExpectedOccurrences != cursor.getCount()) {
-                Log.e(TAG, "Test failed! Instance index: " + ii);
-                Log.e(TAG, "title: " + event.mTitle + " desc: " + event.mDescription
-                        + " [begin,end]: [" + instance.mBegin + " " + instance.mEnd + "]"
-                        + " expected: " + instance.mExpectedOccurrences);
-                dumpCursor(cursor);
-            }
-            assertEquals(instance.mExpectedOccurrences, cursor.getCount());
-            cursor.close();
-            // Delete as sync_adapter so event is really deleted.
-            int rows = mResolver.delete(
-                    updatedUri(url, true, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE),
-                    null /* selection */, null /* selection args */);
-            assertEquals(1, rows);
-        }
-    }
-
-    public static <T> void assertArrayEquals(T[] expected, T[] actual) {
-        if (!Arrays.equals(expected, actual)) {
-            fail("expected:<" + Arrays.toString(expected) +
-                "> but was:<" + Arrays.toString(actual) + ">");
-        }
-    }
-
-    @SmallTest @Smoke
-    public void testEscapeSearchToken() {
-        String token = "test";
-        String expected = "test";
-        assertEquals(expected, mProvider.escapeSearchToken(token));
-
-        token = "%";
-        expected = "#%";
-        assertEquals(expected, mProvider.escapeSearchToken(token));
-
-        token = "_";
-        expected = "#_";
-        assertEquals(expected, mProvider.escapeSearchToken(token));
-
-        token = "#";
-        expected = "##";
-        assertEquals(expected, mProvider.escapeSearchToken(token));
-
-        token = "##";
-        expected = "####";
-        assertEquals(expected, mProvider.escapeSearchToken(token));
-
-        token = "%_#";
-        expected = "#%#_##";
-        assertEquals(expected, mProvider.escapeSearchToken(token));
-
-        token = "blah%blah";
-        expected = "blah#%blah";
-        assertEquals(expected, mProvider.escapeSearchToken(token));
-    }
-
-    @SmallTest @Smoke
-    public void testTokenizeSearchQuery() {
-        String query = "";
-        String[] expectedTokens = new String[] {};
-        assertArrayEquals(expectedTokens, mProvider.tokenizeSearchQuery(query));
-
-        query = "a";
-        expectedTokens = new String[] {"a"};
-        assertArrayEquals(expectedTokens, mProvider.tokenizeSearchQuery(query));
-
-        query = "word";
-        expectedTokens = new String[] {"word"};
-        assertArrayEquals(expectedTokens, mProvider.tokenizeSearchQuery(query));
-
-        query = "two words";
-        expectedTokens = new String[] {"two", "words"};
-        assertArrayEquals(expectedTokens, mProvider.tokenizeSearchQuery(query));
-
-        query = "test, punctuation.";
-        expectedTokens = new String[] {"test", "punctuation"};
-        assertArrayEquals(expectedTokens, mProvider.tokenizeSearchQuery(query));
-
-        query = "\"test phrase\"";
-        expectedTokens = new String[] {"test phrase"};
-        assertArrayEquals(expectedTokens, mProvider.tokenizeSearchQuery(query));
-
-        query = "unquoted \"this is quoted\"";
-        expectedTokens = new String[] {"unquoted", "this is quoted"};
-        assertArrayEquals(expectedTokens, mProvider.tokenizeSearchQuery(query));
-
-        query = " \"this is quoted\"  unquoted ";
-        expectedTokens = new String[] {"this is quoted", "unquoted"};
-        assertArrayEquals(expectedTokens, mProvider.tokenizeSearchQuery(query));
-
-        query = "escap%e m_e";
-        expectedTokens = new String[] {"escap#%e", "m#_e"};
-        assertArrayEquals(expectedTokens, mProvider.tokenizeSearchQuery(query));
-
-        query = "'a bunch' of malformed\" things";
-        expectedTokens = new String[] {"a", "bunch", "of", "malformed", "things"};
-        assertArrayEquals(expectedTokens, mProvider.tokenizeSearchQuery(query));
-
-        query = "''''''....,.''trim punctuation";
-        expectedTokens = new String[] {"trim", "punctuation"};
-        assertArrayEquals(expectedTokens, mProvider.tokenizeSearchQuery(query));
-    }
-
-    @SmallTest @Smoke
-    public void testConstructSearchWhere() {
-        String[] tokens = new String[] {"red"};
-        String expected = "(title LIKE ? ESCAPE \"#\" OR "
-            + "description LIKE ? ESCAPE \"#\" OR "
-            + "eventLocation LIKE ? ESCAPE \"#\" OR "
-            + "group_concat(attendeeEmail) LIKE ? ESCAPE \"#\" OR "
-            + "group_concat(attendeeName) LIKE ? ESCAPE \"#\" )";
-        assertEquals(expected, mProvider.constructSearchWhere(tokens));
-
-        tokens = new String[] {};
-        expected = "";
-        assertEquals(expected, mProvider.constructSearchWhere(tokens));
-
-        tokens = new String[] {"red", "green"};
-        expected = "(title LIKE ? ESCAPE \"#\" OR "
-                + "description LIKE ? ESCAPE \"#\" OR "
-                + "eventLocation LIKE ? ESCAPE \"#\" OR "
-                + "group_concat(attendeeEmail) LIKE ? ESCAPE \"#\" OR "
-                + "group_concat(attendeeName) LIKE ? ESCAPE \"#\" ) AND "
-                + "(title LIKE ? ESCAPE \"#\" OR "
-                + "description LIKE ? ESCAPE \"#\" OR "
-                + "eventLocation LIKE ? ESCAPE \"#\" OR "
-                + "group_concat(attendeeEmail) LIKE ? ESCAPE \"#\" OR "
-                + "group_concat(attendeeName) LIKE ? ESCAPE \"#\" )";
-        assertEquals(expected, mProvider.constructSearchWhere(tokens));
-
-        tokens = new String[] {"red blue", "green"};
-        expected = "(title LIKE ? ESCAPE \"#\" OR "
-            + "description LIKE ? ESCAPE \"#\" OR "
-            + "eventLocation LIKE ? ESCAPE \"#\" OR "
-            + "group_concat(attendeeEmail) LIKE ? ESCAPE \"#\" OR "
-            + "group_concat(attendeeName) LIKE ? ESCAPE \"#\" ) AND "
-            + "(title LIKE ? ESCAPE \"#\" OR "
-            + "description LIKE ? ESCAPE \"#\" OR "
-            + "eventLocation LIKE ? ESCAPE \"#\" OR "
-            + "group_concat(attendeeEmail) LIKE ? ESCAPE \"#\" OR "
-            + "group_concat(attendeeName) LIKE ? ESCAPE \"#\" )";
-        assertEquals(expected, mProvider.constructSearchWhere(tokens));
-    }
-
-    @SmallTest @Smoke
-    public void testConstructSearchArgs() {
-        String[] tokens = new String[] {"red"};
-        String[] expected = new String[] {"%red%", "%red%",
-                "%red%", "%red%", "%red%" };
-        assertArrayEquals(expected, mProvider.constructSearchArgs(tokens));
-
-        tokens = new String[] {"red", "blue"};
-        expected = new String[] { "%red%", "%red%", "%red%",
-                "%red%", "%red%", "%blue%", "%blue%",
-                "%blue%", "%blue%","%blue%"};
-        assertArrayEquals(expected, mProvider.constructSearchArgs(tokens));
-
-        tokens = new String[] {};
-        expected = new String[] {};
-        assertArrayEquals(expected, mProvider.constructSearchArgs(tokens));
-    }
-
-    public void testInstanceSearchQuery() throws Exception {
-        final String[] PROJECTION = new String[] {
-                Instances.TITLE,                 // 0
-                Instances.EVENT_LOCATION,        // 1
-                Instances.ALL_DAY,               // 2
-                Instances.CALENDAR_COLOR,        // 3
-                Instances.EVENT_TIMEZONE,        // 4
-                Instances.EVENT_ID,              // 5
-                Instances.BEGIN,                 // 6
-                Instances.END,                   // 7
-                Instances._ID,                   // 8
-                Instances.START_DAY,             // 9
-                Instances.END_DAY,               // 10
-                Instances.START_MINUTE,          // 11
-                Instances.END_MINUTE,            // 12
-                Instances.HAS_ALARM,             // 13
-                Instances.RRULE,                 // 14
-                Instances.RDATE,                 // 15
-                Instances.SELF_ATTENDEE_STATUS,  // 16
-                Events.ORGANIZER,                // 17
-                Events.GUESTS_CAN_MODIFY,        // 18
-        };
-
-        String orderBy = CalendarProvider2.SORT_CALENDAR_VIEW;
-        String where = Instances.SELF_ATTENDEE_STATUS + "!=" +
-                CalendarContract.Attendees.ATTENDEE_STATUS_DECLINED;
-
-        int calId = insertCal("Calendar0", DEFAULT_TIMEZONE);
-        final String START = "2008-05-01T00:00:00";
-        final String END = "2008-05-01T20:00:00";
-
-        EventInfo event1 = new EventInfo("search orange",
-                START,
-                END,
-                false /* allDay */,
-                DEFAULT_TIMEZONE);
-        event1.mDescription = "this is description1";
-
-        EventInfo event2 = new EventInfo("search purple",
-                START,
-                END,
-                false /* allDay */,
-                DEFAULT_TIMEZONE);
-        event2.mDescription = "lasers, out of nowhere";
-
-        EventInfo event3 = new EventInfo("",
-                START,
-                END,
-                false /* allDay */,
-                DEFAULT_TIMEZONE);
-        event3.mDescription = "kapow";
-
-        EventInfo[] events = { event1, event2, event3 };
-
-        insertEvent(calId, events[0]);
-        insertEvent(calId, events[1]);
-        insertEvent(calId, events[2]);
-
-        Time time = new Time(DEFAULT_TIMEZONE);
-        time.parse3339(START);
-        long startMs = time.toMillis(true /* ignoreDst */);
-        // Query starting from way in the past to one hour into the event.
-        // Query is more than 2 months so the range won't get extended by the provider.
-        Cursor cursor = null;
-
-        try {
-            cursor = queryInstances(mResolver, PROJECTION,
-                    startMs - DateUtils.YEAR_IN_MILLIS,
-                    startMs + DateUtils.HOUR_IN_MILLIS,
-                    "search", where, null, orderBy);
-            assertEquals(2, cursor.getCount());
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-
-        try {
-            cursor = queryInstances(mResolver, PROJECTION,
-                    startMs - DateUtils.YEAR_IN_MILLIS,
-                    startMs + DateUtils.HOUR_IN_MILLIS,
-                    "purple", where, null, orderBy);
-            assertEquals(1, cursor.getCount());
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-
-        try {
-            cursor = queryInstances(mResolver, PROJECTION,
-                    startMs - DateUtils.YEAR_IN_MILLIS,
-                    startMs + DateUtils.HOUR_IN_MILLIS,
-                    "puurple", where, null, orderBy);
-            assertEquals(0, cursor.getCount());
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-
-        try {
-            cursor = queryInstances(mResolver, PROJECTION,
-                    startMs - DateUtils.YEAR_IN_MILLIS,
-                    startMs + DateUtils.HOUR_IN_MILLIS,
-                    "purple lasers", where, null, orderBy);
-            assertEquals(1, cursor.getCount());
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-
-        try {
-            cursor = queryInstances(mResolver, PROJECTION,
-                    startMs - DateUtils.YEAR_IN_MILLIS,
-                    startMs + DateUtils.HOUR_IN_MILLIS,
-                    "lasers kapow", where, null, orderBy);
-            assertEquals(0, cursor.getCount());
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-
-        try {
-            cursor = queryInstances(mResolver, PROJECTION,
-                    startMs - DateUtils.YEAR_IN_MILLIS,
-                    startMs + DateUtils.HOUR_IN_MILLIS,
-                    "\"search purple\"", where, null, orderBy);
-            assertEquals(1, cursor.getCount());
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-
-        try {
-            cursor = queryInstances(mResolver, PROJECTION,
-                    startMs - DateUtils.YEAR_IN_MILLIS,
-                    startMs + DateUtils.HOUR_IN_MILLIS,
-                    "\"purple search\"", where, null, orderBy);
-            assertEquals(0, cursor.getCount());
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-
-        try {
-            cursor = queryInstances(mResolver, PROJECTION,
-                    startMs - DateUtils.YEAR_IN_MILLIS,
-                    startMs + DateUtils.HOUR_IN_MILLIS,
-                    "%", where, null, orderBy);
-            assertEquals(0, cursor.getCount());
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-    }
-
-    public void testDeleteCalendar() throws Exception {
-        int calendarId0 = insertCal("Calendar0", DEFAULT_TIMEZONE);
-        int calendarId1 = insertCal("Calendar1", DEFAULT_TIMEZONE, "user2@google.com");
-        insertEvent(calendarId0, mEvents[0]);
-        insertEvent(calendarId1, mEvents[1]);
-        // Should have 2 calendars and 2 events
-        testQueryCount(CalendarContract.Calendars.CONTENT_URI, null /* where */, 2);
-        testQueryCount(CalendarContract.Events.CONTENT_URI, null /* where */, 2);
-
-        int deletes = mResolver.delete(CalendarContract.Calendars.CONTENT_URI,
-                "ownerAccount='user2@google.com'", null /* selectionArgs */);
-
-        assertEquals(1, deletes);
-        // Should have 1 calendar and 1 event
-        testQueryCount(CalendarContract.Calendars.CONTENT_URI, null /* where */, 1);
-        testQueryCount(CalendarContract.Events.CONTENT_URI, null /* where */, 1);
-
-        deletes = mResolver.delete(Uri.withAppendedPath(CalendarContract.Calendars.CONTENT_URI,
-                String.valueOf(calendarId0)),
-                null /* selection*/ , null /* selectionArgs */);
-
-        assertEquals(1, deletes);
-        // Should have 0 calendars and 0 events
-        testQueryCount(CalendarContract.Calendars.CONTENT_URI, null /* where */, 0);
-        testQueryCount(CalendarContract.Events.CONTENT_URI, null /* where */, 0);
-
-        deletes = mResolver.delete(CalendarContract.Calendars.CONTENT_URI,
-                "ownerAccount=?", new String[] {"user2@google.com"} /* selectionArgs */);
-
-        assertEquals(0, deletes);
-    }
-
-    public void testCalendarAlerts() throws Exception {
-        // This projection is from AlertActivity; want to make sure it works.
-        String[] projection = new String[] {
-                CalendarContract.CalendarAlerts._ID,              // 0
-                CalendarContract.CalendarAlerts.TITLE,            // 1
-                CalendarContract.CalendarAlerts.EVENT_LOCATION,   // 2
-                CalendarContract.CalendarAlerts.ALL_DAY,          // 3
-                CalendarContract.CalendarAlerts.BEGIN,            // 4
-                CalendarContract.CalendarAlerts.END,              // 5
-                CalendarContract.CalendarAlerts.EVENT_ID,         // 6
-                CalendarContract.CalendarAlerts.CALENDAR_COLOR,   // 7
-                CalendarContract.CalendarAlerts.RRULE,            // 8
-                CalendarContract.CalendarAlerts.HAS_ALARM,        // 9
-                CalendarContract.CalendarAlerts.STATE,            // 10
-                CalendarContract.CalendarAlerts.ALARM_TIME,       // 11
-        };
-
-        mCalendarId = insertCal("CalendarTestAttendees", DEFAULT_TIMEZONE);
-        String calendarIdString = Integer.toString(mCalendarId);
-        checkEvents(0, mDb, calendarIdString);
-        Uri eventUri = insertEvent(mCalendarId, findEvent("normal0"));
-        checkEvents(1, mDb, calendarIdString);
-        long eventId = ContentUris.parseId(eventUri);
-
-        Uri alertUri = CalendarContract.CalendarAlerts.insert(mResolver, eventId /* eventId */,
-                2 /* begin */, 3 /* end */, 4 /* alarmTime */, 5 /* minutes */);
-        CalendarContract.CalendarAlerts.insert(mResolver, eventId /* eventId */,
-                2 /* begin */, 7 /* end */, 8 /* alarmTime */, 9 /* minutes */);
-
-        // Regular query
-        Cursor cursor = mResolver.query(CalendarContract.CalendarAlerts.CONTENT_URI, projection,
-                null /* selection */, null /* selectionArgs */, null /* sortOrder */);
-
-        assertEquals(2, cursor.getCount());
-        cursor.close();
-
-        // Instance query
-        cursor = mResolver.query(alertUri, projection,
-                null /* selection */, null /* selectionArgs */, null /* sortOrder */);
-
-        assertEquals(1, cursor.getCount());
-        cursor.close();
-
-        // Grouped by event query
-        cursor = mResolver.query(CalendarContract.CalendarAlerts.CONTENT_URI_BY_INSTANCE,
-                projection, null /* selection */, null /* selectionArgs */, null /* sortOrder */);
-
-        assertEquals(1, cursor.getCount());
-        cursor.close();
-    }
-
-    public void testInsertAlertToNonExistentEvent() {
-        Uri alertUri = CalendarContract.CalendarAlerts.insert(mResolver, 1 /* eventId */,
-                2 /* begin */, 3 /* end */, 4 /* alarmTime */, 5 /* minutes */);
-        assertEquals(null, alertUri);
-    }
-
-    public void testInsertReminderToNonExistentEvent() {
-        ContentValues reminder = new ContentValues();
-        reminder.put(CalendarContract.Reminders.MINUTES, 30);
-        reminder.put(CalendarContract.Reminders.METHOD, CalendarContract.Reminders.METHOD_EMAIL);
-        reminder.put(CalendarContract.Attendees.EVENT_ID, 1);
-        Uri reminderUri = mResolver.insert(
-                updatedUri(CalendarContract.Reminders.CONTENT_URI, true, DEFAULT_ACCOUNT,
-                        DEFAULT_ACCOUNT_TYPE), reminder);
-        assertEquals(null, reminderUri);
-    }
-
-    public void testInsertAttendeeToNonExistentEvent() {
-        ContentValues attendee = new ContentValues();
-        attendee.put(CalendarContract.Attendees.ATTENDEE_NAME, "Joe");
-        attendee.put(CalendarContract.Attendees.ATTENDEE_EMAIL, DEFAULT_ACCOUNT);
-        attendee.put(CalendarContract.Attendees.ATTENDEE_TYPE,
-                CalendarContract.Attendees.TYPE_REQUIRED);
-        attendee.put(CalendarContract.Attendees.ATTENDEE_RELATIONSHIP,
-                CalendarContract.Attendees.RELATIONSHIP_ORGANIZER);
-        attendee.put(CalendarContract.Attendees.EVENT_ID, 1);
-        attendee.put(CalendarContract.Attendees.ATTENDEE_IDENTITY, "ID1");
-        attendee.put(CalendarContract.Attendees.ATTENDEE_ID_NAMESPACE, "IDNS1");
-        Uri attendeesUri = mResolver.insert(CalendarContract.Attendees.CONTENT_URI, attendee);
-        assertEquals(null, attendeesUri);
-    }
-
-    public void testInsertExtendedPropertyToNonExistentEvent() {
-        ContentValues extended = new ContentValues();
-        extended.put(CalendarContract.ExtendedProperties.NAME, "foo");
-        extended.put(CalendarContract.ExtendedProperties.VALUE, "bar");
-        extended.put(CalendarContract.ExtendedProperties.EVENT_ID, 1);
-
-        Uri extendedUri = mResolver.insert(
-                updatedUri(CalendarContract.ExtendedProperties.CONTENT_URI, true,
-                        DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE), extended);
-        assertEquals(null, extendedUri);
-    }
-
-    void checkEvents(int count, SQLiteDatabase db) {
-        Cursor cursor = db.query("Events", null, null, null, null, null, null);
-        try {
-            assertEquals(count, cursor.getCount());
-        } finally {
-            cursor.close();
-        }
-    }
-
-    void checkEvents(int count, SQLiteDatabase db, String calendar) {
-        Cursor cursor = db.query("Events", null, Events.CALENDAR_ID + "=?", new String[] {calendar},
-                null, null, null);
-        try {
-            assertEquals(count, cursor.getCount());
-        } finally {
-            cursor.close();
-        }
-    }
-
-
-//    TODO Reenable this when we are ready to work on this
-//
-//    public void testToShowInsertIsSlowForRecurringEvents() throws Exception {
-//        mCalendarId = insertCal("CalendarTestToShowInsertIsSlowForRecurringEvents", DEFAULT_TIMEZONE);
-//        String calendarIdString = Integer.toString(mCalendarId);
-//        long testStart = System.currentTimeMillis();
-//
-//        final int testTrials = 100;
-//
-//        for (int i = 0; i < testTrials; i++) {
-//            checkEvents(i, mDb, calendarIdString);
-//            long insertStartTime = System.currentTimeMillis();
-//            Uri eventUri = insertEvent(mCalendarId, findEvent("daily0"));
-//            Log.e(TAG, i + ") insertion time " + (System.currentTimeMillis() - insertStartTime));
-//        }
-//        Log.e(TAG, " Avg insertion time = " + (System.currentTimeMillis() - testStart)/testTrials);
-//    }
-
-    /**
-     * Test attendee processing
-     * @throws Exception
-     */
-    public void testAttendees() throws Exception {
-        mCalendarId = insertCal("CalendarTestAttendees", DEFAULT_TIMEZONE);
-        String calendarIdString = Integer.toString(mCalendarId);
-        checkEvents(0, mDb, calendarIdString);
-        Uri eventUri = insertEvent(mCalendarId, findEvent("normal0"));
-        checkEvents(1, mDb, calendarIdString);
-        long eventId = ContentUris.parseId(eventUri);
-
-        ContentValues attendee = new ContentValues();
-        attendee.put(CalendarContract.Attendees.ATTENDEE_NAME, "Joe");
-        attendee.put(CalendarContract.Attendees.ATTENDEE_EMAIL, DEFAULT_ACCOUNT);
-        attendee.put(CalendarContract.Attendees.ATTENDEE_TYPE,
-                CalendarContract.Attendees.TYPE_REQUIRED);
-        attendee.put(CalendarContract.Attendees.ATTENDEE_RELATIONSHIP,
-                CalendarContract.Attendees.RELATIONSHIP_ORGANIZER);
-        attendee.put(CalendarContract.Attendees.EVENT_ID, eventId);
-        attendee.put(CalendarContract.Attendees.ATTENDEE_IDENTITY, "ID1");
-        attendee.put(CalendarContract.Attendees.ATTENDEE_ID_NAMESPACE, "IDNS1");
-        Uri attendeesUri = mResolver.insert(CalendarContract.Attendees.CONTENT_URI, attendee);
-
-        Cursor cursor = mResolver.query(CalendarContract.Attendees.CONTENT_URI, null,
-                "event_id=" + eventId, null, null);
-        assertEquals("Created event is missing - cannot find EventUri = " + eventUri, 1,
-                cursor.getCount());
-        Set<String> attendeeColumns = attendee.keySet();
-        verifyContentValueAgainstCursor(attendee, attendeeColumns, cursor);
-        cursor.close();
-
-        cursor = mResolver.query(eventUri, null, null, null, null);
-        // TODO figure out why this test fails. App works fine for this case.
-        assertEquals("Created event is missing - cannot find EventUri = " + eventUri, 1,
-                cursor.getCount());
-        int selfColumn = cursor.getColumnIndex(CalendarContract.Events.SELF_ATTENDEE_STATUS);
-        cursor.moveToNext();
-        long selfAttendeeStatus = cursor.getInt(selfColumn);
-        assertEquals(CalendarContract.Attendees.ATTENDEE_STATUS_ACCEPTED, selfAttendeeStatus);
-        cursor.close();
-
-        // Update status to declined and change identity
-        ContentValues attendeeUpdate = new ContentValues();
-        attendeeUpdate.put(CalendarContract.Attendees.ATTENDEE_IDENTITY, "ID2");
-        attendee.put(CalendarContract.Attendees.ATTENDEE_IDENTITY, "ID2");
-        attendeeUpdate.put(CalendarContract.Attendees.ATTENDEE_STATUS,
-                CalendarContract.Attendees.ATTENDEE_STATUS_DECLINED);
-        attendee.put(CalendarContract.Attendees.ATTENDEE_STATUS,
-                CalendarContract.Attendees.ATTENDEE_STATUS_DECLINED);
-        mResolver.update(attendeesUri, attendeeUpdate, null, null);
-
-        // Check in attendees table
-        cursor = mResolver.query(attendeesUri, null, null, null, null);
-        cursor.moveToNext();
-        verifyContentValueAgainstCursor(attendee, attendeeColumns, cursor);
-        cursor.close();
-
-        // Test that the self status in events table is updated
-        cursor = mResolver.query(eventUri, null, null, null, null);
-        cursor.moveToNext();
-        selfAttendeeStatus = cursor.getInt(selfColumn);
-        assertEquals(CalendarContract.Attendees.ATTENDEE_STATUS_DECLINED, selfAttendeeStatus);
-        cursor.close();
-
-        // Add another attendee
-        attendee.put(CalendarContract.Attendees.ATTENDEE_NAME, "Dude");
-        attendee.put(CalendarContract.Attendees.ATTENDEE_EMAIL, "dude@dude.com");
-        attendee.put(CalendarContract.Attendees.ATTENDEE_STATUS,
-                CalendarContract.Attendees.ATTENDEE_STATUS_ACCEPTED);
-        mResolver.insert(CalendarContract.Attendees.CONTENT_URI, attendee);
-
-        cursor = mResolver.query(CalendarContract.Attendees.CONTENT_URI, null,
-                "event_id=" + eventId, null, null);
-        assertEquals(2, cursor.getCount());
-        cursor.close();
-
-        cursor = mResolver.query(eventUri, null, null, null, null);
-        cursor.moveToNext();
-        selfAttendeeStatus = cursor.getInt(selfColumn);
-        assertEquals(CalendarContract.Attendees.ATTENDEE_STATUS_DECLINED, selfAttendeeStatus);
-        cursor.close();
-    }
-
-    private void verifyContentValueAgainstCursor(ContentValues cv,
-            Set<String> keys, Cursor cursor) {
-        cursor.moveToFirst();
-        for (String key : keys) {
-            assertEquals(cv.get(key).toString(),
-                    cursor.getString(cursor.getColumnIndex(key)));
-        }
-        cursor.close();
-    }
-
-    /**
-     * Test the event's dirty status and clear it.
-     *
-     * @param eventId event to fetch.
-     * @param wanted the wanted dirty status
-     */
-    private void testAndClearDirty(long eventId, int wanted) {
-        Cursor cursor = mResolver.query(
-                ContentUris.withAppendedId(CalendarContract.Events.CONTENT_URI, eventId),
-                null, null, null, null);
-        try {
-            assertEquals("Event count", 1, cursor.getCount());
-            cursor.moveToNext();
-            int dirty = cursor.getInt(cursor.getColumnIndex(CalendarContract.Events.DIRTY));
-            assertEquals("dirty flag", wanted, dirty);
-            if (dirty == 1) {
-                // Have to access database directly since provider will set dirty again.
-                mDb.execSQL("UPDATE Events SET " + Events.DIRTY + "=0 WHERE _id=" + eventId);
-            }
-        } finally {
-            cursor.close();
-        }
-    }
-
-    /**
-     * Test the count of results from a query.
-     * @param uri The URI to query
-     * @param where The where string or null.
-     * @param wanted The number of results wanted.  An assertion is thrown if it doesn't match.
-     */
-    private void testQueryCount(Uri uri, String where, int wanted) {
-        Cursor cursor = mResolver.query(uri, null/* projection */, where, null /* selectionArgs */,
-                null /* sortOrder */);
-        try {
-            assertEquals("query results", wanted, cursor.getCount());
-        } finally {
-            cursor.close();
-        }
-    }
-
-    /**
-     * Test dirty flag processing.
-     * @throws Exception
-     */
-    public void testDirty() throws Exception {
-        internalTestDirty(false);
-    }
-
-    /**
-     * Test dirty flag processing for updates from a sync adapter.
-     * @throws Exception
-     */
-    public void testDirtyWithSyncAdapter() throws Exception {
-        internalTestDirty(true);
-    }
-
-    /**
-     * Adds CALLER_IS_SYNCADAPTER to URI if this is a sync adapter operation.  Otherwise,
-     * returns the original URI.
-     */
-    private Uri updatedUri(Uri uri, boolean syncAdapter, String account, String accountType) {
-        if (syncAdapter) {
-            return addSyncQueryParams(uri, account, accountType);
-        } else {
-            return uri;
-        }
-    }
-
-    /**
-     * Test dirty flag processing either for syncAdapter operations or client operations.
-     * The main difference is syncAdapter operations don't set the dirty bit.
-     */
-    private void internalTestDirty(boolean syncAdapter) throws Exception {
-        mCalendarId = insertCal("Calendar0", DEFAULT_TIMEZONE);
-
-        long now = System.currentTimeMillis();
-        long begin = (now / 1000) * 1000;
-        long end = begin + ONE_HOUR_MILLIS;
-        Time time = new Time(DEFAULT_TIMEZONE);
-        time.set(begin);
-        String startDate = time.format3339(false);
-        time.set(end);
-        String endDate = time.format3339(false);
-
-        EventInfo eventInfo = new EventInfo("current", startDate, endDate, false);
-        Uri eventUri = insertEvent(mCalendarId, eventInfo);
-
-        long eventId = ContentUris.parseId(eventUri);
-        testAndClearDirty(eventId, 1);
-
-        ContentValues attendee = new ContentValues();
-        attendee.put(CalendarContract.Attendees.ATTENDEE_NAME, "Joe");
-        attendee.put(CalendarContract.Attendees.ATTENDEE_EMAIL, DEFAULT_ACCOUNT);
-        attendee.put(CalendarContract.Attendees.ATTENDEE_TYPE,
-                CalendarContract.Attendees.TYPE_REQUIRED);
-        attendee.put(CalendarContract.Attendees.ATTENDEE_RELATIONSHIP,
-                CalendarContract.Attendees.RELATIONSHIP_ORGANIZER);
-        attendee.put(CalendarContract.Attendees.EVENT_ID, eventId);
-
-        Uri attendeeUri = mResolver.insert(
-                updatedUri(CalendarContract.Attendees.CONTENT_URI, syncAdapter, DEFAULT_ACCOUNT,
-                        DEFAULT_ACCOUNT_TYPE),
-                attendee);
-        testAndClearDirty(eventId, syncAdapter ? 0 : 1);
-        testQueryCount(CalendarContract.Attendees.CONTENT_URI, "event_id=" + eventId, 1);
-
-        ContentValues reminder = new ContentValues();
-        reminder.put(CalendarContract.Reminders.MINUTES, 30);
-        reminder.put(CalendarContract.Reminders.METHOD, CalendarContract.Reminders.METHOD_EMAIL);
-        reminder.put(CalendarContract.Attendees.EVENT_ID, eventId);
-
-        Uri reminderUri = mResolver.insert(
-                updatedUri(CalendarContract.Reminders.CONTENT_URI, syncAdapter, DEFAULT_ACCOUNT,
-                        DEFAULT_ACCOUNT_TYPE), reminder);
-        testAndClearDirty(eventId, syncAdapter ? 0 : 1);
-        testQueryCount(CalendarContract.Reminders.CONTENT_URI, "event_id=" + eventId, 1);
-
-        long alarmTime = begin + 5 * ONE_MINUTE_MILLIS;
-
-        ContentValues alert = new ContentValues();
-        alert.put(CalendarContract.CalendarAlerts.BEGIN, begin);
-        alert.put(CalendarContract.CalendarAlerts.END, end);
-        alert.put(CalendarContract.CalendarAlerts.ALARM_TIME, alarmTime);
-        alert.put(CalendarContract.CalendarAlerts.CREATION_TIME, now);
-        alert.put(CalendarContract.CalendarAlerts.RECEIVED_TIME, now);
-        alert.put(CalendarContract.CalendarAlerts.NOTIFY_TIME, now);
-        alert.put(CalendarContract.CalendarAlerts.STATE,
-                CalendarContract.CalendarAlerts.STATE_SCHEDULED);
-        alert.put(CalendarContract.CalendarAlerts.MINUTES, 30);
-        alert.put(CalendarContract.CalendarAlerts.EVENT_ID, eventId);
-
-        Uri alertUri = mResolver.insert(
-                updatedUri(CalendarContract.CalendarAlerts.CONTENT_URI, syncAdapter,
-                        DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE), alert);
-        // Alerts don't dirty the event
-        testAndClearDirty(eventId, 0);
-        testQueryCount(CalendarContract.CalendarAlerts.CONTENT_URI, "event_id=" + eventId, 1);
-
-        ContentValues extended = new ContentValues();
-        extended.put(CalendarContract.ExtendedProperties.NAME, "foo");
-        extended.put(CalendarContract.ExtendedProperties.VALUE, "bar");
-        extended.put(CalendarContract.ExtendedProperties.EVENT_ID, eventId);
-
-        Uri extendedUri = null;
-        if (syncAdapter) {
-            // Only the sync adapter is allowed to modify ExtendedProperties.
-            extendedUri = mResolver.insert(
-                    updatedUri(CalendarContract.ExtendedProperties.CONTENT_URI, syncAdapter,
-                            DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE), extended);
-            testAndClearDirty(eventId, syncAdapter ? 0 : 1);
-            testQueryCount(CalendarContract.ExtendedProperties.CONTENT_URI,
-                    "event_id=" + eventId, 1);
-        } else {
-            // Confirm that inserting as app fails.
-            try {
-                extendedUri = mResolver.insert(
-                        updatedUri(CalendarContract.ExtendedProperties.CONTENT_URI, syncAdapter,
-                                DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE), extended);
-                fail("Only sync adapter should be allowed to insert into ExtendedProperties");
-            } catch (IllegalArgumentException iae) {}
-        }
-
-        // Now test updates
-
-        attendee = new ContentValues();
-        attendee.put(CalendarContract.Attendees.ATTENDEE_NAME, "Sam");
-
-        assertEquals("update", 1, mResolver.update(
-                updatedUri(attendeeUri, syncAdapter, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE),
-                attendee,
-                null /* where */, null /* selectionArgs */));
-        testAndClearDirty(eventId, syncAdapter ? 0 : 1);
-
-        testQueryCount(CalendarContract.Attendees.CONTENT_URI, "event_id=" + eventId, 1);
-
-        alert = new ContentValues();
-        alert.put(CalendarContract.CalendarAlerts.STATE,
-                CalendarContract.CalendarAlerts.STATE_DISMISSED);
-
-        assertEquals("update", 1, mResolver.update(
-                updatedUri(alertUri, syncAdapter, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE), alert,
-                null /* where */, null /* selectionArgs */));
-        // Alerts don't dirty the event
-        testAndClearDirty(eventId, 0);
-        testQueryCount(CalendarContract.CalendarAlerts.CONTENT_URI, "event_id=" + eventId, 1);
-
-        extended = new ContentValues();
-        extended.put(CalendarContract.ExtendedProperties.VALUE, "baz");
-
-        if (syncAdapter) {
-            assertEquals("update", 1, mResolver.update(
-                    updatedUri(extendedUri, syncAdapter, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE),
-                    extended,
-                    null /* where */, null /* selectionArgs */));
-            testAndClearDirty(eventId, syncAdapter ? 0 : 1);
-            testQueryCount(CalendarContract.ExtendedProperties.CONTENT_URI,
-                    "event_id=" + eventId, 1);
-        }
-
-        // Now test deletes
-
-        assertEquals("delete", 1, mResolver.delete(
-                updatedUri(attendeeUri, syncAdapter, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE),
-                null, null /* selectionArgs */));
-        testAndClearDirty(eventId, syncAdapter ? 0 : 1);
-        testQueryCount(CalendarContract.Attendees.CONTENT_URI, "event_id=" + eventId, 0);
-
-        assertEquals("delete", 1, mResolver.delete(
-                updatedUri(reminderUri, syncAdapter, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE),
-                null /* where */, null /* selectionArgs */));
-
-        testAndClearDirty(eventId, syncAdapter ? 0 : 1);
-        testQueryCount(CalendarContract.Reminders.CONTENT_URI, "event_id=" + eventId, 0);
-
-        assertEquals("delete", 1, mResolver.delete(
-                updatedUri(alertUri, syncAdapter, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE),
-                null /* where */, null /* selectionArgs */));
-
-        // Alerts don't dirty the event
-        testAndClearDirty(eventId, 0);
-        testQueryCount(CalendarContract.CalendarAlerts.CONTENT_URI, "event_id=" + eventId, 0);
-
-        if (syncAdapter) {
-            assertEquals("delete", 1, mResolver.delete(
-                    updatedUri(extendedUri, syncAdapter, DEFAULT_ACCOUNT, DEFAULT_ACCOUNT_TYPE),
-                    null /* where */, null /* selectionArgs */));
-
-            testAndClearDirty(eventId, syncAdapter ? 0 : 1);
-            testQueryCount(CalendarContract.ExtendedProperties.CONTENT_URI, "event_id=" + eventId,
-                    0);
-        }
-    }
-
-    /**
-     * Test calendar deletion
-     * @throws Exception
-     */
-    public void testCalendarDeletion() throws Exception {
-        mCalendarId = insertCal("Calendar0", DEFAULT_TIMEZONE);
-        Uri eventUri = insertEvent(mCalendarId, findEvent("daily0"));
-        long eventId = ContentUris.parseId(eventUri);
-        testAndClearDirty(eventId, 1);
-        Uri eventUri1 = insertEvent(mCalendarId, findEvent("daily1"));
-        long eventId1 = ContentUris.parseId(eventUri);
-        assertEquals("delete", 1, mResolver.delete(eventUri1, null, null));
-        // Calendar has one event and one deleted event
-        testQueryCount(CalendarContract.Events.CONTENT_URI, null, 2);
-
-        assertEquals("delete", 1, mResolver.delete(CalendarContract.Calendars.CONTENT_URI,
-                "_id=" + mCalendarId, null));
-        // Calendar should be deleted
-        testQueryCount(CalendarContract.Calendars.CONTENT_URI, null, 0);
-        // Event should be gone
-        testQueryCount(CalendarContract.Events.CONTENT_URI, null, 0);
-    }
-
-    /**
-     * Test multiple account support.
-     */
-    public void testMultipleAccounts() throws Exception {
-        mCalendarId = insertCal("Calendar0", DEFAULT_TIMEZONE);
-        int calendarId1 = insertCal("Calendar1", DEFAULT_TIMEZONE, "user2@google.com");
-        Uri eventUri0 = insertEvent(mCalendarId, findEvent("daily0"));
-        Uri eventUri1 = insertEvent(calendarId1, findEvent("daily1"));
-
-        testQueryCount(CalendarContract.Events.CONTENT_URI, null, 2);
-        Uri eventsWithAccount = CalendarContract.Events.CONTENT_URI.buildUpon()
-                .appendQueryParameter(CalendarContract.EventsEntity.ACCOUNT_NAME, DEFAULT_ACCOUNT)
-                .appendQueryParameter(CalendarContract.EventsEntity.ACCOUNT_TYPE,
-                        DEFAULT_ACCOUNT_TYPE)
-                .build();
-        // Only one event for that account
-        testQueryCount(eventsWithAccount, null, 1);
-
-        // Test deletion with account and selection
-
-        long eventId = ContentUris.parseId(eventUri1);
-        // Wrong account, should not be deleted
-        assertEquals("delete", 0, mResolver.delete(
-                updatedUri(eventsWithAccount, true /* syncAdapter */, DEFAULT_ACCOUNT,
-                        DEFAULT_ACCOUNT_TYPE),
-                "_id=" + eventId, null /* selectionArgs */));
-        testQueryCount(CalendarContract.Events.CONTENT_URI, null, 2);
-        // Right account, should be deleted
-        assertEquals("delete", 1, mResolver.delete(
-                updatedUri(CalendarContract.Events.CONTENT_URI, true /* syncAdapter */,
-                        "user2@google.com", DEFAULT_ACCOUNT_TYPE),
-                "_id=" + eventId, null /* selectionArgs */));
-        testQueryCount(CalendarContract.Events.CONTENT_URI, null, 1);
-    }
-
-    /**
-     * Run commands, wiping instance table at each step.
-     * This tests full instance expansion.
-     * @throws Exception
-     */
-    public void testCommandSequences1() throws Exception {
-        commandSequences(true);
-    }
-
-    /**
-     * Run commands normally.
-     * This tests incremental instance expansion.
-     * @throws Exception
-     */
-    public void testCommandSequences2() throws Exception {
-        commandSequences(false);
-    }
-
-    /**
-     * Run thorough set of command sequences
-     * @param wipe true if instances should be wiped and regenerated
-     * @throws Exception
-     */
-    private void commandSequences(boolean wipe) throws Exception {
-        Cursor cursor;
-        Uri url = null;
-        mWipe = wipe; // Set global flag
-
-        mCalendarId = insertCal("Calendar0", DEFAULT_TIMEZONE);
-
-        cursor = mResolver.query(mEventsUri, null, null, null, null);
-        assertEquals(0, cursor.getCount());
-        cursor.close();
-        Command[] commands;
-
-        Log.i(TAG, "Normal insert/delete");
-        commands = mNormalInsertDelete;
-        for (Command command : commands) {
-            command.execute();
-        }
-
-        deleteAllEvents();
-
-        Log.i(TAG, "All-day insert/delete");
-        commands = mAlldayInsertDelete;
-        for (Command command : commands) {
-            command.execute();
-        }
-
-        deleteAllEvents();
-
-        Log.i(TAG, "Recurring insert/delete");
-        commands = mRecurringInsertDelete;
-        for (Command command : commands) {
-            command.execute();
-        }
-
-        deleteAllEvents();
-
-        Log.i(TAG, "Exception with truncated recurrence");
-        commands = mExceptionWithTruncatedRecurrence;
-        for (Command command : commands) {
-            command.execute();
-        }
-
-        deleteAllEvents();
-
-        Log.i(TAG, "Exception with moved recurrence");
-        commands = mExceptionWithMovedRecurrence;
-        for (Command command : commands) {
-            command.execute();
-        }
-
-        deleteAllEvents();
-
-        Log.i(TAG, "Exception with cancel");
-        commands = mCancelInstance;
-        for (Command command : commands) {
-            command.execute();
-        }
-
-        deleteAllEvents();
-
-        Log.i(TAG, "Exception with moved recurrence2");
-        commands = mExceptionWithMovedRecurrence2;
-        for (Command command : commands) {
-            command.execute();
-        }
-
-        deleteAllEvents();
-
-        Log.i(TAG, "Exception with no recurrence");
-        commands = mExceptionWithNoRecurrence;
-        for (Command command : commands) {
-            command.execute();
-        }
-    }
-
-    /**
-     * Test Time toString.
-     * @throws Exception
-     */
-    // Suppressed because toString currently hangs.
-    @Suppress
-    public void testTimeToString() throws Exception {
-        Time time = new Time(Time.TIMEZONE_UTC);
-        String str = "2039-01-01T23:00:00.000Z";
-        String result = "20390101T230000UTC(0,0,0,-1,0)";
-        time.parse3339(str);
-        assertEquals(result, time.toString());
-    }
-
-    /**
-     * Test the query done by Event.loadEvents
-     * Also test that instance queries work when an event straddles the expansion range
-     * @throws Exception
-     */
-    public void testInstanceQuery() throws Exception {
-        final String[] PROJECTION = new String[] {
-                Instances.TITLE,                 // 0
-                Instances.EVENT_LOCATION,        // 1
-                Instances.ALL_DAY,               // 2
-                Instances.CALENDAR_COLOR,        // 3
-                Instances.EVENT_TIMEZONE,        // 4
-                Instances.EVENT_ID,              // 5
-                Instances.BEGIN,                 // 6
-                Instances.END,                   // 7
-                Instances._ID,                   // 8
-                Instances.START_DAY,             // 9
-                Instances.END_DAY,               // 10
-                Instances.START_MINUTE,          // 11
-                Instances.END_MINUTE,            // 12
-                Instances.HAS_ALARM,             // 13
-                Instances.RRULE,                 // 14
-                Instances.RDATE,                 // 15
-                Instances.SELF_ATTENDEE_STATUS,  // 16
-                Events.ORGANIZER,                // 17
-                Events.GUESTS_CAN_MODIFY,        // 18
-        };
-
-        String orderBy = CalendarProvider2.SORT_CALENDAR_VIEW;
-        String where = Instances.SELF_ATTENDEE_STATUS + "!="
-                + CalendarContract.Attendees.ATTENDEE_STATUS_DECLINED;
-
-        int calId = insertCal("Calendar0", DEFAULT_TIMEZONE);
-        final String START = "2008-05-01T00:00:00";
-        final String END = "2008-05-01T20:00:00";
-
-        EventInfo[] events = { new EventInfo("normal0",
-                START,
-                END,
-                false /* allDay */,
-                DEFAULT_TIMEZONE) };
-
-        insertEvent(calId, events[0]);
-
-        Time time = new Time(DEFAULT_TIMEZONE);
-        time.parse3339(START);
-        long startMs = time.toMillis(true /* ignoreDst */);
-        // Query starting from way in the past to one hour into the event.
-        // Query is more than 2 months so the range won't get extended by the provider.
-        Cursor cursor = queryInstances(mResolver, PROJECTION,
-                startMs - DateUtils.YEAR_IN_MILLIS, startMs + DateUtils.HOUR_IN_MILLIS,
-                where, null, orderBy);
-        try {
-            assertEquals(1, cursor.getCount());
-        } finally {
-            cursor.close();
-        }
-
-        // Now expand the instance range.  The event overlaps the new part of the range.
-        cursor = queryInstances(mResolver, PROJECTION,
-                startMs - DateUtils.YEAR_IN_MILLIS, startMs + 2 * DateUtils.HOUR_IN_MILLIS,
-                where, null, orderBy);
-        try {
-            assertEquals(1, cursor.getCount());
-        } finally {
-            cursor.close();
-        }
-    }
-
-    /**
-     * Performs a query to return all visible instances in the given range that
-     * match the given selection. This is a blocking function and should not be
-     * done on the UI thread. This will cause an expansion of recurring events
-     * to fill this time range if they are not already expanded and will slow
-     * down for larger time ranges with many recurring events.
-     *
-     * @param cr The ContentResolver to use for the query
-     * @param projection The columns to return
-     * @param begin The start of the time range to query in UTC millis since
-     *            epoch
-     * @param end The end of the time range to query in UTC millis since epoch
-     * @param selection Filter on the query as an SQL WHERE statement
-     * @param selectionArgs Args to replace any '?'s in the selection
-     * @param orderBy How to order the rows as an SQL ORDER BY statement
-     * @return A Cursor of instances matching the selection
-     */
-    private static final Cursor queryInstances(ContentResolver cr, String[] projection, long begin,
-            long end, String selection, String[] selectionArgs, String orderBy) {
-
-        Uri.Builder builder = Instances.CONTENT_URI.buildUpon();
-        ContentUris.appendId(builder, begin);
-        ContentUris.appendId(builder, end);
-        if (TextUtils.isEmpty(selection)) {
-            selection = WHERE_CALENDARS_SELECTED;
-            selectionArgs = WHERE_CALENDARS_ARGS;
-        } else {
-            selection = "(" + selection + ") AND " + WHERE_CALENDARS_SELECTED;
-            if (selectionArgs != null && selectionArgs.length > 0) {
-                selectionArgs = Arrays.copyOf(selectionArgs, selectionArgs.length + 1);
-                selectionArgs[selectionArgs.length - 1] = WHERE_CALENDARS_ARGS[0];
-            } else {
-                selectionArgs = WHERE_CALENDARS_ARGS;
-            }
-        }
-        return cr.query(builder.build(), projection, selection, selectionArgs,
-                orderBy == null ? DEFAULT_SORT_ORDER : orderBy);
-    }
-
-    /**
-     * Performs a query to return all visible instances in the given range that
-     * match the given selection. This is a blocking function and should not be
-     * done on the UI thread. This will cause an expansion of recurring events
-     * to fill this time range if they are not already expanded and will slow
-     * down for larger time ranges with many recurring events.
-     *
-     * @param cr The ContentResolver to use for the query
-     * @param projection The columns to return
-     * @param begin The start of the time range to query in UTC millis since
-     *            epoch
-     * @param end The end of the time range to query in UTC millis since epoch
-     * @param searchQuery A string of space separated search terms. Segments
-     *            enclosed by double quotes will be treated as a single term.
-     * @param selection Filter on the query as an SQL WHERE statement
-     * @param selectionArgs Args to replace any '?'s in the selection
-     * @param orderBy How to order the rows as an SQL ORDER BY statement
-     * @return A Cursor of instances matching the selection
-     */
-    public static final Cursor queryInstances(ContentResolver cr, String[] projection, long begin,
-            long end, String searchQuery, String selection, String[] selectionArgs, String orderBy)
-            {
-        Uri.Builder builder = Instances.CONTENT_SEARCH_URI.buildUpon();
-        ContentUris.appendId(builder, begin);
-        ContentUris.appendId(builder, end);
-        builder = builder.appendPath(searchQuery);
-        if (TextUtils.isEmpty(selection)) {
-            selection = WHERE_CALENDARS_SELECTED;
-            selectionArgs = WHERE_CALENDARS_ARGS;
-        } else {
-            selection = "(" + selection + ") AND " + WHERE_CALENDARS_SELECTED;
-            if (selectionArgs != null && selectionArgs.length > 0) {
-                selectionArgs = Arrays.copyOf(selectionArgs, selectionArgs.length + 1);
-                selectionArgs[selectionArgs.length - 1] = WHERE_CALENDARS_ARGS[0];
-            } else {
-                selectionArgs = WHERE_CALENDARS_ARGS;
-            }
-        }
-        return cr.query(builder.build(), projection, selection, selectionArgs,
-                orderBy == null ? DEFAULT_SORT_ORDER : orderBy);
-    }
-
-    private Cursor queryInstances(long begin, long end) {
-        Uri url = Uri.withAppendedPath(CalendarContract.Instances.CONTENT_URI, begin + "/" + end);
-        return mResolver.query(url, null, null, null, null);
-    }
-
-    protected static class MockProvider extends ContentProvider {
-
-        private String mAuthority;
-
-        private int mNumItems = 0;
-
-        public MockProvider(String authority) {
-            mAuthority = authority;
-        }
-
-        @Override
-        public boolean onCreate() {
-            return true;
-        }
-
-        @Override
-        public Cursor query(Uri uri, String[] projection, String selection,
-                String[] selectionArgs, String sortOrder) {
-            return new MatrixCursor(new String[]{ "_id" }, 0);
-        }
-
-        @Override
-        public String getType(Uri uri) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Uri insert(Uri uri, ContentValues values) {
-            mNumItems++;
-            return Uri.parse("content://" + mAuthority + "/" + mNumItems);
-        }
-
-        @Override
-        public int delete(Uri uri, String selection, String[] selectionArgs) {
-            return 0;
-        }
-
-        @Override
-        public int update(Uri uri, ContentValues values, String selection,
-                String[] selectionArgs) {
-            return 0;
-        }
-    }
-
-    private void cleanCalendarDataTable(SQLiteOpenHelper helper) {
-        if (null == helper) {
-            return;
-        }
-        SQLiteDatabase db = helper.getWritableDatabase();
-        db.execSQL("DELETE FROM CalendarCache;");
-    }
-
-    public void testGetAndSetTimezoneDatabaseVersion() throws CalendarCache.CacheException {
-        CalendarDatabaseHelper helper = (CalendarDatabaseHelper) getProvider().getDatabaseHelper();
-        cleanCalendarDataTable(helper);
-        CalendarCache cache = new CalendarCache(helper);
-
-        boolean hasException = false;
-        try {
-            String value = cache.readData(null);
-        } catch (CalendarCache.CacheException e) {
-            hasException = true;
-        }
-        assertTrue(hasException);
-
-        assertNull(cache.readTimezoneDatabaseVersion());
-
-        cache.writeTimezoneDatabaseVersion("1234");
-        assertEquals("1234", cache.readTimezoneDatabaseVersion());
-
-        cache.writeTimezoneDatabaseVersion("5678");
-        assertEquals("5678", cache.readTimezoneDatabaseVersion());
-    }
-
-    private void checkEvent(int eventId, String title, long dtStart, long dtEnd, boolean allDay) {
-        Uri uri = Uri.parse("content://" + CalendarContract.AUTHORITY + "/events");
-        Log.i(TAG, "Looking for EventId = " + eventId);
-
-        Cursor cursor = mResolver.query(uri, null, null, null, null);
-        assertEquals(1, cursor.getCount());
-
-        int colIndexTitle = cursor.getColumnIndex(CalendarContract.Events.TITLE);
-        int colIndexDtStart = cursor.getColumnIndex(CalendarContract.Events.DTSTART);
-        int colIndexDtEnd = cursor.getColumnIndex(CalendarContract.Events.DTEND);
-        int colIndexAllDay = cursor.getColumnIndex(CalendarContract.Events.ALL_DAY);
-        if (!cursor.moveToNext()) {
-            Log.e(TAG,"Could not find inserted event");
-            assertTrue(false);
-        }
-        assertEquals(title, cursor.getString(colIndexTitle));
-        assertEquals(dtStart, cursor.getLong(colIndexDtStart));
-        assertEquals(dtEnd, cursor.getLong(colIndexDtEnd));
-        assertEquals(allDay, (cursor.getInt(colIndexAllDay) != 0));
-        cursor.close();
-    }
-
-    public void testChangeTimezoneDB() {
-        int calId = insertCal("Calendar0", DEFAULT_TIMEZONE);
-
-        Cursor cursor = mResolver
-                .query(CalendarContract.Events.CONTENT_URI, null, null, null, null);
-        assertEquals(0, cursor.getCount());
-        cursor.close();
-
-        EventInfo[] events = { new EventInfo("normal0",
-                                        "2008-05-01T00:00:00",
-                                        "2008-05-02T00:00:00",
-                                        false,
-                                        DEFAULT_TIMEZONE) };
-
-        Uri uri = insertEvent(calId, events[0]);
-        assertNotNull(uri);
-
-        // check the inserted event
-        checkEvent(1, events[0].mTitle, events[0].mDtstart, events[0].mDtend, events[0].mAllDay);
-
-        // inject a new time zone
-        getProvider().doProcessEventRawTimes(TIME_ZONE_AMERICA_ANCHORAGE,
-                MOCK_TIME_ZONE_DATABASE_VERSION);
-
-        // check timezone database version
-        assertEquals(MOCK_TIME_ZONE_DATABASE_VERSION, getProvider().getTimezoneDatabaseVersion());
-
-        // check that the inserted event has *not* been updated
-        checkEvent(1, events[0].mTitle, events[0].mDtstart, events[0].mDtend, events[0].mAllDay);
-    }
-
-    public static final Uri PROPERTIES_CONTENT_URI =
-            Uri.parse("content://" + CalendarContract.AUTHORITY + "/properties");
-
-    public static final int COLUMN_KEY_INDEX = 0;
-    public static final int COLUMN_VALUE_INDEX = 1;
-
-    public void testGetProviderProperties() throws CalendarCache.CacheException {
-        CalendarDatabaseHelper helper = (CalendarDatabaseHelper) getProvider().getDatabaseHelper();
-        cleanCalendarDataTable(helper);
-        CalendarCache cache = new CalendarCache(helper);
-
-        cache.writeTimezoneDatabaseVersion("2010k");
-        cache.writeTimezoneInstances("America/Denver");
-        cache.writeTimezoneInstancesPrevious("America/Los_Angeles");
-        cache.writeTimezoneType(CalendarCache.TIMEZONE_TYPE_AUTO);
-
-        Cursor cursor = mResolver.query(PROPERTIES_CONTENT_URI, null, null, null, null);
-        assertEquals(4, cursor.getCount());
-
-        assertEquals(CalendarCache.COLUMN_NAME_KEY, cursor.getColumnName(COLUMN_KEY_INDEX));
-        assertEquals(CalendarCache.COLUMN_NAME_VALUE, cursor.getColumnName(COLUMN_VALUE_INDEX));
-
-        Map<String, String> map = new HashMap<String, String>();
-
-        while (cursor.moveToNext()) {
-            String key = cursor.getString(COLUMN_KEY_INDEX);
-            String value = cursor.getString(COLUMN_VALUE_INDEX);
-            map.put(key, value);
-        }
-
-        assertTrue(map.containsKey(CalendarCache.KEY_TIMEZONE_DATABASE_VERSION));
-        assertTrue(map.containsKey(CalendarCache.KEY_TIMEZONE_TYPE));
-        assertTrue(map.containsKey(CalendarCache.KEY_TIMEZONE_INSTANCES));
-        assertTrue(map.containsKey(CalendarCache.KEY_TIMEZONE_INSTANCES_PREVIOUS));
-
-        assertEquals("2010k", map.get(CalendarCache.KEY_TIMEZONE_DATABASE_VERSION));
-        assertEquals("America/Denver", map.get(CalendarCache.KEY_TIMEZONE_INSTANCES));
-        assertEquals("America/Los_Angeles", map.get(CalendarCache.KEY_TIMEZONE_INSTANCES_PREVIOUS));
-        assertEquals(CalendarCache.TIMEZONE_TYPE_AUTO, map.get(CalendarCache.KEY_TIMEZONE_TYPE));
-
-        cursor.close();
-    }
-
-    public void testGetProviderPropertiesByKey() throws CalendarCache.CacheException {
-        CalendarDatabaseHelper helper = (CalendarDatabaseHelper) getProvider().getDatabaseHelper();
-        cleanCalendarDataTable(helper);
-        CalendarCache cache = new CalendarCache(helper);
-
-        cache.writeTimezoneDatabaseVersion("2010k");
-        cache.writeTimezoneInstances("America/Denver");
-        cache.writeTimezoneInstancesPrevious("America/Los_Angeles");
-        cache.writeTimezoneType(CalendarCache.TIMEZONE_TYPE_AUTO);
-
-        checkValueForKey(CalendarCache.TIMEZONE_TYPE_AUTO, CalendarCache.KEY_TIMEZONE_TYPE);
-        checkValueForKey("2010k", CalendarCache.KEY_TIMEZONE_DATABASE_VERSION);
-        checkValueForKey("America/Denver", CalendarCache.KEY_TIMEZONE_INSTANCES);
-        checkValueForKey("America/Los_Angeles", CalendarCache.KEY_TIMEZONE_INSTANCES_PREVIOUS);
-    }
-
-    private void checkValueForKey(String value, String key) {
-        Cursor cursor = mResolver.query(PROPERTIES_CONTENT_URI, null,
-                "key=?", new String[] {key}, null);
-
-        assertEquals(1, cursor.getCount());
-        assertTrue(cursor.moveToFirst());
-        assertEquals(cursor.getString(COLUMN_KEY_INDEX), key);
-        assertEquals(cursor.getString(COLUMN_VALUE_INDEX), value);
-
-        cursor.close();
-    }
-
-    public void testUpdateProviderProperties() throws CalendarCache.CacheException {
-        CalendarDatabaseHelper helper = (CalendarDatabaseHelper) getProvider().getDatabaseHelper();
-        cleanCalendarDataTable(helper);
-        CalendarCache cache = new CalendarCache(helper);
-
-        String localTimezone = TimeZone.getDefault().getID();
-
-        // Set initial value
-        cache.writeTimezoneDatabaseVersion("2010k");
-
-        updateValueForKey("2009s", CalendarCache.KEY_TIMEZONE_DATABASE_VERSION);
-        checkValueForKey("2009s", CalendarCache.KEY_TIMEZONE_DATABASE_VERSION);
-
-        // Set initial values
-        cache.writeTimezoneType(CalendarCache.TIMEZONE_TYPE_AUTO);
-        cache.writeTimezoneInstances("America/Chicago");
-        cache.writeTimezoneInstancesPrevious("America/Denver");
-
-        updateValueForKey(CalendarCache.TIMEZONE_TYPE_AUTO, CalendarCache.KEY_TIMEZONE_TYPE);
-        checkValueForKey(localTimezone, CalendarCache.KEY_TIMEZONE_INSTANCES);
-        checkValueForKey("America/Denver", CalendarCache.KEY_TIMEZONE_INSTANCES_PREVIOUS);
-
-        updateValueForKey(CalendarCache.TIMEZONE_TYPE_HOME, CalendarCache.KEY_TIMEZONE_TYPE);
-        checkValueForKey("America/Denver", CalendarCache.KEY_TIMEZONE_INSTANCES);
-        checkValueForKey("America/Denver", CalendarCache.KEY_TIMEZONE_INSTANCES_PREVIOUS);
-
-        // Set initial value
-        cache.writeTimezoneInstancesPrevious("");
-        updateValueForKey(localTimezone, CalendarCache.KEY_TIMEZONE_INSTANCES);
-        checkValueForKey(localTimezone, CalendarCache.KEY_TIMEZONE_INSTANCES);
-        checkValueForKey(localTimezone, CalendarCache.KEY_TIMEZONE_INSTANCES_PREVIOUS);
-    }
-
-    private void updateValueForKey(String value, String key) {
-        ContentValues contentValues = new ContentValues();
-        contentValues.put(CalendarCache.COLUMN_NAME_VALUE, value);
-
-        int result = mResolver.update(PROPERTIES_CONTENT_URI,
-                contentValues,
-                CalendarCache.COLUMN_NAME_KEY + "=?",
-                new String[] {key});
-
-        assertEquals(1, result);
-    }
-
-    /**
-     * Verifies that the number of defined calendars meets expectations.
-     *
-     * @param expectedCount The number of calendars we expect to find.
-     */
-    private void checkCalendarCount(int expectedCount) {
-        Cursor cursor = mResolver.query(mCalendarsUri,
-                null /* projection */,
-                null /* selection */,
-                null /* selectionArgs */,
-                null /* sortOrder */);
-        assertEquals(expectedCount, cursor.getCount());
-        cursor.close();
-    }
-
-    private void checkCalendarExists(int calId) {
-        assertTrue(isCalendarExists(calId));
-    }
-
-    private void checkCalendarDoesNotExists(int calId) {
-        assertFalse(isCalendarExists(calId));
-    }
-
-    private boolean isCalendarExists(int calId) {
-        Cursor cursor = mResolver.query(mCalendarsUri,
-                new String[] {Calendars._ID},
-                null /* selection */,
-                null /* selectionArgs */,
-                null /* sortOrder */);
-        boolean found = false;
-        while (cursor.moveToNext()) {
-            if (calId == cursor.getInt(0)) {
-                found = true;
-                break;
-            }
-        }
-        cursor.close();
-        return found;
-    }
-
-    public void testDeleteAllCalendars() {
-        checkCalendarCount(0);
-
-        insertCal("Calendar1", "America/Los_Angeles");
-        insertCal("Calendar2", "America/Los_Angeles");
-
-        checkCalendarCount(2);
-
-        deleteMatchingCalendars(null /* selection */, null /* selectionArgs*/);
-        checkCalendarCount(0);
-    }
-
-    public void testDeleteCalendarsWithSelection() {
-        checkCalendarCount(0);
-
-        int calId1 = insertCal("Calendar1", "America/Los_Angeles");
-        int calId2 = insertCal("Calendar2", "America/Los_Angeles");
-
-        checkCalendarCount(2);
-        checkCalendarExists(calId1);
-        checkCalendarExists(calId2);
-
-        deleteMatchingCalendars(Calendars._ID + "=" + calId2, null /* selectionArgs*/);
-        checkCalendarCount(1);
-        checkCalendarExists(calId1);
-        checkCalendarDoesNotExists(calId2);
-    }
-
-    public void testDeleteCalendarsWithSelectionAndArgs() {
-        checkCalendarCount(0);
-
-        int calId1 = insertCal("Calendar1", "America/Los_Angeles");
-        int calId2 = insertCal("Calendar2", "America/Los_Angeles");
-
-        checkCalendarCount(2);
-        checkCalendarExists(calId1);
-        checkCalendarExists(calId2);
-
-        deleteMatchingCalendars(Calendars._ID + "=?",
-                new String[] { Integer.toString(calId2) });
-        checkCalendarCount(1);
-        checkCalendarExists(calId1);
-        checkCalendarDoesNotExists(calId2);
-
-        deleteMatchingCalendars(Calendars._ID + "=?" + " AND " + Calendars.NAME + "=?",
-                new String[] { Integer.toString(calId1), "Calendar1" });
-        checkCalendarCount(0);
-    }
-
-    public void testGetColumnIndex_IsPrimary() {
-        checkCalendarCount(0);
-        int calendarId0 = insertCal("Calendar0", DEFAULT_TIMEZONE);
-
-        String[] projection = new String[] {
-            Calendars.ACCOUNT_NAME,
-            Calendars.CALENDAR_DISPLAY_NAME,
-            Calendars.OWNER_ACCOUNT,
-            Calendars.IS_PRIMARY
-        };
-        String selection = "((" + Calendars.ACCOUNT_NAME + " = ? ))";
-        String[] selectionArgs = new String[] {
-            DEFAULT_ACCOUNT
-        };
-        Cursor cursor = mResolver.query(Calendars.CONTENT_URI, projection, selection, selectionArgs,
-                null);
-        assertNotNull(cursor);
-        assertEquals(3, cursor.getColumnIndex(Calendars.IS_PRIMARY));
-        cursor.close();
-        deleteMatchingCalendars(Calendars._ID + "=" + calendarId0, null /* selectionArgs*/);
-        checkCalendarCount(0);
-    }
-
-    public void testGetColumnIndex_Count() {
-        checkCalendarCount(0);
-        int calendarId0 = insertCal("Calendar0", DEFAULT_TIMEZONE);
-
-        String[] projection = new String[] {
-            BaseColumns._COUNT
-        };
-        String selection = "((" + Calendars.ACCOUNT_NAME + " = ? ))";
-        String[] selectionArgs = new String[] {
-            DEFAULT_ACCOUNT
-        };
-        Cursor cursor = mResolver.query(Calendars.CONTENT_URI, projection, selection, selectionArgs,
-                null);
-        assertNotNull(cursor);
-        assertEquals(0, cursor.getColumnIndex(BaseColumns._COUNT));
-        cursor.close();
-        deleteMatchingCalendars(Calendars._ID + "=" + calendarId0, null /* selectionArgs*/);
-        checkCalendarCount(0);
-    }
-
-}
Index: packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/RecurrenceSetTest.java
===================================================================
--- packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/RecurrenceSetTest.java	(revision 168086)
+++ packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/RecurrenceSetTest.java	(revision 168087)
@@ -1,147 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.calendar;
-
-import com.android.calendarcommon2.ICalendar;
-import com.android.calendarcommon2.RecurrenceSet;
-
-import android.content.ContentValues;
-import android.provider.CalendarContract;
-import android.test.suitebuilder.annotation.SmallTest;
-import junit.framework.TestCase;
-
-import java.util.List;
-
-public class RecurrenceSetTest extends TestCase {
-
-    private static String MOCK_COMPONENT_NAME = "mockComponent";
-
-    private static final String RRULE_LESS_THAN_75_CHARS =
-            "FREQ=WEEKLY;BYDAY=SU,FR,SA;UNTIL=20100326T190000Z;WKST=MO";
-
-    private static final String RRULE_MORE_THAN_75_CHARS =
-            "FREQ=WEEKLY;WKST=MO;UNTIL=20100129T130000Z;INTERVAL=1;BYDAY=MO,TU,WE,TH,FR, SA,SU";
-
-    private static final String RRULE_MORE_THAN_75_CHARS_FOLDED =
-            "FREQ=WEEKLY;WKST=MO;UNTIL=20100129T130000Z;INTERVAL=1;BYDAY=MO,TU,WE,TH,FR,\r\n  SA,SU";
-
-    private static final String STRING_WITH_160_CHARS = "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789";
-
-    private static final String STRING_WITH_160_CHARS_FOLDED = "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "01234"
-            + "\r\n "
-            + "56789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "0123456789"
-            + "\r\n "
-            + "0123456789";
-
-    @SmallTest
-    public void testFoldPerRFC2445() {
-        assertEquals(RRULE_LESS_THAN_75_CHARS,
-                RecurrenceSet.fold(RRULE_LESS_THAN_75_CHARS));
-
-        assertEquals(RRULE_MORE_THAN_75_CHARS_FOLDED,
-                RecurrenceSet.fold(RRULE_MORE_THAN_75_CHARS));
-
-        assertEquals(STRING_WITH_160_CHARS_FOLDED,
-                RecurrenceSet.fold(STRING_WITH_160_CHARS));
-    }
-
-    @SmallTest
-    public void testUnFoldPerRFC2445() {
-        assertEquals(RRULE_LESS_THAN_75_CHARS,
-                RecurrenceSet.unfold(RRULE_LESS_THAN_75_CHARS));
-
-        assertEquals(RRULE_MORE_THAN_75_CHARS,
-                RecurrenceSet.unfold(RRULE_MORE_THAN_75_CHARS_FOLDED));
-
-        assertEquals(STRING_WITH_160_CHARS,
-                RecurrenceSet.unfold(STRING_WITH_160_CHARS_FOLDED));
-    }
-
-    @SmallTest
-    public void testRRULEfolding() {
-        ICalendar.Component component = new ICalendar.Component(MOCK_COMPONENT_NAME, null);
-
-        ContentValues values = new ContentValues();
-        values.put(CalendarContract.Events.DTSTART, 0);
-        values.put(CalendarContract.Events.DURATION, "P3600S");
-        values.put(CalendarContract.Events.RRULE, RRULE_LESS_THAN_75_CHARS);
-
-        assertTrue(RecurrenceSet.populateComponent(values, component));
-        List<ICalendar.Property> list = component.getProperties("DTSTART");
-        assertTrue(list.size() == 1);
-        assertEquals("19700101T000000Z", list.get(0).getValue());
-
-        list = component.getProperties("RRULE");
-        assertTrue(list.size() == 1);
-        assertEquals(RRULE_LESS_THAN_75_CHARS,list.get(0).getValue());
-
-        component = new ICalendar.Component(MOCK_COMPONENT_NAME, null);
-
-        values = new ContentValues();
-        values.put(CalendarContract.Events.DTSTART, 0);
-        values.put(CalendarContract.Events.DURATION, "P3600S");
-        values.put(CalendarContract.Events.RRULE, RRULE_MORE_THAN_75_CHARS);
-
-        assertTrue(RecurrenceSet.populateComponent(values, component));
-
-        list = component.getProperties("RRULE");
-        assertTrue(list.size() == 1);
-        assertEquals(RRULE_MORE_THAN_75_CHARS_FOLDED, list.get(0).getValue());
-
-        component = new ICalendar.Component(MOCK_COMPONENT_NAME, null);
-
-        values = new ContentValues();
-        values.put(CalendarContract.Events.DTSTART, 0);
-        values.put(CalendarContract.Events.DURATION, "P3600S");
-        values.put(CalendarContract.Events.RRULE, STRING_WITH_160_CHARS);
-
-        assertTrue(RecurrenceSet.populateComponent(values, component));
-
-        list = component.getProperties("RRULE");
-        assertTrue(list.size() == 1);
-        assertEquals(STRING_WITH_160_CHARS_FOLDED, list.get(0).getValue());
-    }
-}
Index: packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/CalendarProvider2ForTesting.java
===================================================================
--- packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/CalendarProvider2ForTesting.java	(revision 168086)
+++ packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/CalendarProvider2ForTesting.java	(revision 168087)
@@ -1,95 +0,0 @@
-package com.android.providers.calendar;
-
-import android.accounts.Account;
-import android.app.PendingIntent;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.net.Uri;
-import android.os.PowerManager;
-
-import java.util.concurrent.atomic.AtomicBoolean;
-
-public class CalendarProvider2ForTesting extends CalendarProvider2 {
-
-    /**
-     * For testing, don't want to start the TimezoneCheckerThread, as it results
-     * in race conditions.  Thus updateTimezoneDependentFields is stubbed out.
-     */
-    @Override
-    protected void updateTimezoneDependentFields() {
-    }
-
-    /**
-     * For testing, don't want onAccountsUpdated asynchronously deleting data.
-     */
-    @Override
-    public void onAccountsUpdated(Account[] accounts) {
-    }
-
-    @Override
-    protected void doUpdateTimezoneDependentFields() {
-    }
-
-    @Override
-    protected void postInitialize() {
-    }
-
-    @Override
-    protected void initCalendarAlarm() {
-        mCalendarAlarm = new MockCalendarAlarmManager(getContext());
-    }
-
-    @Override
-    protected boolean shouldSyncFor(Uri uri) {
-        return true;
-    }
-
-    private static class MockCalendarAlarmManager extends CalendarAlarmManager {
-
-        public MockCalendarAlarmManager(Context context) {
-            super(context);
-        }
-
-        @Override
-        protected void initializeWithContext(Context context) {
-            mContext = context;
-            mNextAlarmCheckScheduled = new AtomicBoolean(false);
-            mAlarmLock = new Object();
-        }
-
-        @Override
-        public void setExact(int type, long triggerAtTime, PendingIntent operation) {
-        }
-
-        @Override
-        public void setExactAndAllowWhileIdle(int type, long triggerAtTime,
-                PendingIntent operation) {
-        }
-
-        @Override
-        public void cancel(PendingIntent operation) {
-        }
-
-        @Override
-        public void scheduleAlarm(long alarmTime) {
-        }
-
-        @Override
-        public void rescheduleMissedAlarms(ContentResolver cr) {
-        }
-
-
-        @Override
-        PowerManager.WakeLock getScheduleNextAlarmWakeLock() {
-            return null;
-        }
-
-        @Override
-        void acquireScheduleNextAlarmWakeLock() {
-        }
-
-        @Override
-        void releaseScheduleNextAlarmWakeLock() {
-        }
-    }
-}
Index: packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/CalendarCacheTest.java
===================================================================
--- packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/CalendarCacheTest.java	(revision 168086)
+++ packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/CalendarCacheTest.java	(revision 168087)
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.providers.calendar;
-
-import android.database.sqlite.SQLiteOpenHelper;
-import android.test.AndroidTestCase;
-
-/**
- * Run various tests on CalendarCache
- *
- * Use the following command line:
- *
- * adb shell am instrument -e debug false -w -e class com.android.providers.calendar.CalendarCacheTest com.android.providers.calendar.tests/android.test.InstrumentationTestRunner
- *
- */
-public class CalendarCacheTest extends AndroidTestCase {
-
-    private SQLiteOpenHelper mDbHelper;
-    private CalendarCache mCalendarCache;
-    private static final String TIMEZONE_DB_2011A = "2011a";
-
-    private static final String TIMEZONE_AMERICA_LOS_ANGELES = "America/Los_Angeles";
-    private static final String TIMEZONE_AMERICA_DENVER = "America/Denver";
-
-    @Override
-    public void setUp() {
-        mDbHelper = CalendarDatabaseHelper.getInstance(getContext());
-        mCalendarCache = new CalendarCache(mDbHelper);
-    }
-
-    @Override
-    public void tearDown() {
-        if (mDbHelper != null) {
-            mDbHelper.close();
-            mDbHelper = null;
-            mCalendarCache = null;
-        }
-    }
-
-    public void testGenerateCacheException() {
-        boolean hasException = false;
-        try {
-            String value = mCalendarCache.readData(null);
-        } catch (CalendarCache.CacheException e) {
-            hasException = true;
-        }
-        assertTrue(hasException);
-    }
-
-    public void testWriteAndReadTimezoneDatabaseVersion() throws CalendarCache.CacheException {
-        mCalendarCache.writeTimezoneDatabaseVersion(TIMEZONE_DB_2011A);
-        assertEquals(TIMEZONE_DB_2011A, mCalendarCache.readTimezoneDatabaseVersion());
-    }
-
-    public void testWriteAndReadTimezone() throws CalendarCache.CacheException {
-        mCalendarCache.writeTimezoneInstances(TIMEZONE_AMERICA_DENVER);
-        assertEquals(TIMEZONE_AMERICA_DENVER, mCalendarCache.readTimezoneInstances());
-    }
-
-    public void testWriteAndReadTimezonePrevious() throws CalendarCache.CacheException {
-        mCalendarCache.writeTimezoneInstancesPrevious(TIMEZONE_AMERICA_LOS_ANGELES);
-        assertEquals(TIMEZONE_AMERICA_LOS_ANGELES, mCalendarCache.readTimezoneInstancesPrevious());
-    }
-
-    public void testWriteAndReadTimezoneType() throws CalendarCache.CacheException {
-        mCalendarCache.writeTimezoneType(CalendarCache.TIMEZONE_TYPE_AUTO);
-        assertEquals(CalendarCache.TIMEZONE_TYPE_AUTO, mCalendarCache.readTimezoneType());
-
-        mCalendarCache.writeTimezoneType(CalendarCache.TIMEZONE_TYPE_HOME);
-        assertEquals(CalendarCache.TIMEZONE_TYPE_HOME, mCalendarCache.readTimezoneType());
-    }
-}
Index: packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/CalendarDatabaseHelperTest.java
===================================================================
--- packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/CalendarDatabaseHelperTest.java	(revision 168086)
+++ packages/providers/CalendarProvider/tests/src/com/android/providers/calendar/CalendarDatabaseHelperTest.java	(revision 168087)
@@ -1,550 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License
- */
-package com.android.providers.calendar;
-
-
-import com.android.common.content.SyncStateContentProviderHelper;
-
-import android.database.Cursor;
-import android.database.DatabaseUtils;
-import android.database.sqlite.SQLiteDatabase;
-import android.test.mock.MockContext;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.text.TextUtils;
-import android.util.Log;
-
-import java.util.Arrays;
-
-import junit.framework.TestCase;
-
-public class CalendarDatabaseHelperTest extends TestCase {
-    private static final String TAG = "CDbHelperTest";
-
-    private SQLiteDatabase mBadDb;
-    private SQLiteDatabase mGoodDb;
-    private DatabaseUtils.InsertHelper mBadEventsInserter;
-    private DatabaseUtils.InsertHelper mGoodEventsInserter;
-
-    @Override
-    public void setUp() {
-        mBadDb = SQLiteDatabase.create(null);
-        assertNotNull(mBadDb);
-        mGoodDb = SQLiteDatabase.create(null);
-        assertNotNull(mGoodDb);
-    }
-
-    protected void bootstrapDbVersion50(SQLiteDatabase db) {
-
-        // TODO remove the dependency on this system class
-        SyncStateContentProviderHelper syncStateHelper = new SyncStateContentProviderHelper();
-        syncStateHelper.createDatabase(db);
-
-        db.execSQL("CREATE TABLE Calendars (" +
-                        "_id INTEGER PRIMARY KEY," +
-                        "_sync_account TEXT," +
-                        "_sync_id TEXT," +
-                        "_sync_version TEXT," +
-                        "_sync_time TEXT," +            // UTC
-                        "_sync_local_id INTEGER," +
-                        "_sync_dirty INTEGER," +
-                        "_sync_mark INTEGER," + // Used to filter out new rows
-                        "url TEXT," +
-                        "name TEXT," +
-                        "displayName TEXT," +
-                        "hidden INTEGER NOT NULL DEFAULT 0," +
-                        "color INTEGER," +
-                        "access_level INTEGER," +
-                        "selected INTEGER NOT NULL DEFAULT 1," +
-                        "sync_events INTEGER NOT NULL DEFAULT 0," +
-                        "location TEXT," +
-                        "timezone TEXT" +
-                        ");");
-
-        // Trigger to remove a calendar's events when we delete the calendar
-        db.execSQL("CREATE TRIGGER calendar_cleanup DELETE ON Calendars " +
-                    "BEGIN " +
-                        "DELETE FROM Events WHERE calendar_id = old._id;" +
-                        "DELETE FROM DeletedEvents WHERE calendar_id = old._id;" +
-                    "END");
-
-        // TODO: do we need both dtend and duration?
-        db.execSQL("CREATE TABLE Events (" +
-                        "_id INTEGER PRIMARY KEY," +
-                        "_sync_account TEXT," +
-                        "_sync_id TEXT," +
-                        "_sync_version TEXT," +
-                        "_sync_time TEXT," +            // UTC
-                        "_sync_local_id INTEGER," +
-                        "_sync_dirty INTEGER," +
-                        "_sync_mark INTEGER," + // To filter out new rows
-                        // TODO remove NOT NULL when upgrade rebuilds events to have
-                        // true v50 schema
-                        "calendar_id INTEGER NOT NULL," +
-                        "htmlUri TEXT," +
-                        "title TEXT," +
-                        "eventLocation TEXT," +
-                        "description TEXT," +
-                        "eventStatus INTEGER," +
-                        "selfAttendeeStatus INTEGER NOT NULL DEFAULT 0," +
-                        "commentsUri TEXT," +
-                        "dtstart INTEGER," +               // millis since epoch
-                        "dtend INTEGER," +                 // millis since epoch
-                        "eventTimezone TEXT," +         // timezone for event
-                        "duration TEXT," +
-                        "allDay INTEGER NOT NULL DEFAULT 0," +
-                        "visibility INTEGER NOT NULL DEFAULT 0," +
-                        "transparency INTEGER NOT NULL DEFAULT 0," +
-                        "hasAlarm INTEGER NOT NULL DEFAULT 0," +
-                        "hasExtendedProperties INTEGER NOT NULL DEFAULT 0," +
-                        "rrule TEXT," +
-                        "rdate TEXT," +
-                        "exrule TEXT," +
-                        "exdate TEXT," +
-                        "originalEvent TEXT," +
-                        "originalInstanceTime INTEGER," +  // millis since epoch
-                        "lastDate INTEGER" +               // millis since epoch
-                    ");");
-
-        db.execSQL("CREATE INDEX eventsCalendarIdIndex ON Events (calendar_id);");
-
-        db.execSQL("CREATE TABLE EventsRawTimes (" +
-                        "_id INTEGER PRIMARY KEY," +
-                        "event_id INTEGER NOT NULL," +
-                        "dtstart2445 TEXT," +
-                        "dtend2445 TEXT," +
-                        "originalInstanceTime2445 TEXT," +
-                        "lastDate2445 TEXT," +
-                        "UNIQUE (event_id)" +
-                    ");");
-
-        // NOTE: we do not create a trigger to delete an event's instances upon update,
-        // as all rows currently get updated during a merge.
-
-        db.execSQL("CREATE TABLE DeletedEvents (" +
-                        "_sync_id TEXT," +
-                        "_sync_version TEXT," +
-                        "_sync_account TEXT," +
-                        "_sync_mark INTEGER" + // To filter out new rows
-                    ");");
-
-        db.execSQL("CREATE TABLE Instances (" +
-                        "_id INTEGER PRIMARY KEY," +
-                        "event_id INTEGER," +
-                        "begin INTEGER," +         // UTC millis
-                        "end INTEGER," +           // UTC millis
-                        "startDay INTEGER," +      // Julian start day
-                        "endDay INTEGER," +        // Julian end day
-                        "startMinute INTEGER," +   // minutes from midnight
-                        "endMinute INTEGER," +     // minutes from midnight
-                        "UNIQUE (event_id, begin, end)" +
-                    ");");
-
-        db.execSQL("CREATE INDEX instancesStartDayIndex ON Instances (startDay);");
-
-        db.execSQL("CREATE TABLE CalendarMetaData (" +
-                        "_id INTEGER PRIMARY KEY," +
-                        "localTimezone TEXT," +
-                        "minInstance INTEGER," +      // UTC millis
-                        "maxInstance INTEGER," +      // UTC millis
-                        "minBusyBits INTEGER," +      // UTC millis
-                        "maxBusyBits INTEGER" +       // UTC millis
-        ");");
-
-        db.execSQL("CREATE TABLE BusyBits(" +
-                        "day INTEGER PRIMARY KEY," +  // the Julian day
-                        "busyBits INTEGER," +         // 24 bits for 60-minute intervals
-                        "allDayCount INTEGER" +       // number of all-day events
-        ");");
-
-        db.execSQL("CREATE TABLE Attendees (" +
-                        "_id INTEGER PRIMARY KEY," +
-                        "event_id INTEGER," +
-                        "attendeeName TEXT," +
-                        "attendeeEmail TEXT," +
-                        "attendeeStatus INTEGER," +
-                        "attendeeRelationship INTEGER," +
-                        "attendeeType INTEGER" +
-                   ");");
-
-        db.execSQL("CREATE INDEX attendeesEventIdIndex ON Attendees (event_id);");
-
-        db.execSQL("CREATE TABLE Reminders (" +
-                        "_id INTEGER PRIMARY KEY," +
-                        "event_id INTEGER," +
-                        "minutes INTEGER," +
-                        "method INTEGER NOT NULL" +
-                        " DEFAULT 0);");
-
-        db.execSQL("CREATE INDEX remindersEventIdIndex ON Reminders (event_id);");
-
-        // This table stores the Calendar notifications that have gone off.
-        db.execSQL("CREATE TABLE CalendarAlerts (" +
-                        "_id INTEGER PRIMARY KEY," +
-                        "event_id INTEGER," +
-                        "begin INTEGER NOT NULL," +        // UTC millis
-                        "end INTEGER NOT NULL," +          // UTC millis
-                        "alarmTime INTEGER NOT NULL," +    // UTC millis
-                        "state INTEGER NOT NULL," +
-                        "minutes INTEGER," +
-                        "UNIQUE (alarmTime, begin, event_id)" +
-                   ");");
-
-        db.execSQL("CREATE INDEX calendarAlertsEventIdIndex ON CalendarAlerts (event_id);");
-
-        db.execSQL("CREATE TABLE ExtendedProperties (" +
-                        "_id INTEGER PRIMARY KEY," +
-                        "event_id INTEGER," +
-                        "name TEXT," +
-                        "value TEXT" +
-                   ");");
-
-        db.execSQL("CREATE INDEX extendedPropertiesEventIdIndex ON ExtendedProperties (event_id);");
-
-        // Trigger to remove data tied to an event when we delete that event.
-        db.execSQL("CREATE TRIGGER events_cleanup_delete DELETE ON Events " +
-                    "BEGIN " +
-                        "DELETE FROM Instances WHERE event_id = old._id;" +
-                        "DELETE FROM EventsRawTimes WHERE event_id = old._id;" +
-                        "DELETE FROM Attendees WHERE event_id = old._id;" +
-                        "DELETE FROM Reminders WHERE event_id = old._id;" +
-                        "DELETE FROM CalendarAlerts WHERE event_id = old._id;" +
-                        "DELETE FROM ExtendedProperties WHERE event_id = old._id;" +
-                    "END");
-
-        // Triggers to set the _sync_dirty flag when an attendee is changed,
-        // inserted or deleted
-        db.execSQL("CREATE TRIGGER attendees_update UPDATE ON Attendees " +
-                    "BEGIN " +
-                        "UPDATE Events SET _sync_dirty=1 WHERE Events._id=old.event_id;" +
-                    "END");
-        db.execSQL("CREATE TRIGGER attendees_insert INSERT ON Attendees " +
-                    "BEGIN " +
-                        "UPDATE Events SET _sync_dirty=1 WHERE Events._id=new.event_id;" +
-                    "END");
-        db.execSQL("CREATE TRIGGER attendees_delete DELETE ON Attendees " +
-                    "BEGIN " +
-                        "UPDATE Events SET _sync_dirty=1 WHERE Events._id=old.event_id;" +
-                    "END");
-
-        // Triggers to set the _sync_dirty flag when a reminder is changed,
-        // inserted or deleted
-        db.execSQL("CREATE TRIGGER reminders_update UPDATE ON Reminders " +
-                    "BEGIN " +
-                        "UPDATE Events SET _sync_dirty=1 WHERE Events._id=old.event_id;" +
-                    "END");
-        db.execSQL("CREATE TRIGGER reminders_insert INSERT ON Reminders " +
-                    "BEGIN " +
-                        "UPDATE Events SET _sync_dirty=1 WHERE Events._id=new.event_id;" +
-                    "END");
-        db.execSQL("CREATE TRIGGER reminders_delete DELETE ON Reminders " +
-                    "BEGIN " +
-                        "UPDATE Events SET _sync_dirty=1 WHERE Events._id=old.event_id;" +
-                    "END");
-        // Triggers to set the _sync_dirty flag when an extended property is changed,
-        // inserted or deleted
-        db.execSQL("CREATE TRIGGER extended_properties_update UPDATE ON ExtendedProperties " +
-                    "BEGIN " +
-                        "UPDATE Events SET _sync_dirty=1 WHERE Events._id=old.event_id;" +
-                    "END");
-        db.execSQL("CREATE TRIGGER extended_properties_insert UPDATE ON ExtendedProperties " +
-                    "BEGIN " +
-                        "UPDATE Events SET _sync_dirty=1 WHERE Events._id=new.event_id;" +
-                    "END");
-        db.execSQL("CREATE TRIGGER extended_properties_delete UPDATE ON ExtendedProperties " +
-                    "BEGIN " +
-                        "UPDATE Events SET _sync_dirty=1 WHERE Events._id=old.event_id;" +
-                    "END");
-    }
-
-    private void createVersion67EventsTable(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE Events (" +
-                "_id INTEGER PRIMARY KEY," +
-                "_sync_account TEXT," +
-                "_sync_account_type TEXT," +
-                "_sync_id TEXT," +
-                "_sync_version TEXT," +
-                "_sync_time TEXT," +            // UTC
-                "_sync_local_id INTEGER," +
-                "_sync_dirty INTEGER," +
-                "_sync_mark INTEGER," + // To filter out new rows
-                "calendar_id INTEGER NOT NULL," +
-                "htmlUri TEXT," +
-                "title TEXT," +
-                "eventLocation TEXT," +
-                "description TEXT," +
-                "eventStatus INTEGER," +
-                "selfAttendeeStatus INTEGER NOT NULL DEFAULT 0," +
-                "commentsUri TEXT," +
-                "dtstart INTEGER," +               // millis since epoch
-                "dtend INTEGER," +                 // millis since epoch
-                "eventTimezone TEXT," +         // timezone for event
-                "duration TEXT," +
-                "allDay INTEGER NOT NULL DEFAULT 0," +
-                "visibility INTEGER NOT NULL DEFAULT 0," +
-                "transparency INTEGER NOT NULL DEFAULT 0," +
-                "hasAlarm INTEGER NOT NULL DEFAULT 0," +
-                "hasExtendedProperties INTEGER NOT NULL DEFAULT 0," +
-                "rrule TEXT," +
-                "rdate TEXT," +
-                "exrule TEXT," +
-                "exdate TEXT," +
-                "originalEvent TEXT," +  // _sync_id of recurring event
-                "originalInstanceTime INTEGER," +  // millis since epoch
-                "originalAllDay INTEGER," +
-                "lastDate INTEGER," +               // millis since epoch
-                "hasAttendeeData INTEGER NOT NULL DEFAULT 0," +
-                "guestsCanModify INTEGER NOT NULL DEFAULT 0," +
-                "guestsCanInviteOthers INTEGER NOT NULL DEFAULT 1," +
-                "guestsCanSeeGuests INTEGER NOT NULL DEFAULT 1," +
-                "organizer STRING," +
-                "deleted INTEGER NOT NULL DEFAULT 0," +
-                "dtstart2 INTEGER," + //millis since epoch, allDay events in local timezone
-                "dtend2 INTEGER," + //millis since epoch, allDay events in local timezone
-                "eventTimezone2 TEXT," + //timezone for event with allDay events in local timezone
-                "syncAdapterData TEXT" + //available for use by sync adapters
-                ");");
-    }
-
-    private void addVersion50Events() {
-        // April 5th 1:01:01 AM to April 6th 1:01:01
-        mBadDb.execSQL("INSERT INTO Events (_id,dtstart,dtend,duration," +
-                "eventTimezone,allDay,calendar_id) " +
-                "VALUES (1,1270454471000,1270540872000,'P10S'," +
-                "'America/Los_Angeles',1,1);");
-
-        // April 5th midnight to April 6th midnight, duration cleared
-        mGoodDb.execSQL("INSERT INTO Events (_id,dtstart,dtend,duration," +
-                "eventTimezone,allDay,calendar_id) " +
-                "VALUES (1,1270425600000,1270512000000,null," +
-                "'UTC',1,1);");
-
-        // April 5th 1:01:01 AM to April 6th 1:01:01, recurring weekly (We only check for the
-        // existence of an rrule so it doesn't matter if the day is correct)
-        mBadDb.execSQL("INSERT INTO Events (_id,dtstart,dtend,duration," +
-                "eventTimezone,allDay,rrule,calendar_id) " +
-                "VALUES (2,1270454462000,1270540863000," +
-                "'P10S','America/Los_Angeles',1," +
-                "'WEEKLY:MON',1);");
-
-        // April 5th midnight with 1 day duration, if only dtend was wrong we wouldn't fix it, but
-        // if anything else is wrong we clear dtend to be sure.
-        mGoodDb.execSQL("INSERT INTO Events (" +
-                "_id,dtstart,dtend,duration," +
-                "eventTimezone,allDay,rrule,calendar_id)" +
-                "VALUES (2,1270425600000,null,'P1D'," +
-                "'UTC',1," +
-                "'WEEKLY:MON',1);");
-
-        assertEquals(mBadDb.rawQuery("SELECT _id FROM Events;", null).getCount(), 2);
-        assertEquals(mGoodDb.rawQuery("SELECT _id FROM Events;", null).getCount(), 2);
-    }
-
-    private void addVersion67Events() {
-        // April 5th 1:01:01 AM to April 6th 1:01:01
-        mBadDb.execSQL("INSERT INTO Events (_id,dtstart,dtend,duration,dtstart2,dtend2," +
-                "eventTimezone,eventTimezone2,allDay,calendar_id) " +
-                "VALUES (1,1270454471000,1270540872000,'P10S'," +
-                "1270454460000,1270540861000,'America/Los_Angeles','America/Los_Angeles',1,1);");
-
-        // April 5th midnight to April 6th midnight, duration cleared
-        mGoodDb.execSQL("INSERT INTO Events (_id,dtstart,dtend,duration,dtstart2,dtend2," +
-                "eventTimezone,eventTimezone2,allDay,calendar_id) " +
-                "VALUES (1,1270425600000,1270512000000,null," +
-                "1270450800000,1270537200000,'UTC','America/Los_Angeles',1,1);");
-
-        // April 5th 1:01:01 AM to April 6th 1:01:01, recurring weekly (We only check for the
-        // existence of an rrule so it doesn't matter if the day is correct)
-        mBadDb.execSQL("INSERT INTO Events (_id,dtstart,dtend,duration,dtstart2,dtend2," +
-                "eventTimezone,eventTimezone2,allDay,rrule,calendar_id) " +
-                "VALUES (2,1270454462000,1270540863000," +
-                "'P10S',1270454461000,1270540861000,'America/Los_Angeles','America/Los_Angeles',1," +
-                "'WEEKLY:MON',1);");
-
-        // April 5th midnight with 1 day duration, if only dtend was wrong we wouldn't fix it, but
-        // if anything else is wrong we clear dtend to be sure.
-        mGoodDb.execSQL("INSERT INTO Events (" +
-                "_id,dtstart,dtend,duration,dtstart2,dtend2," +
-                "eventTimezone,eventTimezone2,allDay,rrule,calendar_id)" +
-                "VALUES (2,1270425600000,null,'P1D',1270450800000,null," +
-                "'UTC','America/Los_Angeles',1," +
-                "'WEEKLY:MON',1);");
-
-        assertEquals(mBadDb.rawQuery("SELECT _id FROM Events;", null).getCount(), 2);
-        assertEquals(mGoodDb.rawQuery("SELECT _id FROM Events;", null).getCount(), 2);
-    }
-
-    @MediumTest
-    public void testUpgradeToVersion69() {
-        // Create event tables
-        createVersion67EventsTable(mBadDb);
-        createVersion67EventsTable(mGoodDb);
-        // Fill in good and bad events
-        addVersion67Events();
-        // Run the upgrade on the bad events
-        CalendarDatabaseHelper.upgradeToVersion69(mBadDb);
-        Cursor badCursor = null;
-        Cursor goodCursor = null;
-        try {
-            badCursor = mBadDb.rawQuery("SELECT _id,dtstart,dtend,duration,dtstart2,dtend2," +
-                    "eventTimezone,eventTimezone2,rrule FROM Events WHERE allDay=?",
-                    new String[] {"1"});
-            goodCursor = mGoodDb.rawQuery("SELECT _id,dtstart,dtend,duration,dtstart2,dtend2," +
-                    "eventTimezone,eventTimezone2,rrule FROM Events WHERE allDay=?",
-                    new String[] {"1"});
-            // Check that we get the correct results back
-            assertTrue(compareCursors(badCursor, goodCursor));
-        } finally {
-            if (badCursor != null) {
-                badCursor.close();
-            }
-            if (goodCursor != null) {
-                goodCursor.close();
-            }
-        }
-    }
-
-    @MediumTest
-    public void testUpgradeToCurrentVersion() {
-        // Create event tables
-        bootstrapDbVersion50(mBadDb);
-        bootstrapDbVersion50(mGoodDb);
-        // Fill in good and bad events
-        addVersion50Events();
-        // Run the upgrade on the bad events
-        CalendarDatabaseHelper cDbHelper = new CalendarDatabaseHelper(new MockContext());
-        cDbHelper.mInTestMode = true;
-        cDbHelper.onUpgrade(mBadDb, 50, CalendarDatabaseHelper.DATABASE_VERSION);
-        Cursor badCursor = null;
-        Cursor goodCursor = null;
-        try {
-            badCursor = mBadDb.rawQuery("SELECT _id,dtstart,dtend,duration," +
-                    "eventTimezone,rrule FROM Events WHERE allDay=?",
-                    new String[] {"1"});
-            goodCursor = mGoodDb.rawQuery("SELECT _id,dtstart,dtend,duration," +
-                    "eventTimezone,rrule FROM Events WHERE allDay=?",
-                    new String[] {"1"});
-            // Check that we get the correct results back
-            assertTrue(compareCursors(badCursor, goodCursor));
-        } finally {
-            if (badCursor != null) {
-                badCursor.close();
-            }
-            if (goodCursor != null) {
-                goodCursor.close();
-            }
-        }
-    }
-
-    private static final String SQLITE_MASTER = "sqlite_master";
-
-    private static final String[] PROJECTION = {"tbl_name", "sql"};
-
-    public void testSchemasEqualForAllTables() {
-
-        CalendarDatabaseHelper cDbHelper = new CalendarDatabaseHelper(new MockContext());
-        cDbHelper.mInTestMode = true;
-        bootstrapDbVersion50(mBadDb);
-        cDbHelper.onCreate(mGoodDb);
-        cDbHelper.onUpgrade(mBadDb, 50, CalendarDatabaseHelper.DATABASE_VERSION);
-        // Check that for all tables, schema definitions are the same between updated db and new db.
-        Cursor goodCursor = mGoodDb.query(SQLITE_MASTER, PROJECTION, null, null, null, null,
-                "tbl_name,sql" /* orderBy */);
-        Cursor badCursor = mBadDb.query(SQLITE_MASTER, PROJECTION, null, null, null, null,
-                "tbl_name,sql" /* orderBy */);
-
-        while (goodCursor.moveToNext()) {
-            String goodTableName = goodCursor.getString(0);
-            // Ignore tables that do not belong to calendar
-            if (goodTableName.startsWith("sqlite_") || goodTableName.equals("android_metadata")) {
-                continue;
-            }
-
-            // Ignore tables that do not belong to calendar
-            String badTableName;
-            do {
-                assertTrue("Should have same number of tables", badCursor.moveToNext());
-                badTableName = badCursor.getString(0);
-            } while (badTableName.startsWith("sqlite_") || badTableName.equals("android_metadata"));
-
-            assertEquals("Table names different between upgraded schema and freshly-created scheme",
-                    goodTableName, badTableName);
-
-            String badString = badCursor.getString(1);
-            String goodString = goodCursor.getString(1);
-            if (badString == null && goodString == null) {
-                continue;
-            }
-            // Have to strip out some special characters and collapse spaces to
-            // get reasonable output
-            badString = badString.replaceAll("[()]", "");
-            goodString = goodString.replaceAll("[()]", "");
-            badString = badString.replaceAll(" +", " ");
-            goodString = goodString.replaceAll(" +", " ");
-            // And then split on commas and trim whitespace
-            String[] badSql = badString.split(",");
-            String[] goodSql = goodString.split(",");
-            for (int i = 0; i < badSql.length; i++) {
-                badSql[i] = badSql[i].trim();
-            }
-            for (int i = 0; i < goodSql.length; i++) {
-                goodSql[i] = goodSql[i].trim();
-            }
-            Arrays.sort(badSql);
-            Arrays.sort(goodSql);
-            assertTrue("Table schema different for table " + goodCursor.getString(0) + ": <"
-                    + Arrays.toString(goodSql) + "> -- <" + Arrays.toString(badSql) + ">",
-                    Arrays.equals(goodSql, badSql));
-        }
-        assertFalse("Should have same number of tables", badCursor.moveToNext());
-    }
-
-    /**
-     * Compares two cursors to see if they contain the same data.
-     *
-     * @return Returns true of the cursors contain the same data and are not null, false
-     * otherwise
-     */
-    private static boolean compareCursors(Cursor c1, Cursor c2) {
-        if(c1 == null || c2 == null) {
-            Log.d("CDBT","c1 is " + c1 + " and c2 is " + c2);
-            return false;
-        }
-
-        int numColumns = c1.getColumnCount();
-        if (numColumns != c2.getColumnCount()) {
-            Log.d("CDBT","c1 has " + numColumns + " columns and c2 has " + c2.getColumnCount());
-            return false;
-        }
-
-        if (c1.getCount() != c2.getCount()) {
-            Log.d("CDBT","c1 has " + c1.getCount() + " rows and c2 has " + c2.getCount());
-            return false;
-        }
-
-        c1.moveToPosition(-1);
-        c2.moveToPosition(-1);
-        while(c1.moveToNext() && c2.moveToNext()) {
-            for(int i = 0; i < numColumns; i++) {
-                if(!TextUtils.equals(c1.getString(i),c2.getString(i))) {
-                    Log.d("CDBT", c1.getString(i) + "\n" + c2.getString(i));
-                    return false;
-                }
-            }
-        }
-
-        return true;
-    }
-}
Index: packages/providers/CalendarProvider/CleanSpec.mk
===================================================================
--- packages/providers/CalendarProvider/CleanSpec.mk	(revision 168086)
+++ packages/providers/CalendarProvider/CleanSpec.mk	(revision 168087)
@@ -1,49 +0,0 @@
-# Copyright (C) 2007 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-# If you don't need to do a full clean build but would like to touch
-# a file or delete some intermediate files, add a clean step to the end
-# of the list.  These steps will only be run once, if they haven't been
-# run before.
-#
-# E.g.:
-#     $(call add-clean-step, touch -c external/sqlite/sqlite3.h)
-#     $(call add-clean-step, rm -rf $(PRODUCT_OUT)/obj/STATIC_LIBRARIES/libz_intermediates)
-#
-# Always use "touch -c" and "rm -f" or "rm -rf" to gracefully deal with
-# files that are missing or have been moved.
-#
-# Use $(PRODUCT_OUT) to get to the "out/target/product/blah/" directory.
-# Use $(OUT_DIR) to refer to the "out" directory.
-#
-# If you need to re-do something that's already mentioned, just copy
-# the command and add it to the bottom of the list.  E.g., if a change
-# that you made last week required touching a file and a change you
-# made today requires touching the same file, just copy the old
-# touch step and add it to the end of the list.
-#
-# ************************************************
-# NEWER CLEAN STEPS MUST BE AT THE END OF THE LIST
-# ************************************************
-
-# For example:
-#$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/APPS/AndroidTests_intermediates)
-#$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/JAVA_LIBRARIES/core_intermediates)
-#$(call add-clean-step, find $(OUT_DIR) -type f -name "IGTalkSession*" -print0 | xargs -0 rm -f)
-#$(call add-clean-step, rm -rf $(PRODUCT_OUT)/data/*)
-
-# ************************************************
-# NEWER CLEAN STEPS MUST BE AT THE END OF THE LIST
-# ************************************************
Index: packages/providers/CalendarProvider/Android.mk
===================================================================
--- packages/providers/CalendarProvider/Android.mk	(revision 168086)
+++ packages/providers/CalendarProvider/Android.mk	(revision 168087)
@@ -1,4 +1,9 @@
 #
+# Copyright (C) 2014 MediaTek Inc.
+# Modification based on code covered by the mentioned copyright
+# and/or permission notice(s).
+#
+#
 # Copyright (C) 2008 The Android Open Source Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
@@ -15,29 +20,24 @@
 #
 LOCAL_PATH := $(call my-dir)
 include $(CLEAR_VARS)
-
+LOCAL_MODULE := CalendarProvider
 LOCAL_MODULE_TAGS := optional
 
-LOCAL_STATIC_JAVA_LIBRARIES := guava \
-        android-common \
-        calendar-common
+LOCAL_SRC_FILES := CalendarProvider.apk
 
-LOCAL_SRC_FILES := $(call all-java-files-under,src)
-LOCAL_SRC_FILES += \
-        src/com/android/providers/calendar/EventLogTags.logtags
+LOCAL_MODULE_CLASS := APPS
+LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
 
-LOCAL_PACKAGE_NAME := CalendarProvider
-
 LOCAL_PRIVILEGED_MODULE := true
 
-# The Jacoco tool analyzes code coverage when running unit tests on the
+LOCAL_CERTIFICATE := PRESIGNED
+
+# The Emma tool analyzes code coverage when running unit tests on the
 # application. This configuration line selects which packages will be analyzed,
 # leaving out code which is tested by other means (e.g. static libraries) that
 # would dilute the coverage results. These options do not affect regular
 # production builds.
-LOCAL_JACK_COVERAGE_INCLUDE_FILTER := com.android.providers.calendar.*
+LOCAL_EMMA_COVERAGE_FILTER := +com.android.providers.calendar.*, +com.mediatek.providers.calendar.*
 
-include $(BUILD_PACKAGE)
+include $(BUILD_PREBUILT)
 
-# Use the following include to make our test apk.
-include $(call all-makefiles-under,$(LOCAL_PATH))
Index: packages/providers/CalendarProvider/CalendarProvider.apk
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: packages/providers/CalendarProvider/CalendarProvider.apk
===================================================================
--- packages/providers/CalendarProvider/CalendarProvider.apk	(revision 0)
+++ packages/providers/CalendarProvider/CalendarProvider.apk	(revision 168087)

Property changes on: packages/providers/CalendarProvider/CalendarProvider.apk
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
