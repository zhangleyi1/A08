Index: vendor/custom/cts/packages/apps/Messaging/AndroidManifest.xml
===================================================================
--- vendor/custom/cts/packages/apps/Messaging/AndroidManifest.xml	(revision 0)
+++ vendor/custom/cts/packages/apps/Messaging/AndroidManifest.xml	(revision 173004)
@@ -0,0 +1,783 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (C) 2015 The Android Open Source Project
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.android.messaging"
+    android:installLocation="internalOnly" 
+    android:sharedUserId="com.android.messaging.plugins"><!-- bug 478514: Add for MmsFolderView Feature -->
+
+    <uses-sdk
+        android:minSdkVersion="19"
+        android:targetSdkVersion="23" />
+    <!-- #501064 Grant permission to other apps to view messages attachments -->
+    <!-- STOPSHIP: protectionLevel should not be dangerous -->
+    <permission android:name="com.android.messages.permission.READ_MESSAGES_ATTACHMENT"
+        android:permissionGroup="android.permission-group.MESSAGES"
+        android:protectionLevel="dangerous"
+        android:label="@string/permission_read_messages_attachment_label"
+        android:description="@string/permission_read_messages_attachment_desc"/>
+    <uses-permission android:name="com.android.messages.permission.READ_MESSAGES_ATTACHMENT"/>
+    <uses-permission android:name="com.android.email.permission.READ_ATTACHMENT"/>
+    <!-- Application holds CPU wakelock while working in background -->
+    <uses-permission android:name="android.permission.WAKE_LOCK" />
+    <!-- Application needs SMS/MMS permissions -->
+    <uses-permission android:name="android.permission.READ_SMS" />
+    <uses-permission android:name="android.permission.WRITE_SMS" />
+    <uses-permission android:name="android.permission.RECEIVE_SMS" />
+    <uses-permission android:name="android.permission.RECEIVE_MMS" />
+    <uses-permission android:name="android.permission.SEND_SMS" />
+    <uses-permission android:name="android.permission.RECEIVE_WAP_PUSH"/>
+    <!-- Application needs access to MMS network -->
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+    <uses-permission android:name="android.permission.CHANGE_NETWORK_STATE" />
+    <!-- Application needs CONTACT permissions -->
+    <uses-permission android:name="android.permission.READ_CONTACTS" />
+    <uses-permission android:name="android.permission.WRITE_CONTACTS" />
+    <!-- Application needs to read profiles for the user itself from CP2 -->
+    <uses-permission android:name="android.permission.READ_PROFILE" />
+    <uses-permission android:name="android.permission.VIBRATE" />
+    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
+    <uses-permission android:name="android.permission.CAMERA" />
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
+    <uses-permission android:name="android.permission.RECORD_AUDIO" />
+    <uses-permission android:name="android.permission.CALL_PHONE" />
+    <uses-permission android:name="android.permission.DOWNLOAD_WITHOUT_NOTIFICATION" />
+    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
+    <uses-permission android:name="android.permission.MODIFY_PHONE_STATE" />
+    <!-- SPED: add for  permission -->
+    <uses-permission android:name="android.permission.MANAGE_DOCUMENTS" />
+    <uses-permission android:name="android.permission.READ_MESSAGES_ATTACHMENT"/>
+    <!-- Optional features -->
+    <uses-permission android:name="android.permission.WRITE_MEDIA_STORAGE" />
+
+    <uses-permission android:name="android.permission.WRITE_SECURE_SETTINGS" />
+
+    <uses-feature
+        android:name="android.hardware.camera"
+        android:required="false" />
+    <uses-feature
+        android:name="android.hardware.camera.front"
+        android:required="false" />
+    <uses-feature
+        android:name="android.hardware.camera.autofocus"
+        android:required="false" />
+    <uses-feature
+        android:name="android.hardware.microphone"
+        android:required="false" />
+    <uses-feature
+        android:name="android.hardware.screen.portrait"
+        android:required="false" />
+
+    <application
+        android:name="com.android.messaging.BugleApplication"
+        android:allowBackup="false"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:supportsRtl="true"
+        android:theme="@style/BugleTheme" >
+ <meta-data
+  android:name="cn.cmcc.online.smsapi.API_KEY"
+  android:value="93e36ba5ad0847d7be911097a084f334"/>
+ 
+        <!-- Displays a list of conversations -->
+        <!-- add for bug 495194 begin -->
+        <activity
+            android:name=".ui.conversationlist.ConversationListActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:label="@string/app_name"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme.ConversationListActivity" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.APP_MESSAGING" />
+            </intent-filter>
+            <meta-data
+                android:name="android.app.default_searchable"
+                android:value=".ui.SearchActivity" />
+            <!-- add for bug 495194 end -->
+        </activity>
+        <activity
+            android:name="com.android.messaging.smil.ui.SmilMainActivity"
+            android:screenOrientation="portrait"
+            android:configChanges="orientation|keyboardHidden"
+            android:label="@string/app_name"
+            android:theme="@style/BugleTheme.ConversationListActivity" >
+            <intent-filter>
+                <category android:name="android.intent.category.Smil_edit" />
+            </intent-filter>
+        </activity>
+
+        <activity
+            android:name=".ui.PermissionCheckActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:screenOrientation="portrait" />
+
+        <!-- Launches a conversation (ensures correct app name shown in recents) -->
+        <activity
+            android:name=".ui.conversation.LaunchConversationActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:documentLaunchMode="always"
+            android:noHistory="true"
+            android:screenOrientation="user"
+            android:theme="@style/Invisible" >
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+                <action android:name="android.intent.action.SENDTO" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.BROWSABLE" />
+                <data android:scheme="sms" />
+                <data android:scheme="smsto" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+                <action android:name="android.intent.action.SENDTO" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.BROWSABLE" />
+                <data android:scheme="mms" />
+                <data android:scheme="mmsto" />
+            </intent-filter>
+        </activity>
+        <!-- add for bug 495194 begin -->
+        <activity
+            android:name=".ui.SearchActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:label="@string/search"
+            android:launchMode="singleTask"
+            android:theme="@style/MmsHoloThemeNewui" >
+            <intent-filter>
+                <action android:name="android.intent.action.SEARCH" />
+
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+            <meta-data
+                android:name="android.app.searchable"
+                android:resource="@xml/searchable" />
+        </activity>
+        <!-- add for bug 495194 end -->
+
+        <!-- Displays a list of archived conversations -->
+        <activity
+            android:name=".ui.conversationlist.ArchivedConversationListActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:label="@string/archived_activity_title"
+            android:parentActivityName="com.android.messaging.ui.conversationlist.ConversationListActivity"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme.ArchivedConversationListActivity" >
+            <meta-data
+                android:name="android.support.PARENT_ACTIVITY"
+                android:value="com.android.messaging.ui.conversationlist.ConversationListActivity" />
+        </activity>
+
+        <!-- Displays the contents of a single conversation -->
+        <activity
+            android:name=".ui.conversation.ConversationActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:parentActivityName="com.android.messaging.ui.conversationlist.ConversationListActivity"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme.ConversationActivity"
+            android:windowSoftInputMode="stateHidden|adjustResize" >
+            <meta-data
+                android:name="android.support.PARENT_ACTIVITY"
+                android:value="com.android.messaging.ui.conversationlist.ConversationListActivity" />
+        </activity>
+
+        <!-- Blocked Participants -->
+        <activity
+            android:name=".ui.BlockedParticipantsActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:label="@string/blocked_contacts_title"
+            android:parentActivityName="com.android.messaging.ui.conversationlist.ConversationListActivity"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme" >
+            <meta-data
+                android:name="android.support.PARENT_ACTIVITY"
+                android:value="com.android.messaging.ui.conversationlist.ConversationListActivity" />
+        </activity>
+
+        <!-- Full-screen photo viewer -->
+        <!-- Modify by SPRD for Bug:498144  2015.12.02 Start -->
+        <activity
+            android:name=".ui.photoviewer.BuglePhotoViewActivity"
+            android:configChanges="screenSize|keyboardHidden"
+            android:label="@string/photo_view_activity_title"
+            android:screenOrientation="nosensor"
+            android:theme="@style/BuglePhotoViewTheme" />
+        <!-- Modify by SPRD for Bug:498144  2015.12.02 End -->
+        <!-- Settings -->
+        <activity
+            android:name=".ui.appsettings.SettingsActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:label="@string/settings_activity_title"
+            android:parentActivityName="com.android.messaging.ui.conversationlist.ConversationListActivity"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme.SettingsActivity" >
+            <meta-data
+                android:name="android.support.PARENT_ACTIVITY"
+                android:value="com.android.messaging.ui.conversationlist.ConversationListActivity" />
+        </activity>
+        <activity
+            android:name=".ui.appsettings.PerSubscriptionSettingsActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:label="@string/advanced_settings_activity_title"
+            android:parentActivityName="com.android.messaging.ui.appsettings.SettingsActivity"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme.SettingsActivity" >
+            <meta-data
+                android:name="android.support.PARENT_ACTIVITY"
+                android:value="com.android.messaging.ui.appsettings.SettingsActivity" />
+        </activity>
+        <activity
+            android:name=".ui.appsettings.ApplicationSettingsActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:label="@string/general_settings_activity_title"
+            android:parentActivityName="com.android.messaging.ui.appsettings.SettingsActivity"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme.SettingsActivity" >
+            <meta-data
+                android:name="android.support.PARENT_ACTIVITY"
+                android:value="com.android.messaging.ui.appsettings.SettingsActivity" />
+
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.NOTIFICATION_PREFERENCES" />
+            </intent-filter>
+        </activity>
+
+        <!-- Handles sharing intent -->
+
+        <!-- Add by SPRD for Bug:501210 2015.11.24 Start !-->
+        <!--<activity-->
+        <!--android:name=".ui.conversationlist.ShareIntentActivity"-->
+        <!--android:configChanges="orientation|screenSize|keyboardHidden"-->
+        <!--android:documentLaunchMode="always"-->
+        <!--android:excludeFromRecents="true"-->
+        <!--android:screenOrientation="user"-->
+        <!--android:theme="@style/BugleTheme.DialogActivity.Invisible" >-->
+        <activity
+            android:name=".ui.conversationlist.ShareIntentActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:documentLaunchMode="always"
+            android:excludeFromRecents="true"
+            android:screenOrientation="user"
+            android:launchMode="singleTop"
+            android:theme="@style/BugleTheme.DialogActivity.Invisible" >
+        <!-- Add by SPRD for Bug:501210 2015.11.24 End !-->
+
+            <intent-filter android:label="@string/share_intent_label" >
+                <action android:name="android.intent.action.SEND" />
+
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:mimeType="text/plain" />
+                <data android:mimeType="text/x-vCard" />
+                <data android:mimeType="text/x-vcard" />
+                <data android:mimeType="text/x-vCalendar" />
+                <data android:mimeType="text/x-vcalendar" />
+                <data android:mimeType="image/*" />
+                <data android:mimeType="audio/*" />
+                <data android:mimeType="video/*" />
+                <data android:mimeType="application/ogg" />
+                <data android:mimeType="application/vnd.oma.drm.content" />
+                <data android:mimeType="application/vnd.oma.drm.message" />
+            </intent-filter>
+            <intent-filter android:label="@string/share_intent_label" >
+                <action android:name="android.intent.action.SEND_MULTIPLE" />
+
+                <category android:name="android.intent.category.DEFAULT" />
+		
+                <data android:mimeType="image/*" />
+		
+            </intent-filter>
+        </activity>
+
+        <!-- People & Options -->
+        <activity
+            android:name=".ui.conversationsettings.PeopleAndOptionsActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:label="@string/people_and_options_activity_title"
+            android:parentActivityName="com.android.messaging.ui.conversation.ConversationActivity"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme" >
+            <meta-data
+                android:name="android.support.PARENT_ACTIVITY"
+                android:value="com.android.messaging.ui.conversation.ConversationActivity" />
+        </activity>
+
+        <!-- License -->
+        <activity
+            android:name=".ui.LicenseActivity"
+            android:exported="true"
+            android:label="@string/menu_license"
+            android:theme="@android:style/Theme.Holo.Light.Dialog" >
+        </activity>
+
+        <!-- Message Forwarding -->
+        <activity
+            android:name=".ui.conversationlist.ForwardMessageActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:label="@string/forward_message_activity_title"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme.DialogActivity" >
+        </activity>
+
+        <!--
+             Entry point for handling remote input/actions. Currently, this is only used by Android
+             Wear to send voice replies. Since that uses PendingIntents, we don't need to export
+             this activity. If we want other apps to be able to use this activity at will,
+             we'll need to guard it with a signature-matching protected permission. We would also
+             need to add an intent filter and remove the android:exported attribute.
+        -->
+        <activity
+            android:name=".ui.RemoteInputEntrypointActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:exported="false"
+            android:screenOrientation="user"
+            android:theme="@style/Invisible" >
+        </activity>
+
+        <!-- VCard details -->
+        <activity
+            android:name=".ui.VCardDetailActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:label="@string/vcard_detail_activity_title"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme" >
+            <meta-data
+                android:name="android.support.PARENT_ACTIVITY"
+                android:value=".ui.conversation.ConversationActivity" />
+        </activity>
+
+        <!-- Attachment chooser -->
+        <activity
+            android:name=".ui.attachmentchooser.AttachmentChooserActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:label="@string/attachment_chooser_activity_title"
+            android:parentActivityName="com.android.messaging.ui.conversation.ConversationActivity"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme" >
+            <meta-data
+                android:name="android.support.PARENT_ACTIVITY"
+                android:value="com.android.messaging.ui.conversation.ConversationActivity" />
+        </activity>
+
+        <!--
+             Test activity that we use to host fragments/views. Unfortunately, apparently necessary
+             because Android framework test cases want activity to be in the instrumented package.
+             See http://developer.android.com/reference/android/test/ActivityInstrumentationTestCase2.html
+        -->
+        <activity
+            android:name=".ui.TestActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden" >
+        </activity>
+        <activity
+            android:name=".ui.debug.DebugMmsConfigActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:exported="false"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme.DialogActivity" >
+        </activity>
+        <!-- bug 495194 : add for search feature begin -->
+        <provider
+            android:name=".datamodel.data.SuggestionsProvider"
+            android:authorities="com.android.mms.SuggestionsProvider"
+            android:exported="true"
+            android:readPermission="android.permission.READ_SMS" >
+            <path-permission
+                android:pathPrefix="/search_suggest_query"
+                android:readPermission="android.permission.GLOBAL_SEARCH" />
+            <path-permission
+                android:pathPrefix="/search_suggest_shortcut"
+                android:readPermission="android.permission.GLOBAL_SEARCH" />
+        </provider>
+        <provider
+            android:name=".datamodel.MessagingContentProvider"
+            android:authorities="com.android.messaging.datamodel.MessagingContentProvider"
+            android:exported="true"
+            android:label="@string/app_name" >
+        </provider>
+        <!-- bug 495194 : add for search feature end -->
+
+        <provider
+            android:name=".datamodel.MmsFileProvider"
+            android:authorities="com.android.messaging.datamodel.MmsFileProvider"
+            android:grantUriPermissions="true"
+            android:exported="false" />
+        <provider
+            android:name=".datamodel.MediaScratchFileProvider"
+            android:authorities="com.android.messaging.datamodel.MediaScratchFileProvider"
+            android:grantUriPermissions="true"
+            android:exported="true"
+            android:readPermission="com.android.messages.permission.READ_MESSAGES_ATTACHMENT"/>
+
+        <!-- Action Services -->
+        <service android:name=".datamodel.action.ActionServiceImpl" />
+        <service android:name=".datamodel.action.BackgroundWorkerService" />
+        <!-- bug 633234 : six queues begin -->
+        <!-- for Sms -->
+        <service android:name=".datamodel.action.BackgroundWorkerServiceSim1" />
+        <service android:name=".datamodel.action.BackgroundWorkerServiceSim2" />
+        <!-- for Mms -->
+        <service android:name=".datamodel.action.BackgroundWorkerServiceSim1Mms" />
+        <service android:name=".datamodel.action.BackgroundWorkerServiceSim2Mms" />
+        <!-- for history subid Mms -->
+	 <service android:name=".datamodel.action.BackgroundWorkerServiceHistorySubidMms" />
+        <!-- bug 633234 : six queues end -->
+        <!-- Sms and Mms related items -->
+
+
+        <!-- Intents for Notification and Pre-KLP Delivery -->
+        <!-- Registered with the highest possible priority (max_int) -->
+        <receiver
+            android:name=".receiver.MmsWapPushReceiver"
+            android:enabled="false"
+            android:permission="android.permission.BROADCAST_WAP_PUSH" >
+            <intent-filter android:priority="2147483647" >
+                <action android:name="android.provider.Telephony.WAP_PUSH_RECEIVED" />
+
+                <data android:mimeType="application/vnd.wap.mms-message" />
+            </intent-filter>
+        </receiver>
+        <receiver
+            android:name=".receiver.SmsReceiver"
+            android:enabled="false"
+            android:permission="android.permission.BROADCAST_SMS" >
+            <intent-filter android:priority="2147483647" >
+                <action android:name="android.provider.Telephony.SMS_RECEIVED" />
+            </intent-filter>
+            <intent-filter android:priority="2147483647" >
+                <action android:name="android.provider.Telephony.MMS_DOWNLOADED" />
+            </intent-filter>
+        </receiver>
+
+        <!-- Intents for aborting SMS/MMS broadcasts pre-KLP -->
+        <!-- Registered for a priority just ahead of inbox Messaging apps (2) -->
+        <receiver
+            android:name=".receiver.AbortMmsWapPushReceiver"
+            android:enabled="false"
+            android:permission="android.permission.BROADCAST_WAP_PUSH" >
+            <intent-filter android:priority="3" >
+                <action android:name="android.provider.Telephony.WAP_PUSH_RECEIVED" />
+
+                <data android:mimeType="application/vnd.wap.mms-message" />
+            </intent-filter>
+        </receiver>
+        <receiver
+            android:name=".receiver.AbortSmsReceiver"
+            android:enabled="false"
+            android:permission="android.permission.BROADCAST_SMS" >
+            <intent-filter android:priority="3" >
+                <action android:name="android.provider.Telephony.SMS_RECEIVED" />
+            </intent-filter>
+        </receiver>
+
+        <!-- Intents for KLP+ Delivery -->
+        <receiver
+            android:name=".receiver.MmsWapPushDeliverReceiver"
+            android:permission="android.permission.BROADCAST_WAP_PUSH" >
+            <intent-filter>
+                <action android:name="android.provider.Telephony.WAP_PUSH_DELIVER" />
+
+                <data android:mimeType="application/vnd.wap.mms-message" />
+            </intent-filter>
+        </receiver>
+        <receiver
+            android:name=".receiver.SmsDeliverReceiver"
+            android:permission="android.permission.BROADCAST_SMS" >
+            <intent-filter>
+                <action android:name="android.provider.Telephony.SMS_DELIVER" />
+            </intent-filter>
+        </receiver>
+
+        <receiver
+            android:name=".receiver.WapPushReceiver"
+            android:permission="android.permission.BROADCAST_SMS" >
+            <intent-filter>
+                <action android:name="android.provider.Telephony.WAP_PUSH_RECEIVED" />
+
+                <data android:mimeType="application/vnd.wap.sic" />
+                <data android:mimeType="application/vnd.wap.slc" />
+            </intent-filter>
+            <!-- @} -->
+        </receiver>
+
+        <receiver
+            android:name=".receiver.WapPushDeleteReceiver">
+            <intent-filter>
+                <action android:name="com.android.mms.transaction.wappush_expire_delete" />
+            </intent-filter>
+        </receiver>
+
+        <!-- 489220 begin -->
+        <receiver android:name=".receiver.MmsSmsEventReceiver">
+            <intent-filter>
+                <action android:name="com.sprd.notify_show_mms_sms_report_action" />
+            </intent-filter>
+        </receiver>
+        <!-- 489220 end -->
+
+        <receiver
+            android:name=".receiver.SendStatusReceiver"
+            android:exported="false" >
+            <intent-filter>
+                <action android:name="com.android.messaging.receiver.SendStatusReceiver.MESSAGE_SENT" />
+                <data android:scheme="content" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="com.android.messaging.receiver.SendStatusReceiver.MESSAGE_DELIVERED" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="com.android.messaging.receiver.SendStatusReceiver.MMS_SENT" />
+
+                <data android:scheme="content" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="com.android.messaging.receiver.SendStatusReceiver.MMS_DOWNLOADED" />
+
+                <data android:scheme="content" />
+            </intent-filter>
+        </receiver>
+
+        <service
+            android:name=".datamodel.NoConfirmationSmsSendService"
+            android:exported="true"
+            android:permission="android.permission.SEND_RESPOND_VIA_MESSAGE" >
+            <intent-filter>
+                <action android:name="android.intent.action.RESPOND_VIA_MESSAGE" />
+
+                <category android:name="android.intent.category.DEFAULT" />
+
+                <data android:scheme="sms" />
+                <data android:scheme="smsto" />
+            </intent-filter>
+        </service>
+        <!--
+          ClassZeroActivity remove android:launchMode="singleTask" for bug 525394 
+        -->
+        <activity
+            android:name=".ui.ClassZeroActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:excludeFromRecents="true"
+            android:label="@string/class_0_message_activity"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme.DialogActivity" >
+        </activity>
+        <activity
+            android:name=".ui.SmsStorageLowWarningActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:theme="@style/LowWarningvisible" />
+        <activity
+            android:name=".ui.appsettings.ApnSettingsActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:parentActivityName="com.android.messaging.ui.appsettings.SettingsActivity"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme" />
+        <activity
+            android:name=".ui.appsettings.ApnEditorActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:parentActivityName="com.android.messaging.ui.appsettings.ApnSettingsActivity"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme" />
+
+        <receiver android:name=".receiver.StorageStatusReceiver" >
+            <intent-filter>
+                <action android:name="android.intent.action.DEVICE_STORAGE_LOW" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="android.intent.action.DEVICE_STORAGE_OK" />
+            </intent-filter>
+        </receiver>
+        <!-- sprd #542214 start -->
+        <receiver android:name=".receiver.SimStatusReceiver" >
+            <intent-filter>
+                <action android:name="android.provider.Telephony.SIM_FULL" />
+                <action android:name="com.android.providers.telephony.SIM_MESSAGE_DELETE" />
+            </intent-filter>
+        </receiver>
+        <!-- sprd #542214 end -->
+        <receiver android:name=".receiver.BootAndPackageReplacedReceiver" >
+            <intent-filter>
+                <action android:name="android.intent.action.BOOT_COMPLETED" />
+                <action android:name="android.intent.action.MY_PACKAGE_REPLACED" />
+                <action android:name="android.intent.action.internal_sim_state_changed" />
+            </intent-filter>
+        </receiver>
+
+        <!-- Broadcast receiver that will be notified to reset notifications -->
+        <receiver
+            android:name=".receiver.NotificationReceiver"
+            android:exported="false" >
+        </receiver>
+        
+        <!-- @} -->
+        <!-- SPRD: Add for wap push. @{ -->
+        <activity
+            android:name="com.android.messaging.wappush.WapPushMessageShowActivity"
+            android:configChanges="orientation"
+            android:theme="@style/FullyTranslucent" >
+            <intent-filter>
+                <action android:name="android.intent.action.ShowWapPush" />
+            </intent-filter>
+        </activity>
+        <!-- @} -->
+
+        <!-- Broadcast receiver that will be notified for ActionService alarms. -->
+        <receiver
+            android:name=".datamodel.action.ActionServiceImpl$PendingActionReceiver"
+            android:exported="false" >
+            <intent-filter>
+                <action android:name="com.android.messaging.datamodel.PENDING_ACTION" />
+            </intent-filter>
+        </receiver>
+        <receiver android:name=".receiver.DefaultSmsSubscriptionChangeReceiver" >
+            <intent-filter>
+                <action android:name="android.intent.action.ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED" />
+            </intent-filter>
+        </receiver>
+
+        <!-- Widget that displays the conversation list -->
+        <receiver
+            android:name=".widget.BugleWidgetProvider"
+            android:label="@string/widget_conversation_name" >
+            <intent-filter>
+                <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="com.android.Bugle.intent.action.ACTION_NOTIFY_CONVERSATIONS_CHANGED" />
+            </intent-filter>
+
+            <meta-data
+                android:name="android.appwidget.provider"
+                android:resource="@xml/widget_conversation_list" />
+        </receiver>
+
+        <!-- Widget that displays the messages of a single conversation -->
+        <receiver
+            android:name=".widget.WidgetConversationProvider"
+            android:label="@string/widget_conversation_name" >
+            <intent-filter>
+                <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="com.android.Bugle.intent.action.ACTION_NOTIFY_MESSAGES_CHANGED" />
+            </intent-filter>
+
+            <meta-data
+                android:name="android.appwidget.provider"
+                android:resource="@xml/widget_conversation" />
+        </receiver>
+
+        <service
+            android:name=".widget.WidgetConversationListService"
+            android:exported="false"
+            android:permission="android.permission.BIND_REMOTEVIEWS" />
+        <service
+            android:name=".widget.WidgetConversationService"
+            android:exported="false"
+            android:permission="android.permission.BIND_REMOTEVIEWS" />
+
+        <activity
+            android:name=".ui.WidgetPickConversationActivity"
+            android:label="@string/app_name"
+            android:theme="@style/BugleTheme" >
+            <intent-filter>
+                <action android:name="android.appwidget.action.APPWIDGET_CONFIGURE" />
+            </intent-filter>
+        </activity>
+
+        <service android:name="android.support.v7.mms.MmsService" />
+
+        <!-- add for common phrase-->
+        <activity
+            android:name="com.sprd.messaging.sms.commonphrase.ui.PharserActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:label="@string/preference_name"
+            android:screenOrientation="user"
+            android:theme="@style/BugleTheme" >
+        </activity>
+        <activity
+            android:name="com.sprd.messaging.sms.commonphrase.ui.ShowPharseActivity"
+            android:label="@string/select_commmon_phrase"
+            android:theme="@style/BugleTheme.DialogActivity" >
+        </activity>
+
+        <provider
+            android:name="com.sprd.messaging.sms.commonphrase.provider.PhaserProvider"
+            android:authorities="com.android.messaging.commonphrase"
+            android:exported="true" >
+        </provider>
+        <!-- bug 478514: Add for MmsFolderView Feature Begin -->
+        <activity
+            android:name="com.sprd.messaging.ui.folderview.MessageDetailsActivity"
+            android:configChanges="orientation|screenSize|keyboardHidden"
+            android:screenOrientation="user"
+            android:theme="@style/CustomTheme.MessageDetailsActivity"
+            android:windowSoftInputMode="stateAlwaysHidden" >
+        </activity>
+        <activity
+            android:name="com.sprd.messaging.ui.folderview.CopyTextAcitvityDialog"
+            android:configChanges="orientation|keyboardHidden|screenSize"
+            android:excludeFromRecents="true"
+            android:label="@string/copy_message_text"
+            android:theme="@android:style/Theme.Material.Light.Dialog"
+            android:windowSoftInputMode="stateHidden|adjustResize" >
+        </activity>
+
+        <service
+            android:name="com.sprd.messaging.ui.folderview.FolderViewMessagingCommService"
+            android:exported="true" >
+            <intent-filter>
+                <action android:name="com.android.action.FOLDER_VIEW_MESSAGING_COMM" />
+
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </service>
+        <!-- bug 478514: Add for MmsFolderView Feature End -->
+ 
+        <!-- add for smsc -->
+        <activity
+            android:name="com.sprd.messaging.ui.smsc.SmscListActivity"
+            android:label="@string/smsc_list"
+            android:parentActivityName="com.android.messaging.ui.appsettings.PerSubscriptionSettingsActivity"
+            android:theme="@style/BugleTheme" >
+        </activity>
+
+        <activity
+             android:name="com.sprd.messaging.ui.smsc.ShowSmscEditDialogActivity"
+             android:configChanges="orientation|screenSize|keyboardHidden"
+             android:theme="@style/Theme.AppCompat.Light.Dialog" >
+        </activity>
+
+        <!-- Sprd add for sms merge forward begin -->
+        <activity android:name="com.sprd.messaging.ui.smsmergeforward.SmsMergeForwardActivity"
+	         android:theme="@style/MmsHoloThemeNewui"
+	         android:configChanges="orientation|screenSize|keyboardHidden"
+	         android:parentActivityName="com.android.messaging.ui.conversation.ConversationActivity"
+	         android:label="@string/sms_merge_forward" >
+             <intent-filter>
+                <action android:name="com.sprd.messaging.ui.smsmergeforward.SmsMergeForwardActivity" />
+             </intent-filter>
+        </activity>
+        <!-- Sprd add for sms merge forward end -->
+
+    </application>
+
+</manifest>
Index: vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/ui/conversation/ConversationFragment.java
===================================================================
--- vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/ui/conversation/ConversationFragment.java	(revision 0)
+++ vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/ui/conversation/ConversationFragment.java	(revision 173004)
@@ -0,0 +1,2858 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.messaging.ui.conversation;
+
+import android.Manifest;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.DownloadManager;
+import android.app.Fragment;
+import android.app.FragmentManager;
+import android.app.FragmentTransaction;
+import android.app.ProgressDialog;
+import android.content.BroadcastReceiver;
+import android.content.ClipData;
+import android.content.ClipboardManager;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnCancelListener;
+import android.content.DialogInterface.OnClickListener;
+import android.content.DialogInterface.OnDismissListener;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Configuration;
+import android.database.Cursor;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.graphics.drawable.ColorDrawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.EnvironmentEx;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.Message;
+import android.os.Parcelable;
+import android.os.StatFs;
+import android.support.v4.content.LocalBroadcastManager;
+import android.support.v4.text.BidiFormatter;
+import android.support.v4.text.TextDirectionHeuristicsCompat;
+import android.support.v7.app.ActionBar;
+import android.support.v7.widget.DefaultItemAnimator;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.RecyclerView.ViewHolder;
+import android.telephony.SubscriptionInfo;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.ActionMode;
+import android.view.Display;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.TextView;
+
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.messaging.Factory;
+import com.android.messaging.R;
+import com.android.messaging.datamodel.DataModel;
+import com.android.messaging.datamodel.MediaScratchFileProvider;
+import com.android.messaging.datamodel.MessagingContentProvider;
+import com.android.messaging.datamodel.action.InsertNewMessageAction;
+import com.android.messaging.datamodel.binding.Binding;
+import com.android.messaging.datamodel.binding.BindingBase;
+import com.android.messaging.datamodel.binding.ImmutableBindingRef;
+import com.android.messaging.datamodel.data.ConversationData;
+import com.android.messaging.datamodel.data.ConversationData.ConversationDataListener;
+import com.android.messaging.datamodel.data.ConversationMessageData;
+import com.android.messaging.datamodel.data.ConversationParticipantsData;
+import com.android.messaging.datamodel.data.DraftMessageData;
+import com.android.messaging.datamodel.data.DraftMessageData.DraftMessageDataListener;
+import com.android.messaging.datamodel.data.MessageData;
+import com.android.messaging.datamodel.data.MessagePartData;
+import com.android.messaging.datamodel.data.ParticipantData;
+import com.android.messaging.datamodel.data.SubscriptionListData.SubscriptionListEntry;
+import com.android.messaging.smil.data.SmilDraftDataManager;
+// Add for bug 563344
+import com.android.messaging.smil.ui.SmilMainActivity;
+import com.android.messaging.sms.MmsConfig;
+import com.android.messaging.sms.MmsUtils;
+import com.android.messaging.ui.AttachmentPreview;
+import com.android.messaging.ui.BugleActionBarActivity;
+import com.android.messaging.ui.ConversationDrawables;
+import com.android.messaging.ui.SnackBar;
+import com.android.messaging.ui.UIIntents;
+import com.android.messaging.ui.animation.PopupTransitionAnimation;
+import com.android.messaging.ui.contact.AddContactsConfirmationDialog;
+import com.android.messaging.ui.conversation.ComposeMessageView;
+import com.android.messaging.ui.conversation.ComposeMessageView.IComposeMessageViewHost;
+import com.android.messaging.ui.conversation.ConversationInputManager.ConversationInputHost;
+import com.android.messaging.ui.conversation.ConversationMessageView.ConversationMessageViewHost;
+import com.android.messaging.ui.conversationlist.ShareIntentActivity;
+import com.android.messaging.ui.mediapicker.MediaPicker;
+import com.android.messaging.util.AccessibilityUtil;
+import com.android.messaging.util.Assert;
+import com.android.messaging.util.AvatarUriUtil;
+import com.android.messaging.util.ChangeDefaultSmsAppHelper;
+import com.android.messaging.util.ContentType;
+import com.android.messaging.util.ImeUtil;
+import com.android.messaging.util.LogUtil;
+import com.android.messaging.util.OsUtil;
+import com.android.messaging.util.PhoneUtils;
+import com.android.messaging.util.SafeAsyncTask;
+import com.android.messaging.util.TextUtil;
+import com.android.messaging.util.UiUtils;
+import com.android.messaging.util.UriUtil;
+import com.google.common.annotations.VisibleForTesting;
+//import com.android.messaging.ui.smsmergeforward.SmsMergeForwardActivity;
+import com.android.messaging.ui.VdataUtils;
+import com.sprd.messaging.sms.commonphrase.ui.ShowPharseActivity;
+import com.sprd.messaging.drm.MessagingDrmSession;
+//import com.sprd.messaging.sms.commonphrase.ui.ShowPharseActivity;
+import com.sprd.messaging.ui.folderview.FolderViewMessagingCommService;
+import com.sprd.messaging.ui.smsmergeforward.SmsMergeForwardActivity;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.lang.ref.WeakReference;
+import java.util.Iterator;
+import java.util.List;
+
+import android.util.Log;
+import android.widget.Toast;
+import android.content.DialogInterface;
+import android.app.AlertDialog;
+
+import com.android.messaging.R;
+import com.sprd.messaging.drm.MessagingDrmSession;
+// bug 478514: Add for MmsFolderView Feature -- Begin
+import com.android.messaging.ui.conversationlist.ConversationListActivity;
+import com.android.messaging.util.BuglePrefs;
+import com.android.messaging.util.BuglePrefsKeys;
+
+
+// bug 478514: Add for MmsFolderView Feature -- End
+import android.text.TextUtils;
+
+import com.android.messaging.util.GlobleUtil;
+/*Add by SPRD for bug581044  2016.07.08 Start*/
+import com.android.messaging.datamodel.BugleDatabaseOperations;
+import com.android.messaging.datamodel.action.DeleteConversationAction;
+import com.sprd.messaging.util.SystemAdapter;
+/*Add by SPRD for bug581044  2016.07.08 End*/
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import cn.cmcc.online.smsapi.MenuClickHelper;
+import cn.cmcc.online.smsapi.SmsPortFetcher;
+import cn.cmcc.online.smsapi.Terminal;
+
+import android.graphics.Color;
+import android.os.Looper;
+import android.widget.PopupWindow;
+import android.view.Gravity;
+import android.widget.LinearLayout;
+import android.widget.PopupWindow;
+import android.app.ProgressDialog;
+import android.os.AsyncTask;
+import android.provider.Telephony.Sms;
+import android.content.ContentResolver;
+
+import android.support.v4.util.LruCache;
+import cn.cmcc.online.smsapi.SmsPortFetcher;
+import cn.cmcc.online.smsapi.Terminal;
+import android.view.View;
+import android.widget.LinearLayout;
+import android.content.Intent;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+import android.net.Uri;
+import com.android.messaging.datamodel.data.ConversationMessageData;
+import java.util.HashMap;
+import android.widget.ImageView;
+import android.support.v7.widget.LinearLayoutManager;
+import com.android.messaging.sms.MmsConfig;
+import com.android.messaging.BugleApplication;
+import com.android.messaging.Factory;
+import android.graphics.drawable.Drawable;
+import android.view.inputmethod.InputMethodManager;
+
+/**
+ * Shows a list of messages/parts comprising a conversation.
+ */
+public class ConversationFragment extends Fragment implements ConversationDataListener,
+        IComposeMessageViewHost, ConversationMessageViewHost, ConversationInputHost,
+        DraftMessageDataListener {
+
+    private LinearLayout mServerMenu;    /* add for SmartMessage ServerMenu */
+    private String mPort;    /* add for SmartMessage  Port*/
+
+    public interface ConversationFragmentHost extends ImeUtil.ImeStateHost {
+        void onStartComposeMessage();
+
+        void onConversationMetadataUpdated();
+
+        boolean shouldResumeComposeMessage();
+
+        void onFinishCurrentConversation();
+
+        void invalidateActionBar();
+
+        ActionMode startActionMode(ActionMode.Callback callback);
+
+        void dismissActionMode();
+
+        ActionMode getActionMode();
+
+        void onConversationMessagesUpdated(int numberOfMessages);
+
+        void onConversationParticipantDataLoaded(int numberOfParticipants);
+
+        boolean isActiveAndFocused();
+
+        /*Add by SPRD for bug581044  2016.07.08 Start*/
+        void setKeepingMessageData(MessageData data);
+
+        String getOldConversationId();
+        /*Add by SPRD for bug581044  2016.07.08 End*/
+    }
+
+    private Context mContext;
+    public static final String FRAGMENT_TAG = "conversation";
+
+    public static final String TAG = "ConversationFragment";
+    public static final String SMART_TAG = "ConversationFragmentSmartMessage";    /* add for SmartMessage start*/
+
+    static final int REQUEST_CHOOSE_ATTACHMENTS = 2;
+    static final int REQUEST_INSERT_PHRASE = 3;//sprd add for common message
+    private static final int JUMP_SCROLL_THRESHOLD = 15;
+    // We animate the message from draft to message list, if we the message doesn't show up in the
+    // list within this time limit, then we just do a fade in animation instead
+    public static final int MESSAGE_ANIMATION_MAX_WAIT = 500;
+
+    private ComposeMessageView mComposeMessageView;
+    private RecyclerView mRecyclerView;
+    private ConversationMessageAdapter mAdapter;
+    private ConversationFastScroller mFastScroller;
+
+    private View mConversationComposeDivider;
+    private ChangeDefaultSmsAppHelper mChangeDefaultSmsAppHelper;
+
+    private String mConversationId;
+    /*Add by SPRD for bug581044  2016.07.08 Start*/
+    private boolean isEmptyRecipientConversaton = false;
+    /*Add by SPRD for bug581044  2016.07.08 End*/
+    // If the fragment receives a draft as part of the invocation this is set
+    private MessageData mIncomingDraft;
+
+    // This binding keeps track of our associated ConversationData instance
+    // A binding should have the lifetime of the owning component,
+    //  don't recreate, unbind and bind if you need new data
+    @VisibleForTesting
+    final Binding<ConversationData> mBinding = BindingBase.createBinding(this);
+
+    // Saved Instance State Data - only for temporal data which is nice to maintain but not
+    // critical for correctness.
+    private static final String SAVED_INSTANCE_STATE_LIST_VIEW_STATE_KEY = "conversationViewState";
+    private Parcelable mListState;
+    private static final String CLEAR_LOCAL_DRAFT_STATE = "clear_local_draft_state";
+
+    private ConversationFragmentHost mHost;
+
+    protected List<Integer> mFilterResults;
+
+    // The minimum scrolling distance between RecyclerView's scroll change event beyong which
+    // a fling motion is considered fast, in which case we'll delay load image attachments for
+    // perf optimization.
+    private int mFastFlingThreshold;
+
+    // ConversationMessageView that is currently selected
+    private ConversationMessageView mSelectedMessage;
+
+    // Attachment data for the attachment within the selected message that was long pressed
+    private MessagePartData mSelectedAttachment;
+
+    AlertDialog mSimSelectDialog;
+
+    private LoadsmartSmsTask mLoadsmartSmsTask;
+
+    // Normally, as soon as draft message is loaded, we trust the UI state held in
+    // ComposeMessageView to be the only source of truth (incl. the conversation self id). However,
+    // there can be external events that forces the UI state to change, such as SIM state changes
+    // or SIM auto-switching on receiving a message. This receiver is used to receive such
+    // local broadcast messages and reflect the change in the UI.
+    private final BroadcastReceiver mConversationSelfIdChangeReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(final Context context, final Intent intent) {
+            final String conversationId =
+                    intent.getStringExtra(UIIntents.UI_INTENT_EXTRA_CONVERSATION_ID);
+            final String selfId =
+                    intent.getStringExtra(UIIntents.UI_INTENT_EXTRA_CONVERSATION_SELF_ID);
+            Assert.notNull(conversationId);
+            Assert.notNull(selfId);
+            // spread: fixed for bug  522393 start
+            if (mBinding.isBound()) {
+                if (TextUtils.equals(mBinding.getData().getConversationId(), conversationId) && !MmsConfig.get(1).getUsingSimInSettingsEnabled()) {
+                    mComposeMessageView.updateConversationSelfIdOnExternalChange(selfId);
+                }
+            }
+            // spread: fixed for bug  522393 end
+        }
+    };
+
+    // Flag to prevent writing draft to DB on pause
+    private boolean mSuppressWriteDraft;
+    /* Add by SPRD for bug 583553 2016.07.27 Start */
+    private boolean mLoadDraftDone = false;
+    private boolean mOnAttachmentChosen = false;
+    private int mOldAttachmentCount = 0;
+    /* Add by SPRD for bug 583553 2016.07.27 End */
+
+    // Indicates whether local draft should be cleared due to external draft changes that must
+    // be reloaded from db
+    private boolean mClearLocalDraft;
+    private ImmutableBindingRef<DraftMessageData> mDraftMessageDataModel;
+
+    // flag for mediaPicker paused when
+    private boolean mPauseRusume = false;
+    //sprd fix bug 562320 start
+    private SmileMessageHandle mSmilDraftListen;
+
+    private static class SmileMessageHandle extends Handler {
+        private WeakReference<ConversationFragment> wref;
+
+        public SmileMessageHandle(ConversationFragment act) {
+            wref = new WeakReference<ConversationFragment>(act);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            ConversationFragment frag = wref.get();
+            Log.d(TAG, "smil handle message "+msg);
+            if (frag == null) {
+                return;
+            }
+            switch (msg.what) {
+                case GlobleUtil.SMIL_DRAFT_MSG:
+                    if (GlobleUtil.getEditedDraftMessageDate() == null) {
+                        Log.d(TAG, "smilhandler[ smil attachment is : " + GlobleUtil.isSmilAttament + "  mClearLocalDraft: " + frag.mClearLocalDraft+"]");
+                        //mComposeMessageView.setDraftMessage(null);
+                        // ConversationMessageData messageData = mSelectedMessage.getData();
+                        frag.mComposeMessageView.requestDraftMessage(true);
+                    }
+                    break;
+            }
+        }
+    }
+    //sprd fix bug 562320 end
+
+    private boolean isScrolledToBottom() {
+        if (mRecyclerView.getChildCount() == 0) {
+            return true;
+        }
+        final View lastView = mRecyclerView.getChildAt(mRecyclerView.getChildCount() - 1);
+        int lastVisibleItem = ((LinearLayoutManager) mRecyclerView
+                .getLayoutManager()).findLastVisibleItemPosition();
+        if (lastVisibleItem < 0) {
+            // If the recyclerView height is 0, then the last visible item position is -1
+            // Try to compute the position of the last item, even though it's not visible
+            final long id = mRecyclerView.getChildItemId(lastView);
+            final RecyclerView.ViewHolder holder = mRecyclerView.findViewHolderForItemId(id);
+            if (holder != null) {
+                lastVisibleItem = holder.getAdapterPosition();
+            }
+        }
+        final int totalItemCount = mRecyclerView.getAdapter().getItemCount();
+        final boolean isAtBottom = (lastVisibleItem + 1 == totalItemCount);
+        return isAtBottom && lastView.getBottom() <= mRecyclerView.getHeight();
+    }
+
+            /* SPRD: Add this method for multi-sim setting. @{ */
+
+
+
+private class LoadsmartSmsTask extends AsyncTask<Void, Void, Void> {
+            private Context mContext;
+
+            private ProgressDialog processDia;
+
+            public LoadsmartSmsTask(Context context) {
+                mContext=context;
+            }
+
+            public void showLoadingDialog() {
+                        try {
+                            if (processDia == null) {
+                                processDia = new ProgressDialog(mContext);
+                                processDia.setCanceledOnTouchOutside(false);
+                                processDia.setCancelable(false);
+                                processDia.setIndeterminate(true);
+                              processDia.setMessage(getString(R.string.folder_loading));
+
+                                processDia.show();
+
+                            } else if (!processDia.isShowing()) {
+                                processDia.show();
+
+                            }
+                        } catch (Exception ex) {
+                            Log.d(TAG, " showLoadingDialog ", ex.fillInStackTrace());
+                        }
+            }
+            @Override
+           protected void onPreExecute() {
+               boolean showDlaog = true;
+                if (mContext instanceof Activity) {
+                    Activity a = (Activity) mContext;
+                    if (a.isFinishing() || a.isDestroyed()) {
+                        showDlaog = false;
+                    }
+                }
+                if (showDlaog) {
+                   showLoadingDialog();
+                }
+            }
+            @Override
+    protected Void doInBackground(Void... params) {
+        String mthreadId = mBinding.getData().getConversationId();
+        ContentResolver resolver = mContext.getContentResolver();
+        Cursor c = resolver.query(Sms.CONTENT_URI, new String[]{"_id","body"}, ("thread_id=" +mthreadId+" and type=1"), null, null);
+        try{
+            if(c!=null){
+                while(c.moveToNext())
+                    {
+
+                        String mMessageId=c.getString(0);
+                        String mPhonePort=mBinding.getData().getParticipantPhoneNumber();
+
+                        String mBody=c.getString(1);
+                        String mServerPort=mBinding.getData().getParticipantPhoneNumber();
+                       if(  ((BugleApplication) mContext.getApplicationContext()).mWebViewCache.get(mMessageId)==null)
+                        {
+                     LoadCardView(mMessageId,mPhonePort,mBody,mServerPort);
+                        }
+                    }
+                }
+
+            } catch(IllegalArgumentException e) {
+            e.printStackTrace();
+            } finally {
+                        if(c != null){
+                            c.close();
+                        }
+            }
+
+                return null;
+            }
+
+            @Override
+            protected void onPostExecute(Void result) {
+            Log.w("hzh","onPostExecute");
+             //   if (result!=null) {
+                 closeLoadingDialog();
+         //       }
+
+            }
+
+    public void closeLoadingDialog() {
+        try {
+            if (processDia != null) {
+                if (processDia.isShowing()) {
+                    processDia.cancel();
+                }
+                processDia = null;
+
+            }
+        } catch (Exception ex) {
+            Log.d(TAG, " closeLoadingDialog ", ex.fillInStackTrace());
+        }
+    }
+
+ private   void LoadCardView(String mMessagingId,String mPhonePort,String mbody,String mserver) {
+            try {
+                Terminal.getCardView(mContext, mPhonePort, mbody, mserver,Integer.parseInt(mMessagingId),new Terminal.TerminalCallBack() {
+                    @Override
+                    public void loadUrl(Context context, String url) {
+                        Uri uri = Uri.parse(url);
+                        Intent intent = new Intent(Intent.ACTION_VIEW, uri);
+                        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                        context.startActivity(intent);
+                    }
+
+                    @Override
+                    public void loadCard(WebView card, boolean isSpam) {
+
+                        if (card != null) {
+                            card.setWebViewClient(new WebViewClient() {
+                                @Override
+                                public boolean shouldOverrideUrlLoading(WebView view, String url) {
+
+                                    Uri uri = Uri.parse(url);
+                                    Intent intent = new Intent(Intent.ACTION_VIEW, uri);
+                                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                                    view.getContext().startActivity(intent);
+                                    return true;
+                                }
+                            });
+                           Log.d("hzh","PUT--WEBVIEW--"+mMessagingId+"----card-----"+card);
+
+                        ((BugleApplication) mContext.getApplicationContext()).mWebViewCache.put(mMessagingId,card);
+
+                        }
+
+                    }
+                });
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+
+}
+
+    private void scrollToBottom(final boolean smoothScroll) {
+        if (mAdapter.getItemCount() > 0) {
+            scrollToPosition(mAdapter.getItemCount() - 1, smoothScroll);
+        }
+    }
+
+    private int mScrollToDismissThreshold;
+    private final RecyclerView.OnScrollListener mListScrollListener =
+            new RecyclerView.OnScrollListener() {
+                // Keeps track of cumulative scroll delta during a scroll event, which we may use to
+                // hide the media picker & co.
+                private int mCumulativeScrollDelta;
+                private boolean mScrollToDismissHandled;
+                private boolean mWasScrolledToBottom = true;
+                private int mScrollState = RecyclerView.SCROLL_STATE_IDLE;
+
+                @Override
+                public void onScrollStateChanged(final RecyclerView view, final int newState) {
+                    if (newState == RecyclerView.SCROLL_STATE_IDLE) {
+                        // Reset scroll states.
+                        mCumulativeScrollDelta = 0;
+                        mScrollToDismissHandled = false;
+                    } else if (newState == RecyclerView.SCROLL_STATE_DRAGGING) {
+                        mRecyclerView.getItemAnimator().endAnimations();
+                    }
+                    mScrollState = newState;
+
+           //         Log.i("hzh","mScrollState"+mScrollState);
+            if(RecyclerView.SCROLL_STATE_IDLE==mScrollState){
+           final LinearLayoutManager layoutManager =
+                    (LinearLayoutManager) mRecyclerView.getLayoutManager();
+            final int firstVisibleItemPosition =
+                    layoutManager.findFirstVisibleItemPosition();
+            final int lastVisibleItemPosition =
+                   layoutManager.findLastVisibleItemPosition();
+                          mAdapter.setScollState(newState,firstVisibleItemPosition,lastVisibleItemPosition);
+                }
+
+                }
+
+                @Override
+                public void onScrolled(final RecyclerView view, final int dx, final int dy) {
+                    if (mScrollState == RecyclerView.SCROLL_STATE_DRAGGING &&
+                            !mScrollToDismissHandled) {
+                        mCumulativeScrollDelta += dy;
+                        // Dismiss the keyboard only when the user scroll up (into the past).
+                        if (mCumulativeScrollDelta < -mScrollToDismissThreshold) {
+                            mComposeMessageView.hideAllComposeInputs(false /* animate */);
+                            mScrollToDismissHandled = true;
+                        }
+                    }
+                    if (mWasScrolledToBottom != isScrolledToBottom()) {
+                        mConversationComposeDivider.animate().alpha(isScrolledToBottom() ? 0 : 1);
+                        mWasScrolledToBottom = isScrolledToBottom();
+                    }
+                }
+            };
+
+    private final ActionMode.Callback mMessageActionModeCallback = new ActionMode.Callback() {
+        @Override
+        public boolean onCreateActionMode(final ActionMode actionMode, final Menu menu) {
+            if (mSelectedMessage == null) {
+                return false;
+            }
+            final ConversationMessageData data = mSelectedMessage.getData();
+            final MenuInflater menuInflater = getActivity().getMenuInflater();
+            menuInflater.inflate(R.menu.conversation_fragment_select_menu, menu);
+            menu.findItem(R.id.action_download).setVisible(data.getShowDownloadMessage());
+            menu.findItem(R.id.action_send).setVisible(data.getShowResendMessage());
+
+            // ShareActionProvider does not work with ActionMode. So we use a normal menu item.
+            menu.findItem(R.id.share_message_menu).setVisible(data.getCanForwardMessage());
+            Log.d(TAG, "lxg mSelectedAttachment != null:" + (mSelectedAttachment != null));
+            menu.findItem(R.id.save_attachment).setVisible(mSelectedAttachment != null);
+            menu.findItem(R.id.forward_message_menu).setVisible(data.getCanForwardMessage());
+
+            // TODO: We may want to support copying attachments in the future, but it's
+            // unclear which attachment to pick when we make this context menu at the message level
+            // instead of the part level
+            menu.findItem(R.id.copy_text).setVisible(data.getCanCopyMessageToClipboard());
+            //add for bug 566254 begin
+            System.out.println("data.getStatus=[" + data.getStatus() + "], data.getCanPreviewSmilData() = [" + data.getCanPreviewSmilData() + "]");
+            if (data.getCanPreviewSmilData() && (data.getAttachments().size() > 0)) {
+                menu.findItem(R.id.action_smil_player).setVisible(true);
+            } else {
+                menu.findItem(R.id.action_smil_player).setVisible(false);
+            }
+            /*607986 {@*/
+            final List<SubscriptionInfo> InfoList = SystemAdapter.getInstance().getActiveSubInfoList();
+            int subId = 0;
+            if (InfoList != null && InfoList.size() != 0)
+                subId = InfoList.get(0).getSubscriptionId();
+            //if find active sim(s), message type is sms and it's body lenght > 0, show action_copy_to_sim icon for copy sms to sim card
+            if ((InfoList != null && InfoList.size() != 0) && (!MmsUtils.isAirplaneModeOn(subId)) && data.getIsSms()
+                    && ((MmsConfig.get(subId).getFinalSendEmptyMessageFlag() > 0) || (MmsConfig.get(subId).getFinalSendEmptyMessageFlag() == 0 && data.getText() != null && data.getText().length() > 0))) {
+                menu.findItem(R.id.action_copy_to_sim).setVisible(true);
+            } else {
+                menu.findItem(R.id.action_copy_to_sim).setVisible(false);
+            }
+            /*@}*/
+            //add for bug 566254 end
+            return true;
+        }
+
+        @Override
+        public boolean onPrepareActionMode(final ActionMode actionMode, final Menu menu) {
+            return true;
+        }
+
+        @Override
+        public boolean onActionItemClicked(final ActionMode actionMode, final MenuItem menuItem) {
+            final ConversationMessageData data = mSelectedMessage.getData();
+            final String messageId = data.getMessageId();
+            switch (menuItem.getItemId()) {
+                case R.id.save_attachment:
+                    if (OsUtil.hasStoragePermission()) {
+                        final SaveAttachmentTask saveAttachmentTask = new SaveAttachmentTask(
+                                getActivity());
+                        for (final MessagePartData part : data.getAttachments()) {
+                            // FIXME: drm files cannot be saved? delete it, if possible.
+                            /*Modify by SPRD for Bug:574142 Start*/
+                            if (part.isDrmType() || ContentType.isDrmType(part.getContentType())) {
+                                UiUtils.showToastAtBottom(R.string.drm_can_not_processed);
+                            } else {
+                                saveAttachmentTask.addAttachmentToSave(part.getContentUri(),
+                                        part.getContentType());
+                            }
+                            /*Modify by SPRD for Bug:574142 End*/
+                        }
+                        if (saveAttachmentTask.getAttachmentCount() > 0) {
+                            saveAttachmentTask.executeOnThreadPool();
+                            mHost.dismissActionMode();
+                        }
+                    } else {
+                        getActivity().requestPermissions(
+                                new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 0);
+                    }
+                    return true;
+                case R.id.action_delete_message:
+                    if (mSelectedMessage != null) {
+                        deleteMessage(messageId);
+                    }
+                    return true;
+                case R.id.action_download:
+                    if (mSelectedMessage != null) {
+                        retryDownload(messageId);
+                        mHost.dismissActionMode();
+                    }
+                    return true;
+                case R.id.action_send:
+                    if (mSelectedMessage != null) {
+                        retrySend(messageId);
+                        mHost.dismissActionMode();
+                    }
+                    return true;
+                case R.id.copy_text:
+                    Assert.isTrue(data.hasText());
+                    final ClipboardManager clipboard = (ClipboardManager) getActivity()
+                            .getSystemService(Context.CLIPBOARD_SERVICE);
+                    clipboard.setPrimaryClip(
+                            ClipData.newPlainText(null /* label */, data.getText()));
+                    mHost.dismissActionMode();
+                    return true;
+                case R.id.details_menu:
+                    MessageDetailsDialog.show(
+                            getActivity(), data, mBinding.getData().getParticipants(),
+                            mBinding.getData().getSelfParticipantById(data.getSelfParticipantId()));
+                    mHost.dismissActionMode();
+                    return true;
+                case R.id.share_message_menu:
+                    shareMessage(data);
+                    mHost.dismissActionMode();
+                    return true;
+                case R.id.forward_message_menu:
+                    // TODO: Currently we are forwarding one part at a time, instead of
+                    // the entire message. Change this to forwarding the entire message when we
+                    // use message-based cursor in conversation.
+                    final MessageData message = mBinding.getData().createForwardedMessage(data);
+                    UIIntents.get().launchForwardMessageActivity(getActivity(), message);
+                    mHost.dismissActionMode();
+                    return true; //yao_y.chen smil
+                case R.id.action_smil_player:
+                    final ConversationMessageData messageData = mSelectedMessage.getData();
+                    if (GlobleUtil.isPkgInstalled(getActivity(), GlobleUtil.SMILPLAYER_PACKAGE_NAME)) {
+                        if (messageData.isCanSildeshow()) {
+                            showSmilChoiceDlalog(messageData);
+                        } else {
+                            launchSmilMainActivity(messageData);
+                        }
+                    } else {
+                        launchSmilMainActivity(messageData);
+                    }
+                    mHost.dismissActionMode();
+                    return true;
+                //yao_y.chen smil
+                case R.id.action_copy_to_sim:
+                    List<String> smsUriList = new ArrayList<>();
+                    String smsUri = data.getSmsMessageUri();
+                    smsUriList.add(smsUri);
+                    createSimSelectDialog(smsUriList);
+                    mHost.dismissActionMode();
+                    return true;
+            }
+            return false;
+        }
+
+        private void launchSmilMainActivity(final ConversationMessageData data) {
+            GlobleUtil.setConvMessageData(data);
+            String convName = getConversationName();
+            UIIntents.get().launchSmilMainActivity(getActivity(), false, convName);
+
+        }
+
+        private void showSmilChoiceDlalog(final ConversationMessageData data) {
+            final String[] items = getActivity().getResources().getStringArray(R.array.smil_choice_items);
+            new AlertDialog.Builder(getActivity()).setItems(items, new DialogInterface.OnClickListener() {
+                @Override
+                public void onClick(DialogInterface dialog, int which) {
+                    switch (which) {
+                        case 0:
+                            launchSmilMainActivity(data);
+                            mHost.dismissActionMode();
+                            break;
+
+                        case 1:
+                            playSlideshowMessage(data);
+                            mHost.dismissActionMode();
+                            break;
+                    }
+                }
+            }).show();
+        }
+
+        private void playSlideshowMessage(final ConversationMessageData data) {
+            String mmsUri = data.getSmsMessageUri();
+            Uri uri = Uri.parse(mmsUri);
+            UIIntents.get().launchSlideshowActivity(mContext, uri, 0);
+        }
+
+        private void shareMessage(final ConversationMessageData data) {
+            // Figure out what to share.
+            MessagePartData attachmentToShare = mSelectedAttachment;
+            // If the user long-pressed on the background, we will share the text (if any)
+            // or the first attachment.
+            if (mSelectedAttachment == null
+                    && TextUtil.isAllWhitespace(data.getText())) {
+                final List<MessagePartData> attachments = data.getAttachments();
+                if (attachments.size() > 0) {
+                    attachmentToShare = attachments.get(0);
+                }
+            }
+
+            final Intent shareIntent = new Intent();
+            shareIntent.setAction(Intent.ACTION_SEND);
+            if (attachmentToShare == null) {
+                shareIntent.putExtra(Intent.EXTRA_TEXT, data.getText());
+                shareIntent.setType("text/plain");
+            } else {
+                shareIntent.putExtra(
+                        Intent.EXTRA_STREAM, attachmentToShare.getContentUri());
+                shareIntent.setType(attachmentToShare.getContentType());
+            }
+            final CharSequence title = getResources().getText(R.string.action_share);
+            startActivity(Intent.createChooser(shareIntent, title));
+        }
+
+        @Override
+        public void onDestroyActionMode(final ActionMode actionMode) {
+            selectMessage(null);
+        }
+    };
+
+    /**
+     * {@inheritDoc} from Fragment
+     */
+    @Override
+    public void onCreate(final Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        Log.d(TAG, "onCreate");
+        mFastFlingThreshold = getResources().getDimensionPixelOffset(
+                R.dimen.conversation_fast_fling_threshold);
+        mAdapter = new ConversationMessageAdapter(getActivity(), null, this,
+                null,
+                // Sets the item click listener on the Recycler item views.
+                new View.OnClickListener() {
+                    @Override
+                    public void onClick(final View v) {
+                        final ConversationMessageView messageView = (ConversationMessageView) v;
+                        handleMessageClick(messageView);
+                    }
+                },
+                new View.OnLongClickListener() {
+                    @Override
+                    public boolean onLongClick(final View view) {
+                        selectMessage((ConversationMessageView) view);
+                        return true;
+                    }
+                }
+        );
+        //sprd fix bug 562320 start
+        mSmilDraftListen = new SmileMessageHandle(this);
+        GlobleUtil.registerHandler(TAG, mSmilDraftListen);
+        //sprd fix bug 562320 end
+        if (savedInstanceState != null) {
+            mClearLocalDraft = savedInstanceState.getBoolean(CLEAR_LOCAL_DRAFT_STATE);
+            Log.d(TAG, "savedInstanceState is not null and mClearLocalDraft:" + mClearLocalDraft);
+        }
+        getActivity().registerReceiver(mSimInOutReceiver, mSimFilter);
+        getActivity().registerReceiver(mAirPlaneModeReceiver, mAirPlaneModeFilter);
+    }
+
+    /**
+     * setConversationInfo() may be called before or after onCreate(). When a user initiate a
+     * conversation from compose, the ConversationActivity creates this fragment and calls
+     * setConversationInfo(), so it happens before onCreate(). However, when the activity is
+     * restored from saved instance state, the ConversationFragment is created automatically by
+     * the fragment, before ConversationActivity has a chance to call setConversationInfo(). Since
+     * the ability to start loading data depends on both methods being called, we need to start
+     * loading when onActivityCreated() is called, which is guaranteed to happen after both.
+     */
+    @Override
+    public void onActivityCreated(final Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+        // Delay showing the message list until the participant list is loaded.
+        mRecyclerView.setVisibility(View.INVISIBLE);
+
+        /*add by sprd for Bug 630177 start*/
+        if (mHost == null) {
+            Log.d(TAG, "onActivityCreated mHost is null");
+            return;
+        }
+        /*add by sprd for Bug 630177 end*/
+
+        mBinding.ensureBound();
+        mBinding.getData().init(getLoaderManager(), mBinding);
+
+        // Build the input manager with all its required dependencies and pass it along to the
+        // compose message view.
+        final ConversationInputManager inputManager = new ConversationInputManager(
+                getActivity(), this, mComposeMessageView, mHost, getFragmentManagerToUse(),
+                mBinding, mComposeMessageView.getDraftDataModel(), savedInstanceState);
+        mComposeMessageView.setInputManager(inputManager);
+        mComposeMessageView.setConversationDataModel(BindingBase.createBindingReference(mBinding));
+        mHost.invalidateActionBar();
+
+        mDraftMessageDataModel =
+                BindingBase.createBindingReference(mComposeMessageView.getDraftDataModel());
+        mDraftMessageDataModel.getData().addListener(this);
+        mContext = getActivity();
+    }
+
+    public void onAttachmentChoosen() {
+        // Attachment has been choosen in the AttachmentChooserActivity, so clear local draft
+        // and reload draft on resume.
+        mClearLocalDraft = true;
+        // Add for bug 583553
+        mOnAttachmentChosen = true;
+    }
+
+    private int getScrollToMessagePosition() {
+        final Activity activity = getActivity();
+        if (activity == null) {
+            return -1;
+        }
+
+        final Intent intent = activity.getIntent();
+        if (intent == null) {
+            return -1;
+        }
+
+        return intent.getIntExtra(UIIntents.UI_INTENT_EXTRA_MESSAGE_POSITION, -1);
+    }
+
+    private void clearScrollToMessagePosition() {
+        final Activity activity = getActivity();
+        if (activity == null) {
+            return;
+        }
+
+        final Intent intent = activity.getIntent();
+        if (intent == null) {
+            return;
+        }
+        intent.putExtra(UIIntents.UI_INTENT_EXTRA_MESSAGE_POSITION, -1);
+    }
+
+    private final Handler mHandler = new Handler();
+
+    /**
+     * {@inheritDoc} from Fragment
+     */
+    @Override
+    public View onCreateView(final LayoutInflater inflater, final ViewGroup container,
+                             final Bundle savedInstanceState) {
+        final View view = inflater.inflate(R.layout.conversation_fragment, container, false);
+        mServerMenu = (LinearLayout)view.findViewById(R.id.serverMenu);    /* add for SmartMessage */
+
+        mRecyclerView = (RecyclerView) view.findViewById(android.R.id.list);
+        final LinearLayoutManager manager = new LinearLayoutManager(getActivity());
+        manager.setStackFromEnd(true);
+        manager.setReverseLayout(false);
+        mRecyclerView.setHasFixedSize(true);
+        mRecyclerView.setLayoutManager(manager);
+                if(!MmsConfig.getCmccSdkEnabled()){
+        mRecyclerView.setItemAnimator(new DefaultItemAnimator());
+                    }
+        mRecyclerView.setAdapter(mAdapter);
+
+        if (savedInstanceState != null) {
+            mListState = savedInstanceState.getParcelable(SAVED_INSTANCE_STATE_LIST_VIEW_STATE_KEY);
+        }
+
+        mConversationComposeDivider = view.findViewById(R.id.conversation_compose_divider);
+        mScrollToDismissThreshold = ViewConfiguration.get(getActivity()).getScaledTouchSlop();
+        mRecyclerView.addOnScrollListener(mListScrollListener);
+        mFastScroller = ConversationFastScroller.addTo(mRecyclerView,
+                UiUtils.isRtlMode() ? ConversationFastScroller.POSITION_LEFT_SIDE :
+                        ConversationFastScroller.POSITION_RIGHT_SIDE);
+
+        mComposeMessageView = (ComposeMessageView)
+                view.findViewById(R.id.message_compose_view_container);
+        // Bind the compose message view to the DraftMessageData
+//        mComposeMessageView.bind(DataModel.get().createDraftMessageData(
+//                mBinding.getData().getConversationId()), this);
+
+        /* Modify by SPRD for Bug:525178 2016.01.27 Start */
+        //add for 600739 start
+        if (mBinding.isBound()) {
+            mPreDraftMessageData = DataModel.get().createDraftMessageData(
+                    mBinding.getData().getConversationId());
+        } else {
+            //Bug 626575 start
+            Log.d(TAG, "onCreateView  bind: mConversationId:" + mConversationId);
+           /*add by sprd for Bug 630177 start*/
+            if (null==mConversationId) {
+                Log.d(TAG, "onCreateView  bind: getActivity()=" + getActivity());
+                if (getActivity()!=null){
+                    getActivity().finish();
+                }
+                return view;
+            }
+            /*add by sprd for  Bug 630177 end*/
+            mBinding.bind(DataModel.get().createConversationData(getActivity(), this, mConversationId));
+            mPreDraftMessageData = DataModel.get().createDraftMessageData(
+                    mBinding.getData().getConversationId());
+        }
+        Log.d(TAG, "onCreateView mConversationId = " + mConversationId);
+        //Bug 626575 end
+        //add for 600739 end
+        if (mPreDraftMessageData != null && savedInstanceState != null) {
+            ArrayList<MessagePartData> list = savedInstanceState.getParcelableArrayList(KEY_PRE_ATTACHMENT);
+            if (list != null && list.size() > 0) {
+                Log.d(TAG, "restore message attachment data from saved instance.");
+                //add for bug 638856 --begin
+                if(OsUtil.hasSmsPermission()) {
+                    mPreDraftMessageData.addAttachments(list);
+                }
+                //add for bug 638856 --end
+            }
+        }
+        /* Modify by SPRD for Bug:525178 2016.01.27 End */
+        if (mPreDraftMessageData != null) {
+            mComposeMessageView.bind(mPreDraftMessageData, this);
+        }
+
+
+        return view;
+    }
+
+    private void scrollToPosition(final int targetPosition, final boolean smoothScroll) {
+        if (smoothScroll) {
+            final int maxScrollDelta = JUMP_SCROLL_THRESHOLD;
+
+            final LinearLayoutManager layoutManager =
+                    (LinearLayoutManager) mRecyclerView.getLayoutManager();
+            final int firstVisibleItemPosition =
+                    layoutManager.findFirstVisibleItemPosition();
+            final int delta = targetPosition - firstVisibleItemPosition;
+            final int intermediatePosition;
+
+            if (delta > maxScrollDelta) {
+                intermediatePosition = Math.max(0, targetPosition - maxScrollDelta);
+            } else if (delta < -maxScrollDelta) {
+                final int count = layoutManager.getItemCount();
+                intermediatePosition = Math.min(count - 1, targetPosition + maxScrollDelta);
+            } else {
+                intermediatePosition = -1;
+            }
+            if (intermediatePosition != -1) {
+                mRecyclerView.scrollToPosition(intermediatePosition);
+            }
+            mRecyclerView.smoothScrollToPosition(targetPosition);
+        } else {
+            mRecyclerView.scrollToPosition(targetPosition);
+        }
+    }
+
+    private int getScrollPositionFromBottom() {
+        final LinearLayoutManager layoutManager =
+                (LinearLayoutManager) mRecyclerView.getLayoutManager();
+        final int lastVisibleItem =
+                layoutManager.findLastVisibleItemPosition();
+        return Math.max(mAdapter.getItemCount() - 1 - lastVisibleItem, 0);
+    }
+
+    /**
+     * Display a photo using the Photoviewer component.
+     */
+    @Override
+    public void displayPhoto(final Uri photoUri, final Rect imageBounds, final boolean isDraft) {
+        boolean isDrm = false;
+        try {
+            String dataPath = MessagingDrmSession.get().getPath(photoUri);
+            Log.d(TAG, " uri is " + photoUri + " path is " + dataPath);
+            if (dataPath != null && MessagingDrmSession.get().drmCanHandle(dataPath, null)) {
+                Log.d(TAG, " is drm data ");
+                isDrm = true;
+            }
+        } catch (Exception ex) {
+            Log.d(TAG, " drm ex " + ex);
+        }
+        displayPhoto(photoUri, imageBounds, isDraft, mConversationId, getActivity(), isDrm);
+    }
+
+    public static void displayPhoto(final Uri photoUri, final Rect imageBounds,
+                                    final boolean isDraft, final String conversationId, final Activity activity, boolean isDrm) {
+        final Uri imagesUri =
+                isDraft ? MessagingContentProvider.buildDraftImagesUri(conversationId)
+                        : MessagingContentProvider.buildConversationImagesUri(conversationId);
+        if (isDrm) {
+            UIIntents.get().launchFullScreenPhotoViewerForDrm(activity, photoUri, imageBounds, photoUri);
+        } else {
+            UIIntents.get().launchFullScreenPhotoViewer(activity, photoUri, imageBounds, imagesUri);
+        }
+    }
+
+    /* Add by SPRD for bug 563344 Start */
+    @Override
+    public void gotoSmilView(DraftMessageData draft) {
+        GlobleUtil.setEditedDraftMessageDate(null, null);
+        GlobleUtil.setDraftMessageData(draft);
+        String conversationName = getConversationName();
+        UIIntents.get().launchSmilMainActivity(getActivity(), true, conversationName);
+        mClearLocalDraft = true;
+    }
+    /* Add by SPRD for bug 563344 End */
+
+    /*Add by SPRD for bug581044  2016.07.08 Start*/
+    @Override
+    public boolean isEmptyRecipientConversaton() {
+        return isEmptyRecipientConversaton;
+    }
+    /*Add by SPRD for bug581044  2016.07.08 End*/
+
+    private void selectMessage(final ConversationMessageView messageView) {
+        selectMessage(messageView, null /* attachment */);
+    }
+
+    private void selectMessage(final ConversationMessageView messageView,
+                               final MessagePartData attachment) {
+        mSelectedMessage = messageView;
+        if (mSelectedMessage == null) {
+            mAdapter.setSelectedMessage(null);
+            mHost.dismissActionMode();
+            mSelectedAttachment = null;
+            return;
+        }
+        mSelectedAttachment = attachment;
+        mAdapter.setSelectedMessage(messageView.getData().getMessageId());
+        if (messageView != null && messageView.getDrmPathLocked()) {
+            Log.d(TAG, " selectMessage messageView locked ");
+            mHost.dismissActionMode();
+            UiUtils.showToastAtBottom(R.string.drm_can_not_processed);
+            return;
+        }
+        mHost.startActionMode(mMessageActionModeCallback);
+    }
+
+    /* And by SPRD for Bug:525178 2016.01.27 Start */
+    private DraftMessageData mPreDraftMessageData;
+    private static final String KEY_PRE_ATTACHMENT = "--k-p-a";
+    /* And by SPRD for Bug:525178 2016.01.27 End */
+
+    @Override
+    public void onSaveInstanceState(final Bundle outState) {
+        super.onSaveInstanceState(outState);
+        if (mListState != null) {
+            outState.putParcelable(SAVED_INSTANCE_STATE_LIST_VIEW_STATE_KEY, mListState);
+        }
+
+        /* And by SPRD for Bug:525178 2016.01.27 Start */
+        if (mPreDraftMessageData != null && mPreDraftMessageData.hasAttachments()) {
+            ArrayList<MessagePartData> list = new ArrayList<>();
+            for (MessagePartData mpd : mPreDraftMessageData.getReadOnlyAttachments()) {
+                Log.d(TAG, "content type:" + mpd.getContentType() + ", is attachment:" + mpd.isAttachment());
+                if (mpd != null && ContentType.APP_SMIL.equals(mpd.getContentType())) {
+                    mClearLocalDraft = true;
+                }
+                if (mpd != null && mpd.isAttachment()) {
+                    list.add(mpd);
+                }
+            }
+            outState.putParcelableArrayList(KEY_PRE_ATTACHMENT, list);
+        }
+        /* And by SPRD for Bug:525178 2016.01.27 Start */
+        outState.putBoolean(CLEAR_LOCAL_DRAFT_STATE, mClearLocalDraft);
+        mComposeMessageView.saveInputState(outState);
+    }
+
+    @Override
+    public void onResume() {
+        Log.d(TAG, " onResume mIncomingDraft=" + mIncomingDraft +" isSmilAttament="+GlobleUtil.isSmilAttament);
+        Log.d(TAG, " onResume mClearLocalDraft=" + mClearLocalDraft);
+        super.onResume();
+        // fix for bug 561498 begin
+        GlobleUtil.setSmilAdapter(null);
+        // fix for bug 561498 begin
+        if (GlobleUtil.isSmilAttament) {
+            GlobleUtil.isSmilAttament = false;
+            mPreDraftMessageData.mIsDraftCachedCopy = false;
+            mPreDraftMessageData.updateAttachmentsData();
+        }
+        if (mIncomingDraft == null) {
+            mComposeMessageView.requestDraftMessage(mClearLocalDraft);
+        } else {
+            mComposeMessageView.setDraftMessage(mIncomingDraft);
+            mIncomingDraft = null;
+        }
+        mClearLocalDraft = false;
+
+        // On resume, check if there's a pending request for resuming message compose. This
+        // may happen when the user commits the contact selection for a group conversation and
+        // goes from compose back to the conversation fragment.
+        if (mHost.shouldResumeComposeMessage()) {
+            mComposeMessageView.resumeComposeMessage();
+        }
+
+        setConversationFocus();
+
+        // On resume, invalidate all message views to show the updated timestamp.
+        mAdapter.notifyDataSetChanged();
+
+        LocalBroadcastManager.getInstance(getActivity()).registerReceiver(
+                mConversationSelfIdChangeReceiver,
+                new IntentFilter(UIIntents.CONVERSATION_SELF_ID_CHANGE_BROADCAST_ACTION));
+    }
+
+    void setConversationFocus() {
+        // bug 478514: Add for MmsFolderView Feature -- Begin
+        int isFolderView = BuglePrefs.getApplicationPrefs().getInt(
+                BuglePrefsKeys.IS_FOLDER_VIEW_MODE, 0);
+        if (mHost.isActiveAndFocused()) {
+            if (isFolderView == BuglePrefsKeys.CONVERSATION_STATE) {
+                mBinding.getData().setFocus();
+            }
+            // bug 478514: Add for MmsFolderView Feature -- end
+            // spread: fixe for bug 516158 start
+            if (mPauseRusume) {
+                mComposeMessageView.resumeComposeMessage();
+                mPauseRusume = false;
+            }
+            // spread: fixe for bug 516158 end
+        }
+    }
+
+    @Override
+    public void onPrepareOptionsMenu(Menu menu) {
+        MenuItem addPhraseMenu = menu.findItem(R.id.action_add_phrase);
+        if (null != addPhraseMenu) {
+            if (MessageData.PROTOCOL_MMS_SMIL == mComposeMessageView.getDraftDataModel().getData().mProtocol) {
+                addPhraseMenu.setVisible(false);
+            } else {
+                addPhraseMenu.setVisible(true);
+            }
+        }
+    }
+
+    @Override
+    public void onCreateOptionsMenu(final Menu menu, final MenuInflater inflater) {
+        if (mHost.getActionMode() != null) {
+            return;
+        }
+
+        inflater.inflate(R.menu.conversation_menu, menu);
+
+        final ConversationData data = mBinding.getData();
+
+        // Disable the "people & options" item if we haven't loaded participants yet.
+        menu.findItem(R.id.action_people_and_options).setEnabled(data.getParticipantsLoaded());
+
+        // See if we can show add contact action.
+        final ParticipantData participant = data.getOtherParticipant();
+        final boolean addContactActionVisible = (participant != null
+                && TextUtils.isEmpty(participant.getLookupKey()));
+        menu.findItem(R.id.action_add_contact).setVisible(addContactActionVisible);
+
+        // See if we should show archive or unarchive.
+        final boolean isArchived = data.getIsArchived();
+        menu.findItem(R.id.action_archive).setVisible(!isArchived);
+        menu.findItem(R.id.action_unarchive).setVisible(isArchived);
+
+        // Conditionally enable the phone call button.
+        final boolean supportCallAction = (PhoneUtils.getDefault().isVoiceCapable() &&
+                data.getParticipantPhoneNumber() != null);
+        menu.findItem(R.id.action_call).setVisible(supportCallAction);
+        menu.findItem(R.id.action_add_phrase).setVisible(true);//sprd add for common message
+        menu.findItem(R.id.action_sms_merge_forward).setVisible(true);//sprd add for sms merge forward
+        //wqq modify for bug 92593
+        //menu.findItem(R.id.goto_smil).setVisible(true);//Sprd add for smil   
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(final MenuItem item) {
+        switch (item.getItemId()) {
+            case R.id.action_people_and_options:
+                Assert.isTrue(mBinding.getData().getParticipantsLoaded());
+                UIIntents.get().launchPeopleAndOptionsActivity(getActivity(), mConversationId);
+                return true;
+
+            case R.id.action_call:
+                final String phoneNumber = mBinding.getData().getParticipantPhoneNumber();
+                Assert.notNull(phoneNumber);
+                final View targetView = getActivity().findViewById(R.id.action_call);
+                Point centerPoint;
+                if (targetView != null) {
+                    final int screenLocation[] = new int[2];
+                    targetView.getLocationOnScreen(screenLocation);
+                    final int centerX = screenLocation[0] + targetView.getWidth() / 2;
+                    final int centerY = screenLocation[1] + targetView.getHeight() / 2;
+                    centerPoint = new Point(centerX, centerY);
+                } else {
+                    // In the overflow menu, just use the center of the screen.
+                    final Display display = getActivity().getWindowManager().getDefaultDisplay();
+                    centerPoint = new Point(display.getWidth() / 2, display.getHeight() / 2);
+                }
+                UIIntents.get().launchPhoneCallActivity(getActivity(), phoneNumber, centerPoint);
+                return true;
+
+            case R.id.action_archive:
+                mBinding.getData().archiveConversation(mBinding);
+                closeConversation(mConversationId);
+                return true;
+
+            case R.id.action_unarchive:
+                mBinding.getData().unarchiveConversation(mBinding);
+                return true;
+
+            case R.id.action_settings:
+                return true;
+
+            case R.id.action_add_contact:
+                final ParticipantData participant = mBinding.getData().getOtherParticipant();
+                Assert.notNull(participant);
+                final String destination = participant.getNormalizedDestination();
+                final Uri avatarUri = AvatarUriUtil.createAvatarUri(participant);
+                (new AddContactsConfirmationDialog(getActivity(), avatarUri, destination)).show();
+                return true;
+
+            case R.id.action_delete:
+                if (isReadyForAction()) {
+                    new AlertDialog.Builder(getActivity())
+                            .setTitle(getResources().getQuantityString(
+                                    R.plurals.delete_conversations_confirmation_dialog_title, 1))
+                            .setPositiveButton(R.string.delete_conversation_confirmation_button,
+                                    new DialogInterface.OnClickListener() {
+                                        @Override
+                                        public void onClick(final DialogInterface dialog,
+                                                            final int button) {
+                                            deleteConversation();
+                                        }
+                                    })
+                            .setNegativeButton(R.string.delete_conversation_decline_button, null)
+                            .show();
+                } else {
+                    warnOfMissingActionConditions(false /*sending*/,
+                            null /*commandToRunAfterActionConditionResolved*/);
+                }
+                return true;
+            //sprd add for common message begin
+            case R.id.action_add_phrase:
+                Intent intent = new Intent(getActivity(), ShowPharseActivity.class);
+                startActivityForResult(intent, REQUEST_INSERT_PHRASE);
+                return true;
+            //sprd add for common message end
+            //Sprd add for sms merge forward begin
+            case R.id.action_sms_merge_forward:
+                Log.d(TAG, "click sms merge menu: mConversationId: " + mConversationId);
+                Intent i = new Intent(getActivity(), SmsMergeForwardActivity.class);
+                i.putExtra("thread_id", mConversationId);
+                i.putExtra("SMS_MERGE_FORWARD_FROM", "ConversationFragment");
+                startActivity(i);
+                return true;
+            //Sprd add for sms merge forward end
+
+           /* case R.id.goto_smil:  wqq modify for bug 92593
+                // store data to DB if the data hasn't been stored in DB
+                StartSlideshow();
+                return true;*/
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    /**
+     * {@inheritDoc} from ConversationDataListener
+     */
+    @Override
+    public void onConversationMessagesCursorUpdated(final ConversationData data,
+                                                    final Cursor cursor, final ConversationMessageData newestMessage,
+                                                    final boolean isSync) {
+        Log.d(TAG, "onConversationMessagesCursorUpdated");
+        mBinding.ensureBound(data);
+
+        // This needs to be determined before swapping cursor, which may change the scroll state.
+        final boolean scrolledToBottom = isScrolledToBottom();
+        final int positionFromBottom = getScrollPositionFromBottom();
+
+        // If participants not loaded, assume 1:1 since that's the 99% case
+        final boolean oneOnOne =
+                !data.getParticipantsLoaded() || data.getOtherParticipant() != null;
+        mAdapter.setOneOnOne(oneOnOne, false /* invalidate */);
+
+        // Ensure that the action bar is updated with the current data.
+        invalidateOptionsMenu();
+        final Cursor oldCursor = mAdapter.swapCursor(cursor);
+
+        if (cursor != null && oldCursor == null) {
+            if (mListState != null) {
+                mRecyclerView.getLayoutManager().onRestoreInstanceState(mListState);
+                // RecyclerView restores scroll states without triggering scroll change events, so
+                // we need to manually ensure that they are correctly handled.
+                mListScrollListener.onScrolled(mRecyclerView, 0, 0);
+            }
+        }
+
+        if (isSync) {
+            // This is a message sync. Syncing messages changes cursor item count, which would
+            // implicitly change RV's scroll position. We'd like the RV to keep scrolled to the same
+            // relative position from the bottom (because RV is stacked from bottom), so that it
+            // stays relatively put as we sync.
+            final int position = Math.max(mAdapter.getItemCount() - 1 - positionFromBottom, 0);
+            scrollToPosition(position, false /* smoothScroll */);
+        } else if (newestMessage != null) {
+            // Show a snack bar notification if we are not scrolled to the bottom and the new
+            // message is an incoming message.
+            if (!scrolledToBottom && newestMessage.getIsIncoming()) {
+                // If the conversation activity is started but not resumed (if another dialog
+                // activity was in the foregrond), we will show a system notification instead of
+                // the snack bar.
+                if (mBinding.getData().isFocused()) {
+                    UiUtils.showSnackBarWithCustomAction(getActivity(),
+                            getView().getRootView(),
+                            getString(R.string.in_conversation_notify_new_message_text),
+                            SnackBar.Action.createCustomAction(new Runnable() {
+                                                                   @Override
+                                                                   public void run() {
+                                                                       scrollToBottom(true /* smoothScroll */);
+                                                                       mComposeMessageView.hideAllComposeInputs(false /* animate */);
+                                                                   }
+                                                               },
+                                    getString(R.string.in_conversation_notify_new_message_action)),
+                            null /* interactions */,
+                            SnackBar.Placement.above(mComposeMessageView));
+                }
+            } else {
+                // We are either already scrolled to the bottom or this is an outgoing message,
+                // scroll to the bottom to reveal it.
+                // Don't smooth scroll if we were already at the bottom; instead, we scroll
+                // immediately so RecyclerView's view animation will take place.
+                scrollToBottom(!scrolledToBottom);
+            }
+        }
+
+        if (cursor != null) {
+            mHost.onConversationMessagesUpdated(cursor.getCount());
+
+            // Are we coming from a widget click where we're told to scroll to a particular item?
+            final int scrollToPos = getScrollToMessagePosition();
+            if (scrollToPos >= 0) {
+                if (LogUtil.isLoggable(LogUtil.BUGLE_TAG, LogUtil.VERBOSE)) {
+                    LogUtil.v(LogUtil.BUGLE_TAG, "onConversationMessagesCursorUpdated " +
+                            " scrollToPos: " + scrollToPos +
+                            " cursorCount: " + cursor.getCount());
+                }
+                scrollToPosition(scrollToPos, true /*smoothScroll*/);
+                clearScrollToMessagePosition();
+            }
+        }
+
+        mHost.invalidateActionBar();
+    }
+
+    /**
+     * {@inheritDoc} from ConversationDataListener
+     */
+    @Override
+    public void onConversationMetadataUpdated(final ConversationData conversationData) {
+        mBinding.ensureBound(conversationData);
+        Log.d(TAG, "onConversationMetadataUpdated");
+        if (mSelectedMessage != null && mSelectedAttachment != null) {
+            // We may have just sent a message and the temp attachment we selected is now gone.
+            // and it was replaced with some new attachment.  Since we don't know which one it
+            // is we shouldn't reselect it (unless there is just one) In the multi-attachment
+            // case we would just deselect the message and allow the user to reselect, otherwise we
+            // may act on old temp data and may crash.
+            final List<MessagePartData> currentAttachments = mSelectedMessage.getData().getAttachments();
+            if (currentAttachments.size() == 1) {
+                mSelectedAttachment = currentAttachments.get(0);
+            } else if (!currentAttachments.contains(mSelectedAttachment)) {
+                selectMessage(null);
+            }
+        }
+        // Ensure that the action bar is updated with the current data.
+        invalidateOptionsMenu();
+        mHost.onConversationMetadataUpdated();
+        mAdapter.notifyDataSetChanged();
+        setConversationFocus();
+    }
+
+    public void setConversationInfo(final Context context, final String conversationId,
+                                    final MessageData draftData) {
+        // TODO: Eventually I would like the Factory to implement
+        // Factory.get().bindConversationData(mBinding, getActivity(), this, conversationId));
+
+        //modify for bug 611547
+        mConversationId = conversationId;
+        mIncomingDraft = draftData;
+        //modify for bug 611547
+
+        if (!mBinding.isBound()) {
+            mBinding.bind(DataModel.get().createConversationData(context, this, conversationId));
+            /*Add by SPRD for bug581044  2016.07.08 Start*/
+            if (MmsConfig.get(ParticipantData.DEFAULT_SELF_SUB_ID).getContentEditEnabled()) {
+                String oldConversation = mHost.getOldConversationId();
+                Log.d(TAG, " setConversationInfo oldConversationId:" + oldConversation + " conversationId," + conversationId);
+                if (oldConversation != null && !oldConversation.equals(conversationId)) {
+                    if (BugleDatabaseOperations.isEmptyConversation(oldConversation) && BugleDatabaseOperations.isNeedDeleteConveration(oldConversation)) {
+                        DeleteConversationAction.deleteConversation(oldConversation,
+                                System.currentTimeMillis());
+                    }
+                }
+                isEmptyRecipientConversaton = BugleDatabaseOperations.isEmptyConversation(conversationId);
+            }
+            /*Add by SPRD for bug581044  2016.07.08 End*/
+        } else {
+            Assert.isTrue(TextUtils.equals(mBinding.getData().getConversationId(), conversationId));
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        // Unbind all the views that we bound to data
+        if (mComposeMessageView != null) {
+            mComposeMessageView.unbind();
+        }
+
+        // And unbind this fragment from its data
+        mBinding.unbind();
+        mConversationId = null;
+        getActivity().unregisterReceiver(mSimInOutReceiver);
+        getActivity().unregisterReceiver(mAirPlaneModeReceiver);
+        //sprd fix bug 562320 start
+        GlobleUtil.unRegisterHandler(TAG);
+        //sprd fix bug 562320 end
+    }
+
+    void suppressWriteDraft() {
+        mSuppressWriteDraft = true;
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+       /*add by sprd for Bug 626075 start*/
+        if (getActivity().isInMultiWindowMode()){
+            return;
+        }
+       /*add by sprd for Bug 626075 end*/
+        mLoadDraftDone = false;
+        mOnAttachmentChosen = false;
+        Log.d(TAG, " onPause setKeepingMessageData: mSuppressWriteDraft="+mSuppressWriteDraft + " mComposeMessageView="+ mComposeMessageView);
+        if (mComposeMessageView != null && !mSuppressWriteDraft) {
+            mComposeMessageView.writeDraftMessage();
+        }
+        /*Add by SPRD for bug581044  2016.07.08 Start*/
+        if (MmsConfig.get(ParticipantData.DEFAULT_SELF_SUB_ID).getContentEditEnabled() && mComposeMessageView != null) {
+            Log.d(TAG, " onPause setKeepingMessageData: " + mComposeMessageView.getKeepingMessageData());
+            mHost.setKeepingMessageData(mComposeMessageView.getKeepingMessageData());
+        }
+        /*Add by SPRD for bug581044  2016.07.08 End*/
+        mSuppressWriteDraft = false;
+        mBinding.getData().unsetFocus();
+        mListState = mRecyclerView.getLayoutManager().onSaveInstanceState();
+
+        LocalBroadcastManager.getInstance(getActivity())
+                .unregisterReceiver(mConversationSelfIdChangeReceiver);
+    }
+
+    /*add by sprd for Bug 626075 start*/
+    @Override
+    public void onStop() {
+        if (getActivity().isInMultiWindowMode()){
+            mLoadDraftDone = false;
+            mOnAttachmentChosen = false;
+            Log.d(TAG, " onStop setKeepingMessageData: mSuppressWriteDraft="+mSuppressWriteDraft + " mComposeMessageView="+ mComposeMessageView);
+            if (mComposeMessageView != null && !mSuppressWriteDraft) {
+                mComposeMessageView.writeDraftMessage();
+            }
+            /*Add by SPRD for bug581044  2016.07.08 Start*/
+            if (MmsConfig.get(ParticipantData.DEFAULT_SELF_SUB_ID).getContentEditEnabled() && mComposeMessageView != null) {
+                Log.d(TAG, " onStop setKeepingMessageData: " + mComposeMessageView.getKeepingMessageData());
+                mHost.setKeepingMessageData(mComposeMessageView.getKeepingMessageData());
+            }
+            /*Add by SPRD for bug581044  2016.07.08 End*/
+            mSuppressWriteDraft = false;
+            mBinding.getData().unsetFocus();
+            mListState = mRecyclerView.getLayoutManager().onSaveInstanceState();
+
+            LocalBroadcastManager.getInstance(getActivity())
+                    .unregisterReceiver(mConversationSelfIdChangeReceiver);
+        }
+        super.onStop();
+    }
+    /*add by sprd for Bug 626075 end*/
+    @Override
+    public void onConfigurationChanged(final Configuration newConfig) {
+        super.onConfigurationChanged(newConfig);
+        mRecyclerView.getItemAnimator().endAnimations();
+    }
+
+    // TODO: Remove isBound and replace it with ensureBound after b/15704674.
+    public boolean isBound() {
+        return mBinding.isBound();
+    }
+
+    private FragmentManager getFragmentManagerToUse() {
+        return OsUtil.isAtLeastJB_MR1() ? getChildFragmentManager() : getFragmentManager();
+    }
+
+    public MediaPicker getMediaPicker() {
+        return (MediaPicker) getFragmentManagerToUse().findFragmentByTag(
+                MediaPicker.FRAGMENT_TAG);
+    }
+
+    @Override
+    public void sendMessage(final MessageData message) {
+        if (isReadyForAction()) {
+            if (ensureKnownRecipients()) {
+                /* Add by SPRD for bug 563344 Start */
+                if (MessageData.PROTOCOL_MMS_SMIL == message.getProtocol()) {
+                    Log.d(TAG, "sendMessage: message protocol is PROTOCOL_MMS_SMIL");
+                } else {
+                /* Add by SPRD for bug 563344 End */
+                    // Merge the caption text from attachments into the text body of
+                    // the messages
+                    message.consolidateText();
+                }
+                mBinding.getData().sendMessage(mBinding, message);
+                mComposeMessageView.resetMediaPickerState();
+            } else {
+                LogUtil.w(LogUtil.BUGLE_TAG, "Message can't be sent: conv participants not loaded");
+            }
+        } else {
+            warnOfMissingActionConditions(true /*sending*/,
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            sendMessage(message);
+                        }
+                    });
+        }
+        // bug 478514: Add for MmsFolderView Feature -- Begin
+        getActivity().runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                int isFolderView = BuglePrefs.getApplicationPrefs().getInt(BuglePrefsKeys.IS_FOLDER_VIEW_MODE,
+                        0);
+                if (isFolderView == BuglePrefsKeys.FOLDERVIEW_STATE) {
+                    getActivity().setResult(getActivity().RESULT_OK);
+                    getActivity().finish();
+                }
+            }
+        });
+        // bug 478514: Add for MmsFolderView Feature -- End
+    }
+
+    public void setHost(final ConversationFragmentHost host) {
+        mHost = host;
+    }
+
+    public String getConversationName() {
+        //add for bug 637364 --begin
+        String ConversationName = mBinding.getData().getConversationName();
+        if (ConversationName!=null){
+            return ConversationName;
+        }else{
+            return " ";
+        }
+        //add for bug 637364 --end
+    }
+
+    @Override
+    public void onComposeEditTextFocused() {
+        mHost.onStartComposeMessage();
+    }
+
+    @Override
+    public void onAttachmentsCleared() {
+        // When attachments are removed, reset transient media picker state such as image selection.
+        mComposeMessageView.resetMediaPickerState();
+    }
+
+    /**
+     * Called to check if all conditions are nominal and a "go" for some action, such as deleting
+     * a message, that requires this app to be the default app. This is also a precondition
+     * required for sending a draft.
+     *
+     * @return true if all conditions are nominal and we're ready to send a message
+     */
+    @Override
+    public boolean isReadyForAction() {
+        return UiUtils.isReadyForAction();
+    }
+
+    /**
+     * When there's some condition that prevents an operation, such as sending a message,
+     * call warnOfMissingActionConditions to put up a snackbar and allow the user to repair
+     * that condition.
+     *
+     * @param sending                                  - true if we're called during a sending operation
+     * @param commandToRunAfterActionConditionResolved - a runnable to run after the user responds
+     *                                                 positively to the condition prompt and resolves the condition. If null,
+     *                                                 the user will be shown a toast to tap the send button again.
+     */
+    @Override
+    public void warnOfMissingActionConditions(final boolean sending,
+                                              final Runnable commandToRunAfterActionConditionResolved) {
+        if (mChangeDefaultSmsAppHelper == null) {
+            mChangeDefaultSmsAppHelper = new ChangeDefaultSmsAppHelper();
+        }
+        mChangeDefaultSmsAppHelper.warnOfMissingActionConditions(sending,
+                commandToRunAfterActionConditionResolved, mComposeMessageView,
+                getView().getRootView(),
+                getActivity(), this);
+    }
+
+    private boolean ensureKnownRecipients() {
+        final ConversationData conversationData = mBinding.getData();
+
+        if (!conversationData.getParticipantsLoaded()) {
+            // We can't tell yet whether or not we have an unknown recipient
+            return false;
+        }
+
+        final ConversationParticipantsData participants = conversationData.getParticipants();
+        for (final ParticipantData participant : participants) {
+
+
+            if (participant.isUnknownSender()) {
+                UiUtils.showToast(R.string.unknown_sender);
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public void retryDownload(final String messageId) {
+        if (isReadyForAction()) {
+            mBinding.getData().downloadMessage(mBinding, messageId);
+        } else {
+            warnOfMissingActionConditions(false /*sending*/,
+                    null /*commandToRunAfterActionConditionResolved*/);
+        }
+    }
+
+    public void retrySend(final String messageId) {
+        if (isReadyForAction()) {
+            if (ensureKnownRecipients()) {
+                mBinding.getData().resendMessage(mBinding, messageId);
+            }
+        } else {
+            warnOfMissingActionConditions(true /*sending*/,
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            retrySend(messageId);
+                        }
+
+                    });
+        }
+    }
+
+    void deleteMessage(final String messageId) {
+        if (isReadyForAction()) {
+            final AlertDialog.Builder builder = new AlertDialog.Builder(getActivity())
+                    .setTitle(R.string.delete_message_confirmation_dialog_title)
+                    .setMessage(R.string.delete_message_confirmation_dialog_text)
+                    .setPositiveButton(R.string.delete_message_confirmation_button,
+                            new OnClickListener() {
+                                @Override
+                                public void onClick(final DialogInterface dialog, final int which) {
+                                    mBinding.getData().deleteMessage(mBinding, messageId);
+                                }
+                            })
+                    .setNegativeButton(android.R.string.cancel, null);
+            if (OsUtil.isAtLeastJB_MR1()) {
+                builder.setOnDismissListener(new OnDismissListener() {
+                    @Override
+                    public void onDismiss(final DialogInterface dialog) {
+                        mHost.dismissActionMode();
+                    }
+                });
+            } else {
+                builder.setOnCancelListener(new OnCancelListener() {
+                    @Override
+                    public void onCancel(final DialogInterface dialog) {
+                        mHost.dismissActionMode();
+                    }
+                });
+            }
+            builder.create().show();
+        } else {
+            warnOfMissingActionConditions(false /*sending*/,
+                    null /*commandToRunAfterActionConditionResolved*/);
+            mHost.dismissActionMode();
+        }
+    }
+
+    public void deleteConversation() {
+        if (isReadyForAction()) {
+            final Context context = getActivity();
+            mBinding.getData().deleteConversation(mBinding);
+            closeConversation(mConversationId);
+        } else {
+            warnOfMissingActionConditions(false /*sending*/,
+                    null /*commandToRunAfterActionConditionResolved*/);
+        }
+    }
+
+    @Override
+    public void closeConversation(final String conversationId) {
+        if (TextUtils.equals(conversationId, mConversationId)) {
+            mHost.onFinishCurrentConversation();
+            // TODO: Explicitly transition to ConversationList (or just go back)?
+        }
+    }
+
+    @Override
+    public void onConversationParticipantDataLoaded(final ConversationData data) {
+        mBinding.ensureBound(data);
+        if (mBinding.getData().getParticipantsLoaded()) {
+            final boolean oneOnOne = mBinding.getData().getOtherParticipant() != null;
+            mAdapter.setOneOnOne(oneOnOne, true /* invalidate */);
+
+            // refresh the options menu which will enable the "people & options" item.
+            invalidateOptionsMenu();
+
+            mHost.invalidateActionBar();
+
+            // bug 478514: Add for MmsFolderView Feature -- Begin
+            int isFolderView = BuglePrefs.getApplicationPrefs().getInt(
+                    BuglePrefsKeys.IS_FOLDER_VIEW_MODE, 0);
+            if (isFolderView == BuglePrefsKeys.FOLDERVIEW_STATE) {
+                mRecyclerView.setVisibility(View.INVISIBLE);
+            } else {
+                mRecyclerView.setVisibility(View.VISIBLE);
+            }
+            // bug 478514: Add for MmsFolderView Feature -- End
+            mHost.onConversationParticipantDataLoaded
+                    (mBinding.getData().getNumberOfParticipantsExcludingSelf());
+
+            /* add for SmartMessage start*/
+           if (MmsConfig.getCmccSdkEnabled()) {
+                if (isSmartMessage()){
+                    mPort = mBinding.getData().getParticipantPhoneNumber(); //"10010";
+                    Log.d(SMART_TAG, " mPort = " + mPort);
+                    if (mPort != null){
+                        LoadServerMenuThread loadServerMenuThread = new LoadServerMenuThread();
+                        loadServerMenuThread.start();
+                                    Log.w("hzh","mLoadsmartSmsTask");
+             mLoadsmartSmsTask=new LoadsmartSmsTask(mContext);
+             mLoadsmartSmsTask.execute();
+                    }
+                }
+            }
+            /* add for SmartMessage end*/
+        }
+    }
+
+    @Override
+    public void onSubscriptionListDataLoaded(final ConversationData data) {
+        mBinding.ensureBound(data);
+        mAdapter.notifyDataSetChanged();
+    }
+
+    @Override
+    public void promptForSelfPhoneNumber() {
+        if (mComposeMessageView != null) {
+            // Avoid bug in system which puts soft keyboard over dialog after orientation change
+            ImeUtil.hideSoftInput(getActivity(), mComposeMessageView);
+        }
+
+        final FragmentTransaction ft = getActivity().getFragmentManager().beginTransaction();
+        final EnterSelfPhoneNumberDialog dialog = EnterSelfPhoneNumberDialog
+                .newInstance(getConversationSelfSubId());
+        dialog.setTargetFragment(this, 0/*requestCode*/);
+        dialog.show(ft, null/*tag*/);
+    }
+
+    @Override
+    public void onActivityResult(final int requestCode, final int resultCode, final Intent data) {
+        if (mChangeDefaultSmsAppHelper == null) {
+            mChangeDefaultSmsAppHelper = new ChangeDefaultSmsAppHelper();
+        }
+        mChangeDefaultSmsAppHelper.handleChangeDefaultSmsResult(requestCode, resultCode, null);
+        //sprd add for common message begin
+        if (requestCode == REQUEST_INSERT_PHRASE) {
+            if (data != null) {
+                boolean noCommonPhrase = data.getBooleanExtra("k-n-p", false);
+                if (noCommonPhrase) {
+                    Toast.makeText(
+                            mContext,
+                            mContext.getString(R.string.no_common_phrase),
+                            Toast.LENGTH_LONG).show();
+                    return;
+                }
+                String insertText = data.getStringExtra("clickPhrase");
+                if (insertText != null) {
+                    mComposeMessageView.getComposeEditText().append(insertText);
+                }
+            }
+
+            /* And SPRD for Bug:527166  2015.01.22 Start */
+//            if (resultCode == Activity.RESULT_OK) {
+//                if (data != null) {
+//                    if (data.getBooleanExtra(ShowPharseActivity.KEY_NO_PHRASE, false)) {
+//                        UiUtils.showToastAtBottom(R.string.common_phrase_empty);
+//                    }
+//                }
+//            }
+            /* And by SPRD for Bug:527166  2015.01.22 End */
+
+        }
+        //sprd add for common message end
+    }
+
+    public boolean hasMessages() {
+        return mAdapter != null && mAdapter.getItemCount() > 0;
+    }
+
+    public boolean onBackPressed() {
+        if (mComposeMessageView.onBackPressed()) {
+            return true;
+        }
+        return false;
+    }
+
+    public boolean onNavigationUpPressed() {
+        return mComposeMessageView.onNavigationUpPressed();
+    }
+
+    private void checkDrmRightsConsume(final MessagePartData attachment, final Rect imageBounds) {
+        AlertDialog.Builder builder = MessagingDrmSession.get().showProtectInfo(getContext(), attachment.getDrmDataPath(), true/*is picture*/);
+
+        /* Modify by SPRD for Bug:524873  2015.01.21 Start */
+//        builder.setTitle(mContext.getString(R.string.drm_consume_title))
+//               .setMessage(mContext.getString(R.string.drm_consume_hint))
+        builder.setPositiveButton(mContext.getString(R.string.ok_drm_rights_consume),
+        /* Modify by SPRD for Bug:524873  2015.01.21 End */
+
+                new AlertDialog.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        try {
+                            displayPhoto(attachment.getContentUri(), imageBounds, false);
+                        } catch (Exception e) {
+                            Toast.makeText(
+                                    mContext,
+                                    mContext.getString(R.string.drm_no_application_open),
+                                    Toast.LENGTH_LONG).show();
+                        }
+                    }
+                })
+                .setNegativeButton(mContext.getString(R.string.cancel_drm_rights_consume), null).show();
+    }
+
+    @Override
+    public boolean onAttachmentClick(final ConversationMessageView messageView,
+                                     final MessagePartData attachment, final Rect imageBounds, final boolean longPress) {
+        if (longPress) {
+            if (attachment.isDrmType()) {
+                mHost.dismissActionMode();
+                UiUtils.showToastAtBottom(R.string.drm_can_not_processed);
+                return true;
+            }
+            selectMessage(messageView, attachment);
+            return true;
+        } else if (messageView.getData().getOneClickResendMessage()) {
+            handleMessageClick(messageView);
+            return true;
+        }
+
+        if (attachment.isImage()) {
+            String contentType = attachment.getContentType();
+            boolean isDrm = ContentType.isDrmType(contentType);
+            if (isDrm) {
+                Log.d(TAG, " content type is " + contentType + " path " + attachment.getDrmDataPath());
+                if (attachment.getDrmFileRightsStatus() == false) {
+                    UIIntents.get().launchDrmRightRequestActivity(getContext(), attachment);
+                    return true;
+                }
+                checkDrmRightsConsume(attachment, imageBounds);
+                return true;
+            }
+            displayPhoto(attachment.getContentUri(), imageBounds, false /* isDraft */);
+        }
+
+        if (attachment.isVCard()) {
+            UIIntents.get().launchVCardDetailActivity(getActivity(), attachment.getContentUri());
+        }
+        if (attachment.isVCalendar() /*|| !(attachment.isMedia())*/ && !MediaScratchFileProvider.AUTHORITY.equals(attachment.getContentUri().getAuthority())) {
+            // getImportAlertMessage(attachment);
+            UIIntents.get().launchVCalendarActivity(getActivity(), attachment.getContentUri());
+        }
+        if (!(attachment.isMedia())) {
+            getImportAlertMessage(attachment);
+        }
+
+        return false;
+    }
+
+    private void handleMessageClick(final ConversationMessageView messageView) {
+        if (messageView != mSelectedMessage) {
+            final ConversationMessageData data = messageView.getData();
+            final boolean isReadyToSend = isReadyForAction();
+            if (data.getOneClickResendMessage()) {
+                // Directly resend the message on tap if it's failed
+                retrySend(data.getMessageId());
+                selectMessage(null);
+            } else if (data.getShowResendMessage() && isReadyToSend) {
+                // Select the message to show the resend/download/delete options
+                selectMessage(messageView);
+            } else if (data.getShowDownloadMessage() && isReadyToSend) {
+                // Directly download the message on tap
+                retryDownload(data.getMessageId());
+            } else {
+                // Let the toast from warnOfMissingActionConditions show and skip
+                // selecting
+                warnOfMissingActionConditions(false /*sending*/,
+                        null /*commandToRunAfterActionConditionResolved*/);
+                selectMessage(null);
+            }
+        } else {
+            selectMessage(null);
+        }
+    }
+
+    private static class AttachmentToSave {
+        public Uri uri;
+        public String contentType;
+        public Uri persistedUri;
+        // Saved status.
+        public Status status;
+
+        AttachmentToSave(final Uri uri, final String contentType) {
+            this.uri = uri;
+            this.contentType = contentType;
+        }
+
+        public enum Status {SUCCESS, FAILED_FULL_STORAGE}
+
+        ;
+    }
+
+    public static class SaveAttachmentTask extends SafeAsyncTask<Void, Void, Void> {
+        private Context mContext;
+        private final List<AttachmentToSave> mAttachmentsToSave = new ArrayList<>();
+
+        public SaveAttachmentTask(final Context context, final Uri contentUri,
+                                  final String contentType) {
+            mContext = context;
+            addAttachmentToSave(contentUri, contentType);
+        }
+
+        public SaveAttachmentTask(final Context context) {
+            mContext = context;
+        }
+
+        public void addAttachmentToSave(final Uri contentUri, String contentType) {
+            AttachmentToSave savedAttachment = new AttachmentToSave(contentUri, contentType);
+            mAttachmentsToSave.add(savedAttachment);
+        }
+
+        ProgressDialog mWaitDialg;
+
+        @Override
+        protected void onPreExecute() {
+            super.onPreExecute();
+            boolean showDlaog = true;
+            if (mContext instanceof Activity) {
+                Activity a = (Activity) mContext;
+                if (a.isFinishing() || a.isDestroyed()) {
+                    showDlaog = false;
+                }
+            }
+            if (showDlaog) {
+                mWaitDialg = new ProgressDialog(mContext);
+                mWaitDialg.setCancelable(true);
+                mWaitDialg.setIndeterminate(true);
+                mWaitDialg.setMessage(mContext.getString(R.string.dlg_save_attachment));
+                mWaitDialg.show();
+            }
+        }
+
+        public int getAttachmentCount() {
+            return mAttachmentsToSave.size();
+        }
+
+        @Override
+        protected Void doInBackgroundTimed(final Void... arg) {
+            final File appDir = new File(Environment.getExternalStoragePublicDirectory(
+                    Environment.DIRECTORY_PICTURES),
+                    mContext.getResources().getString(R.string.app_name));
+            final File downloadDir = Environment.getExternalStoragePublicDirectory(
+                    Environment.DIRECTORY_DOWNLOADS);
+            for (final AttachmentToSave attachment : mAttachmentsToSave) {
+                if (attachment != null) {
+                    // In a new thread.
+                    if (TextUtils.isEmpty(attachment.contentType)
+                            && attachment.uri != null
+                            && attachment.uri.toString().startsWith("content://mms/part/")) {
+                        attachment.contentType = UriUtil.getContentFromPartUri(attachment.uri);
+                    }
+                    if (!TextUtils.isEmpty(attachment.contentType)) {
+                          /*Delete by SPRD for Bug:574142 Start {@*/
+//                        // FIXME: drm files cannot be saved? delete it, if possible.
+//                        if (ContentType.isDrmType(attachment.contentType)) {
+//                             UiUtils.showToastAtBottom(R.string.drm_can_not_processed);
+//                        } else {
+                        File savedDir = getSaveDir();
+                        if (savedDir != null) {
+                            attachment.persistedUri = UriUtil.persistContent(attachment.uri,
+                                    savedDir, attachment.contentType);
+                        } else {
+                            Log.d(TAG, "lxg cannot save attachment, no available storage.");
+                            attachment.status = AttachmentToSave.Status.FAILED_FULL_STORAGE;
+                        }
+//                        }
+                          /*end @}*/
+                    } else {
+                        Log.d(TAG, "lxg cannot save attachment, content type is null.");
+                    }
+                }
+            }
+            return null;
+        }
+
+        private File getSaveDir() {
+            File dir = mkdirs(EnvironmentEx.getExternalStoragePath(), EnvironmentEx.getExternalStoragePathState());
+            if (dir == null) {
+                dir = mkdirs(EnvironmentEx.getInternalStoragePath(), EnvironmentEx.getInternalStoragePathState());
+            }
+            return dir;
+        }
+
+        private File mkdirs(File root, String state) {
+            File dir = null;
+            if (isMounted(state) && isSizeAvailable(root)) {
+                dir = new File(root, Environment.DIRECTORY_DOWNLOADS);
+                if (!dir.exists()) {
+                    if (!dir.mkdirs()) {
+                        dir = null;
+                    }
+                }
+            }
+            return dir;
+        }
+
+        private boolean isMounted(String state) {
+            return Environment.MEDIA_MOUNTED.equals(state);
+        }
+
+        private boolean isSizeAvailable(File dir) {
+            try {
+                if (dir != null && dir.exists()) {
+                    StatFs statfs = new StatFs(dir.getPath());
+                    // FIXME: full message size or one media size in message ?
+                    // in byte.
+                    return (long) statfs.getBlockSize() * (long) statfs.getAvailableBlocks()
+                            - MmsConfig.getMaxMaxMessageSize() * 1024 > 0;
+                }
+            } catch (Exception ignored) {
+            }
+            return false;
+        }
+
+        @Override
+        protected void onPostExecute(final Void result) {
+            int failCount = 0;
+            int imageCount = 0;
+            int videoCount = 0;
+            int otherCount = 0;
+            for (final AttachmentToSave attachment : mAttachmentsToSave) {
+                /*Modify by SPRD for Bug:536961 {@ */
+                String contentType = attachment.contentType;
+                Log.d(TAG, "lxg saved attachment type : " + contentType
+                        + ", path=" + (attachment.persistedUri != null ? attachment.persistedUri.getPath() : null));
+                if (contentType.equals(ContentType.APP_SMIL))
+                    continue;
+                // add for bug 533699 begin
+                if ((attachment.persistedUri == null)
+                        || (TextUtils.isEmpty(contentType)
+                        || contentType.equals(ContentType.APP_OCT))) {
+                /*@}*/
+                    failCount++;
+                    continue;
+                }
+
+                // Inform MediaScanner about the new file
+                final Intent scanFileIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);
+                scanFileIntent.setData(attachment.persistedUri);
+                mContext.sendBroadcast(scanFileIntent);
+
+                if (ContentType.isImageType(attachment.contentType)) {
+                    imageCount++;
+                } else if (ContentType.isVideoType(attachment.contentType)) {
+                    videoCount++;
+                } else {
+                    otherCount++;
+                    // Inform DownloadManager of the file so it will show in the "downloads" app
+                    final DownloadManager downloadManager =
+                            (DownloadManager) mContext.getSystemService(
+                                    Context.DOWNLOAD_SERVICE);
+                    final String filePath = attachment.persistedUri.getPath();
+                    final File file = new File(filePath);
+
+                    if (file.exists()) {
+                        /*Add by SPRD for Bug:542891  2016.03.24 Start*/
+                        if ((ContentType.TEXT_VCALENDAR).equals(attachment.contentType)
+                                || (ContentType.TEXT_VCARD).equals(attachment.contentType)) {
+                            contentType = contentType.toLowerCase();
+                        }
+                        /*Add by SPRD for Bug:542891  2016.03.24 End*/
+                        downloadManager.addCompletedDownload(
+                                file.getName() /* title */,
+                                mContext.getString(
+                                        R.string.attachment_file_description) /* description */,
+                                true /* isMediaScannerScannable */,
+                                contentType,
+                                file.getAbsolutePath(),
+                                file.length(),
+                                false /* showNotification */);
+                    }
+                }
+            }
+
+            String message = "";
+            if (failCount > 0) {
+                // FIXME: handle filed staus.
+                message = mContext.getResources().getQuantityString(
+                        R.plurals.attachment_save_error, failCount, failCount);
+            } else if (failCount < mAttachmentsToSave.size()) {
+//                int messageId = R.plurals.attachments_saved;
+//                if (otherCount > 0) {
+//                    if (imageCount + videoCount == 0) {
+//                        messageId = R.plurals.attachments_saved_to_downloads;
+//                    }
+//                } else {
+//                    if (videoCount == 0) {
+//                        messageId = R.plurals.photos_saved_to_album;
+//                    } else if (imageCount == 0) {
+//                        messageId = R.plurals.videos_saved_to_album;
+//                    } else {
+//                        messageId = R.plurals.attachments_saved_to_album;
+//                    }
+//                }
+                int messageId = R.plurals.attachments_saved_dir;
+                String dirName = Environment.DIRECTORY_DOWNLOADS;
+                final int count = imageCount + videoCount + otherCount;
+                message = mContext.getResources().getQuantityString(
+                        messageId, count, count, dirName);
+            }
+            if (mWaitDialg != null && mWaitDialg.isShowing()) {
+                mWaitDialg.dismiss();
+            }
+            if (!TextUtils.isEmpty(message)) {
+                UiUtils.showToastAtBottom(message);
+            }
+        }
+    }
+
+    private void invalidateOptionsMenu() {
+        final Activity activity = getActivity();
+        // TODO: Add the supportInvalidateOptionsMenu call to the host activity.
+        if (activity == null || !(activity instanceof BugleActionBarActivity)) {
+            return;
+        }
+        ((BugleActionBarActivity) activity).supportInvalidateOptionsMenu();
+    }
+
+    @Override
+    public void setOptionsMenuVisibility(final boolean visible) {
+        setHasOptionsMenu(visible);
+    }
+
+    // spread: fixe for bug 516158 start
+    @Override
+    public void dimissPaused(boolean pausefromMediaPicker) {
+        mPauseRusume = pausefromMediaPicker;
+    }
+    // spread: fixe for bug 516158 end
+
+    @Override
+    public int getConversationSelfSubId() {
+        final String selfParticipantId = mComposeMessageView.getConversationSelfId();
+        if (mBinding.isBound()) {
+            final ParticipantData self = mBinding.getData().getSelfParticipantById(selfParticipantId);
+            // If the self id or the self participant data hasn't been loaded yet, fallback to
+            // the default setting.
+            return self == null ? ParticipantData.DEFAULT_SELF_SUB_ID : self.getSubId();
+        }
+        return ParticipantData.DEFAULT_SELF_SUB_ID;
+    }
+
+    @Override
+    public void invalidateActionBar() {
+        mHost.invalidateActionBar();
+    }
+
+    @Override
+    public void dismissActionMode() {
+        mHost.dismissActionMode();
+    }
+
+    @Override
+    public void selectSim(final SubscriptionListEntry subscriptionData) {
+        mComposeMessageView.selectSim(subscriptionData);
+        mHost.onStartComposeMessage();
+    }
+
+    @Override
+    public void onStartComposeMessage() {
+        mHost.onStartComposeMessage();
+    }
+
+    @Override
+    public SubscriptionListEntry getSubscriptionEntryForSelfParticipant(
+            final String selfParticipantId, final boolean excludeDefault) {
+        // TODO: ConversationMessageView is the only one using this. We should probably
+        // inject this into the view during binding in the ConversationMessageAdapter.
+        return mBinding.getData().getSubscriptionEntryForSelfParticipant(selfParticipantId,
+                excludeDefault);
+    }
+
+    @Override
+    public SimSelectorView getSimSelectorView() {
+        return (SimSelectorView) getView().findViewById(R.id.sim_selector);
+    }
+
+    @Override
+    public MediaPicker createMediaPicker() {
+        return new MediaPicker(getActivity());
+    }
+
+    @Override
+    public void notifyOfAttachmentLoadFailed() {
+        UiUtils.showToastAtBottom(R.string.attachment_load_failed_dialog_message);
+    }
+
+    @Override
+    public void warnOfExceedingMessageLimit(final boolean sending, final boolean tooManyVideos) {
+        warnOfExceedingMessageLimit(sending, mComposeMessageView, mConversationId,
+                getActivity(), tooManyVideos);
+    }
+
+    public static void warnOfExceedingMessageLimit(final boolean sending,
+                                                   final ComposeMessageView composeMessageView, final String conversationId,
+                                                   final Activity activity, final boolean tooManyVideos) {
+        final AlertDialog.Builder builder =
+                new AlertDialog.Builder(activity)
+                        .setTitle(R.string.mms_attachment_limit_reached);
+
+        if (sending) {
+            if (tooManyVideos) {
+                builder.setMessage(R.string.video_attachment_limit_exceeded_when_sending);
+            } else {
+                builder.setMessage(R.string.attachment_limit_reached_dialog_message_when_sending)
+                        .setNegativeButton(R.string.attachment_limit_reached_send_anyway,
+                                new OnClickListener() {
+                                    @Override
+                                    public void onClick(final DialogInterface dialog,
+                                                        final int which) {
+                                        composeMessageView.sendMessageIgnoreMessageSizeLimit();
+                                    }
+                                });
+            }
+            builder.setPositiveButton(android.R.string.ok, new OnClickListener() {
+                @Override
+                public void onClick(final DialogInterface dialog, final int which) {
+                    showAttachmentChooser(conversationId, activity);
+                }
+            });
+        } else {
+            builder.setMessage(R.string.attachment_limit_reached_dialog_message_when_composing)
+                    .setPositiveButton(android.R.string.ok, null);
+        }
+        builder.show();
+    }
+
+    @Override
+    public void showAttachmentChooser() {
+        showAttachmentChooser(mConversationId, getActivity());
+    }
+
+    public static void showAttachmentChooser(final String conversationId,
+                                             final Activity activity) {
+        UIIntents.get().launchAttachmentChooserActivity(activity,
+                conversationId, REQUEST_CHOOSE_ATTACHMENTS);
+    }
+
+    private void updateActionAndStatusBarColor(final ActionBar actionBar) {
+        final int themeColor = ConversationDrawables.get().getConversationThemeColor();
+        actionBar.setBackgroundDrawable(new ColorDrawable(themeColor));
+        UiUtils.setStatusBarColor(getActivity(), themeColor);
+    }
+
+    public void updateActionBar(final ActionBar actionBar) {
+        if (mComposeMessageView == null || !mComposeMessageView.updateActionBar(actionBar)) {
+            updateActionAndStatusBarColor(actionBar);
+            // We update this regardless of whether or not the action bar is showing so that we
+            // don't get a race when it reappears.
+            actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
+            actionBar.setDisplayHomeAsUpEnabled(true);
+            // Reset the back arrow to its default
+            actionBar.setHomeAsUpIndicator(0);
+            View customView = actionBar.getCustomView();
+            if (customView == null || customView.getId() != R.id.conversation_title_container) {
+                final LayoutInflater inflator = (LayoutInflater)
+                        getActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                customView = inflator.inflate(R.layout.action_bar_conversation_name, null);
+                customView.setOnClickListener(new View.OnClickListener() {
+                    @Override
+                    public void onClick(final View v) {
+                        onBackPressed();
+                    }
+                });
+                actionBar.setCustomView(customView);
+            }
+
+            final TextView conversationNameView =
+                    (TextView) customView.findViewById(R.id.conversation_title);
+            final String conversationName = getConversationName();
+            if (!TextUtils.isEmpty(conversationName)) {
+                // RTL : To format conversation title if it happens to be phone numbers.
+                final BidiFormatter bidiFormatter = BidiFormatter.getInstance();
+                final String formattedName = bidiFormatter.unicodeWrap(
+                        UiUtils.commaEllipsize(
+                                conversationName,
+                                conversationNameView.getPaint(),
+                                conversationNameView.getWidth(),
+                                getString(R.string.plus_one),
+                                getString(R.string.plus_n)).toString(),
+                        TextDirectionHeuristicsCompat.LTR);
+                conversationNameView.setText(formattedName);
+                // In case phone numbers are mixed in the conversation name, we need to vocalize it.
+                final String vocalizedConversationName =
+                        AccessibilityUtil.getVocalizedPhoneNumber(getResources(), conversationName);
+                conversationNameView.setContentDescription(vocalizedConversationName);
+                getActivity().setTitle(conversationName);
+            } else {
+                final String appName = getString(R.string.app_name);
+                conversationNameView.setText(appName);
+                getActivity().setTitle(appName);
+            }
+
+            // When conversation is showing and media picker is not showing, then hide the action
+            // bar only when we are in landscape mode, with IME open.
+            if (mHost.isImeOpen() && UiUtils.isLandscapeMode()) {
+                actionBar.hide();
+            } else {
+                actionBar.show();
+            }
+        }
+    }
+
+    @Override
+    public boolean shouldShowSubjectEditor() {
+        return true;
+    }
+
+    @Override
+    public boolean shouldHideAttachmentsWhenSimSelectorShown() {
+        return false;
+    }
+
+    @Override
+    public void showHideSimSelector(final boolean show) {
+        // no-op for now
+    }
+
+    @Override
+    public int getSimSelectorItemLayoutId() {
+        return R.layout.sim_selector_item_view;
+    }
+
+    @Override
+    public Uri getSelfSendButtonIconUri() {
+        return null;    // use default button icon uri
+    }
+
+    @Override
+    public int overrideCounterColor() {
+        return -1;      // don't override the color
+    }
+
+    @Override
+    public void onAttachmentsChanged(final boolean haveAttachments) {
+        // no-op for now
+    }
+
+    @Override
+    public void onDraftChanged(final DraftMessageData data, final int changeFlags) {
+        Log.d(TAG, "onDraftChanged: mLoadDraftDone = " + mLoadDraftDone);
+        mDraftMessageDataModel.ensureBound(data);
+        // We're specifically only interested in ATTACHMENTS_CHANGED from the widget. Ignore
+        // other changes. When the widget changes an attachment, we need to reload the draft.
+        if (changeFlags ==
+                (DraftMessageData.WIDGET_CHANGED | DraftMessageData.ATTACHMENTS_CHANGED)) {
+            mClearLocalDraft = true;        // force a reload of the draft in onResume
+        }
+        // Add by SPRD for bug 563344
+        //sprd 572931 start
+        GlobleUtil.setDraftMessageData(data);
+        if (mLoadDraftDone) {
+            GlobleUtil.setEditedDraftMessageDate(null, null);
+        }
+        //sprf 572931 end
+    }
+
+    @Override
+    public void onDraftAttachmentLimitReached(final DraftMessageData data) {
+        // no-op for now
+    }
+
+    @Override
+    public void onDraftAttachmentLoadFailed() {
+        // no-op for now
+    }
+
+    @Override
+    public void onDraftAttachmentOverSizeReached(final DraftMessageData data,
+                                                 final MessagePartData attachment) {
+    }
+
+    @Override
+    public int getAttachmentsClearedFlags() {
+        return DraftMessageData.ATTACHMENTS_CHANGED;
+    }
+
+    /* SPRD: modified for bug 503091 begin */
+    public void showAttachmentExceededDialog(int str) {
+        new AlertDialog.Builder(getActivity()).setTitle(R.string.warning)
+                .setMessage(str).setPositiveButton(android.R.string.ok,
+                new OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface arg0, int arg1) {
+                        // DraftMessageData draftMessageData = GlobleUtil.getDraftMessageData();
+                        //long attachmentSize = draftMessageData == null?0:draftMessageData.getAttachmentsFileSize();
+                        //  Log.d("CameraMediaChooser","=======showAttachmentExceededDialog===1=====attachmentSize: "+attachmentSize);
+                        // mComposeMessageView.clearAttachments();
+                        //  Log.d("CameraMediaChooser","=========showAttachmentExceededDialog===2=====attachmentSize: "+attachmentSize);
+                    }
+                }
+        ).show();
+    }
+
+    /* SPRD: modified for bug 503091 end */
+    public void getImportAlertMessage(final MessagePartData attachment) {
+        final Activity activity = getActivity();
+        String msg;
+        if (attachment.isVCalendar()) {
+            msg = activity.getString(R.string.confirm_import_vcalendar);
+        } else {
+            msg = activity.getString(R.string.confirm_save_otherfiles);
+        }
+        AlertDialog.Builder adb = new AlertDialog.Builder(activity);
+        adb.setMessage(msg);
+        adb.setPositiveButton(R.string.confirm_import, new OnClickListener() {
+            @Override
+            public void onClick(DialogInterface arg0, int arg1) {
+                if (attachment.isVCalendar()) {
+                    UIIntents.get().launchVCalendarActivity(activity,
+                            attachment.getContentUri());
+                } else if (!attachment.isMedia()) {
+//                    VdataUtils.saveOtherFile(activity,
+//                            attachment.getContentUri());
+                    // FIXME: drm files cannot be saved? delete it, if possible.
+                    if (ContentType.isDrmType(attachment.getContentType())) {
+                        UiUtils.showToastAtBottom(R.string.drm_can_not_processed);
+                    } else {
+                        if (OsUtil.hasStoragePermission()) {
+                            SaveAttachmentTask saveAttachmentTask = new SaveAttachmentTask(
+                                    getActivity());
+                            saveAttachmentTask.addAttachmentToSave(attachment.getContentUri(),
+                                    attachment.getContentType());
+                            if (saveAttachmentTask.getAttachmentCount() > 0) {
+                                saveAttachmentTask.executeOnThreadPool();
+                            }
+                        } else {
+                            getActivity().requestPermissions(
+                                    new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 0);
+                        }
+                    }
+                }
+            }
+        });
+        adb.setNegativeButton(R.string.cancel_import, null);
+        adb.show();
+    }
+
+    /* Add by SPRD for bug 563344 Start */
+    @Override
+    public void onDraftLoadDone(DraftMessageData data) {
+        /* Add by SPRD for bug 583553 2016.07.27 Start */
+        mLoadDraftDone = true;
+        int newAttachmentCount = data.getAttachments().size();
+        if (mOnAttachmentChosen && mOldAttachmentCount != newAttachmentCount) {
+            mOnAttachmentChosen = false;
+            mOldAttachmentCount = newAttachmentCount;
+            GlobleUtil.setEditedDraftMessageDate(null, null);
+        } else {
+            mOldAttachmentCount = newAttachmentCount;
+        }
+        Log.d(TAG, "onDraftLoadDone: mLoadDraftDone = " + mLoadDraftDone +
+                ", mOldAttachmentCount = " + mOldAttachmentCount);
+        /* Add by SPRD for bug 583553 2016.07.27 End */
+    }
+
+    /* Add by SPRD for bug 563344 End */
+    @Override
+    public void StartSlideshow() {
+        /*Add by SPRD for bug581044  2016.07.31 Start*/
+        if (isEmptyRecipientConversaton()) {
+            UiUtils.showToastAtBottom(R.string.contact_invalid);
+            return;
+        }
+        /*Add by SPRD for bug581044  2016.07.31 End*/
+        /* These things will be done in onPause, so delete these codes here. */
+//        if (mComposeMessageView != null && !mSuppressWriteDraft) {
+//            mComposeMessageView.writeDraftMessage();
+//            mSuppressWriteDraft = false;
+//            mBinding.getData().unsetFocus();
+//            mListState = mRecyclerView.getLayoutManager().onSaveInstanceState();
+//            LocalBroadcastManager.getInstance(getActivity()).unregisterReceiver(mConversationSelfIdChangeReceiver);
+//        }
+        /* Modify by SPRD for bug 585286 2016.08.08 Start */
+//        String convName = getConversationName();
+//        UIIntents.get().launchSmilMainActivity(getActivity(), true,convName);
+//        mHost.dismissActionMode();
+//        mClearLocalDraft = true;
+        if (shouldWarningConvertToSlides()) {
+            warningConvertToSlides();
+        } else {
+            GlobleUtil.setDraftMessageData(mComposeMessageView.getDraftDataModel().getData());
+            GlobleUtil.setEditedDraftMessageDate(null, null);
+            UIIntents.get().launchSmilMainActivity(getActivity(), true, getConversationName());
+            mHost.dismissActionMode();
+            mClearLocalDraft = true;
+        }
+        /* Modify by SPRD for bug 585286 2016.08.08 End */
+    }
+
+    /* Add by SPRD for bug 585286 2016.08.08 Start */
+    private void warningConvertToSlides() {
+        final AlertDialog.Builder builder = new AlertDialog.Builder(getActivity())
+                .setTitle(R.string.mms_convert_to_smil_title).setMessage(R.string.mms_convert_to_smil_message);
+        builder.setPositiveButton(R.string.confirm_convert, new OnClickListener() {
+
+            @Override
+            public void onClick(DialogInterface dialog, int which) {
+                GlobleUtil.setDraftMessageData(mComposeMessageView.getDraftDataModel().getData());
+                GlobleUtil.setEditedDraftMessageDate(null, null);
+                UIIntents.get().launchSmilMainActivity(getActivity(), true, getConversationName());
+                mHost.dismissActionMode();
+                mClearLocalDraft = true;
+            }
+        });
+
+        builder.setNegativeButton(R.string.cancel_convert, new OnClickListener() {
+
+            @Override
+            public void onClick(DialogInterface dialog, int which) {
+                // Do nothing
+            }
+        });
+
+        builder.show();
+    }
+    /* Add by SPRD for bug 585286 2016.08.08 End */
+
+    /* Add by SPRD for bug 579252 2016.08.12 Start */
+    private boolean shouldWarningConvertToSlides() {
+        DraftMessageData draft = mComposeMessageView.getDraftDataModel().getData();
+        if (draft.mProtocol == MessageData.PROTOCOL_MMS_SMIL) return false;
+        if (draft.getAttachments().size() > 1) {
+            return true;
+        } else if (draft.getAttachments().size() == 1) {
+            MessagePartData p = draft.getAttachments().get(0);
+            return !(p.isAudio() || p.isVideo() || p.isImage());
+        }
+        return false;
+    }
+    /* Add by SPRD for bug 579252 2016.08.12 Start */
+
+    private void createSimSelectDialog(final List<String> smsUriList) {
+        final ArrayList<String> simList = new ArrayList<String>();
+        if (!OsUtil.hasPhonePermission()) {
+            OsUtil.requestMissingPermission(getActivity());
+        } else {
+            final List<SubscriptionInfo> infoList = SystemAdapter.getInstance().getActiveSubInfoList();
+            if (infoList != null && infoList.size() != 0) {
+                Iterator iterator = infoList.iterator();
+                while (iterator.hasNext()) {
+                    SubscriptionInfo subscriptionInfo = (SubscriptionInfo) iterator.next();
+                    String simNameText = subscriptionInfo.getDisplayName().toString();
+                    String displayName = TextUtils.isEmpty(simNameText) ? getActivity()
+                            .getString(R.string.sim_slot_identifier,
+                                    subscriptionInfo.getSimSlotIndex() + 1) : simNameText;
+                    simList.add(displayName);
+                }
+            }
+
+            ArrayAdapter<String> simAdapter = new ArrayAdapter<String>(getActivity(),
+                    R.layout.display_options, simList) {
+                @Override
+                public View getView(int position, View convertView, ViewGroup parent) {
+                    View v = super.getView(position, convertView, parent);
+                    String simName = getItem(position);
+                    TextView tv = (TextView) v;
+                    tv.setText(simName);
+                    return v;
+                }
+            };
+
+            DialogInterface.OnClickListener simSelectListener = new DialogInterface.OnClickListener() {
+                @Override
+                public final void onClick(DialogInterface dialog, int which) {
+                    SubscriptionInfo subscriptionInfo = infoList.get(which);
+                    int subId = subscriptionInfo.getSubscriptionId();
+                    UiUtils.startCommonServiceToCopySmsToSim(getContext(), smsUriList, subId);
+                    dialog.dismiss();
+                }
+            };
+            AlertDialog.Builder simSelectDialog = new AlertDialog.Builder(getActivity());
+            simSelectDialog.setTitle(R.string.select_sim);
+            simSelectDialog.setAdapter(simAdapter, simSelectListener);
+            simSelectDialog.setNegativeButton(android.R.string.cancel,
+                    new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            dialog.dismiss();
+                        }
+                    });
+            mSimSelectDialog = simSelectDialog.show();
+        }
+    }
+
+    //add for bug 610115 start
+    private IntentFilter mSimFilter = new IntentFilter(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
+    private BroadcastReceiver mSimInOutReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            Log.d(TAG, "receive sim state changed.");
+            String simStatus = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
+            Log.d(TAG, "sim status is:" + simStatus);
+            if (intent.getAction() == TelephonyIntents.ACTION_SIM_STATE_CHANGED){
+                if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(simStatus)){
+                    if (mSimSelectDialog != null && mSimSelectDialog.isShowing()) {
+                        mSimSelectDialog.dismiss();
+                    }
+                }
+            }
+        }
+    };
+    //add for bug 610115 end
+
+    private IntentFilter mAirPlaneModeFilter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+    private BroadcastReceiver mAirPlaneModeReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            boolean isAirPlaneMode = intent.getBooleanExtra("state", false);
+            Log.d(TAG, "mAirReceiver onReceive()  enable = " + isAirPlaneMode);
+            if (isAirPlaneMode) {
+                if (mSimSelectDialog != null && mSimSelectDialog.isShowing()) {
+                    mSimSelectDialog.dismiss();
+                }
+            }
+        }
+    };
+
+        /* add for SmartMessage start*/
+   private boolean isSmartMessage(){
+        final ConversationData conversationData = mBinding.getData();
+        Log.d(SMART_TAG, "getParticipantsLoaded= " +conversationData.getParticipantsLoaded());
+        Log.d(SMART_TAG, "getParticipantPhoneNumber= " +conversationData.getParticipantPhoneNumber());
+        Log.d(SMART_TAG, "getOtherParticipant()= " +conversationData.getOtherParticipant());
+        if (!conversationData.getParticipantsLoaded()) {
+            return false;
+        }
+        ParticipantData participant = conversationData.getOtherParticipant();
+        if (participant!=null && participant.getProfilePhotoUri()!=null && participant.getProfilePhotoUri().startsWith("http")) {
+            return true;
+        }
+        Log.d(SMART_TAG, " participant.isSmartMessage()=fase ");
+        return false;
+    }
+
+    class LoadServerMenuThread extends Thread {
+        @Override
+        public void run() {
+            final String serverInfoString = SmsPortFetcher.getPortInfo(mContext, mPort);
+            Log.d(SMART_TAG, " ServerMenu onClick: mPort=" + mPort);
+            new Handler(Looper.getMainLooper()).post(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        showServerMenu(serverInfoString);
+                    } catch (Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+            });
+        }
+    }
+
+    private void showServerMenu(String serverInfoString) throws JSONException {
+        Log.d(SMART_TAG, " showServerMenu onClick: serverInfoString" + serverInfoString);
+        JSONObject serverInfo = new JSONObject(serverInfoString);
+        int hasdata = serverInfo.getInt("hasData");
+        Log.d(SMART_TAG, " ServerMenu onClick: hasdata=" + hasdata);
+        mServerMenu.setVisibility((hasdata > 0) ? View.VISIBLE : View.GONE);
+        if (hasdata > 0) {
+            mServerMenu.removeAllViews();
+            JSONArray menus = serverInfo.getJSONArray("menu");
+            int number = menus.length();
+            for (int i = 0; i < menus.length(); i++) {
+                JSONObject menu = menus.getJSONObject(i);
+                final String name = menu.getString("Menuname");
+                final String openType = menu.getString("Opentype");
+                final String openUrl = menu.getString("Openurl");
+                final JSONArray subMenu = menu.getJSONArray("Submenu");
+
+                TextView tv_menu = new TextView(mContext);
+                boolean hasSubMenu = (subMenu != null && subMenu.length() > 0);
+                if (hasSubMenu){
+                   Drawable subMenuIcon =mContext.getDrawable(R.drawable.ic_smart_sms_menu);
+                   subMenuIcon.setBounds(1, 1, 48, 48);
+                   tv_menu.setCompoundDrawables(subMenuIcon, null, null, null);
+                }
+                tv_menu.setText(name);
+                tv_menu.setPadding(5, 5, 5, 5);
+                tv_menu.setTextSize(14);
+                tv_menu.setGravity(Gravity.CENTER);
+
+                LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(-1, -1, 0.3F);
+                mServerMenu.addView(tv_menu, params);
+
+                tv_menu.setOnClickListener(new View.OnClickListener() {
+                    @Override
+                    public void onClick(View view) {
+                        Log.d(SMART_TAG, " ServerMenu onClick: " + openUrl);
+                        if (hasSubMenu) {
+                            LinearLayout contentView = new LinearLayout(mContext);
+                            //contentView.setBackgroundColor(Color.GRAY);
+                            contentView.setOrientation(LinearLayout.VERTICAL);
+	                     contentView.setDividerDrawable(mContext.getDrawable(R.drawable.divider_horizontal));
+                            contentView.setShowDividers(LinearLayout.SHOW_DIVIDER_MIDDLE);
+                            PopupWindow popupWindow = new PopupWindow(contentView);
+                            popupWindow.setWidth(view.getWidth());
+                            popupWindow.setHeight(ViewGroup.LayoutParams.WRAP_CONTENT);
+                            popupWindow.setBackgroundDrawable(mContext.getDrawable(R.drawable.textview_border));//(new ColorDrawable(Color.WHITE));
+                            popupWindow.setFocusable(true);
+                            //add bysprd for  Bug 646992 start
+                            final InputMethodManager inputMethodManager =
+                                    (InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE);
+                            inputMethodManager.hideSoftInputFromWindow(view.getWindowToken(), 0);
+                            //add bysprd for  Bug 646992 end
+                            popupWindow.setOutsideTouchable(true);
+                            for (int i = 0; i < subMenu.length(); i++) {
+                                try {
+                                    JSONObject jo = subMenu.getJSONObject(i);
+                                    final String name = jo.getString("Menuname");
+                                    final String openType = jo.getString("Opentype");
+                                    final String openUrl = jo.getString("Openurl");
+                                    TextView textView = new TextView(mContext);
+                                    textView.setTextSize(14);
+                                    textView.setText(name);
+                                    textView.setHeight(view.getHeight());
+                                    textView.setGravity(Gravity.CENTER);
+                                    textView.setOnClickListener(new View.OnClickListener() {
+                                        @Override
+                                        public void onClick(View view) {
+                                            MenuClickHelper.menuJump(mContext, mPort, name, openType, openUrl);
+                                        }
+                                    });
+                                    contentView.addView(textView);
+                                } catch (JSONException e) {
+                                    e.printStackTrace();
+                                }
+                            }
+                            popupWindow.showAtLocation(view, Gravity.BOTTOM | Gravity.LEFT, view.getLeft(), view.getHeight() + dp2px(5));//20
+                        } else {
+                            MenuClickHelper.menuJump(mContext, mPort, name, openType, openUrl);
+                        }
+                    }
+                });
+            }
+        }
+    }
+
+    private int dp2px(int dp) {
+        return (int) (mContext.getResources().getDisplayMetrics().density * dp + 0.5);
+    }
+    /* add for SmartMessage end*/
+}
Index: vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/ui/conversation/ComposeMessageView.java
===================================================================
--- vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/ui/conversation/ComposeMessageView.java	(revision 0)
+++ vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/ui/conversation/ComposeMessageView.java	(revision 173004)
@@ -0,0 +1,1584 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.messaging.ui.conversation;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.res.Resources;
+import android.graphics.Rect;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.v7.app.ActionBar;
+import android.text.Editable;
+import android.text.Html;
+import android.text.InputFilter;
+import android.text.InputFilter.LengthFilter;
+import android.text.Spanned;  // Add by SPRD for bug 542386
+import android.text.TextUtils;
+import android.text.TextWatcher;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.ContextThemeWrapper;
+import android.view.KeyEvent;
+import android.view.View;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.inputmethod.EditorInfo;
+import android.widget.ImageButton;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+import android.widget.Toast;  // Add by SPRD for bug 542386
+
+import com.android.messaging.Factory;
+import com.android.messaging.R;
+import com.android.messaging.datamodel.binding.Binding;
+import com.android.messaging.datamodel.binding.BindingBase;
+import com.android.messaging.datamodel.binding.ImmutableBindingRef;
+import com.android.messaging.datamodel.data.ConversationData;
+import com.android.messaging.datamodel.data.ConversationData.ConversationDataListener;
+import com.android.messaging.datamodel.data.ConversationData.SimpleConversationDataListener;
+import com.android.messaging.datamodel.data.DraftMessageData;
+import com.android.messaging.datamodel.data.DraftMessageData.CheckDraftForSendTask;
+import com.android.messaging.datamodel.data.DraftMessageData.CheckDraftTaskCallback;
+import com.android.messaging.datamodel.data.DraftMessageData.DraftMessageDataListener;
+import com.android.messaging.datamodel.data.MessageData;
+import com.android.messaging.datamodel.data.MessagePartData;
+import com.android.messaging.datamodel.data.ParticipantData;
+import com.android.messaging.datamodel.data.PendingAttachmentData;
+import com.android.messaging.datamodel.data.SubscriptionListData.SubscriptionListEntry;
+/* Add for bug 563344 {@ */
+import com.android.messaging.datamodel.action.InsertNewMessageAction;
+import com.android.messaging.smil.data.SmilDraftDataManager;
+import com.android.messaging.smil.data.SmilPartEntity;
+import com.android.messaging.smil.ui.SmilMainFragment;
+import com.android.messaging.smil.util.SMIL2PartUtil;
+import com.android.messaging.util.GlobleUtil;
+/* @} */
+import com.android.messaging.sms.MmsConfig;
+import com.android.messaging.ui.AttachmentPreview;
+import com.android.messaging.ui.BugleActionBarActivity;
+import com.android.messaging.ui.PlainTextEditText;
+import com.android.messaging.ui.conversation.ComposeMessageView;
+import com.android.messaging.ui.conversation.ConversationInputManager.ConversationInputSink;
+import com.android.messaging.util.AccessibilityUtil;
+import com.android.messaging.util.Assert;
+import com.android.messaging.util.AvatarUriUtil;
+import com.android.messaging.util.BuglePrefs;
+import com.android.messaging.util.ContentType;
+//Add by SPRD for Bug 549991
+import com.android.messaging.util.GlobleUtil;
+import com.android.messaging.util.LogUtil;
+import com.android.messaging.util.MediaUtil;
+import com.android.messaging.util.OsUtil;
+import com.android.messaging.util.UiUtils;
+import com.android.messaging.util.BuglePrefs;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import com.sprd.messaging.drm.MessagingDrmSession;
+import com.android.messaging.util.PhoneUtils;
+import com.sprd.messaging.util.Utils;
+import android.telephony.SubscriptionInfo;
+import com.android.messaging.datamodel.DatabaseWrapper;
+import com.android.messaging.datamodel.DataModel;
+import com.android.messaging.datamodel.BugleDatabaseOperations;
+import com.sprd.messaging.util.SystemAdapter;
+
+/**
+ * This view contains the UI required to generate and send messages.
+ */
+public class ComposeMessageView extends LinearLayout
+        implements TextView.OnEditorActionListener, DraftMessageDataListener, TextWatcher,
+        ConversationInputSink {
+
+    public interface IComposeMessageViewHost extends
+            DraftMessageData.DraftMessageSubscriptionDataProvider {
+        void sendMessage(MessageData message);
+        void onComposeEditTextFocused();
+        void onAttachmentsCleared();
+        void onAttachmentsChanged(final boolean haveAttachments);
+        void displayPhoto(Uri photoUri, Rect imageBounds, boolean isDraft);
+        void promptForSelfPhoneNumber();
+        boolean isReadyForAction();
+        void warnOfMissingActionConditions(final boolean sending,
+                final Runnable commandToRunAfterActionConditionResolved);
+        void warnOfExceedingMessageLimit(final boolean showAttachmentChooser,
+                boolean tooManyVideos);
+        void notifyOfAttachmentLoadFailed();
+        void showAttachmentChooser();
+        boolean shouldShowSubjectEditor();
+        boolean shouldHideAttachmentsWhenSimSelectorShown();
+        Uri getSelfSendButtonIconUri();
+        int overrideCounterColor();
+        int getAttachmentsClearedFlags();
+        void showAttachmentExceededDialog(int str);
+        // Add for bug 563344
+        void gotoSmilView(DraftMessageData draft);
+        void StartSlideshow();
+        /*Add by SPRD for bug581044  2016.07.08 Start*/
+        boolean isEmptyRecipientConversaton();
+        /*Add by SPRD for bug581044  2016.07.08 End*/
+    }
+
+
+    public static final int CODEPOINTS_REMAINING_BEFORE_COUNTER_SHOWN = 10;
+
+    // There is no draft and there is no need for the SIM selector
+    private static final int SEND_WIDGET_MODE_SELF_AVATAR = 1;
+    // There is no draft but we need to show the SIM selector
+    private static final int SEND_WIDGET_MODE_SIM_SELECTOR = 2;
+    // There is a draft
+    private static final int SEND_WIDGET_MODE_SEND_BUTTON = 3;
+
+    private PlainTextEditText mComposeEditText;
+    private PlainTextEditText mComposeSubjectText;
+    private int selectionStart;
+    private int selectionEnd;
+    private TextView mCharCounter;
+	private TextView mCharCounter1;
+    private TextView mMmsIndicator;
+    private SimIconView mSelfSendIcon;
+    private ImageButton mSendButton;
+	private ImageButton mSelectSIMButton;
+	private ImageButton mSendSMSButton;
+	private LinearLayout mTwoSimLL;
+	private LinearLayout mOneSimLL;
+	private boolean isOne = true;
+    private View mSubjectView;
+    private ImageButton mDeleteSubjectButton;
+    private AttachmentPreview mAttachmentPreview;
+    private ImageButton mAttachMediaButton;
+    /*SPRD: add for Bug 489231--new feature,enable signature text append to a message. begin */
+    private TextView mSignatureIndicator;
+    /*SPRD: add for Bug 489231--new feature,enable signature text append to a message. end */
+
+    private final Binding<DraftMessageData> mBinding;
+    private IComposeMessageViewHost mHost;
+    private final Context mOriginalContext;
+    private int mSendWidgetMode = SEND_WIDGET_MODE_SELF_AVATAR;
+
+    // Shared data model object binding from the conversation.
+    private ImmutableBindingRef<ConversationData> mConversationDataModel;
+
+    // Centrally manages all the mutual exclusive UI components accepting user input, i.e.
+    // media picker, IME keyboard and SIM selector.
+    private ConversationInputManager mInputManager;
+
+    /*SPRD: add for Bug 489231--new feature,enable signature text append to a message. begin */
+    //the signature text
+    private String mSignatureText="";
+    /*SPRD: add for Bug 489231--new feature,enable signature text append to a message. end */
+    /* SPRD: modified for bug 497374 begin */
+    private boolean mUpdateAttachment;
+    /* SPRD: modified for bug 497374 end */
+
+    // Add by SPRD for bug 563344
+    private boolean mEnableTextLengthLimitation = false;
+    private boolean mIsDraftLoadDone = false;
+	String firstSimSelfId;
+	String secondSimSelfId;
+	List<SubscriptionInfo> subIdList; 
+    private final ConversationDataListener mDataListener = new SimpleConversationDataListener() {
+        @Override
+        public void onConversationMetadataUpdated(ConversationData data) {
+            mConversationDataModel.ensureBound(data);
+            updateVisualsOnDraftChanged();
+        }
+
+        @Override
+        public void onConversationParticipantDataLoaded(ConversationData data) {
+            mConversationDataModel.ensureBound(data);
+            updateVisualsOnDraftChanged();
+        }
+
+        @Override
+        public void onSubscriptionListDataLoaded(ConversationData data) {
+            mConversationDataModel.ensureBound(data);
+            updateOnSelfSubscriptionChange();
+            updateVisualsOnDraftChanged();
+        }
+    };
+
+    public ComposeMessageView(final Context context, final AttributeSet attrs) {
+        super(new ContextThemeWrapper(context, R.style.ColorAccentBlueOverrideStyle), attrs);
+        mOriginalContext = context;
+        mBinding = BindingBase.createBinding(this);
+	    subIdList = SystemAdapter.getInstance().getActiveSubInfoList();
+		setSelfId();
+    }
+	
+	
+	 private String getSelfId(int subId){ 
+		DatabaseWrapper db = DataModel.get().getDatabase();
+		final ParticipantData self = ParticipantData.getSelfParticipant(subId); 
+		String selfId; 
+		db.beginTransaction(); 
+		try { 
+			selfId = BugleDatabaseOperations.getOrCreateParticipantInTransaction(db, self); 
+			db.setTransactionSuccessful(); 
+		} finally { 
+			db.endTransaction(); 
+		} 
+		return selfId; 
+    } 
+	
+	private void setSelfId(){
+		if(subIdList != null && subIdList.size() > 1){
+			for (SubscriptionInfo subInfo : subIdList) { 
+				if (subInfo.getSimSlotIndex() == 0) {
+					firstSimSelfId = getSelfId(subInfo.getSubscriptionId());
+				}else{
+					secondSimSelfId = getSelfId(subInfo.getSubscriptionId());
+				}
+			}
+		}
+	}
+	
+	private void setSimCard(boolean isFirstSim){
+		if(isFirstSim){
+			if(firstSimSelfId != null && !firstSimSelfId.equals("")){
+				Assert.notNull(firstSimSelfId);
+				updateConversationSelfId(firstSimSelfId, true);
+			}
+		}else{
+			if(secondSimSelfId != null && !secondSimSelfId.equals("")){
+				Assert.notNull(secondSimSelfId);
+				updateConversationSelfId(secondSimSelfId, true);
+			}
+		}
+	}
+	
+	
+    public void bind(final DraftMessageData data, final IComposeMessageViewHost host) {
+        mHost = host;
+        mBinding.bind(data);
+        data.addListener(this);
+        data.setSubscriptionDataProvider(host);
+
+        final int counterColor = mHost.overrideCounterColor();
+        if (counterColor != -1) {
+            mCharCounter.setTextColor(counterColor);
+        }
+    }
+
+    /**
+     * Host calls this to unbind view
+     */
+    public void unbind() {
+        mBinding.unbind();
+        mHost = null;
+        /*add by sprd for Bug 630177  start*/
+        if (mInputManager!=null) {
+        /*add by sprd for Bug 630177  end*/
+            mInputManager.onDetach();
+        }
+    }
+
+    @Override
+    protected void onFinishInflate() {
+        mComposeEditText = (PlainTextEditText) findViewById(
+                R.id.compose_message_text);
+        mComposeEditText.setOnEditorActionListener(this);
+        mComposeEditText.addTextChangedListener(this);
+        mComposeEditText.setOnFocusChangeListener(new OnFocusChangeListener() {
+            @Override
+            public void onFocusChange(final View v, final boolean hasFocus) {
+                if (v == mComposeEditText && hasFocus) {
+                    mHost.onComposeEditTextFocused();
+                }
+            }
+        });
+        mComposeEditText.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View arg0) {
+                boolean shouldUseSmilView = false;
+                if (null != mBinding.getData()) {
+                shouldUseSmilView = ( (MessageData.PROTOCOL_MMS_SMIL == mBinding.getData().mProtocol) &&
+                        (mBinding.getData().getAttachments().size() > 0) );
+                }
+                if (mHost.shouldHideAttachmentsWhenSimSelectorShown()) {
+                    hideSimSelector();
+                }
+                if (shouldUseSmilView) {
+                    gotoSmilView();
+                }
+            }
+        });
+        mComposeEditText.setOnLongClickListener(new View.OnLongClickListener() {
+            @Override
+            public boolean onLongClick(View v) {
+                boolean shouldUseSmilView = false;
+                if (null != mBinding.getData()) {
+                shouldUseSmilView = ( (MessageData.PROTOCOL_MMS_SMIL == mBinding.getData().mProtocol) &&
+                        (mBinding.getData().getAttachments().size() > 0) );
+                }
+                if (shouldUseSmilView) {
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+        });
+
+        // onFinishInflate() is called before self is loaded from db. We set the default text
+        // limit here, and apply the real limit later in updateOnSelfSubscriptionChange().
+       /*sprd #510380
+        mComposeEditText.setFilters(new InputFilter[] {
+                new LengthFilter(MmsConfig.get(ParticipantData.DEFAULT_SELF_SUB_ID)
+                        .getMaxTextLimit()) });
+      */
+
+        mSelfSendIcon = (SimIconView) findViewById(R.id.self_send_icon);
+        mSelfSendIcon.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                boolean shown = mInputManager.toggleSimSelector(true /* animate */,
+                        getSelfSubscriptionListEntry());
+                hideAttachmentsWhenShowingSims(shown);
+            }
+        });
+        mSelfSendIcon.setOnLongClickListener(new OnLongClickListener() {
+            @Override
+            public boolean onLongClick(final View v) {
+                if (mHost.shouldShowSubjectEditor()) {
+                    showSubjectEditor();
+                } else {
+                    boolean shown = mInputManager.toggleSimSelector(true /* animate */,
+                            getSelfSubscriptionListEntry());
+                    hideAttachmentsWhenShowingSims(shown);
+                }
+                return true;
+            }
+        });
+
+        mComposeSubjectText = (PlainTextEditText) findViewById(
+                R.id.compose_subject_text);
+        // We need the listener to change the avatar to the send button when the user starts
+        // typing a subject without a message.
+        mComposeSubjectText.addTextChangedListener(this);
+        // onFinishInflate() is called before self is loaded from db. We set the default text
+        // limit here, and apply the real limit later in updateOnSelfSubscriptionChange().
+        mComposeSubjectText.setFilters(new InputFilter[] {
+                new BytesLengthFilter(MmsConfig.get(ParticipantData.DEFAULT_SELF_SUB_ID)
+                        .getMaxSubjectLength())});  // Modify by SPRD for bug 542386
+
+        mDeleteSubjectButton = (ImageButton) findViewById(R.id.delete_subject_button);
+        mDeleteSubjectButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(final View clickView) {
+                hideSubjectEditor();
+                mComposeSubjectText.setText(null);
+                mBinding.getData().setMessageSubject(null);
+            }
+        });
+
+        mSubjectView = findViewById(R.id.subject_view);
+		
+		mTwoSimLL = (LinearLayout) findViewById(R.id.ll_two_sim);
+		mOneSimLL = (LinearLayout) findViewById(R.id.ll_one_sim);
+		if(subIdList != null && subIdList.size() > 1){
+			mTwoSimLL.setVisibility(View.VISIBLE);
+			mOneSimLL.setVisibility(View.GONE);
+		}else{
+			mTwoSimLL.setVisibility(View.GONE);
+			mOneSimLL.setVisibility(View.VISIBLE);
+		}
+		mSelectSIMButton = (ImageButton) findViewById(R.id.select_sim_button);
+		mSelectSIMButton.setImageDrawable(getResources().getDrawable(R.drawable.ic_switch_send));
+		mSelectSIMButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(final View clickView) {
+				boolean toFirstSim = false;
+				if(secondSimSelfId != null && !"".equals(secondSimSelfId)){
+					toFirstSim = getConversationSelfId().equals(secondSimSelfId);
+				}
+				
+                setSimCard(toFirstSim);
+				mSendSMSButton.setImageDrawable(getResources().getDrawable(toFirstSim? R.drawable.sim1 : R.drawable.sim2));
+            }
+        });
+		
+		mSendSMSButton = (ImageButton) findViewById(R.id.send_sms_button);
+		mSendSMSButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(final View clickView) {
+                sendMessageIgnoreMessageSizeLimit();
+            }
+        });
+		
+        mSendButton = (ImageButton) findViewById(R.id.send_message_button);
+        mSendButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(final View clickView) {
+                //sendMessageInternal(true /* checkMessageSize */);
+                sendMessageIgnoreMessageSizeLimit();
+            }
+        });
+        mSendButton.setOnLongClickListener(new OnLongClickListener() {
+            @Override
+            public boolean onLongClick(final View arg0) {
+                boolean shown = mInputManager.toggleSimSelector(true /* animate */,
+                        getSelfSubscriptionListEntry());
+                hideAttachmentsWhenShowingSims(shown);
+                if (mHost.shouldShowSubjectEditor()) {
+                    showSubjectEditor();
+                }
+                return true;
+            }
+        });
+        mSendButton.setAccessibilityDelegate(new AccessibilityDelegate() {
+            @Override
+            public void onPopulateAccessibilityEvent(View host, AccessibilityEvent event) {
+                super.onPopulateAccessibilityEvent(host, event);
+                // When the send button is long clicked, we want TalkBack to announce the real
+                // action (select SIM or edit subject), as opposed to "long press send button."
+                if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_LONG_CLICKED) {
+                    event.getText().clear();
+                    event.getText().add(getResources()
+                            .getText(shouldShowSimSelector(mConversationDataModel.getData()) ?
+                            R.string.send_button_long_click_description_with_sim_selector :
+                                R.string.send_button_long_click_description_no_sim_selector));
+                    // Make this an announcement so TalkBack will read our custom message.
+                    event.setEventType(AccessibilityEvent.TYPE_ANNOUNCEMENT);
+                }
+            }
+        });
+
+        mAttachMediaButton =
+                (ImageButton) findViewById(R.id.attach_media_button);
+        mAttachMediaButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(final View clickView) {
+                boolean shouldUseSmilView = false;
+                if (null != mBinding.getData()) {
+                shouldUseSmilView = ( (MessageData.PROTOCOL_MMS_SMIL == mBinding.getData().mProtocol) &&
+                        (mBinding.getData().getAttachments().size() > 0) );
+                }
+                if (shouldUseSmilView) {
+                    gotoSmilView();
+                } else {
+                // Showing the media picker is treated as starting to compose the message.
+                mInputManager.showHideMediaPicker(false /* show */, false /* animate */);
+            }
+            }
+        });
+
+        mAttachmentPreview = (AttachmentPreview) findViewById(R.id.attachment_draft_view);
+        mAttachmentPreview.setComposeMessageView(this);
+
+        mCharCounter = (TextView) findViewById(R.id.char_counter);
+		mCharCounter1 = (TextView) findViewById(R.id.char_counter1);
+        mMmsIndicator = (TextView) findViewById(R.id.mms_indicator);
+
+        /*SPRD: add for Bug 489231--new feature,enable signature text append to a message. begin*/
+        mSignatureIndicator = (TextView) findViewById(R.id.signature_indicator);
+        /*Modify by SPRD for Bug:542982   Start*/
+        if (MmsConfig.getSignatureEnabled()) {
+             final Context context = Factory.get().getApplicationContext();
+             final String prefKey = context.getString(R.string.signature_pref_key);
+             mSignatureText = BuglePrefs.getApplicationPrefs().getString(prefKey, "");
+        }
+
+        if(mSignatureText != null && "".equals(mSignatureText.trim())){
+            mSignatureIndicator.setVisibility(View.GONE);
+        }else{
+            mSignatureIndicator.setVisibility(View.VISIBLE);
+            mSignatureIndicator.setText(mSignatureText);
+        }
+        /*Modify by SPRD for Bug:542982   End*/
+        /*SPRD: add for Bug 489231--new feature,enable signature text append to a message. end */
+    }
+
+    private void hideAttachmentsWhenShowingSims(final boolean simPickerVisible) {
+        if (!mHost.shouldHideAttachmentsWhenSimSelectorShown()) {
+            return;
+        }
+        final boolean haveAttachments = mBinding.getData().hasAttachments();
+        if (simPickerVisible && haveAttachments) {
+            mHost.onAttachmentsChanged(false);
+            mAttachmentPreview.hideAttachmentPreview();
+        } else {
+            mHost.onAttachmentsChanged(haveAttachments);
+            mAttachmentPreview.onAttachmentsChanged(mBinding.getData());
+        }
+    }
+
+    public void setInputManager(final ConversationInputManager inputManager) {
+        mInputManager = inputManager;
+    }
+
+    public void setConversationDataModel(final ImmutableBindingRef<ConversationData> refDataModel) {
+        mConversationDataModel = refDataModel;
+        mConversationDataModel.getData().addConversationDataListener(mDataListener);
+    }
+
+    ImmutableBindingRef<DraftMessageData> getDraftDataModel() {
+        return BindingBase.createBindingReference(mBinding);
+    }
+
+    // returns true if it actually shows the subject editor and false if already showing
+    private boolean showSubjectEditor() {
+        // show the subject editor
+        if (mSubjectView.getVisibility() == View.GONE) {
+            mSubjectView.setVisibility(View.VISIBLE);
+            mSubjectView.requestFocus();
+            return true;
+        }
+        return false;
+    }
+
+    private void hideSubjectEditor() {
+        mSubjectView.setVisibility(View.GONE);
+        mComposeEditText.requestFocus();
+    }
+
+    /**
+     * {@inheritDoc} from TextView.OnEditorActionListener
+     */
+    @Override // TextView.OnEditorActionListener.onEditorAction
+    public boolean onEditorAction(final TextView view, final int actionId, final KeyEvent event) {
+        if (actionId == EditorInfo.IME_ACTION_SEND) {
+            //sendMessageInternal(true /* checkMessageSize */);
+            sendMessageIgnoreMessageSizeLimit();
+            return true;
+        }
+        return false;
+    }
+
+    private void sendMessageInternal(final boolean checkMessageSize) {
+        LogUtil.i(LogUtil.BUGLE_TAG, "UI initiated message sending in conversation " +
+                mBinding.getData().getConversationId());
+        //bug 620043 begin
+        final PhoneUtils phoneUtils = PhoneUtils.get(mHost.getConversationSelfSubId());
+        final int subId=mBinding.getData().getSelfSubId();
+        LogUtil.d("AirplaneSend","mHost.getConversationSelfSubId() = " + mHost.getConversationSelfSubId());
+        if(phoneUtils.isAirplaneModeOn()){
+             if (!Utils.isVowifiSmsEnable(subId)) {
+            Toast.makeText(getContext(),
+                    getContext().getString(R.string.send_message_failure_airplane_mode), Toast.LENGTH_LONG).show();
+            return;
+              }
+          }
+        //bug 620043 end
+        if (mBinding.getData().isCheckingDraft()) {
+            // Don't send message if we are currently checking draft for sending.
+            LogUtil.w(LogUtil.BUGLE_TAG, "Message can't be sent: still checking draft");
+            return;
+        }
+        // Check the host for pre-conditions about any action.
+        if (mHost.isReadyForAction()) {
+            mInputManager.showHideSimSelector(false /* show */, true /* animate */);
+            /* Add by SPRD for bug 563344 Start */
+            if(MessageData.PROTOCOL_MMS_SMIL == mBinding.getData().mProtocol) {
+                Log.d("ComposeMessageView", "sendMessageInternal: message protocol is PROTOCOL_MMS_SMIL");
+                /*Add by SPRD for bug581044  2016.07.31 Start*/
+                if(MmsConfig.get(ParticipantData.DEFAULT_SELF_SUB_ID).getContentEditEnabled()){
+                    boolean isEmpty = mHost.isEmptyRecipientConversaton();
+                    LogUtil.w(LogUtil.BUGLE_TAG, "sendMessageInternal1  isEmpty:" + isEmpty);
+                    if(isEmpty){
+                         UiUtils.showToastAtBottom(R.string.invalid_destination);
+                         return;
+                    }
+                }
+                /*Add by SPRD for bug581044  2016.07.31 End*/
+                List<SmilPartEntity> smilPartEntities;
+                final DraftMessageData draftMessage = mBinding.getData();
+                draftMessage.setMessageSubject(mComposeSubjectText.getText().toString());
+                // FIXME The better way is do this asynchronously.
+                // And this maybe should be encapsulated into a method
+                smilPartEntities = SMIL2PartUtil.convertToSmilPart(draftMessage);
+                SMIL2PartUtil.clearData();
+                if (smilPartEntities == null) {
+                    Log.e("ComposeMessageView", "sendMessageInternal: failed to convert draft to SmilPart");
+                    return;
+                }
+                SmilDraftDataManager.updateDraftMessageDataForSmil(getContext(), smilPartEntities, draftMessage);
+                MessageData message = SmilDraftDataManager.getMessageData(getContext(), draftMessage, smilPartEntities);
+                draftMessage.clearLocalDraftBeforeSending();
+                mHost.sendMessage(message);
+                hideSubjectEditor();
+                GlobleUtil.setEditedDraftMessageDate(null,null);
+                GlobleUtil.setDraftMessageData(null);
+                return;
+            }
+
+            /* Add by SPRD for bug 563344 End */
+            /*SPRD: add for Bug 489231--new feature,enable signature text append to a message. begin */
+            String prefixSignature;
+            if (MmsConfig.getSignatureEnabled() && (mSignatureText != null && !("".equals(mSignatureText.trim())))) {
+                prefixSignature = "--" + mSignatureText;
+            } else {
+                prefixSignature = "";
+            }
+            mBinding.getData().setSending(true);
+            final String messageToSend = mComposeEditText.getText().toString() + prefixSignature;
+            /*SPRD: add for Bug 489231--new feature,enable signature text append to a message. end */
+            mBinding.getData().setMessageText(messageToSend);
+            final String subject = mComposeSubjectText.getText().toString();
+            mBinding.getData().setMessageSubject(subject);
+            // Asynchronously check the draft against various requirements before sending.
+            mBinding.getData().checkDraftForAction(checkMessageSize,
+                    mHost.getConversationSelfSubId(), new CheckDraftTaskCallback() {
+                @Override
+                public void onDraftChecked(DraftMessageData data, int result) {
+                    mBinding.ensureBound(data);
+                    switch (result) {
+                        case CheckDraftForSendTask.RESULT_PASSED:
+                            // Continue sending after check succeeded.
+                            /*Add by SPRD for bug581044  2016.07.08 Start*/
+                            if(MmsConfig.get(ParticipantData.DEFAULT_SELF_SUB_ID).getContentEditEnabled()){
+                                boolean isEmpty = mHost.isEmptyRecipientConversaton();
+                                LogUtil.w(LogUtil.BUGLE_TAG, "sendMessageInternal  isEmpty:" + isEmpty);
+                                if(isEmpty){
+                                    UiUtils.showToastAtBottom(R.string.invalid_destination);
+                                    return;
+                                }
+                            }
+                            /*Add by SPRD for bug581044  2016.07.08 End*/
+                            final MessageData message = mBinding.getData()
+                                    .prepareMessageForSending(mBinding);
+                            //spread: function for sending empty msg start
+                            if(message.getIsMms()){
+                                if (message != null && message.hasContent()) {
+                                    playSentSound();
+                                    mHost.sendMessage(message);
+                                    hideSubjectEditor();
+                                    if (AccessibilityUtil.isTouchExplorationEnabled(getContext())) {
+                                        AccessibilityUtil.announceForAccessibilityCompat(
+                                                ComposeMessageView.this, null,
+                                                R.string.sending_message);
+                                    }
+                                }
+                            }else{
+                                if(TextUtils.getTrimmedLength(message.getMessageText()) == 0){
+                                    if((MmsConfig.get(mHost.getConversationSelfSubId()).getFinalSendEmptyMessageFlag() == 1)
+                                            || (MmsConfig.get(mHost.getConversationSelfSubId()).getFinalSendEmptyMessageFlag() == 0 && message.getMessageText().length() > 0)) {
+                                           confirmSendEmptyMsg(message);
+                                    }else{
+                                        if (message != null && message.hasContent()) {
+                                            playSentSound();
+                                            mHost.sendMessage(message);
+                                            hideSubjectEditor();
+                                            if (AccessibilityUtil.isTouchExplorationEnabled(getContext())) {
+                                                AccessibilityUtil.announceForAccessibilityCompat(
+                                                        ComposeMessageView.this, null,
+                                                        R.string.sending_message);
+                                            }
+                                        }
+                                    }
+                                }else{
+                                    if (message != null && message.hasContent()) {
+                                        playSentSound();
+                                        mHost.sendMessage(message);
+                                        hideSubjectEditor();
+                                        if (AccessibilityUtil.isTouchExplorationEnabled(getContext())) {
+                                            AccessibilityUtil.announceForAccessibilityCompat(
+                                                    ComposeMessageView.this, null,
+                                                    R.string.sending_message);
+                                        }
+                                    }
+                                }
+                            }
+                            //spread: function for sending empty msg end
+                            break;
+
+                        case CheckDraftForSendTask.RESULT_HAS_PENDING_ATTACHMENTS:
+                            // Cannot send while there's still attachment(s) being loaded.
+                            UiUtils.showToastAtBottom(
+                                    R.string.cant_send_message_while_loading_attachments);
+                            break;
+
+                        case CheckDraftForSendTask.RESULT_NO_SELF_PHONE_NUMBER_IN_GROUP_MMS:
+                            mHost.promptForSelfPhoneNumber();
+                            break;
+
+                        case CheckDraftForSendTask.RESULT_MESSAGE_OVER_LIMIT:
+                            Assert.isTrue(checkMessageSize);
+                            mHost.warnOfExceedingMessageLimit(
+                                    true /*sending*/, false /* tooManyVideos */);
+                            break;
+
+                        case CheckDraftForSendTask.RESULT_VIDEO_ATTACHMENT_LIMIT_EXCEEDED:
+                            Assert.isTrue(checkMessageSize);
+                            mHost.warnOfExceedingMessageLimit(
+                                    true /*sending*/, true /* tooManyVideos */);
+                            break;
+
+                        case CheckDraftForSendTask.RESULT_SIM_NOT_READY:
+                            // Cannot send if there is no active subscription
+                            UiUtils.showToastAtBottom(
+                                    R.string.cant_send_message_without_active_subscription);
+                            break;
+                        case CheckDraftForSendTask.RESULT_PARTICIPANT_LIMIT_EXCEEDED:
+                            UiUtils.showExceedRecipientLimitDialog(getContext(),
+                                    MmsConfig.get(mBinding.getData().getSelfSubId()).getRecipientLimit(),
+                                    mBinding.getData().getParticipantCount());
+                            break;
+                        default:
+                            break;
+                    }
+                }
+            }, mBinding);
+        } else {
+            mHost.warnOfMissingActionConditions(true /*sending*/,
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            //sendMessageInternal(checkMessageSize);
+                            sendMessageIgnoreMessageSizeLimit();
+                        }
+
+            });
+        }
+    }
+
+    //spread : add for new function send empty msg begin
+    private void confirmSendEmptyMsg(final MessageData message){
+          //  set flag else return  606
+           AlertDialog.Builder builder = new AlertDialog.Builder(mOriginalContext);
+           builder.setTitle(R.string.empty_msg);
+           builder.setMessage(R.string.send_empty_msg);
+           builder.setPositiveButton(R.string.yes, new DialogInterface.OnClickListener() {
+
+             @Override
+             public void onClick(DialogInterface dialog, int which) {
+                     dialog.dismiss();
+                     // sprd 572208  begin
+                     playSentSound();
+                     mHost.sendMessage(message);
+                     hideSubjectEditor();
+                     if (AccessibilityUtil.isTouchExplorationEnabled(getContext())) {
+                         AccessibilityUtil.announceForAccessibilityCompat(
+                                 ComposeMessageView.this, null,
+                                 R.string.sending_message);
+                     }
+
+             }
+             // sprd 572208  end
+           });
+           builder.setNegativeButton(R.string.no, new DialogInterface.OnClickListener() {
+
+             @Override
+              public void onClick(DialogInterface dialog, int which) {
+                 dialog.dismiss();
+                 return;
+             }
+           });
+           builder.show();
+    }
+    // spread : add for new function send empty msg end
+
+    public static void playSentSound() {
+        // Check if this setting is enabled before playing
+        final BuglePrefs prefs = BuglePrefs.getApplicationPrefs();
+        final Context context = Factory.get().getApplicationContext();
+        final String prefKey = context.getString(R.string.send_sound_pref_key);
+        final boolean defaultValue = context.getResources().getBoolean(
+                R.bool.send_sound_pref_default);
+        if (!prefs.getBoolean(prefKey, defaultValue)) {
+            return;
+        }
+        MediaUtil.get().playSound(context, R.raw.message_sent, null /* completionListener */);
+    }
+
+    /**
+     * {@inheritDoc} from DraftMessageDataListener
+     */
+    @Override // From DraftMessageDataListener
+    public void onDraftChanged(final DraftMessageData data, final int changeFlags) {
+        // As this is called asynchronously when message read check bound before updating text
+        mBinding.ensureBound(data);
+        // Add by SPRD for bug 563344
+        final boolean shouldUseSmilView = ( (MessageData.PROTOCOL_MMS_SMIL == data.mProtocol) &&
+                                            (data.getAttachments().size() > 0) );
+
+        // We have to cache the values of the DraftMessageData because when we set
+        // mComposeEditText, its onTextChanged calls updateVisualsOnDraftChanged,
+        // which immediately reloads the text from the subject and message fields and replaces
+        // what's in the DraftMessageData.
+
+        final String subject = data.getMessageSubject();
+//        final String message = data.getMessageText();
+        /* Add by SPRD for bug 563344 Start */
+        final String message;
+        if (!shouldUseSmilView) {
+            message = data.getMessageText();
+            //mComposeEditText.setEnabled(true);
+            //mAttachMediaButton.setEnabled(true);
+            mComposeEditText.setFocusable(true);
+            mComposeEditText.setFocusableInTouchMode(true);
+        } else {
+            message = "";
+            //mComposeEditText.setEnabled(false);
+            //mAttachMediaButton.setEnabled(false);
+            mComposeEditText.setFocusable(false);
+        }
+        /* Add by SPRD for bug 563344 End */
+
+        if ((changeFlags & DraftMessageData.MESSAGE_SUBJECT_CHANGED) ==
+                DraftMessageData.MESSAGE_SUBJECT_CHANGED) {
+            mComposeSubjectText.setText(subject);
+
+            // Set the cursor selection to the end since setText resets it to the start
+            mComposeSubjectText.setSelection(mComposeSubjectText.getText().length());
+        }
+
+        if ((changeFlags & DraftMessageData.MESSAGE_TEXT_CHANGED) ==
+                DraftMessageData.MESSAGE_TEXT_CHANGED) {
+            mComposeEditText.setText(message);
+
+            // Set the cursor selection to the end since setText resets it to the start
+            mComposeEditText.setSelection(mComposeEditText.getText().length());
+        }
+
+        if ((changeFlags & DraftMessageData.ATTACHMENTS_CHANGED) ==
+                DraftMessageData.ATTACHMENTS_CHANGED) {
+            /* Add for bug 590159 Start */
+            if (MessageData.PROTOCOL_MMS_SMIL == data.mProtocol && mIsDraftLoadDone && data.getAttachments().size() <= 2) {
+                for(Iterator<MessagePartData> i = data.getAttachments().iterator(); i.hasNext();) {
+                    if (ContentType.APP_SMIL.equals(i.next().getContentType())) {
+                        i.remove();
+                        break;
+                    }
+                }
+                data.mProtocol = MessageData.PROTOCOL_UNKNOWN;
+            }
+            /* Add for bug 590159 End */
+            final boolean haveAttachments = mAttachmentPreview.onAttachmentsChanged(data);
+            mHost.onAttachmentsChanged(haveAttachments);
+        }
+
+        if ((changeFlags & DraftMessageData.SELF_CHANGED) == DraftMessageData.SELF_CHANGED) {
+            updateOnSelfSubscriptionChange();
+        }
+        updateVisualsOnDraftChanged();
+        /* Add by SPRD for Bug 549991 Start */
+        GlobleUtil.setDraftMessageData(data);
+        /* Add by SPRD for Bug 549991 end */
+    }
+
+    @Override   // From DraftMessageDataListener
+    public void onDraftAttachmentLimitReached(final DraftMessageData data) {
+        mBinding.ensureBound(data);
+        mHost.warnOfExceedingMessageLimit(false /* sending */, false /* tooManyVideos */);
+    }
+
+    private void updateOnSelfSubscriptionChange() {
+        // Refresh the length filters according to the selected self's MmsConfig.
+       /*sprd 510380
+        mComposeEditText.setFilters(new InputFilter[] {
+                new LengthFilter(MmsConfig.get(mBinding.getData().getSelfSubId())
+                        .getMaxTextLimit()) });
+       */
+        mComposeSubjectText.setFilters(new InputFilter[] {
+                new BytesLengthFilter(MmsConfig.get(mBinding.getData().getSelfSubId())
+                        .getMaxSubjectLength())});  // Modify by SPRD for bug 542386
+    }
+
+    /* Add by SPRD for bug 542386 Start */
+    private static class BytesLengthFilter implements InputFilter{
+        private final int mMax;
+
+        public BytesLengthFilter(int max) {
+            mMax = max;
+        }
+        @Override
+        public CharSequence filter(CharSequence source, int start, int end, Spanned dest,
+                int dstart, int dend) {
+            int sourceSubBytes = source.subSequence(start, end).toString().getBytes().length;
+            int destSubBytes = dest.subSequence(dstart, dend).toString().getBytes().length;
+            int originalBytes = dest.toString().getBytes().length;
+            int bytesKeep = mMax - (originalBytes - destSubBytes);
+
+            if (bytesKeep <= 0) {
+                Toast.makeText(Factory.get().getApplicationContext(),
+                        R.string.exceed_text_length_limitation, Toast.LENGTH_SHORT).show();
+                return "";
+            } else if (bytesKeep >= sourceSubBytes) {
+                return null; // keep original
+            } else {
+                int endIndex = 1;
+                // Search for the longest sub-sequence that under the limitation
+                while (bytesKeep >= source.subSequence(start, endIndex).toString().getBytes().length) {
+                    endIndex++;
+                }
+                endIndex--;
+                if (endIndex == start) {
+                    Toast.makeText(Factory.get().getApplicationContext(),
+                            R.string.exceed_text_length_limitation, Toast.LENGTH_SHORT).show();
+                    return "";
+                }
+                return source.subSequence(start, endIndex);
+            }
+        }
+
+        /**
+         * @return the maximum length enforced by this input filter
+         */
+        public int getMax() {
+            return mMax;
+        }
+    }
+    /* Add by SPRD for bug 542386 End */
+
+    @Override
+    public void onMediaItemsSelected(final Collection<MessagePartData> items) {
+        mBinding.getData().addAttachments(items);
+        announceMediaItemState(true /* isSelected */);
+    }
+
+    @Override
+    public void onMediaItemsUnselected(final MessagePartData item) {
+        mBinding.getData().removeAttachment(item);
+        announceMediaItemState(false /*isSelected*/);
+    }
+    @Override
+    public void onTextContactsAdded(final String string) {
+        Log.d("wenbo","CompoeMessageView  onTextContactsAdded");
+        mComposeEditText.requestFocus();
+        mComposeEditText.append(string);
+        mComposeEditText.setSelection(mComposeEditText.getText().length());
+    }
+    @Override
+    public void onPendingAttachmentAdded(final PendingAttachmentData pendingItem) {
+        try{
+            mBinding.getData().addPendingAttachment(pendingItem, mBinding);
+            resumeComposeMessage();
+        }catch (Exception ex){
+            Log.d("CompoeMessageView","addPendingAttachment Exception");
+        }
+    }
+    @Override
+    public void StartSlideshow() {
+        mHost.StartSlideshow();
+    }
+
+    private void announceMediaItemState(final boolean isSelected) {
+        final Resources res = getContext().getResources();
+        final String announcement = isSelected ? res.getString(
+                R.string.mediapicker_gallery_item_selected_content_description) :
+                    res.getString(R.string.mediapicker_gallery_item_unselected_content_description);
+        AccessibilityUtil.announceForAccessibilityCompat(
+                this, null, announcement);
+    }
+
+    private void announceAttachmentState() {
+        if (AccessibilityUtil.isTouchExplorationEnabled(getContext())) {
+            int attachmentCount = mBinding.getData().getReadOnlyAttachments().size()
+                    + mBinding.getData().getReadOnlyPendingAttachments().size();
+            final String announcement = getContext().getResources().getQuantityString(
+                    R.plurals.attachment_changed_accessibility_announcement,
+                    attachmentCount, attachmentCount);
+            AccessibilityUtil.announceForAccessibilityCompat(
+                    this, null, announcement);
+        }
+    }
+
+    @Override
+    public void resumeComposeMessage() {
+        mComposeEditText.requestFocus();
+        mInputManager.showHideImeKeyboard(true, true);
+        announceAttachmentState();
+    }
+
+    public void clearAttachments() {
+        mBinding.getData().clearAttachments(mHost.getAttachmentsClearedFlags());
+        mHost.onAttachmentsCleared();
+    }
+
+    public void requestDraftMessage(boolean clearLocalDraft) {
+        /* Add by SPRD for bug 576767 Start */
+        if (clearLocalDraft) {
+            mComposeSubjectText.setText("");
+            hideSubjectEditor();
+            mComposeEditText.setText("");   // Add for bug 581658
+        }
+        /* Add by SPRD for bug 576767 End */
+        mBinding.getData().loadFromStorage(mBinding, null, clearLocalDraft);
+        /* SPRD: modified for bug 497374 begin */
+        if (mUpdateAttachment) {
+            mBinding.getData().updateAttachmentsData();
+        }
+        mUpdateAttachment=false;
+        /* SPRD: modified for bug 497374 end */
+    }
+
+    public void setDraftMessage(final MessageData message) {
+        mBinding.getData().loadFromStorage(mBinding, message, false);
+    }
+
+    public void writeDraftMessage() {
+        final String messageText = mComposeEditText.getText().toString();
+        mBinding.getData().setMessageText(messageText);
+
+        final String subject = mComposeSubjectText.getText().toString();
+        mBinding.getData().setMessageSubject(subject);
+
+        mBinding.getData().saveToStorage(mBinding);
+        /* SPRD: modified for bug 497374 begin */
+        mUpdateAttachment = true;
+        /* SPRD: modified for bug 497374 end */
+    }
+
+    /*Add by SPRD for bug581044  2016.07.08 Start*/
+    public MessageData getKeepingMessageData(){
+        final String messageText = mComposeEditText.getText().toString();
+        mBinding.getData().setMessageText(messageText);
+        final String subject = mComposeSubjectText.getText().toString();
+        Log.d("","getKeepingMessageData subject: " + subject + " messageText:" + messageText);
+        mBinding.getData().setMessageSubject(subject);
+        return mBinding.getData().getMessageData();
+    }
+    /*Add by SPRD for bug581044  2016.07.08 End*/
+
+    private void updateConversationSelfId(final String selfId, final boolean notify) {
+        mBinding.getData().setSelfId(selfId, notify);
+    }
+
+    private Uri getSelfSendButtonIconUri() {
+        final Uri overridenSelfUri = mHost.getSelfSendButtonIconUri();
+        if (overridenSelfUri != null) {
+            return overridenSelfUri;
+        }
+        final SubscriptionListEntry subscriptionListEntry = getSelfSubscriptionListEntry();
+
+        if (subscriptionListEntry != null) {
+            return subscriptionListEntry.selectedIconUri;
+        }
+
+        // Fall back to default self-avatar in the base case.
+        final ParticipantData self = mConversationDataModel.getData().getDefaultSelfParticipant();
+        return self == null ? null : AvatarUriUtil.createAvatarUri(self);
+    }
+
+    private SubscriptionListEntry getSelfSubscriptionListEntry() {
+        if (mBinding.isBound()) {
+            return mConversationDataModel.getData().getSubscriptionEntryForSelfParticipant(
+                    mBinding.getData().getSelfId(), false /* excludeDefault */);
+        } else {
+            return null;
+        }
+    }
+
+    private boolean isDataLoadedForMessageSend() {
+        // Check data loading prerequisites for sending a message.
+        return mConversationDataModel != null && mConversationDataModel.isBound() &&
+                mConversationDataModel.getData().getParticipantsLoaded();
+    }
+
+    private void updateVisualsOnDraftChanged() {
+        final String messageText = mComposeEditText.getText().toString();
+        final DraftMessageData draftMessageData = mBinding.getData();
+        if(!draftMessageData.isSending())
+        draftMessageData.setMessageText(messageText);
+
+        final String subject = mComposeSubjectText.getText().toString();
+        draftMessageData.setMessageSubject(subject);
+        if (!TextUtils.isEmpty(subject)) {
+             mSubjectView.setVisibility(View.VISIBLE);
+        }
+
+        // spread :add for new function for send empty msg start
+        final boolean hasMessageText ;
+        //sprd 572208 start
+        if (MmsConfig.get(mHost.getConversationSelfSubId()).getFinalSendEmptyMessageFlag() == 0) {        //only send sms with space message body
+            if (messageText != null && messageText.length() > 0) {
+                hasMessageText = true;
+            } else {  //if message body don't include any char(eg. space), can't send it
+                hasMessageText = false;     // if you want to send sms which message body don't include any char(eg. space), set this line to hasMessageText = true
+            }
+        } else if((MmsConfig.get(mHost.getConversationSelfSubId()).getFinalSendEmptyMessageFlag() == 1)
+                || (MmsConfig.get(mHost.getConversationSelfSubId()).getFinalSendEmptyMessageFlag() == 2)){
+            hasMessageText = true;
+            //sprd 572208 end
+        } else {
+            hasMessageText = (TextUtils.getTrimmedLength(messageText) > 0);
+        }
+        // spread :add for new function for send empty msg end
+
+        final boolean hasSubject = (TextUtils.getTrimmedLength(subject) > 0);
+        final boolean hasWorkingDraft = hasMessageText || hasSubject ||
+                mBinding.getData().hasAttachments();
+
+        // Update the SMS text counter.
+        final int messageCount = draftMessageData.getNumMessagesToBeSent();
+        final int codePointsRemaining = draftMessageData.getCodePointsRemainingInCurrentMessage();
+        // Show the counter only if:
+        // - We are not in MMS mode
+        // - We are going to send more than one message OR we are getting close
+        boolean showCounter = false;
+        /*Modify by SPRD for Bug:562207 Start*/
+        if (!draftMessageData.getIsMms() && !"".equals(messageText)/* && (messageCount > 1 ||
+                 codePointsRemaining <= CODEPOINTS_REMAINING_BEFORE_COUNTER_SHOWN)*/) {
+        /*Modify by SPRD for Bug:562207 End*/
+            showCounter = true;
+        }
+
+        /*SPRD: add for Bug 489231--new feature,enable signature text append to a message. begin */
+        if (MmsConfig.getSignatureEnabled() && (mSignatureText != null && !("".equals(mSignatureText.trim())))) {
+            mSignatureIndicator.setVisibility(View.VISIBLE);
+            mSignatureIndicator.setText(mSignatureText);
+        } else {
+            mSignatureIndicator.setVisibility(View.GONE);
+        }
+        /*SPRD: add for Bug 489231--new feature,enable signature text append to a message. end */
+        if (showCounter) {
+            // Update the remaining characters and number of messages required.
+            final String counterText = messageCount > 1 ? codePointsRemaining + " / " +
+                    messageCount : String.valueOf(codePointsRemaining);
+           if(subIdList != null && subIdList.size() > 1){
+				mCharCounter1.setText(counterText);
+				mCharCounter1.setVisibility(View.VISIBLE);
+			}else{
+				mCharCounter.setText(counterText);
+				mCharCounter.setVisibility(View.VISIBLE);
+			}
+        } else {
+            mCharCounter.setVisibility(View.INVISIBLE);
+			mCharCounter1.setVisibility(View.INVISIBLE);
+        }
+
+        // Update the send message button. Self icon uri might be null if self participant data
+        // and/or conversation metadata hasn't been loaded by the host.
+        final Uri selfSendButtonUri = getSelfSendButtonIconUri();
+        int sendWidgetMode = SEND_WIDGET_MODE_SELF_AVATAR;
+        if (selfSendButtonUri != null) {
+            if (hasWorkingDraft && isDataLoadedForMessageSend()) {
+                UiUtils.revealOrHideViewWithAnimation(mSendButton, VISIBLE, null);
+                if (isOverriddenAvatarAGroup()) {
+                    // If the host has overriden the avatar to show a group avatar where the
+                    // send button sits, we have to hide the group avatar because it can be larger
+                    // than the send button and pieces of the avatar will stick out from behind
+                    // the send button.
+                    UiUtils.revealOrHideViewWithAnimation(mSelfSendIcon, GONE, null);
+                }
+                mMmsIndicator.setVisibility(draftMessageData.getIsMms() ? VISIBLE : INVISIBLE);
+                sendWidgetMode = SEND_WIDGET_MODE_SEND_BUTTON;
+            } else {
+                mSelfSendIcon.setImageResourceUri(selfSendButtonUri);
+                if (isOverriddenAvatarAGroup()) {
+                    UiUtils.revealOrHideViewWithAnimation(mSelfSendIcon, VISIBLE, null);
+                }
+                UiUtils.revealOrHideViewWithAnimation(mSendButton, GONE, null);
+                mMmsIndicator.setVisibility(INVISIBLE);
+                if (shouldShowSimSelector(mConversationDataModel.getData())) {
+                    sendWidgetMode = SEND_WIDGET_MODE_SIM_SELECTOR;
+                }
+            }
+        } else {
+            mSelfSendIcon.setImageResourceUri(null);
+        }
+
+        if (mSendWidgetMode != sendWidgetMode || sendWidgetMode == SEND_WIDGET_MODE_SIM_SELECTOR) {
+            setSendButtonAccessibility(sendWidgetMode);
+            mSendWidgetMode = sendWidgetMode;
+        }
+
+        if (MessageData.PROTOCOL_MMS_SMIL == draftMessageData.mProtocol) {
+            mComposeEditText.setHint(R.string.smil_edit_hint);
+            return;
+        }
+        // Update the text hint on the message box depending on the attachment type.
+        final List<MessagePartData> attachments = draftMessageData.getReadOnlyAttachments();
+        final int attachmentCount = attachments.size();
+        if (attachmentCount == 0) {
+            final SubscriptionListEntry subscriptionListEntry =
+                    mConversationDataModel.getData().getSubscriptionEntryForSelfParticipant(
+                            mBinding.getData().getSelfId(), false /* excludeDefault */);
+            if (subscriptionListEntry == null) {
+                mComposeEditText.setHint(R.string.compose_message_view_hint_text);
+            } else {
+                mComposeEditText.setHint(R.string.compose_message_view_hint_text);
+				if(subscriptionListEntry.simSlotId == 2){
+					mSendSMSButton.setImageDrawable(getResources().getDrawable(R.drawable.sim2));
+				}else{
+					mSendSMSButton.setImageDrawable(getResources().getDrawable(R.drawable.sim1));
+				}
+            }
+        } else {
+            int type = -1;
+            for (final MessagePartData attachment : attachments) {
+                int newType;
+                if (attachment.isImage()) {
+                    newType = ContentType.TYPE_IMAGE;
+                } else if (attachment.isAudio()) {
+                    newType = ContentType.TYPE_AUDIO;
+                } else if (attachment.isVideo()) {
+                    newType = ContentType.TYPE_VIDEO;
+                } else if (attachment.isVCard()) {
+                    newType = ContentType.TYPE_VCARD;
+                } else {
+                    newType = ContentType.TYPE_OTHER;
+                }
+
+                if (type == -1) {
+                    type = newType;
+                } else if (type != newType || type == ContentType.TYPE_OTHER) {
+                    type = ContentType.TYPE_OTHER;
+                    break;
+                }
+            }
+
+            switch (type) {
+                case ContentType.TYPE_IMAGE:
+                    mComposeEditText.setHint(getResources().getQuantityString(
+                            R.plurals.compose_message_view_hint_text_photo, attachmentCount));
+                    break;
+
+                case ContentType.TYPE_AUDIO:
+                    mComposeEditText.setHint(getResources().getQuantityString(
+                            R.plurals.compose_message_view_hint_text_audio, attachmentCount));
+                    break;
+
+                case ContentType.TYPE_VIDEO:
+                    mComposeEditText.setHint(getResources().getQuantityString(
+                            R.plurals.compose_message_view_hint_text_video, attachmentCount));
+                    break;
+
+                case ContentType.TYPE_VCARD:
+                    mComposeEditText.setHint(getResources().getQuantityString(
+                            R.plurals.compose_message_view_hint_text_vcard, attachmentCount));
+                    break;
+
+                case ContentType.TYPE_OTHER:
+                    mComposeEditText.setHint(getResources().getQuantityString(
+                            R.plurals.compose_message_view_hint_text_attachments, attachmentCount));
+                    break;
+
+                default:
+                    Assert.fail("Unsupported attachment type!");
+                    break;
+            }
+        }
+    }
+
+    private void setSendButtonAccessibility(final int sendWidgetMode) {
+        switch (sendWidgetMode) {
+            case SEND_WIDGET_MODE_SELF_AVATAR:
+                // No send button and no SIM selector; the self send button is no longer
+                // important for accessibility.
+                mSelfSendIcon.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_NO);
+                mSelfSendIcon.setContentDescription(null);
+                mSendButton.setVisibility(View.GONE);
+                setSendWidgetAccessibilityTraversalOrder(SEND_WIDGET_MODE_SELF_AVATAR);
+                break;
+
+            case SEND_WIDGET_MODE_SIM_SELECTOR:
+                mSelfSendIcon.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
+                mSelfSendIcon.setContentDescription(getSimContentDescription());
+                setSendWidgetAccessibilityTraversalOrder(SEND_WIDGET_MODE_SIM_SELECTOR);
+                break;
+
+            case SEND_WIDGET_MODE_SEND_BUTTON:
+                mMmsIndicator.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_NO);
+                mMmsIndicator.setContentDescription(null);
+                setSendWidgetAccessibilityTraversalOrder(SEND_WIDGET_MODE_SEND_BUTTON);
+                break;
+        }
+    }
+
+    private String getSimContentDescription() {
+        final SubscriptionListEntry sub = getSelfSubscriptionListEntry();
+        if (sub != null) {
+            return getResources().getString(
+                    R.string.sim_selector_button_content_description_with_selection,
+                    sub.displayName);
+        } else {
+            return getResources().getString(
+                    R.string.sim_selector_button_content_description);
+        }
+    }
+
+    // Set accessibility traversal order of the components in the send widget.
+    private void setSendWidgetAccessibilityTraversalOrder(final int mode) {
+        if (OsUtil.isAtLeastL_MR1()) {
+            mAttachMediaButton.setAccessibilityTraversalBefore(R.id.compose_message_text);
+            switch (mode) {
+                case SEND_WIDGET_MODE_SIM_SELECTOR:
+                    mComposeEditText.setAccessibilityTraversalBefore(R.id.self_send_icon);
+                    break;
+                case SEND_WIDGET_MODE_SEND_BUTTON:
+                    mComposeEditText.setAccessibilityTraversalBefore(R.id.send_message_button);
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+
+    @Override
+    public void afterTextChanged(final Editable editable) {
+
+        /*Add by SPRD for bug 558909  2016.05.05 Start*/
+        if(editable == mComposeSubjectText.getText())
+            return;
+        /*Add by SPRD for bug 558909  2016.05.05 End*/
+        selectionStart = mComposeEditText.getSelectionStart();
+        selectionEnd = mComposeEditText.getSelectionEnd();
+        /* SPRD: modified for bug 544824  begin */
+        if(mBinding.isBound()){
+            if (mComposeEditText.getText().length() == MmsConfig
+                    .get(mBinding.getData().getSelfSubId()).getMaxTextLimit()) {
+                UiUtils.showToastAtBottom(
+                        R.string.exceed_text_length_limitation);
+                return;
+            }
+            if(selectionStart > 1 && mComposeEditText.getText().length() > MmsConfig
+                    .get(mBinding.getData().getSelfSubId()).getMaxTextLimit()
+                    /*Add for bug 563344*/) {
+                UiUtils.showToastAtBottom(
+                        R.string.exceed_text_length_limitation);
+                // Add by SPRD for bug 563344
+               // mEnableTextLengthLimitation = false;
+                //editable.delete(selectionStart - 1, selectionEnd);
+                    if (MmsConfig.get(mBinding.getData().getSelfSubId())
+                            .getMaxTextLimit() < selectionEnd) {
+                        if (editable.length() >= selectionEnd)editable.delete(MmsConfig
+                                .get(mBinding.getData().getSelfSubId())
+                                .getMaxTextLimit(), selectionEnd);
+                    } else {
+                        if (editable.length() >= selectionEnd)editable.delete(selectionStart - 1, selectionEnd);
+                    }
+                mComposeEditText.setText(editable);
+                mComposeEditText.setSelection(mComposeEditText.length());
+            }
+        }
+        /* SPRD: modified for bug 544824  end */
+    }
+
+    @Override
+    public void beforeTextChanged(final CharSequence s, final int start, final int count,
+            final int after) {
+        if(mBinding.isBound()){
+            mComposeEditText.setFilters(new InputFilter[]{new InputFilter.LengthFilter(MmsConfig
+                    .get(mBinding.getData().getSelfSubId()).getMaxTextLimit())});
+            /* Add by SPRD for bug 563344 Start */
+            if (mComposeEditText.getText().length() != 0 && mComposeEditText.getText().length() <= MmsConfig
+                    .get(mBinding.getData().getSelfSubId()).getMaxTextLimit()) {
+                //mEnableTextLengthLimitation = true;
+            }
+            /* Add by SPRD for bug 563344 End */
+        }
+        if (mHost!=null&&mHost.shouldHideAttachmentsWhenSimSelectorShown()) {
+            hideSimSelector();
+        }
+    }
+
+    private void hideSimSelector() {
+        if (mInputManager.showHideSimSelector(false /* show */, true /* animate */)) {
+            // Now that the sim selector has been hidden, reshow the attachments if they
+            // have been hidden.
+            hideAttachmentsWhenShowingSims(false /*simPickerVisible*/);
+        }
+    }
+
+    @Override
+    public void onTextChanged(final CharSequence s, final int start, final int before,
+            final int count) {
+        final BugleActionBarActivity activity = (mOriginalContext instanceof BugleActionBarActivity)
+                ? (BugleActionBarActivity) mOriginalContext : null;
+        if (activity != null && activity.getIsDestroyed()) {
+            LogUtil.v(LogUtil.BUGLE_TAG, "got onTextChanged after onDestroy");
+
+            // if we get onTextChanged after the activity is destroyed then, ah, wtf
+            // b/18176615
+            // This appears to have occurred as the result of orientation change.
+            return;
+        }
+        mBinding.ensureBound();
+        updateVisualsOnDraftChanged();
+    }
+
+    @Override
+    public PlainTextEditText getComposeEditText() {
+        return mComposeEditText;
+    }
+
+    public void displayPhoto(final Uri photoUri, final Rect imageBounds) {
+        mHost.displayPhoto(photoUri, imageBounds, true /* isDraft */);
+    }
+
+    /* Add by SPRD for bug 563344 Start */
+    public void gotoSmilView() {
+        mHost.gotoSmilView(mBinding.getData());
+    }
+    /* Add by SPRD for bug 563344 End */
+    public void updateConversationSelfIdOnExternalChange(final String selfId) {
+        updateConversationSelfId(selfId, true /* notify */);
+    }
+
+    /**
+     * The selfId of the conversation. As soon as the DraftMessageData successfully loads (i.e.
+     * getSelfId() is non-null), the selfId in DraftMessageData is treated as the sole source
+     * of truth for conversation self id since it reflects any pending self id change the user
+     * makes in the UI.
+     */
+    public String getConversationSelfId() {
+        if(mBinding.isBound())
+        return mBinding.getData().getSelfId();
+        return "";
+    }
+
+    public void selectSim(SubscriptionListEntry subscriptionData) {
+        final String oldSelfId = getConversationSelfId();
+        final String newSelfId = subscriptionData.selfParticipantId;
+        Assert.notNull(newSelfId);
+        // Don't attempt to change self if self hasn't been loaded, or if self hasn't changed.
+        if (oldSelfId == null || TextUtils.equals(oldSelfId, newSelfId)) {
+            return;
+        }
+        updateConversationSelfId(newSelfId, true /* notify */);
+    }
+
+    public void hideAllComposeInputs(final boolean animate) {
+        mInputManager.hideAllInputs(animate);
+    }
+
+    public void saveInputState(final Bundle outState) {
+        mInputManager.onSaveInputState(outState);
+    }
+
+    public void resetMediaPickerState() {
+        mInputManager.resetMediaPickerState();
+    }
+
+    public boolean onBackPressed() {
+        return mInputManager.onBackPressed();
+    }
+
+    public boolean onNavigationUpPressed() {
+        return mInputManager.onNavigationUpPressed();
+    }
+
+    public boolean updateActionBar(final ActionBar actionBar) {
+        return mInputManager != null ? mInputManager.updateActionBar(actionBar) : false;
+    }
+
+    public static boolean shouldShowSimSelector(final ConversationData convData) {
+        return OsUtil.isAtLeastL_MR1() &&
+                convData.getSelfParticipantsCountExcludingDefault(true /* activeOnly */) > 1;
+    }
+
+    public void sendMessageIgnoreMessageSizeLimit() {
+        sendMessageInternal(false /* checkMessageSize */);
+    }
+
+    public void onAttachmentPreviewLongClicked() {
+        mHost.showAttachmentChooser();
+    }
+
+    @Override
+    public void onDraftAttachmentLoadFailed() {
+        mHost.notifyOfAttachmentLoadFailed();
+    }
+
+    @Override
+    public void onDraftAttachmentOverSizeReached(final DraftMessageData data,
+            final MessagePartData attachment) {
+        mHost.showAttachmentExceededDialog(getAttachemtString(attachment));
+    }
+
+    private boolean isOverriddenAvatarAGroup() {
+        final Uri overridenSelfUri = mHost.getSelfSendButtonIconUri();
+        if (overridenSelfUri == null) {
+            return false;
+        }
+        return AvatarUriUtil.TYPE_GROUP_URI.equals(AvatarUriUtil.getAvatarType(overridenSelfUri));
+    }
+
+    @Override
+    public void setAccessibility(boolean enabled) {
+        if (enabled) {
+            mAttachMediaButton.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
+            mComposeEditText.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
+            mSendButton.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
+            setSendButtonAccessibility(mSendWidgetMode);
+        } else {
+            mSelfSendIcon.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_NO);
+            mComposeEditText.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_NO);
+            mSendButton.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_NO);
+            mAttachMediaButton.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_NO);
+        }
+    }
+
+    private int getAttachemtString(final MessagePartData attachment) {
+        /* Add by SPRD for Bug 527835 Start */
+        int stringid =R.string.share_nofile_exceeded;
+        final Uri uri = attachment.getContentUri();
+        String contentType = attachment.getContentType();
+        if(ContentType.isDrmType(contentType)){
+            String dataPath = MessagingDrmSession.get().getPath(uri);
+            contentType = MessagingDrmSession.get().getDrmOrigMimeType(dataPath, ContentType.APP_DRM_CONTENT);
+        }
+        if (ContentType.isImageType(contentType)) {
+            stringid = R.string.share_image_exceeded;
+        } else if(ContentType.isAudioType(contentType)) {
+            stringid = R.string.share_audio_exceeded;
+        } else if(ContentType.isVideoType(contentType)) {
+            stringid = R.string.share_video_exceeded;
+        }else if(ContentType.isVCardType(contentType)){
+            stringid=R.string.share_nofile_exceeded;
+        }
+        /* Add by SPRD for Bug 527835 end */
+        return stringid;
+    }
+
+    /* Add by SPRD for bug 563344 Start */
+    @Override
+    public void onDraftLoadDone(DraftMessageData data) {
+        Log.d("ComposeMessageView", "onDraftLoadDone");
+        if(MessageData.PROTOCOL_MMS_SMIL == data.mProtocol &&
+                data.mSmsMessageUri != null) {
+            Log.d("ComposeMessageView", "load draft from telephony DB done, will update the draft");
+            List<SmilPartEntity> smilPartEntities;
+            // FIXME The better way is do this asynchronously
+            smilPartEntities = SMIL2PartUtil.convertToSmilPart(data);
+            SMIL2PartUtil.clearData();
+            if (smilPartEntities == null) {
+                Log.e("ComposeMessageView", "onDraftLoadDone: failed to convert draft to SmilPart");
+                return;
+            }
+            SmilDraftDataManager.updateDraftMessageDataForSmil(getContext(), smilPartEntities, data);
+        }
+        mIsDraftLoadDone = true;
+        data.dispatchChanged(DraftMessageData.ATTACHMENTS_CHANGED);
+    }
+    /* Add by SPRD for bug 563344 End */
+
+    @Override
+    protected void onWindowVisibilityChanged(int visibility) {
+        try {
+            if (visibility==View.VISIBLE) {
+                DraftMessageData draft = mBinding.getData();
+                boolean hasDrmData = false;
+                for (MessagePartData part : draft.getAttachments()) {
+                    if (ContentType.isDrmType(part.getContentType())) {
+                        hasDrmData = true;
+                        break;
+                    }
+                }
+                if (hasDrmData) {
+                    draft.dispatchChanged(DraftMessageData.ATTACHMENTS_CHANGED);
+                }
+            }
+			setSelfId();
+        }catch (Exception ex){
+            Log.e("ComposeMessageView", "onWindowVisibilityChanged: ex "+ex.fillInStackTrace());
+        }
+        super.onWindowVisibilityChanged(visibility);
+    }
+}
Index: vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/ui/appsettings/GroupMmsSettingDialog.java
===================================================================
--- vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/ui/appsettings/GroupMmsSettingDialog.java	(revision 0)
+++ vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/ui/appsettings/GroupMmsSettingDialog.java	(revision 173004)
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.messaging.ui.appsettings;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.widget.RadioButton;
+
+import com.android.messaging.R;
+import com.android.messaging.util.Assert;
+import com.android.messaging.util.BuglePrefs;
+
+/**
+ * Displays an on/off switch for group MMS setting for a given subscription.
+ */
+public class GroupMmsSettingDialog {
+    private final Context mContext;
+    private final int mSubId;
+    private AlertDialog mDialog;
+
+    /**
+     * Shows a new group MMS setting dialog.
+     */
+    public static void showDialog(final Context context, final int subId) {
+        new GroupMmsSettingDialog(context, subId).show();
+    }
+
+    private GroupMmsSettingDialog(final Context context, final int subId) {
+        mContext = context;
+        mSubId = subId;
+    }
+
+    private void show() {
+        Assert.isNull(mDialog);
+        mDialog = new AlertDialog.Builder(mContext)
+                .setView(createView())
+                .setTitle(R.string.group_mms_pref_title)
+                .setNegativeButton(android.R.string.cancel, null)
+                .show();
+    }
+
+    private void changeGroupMmsSettings(final boolean enable) {
+        Assert.notNull(mDialog);
+        BuglePrefs.getSubscriptionPrefs(mSubId).putBoolean(
+                mContext.getString(R.string.group_mms_pref_key), enable);
+        mDialog.dismiss();
+    }
+
+    private View createView() {
+        final LayoutInflater inflater = (LayoutInflater) mContext
+                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        final View rootView = inflater.inflate(R.layout.group_mms_setting_dialog, null, false);
+        final RadioButton disableButton = (RadioButton)
+                rootView.findViewById(R.id.disable_group_mms_button);
+        final RadioButton enableButton = (RadioButton)
+                rootView.findViewById(R.id.enable_group_mms_button);
+        disableButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                changeGroupMmsSettings(false);
+            }
+        });
+        enableButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                changeGroupMmsSettings(true);
+            }
+        });
+        final boolean mmsEnabled = BuglePrefs.getSubscriptionPrefs(mSubId).getBoolean(
+                mContext.getString(R.string.group_mms_pref_key),
+                mContext.getResources().getBoolean(R.bool.group_mms_pref_default));
+        enableButton.setChecked(mmsEnabled);
+        disableButton.setChecked(!mmsEnabled);
+        return rootView;
+    }
+}
Index: vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/ui/appsettings/PerSubscriptionSettingsActivity.java
===================================================================
--- vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/ui/appsettings/PerSubscriptionSettingsActivity.java	(revision 0)
+++ vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/ui/appsettings/PerSubscriptionSettingsActivity.java	(revision 173004)
@@ -0,0 +1,678 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.messaging.ui.appsettings;
+
+import java.util.List;
+
+import android.app.FragmentTransaction;
+import android.content.ActivityNotFoundException;
+import android.content.BroadcastReceiver;
+import android.content.Intent;
+import android.content.Context;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.telephony.SmsManager;
+import android.provider.Settings;
+/*Add for bug 526653 {@*/
+import android.preference.ListPreference;
+import android.preference.PreferenceManager;
+/*@}*/
+import android.preference.Preference;
+import android.preference.Preference.OnPreferenceClickListener;
+import android.preference.PreferenceCategory;
+import android.preference.PreferenceFragment;
+import android.preference.PreferenceScreen;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.support.v4.app.NavUtils;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.MenuItem;
+
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.messaging.Factory;
+import com.android.messaging.R;
+import com.android.messaging.datamodel.ParticipantRefresh;
+import com.android.messaging.datamodel.data.ParticipantData;
+import com.android.messaging.sms.ApnDatabase;
+import com.android.messaging.sms.MmsConfig;
+import com.android.messaging.sms.MmsUtils;
+//Add for bug 526653
+import com.android.messaging.sms.SystemProperties;
+import com.android.messaging.ui.BugleActionBarActivity;
+import com.android.messaging.ui.UIIntents;
+import com.sprd.messaging.ui.smsc.ShowSmscEditDialogActivity;
+import com.sprd.messaging.ui.smsc.SmscListActivity;
+import com.sprd.messaging.ui.smsc.SmscManager;
+import com.android.messaging.util.Assert;
+import com.android.messaging.util.BuglePrefs;
+import com.android.messaging.util.LogUtil;
+import com.android.messaging.util.OsUtil;
+import com.android.messaging.util.PhoneUtils;
+import com.sprd.messaging.util.SystemAdapter;
+import com.android.sprd.telephony.RadioInteractor;
+
+public class PerSubscriptionSettingsActivity extends BugleActionBarActivity {
+    public static final String MAX_SEND_RETRIES = "3";
+    public static final String MIN_SEND_RETRIES = "0";
+    public static final String SMS_VALIDITY_SETTING = "persist.radio.smstime";
+    public static final String MMS_VALIDITY_SETTING = "persist.radio.mmstime";
+    public static final int RequestCode = 1;
+
+    /**
+     * Declare the property
+     *
+     */
+    public static final String SEND_RETRIE_TIME = "persist.radio.retry_control";
+
+    @Override
+    protected void onCreate(final Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
+        final String title = getIntent().getStringExtra(
+                UIIntents.UI_INTENT_EXTRA_PER_SUBSCRIPTION_SETTING_TITLE);
+        if (!TextUtils.isEmpty(title)) {
+            getSupportActionBar().setTitle(title);
+        } else {
+            // This will fall back to the default title, i.e. "Messaging settings," so No-op.
+        }
+
+        final FragmentTransaction ft = getFragmentManager().beginTransaction();
+        final PerSubscriptionSettingsFragment fragment = new PerSubscriptionSettingsFragment();
+        ft.replace(android.R.id.content, fragment);
+        ft.commit();
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(final MenuItem item) {
+        switch (item.getItemId()) {
+        case android.R.id.home:
+            NavUtils.navigateUpFromSameTask(this);
+            return true;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    public static class PerSubscriptionSettingsFragment extends
+            PreferenceFragment implements OnSharedPreferenceChangeListener,
+            Preference.OnPreferenceChangeListener {
+        private PhoneNumberPreference mPhoneNumberPreference;
+        private Preference mGroupMmsPreference;
+        private String mGroupMmsPrefKey;
+        private String mPhoneNumberKey;
+        private int mSubId;
+        // sprd add for smsc begin
+        private Preference mSmscPreference;
+        private String mSmscPrefKey;
+        private String mDisplayName;
+        private int sub_Id = -1;
+        // sprd add for smsc end
+        // Modify by SPRD for bug 526653
+        private ListPreference mSmsValidityPref;
+        private ListPreference mMmsValidityPref;
+        // private ValidityPopWindow mValidityWin;
+
+        // 489220 begin
+        private Preference mMmsDeliveryReportsPreference;
+        private Preference mMmsReadReportsPreference;
+        /* Delete by SPRD for Bug531825  2016.03.17 Start*/
+        //private Preference mEnableReturnMmsDeliveryReportsPreference;
+        private Preference mEnableReturnMmsReadReportsPreference;
+        private Preference mSmsRetryTimesPref;
+        private String mMmsDeliveryReportPrefKey;
+        private String mMmsReadReportsPrefKey;
+        //private String mEnableReturnMmsDeliveryReportsPrefKey;
+        /* Delete by SPRD for Bug531825  2016.03.17 End*/
+        private String mEnableReturnMmsReadReportsPrefKey;
+
+        // 489220 end
+        // sprd #542214 start
+        private Preference mSmsSaveSimPreference;
+        private String mSmsSaveSimPrefKey;
+        private RadioInteractor mRadioInteractor;
+        private Context mContext;
+        private int mPhoneId;
+        // sprd #542214 end
+        //add for bug 556256 begin
+        private Preference mSimMessageCapacity;
+        //add for bug 556256 end
+
+        public  final String MMS_SIZE_LIMIT = "pref_key_mms_size_limit";
+        private ListPreference mMmsSizeLimit;
+
+        private Preference mSmsWapPushPrefence;
+        private String mSmsWapPrefKey;
+        
+        public PerSubscriptionSettingsFragment() {
+            // Required empty constructor
+        }
+
+        @Override
+        public void onCreate(final Bundle savedInstanceState) {
+            super.onCreate(savedInstanceState);
+
+            // Get sub id from launch intent
+            final Intent intent = getActivity().getIntent();
+            Assert.notNull(intent);
+            // Modify by SPRD for bug 526653
+            // mValidityWin = new ValidityPopWindow(getContext());
+            mSubId = (intent != null) ? intent.getIntExtra(
+                    UIIntents.UI_INTENT_EXTRA_SUB_ID,
+                    ParticipantData.DEFAULT_SELF_SUB_ID)
+                    : ParticipantData.DEFAULT_SELF_SUB_ID;
+            Log.d("PerSubscriptionSettingsActivity", " onCreate mSubId = " + mSubId);
+            final BuglePrefs subPrefs = Factory.get().getSubscriptionPrefs(
+                    mSubId);
+            getPreferenceManager().setSharedPreferencesName(
+                    subPrefs.getSharedPreferencesName());
+            addPreferencesFromResource(R.xml.preferences_per_subscription);
+
+            mPhoneNumberKey = getString(R.string.mms_phone_number_pref_key);
+            mPhoneNumberPreference = (PhoneNumberPreference) findPreference(mPhoneNumberKey);
+            final PreferenceCategory advancedCategory = (PreferenceCategory) findPreference(getString(R.string.advanced_category_pref_key));
+            final PreferenceCategory mmsCategory = (PreferenceCategory) findPreference(getString(R.string.mms_messaging_category_pref_key));
+
+            if (!OsUtil.hasPhonePermission()) {
+                OsUtil.requestMissingPermission(getActivity());
+            } else {
+                mPhoneNumberPreference.setDefaultPhoneNumber(
+                        PhoneUtils.get(mSubId)
+                                .getCanonicalForSelf(false/* allowOverride */),
+                        mSubId);
+            }
+
+            mGroupMmsPrefKey = getString(R.string.group_mms_pref_key);
+            mGroupMmsPreference = findPreference(mGroupMmsPrefKey);
+            if (!MmsConfig.get(mSubId).getGroupMmsEnabled()) {
+                // Always show group messaging setting even if the SIM has no number
+                // If broadcast sms is selected, the SIM number is not needed
+                // If group mms is selected, the phone number dialog will popup when message
+                // is being sent, making sure we will have a self number for group mms.
+                mmsCategory.removePreference(mGroupMmsPreference);
+            } else {
+                mGroupMmsPreference
+                        .setOnPreferenceClickListener(new OnPreferenceClickListener() {
+                            @Override
+                            public boolean onPreferenceClick(Preference pref) {
+                                GroupMmsSettingDialog.showDialog(getActivity(),
+                                        mSubId);
+                                return true;
+                            }
+                        });
+                updateGroupMmsPrefSummary();
+            }
+
+            if (!MmsConfig.get(mSubId).getSMSDeliveryReportsEnabled()) {
+                final Preference deliveryReportsPref = findPreference(getString(R.string.delivery_reports_pref_key));
+                mmsCategory.removePreference(deliveryReportsPref);
+            }
+
+            mSmsRetryTimesPref = findPreference(getString(R.string.sms_retry_times_pref_key));
+            if (!MmsConfig.get(mSubId).getSMSRetryTimesEnabled()) {
+                advancedCategory.removePreference(mSmsRetryTimesPref);
+            } else {
+                mSmsRetryTimesPref.setOnPreferenceChangeListener(this);
+            }
+
+            //add for bug 556256 begin
+            //Add by SPRD for bug 608039 begin
+            String capacity;
+            if (MmsUtils.isAirplaneModeOn(mSubId)) {
+                capacity = getString(R.string.unable_get_data);
+            } else {        //Add by SPRD for bug 608039 end
+                RadioInteractor radioInteractor = new RadioInteractor(Factory.get().getApplicationContext());
+                capacity = radioInteractor.getSimCapacity(
+                        MmsUtils.tanslateSubIdToPhoneId(
+                                Factory.get().getApplicationContext(), getRealSubId(mSubId)));
+                Log.d("PerSubscriptionSettingsActivity", "the capacity is:"+capacity+" and the subId:"+getRealSubId(mSubId));
+            }
+
+            mSimMessageCapacity = findPreference(getString(R.string.capacity_sim_message_key));
+            if(capacity == null)
+            {
+                capacity = "";
+            }
+            else{
+                capacity = capacity.replace(":","/");
+            }
+            String summary = getString(R.string.capacity_sim_message_summary);
+            mSimMessageCapacity.setSummary(String.format(summary, capacity));
+            //add for bug 556256 end
+
+            // Access Point Names (APNs)
+            final Preference apnsPref = findPreference(getString(R.string.sms_apns_key));
+
+            if (MmsUtils.useSystemApnTable()
+                    && !ApnDatabase.doesDatabaseExist()) {
+                // Don't remove the ability to edit the local APN prefs if this
+                // device lets us
+                // access the system APN, but we can't find the MCC/MNC in the
+                // APN table and we
+                // created the local APN table in case the MCC/MNC was in there.
+                // In other words,
+                // if the local APN table exists, let the user edit it.
+                advancedCategory.removePreference(apnsPref);
+            } else {
+                final PreferenceScreen apnsScreen = (PreferenceScreen) findPreference(getString(R.string.sms_apns_key));
+                apnsScreen.setIntent(UIIntents.get().getApnSettingsIntent(
+                        getPreferenceScreen().getContext(), mSubId));
+            }
+
+            // We want to disable preferences if we are not the default app, but
+            // we do all of the
+            // above first so that the user sees the correct information on the
+            // screen
+            if (!PhoneUtils.getDefault().isDefaultSmsApp()) {
+                mGroupMmsPreference.setEnabled(false);
+                final Preference autoRetrieveMmsPreference = findPreference(getString(R.string.auto_retrieve_mms_pref_key));
+                autoRetrieveMmsPreference.setEnabled(false);
+                final Preference deliveryReportsPreference = findPreference(getString(R.string.delivery_reports_pref_key));
+                deliveryReportsPreference.setEnabled(false);
+            }
+
+            // 489220 begin
+            mMmsDeliveryReportPrefKey = getString(R.string.mms_delivery_reports_pref_key);
+            mMmsReadReportsPrefKey = getString(R.string.mms_read_reports_pref_key);
+            /* Delete by SPRD for Bug531825  2016.03.17 Start*/
+            //mEnableReturnMmsDeliveryReportsPrefKey = getString(R.string.enable_return_mms_delivery_reports_pref_key);
+            mEnableReturnMmsReadReportsPrefKey = getString(R.string.enable_return_mms_read_reports_pref_key);
+
+            mMmsDeliveryReportsPreference = findPreference(mMmsDeliveryReportPrefKey);
+            mMmsReadReportsPreference = findPreference(mMmsReadReportsPrefKey);
+            //mEnableReturnMmsDeliveryReportsPreference = findPreference(mEnableReturnMmsDeliveryReportsPrefKey);
+            mEnableReturnMmsReadReportsPreference = findPreference(mEnableReturnMmsReadReportsPrefKey);
+
+            if (!MmsConfig.get(mSubId).getmMmsReadReportsEnable()) {
+                //mMmsDeliveryReportsPreference.setEnabled(false);  //add for bug 610187
+                mMmsReadReportsPreference.setEnabled(false);
+                //mEnableReturnMmsDeliveryReportsPreference.setEnabled(false);
+                mEnableReturnMmsReadReportsPreference.setEnabled(false);
+                //mmsCategory.removePreference(mMmsDeliveryReportsPreference); //add for bug 610187
+                mmsCategory.removePreference(mMmsReadReportsPreference);
+                //mmsCategory
+                        //.removePreference(mEnableReturnMmsDeliveryReportsPreference);
+            /* Delete by SPRD for Bug531825  2016.03.17 End*/
+                mmsCategory
+                        .removePreference(mEnableReturnMmsReadReportsPreference);
+            }
+            // 489220 end
+
+            /* Sprd add for sms and mms validity start */
+            // sprd: fix fof bug 528758 start
+            if (OsUtil.hasPhonePermission()) {
+                /* Add by sprd for bug 526653 Start */
+                String mmsValidityPrefKey = getString(R.string.mms_validity_pref_key);
+                String smsValidityPrefKey = getString(R.string.sms_validity_pref_key);
+                SmsManager smsManager = SmsManager.getDefault();
+                SharedPreferences sharedPref = PreferenceManager
+                        .getDefaultSharedPreferences(this.getActivity());
+                /* Add by sprd for bug 526653 End */
+                mMmsValidityPref = (ListPreference) findPreference(mmsValidityPrefKey);
+                if (!MmsConfig.getValidityMmsEnabled()
+                        || (PhoneUtils.getDefault()
+                                .getActiveSubscriptionCount() == 0)) {
+                    mmsCategory.removePreference(mMmsValidityPref);
+                    /* Modify by sprd for bug 526653 Start */
+                } else {
+                    if (null != mMmsValidityPref) {
+                        String curVal = sharedPref.getString(mmsValidityPrefKey
+                                + mSubId, "604800");
+                        SystemAdapter.getInstance().setProperty(//smsManager.setProperty(
+                                getRealValidityKey(MMS_VALIDITY_SETTING),
+                                curVal);
+                        mMmsValidityPref.setValue(curVal);
+                        mMmsValidityPref
+                                .setSummary(mMmsValidityPref.getEntry());
+                        mMmsValidityPref.setOnPreferenceChangeListener(this);
+                    }
+                }
+
+                mSmsValidityPref = (ListPreference) findPreference(smsValidityPrefKey);
+                if (!MmsConfig.getValiditySmsEnabled()
+                        || (PhoneUtils.getDefault()
+                                .getActiveSubscriptionCount() == 0)) {
+                    advancedCategory.removePreference(mSmsValidityPref);
+                } else {
+                    if (null != mSmsValidityPref) {
+                        String curVal = sharedPref.getString(smsValidityPrefKey
+                                + mSubId, "-1");
+                        SystemAdapter.getInstance().setProperty(//smsManager.setProperty(
+                                getRealValidityKey(SMS_VALIDITY_SETTING),
+                                curVal);
+                        mSmsValidityPref.setValue(curVal);
+                        mSmsValidityPref
+                                .setSummary(mSmsValidityPref.getEntry());
+                        mSmsValidityPref.setOnPreferenceChangeListener(this);
+                    }
+                }
+                mmsValidityPrefKey = null;
+                smsValidityPrefKey = null;
+                smsManager = null;
+                sharedPref = null;
+                /* Modify by sprd for bug 526653 End */
+            }
+            // sprd: fix fof bug 528758 end
+            /* Sprd add for sms and mms validity end */
+
+            // sprd add for smsc begin
+            mSmscPrefKey = getString(R.string.smsc_pref_key);
+            mSmscPreference = findPreference(mSmscPrefKey);
+            if (OsUtil.hasPhonePermission()) {
+                mDisplayName = PhoneUtils.get(getRealSubId(mSubId))
+                        .getCarrierName();
+
+                if (PhoneUtils.getDefault().getActiveSubscriptionCount() == 0
+                        || !MmsConfig.get(mSubId).getSmscShowEnabled()) {
+                    advancedCategory.removePreference(mSmscPreference);
+                } else {
+                    mSmscPreference.setTitle(getString(
+                            R.string.pref_title_manage_simx_smsc, " "
+                                    + mDisplayName));
+                    updateSmscSummary(getRealSubId(mSubId));
+                    if(MmsConfig.get(mSubId).getSmscEditable()) {//add for 647119
+                        mSmscPreference
+                                .setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
+                                    @Override
+                                    public boolean onPreferenceClick(Preference pref) {
+                                        Intent intent;
+                                        if (!SmscManager.getInstance().isMultiSmsc(
+                                                getRealSubId(mSubId))) {
+                                            intent = new Intent(
+                                                    getActivity(),
+                                                    ShowSmscEditDialogActivity.class);
+                                        } else {
+                                            intent = new Intent(getActivity(),
+                                                    SmscListActivity.class);
+                                        }
+                                        intent.putExtra("subId",
+                                                getRealSubId(mSubId));
+                                        startActivityForResult(intent, RequestCode);
+                                        return true;
+                                    }
+                                });
+                    }
+                }
+            }
+            // sprd add for smsc end
+            // sprd #542214 start
+            mContext = Factory.get().getApplicationContext();
+            mRadioInteractor = new RadioInteractor(mContext);
+            mPhoneId = MmsUtils.tanslateSubIdToPhoneId(mContext,
+                    getRealSubId(mSubId));
+            mSmsSaveSimPrefKey = getString(R.string.sms_save_to_sim_pref_key);
+            mSmsSaveSimPreference = findPreference(mSmsSaveSimPrefKey);
+            if (!MmsConfig.getIsCMCC()) {// get(mSubId).getSmsSaveSimEnabled())
+                                         // {
+                advancedCategory.removePreference(mSmsSaveSimPreference);
+            }
+            // sprd #542214 end
+            mSmsWapPrefKey = getString(R.string.sms_wap_pref_key);
+            mSmsWapPushPrefence = findPreference(mSmscPrefKey);
+            if(!MmsConfig.enableSmsWapFeature()) {
+                advancedCategory.removePreference(mSmscPreference);
+            }
+            getActivity().registerReceiver(mSimInOutReceiver, mSimFilter);
+
+            mMmsSizeLimit = (ListPreference) findPreference(MMS_SIZE_LIMIT);
+            if (!MmsConfig.get(mSubId).enableSelectMmsSize()) {
+                mmsCategory.removePreference(mMmsSizeLimit);
+            } else {
+                if (mMmsSizeLimit != null) {
+                    SharedPreferences sharedPref = PreferenceManager
+                            .getDefaultSharedPreferences(this.getActivity());
+                    String curVal = sharedPref.getString(MMS_SIZE_LIMIT, "1024");
+                    mMmsSizeLimit.setValue(curVal);
+                    mMmsSizeLimit.setSummary(mMmsSizeLimit.getEntry());
+                    mMmsSizeLimit.setOnPreferenceChangeListener(this);
+                }
+            }
+        }
+
+        // sprd add for smsc begin
+        @Override
+        public void onActivityResult(int requestCode, int resultCode, Intent data) {
+            switch (requestCode) {
+            case RequestCode:
+                if(resultCode == RESULT_OK) {
+                    String SmscData = data.getStringExtra("Smsc");
+                    mSmscPreference.setSummary(SmscData);
+                }
+                break;
+            default:
+            }
+        }
+
+        private void updateSmscSummary(int subId) {
+           /*  new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    String summary = SmscManager.getSmscString(getActivity(), subId);
+
+                   getActivity().runOnUiThread(new Runnable() {
+                        public void run() {
+                            mSmscPreference.setSummary(summary);
+                        }
+                    });
+
+                }
+            }).start();
+        /*Add by SPRD for bug550266  2016.4.19 End*/
+           Log.w("hzh","updateSmscSummary");
+                      String summary = SmscManager.getSmscString(getActivity(), subId);
+                     mSmscPreference.setSummary(summary);
+        }
+        // sprd add for smsc end
+        
+        private void updateGroupMmsPrefSummary() {
+            final boolean groupMmsEnabled = getPreferenceScreen()
+                    .getSharedPreferences().getBoolean(
+                            mGroupMmsPrefKey,
+                            getResources().getBoolean(
+                                    R.bool.group_mms_pref_default));
+            mGroupMmsPreference
+                    .setSummary(groupMmsEnabled ? R.string.enable_group_mms
+                            : R.string.disable_group_mms);
+        }
+
+        @Override
+        public void onResume() {
+            super.onResume();
+            getPreferenceScreen().getSharedPreferences()
+                    .registerOnSharedPreferenceChangeListener(this);
+             updateSmscSummary(getRealSubId(mSubId));//sprd add for smsc
+        }
+
+        @Override
+        public void onSharedPreferenceChanged(
+                final SharedPreferences sharedPreferences, final String key) {
+            if (key.equals(mGroupMmsPrefKey)) {
+                updateGroupMmsPrefSummary();
+            } else if (key.equals(mPhoneNumberKey)) {
+                // Save the changed phone number in preferences specific to the sub id
+                final String newPhoneNumber = mPhoneNumberPreference.getText();
+                final BuglePrefs subPrefs = BuglePrefs
+                        .getSubscriptionPrefs(mSubId);
+                if (TextUtils.isEmpty(newPhoneNumber)) {
+                    subPrefs.remove(mPhoneNumberKey);
+                } else {
+                    subPrefs.putString(
+                            getString(R.string.mms_phone_number_pref_key),
+                            newPhoneNumber);
+                }
+                // Update the self participants so the new phone number will be reflected
+                // everywhere in the UI.
+                ParticipantRefresh.refreshSelfParticipants();
+            }
+            // sprd add for smsc begin
+            else if (key.equals(mSmscPrefKey)) {
+                updateSmscSummary(getRealSubId(mSubId));
+            }
+            // sprd add for smsc end
+            
+            // sprd #542214 start
+            else if (key.equals(mSmsSaveSimPrefKey)) {
+                Log.d("PerSubscriptionSettingsActivity",
+                        "onSharedPreferenceChanged mSmsSaveSimPrefKey !!");
+                // updateSmsSaveSimPrefSummary();
+            }
+            // sprd #542214 end
+
+            else if(key.equals(mSmsWapPrefKey)) {
+                boolean smsWapEnable =  sharedPreferences.getBoolean(key, true);
+                handleSmsWapPreferenceChanged(smsWapEnable);
+            }
+        }
+
+        @Override
+        public void onPause() {
+            super.onPause();
+            getPreferenceScreen().getSharedPreferences()
+                    .unregisterOnSharedPreferenceChangeListener(this);
+        }
+
+         // sprd add for smsc begin
+        private int getRealSubId(int subId) {
+            if (OsUtil.hasPhonePermission()) {
+                return PhoneUtils.getDefault().getEffectiveSubId(subId);
+            } else {
+                return -1;
+            }
+        }
+
+        //add for bug 610115 start
+        @Override
+        public void onDestroy(){
+            getActivity().unregisterReceiver(mSimInOutReceiver);
+            super.onDestroy();
+        }
+
+        private IntentFilter mSimFilter = new IntentFilter(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
+        private BroadcastReceiver mSimInOutReceiver = new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                Log.d("ApplicationSettingsFragment", "receive sim state changed.");
+                String simStatus = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
+                int subIdEx = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY, -1);
+                Log.d("ApplicationSettingsFragment", " The simStatus"+ simStatus + "  subIdEx = " + subIdEx);
+                if (intent.getAction() == TelephonyIntents.ACTION_SIM_STATE_CHANGED && subIdEx == mSubId){
+                    if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(simStatus)){
+                        getActivity().finish();
+                    }
+                }
+            }
+        };
+        //add for bug 610115 end
+
+        // sprd add for smsc end
+        /* Sprd add for sms and mms validity start */
+        /* Delete by SPRD for bug 526653 Start */
+        /*
+         * public boolean onPreferenceClick(Preference preference) { if
+         * (preference == mSmsValidityPref) {
+         * mValidityWin.initPopWin(preference,
+         * getRealValidityKey(SMS_VALIDITY_SETTING));
+         * mValidityWin.showPopupWindow(); } else if (preference ==
+         * mMmsValidityPref) { mValidityWin.initPopWin(preference,
+         * getRealValidityKey(MMS_VALIDITY_SETTING));
+         * mValidityWin.showPopupWindow(); } return true; }
+         */
+        /* Delete by SPRD for bug 526653 End */
+
+        /* Add by sprd for bug 526653 Start */
+        public boolean onPreferenceChange(Preference preference, Object newValue) {
+            SharedPreferences.Editor prefEditor = PreferenceManager
+                    .getDefaultSharedPreferences(this.getActivity()).edit();
+            SmsManager smsManager = SmsManager.getDefault();
+
+            if (preference == mSmsRetryTimesPref) {
+                if (((Boolean) newValue).booleanValue()) {
+                    SystemAdapter.getInstance().setProperty(SEND_RETRIE_TIME, MAX_SEND_RETRIES);//smsManager.setProperty(SEND_RETRIE_TIME, MAX_SEND_RETRIES);
+                } else {
+                    SystemAdapter.getInstance().setProperty(SEND_RETRIE_TIME, MIN_SEND_RETRIES);//smsManager.setProperty(SEND_RETRIE_TIME, MIN_SEND_RETRIES);
+                }
+                return true;
+            }
+
+            if (preference == mSmsValidityPref) {
+                SystemAdapter.getInstance().setProperty(//smsManager.setProperty(
+                        getRealValidityKey(SMS_VALIDITY_SETTING),
+                        newValue.toString());
+                prefEditor.putString(
+                        this.getActivity().getString(
+                                R.string.sms_validity_pref_key)
+                                + mSubId, newValue.toString());
+                mSmsValidityPref.setValue(newValue.toString());
+                mSmsValidityPref.setSummary(mSmsValidityPref.getEntry());
+                prefEditor.commit();
+                return true;
+            }
+
+            if (preference == mMmsValidityPref) {
+                SystemAdapter.getInstance().setProperty(//smsManager.setProperty(
+                        getRealValidityKey(MMS_VALIDITY_SETTING),
+                        newValue.toString());
+                prefEditor.putString(
+                        this.getActivity().getString(
+                                R.string.mms_validity_pref_key)
+                                + mSubId, newValue.toString());
+                mMmsValidityPref.setValue(newValue.toString());
+                mMmsValidityPref.setSummary(mMmsValidityPref.getEntry());
+                prefEditor.commit();
+                return true;
+            }
+
+            if(preference == mMmsSizeLimit) {
+                prefEditor.putString(MMS_SIZE_LIMIT, newValue.toString());
+                mMmsSizeLimit.setValue(newValue.toString());
+                mMmsSizeLimit.setSummary(mMmsSizeLimit.getEntry());
+                prefEditor.commit();
+                 MmsConfig.get(mSubId).setMmsSizeLimit(Integer.valueOf(newValue.toString()));
+                return true;
+            }
+
+            prefEditor = null;
+            smsManager = null;
+            return false;
+        }
+
+        /* Add by sprd for bug 526653 End */
+
+        private String getRealValidityKey(String key) {
+            // return key + mRealSubId;
+            return key + getRealSubId(mSubId);
+        }
+
+        /* Delete by SPRD for bug 526653 Start */
+        /*
+         * private String getOldValidity(final String key) { String oldValidity
+         * = mValidityWin.getKeyValidity(key); return oldValidity; }
+         */
+        /* Delete by SPRD for bug 526653 End */
+        /* Sprd add for sms and mms validity end */
+
+
+        private void handleSmsWapPreferenceChanged(boolean newValue) {
+            MmsConfig.setSmsWapPreference(mSubId, newValue);
+        }
+    }
+}
Index: vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/util/BugleSubscriptionPrefs.java
===================================================================
--- vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/util/BugleSubscriptionPrefs.java	(revision 0)
+++ vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/util/BugleSubscriptionPrefs.java	(revision 173004)
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.messaging.util;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.text.TextUtils;
+
+import com.android.messaging.Factory;
+import com.android.messaging.R;
+
+/**
+ * Provides interface to access per-subscription shared preferences. We have one instance of
+ * this per active subscription.
+ */
+public class BugleSubscriptionPrefs extends BuglePrefsImpl {
+    private final int mSubId;
+
+    public BugleSubscriptionPrefs(final Context context, final int subId) {
+        super(context);
+        mSubId = subId;
+    }
+
+    @Override
+    public String getSharedPreferencesName() {
+        return SHARED_PREFERENCES_PER_SUBSCRIPTION_PREFIX + String.valueOf(mSubId);
+    }
+
+    @Override
+    protected void validateKey(String key) {
+        super.validateKey(key);
+        // Callers should only access per-subscription preferences from this class
+        Assert.isTrue(key.startsWith(SHARED_PREFERENCES_PER_SUBSCRIPTION_PREFIX));
+    }
+
+    @Override
+    public void onUpgrade(final int oldVersion, final int newVersion) {
+        switch (oldVersion) {
+            case BuglePrefs.NO_SHARED_PREFERENCES_VERSION:
+                // Upgrade to version 1. Adding per-subscription shared prefs.
+                // Migrate values from the application-wide settings.
+                migratePrefBooleanInternal(BuglePrefs.getApplicationPrefs(), "delivery_reports",
+                        R.string.delivery_reports_pref_key, R.bool.delivery_reports_pref_default);
+                migratePrefBooleanInternal(BuglePrefs.getApplicationPrefs(), "auto_retrieve_mms",
+                        R.string.auto_retrieve_mms_pref_key, R.bool.auto_retrieve_mms_pref_default);
+                migratePrefBooleanInternal(BuglePrefs.getApplicationPrefs(),
+                        "auto_retrieve_mms_when_roaming",
+                        R.string.auto_retrieve_mms_when_roaming_pref_key,
+                        R.bool.auto_retrieve_mms_when_roaming_pref_default);
+                migratePrefBooleanInternal(BuglePrefs.getApplicationPrefs(), "group_messaging",
+                        R.string.group_mms_pref_key, R.bool.group_mms_pref_default);
+
+                if (PhoneUtils.getDefault().getActiveSubscriptionCount() == 1) {
+                    migratePrefStringInternal(BuglePrefs.getApplicationPrefs(), "mms_phone_number",
+                            R.string.mms_phone_number_pref_key, null);
+                }
+        }
+    }
+
+    private void migratePrefBooleanInternal(final BuglePrefs oldPrefs, final String oldKey,
+            final int newKeyResId, final int defaultValueResId) {
+        final Resources resources = Factory.get().getApplicationContext().getResources();
+        final boolean defaultValue = resources.getBoolean(defaultValueResId);
+        final boolean oldValue = oldPrefs.getBoolean(oldKey, defaultValue);
+
+        // Only migrate pref value if it's different than the default.
+        if (oldValue != defaultValue) {
+            putBoolean(resources.getString(newKeyResId), oldValue);
+        }
+    }
+
+    private void migratePrefStringInternal(final BuglePrefs oldPrefs, final String oldKey,
+            final int newKeyResId, final String defaultValue) {
+        final Resources resources = Factory.get().getApplicationContext().getResources();
+        final String oldValue = oldPrefs.getString(oldKey, defaultValue);
+
+        // Only migrate pref value if it's different than the default.
+        if (!TextUtils.equals(oldValue, defaultValue)) {
+            putString(resources.getString(newKeyResId), oldValue);
+        }
+    }
+}
Index: vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/sms/MmsUtils.java
===================================================================
--- vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/sms/MmsUtils.java	(revision 0)
+++ vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/sms/MmsUtils.java	(revision 173004)
@@ -0,0 +1,4367 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.messaging.sms;
+
+import android.app.ActivityManager;
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.AssetFileDescriptor;
+import android.content.res.Resources;
+import android.database.Cursor;
+//489220 begin
+import android.database.DatabaseUtils;
+//489220 end
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.graphics.BitmapFactory;
+import android.media.MediaMetadataRetriever;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Message;
+import android.os.Bundle;
+import android.os.Looper;
+import android.provider.ContactsContract;
+import android.provider.MediaStore;
+import android.widget.Toast;
+import android.provider.Settings;
+import android.provider.Telephony;
+import android.provider.Telephony.Mms;
+import android.provider.Settings;
+import android.provider.Telephony;
+import android.provider.Telephony.Mms;
+//489220 begin
+import android.provider.Telephony.Mms.Addr;
+//489220 end
+import android.provider.Telephony.Sms;
+import android.provider.Telephony.Threads;
+import android.support.v7.mms.CarrierConfigValuesLoader;
+import android.telephony.SmsManager;
+import android.telephony.SmsMessage;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.text.TextUtils;
+import android.text.util.Rfc822Token;
+import android.text.util.Rfc822Tokenizer;
+import android.telephony.SubscriptionManager;
+
+import com.android.internal.telephony.gsm.GsmSmsAddress;
+import com.android.messaging.Factory;
+import com.android.messaging.R;
+import com.android.messaging.datamodel.CursorQueryData;
+import com.android.messaging.datamodel.DataModel;
+import com.android.messaging.datamodel.DatabaseHelper;  // Add by SPRD for bug 531941
+import com.android.messaging.datamodel.DatabaseWrapper;
+import com.android.messaging.datamodel.MediaScratchFileProvider;
+import com.android.messaging.datamodel.action.DownloadMmsAction;
+import com.android.messaging.datamodel.action.ProcessDeliveryReportAction;  // Add by SPRD for bug 531941
+import com.android.messaging.datamodel.action.SendMessageAction;
+import com.android.messaging.datamodel.data.ConversationMessageData;
+import com.android.messaging.datamodel.data.DraftMessageData;
+import com.android.messaging.datamodel.data.MessageData;
+import com.android.messaging.datamodel.data.MessagePartData;
+import com.android.messaging.datamodel.data.ParticipantData;
+import com.android.messaging.mmslib.InvalidHeaderValueException;
+import com.android.messaging.datamodel.BugleNotifications;//sprd add for smsc
+import com.android.messaging.mmslib.MmsException;
+import com.android.messaging.mmslib.SqliteWrapper;
+import com.android.messaging.mmslib.pdu.CharacterSets;
+import com.android.messaging.mmslib.pdu.EncodedStringValue;
+import com.android.messaging.mmslib.pdu.GenericPdu;
+import com.android.messaging.mmslib.pdu.NotificationInd;
+//489220 begin
+import com.android.messaging.mmslib.pdu.DeliveryInd;
+import com.android.messaging.mmslib.pdu.ReadOrigInd;
+//489220 end
+import com.android.messaging.mmslib.pdu.PduBody;
+import com.android.messaging.mmslib.pdu.PduComposer;
+import com.android.messaging.mmslib.pdu.PduHeaders;
+import com.android.messaging.mmslib.pdu.PduParser;
+import com.android.messaging.mmslib.pdu.PduPart;
+import com.android.messaging.mmslib.pdu.PduPersister;
+import com.android.messaging.mmslib.pdu.RetrieveConf;
+import com.android.messaging.mmslib.pdu.SendConf;
+import com.android.messaging.mmslib.pdu.SendReq;
+//489220 begin
+import com.android.messaging.mmslib.pdu.ReadRecInd;
+//489220 end
+import com.android.messaging.sms.SmsSender.SendResult;
+import com.android.messaging.util.Assert;
+import com.android.messaging.util.BugleGservices;
+import com.android.messaging.util.BugleGservicesKeys;
+import com.android.messaging.util.BuglePrefs;
+import com.android.messaging.util.ContactUtil;
+import com.android.messaging.util.ContentType;
+import com.android.messaging.util.DebugUtils;
+import com.android.messaging.util.EmailAddress;
+import com.android.messaging.util.ImageUtils;
+import com.android.messaging.util.ImageUtils.ImageResizer;
+import com.android.messaging.util.LogUtil;
+import com.android.messaging.util.MediaMetadataRetrieverWrapper;
+import com.android.messaging.util.GlobleUtil;
+import com.android.messaging.util.OsUtil;
+import com.android.messaging.util.PhoneUtils;
+import com.android.messaging.smil.view.SmileditPar;
+import com.android.messaging.smil.view.TextImage;
+import com.google.common.base.Joiner;
+
+import android.app.ActivityManager;
+
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collection;
+import java.util.GregorianCalendar;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+
+//489220 begin
+import android.database.DatabaseUtils;
+import android.provider.Settings;
+import android.provider.Telephony;
+import android.provider.Telephony.Mms;
+import android.provider.Telephony.Mms.Addr;
+import com.android.messaging.mmslib.pdu.DeliveryInd;
+import com.android.messaging.mmslib.pdu.ReadOrigInd;
+import com.android.messaging.mmslib.pdu.ReadRecInd;
+//489220 end
+import com.android.messaging.smil.data.SmilPartEntity;
+
+import android.util.Log;
+
+import com.sprd.messaging.drm.MessagingDrmSession;
+//import com.android.internal.telephony.ISms;
+import com.android.internal.telephony.ISub;
+
+import android.telephony.TelephonyManager;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+
+import java.util.Iterator;
+
+import com.sprd.messaging.util.SmsMessageAdapter;
+import com.sprd.messaging.util.SystemAdapter;
+import com.sprd.messaging.util.Utils;
+
+/**
+ * Utils for sending sms/mms messages.
+ */
+public class MmsUtils {
+    private static final String TAG = LogUtil.BUGLE_TAG;
+
+    public static final boolean DEFAULT_DELIVERY_REPORT_MODE  = false;
+    public static final boolean DEFAULT_READ_REPORT_MODE = false;
+    public static final long DEFAULT_EXPIRY_TIME_IN_SECONDS = 7 * 24 * 60 * 60;
+    public static final int DEFAULT_PRIORITY = PduHeaders.PRIORITY_NORMAL;
+    private static final int ATTACHMENT_EXCEEDED_SIZE = 10*1024*1024;
+
+    public static final int MAX_SMS_RETRY = 3;
+    // 489220 begin
+    public static final String NOTIFY_SHOW_MMS_REPORT_ACTION = "com.sprd.notify_show_mms_report_action";
+    public static final String NOTIFY_SHOW_MMS_SMS_REPORT_ACTION ="com.sprd.notify_show_mms_sms_report_action";
+    //489220 end
+
+    /**
+     * MMS request succeeded
+     */
+    public static final int MMS_REQUEST_SUCCEEDED = 0;
+    /**
+     * MMS request failed with a transient error and can be retried automatically
+     */
+    public static final int MMS_REQUEST_AUTO_RETRY = 1;
+    /**
+     * MMS request failed with an error and can be retried manually
+     */
+    public static final int MMS_REQUEST_MANUAL_RETRY = 2;
+    /**
+     * MMS request failed with a specific error and should not be retried
+     */
+    public static final int MMS_REQUEST_NO_RETRY = 3;
+
+    public static final String getRequestStatusDescription(final int status) {
+        switch (status) {
+            case MMS_REQUEST_SUCCEEDED:
+                return "SUCCEEDED";
+            case MMS_REQUEST_AUTO_RETRY:
+                return "AUTO_RETRY";
+            case MMS_REQUEST_MANUAL_RETRY:
+                return "MANUAL_RETRY";
+            case MMS_REQUEST_NO_RETRY:
+                return "NO_RETRY";
+            default:
+                return String.valueOf(status) + " (check MmsUtils)";
+        }
+    }
+
+    public static final int PDU_HEADER_VALUE_UNDEFINED = 0;
+
+    private static final int DEFAULT_DURATION = 0; //ms//sprd 600980
+
+    // amount of space to leave in a MMS for text and overhead.
+    private static final int MMS_MAX_SIZE_SLOP = 1024;
+    public static final long INVALID_TIMESTAMP = 0L;
+    private static String[] sNoSubjectStrings;
+
+    public static class MmsInfo {
+        public Uri mUri;
+        public int mMessageSize;
+        public PduBody mPduBody;
+    }
+
+    // Sync all remote messages apart from drafts
+    private static final String REMOTE_SMS_SELECTION = String.format(
+            Locale.US,
+            "(%s IN (%d, %d, %d, %d, %d))",
+            Sms.TYPE,
+            Sms.MESSAGE_TYPE_INBOX,
+            Sms.MESSAGE_TYPE_OUTBOX,
+            Sms.MESSAGE_TYPE_QUEUED,
+            Sms.MESSAGE_TYPE_FAILED,
+            Sms.MESSAGE_TYPE_SENT);
+
+    private static final String REMOTE_MMS_SELECTION = String.format(
+            Locale.US,
+            "((%s IN (%d, %d, %d, %d)) AND (%s IN (%d, %d, %d)))",
+            Mms.MESSAGE_BOX,
+            Mms.MESSAGE_BOX_INBOX,
+            Mms.MESSAGE_BOX_OUTBOX,
+            Mms.MESSAGE_BOX_SENT,
+            Mms.MESSAGE_BOX_FAILED,
+            Mms.MESSAGE_TYPE,
+            PduHeaders.MESSAGE_TYPE_SEND_REQ,
+            PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND,
+            PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF);
+
+    /**
+     * Type selection for importing sms messages.
+     *
+     * @return The SQL selection for importing sms messages
+     */
+    public static String getSmsTypeSelectionSql() {
+        return REMOTE_SMS_SELECTION;
+    }
+
+    /**
+     * Type selection for importing mms messages.
+     *
+     * @return The SQL selection for importing mms messages. This selects the message type,
+     * not including the selection on timestamp.
+     */
+    public static String getMmsTypeSelectionSql() {
+        return REMOTE_MMS_SELECTION;
+    }
+
+    // SMIL spec: http://www.w3.org/TR/SMIL3
+
+    private static final String sSmilImagePart =
+            "<par dur=\"" + DEFAULT_DURATION + "ms\">" +
+                "<img src=\"%s\" region=\"Image\" />" +
+            "</par>";
+
+    private static final String sSmilVideoPart =
+            "<par dur=\"%2$dms\">" +
+                "<video src=\"%1$s\" dur=\"%2$dms\" region=\"Image\" />" +
+            "</par>";
+
+    private static final String sSmilAudioPart =
+            "<par dur=\"%2$dms\">" +
+                    "<audio src=\"%1$s\" dur=\"%2$dms\" />" +
+            "</par>";
+
+    private static final String sSmilTextPart =
+            "<par dur=\"" + DEFAULT_DURATION + "ms\">" +
+                "<text src=\"%s\" region=\"Text\" />" +
+            "</par>";
+
+    private static final String sSmilPart =
+            "<par dur=\"" + DEFAULT_DURATION + "ms\">" +
+                "<ref src=\"%s\" />" +
+            "</par>";
+
+    private static final String sSmilTextOnly =
+            "<smil>" +
+                "<head>" +
+                    "<layout>" +
+                        "<root-layout/>" +
+                        "<region id=\"Text\" top=\"0\" left=\"0\" "
+                          + "height=\"100%%\" width=\"100%%\"/>" +
+                    "</layout>" +
+                "</head>" +
+                "<body>" +
+                       "%s" +  // constructed body goes here
+                "</body>" +
+            "</smil>";
+
+    private static final String sSmilVisualAttachmentsOnly =
+            "<smil>" +
+                "<head>" +
+                    "<layout>" +
+                        "<root-layout/>" +
+                        "<region id=\"Image\" fit=\"meet\" top=\"0\" left=\"0\" "
+                          + "height=\"100%%\" width=\"100%%\"/>" +
+                    "</layout>" +
+                "</head>" +
+                "<body>" +
+                       "%s" +  // constructed body goes here
+                "</body>" +
+            "</smil>";
+
+    private static final String sSmilVisualAttachmentsWithText =
+            "<smil>" +
+                "<head>" +
+                    "<layout>" +
+                        "<root-layout/>" +
+                        "<region id=\"Image\" fit=\"meet\" top=\"0\" left=\"0\" "
+                          + "height=\"80%%\" width=\"100%%\"/>" +
+                        "<region id=\"Text\" top=\"80%%\" left=\"0\" height=\"20%%\" "
+                          + "width=\"100%%\"/>" +
+                    "</layout>" +
+                "</head>" +
+                "<body>" +
+                       "%s" +  // constructed body goes here
+                "</body>" +
+            "</smil>";
+
+    private static final String sSmilVisualAttachmentsWithTextTop =
+            "<smil>" +
+                "<head>" +
+                    "<layout>" +
+                        "<root-layout/>" +
+                        "<region id=\"Text\"  top=\"0\" left=\"0\" height=\"20%%\" "
+                          + "width=\"100%%\"/>" +
+                        "<region id=\"Image\" fit=\"meet\"  top=\"20%%\" left=\"0\" "
+                          + "height=\"80%%\" width=\"100%%\"/>" +
+                    "</layout>" +
+                "</head>" +
+                "<body>" +
+                       "%s" +  // constructed body goes here
+                "</body>" +
+            "</smil>";
+
+
+    private static final String sSmilNonVisualAttachmentsOnly =
+            "<smil>" +
+                "<head>" +
+                    "<layout>" +
+                        "<root-layout/>" +
+                    "</layout>" +
+                "</head>" +
+                "<body>" +
+                       "%s" +  // constructed body goes here
+                "</body>" +
+            "</smil>";
+
+    private static final String sSmilNonVisualAttachmentsWithText = sSmilTextOnly;
+
+    public static final String MMS_DUMP_PREFIX = "mmsdump-";
+    public static final String SMS_DUMP_PREFIX = "smsdump-";
+
+    public static final int MIN_VIDEO_BYTES_PER_SECOND = 4 * 1024;
+    public static final int MIN_IMAGE_BYTE_SIZE = 16 * 1024;
+    public static final int MAX_VIDEO_ATTACHMENT_COUNT = 1;
+
+    private static final String sSmilPartHeader = "<par dur=\"" + DEFAULT_DURATION + "ms\">";
+    private static final String sSmilPartTail = "</par>";
+    private static final String sSmilImage = "<img src=\"%s\" region=\"Image\" />";
+    private static final String sSmilVideo = "<video src=\"%1$s\" dur=\"%2$dms\" region=\"Image\" />";
+    private static final String sSmilAudio = "<audio src=\"%1$s\" dur=\"%2$dms\" />";
+    private static final String sSmilText = "<text src=\"%s\" region=\"Text\" />";
+    private static final String sSmil = "<ref src=\"%s\" />";
+
+    private static int getPictureLength(final Context context, final MessagePartData messagePart,
+            int widthLimit, int heightLimit, final int maxPartSize, final String contentType) {
+        final Uri imageUri = messagePart.getContentUri();
+        int width = messagePart.getWidth();
+        int height = messagePart.getHeight();
+       // BitmapFactory.Options options = new BitmapFactory.Options();
+       // options.inJustDecodeBounds = true;
+       // BitmapFactory.decodeFile(new File(imageUri.getPath()).getAbsolutePath(), options);
+		//sprd 600980 start
+//        final int width = options.outWidth;
+//        final int height = options.outHeight;
+       // final int width = options.outWidth == 0 ? messagePart.getWidth() : options.outWidth;
+        //final int height = options.outHeight == 0 ? messagePart.getHeight() : options.outHeight;
+		//sprd 600980 end
+        //sprd 623241 start
+        if(width==-1||height==-1){
+            setImageWidthHeight(messagePart,imageUri);
+            width = messagePart.getWidth();
+            height = messagePart.getHeight();
+        }
+        //sprd 623241 end
+        if ((height > width) != (heightLimit > widthLimit)) {
+            final int temp = widthLimit;
+            widthLimit = heightLimit;
+            heightLimit = temp;
+        }
+
+        final int orientation = ImageUtils.getOrientation(context, imageUri);
+        int imageSize = getDataLength(context, imageUri);
+        if (imageSize <= 0) {
+            Log.e("smil-s", "getPictureLength: Can't get image", new Exception());
+            return 0;
+        }
+
+        Log.d("smil-s", "getPictureLength: source size: " + imageSize + " width: " + width + " widthLimit: "
+                + widthLimit + " height: " + height + " heightLimit: " + heightLimit + ", imageUri:" + imageUri);
+
+        if((imageSize > ATTACHMENT_EXCEEDED_SIZE)||(contentType==ContentType.IMAGE_GIF))
+            return imageSize;
+
+        if (imageSize <= maxPartSize
+                && width <= widthLimit
+                && height <= heightLimit
+                && (orientation == android.media.ExifInterface.ORIENTATION_UNDEFINED || orientation == android.media.ExifInterface.ORIENTATION_NORMAL)) {
+            Log.d("smil-s", "getPictureLength: already sized");
+            return imageSize;
+        } else {
+            final byte[] data = ImageResizer.getResizedImageData(width, height, orientation,
+                    widthLimit, heightLimit, maxPartSize, imageUri, context, contentType);
+            if (data == null) {
+                final OutOfMemoryError e = new OutOfMemoryError();
+                Log.e("smil-s", "getPictureLength: Can't resize image: not enough memory?", e);
+                return imageSize;
+            }
+            Log.d("smil-s", "getPictureLength: resize = " + data.length);
+            return data.length;
+        }
+    }
+
+    public static long getAttachmentsLength(final Context context,
+            final DraftMessageData draftMsgData) {
+        final PduBody pb = new PduBody();
+
+        long totalLength = 0;
+        int countImage = 0;
+        for (final MessagePartData part : draftMsgData.getAttachments()) {
+            if (part.isAttachment()) {
+                final String contentType = part.getContentType();
+                if (ContentType.isImageType(contentType)) {
+                    countImage++;
+                } else if (ContentType.isVCardType(contentType)) {
+                    totalLength += getDataLength(context, part.getContentUri());
+                } else if(part.getContentUri() != null  && !part.getContentUri().equals("")){
+                    totalLength += getMediaFileSize(part.getContentUri());
+                }
+            }
+        }
+        final long minSize = countImage * MIN_IMAGE_BYTE_SIZE;
+        //should be the with getAttachmentsLength(), so just take the default value.
+//      final int byteBudget = MmsConfig.get(subId).getMaxMessageSize() - totalLength
+//              - MMS_MAX_SIZE_SLOP;
+      final long byteBudget = CarrierConfigValuesLoader.CONFIG_MAX_MESSAGE_SIZE_DEFAULT
+              - totalLength - MMS_MAX_SIZE_SLOP;
+        final double budgetFactor = minSize > 0 ? Math.max(1.0, byteBudget / ((double) minSize))
+                : 1;
+        final int bytesPerImage = MmsConfig.getMaxMaxMessageSize();//(int) (budgetFactor * MIN_IMAGE_BYTE_SIZE);
+        
+        //draft message ignore which subid, so just take the default value.
+//      final int widthLimit = MmsConfig.get(subId).getMaxImageWidth();
+//      final int heightLimit = MmsConfig.get(subId).getMaxImageHeight();
+        final int widthLimit = CarrierConfigValuesLoader.CONFIG_MAX_IMAGE_WIDTH_DEFAULT;
+        final int heightLimit = CarrierConfigValuesLoader.CONFIG_MAX_IMAGE_HEIGHT_DEFAULT;
+
+        // Actually add the attachments, shrinking images appropriately.
+        totalLength = 0;
+
+        for (final MessagePartData part : draftMsgData.getAttachments()) {
+            String contentType = part.getContentType();
+            Log.d("smil-s", "MmsUtils.getAttachmentsLength: contentType="+contentType+".........begin");
+            long attachmentSize = 0;
+            if (ContentType.isImageType(contentType)) {
+                final boolean isGif = ImageUtils.isGif(contentType, part.getContentUri());
+                contentType = isGif ? ContentType.IMAGE_GIF : contentType;
+                attachmentSize = getPictureLength(context, part, widthLimit, heightLimit,
+                        bytesPerImage, contentType);
+            } else if (ContentType.isVideoType(contentType)) {
+                attachmentSize = getMediaFileSize(part.getContentUri());
+            } else if (ContentType.isVCardType(contentType)) {
+                attachmentSize = getDataLength(context, part.getContentUri());
+            } else if (ContentType.isAudioType(contentType)) {
+                attachmentSize =  getMediaFileSize(part.getContentUri());
+            } else if (ContentType.isVcalendarType(contentType)) {
+                attachmentSize = getDataLength(context, part.getContentUri());
+            } else if (ContentType.isTextType(contentType)) {
+                final String text = part.getText();
+                if (text != null) {
+                    attachmentSize = text.getBytes().length;
+                }
+            } else if(part.getContentUri() != null){
+                attachmentSize = getMediaFileSize(part.getContentUri());
+            }
+            part.setmAttachmetSize(attachmentSize);
+            totalLength += attachmentSize;
+        }
+        return totalLength;
+    }
+
+    public static long getAttachmentsLength(final Context context,
+            final List<MessagePartData> draftMsgAttachements) {
+        final PduBody pb = new PduBody();
+
+        long totalLength = 0;
+        int countImage = 0;
+        for (final MessagePartData part : draftMsgAttachements) {
+            if (part.isAttachment()) {
+                final String contentType = part.getContentType();
+                if (ContentType.isImageType(contentType)) {
+                    countImage++;
+                } else if (ContentType.isVCardType(contentType)) {
+                    totalLength += getDataLength(context, part.getContentUri());
+                } else if(part.getContentUri() != null  && !part.getContentUri().equals("")){
+                    totalLength += getMediaFileSize(part.getContentUri());
+                }
+            }
+        }
+        final long minSize = countImage * MIN_IMAGE_BYTE_SIZE;
+        //should be the with getAttachmentsLength(), so just take the default value.
+//      final int byteBudget = MmsConfig.get(subId).getMaxMessageSize() - totalLength
+//              - MMS_MAX_SIZE_SLOP;
+      final long byteBudget = CarrierConfigValuesLoader.CONFIG_MAX_MESSAGE_SIZE_DEFAULT
+              - totalLength - MMS_MAX_SIZE_SLOP;
+        final double budgetFactor = minSize > 0 ? Math.max(1.0, byteBudget / ((double) minSize))
+                : 1;
+        final int bytesPerImage = MmsConfig.getMaxMaxMessageSize();//(int) (budgetFactor * MIN_IMAGE_BYTE_SIZE);
+
+        //draft message ignore which subid, so just take the default value.
+//      final int widthLimit = MmsConfig.get(subId).getMaxImageWidth();
+//      final int heightLimit = MmsConfig.get(subId).getMaxImageHeight();
+        final int widthLimit = CarrierConfigValuesLoader.CONFIG_MAX_IMAGE_WIDTH_DEFAULT;
+        final int heightLimit = CarrierConfigValuesLoader.CONFIG_MAX_IMAGE_HEIGHT_DEFAULT;
+
+        // Actually add the attachments, shrinking images appropriately.
+        totalLength = 0;
+
+        for (final MessagePartData part : draftMsgAttachements) {
+            String contentType = part.getContentType();
+            Log.d("smil-s", "MmsUtils.getAttachmentsLength: contentType="+contentType+".........begin"+" part.getContentUri():"+part.getContentUri());
+            Uri uri=part.getContentUri();
+            String scheme;
+            String authority;
+            if (ContentType.isImageType(contentType)) {
+                final boolean isGif = ImageUtils.isGif(contentType, part.getContentUri());
+                // add for bug 616653  start
+                scheme=uri.getScheme();
+                authority=uri.getAuthority();
+                if (isGif&&("content".equalsIgnoreCase(scheme))&&("com.android.externalstorage.documents".equals(authority))){
+                    totalLength +=getTotalLength(uri,context);
+                }else{
+                    totalLength += isGif ? getMediaFileSize(part.getContentUri()) : getPictureLength(context, part, widthLimit, heightLimit,
+                            bytesPerImage, contentType);
+                }
+                // add for bug 616653  end
+            } else if (ContentType.isVideoType(contentType)) {
+                // add for bug 620391  start
+                scheme=uri.getScheme();
+                authority=uri.getAuthority();
+                if (("content".equalsIgnoreCase(scheme))&&("com.android.externalstorage.documents".equals(authority))){
+                    totalLength +=getTotalLength(uri,context);
+                }else{
+                    totalLength += getMediaFileSize(part.getContentUri());
+                }
+                // add for bug 620391  end
+            } else if (ContentType.isVCardType(contentType)) {
+                //totalLength += getDataLength(context, part.getContentUri());
+            } else if (ContentType.isAudioType(contentType)) {
+                // add for bug 620391  start
+                scheme=uri.getScheme();
+                authority=uri.getAuthority();
+                if (("content".equalsIgnoreCase(scheme))&&("com.android.externalstorage.documents".equals(authority))){
+                    totalLength +=getTotalLength(uri,context);
+                }else{
+                    totalLength +=  getMediaFileSize(part.getContentUri());
+                }
+                // add for bug 620391  end
+            } else if (ContentType.isVcalendarType(contentType)) {
+                totalLength += getDataLength(context, part.getContentUri());
+            } else if (ContentType.isTextType(contentType)) {
+                final String text = part.getText();
+                if (text != null) {
+                    totalLength += text.getBytes().length;
+                }
+            } else if(part.getContentUri() != null){
+                totalLength +=  getMediaFileSize(part.getContentUri());
+            }
+        }
+        return totalLength;
+    }
+
+    /**add for Bug 558980 begin*/
+    public static int getPartsLength(final Context context,
+                                     final ConversationMessageData data) {
+        final PduBody pb = new PduBody();
+        int index = 0;
+        int totalLength = 0;
+        int countImage = 0;
+        for (final MessagePartData part : data.getParts()) {
+            if (part.isAttachment()) {
+                final String contentType = part.getContentType();
+                if (ContentType.isImageType(contentType)) {
+                    countImage++;
+                } else if (ContentType.isVCardType(contentType)) {
+                    totalLength += getDataLength(context, part.getContentUri());
+                } else if(part.getContentUri() != null  && !part.getContentUri().equals("")){
+                    totalLength += getMediaFileSize(part.getContentUri());
+                }
+            }
+        }
+        final long minSize = countImage * MIN_IMAGE_BYTE_SIZE;
+        //should be the with getAttachmentsLength(), so just take the default value.
+//      final int byteBudget = MmsConfig.get(subId).getMaxMessageSize() - totalLength
+//              - MMS_MAX_SIZE_SLOP;
+        final int byteBudget = CarrierConfigValuesLoader.CONFIG_MAX_MESSAGE_SIZE_DEFAULT
+                - totalLength - MMS_MAX_SIZE_SLOP;
+        final double budgetFactor = minSize > 0 ? Math.max(1.0, byteBudget / ((double) minSize))
+                : 1;
+        final int bytesPerImage = MmsConfig.getMaxMaxMessageSize();//(int) (budgetFactor * MIN_IMAGE_BYTE_SIZE);
+
+        //draft message ignore which subid, so just take the default value.
+//      final int widthLimit = MmsConfig.get(subId).getMaxImageWidth();
+//      final int heightLimit = MmsConfig.get(subId).getMaxImageHeight();
+        final int widthLimit = CarrierConfigValuesLoader.CONFIG_MAX_IMAGE_WIDTH_DEFAULT;
+        final int heightLimit = CarrierConfigValuesLoader.CONFIG_MAX_IMAGE_HEIGHT_DEFAULT;
+
+        // Actually add the attachments, shrinking images appropriately.
+        totalLength = 0;
+        boolean hasText = false;
+        for (final MessagePartData part : data.getParts()) {
+            String srcName;
+            if (part.isAttachment()) {
+                String contentType = part.getContentType();
+                if (ContentType.isImageType(contentType)) {
+                    // There's a good chance that if we selected the image from our media picker the
+                    // content type is image/*. Fix the content type here for gifs so that we only
+                    // need to open the input stream once. All other gif vs static image checks will
+                    // only have to do a string comparison which is much cheaper.
+                    final boolean isGif = ImageUtils.isGif(contentType, part.getContentUri());
+                    contentType = isGif ? ContentType.IMAGE_GIF : contentType;
+                    srcName = String.format(isGif ? "image%06d.gif" : "image%06d.jpg", index);
+                    totalLength += isGif ? getDataLength(context, part.getContentUri()):addPicturePart(context, pb, index, part,
+                            widthLimit, heightLimit, bytesPerImage, srcName, contentType);
+                } else if (ContentType.isVideoType(contentType)) {
+                    srcName = String.format("video%06d.mp4", index);
+                    final int length = addVideoPart(context, pb, part, srcName);
+                    totalLength += length;
+                } else if (ContentType.isVCardType(contentType)) {
+                    srcName = String.format("contact%06d.vcf", index);
+                    totalLength += addVCardPart(context, pb, part, srcName);
+                } else if (ContentType.isAudioType(contentType)) {
+                    srcName = String.format("recording%06d.amr", index);
+                    totalLength += addOtherPart(context, pb, part, srcName);
+                    final int duration = getMediaDurationMs(context, part, -1);
+                    Assert.isTrue(duration != -1);
+                } else if (ContentType.isVcalendarType(contentType)) {
+                    srcName = String.format("calendar%06d.vcs", index);
+                    totalLength += addVCalendarPart(context, pb, part, srcName);
+                } else {
+                    srcName = String.format("other%06d.dat", index);
+                    totalLength += addOtherPart(context, pb, part, srcName);
+                }
+                index++;
+            }
+            if (!TextUtils.isEmpty(part.getText())) {
+                hasText = true;
+            }
+        }
+
+        if (hasText) {
+            final String srcName = String.format("text.%06d.txt", index);
+            final String text = getMessageText(data.getParts());
+            totalLength += addTextPart(context, pb, text, srcName);
+        }
+        return totalLength;
+    }
+    /**add for Bug 558980 end*/
+
+    /**add for Bug 558980 begin*/
+    private final static String getMessageText(List<MessagePartData> parts) {
+        final String separator = System.getProperty("line.separator");
+        final StringBuilder text = new StringBuilder();
+        for (final MessagePartData part : parts) {
+            if (!part.isAttachment() && !TextUtils.isEmpty(part.getText()) && ContentType.isTextType(part.getContentType())) {
+                if (text.length() > 0) {
+                    text.append(separator);
+                }
+                text.append(part.getText());
+            }
+        }
+        return text.toString();
+    }
+    /**add for Bug 558980 end*/
+
+    public static String createSmilText(final Context context, List<SmilPartEntity> smileditPars){
+        final StringBuilder smilBody = new StringBuilder();
+        String srcName;
+        boolean hasVisualAttachment = false;
+        boolean hasNonVisualAttachment = false;
+        boolean hasTextAttachment = false;
+        int index = 0;
+        boolean textTop = true;
+        if (smileditPars == null || smileditPars.size() == 0) {
+            final String smil = String.format(sSmilTextOnly, smilBody.toString());
+            Log.d("smil-s", "MmsUtils.createSmilText: smil="+smil);
+            return smil;
+        }
+        for (final SmilPartEntity smilPart : smileditPars) {
+            if (smilPart == null) {
+                Log.d("smil-s", "MmsUtils.createSmilText: smilPart.getList() is null, continue.");
+                continue;
+            }
+            smilBody.append(sSmilPartHeader);
+            for (MessagePartData part : smilPart) {
+                String contentType = part.getContentType();
+                Log.d("smil-s", "MmsUtils.createSmilText: contentType="+contentType+"-----begin");
+                if (ContentType.isImageType(contentType)) {
+                    final boolean isGif = ImageUtils.isGif(contentType, part.getContentUri());
+                    contentType = isGif ? ContentType.IMAGE_GIF : contentType;
+                    srcName = String.format(isGif ? "image%06d.gif" : "image%06d.jpg", index);
+                    smilBody.append(String.format(sSmilImage, srcName));
+                    hasVisualAttachment = true;
+                    if (hasTextAttachment){
+                        textTop = textTop & true;
+                        Log.d("smil-s", " image = true");
+                    } else {
+                        textTop = textTop & false;
+                        Log.d("smil-s", " image = false");
+                    }
+                    Log.d("smil-s", "MmsUtils.createSmilText: srcName="+srcName);
+                } else if (ContentType.isVideoType(contentType)) {
+                    srcName = String.format("video%06d.mp4", index);
+                    smilBody.append(String.format(sSmilVideo, srcName,
+                            getMediaDurationMs(context, part, DEFAULT_DURATION)));
+                    hasVisualAttachment = true;
+                    if (hasTextAttachment){
+                        textTop = textTop & true;
+                        Log.d("smil-s", " vedio = true");
+                      }
+                    else{
+                        textTop = textTop & false;
+                        Log.d("smil-s", " vedio = false");
+                    }
+                    Log.d("smil-s", "MmsUtils.createSmilText: srcName="+srcName);
+                } else if (ContentType.isVCardType(contentType)) {
+                    srcName = String.format("contact%06d.vcf", index);
+                    smilBody.append(String.format(sSmil, srcName));
+                    hasNonVisualAttachment = true;
+                    Log.d("smil-s", "MmsUtils.createSmilText: srcName="+srcName);
+                } else if (ContentType.isAudioType(contentType)) {
+                    srcName = String.format("recording%06d.amr", index);
+                    final int duration = getMediaDurationMs(context, part, -1);
+                    smilBody.append(String.format(sSmilAudio, srcName, duration));
+                    hasNonVisualAttachment = true;
+                    if (hasTextAttachment) {
+                        textTop = textTop & true;
+                        Log.d("smil-s", " audio = true");
+                    } else {
+                        textTop = textTop & false;
+                        Log.d("smil-s", " audio = false");
+                    }
+                    Log.d("smil-s", "MmsUtils.createSmilText: srcName="+srcName);
+                } else if (ContentType.isVcalendarType(contentType)) {
+                    srcName = String.format("calendar%06d.vcs", index);
+                    smilBody.append(String.format(sSmil, srcName));
+                    hasNonVisualAttachment = true;
+                    Log.d("smil-s", "MmsUtils.createSmilText: srcName="+srcName);
+                } else if (ContentType.isTextType(contentType)) {
+                    srcName = String.format("text.%06d.txt", index);
+                    smilBody.append(String.format(sSmilText, srcName));
+                    hasTextAttachment = true;
+                    Log.d("smil-s", "MmsUtils.createSmilText: srcName="+srcName);
+                } else {
+                    srcName = String.format("other%06d.dat", index);
+                    smilBody.append(String.format(sSmil, srcName));
+                    Log.d("smil-s", "MmsUtils.createSmilText: srcName="+srcName);
+                }
+                index++;
+            }
+            smilBody.append(sSmilPartTail);
+        }
+
+        Log.d("smil-s", " textTop="+textTop +"   hasTextAttachment=["+hasTextAttachment+"]");
+        final String smilTemplate = getSmilTemplate(hasVisualAttachment,
+                hasNonVisualAttachment, hasTextAttachment, textTop);
+        return String.format(smilTemplate, smilBody.toString());
+    }
+    
+    public static MmsInfo makePduBodyEx(final Context context, final MessageData message,
+            final int subId, final String smil) {
+        final PduBody pb = new PduBody();
+
+        // Compute data size requirements for this message: count up images and
+        // total size of
+        // non-image attachments.
+        int totalLength = 0;
+        int countImage = 0;
+        for (final MessagePartData part : message.getParts()) {
+            if (part.isAttachment()) {
+                final String contentType = part.getContentType();
+                if (ContentType.isImageType(contentType)) {
+                    countImage++;
+                } else if (ContentType.isVCardType(contentType)) {
+                    totalLength += getDataLength(context, part.getContentUri());
+                } else {
+                    totalLength += getMediaFileSize(part.getContentUri());
+                }
+            }
+        }
+        final long minSize = countImage * MIN_IMAGE_BYTE_SIZE;
+        //should be the with getAttachmentsLength(), so just take the default value.
+//        final int byteBudget = MmsConfig.get(subId).getMaxMessageSize() - totalLength
+//                - MMS_MAX_SIZE_SLOP;
+        final int byteBudget = CarrierConfigValuesLoader.CONFIG_MAX_MESSAGE_SIZE_DEFAULT
+                - totalLength - MMS_MAX_SIZE_SLOP;
+        final double budgetFactor = minSize > 0 ? Math.max(1.0, byteBudget / ((double) minSize))
+                : 1;
+        final int bytesPerImage = MmsConfig.getMaxMaxMessageSize();//(int) (budgetFactor * MIN_IMAGE_BYTE_SIZE);
+//        final int widthLimit = MmsConfig.get(subId).getMaxImageWidth();
+//        final int heightLimit = MmsConfig.get(subId).getMaxImageHeight();
+        //should be the with getAttachmentsLength(), so just take the default value.
+        final int widthLimit = CarrierConfigValuesLoader.CONFIG_MAX_IMAGE_WIDTH_DEFAULT;
+        final int heightLimit = CarrierConfigValuesLoader.CONFIG_MAX_IMAGE_HEIGHT_DEFAULT;
+
+        // Actually add the attachments, shrinking images appropriately.
+        int index = 0;
+        totalLength = 0;
+
+        for (final MessagePartData part : message.getParts()) {
+            String srcName;
+            String contentType = part.getContentType();
+            Log.d("smil-s", "MmsUtils.makePduBodyEx: contentType="+contentType+"==========begin");
+            if (ContentType.isImageType(contentType)) {
+                final boolean isGif = ImageUtils.isGif(contentType, part.getContentUri());
+                contentType = isGif ? ContentType.IMAGE_GIF : contentType;
+                srcName = String.format(isGif ? "image%06d.gif" : "image%06d.jpg", index);
+                totalLength += addPicturePart(context, pb, index, part, widthLimit, heightLimit,
+                        bytesPerImage, srcName, contentType);
+                Log.d("smil-s", "MmsUtils.makePduBodyEx: srcName="+srcName);
+            } else if (ContentType.isVideoType(contentType)) {
+                srcName = String.format("video%06d.mp4", index);
+                final int length = addVideoPart(context, pb, part, srcName);
+                totalLength += length;
+                Log.d("smil-s", "MmsUtils.makePduBodyEx: srcName="+srcName);
+            } else if (ContentType.isVCardType(contentType)) {
+                srcName = String.format("contact%06d.vcf", index);
+                totalLength += addVCardPart(context, pb, part, srcName);
+                Log.d("smil-s", "MmsUtils.makePduBodyEx: srcName="+srcName);
+            } else if (ContentType.isAudioType(contentType)) {
+                srcName = String.format("recording%06d.amr", index);
+                totalLength += addOtherPart(context, pb, part, srcName);
+                final int duration = getMediaDurationMs(context, part, -1);
+                Assert.isTrue(duration != -1);
+                Log.d("smil-s", "MmsUtils.makePduBodyEx: srcName="+srcName);
+            } else if (ContentType.isVcalendarType(contentType)) {
+                srcName = String.format("calendar%06d.vcs", index);
+                totalLength += addVCalendarPart(context, pb, part, srcName);
+                Log.d("smil-s", "MmsUtils.makePduBodyEx: srcName="+srcName);
+            } else if (ContentType.isTextType(contentType)) {
+                srcName = String.format("text.%06d.txt", index);
+                final String text = part.getText();
+                totalLength += addTextPart(context, pb, text, srcName);
+                Log.d("smil-s", "MmsUtils.makePduBodyEx: srcName="+srcName);
+            } else {
+                srcName = String.format("other%06d.dat", index);
+                totalLength += addOtherPart(context, pb, part, srcName);
+                Log.d("smil-s", "MmsUtils.makePduBodyEx: srcName="+srcName);
+            }
+            index++;
+        }
+
+        addSmilPartEx(pb, smil);
+
+        final MmsInfo mmsInfo = new MmsInfo();
+        mmsInfo.mPduBody = pb;
+        mmsInfo.mMessageSize = totalLength;
+
+        return mmsInfo;
+    }
+
+    private static void addSmilPartEx(final PduBody pb, String smil) {
+        final PduPart smilPart = new PduPart();
+        smilPart.setContentId("smil".getBytes());
+        smilPart.setContentLocation("smil.xml".getBytes());
+        smilPart.setContentType(ContentType.APP_SMIL.getBytes());
+        smilPart.setData(smil.getBytes());
+        pb.addPart(0, smilPart);
+    }
+
+    public static MmsInfo makePduBody(final Context context, final MessageData message,
+            final int subId) {
+        final PduBody pb = new PduBody();
+        boolean textTop = false;
+        // Compute data size requirements for this message: count up images and total size of
+        // non-image attachments.
+        int totalLength = 0;
+        int countImage = 0;
+        for (final MessagePartData part : message.getParts()) {
+            if (part.isAttachment()) {
+                final String contentType = part.getContentType();
+                if (ContentType.isImageType(contentType)) {
+                    countImage++;
+                } else if (ContentType.isVCardType(contentType)) {
+                    totalLength += getDataLength(context, part.getContentUri());
+                } else {
+                    totalLength += getMediaFileSize(part.getContentUri());
+                }
+            }
+        }
+        final long minSize = countImage * MIN_IMAGE_BYTE_SIZE;
+        final int byteBudget = MmsConfig.get(subId).getMaxMessageSize() - totalLength
+                - MMS_MAX_SIZE_SLOP;
+        final double budgetFactor =
+                minSize > 0 ? Math.max(1.0, byteBudget / ((double) minSize)) : 1;
+        final int bytesPerImage = MmsConfig.getMaxMaxMessageSize();//(int) (budgetFactor * MIN_IMAGE_BYTE_SIZE);
+        final int widthLimit = MmsConfig.get(subId).getMaxImageWidth();
+        final int heightLimit = MmsConfig.get(subId).getMaxImageHeight();
+
+        // Actually add the attachments, shrinking images appropriately.
+        int index = 0;
+        totalLength = 0;
+        boolean hasVisualAttachment = false;
+        boolean hasNonVisualAttachment = false;
+        boolean hasText = false;
+        final StringBuilder smilBody = new StringBuilder();
+        for (final MessagePartData part : message.getParts()) {
+            String srcName;
+            if (part.isAttachment()) {
+                String contentType = part.getContentType();
+                if (ContentType.isImageType(contentType)) {
+                    // There's a good chance that if we selected the image from our media picker the
+                    // content type is image/*. Fix the content type here for gifs so that we only
+                    // need to open the input stream once. All other gif vs static image checks will
+                    // only have to do a string comparison which is much cheaper.
+                    final boolean isGif = ImageUtils.isGif(contentType, part.getContentUri());
+                    contentType = isGif ? ContentType.IMAGE_GIF : contentType;
+                    srcName = String.format(isGif ? "image%06d.gif" : "image%06d.jpg", index);
+                    smilBody.append(String.format(sSmilImagePart, srcName));
+                    totalLength += addPicturePart(context, pb, index, part,
+                            widthLimit, heightLimit, bytesPerImage, srcName, contentType);
+                    hasVisualAttachment = true;
+                    if (hasText){
+                         textTop = true;
+                    }
+                } else if (ContentType.isVideoType(contentType)) {
+                    srcName = String.format("video%06d.mp4", index);
+                    final int length = addVideoPart(context, pb, part, srcName);
+                    totalLength += length;
+                    smilBody.append(String.format(sSmilVideoPart, srcName,
+                            getMediaDurationMs(context, part, DEFAULT_DURATION)));
+                    hasVisualAttachment = true;
+                    if (hasText){
+                         textTop = true;
+                    }
+                } else if (ContentType.isVCardType(contentType)) {
+                    srcName = String.format("contact%06d.vcf", index);
+                    totalLength += addVCardPart(context, pb, part, srcName);
+                    smilBody.append(String.format(sSmilPart, srcName));
+                    hasNonVisualAttachment = true;
+                } else if (ContentType.isAudioType(contentType)) {
+                    srcName = String.format("recording%06d.amr", index);
+                    totalLength += addOtherPart(context, pb, part, srcName);
+                    final int duration = getMediaDurationMs(context, part, -1);
+                    Assert.isTrue(duration != -1);
+                    smilBody.append(String.format(sSmilAudioPart, srcName, duration));
+                    hasNonVisualAttachment = true;
+                } else if (ContentType.isVcalendarType(contentType)) {
+                    srcName = String.format("calendar%06d.vcs", index);
+                    totalLength += addVCalendarPart(context, pb, part, srcName);
+                    smilBody.append(String.format(sSmilPart, srcName));
+                    hasNonVisualAttachment = true;
+                } else {
+                    srcName = String.format("other%06d.dat", index);
+                    totalLength += addOtherPart(context, pb, part, srcName);
+                    smilBody.append(String.format(sSmilPart, srcName));
+                }
+                index++;
+            }
+            if (!TextUtils.isEmpty(part.getText())) {
+                hasText = true;
+            }
+        }
+
+        if (hasText) {
+            final String srcName = String.format("text.%06d.txt", index);
+            final String text = message.getMessageText();
+            totalLength += addTextPart(context, pb, text, srcName);
+
+            // Append appropriate SMIL to the body.
+            smilBody.append(String.format(sSmilTextPart, srcName));
+        }
+
+        final String smilTemplate = getSmilTemplate(hasVisualAttachment,
+                hasNonVisualAttachment, hasText, textTop);
+        addSmilPart(pb, smilTemplate, smilBody.toString());
+
+        final MmsInfo mmsInfo = new MmsInfo();
+        mmsInfo.mPduBody = pb;
+        mmsInfo.mMessageSize = totalLength;
+
+        return mmsInfo;
+    }
+
+    private static int getMediaDurationMs(final Context context, final MessagePartData part,
+            final int defaultDurationMs) {
+        Assert.notNull(context);
+        Assert.notNull(part);
+        Assert.isTrue(ContentType.isAudioType(part.getContentType()) ||
+                ContentType.isVideoType(part.getContentType()));
+
+        final MediaMetadataRetrieverWrapper retriever = new MediaMetadataRetrieverWrapper();
+        try {
+            retriever.setDataSource(part.getContentUri());
+            return retriever.extractInteger(
+                    MediaMetadataRetriever.METADATA_KEY_DURATION, defaultDurationMs);
+        } catch (final IOException e) {
+            LogUtil.i(LogUtil.BUGLE_TAG, "Error extracting duration from " + part.getContentUri(), e);
+            return defaultDurationMs;
+        } finally {
+            retriever.release();
+        }
+    }
+
+    private static void setPartContentLocationAndId(final PduPart part, final String srcName) {
+        // Set Content-Location.
+        part.setContentLocation(srcName.getBytes());
+
+        // Set Content-Id.
+        final int index = srcName.lastIndexOf(".");
+        final String contentId = (index == -1) ? srcName : srcName.substring(0, index);
+        part.setContentId(contentId.getBytes());
+    }
+
+    private static int addTextPart(final Context context, final PduBody pb,
+            final String text, final String srcName) {
+        final PduPart part = new PduPart();
+
+        // Set Charset if it's a text media.
+        part.setCharset(CharacterSets.UTF_8);
+
+        // Set Content-Type.
+        part.setContentType(ContentType.TEXT_PLAIN.getBytes());
+
+        // Set Content-Location.
+        setPartContentLocationAndId(part, srcName);
+
+        part.setData(text.getBytes());
+
+        pb.addPart(part);
+
+        return part.getData().length;
+    }
+
+    private static int addPicturePart(final Context context, final PduBody pb, final int index,
+            final MessagePartData messagePart, int widthLimit, int heightLimit,
+            final int maxPartSize, final String srcName, final String contentType) {
+        final Uri imageUri = messagePart.getContentUri();
+        final int width = messagePart.getWidth();
+        final int height = messagePart.getHeight();
+
+        // Swap the width and height limits to match the orientation of the image so we scale the
+        // picture as little as possible.
+        if ((height > width) != (heightLimit > widthLimit)) {
+            final int temp = widthLimit;
+            widthLimit = heightLimit;
+            heightLimit = temp;
+        }
+
+        final int orientation = ImageUtils.getOrientation(context, imageUri);
+        int imageSize = getDataLength(context, imageUri);
+        if (imageSize <= 0) {
+            LogUtil.e(TAG, "Can't get image", new Exception());
+            return 0;
+        }
+
+        if (LogUtil.isLoggable(TAG, LogUtil.VERBOSE)) {
+            LogUtil.v(TAG, "addPicturePart size: " + imageSize + " width: "
+                    + width + " widthLimit: " + widthLimit
+                    + " height: " + height
+                    + " heightLimit: " + heightLimit);
+        }
+
+        PduPart part;
+        // Check if we're already within the limits - in which case we don't need to resize.
+        // The size can be zero here, even when the media has content. See the comment in
+        // MediaModel.initMediaSize. Sometimes it'll compute zero and it's costly to read the
+        // whole stream to compute the size. When we call getResizedImageAsPart(), we'll correctly
+        // set the size.
+        
+        Log.d("smil_show_cp", "imageSize--->"+imageSize+"==maxPartSize() ---> "+maxPartSize);
+        Log.d("smil_show_cp", "messagePart.getWidth() ---> "+width+"---widthLimit---->"+widthLimit);
+        Log.d("smil_show_cp", "messagePart.getHeight() ---> "+height+"---widthLimit---->"+heightLimit);
+        Log.d("smil_show_cp", "orientation ---> "+orientation+"---android.media.ExifInterface.ORIENTATION_UNDEFINED---->"+android.media.ExifInterface.ORIENTATION_UNDEFINED);
+        Log.d("smil_show_cp", "orientation ---> "+orientation+"---android.media.ExifInterface.ORIENTATION_UNDEFINED---->"+android.media.ExifInterface.ORIENTATION_NORMAL);
+        if (imageSize <= maxPartSize &&
+                width <= widthLimit &&
+                height <= heightLimit &&
+                (orientation == android.media.ExifInterface.ORIENTATION_UNDEFINED ||
+                orientation == android.media.ExifInterface.ORIENTATION_NORMAL)) {
+            if (LogUtil.isLoggable(TAG, LogUtil.VERBOSE)) {
+                LogUtil.v(TAG, "addPicturePart - already sized");
+            }
+            Log.d("smil_show_cp", "-----part.setDataUri(imageUri)---> ");
+            part = new PduPart();
+            part.setDataUri(imageUri);
+            part.setContentType(contentType.getBytes());
+        } else {
+            part = getResizedImageAsPart(widthLimit, heightLimit, maxPartSize,
+                    width, height, orientation, imageUri, context, contentType);
+            if (part == null) {
+//                final OutOfMemoryError e = new OutOfMemoryError();
+//                LogUtil.e(TAG, "Can't resize image: not enough memory?", e);
+//                throw e;
+                part = new PduPart();
+                part.setDataUri(imageUri);
+                part.setContentType(contentType.getBytes());
+            }else{
+                part.setDataUri(imageUri);
+                part.setContentType(contentType.getBytes());
+            }
+            if (part != null && part.getData() != null) {
+                imageSize = part.getData().length;
+            }
+            Log.d("smil_show_cp", "-----not part.setDataUri(imageUri)---> ");
+            //add for bug 628890 --begin
+            //imageSize = part.getData().length;
+            //add for bug 628890 --end
+        }
+
+        setPartContentLocationAndId(part, srcName);
+
+        //modify for bug 603769 start
+        try {
+            pb.addPart(index, part);
+        } catch (Exception e) {
+            e.printStackTrace();
+            Log.e(TAG, "the attachment has unormal file where the size is 0");
+        }
+        //modify for bug 603769 end
+
+        if (LogUtil.isLoggable(TAG, LogUtil.VERBOSE)) {
+            LogUtil.v(TAG, "addPicturePart size: " + imageSize);
+        }
+
+        return imageSize;
+    }
+
+    private static void addPartForUri(final Context context, final PduBody pb,
+            String srcName, final Uri uri, final String contentType) {
+        final PduPart part = new PduPart();
+        part.setDataUri(uri);
+        part.setContentType(contentType.getBytes());
+
+       if (ContentType.isDrmType(contentType)) {
+           try {
+               String filePath = MessagingDrmSession.get().getPath(uri);
+               Log.d("MmsUtils", "filePath is " + filePath);
+               if (filePath != null) {
+                   int dotIndex = filePath.lastIndexOf("/");
+                   if (dotIndex > 0) {
+                       String drmFilename = filePath.substring(dotIndex+1, filePath.length());
+                       part.setName(drmFilename.getBytes());
+                       part.setFilename(drmFilename.getBytes());
+                       srcName = drmFilename;
+                       String drmOrigType = MessagingDrmSession.get().getDrmOrigMimeType(filePath, contentType);
+                       if (drmOrigType!=null){
+                           if (drmOrigType.startsWith("image/")){
+                               part.setContentType("image/dcf".getBytes());
+                           }else if (drmOrigType.startsWith("audio/")){
+                               part.setContentType("audio/dcf".getBytes());
+                           }else if (drmOrigType.startsWith("video/")){
+                               part.setContentType("video/dcf".getBytes());
+                           }
+                       }
+                       //part.setContentType("application/oct-stream".getBytes());
+                       Log.d("MmsUtils", "drmFilename is " + drmFilename+" drmOrigType "+drmOrigType+" contenttype is "+new String(part.getContentType()));
+                   }
+               }
+           } catch (Exception ex) {
+           }
+       }
+        setPartContentLocationAndId(part, srcName);
+        pb.addPart(part);
+    }
+
+    private static int addVCardPart(final Context context, final PduBody pb,
+            final MessagePartData messagePart, final String srcName) {
+        final Uri vcardUri = messagePart.getContentUri();
+        final String contentType = messagePart.getContentType();
+        final int vcardSize = getDataLength(context, vcardUri);
+        if (vcardSize <= 0) {
+            LogUtil.e(TAG, "Can't get vcard", new Exception());
+            return 0;
+        }
+
+        addPartForUri(context, pb, srcName, vcardUri, contentType);
+
+        if (LogUtil.isLoggable(TAG, LogUtil.VERBOSE)) {
+            LogUtil.v(TAG, "addVCardPart size: " + vcardSize);
+        }
+
+        return vcardSize;
+    }
+    private static int addVCalendarPart(final Context context, final PduBody pb,
+            final MessagePartData messagePart, final String srcName) {
+        final Uri vCalendarUri = messagePart.getContentUri();
+        final String contentType = messagePart.getContentType();
+        final int vcalendarSize = getDataLength(context, vCalendarUri);
+        if (vcalendarSize <= 0) {
+            LogUtil.e(TAG, "Can't get vcalendar", new Exception());
+            return 0;
+        }
+        addPartForUri(context, pb, srcName, vCalendarUri, contentType);
+        if (LogUtil.isLoggable(TAG, LogUtil.VERBOSE)) {
+            LogUtil.v(TAG, "addVCalendarPart size: " + vcalendarSize);
+        }
+        return vcalendarSize;
+    }
+
+    /**
+     * Add video part recompressing video if necessary.  If recompression fails, part is not
+     * added.
+     */
+    private static int addVideoPart(final Context context, final PduBody pb,
+            final MessagePartData messagePart, final String srcName) {
+        final Uri attachmentUri = messagePart.getContentUri();
+        String contentType = messagePart.getContentType();
+
+        if (LogUtil.isLoggable(TAG, LogUtil.VERBOSE)) {
+            LogUtil.v(TAG, "addPart attachmentUrl: " + attachmentUri.toString());
+        }
+
+        if (TextUtils.isEmpty(contentType)) {
+            contentType = ContentType.VIDEO_3G2;
+        }
+
+        addPartForUri(context, pb, srcName, attachmentUri, contentType);
+        return (int) getMediaFileSize(attachmentUri);
+    }
+
+    private static int addOtherPart(final Context context, final PduBody pb,
+            final MessagePartData messagePart, final String srcName) {
+        final Uri attachmentUri = messagePart.getContentUri();
+        //modify for bug 533847 begin
+        String contentType = messagePart.getContentType();
+        if (contentType == null || contentType.isEmpty()){//Modify for Bug:536649
+            contentType = ContentType.APP_OCT;
+        }
+        //modify for bug 533847 end
+        if (LogUtil.isLoggable(TAG, LogUtil.VERBOSE)) {
+            LogUtil.v(TAG, "addPart attachmentUrl: " + attachmentUri.toString());
+        }
+
+        final int dataSize = (int) getMediaFileSize(attachmentUri);
+
+        addPartForUri(context, pb, srcName, attachmentUri, contentType);
+
+        return dataSize;
+    }
+
+    private static void addSmilPart(final PduBody pb, final String smilTemplate,
+            final String smilBody) {
+        final PduPart smilPart = new PduPart();
+        smilPart.setContentId("smil".getBytes());
+        smilPart.setContentLocation("smil.xml".getBytes());
+        smilPart.setContentType(ContentType.APP_SMIL.getBytes());
+        final String smil = String.format(smilTemplate, smilBody);
+        smilPart.setData(smil.getBytes());
+        pb.addPart(0, smilPart);
+    }
+
+    private static String getSmilTemplate(final boolean hasVisualAttachments,
+            final boolean hasNonVisualAttachments, final boolean hasText, final boolean textTop) {
+        if (hasVisualAttachments) {
+            if (textTop){
+                return hasText ? sSmilVisualAttachmentsWithTextTop : sSmilVisualAttachmentsOnly;
+            }else{
+                return hasText ? sSmilVisualAttachmentsWithText : sSmilVisualAttachmentsOnly;
+            }
+        }
+        if (hasNonVisualAttachments) {
+            return hasText ? sSmilNonVisualAttachmentsWithText : sSmilNonVisualAttachmentsOnly;
+        }
+        return sSmilTextOnly;
+    }
+
+    private static int getDataLength(final Context context, final Uri uri) {
+        InputStream is = null;
+        try {
+            is = context.getContentResolver().openInputStream(uri);
+            try {
+                return is == null ? 0 : is.available();
+            } catch (final IOException e) {
+                LogUtil.e(TAG, "getDataLength couldn't stream: " + uri, e);
+            }
+        } catch (final FileNotFoundException e) {
+            LogUtil.e(TAG, "getDataLength couldn't open: " + uri, e);
+        } finally {
+            if (is != null) {
+                try {
+                    is.close();
+                } catch (final IOException e) {
+                    LogUtil.e(TAG, "getDataLength couldn't close: " + uri, e);
+                }
+            }
+        }
+        return 0;
+    }
+
+    /**
+     * Returns {@code true} if group mms is turned on,
+     * {@code false} otherwise.
+     *
+     * For the group mms feature to be enabled, the following must be true:
+     *  1. the feature is enabled in mms_config.xml (currently on by default)
+     *  2. the feature is enabled in the SMS settings page
+     *
+     * @return true if group mms is supported
+     */
+    public static boolean groupMmsEnabled(final int subId) {
+        final Context context = Factory.get().getApplicationContext();
+        final Resources resources = context.getResources();
+        final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
+        final String groupMmsKey = resources.getString(R.string.group_mms_pref_key);
+        final boolean groupMmsEnabledDefault = resources.getBoolean(R.bool.group_mms_pref_default);
+        final boolean groupMmsPrefOn = prefs.getBoolean(groupMmsKey, groupMmsEnabledDefault);
+        return MmsConfig.get(subId).getGroupMmsEnabled() && groupMmsPrefOn;
+    }
+
+    /**
+     * Get a version of this image resized to fit the given dimension and byte-size limits. Note
+     * that the content type of the resulting PduPart may not be the same as the content type of
+     * this UriImage; always call {@link PduPart#getContentType()} to get the new content type.
+     *
+     * @param widthLimit The width limit, in pixels
+     * @param heightLimit The height limit, in pixels
+     * @param byteLimit The binary size limit, in bytes
+     * @param width The image width, in pixels
+     * @param height The image height, in pixels
+     * @param orientation Orientation constant from ExifInterface for rotating or flipping the
+     *                    image
+     * @param imageUri Uri to the image data
+     * @param context Needed to open the image
+     * @return A new PduPart containing the resized image data
+     */
+    private static PduPart getResizedImageAsPart(final int widthLimit,
+            final int heightLimit, final int byteLimit, final int width, final int height,
+            final int orientation, final Uri imageUri, final Context context, final String contentType) {
+        final PduPart part = new PduPart();
+
+        final byte[] data = ImageResizer.getResizedImageData(width, height, orientation,
+                widthLimit, heightLimit, byteLimit, imageUri, context, contentType);
+        if (data == null) {
+            if (LogUtil.isLoggable(TAG, LogUtil.VERBOSE)) {
+                LogUtil.v(TAG, "Resize image failed.");
+            }
+            return null;
+        }
+
+        part.setData(data);
+        // Any static images will be compressed into a jpeg
+        final String contentTypeOfResizedImage = ImageUtils.isGif(contentType, imageUri)
+                ? ContentType.IMAGE_GIF : ContentType.IMAGE_JPEG;
+        part.setContentType(contentTypeOfResizedImage.getBytes());
+
+        return part;
+    }
+
+    /**
+     * Get media file size
+     */
+    public static long getMediaFileSize(final Uri uri) {
+        final Context context = Factory.get().getApplicationContext();
+     // Spread: fixed for bug :521561 start
+        if (ActivityManager.isUserAMonkey()) {
+            // Spread: fixed for bug :518331 start
+            if (!OsUtil.hasStoragePermission()) {
+                LogUtil.e(
+                        TAG,
+                        "MmsUtils.getMediaFileSize: cound not find media file: beacause have not has the pemission ");
+                return 0L;
+            }
+            // Spread: fixed for bug :518331 end
+        }
+     // Spread: fixed for bug :521561 end
+        AssetFileDescriptor fd = null;
+        try {
+            fd = context.getContentResolver().openAssetFileDescriptor(uri, "r");
+            if (fd != null) {
+                return fd.getParcelFileDescriptor().getStatSize();
+            }
+        } catch (final FileNotFoundException e) {
+            LogUtil.e(TAG, "MmsUtils.getMediaFileSize: cound not find media file: " + e, e);
+        } finally {
+            if (fd != null) {
+                try {
+                    fd.close();
+                } catch (final IOException e) {
+                    LogUtil.e(TAG, "MmsUtils.getMediaFileSize: failed to close " + e, e);
+                }
+            }
+        }
+        return 0L;
+    }
+
+    // Code for extracting the actual phone numbers for the participants in a conversation,
+    // given a thread id.
+
+    private static final Uri ALL_THREADS_URI =
+            Threads.CONTENT_URI.buildUpon().appendQueryParameter("simple", "true").build();
+
+    private static final String[] RECIPIENTS_PROJECTION = {
+        Threads._ID,
+        Threads.RECIPIENT_IDS
+    };
+
+    private static final int RECIPIENT_IDS  = 1;
+
+    public static List<String> getRecipientsByThread(final long threadId) {
+        final String spaceSepIds = getRawRecipientIdsForThread(threadId);
+        if (!TextUtils.isEmpty(spaceSepIds)) {
+            final Context context = Factory.get().getApplicationContext();
+            return getAddresses(context, spaceSepIds);
+        }
+        return null;
+    }
+
+    // NOTE: There are phones on which you can't get the recipients from the thread id for SMS
+    // until you have a message in the conversation!
+    public static String getRawRecipientIdsForThread(final long threadId) {
+        if (threadId <= 0) {
+            return null;
+        }
+        final Context context = Factory.get().getApplicationContext();
+        final ContentResolver cr = context.getContentResolver();
+        final Cursor thread = cr.query(
+                ALL_THREADS_URI,
+                RECIPIENTS_PROJECTION, "_id=?", new String[] { String.valueOf(threadId) }, null);
+        if (thread != null) {
+            try {
+                if (thread.moveToFirst()) {
+                    // recipientIds will be a space-separated list of ids into the
+                    // canonical addresses table.
+                    return thread.getString(RECIPIENT_IDS);
+                }
+            } finally {
+                thread.close();
+            }
+        }
+        return null;
+    }
+
+    private static final Uri SINGLE_CANONICAL_ADDRESS_URI =
+            Uri.parse("content://mms-sms/canonical-address");
+
+    private static List<String> getAddresses(final Context context, final String spaceSepIds) {
+        final List<String> numbers = new ArrayList<String>();
+        final String[] ids = spaceSepIds.split(" ");
+        for (final String id : ids) {
+            long longId;
+
+            try {
+                longId = Long.parseLong(id);
+                if (longId < 0) {
+                    LogUtil.e(TAG, "MmsUtils.getAddresses: invalid id " + longId);
+                    continue;
+                }
+            } catch (final NumberFormatException ex) {
+                LogUtil.e(TAG, "MmsUtils.getAddresses: invalid id. " + ex, ex);
+                // skip this id
+                continue;
+            }
+
+            // TODO: build a single query where we get all the addresses at once.
+            Cursor c = null;
+            try {
+                c = context.getContentResolver().query(
+                        ContentUris.withAppendedId(SINGLE_CANONICAL_ADDRESS_URI, longId),
+                        null, null, null, null);
+            } catch (final Exception e) {
+                LogUtil.e(TAG, "MmsUtils.getAddresses: query failed for id " + longId, e);
+            }
+            if (c != null) {
+                try {
+                    if (c.moveToFirst()) {
+                        final String number = c.getString(0);
+                        if (!TextUtils.isEmpty(number)) {
+                            numbers.add(number);
+                        } else {
+                            LogUtil.w(TAG, "Canonical MMS/SMS address is empty for id: " + longId);
+                        }
+                    }
+                } finally {
+                    c.close();
+                }
+            }
+        }
+        if (numbers.isEmpty()) {
+            LogUtil.w(TAG, "No MMS addresses found from ids string [" + spaceSepIds + "]");
+        }
+        return numbers;
+    }
+
+    // Get telephony SMS thread ID
+    public static long getOrCreateSmsThreadId(final Context context, final String dest) {
+        // use destinations to determine threadId
+        final Set<String> recipients = new HashSet<String>();
+        recipients.add(dest);
+        try {
+            return MmsSmsUtils.Threads.getOrCreateThreadId(context, recipients);
+        } catch (final IllegalArgumentException e) {
+            LogUtil.e(TAG, "MmsUtils: getting thread id failed: " + e);
+            return -1;
+        }
+    }
+
+    // Get telephony SMS thread ID
+    public static long getOrCreateThreadId(final Context context, final List<String> dests) {
+        if (dests == null || dests.size() == 0) {
+            return -1;
+        }
+        // use destinations to determine threadId
+        final Set<String> recipients = new HashSet<String>(dests);
+        try {
+            return MmsSmsUtils.Threads.getOrCreateThreadId(context, recipients);
+        } catch (final IllegalArgumentException e) {
+            LogUtil.e(TAG, "MmsUtils: getting thread id failed: " + e);
+            return -1;
+        }
+    }
+
+    /**
+     * Add an SMS to the given URI with thread_id specified.
+     *
+     * @param resolver the content resolver to use
+     * @param uri the URI to add the message to
+     * @param subId subId for the receiving sim
+     * @param address the address of the sender
+     * @param body the body of the message
+     * @param subject the psuedo-subject of the message
+     * @param date the timestamp for the message
+     * @param read true if the message has been read, false if not
+     * @param threadId the thread_id of the message
+     * @return the URI for the new message
+     */
+    private static Uri addMessageToUri(final ContentResolver resolver,
+            final Uri uri, final int subId, final String address, final String body,
+            final String subject, final Long date, final boolean read, final boolean seen,
+            final int status, final int type, final long threadId) {
+        final ContentValues values = new ContentValues(7);
+
+        values.put(Telephony.Sms.ADDRESS, address);
+        if (date != null) {
+            values.put(Telephony.Sms.DATE, date);
+        }
+        values.put(Telephony.Sms.READ, read ? 1 : 0);
+        values.put(Telephony.Sms.SEEN, seen ? 1 : 0);
+        values.put(Telephony.Sms.SUBJECT, subject);
+        values.put(Telephony.Sms.BODY, body);
+        if (OsUtil.isAtLeastL_MR1()) {
+            values.put(Telephony.Sms.SUBSCRIPTION_ID, subId);
+        }
+        if (status != Telephony.Sms.STATUS_NONE) {
+            values.put(Telephony.Sms.STATUS, status);
+        }
+        if (type != Telephony.Sms.MESSAGE_TYPE_ALL) {
+            values.put(Telephony.Sms.TYPE, type);
+        }
+        if (threadId != -1L) {
+            values.put(Telephony.Sms.THREAD_ID, threadId);
+        }
+        return resolver.insert(uri, values);
+    }
+
+    // Insert an SMS message to telephony
+    public static Uri insertSmsMessage(final Context context, final Uri uri, final int subId,
+            final String dest, final String text, final long timestamp, final int status,
+            final int type, final long threadId) {
+        Uri response = null;
+        try {
+            response = addMessageToUri(context.getContentResolver(), uri, subId, dest,
+                    text, null /* subject */, timestamp, true /* read */,
+                    true /* seen */, status, type, threadId);
+            if (LogUtil.isLoggable(TAG, LogUtil.DEBUG)) {
+                LogUtil.d(TAG, "Mmsutils: Inserted SMS message into telephony (type = " + type + ")"
+                        + ", uri: " + response);
+            }
+        } catch (final SQLiteException e) {
+            LogUtil.e(TAG, "MmsUtils: persist sms message failure " + e, e);
+        } catch (final IllegalArgumentException e) {
+            LogUtil.e(TAG, "MmsUtils: persist sms message failure " + e, e);
+        }
+        return response;
+    }
+
+    // Update SMS message type in telephony; returns true if it succeeded.
+    public static boolean updateSmsMessageSendingStatus(final Context context, final Uri uri,
+            final int type, final long date) {
+        try {
+            final ContentResolver resolver = context.getContentResolver();
+            final ContentValues values = new ContentValues(2);
+
+            values.put(Telephony.Sms.TYPE, type);
+            values.put(Telephony.Sms.DATE, date);
+            final int cnt = resolver.update(uri, values, null, null);
+            if (cnt == 1) {
+                if (LogUtil.isLoggable(TAG, LogUtil.DEBUG)) {
+                    LogUtil.d(TAG, "Mmsutils: Updated sending SMS " + uri + "; type = " + type
+                            + ", date = " + date + " (millis since epoch)");
+                }
+                return true;
+            }
+        } catch (final SQLiteException e) {
+            LogUtil.e(TAG, "MmsUtils: update sms message failure " + e, e);
+        } catch (final IllegalArgumentException e) {
+            LogUtil.e(TAG, "MmsUtils: update sms message failure " + e, e);
+        }
+        return false;
+    }
+
+    // Persist a sent MMS message in telephony
+    private static Uri insertSendReq(final Context context, final GenericPdu pdu, final int subId,
+            final String subPhoneNumber) {
+        final PduPersister persister = PduPersister.getPduPersister(context);
+        Uri uri = null;
+        try {
+            // Persist the PDU
+            uri = persister.persist(
+                    pdu,
+                    Mms.Sent.CONTENT_URI,
+                    subId,
+                    subPhoneNumber,
+                    null/*preOpenedFiles*/);
+            // Update mms table to reflect sent messages are always seen and read
+            final ContentValues values = new ContentValues(1);
+            values.put(Mms.READ, 1);
+            values.put(Mms.SEEN, 1);
+            SqliteWrapper.update(context, context.getContentResolver(), uri, values, null, null);
+        } catch (final MmsException e) {
+            LogUtil.e(TAG, "MmsUtils: persist mms sent message failure " + e, e);
+        }
+        return uri;
+    }
+
+    // Persist a received MMS message in telephony
+    public static Uri insertReceivedMmsMessage(final Context context,
+            final RetrieveConf retrieveConf, final int subId, final String subPhoneNumber,
+            final long receivedTimestampInSeconds, final String contentLocation) {
+        final PduPersister persister = PduPersister.getPduPersister(context);
+        Uri uri = null;
+        try {
+            uri = persister.persist(
+                    retrieveConf,
+                    Mms.Inbox.CONTENT_URI,
+                    subId,
+                    subPhoneNumber,
+                    null/*preOpenedFiles*/);
+
+            final ContentValues values = new ContentValues(2);
+            // Update mms table with local time instead of PDU time
+            values.put(Mms.DATE, receivedTimestampInSeconds);
+            // Also update the content location field from NotificationInd so that
+            // wap push dedup would work even after the wap push is deleted
+            values.put(Mms.CONTENT_LOCATION, contentLocation);
+            SqliteWrapper.update(context, context.getContentResolver(), uri, values, null, null);
+            if (LogUtil.isLoggable(TAG, LogUtil.DEBUG)) {
+                LogUtil.d(TAG, "MmsUtils: Inserted MMS message into telephony, uri: " + uri);
+            }
+        } catch (final MmsException e) {
+            LogUtil.e(TAG, "MmsUtils: persist mms received message failure " + e, e);
+            // Just returns empty uri to RetrieveMmsRequest, which triggers a permanent failure
+        } catch (final SQLiteException e) {
+            LogUtil.e(TAG, "MmsUtils: update mms received message failure " + e, e);
+            // Time update failure is ignored.
+        }
+        return uri;
+    }
+
+    // Update MMS message type in telephony; returns true if it succeeded.
+    public static boolean updateMmsMessageSendingStatus(final Context context, final Uri uri,
+            final int box, final long timestampInMillis) {
+        try {
+            final ContentResolver resolver = context.getContentResolver();
+            final ContentValues values = new ContentValues();
+
+            final long timestampInSeconds = timestampInMillis / 1000L;
+            values.put(Telephony.Mms.MESSAGE_BOX, box);
+            values.put(Telephony.Mms.DATE, timestampInSeconds);
+            final int cnt = resolver.update(uri, values, null, null);
+            if (cnt == 1) {
+                if (LogUtil.isLoggable(TAG, LogUtil.DEBUG)) {
+                    LogUtil.d(TAG, "Mmsutils: Updated sending MMS " + uri + "; box = " + box
+                            + ", date = " + timestampInSeconds + " (secs since epoch)");
+                }
+                return true;
+            }
+        } catch (final SQLiteException e) {
+            LogUtil.e(TAG, "MmsUtils: update mms message failure " + e, e);
+        } catch (final IllegalArgumentException e) {
+            LogUtil.e(TAG, "MmsUtils: update mms message failure " + e, e);
+        }
+        return false;
+    }
+
+    /**
+     * Parse values from a received sms message
+     *
+     * @param context
+     * @param msgs The received sms message content
+     * @param error The received sms error
+     * @return Parsed values from the message
+     */
+    public static ContentValues parseReceivedSmsMessage(
+            final Context context, final SmsMessage[] msgs, final int error) {
+        final SmsMessage sms = msgs[0];
+        final ContentValues values = new ContentValues();
+
+        values.put(Sms.ADDRESS, sms.getDisplayOriginatingAddress());
+        values.put(Sms.BODY, buildMessageBodyFromPdus(msgs));
+        if (MmsUtils.hasSmsDateSentColumn()) {
+            // TODO:: The boxing here seems unnecessary.
+            values.put(Sms.DATE_SENT, Long.valueOf(sms.getTimestampMillis()));
+        }
+        values.put(Sms.PROTOCOL, sms.getProtocolIdentifier());
+        if (sms.getPseudoSubject().length() > 0) {
+            values.put(Sms.SUBJECT, sms.getPseudoSubject());
+        }
+        values.put(Sms.REPLY_PATH_PRESENT, sms.isReplyPathPresent() ? 1 : 0);
+        values.put(Sms.SERVICE_CENTER, sms.getServiceCenterAddress());
+        // Error code
+        values.put(Sms.ERROR_CODE, error);
+
+        return values;
+    }
+
+    // Some providers send formfeeds in their messages. Convert those formfeeds to newlines.
+    private static String replaceFormFeeds(final String s) {
+        return s == null ? "" : s.replace('\f', '\n');
+    }
+
+    // Parse the message body from message PDUs
+    private static String buildMessageBodyFromPdus(final SmsMessage[] msgs) {
+        if (msgs.length == 1) {
+            // There is only one part, so grab the body directly.
+            return replaceFormFeeds(msgs[0].getDisplayMessageBody());
+        } else {
+            // Build up the body from the parts.
+            final StringBuilder body = new StringBuilder();
+            for (final SmsMessage msg : msgs) {
+                try {
+                    // getDisplayMessageBody() can NPE if mWrappedMessage inside is null.
+                    body.append(msg.getDisplayMessageBody());
+                } catch (final NullPointerException e) {
+                    // Nothing to do
+                }
+            }
+            return replaceFormFeeds(body.toString());
+        }
+    }
+
+    // Parse the message date
+    public static Long getMessageDate(final SmsMessage sms, long now) {
+        // Use now for the timestamp to avoid confusion with clock
+        // drift between the handset and the SMSC.
+        // Check to make sure the system is giving us a non-bogus time.
+        final Calendar buildDate = new GregorianCalendar(2011, 8, 18);    // 18 Sep 2011
+        final Calendar nowDate = new GregorianCalendar();
+        nowDate.setTimeInMillis(now);
+        if (nowDate.before(buildDate)) {
+            // It looks like our system clock isn't set yet because the current time right now
+            // is before an arbitrary time we made this build. Instead of inserting a bogus
+            // receive time in this case, use the timestamp of when the message was sent.
+            now = sms.getTimestampMillis();
+        }
+        return now;
+    }
+
+    /**
+     * cleanseMmsSubject will take a subject that's says, "<Subject: no subject>", and return
+     * a null string. Otherwise it will return the original subject string.
+     * @param resources So the function can grab string resources
+     * @param subject the raw subject
+     * @return
+     */
+    public static String cleanseMmsSubject(final Resources resources, final String subject) {
+        if (TextUtils.isEmpty(subject)) {
+            return null;
+        }
+        if (sNoSubjectStrings == null) {
+            sNoSubjectStrings =
+                    resources.getStringArray(R.array.empty_subject_strings);
+        }
+        for (final String noSubjectString : sNoSubjectStrings) {
+            if (subject.equalsIgnoreCase(noSubjectString)) {
+                return null;
+            }
+        }
+        return subject;
+    }
+
+    // return a semicolon separated list of phone numbers from a smsto: uri.
+    public static String getSmsRecipients(final Uri uri) {
+        String recipients = uri.getSchemeSpecificPart();
+        final int pos = recipients.indexOf('?');
+        if (pos != -1) {
+            recipients = recipients.substring(0, pos);
+        }
+        recipients = replaceUnicodeDigits(recipients).replace(',', ';');
+        return recipients;
+    }
+
+    // This function was lifted from Telephony.PhoneNumberUtils because it was @hide
+    /**
+     * Replace arabic/unicode digits with decimal digits.
+     * @param number
+     *            the number to be normalized.
+     * @return the replaced number.
+     */
+    private static String replaceUnicodeDigits(final String number) {
+        final StringBuilder normalizedDigits = new StringBuilder(number.length());
+        for (final char c : number.toCharArray()) {
+            final int digit = Character.digit(c, 10);
+            if (digit != -1) {
+                normalizedDigits.append(digit);
+            } else {
+                normalizedDigits.append(c);
+            }
+        }
+        return normalizedDigits.toString();
+    }
+
+    /**
+     * @return Whether the data roaming is enabled
+     */
+    private static boolean isDataRoamingEnabled() {
+        boolean dataRoamingEnabled = false;
+        final ContentResolver cr = Factory.get().getApplicationContext().getContentResolver();
+        if (OsUtil.isAtLeastJB_MR1()) {
+            dataRoamingEnabled = (Settings.Global.getInt(cr, Settings.Global.DATA_ROAMING, 0) != 0);
+        } else {
+            dataRoamingEnabled = (Settings.System.getInt(cr, Settings.System.DATA_ROAMING, 0) != 0);
+        }
+        return dataRoamingEnabled;
+    }
+
+    /**
+     * @return Whether to auto retrieve MMS
+     */
+    public static boolean allowMmsAutoRetrieve(final int subId) {
+        final Context context = Factory.get().getApplicationContext();
+        final Resources resources = context.getResources();
+        final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
+        final boolean autoRetrieve = prefs.getBoolean(
+                resources.getString(R.string.auto_retrieve_mms_pref_key),
+                resources.getBoolean(R.bool.auto_retrieve_mms_pref_default));
+        if (autoRetrieve) {
+            final boolean autoRetrieveInRoaming = prefs.getBoolean(
+                    resources.getString(R.string.auto_retrieve_mms_when_roaming_pref_key),
+                    resources.getBoolean(R.bool.auto_retrieve_mms_when_roaming_pref_default));
+            final PhoneUtils phoneUtils = PhoneUtils.get(subId);
+            if ((autoRetrieveInRoaming && phoneUtils.isDataRoamingEnabled())
+                    || !phoneUtils.isRoaming()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Parse the message row id from a message Uri.
+     *
+     * @param messageUri The input Uri
+     * @return The message row id if valid, otherwise -1
+     */
+    public static long parseRowIdFromMessageUri(final Uri messageUri) {
+        try {
+            if (messageUri != null) {
+                return ContentUris.parseId(messageUri);
+            }
+        } catch (final UnsupportedOperationException e) {
+            // Nothing to do
+        } catch (final NumberFormatException e) {
+            // Nothing to do
+        }
+        return -1;
+    }
+
+    public static SmsMessageAdapter getSmsMessageFromDeliveryReport(final Intent intent) {
+        final byte[] pdu = intent.getByteArrayExtra("pdu");
+        SmsMessage sms = SmsMessage.createFromPdu(pdu);
+        SmsMessageAdapter adapter = new SmsMessageAdapter(sms);
+        adapter.mRecipientAddress = SystemAdapter.getInstance().getRecipientAddress(pdu);
+        return  adapter;
+    }
+
+    /**
+     * Update the status and date_sent column of sms message in telephony provider
+     *
+     * @param smsMessageUri
+     * @param status
+     * @param timeSentInMillis
+     */
+    public static void updateSmsStatusAndDateSent(final Uri smsMessageUri, final int status,
+            final long timeSentInMillis) {
+        if (smsMessageUri == null) {
+            return;
+        }
+        final ContentValues values = new ContentValues();
+        values.put(Sms.STATUS, status);
+        if (MmsUtils.hasSmsDateSentColumn()) {
+            values.put(Sms.DATE_SENT, timeSentInMillis);
+        }
+        final ContentResolver resolver = Factory.get().getApplicationContext().getContentResolver();
+        resolver.update(smsMessageUri, values, null/*where*/, null/*selectionArgs*/);
+    }
+
+    /**
+     * Get the SQL selection statement for matching messages with media.
+     *
+     * Example for MMS part table:
+     * "((ct LIKE 'image/%')
+     *   OR (ct LIKE 'video/%')
+     *   OR (ct LIKE 'audio/%')
+     *   OR (ct='application/ogg'))
+     *
+     * @param contentTypeColumn The content-type column name
+     * @return The SQL selection statement for matching media types: image, video, audio
+     */
+    public static String getMediaTypeSelectionSql(final String contentTypeColumn) {
+        return String.format(
+                Locale.US,
+                "((%s LIKE '%s') OR (%s LIKE '%s') OR (%s LIKE '%s') OR (%s='%s'))",
+                contentTypeColumn,
+                "image/%",
+                contentTypeColumn,
+                "video/%",
+                contentTypeColumn,
+                "audio/%",
+                contentTypeColumn,
+                ContentType.AUDIO_OGG);
+    }
+
+    // Max number of operands per SQL query for deleting SMS messages
+    public static final int MAX_IDS_PER_QUERY = 128;
+
+    /**
+     * Delete MMS messages with media parts.
+     *
+     * Because the telephony provider constraints, we can't use JOIN and delete messages in one
+     * shot. We have to do a query first and then batch delete the messages based on IDs.
+     *
+     * @return The count of messages deleted.
+     */
+    public static int deleteMediaMessages() {
+        // Do a query first
+        //
+        // The WHERE clause has two parts:
+        // The first part is to select the exact same types of MMS messages as when we import them
+        // (so that we don't delete messages that are not in local database)
+        // The second part is to select MMS with media parts, including image, video and audio
+        final String selection = String.format(
+                Locale.US,
+                "%s AND (%s IN (SELECT %s FROM part WHERE %s))",
+                getMmsTypeSelectionSql(),
+                Mms._ID,
+                Mms.Part.MSG_ID,
+                getMediaTypeSelectionSql(Mms.Part.CONTENT_TYPE));
+        final ContentResolver resolver = Factory.get().getApplicationContext().getContentResolver();
+        final Cursor cursor = resolver.query(Mms.CONTENT_URI,
+                new String[]{ Mms._ID },
+                selection,
+                null/*selectionArgs*/,
+                null/*sortOrder*/);
+        int deleted = 0;
+        if (cursor != null) {
+            final long[] messageIds = new long[cursor.getCount()];
+            try {
+                int i = 0;
+                while (cursor.moveToNext()) {
+                    messageIds[i++] = cursor.getLong(0);
+                }
+            } finally {
+                cursor.close();
+            }
+            final int totalIds = messageIds.length;
+            if (totalIds > 0) {
+                // Batch delete the messages using IDs
+                // We don't want to send all IDs at once since there is a limit on SQL statement
+                for (int start = 0; start < totalIds; start += MAX_IDS_PER_QUERY) {
+                    final int end = Math.min(start + MAX_IDS_PER_QUERY, totalIds); // excluding
+                    final int count = end - start;
+                    final String batchSelection = String.format(
+                            Locale.US,
+                            "%s IN %s",
+                            Mms._ID,
+                            getSqlInOperand(count));
+                    final String[] batchSelectionArgs =
+                            getSqlInOperandArgs(messageIds, start, count);
+                    final int deletedForBatch = resolver.delete(
+                            Mms.CONTENT_URI,
+                            batchSelection,
+                            batchSelectionArgs);
+                    if (LogUtil.isLoggable(TAG, LogUtil.DEBUG)) {
+                        LogUtil.d(TAG, "deleteMediaMessages: deleting IDs = "
+                                + Joiner.on(',').skipNulls().join(batchSelectionArgs)
+                                + ", deleted = " + deletedForBatch);
+                    }
+                    deleted += deletedForBatch;
+                }
+            }
+        }
+        return deleted;
+    }
+
+    /**
+     * Get the (?,?,...) thing for the SQL IN operator by a count
+     *
+     * @param count
+     * @return
+     */
+    public static String getSqlInOperand(final int count) {
+        if (count <= 0) {
+            return null;
+        }
+        final StringBuilder sb = new StringBuilder();
+        sb.append("(?");
+        for (int i = 0; i < count - 1; i++) {
+            sb.append(",?");
+        }
+        sb.append(")");
+        return sb.toString();
+    }
+
+    /**
+     * Get the args for SQL IN operator from a long ID array
+     *
+     * @param ids The original long id array
+     * @param start Start of the ids to fill the args
+     * @param count Number of ids to pack
+     * @return The long array with the id args
+     */
+    private static String[] getSqlInOperandArgs(
+            final long[] ids, final int start, final int count) {
+        if (count <= 0) {
+            return null;
+        }
+        final String[] args = new String[count];
+        for (int i = 0; i < count; i++) {
+            args[i] = Long.toString(ids[start + i]);
+        }
+        return args;
+    }
+
+    /**
+     * Delete SMS and MMS messages that are earlier than a specific timestamp
+     *
+     * @param cutOffTimestampInMillis The cut-off timestamp
+     * @return Total number of messages deleted.
+     */
+    public static int deleteMessagesOlderThan(final long cutOffTimestampInMillis) {
+        int deleted = 0;
+        final ContentResolver resolver = Factory.get().getApplicationContext().getContentResolver();
+        // Delete old SMS
+        final String smsSelection = String.format(
+                Locale.US,
+                "%s AND (%s<=%d)",
+                getSmsTypeSelectionSql(),
+                Sms.DATE,
+                cutOffTimestampInMillis);
+        deleted += resolver.delete(Sms.CONTENT_URI, smsSelection, null/*selectionArgs*/);
+        // Delete old MMS
+        final String mmsSelection = String.format(
+                Locale.US,
+                "%s AND (%s<=%d)",
+                getMmsTypeSelectionSql(),
+                Mms.DATE,
+                cutOffTimestampInMillis / 1000L);
+        deleted += resolver.delete(Mms.CONTENT_URI, mmsSelection, null/*selectionArgs*/);
+        return deleted;
+    }
+
+    /**
+     * Update the read status of SMS/MMS messages by thread and timestamp
+     *
+     * @param threadId The thread of sms/mms to change
+     * @param timestampInMillis Change the status before this timestamp
+     */
+    public static void updateSmsReadStatus(final long threadId, final long timestampInMillis) {
+        final ContentResolver resolver = Factory.get().getApplicationContext().getContentResolver();
+        final ContentValues values = new ContentValues();
+        values.put("read", 1);
+        values.put("seen", 1); /* If you read it you saw it */
+        final String smsSelection = String.format(
+                Locale.US,
+                "%s=%d AND %s<=%d AND %s=0",
+                Sms.THREAD_ID,
+                threadId,
+                Sms.DATE,
+                timestampInMillis,
+                Sms.READ);
+        resolver.update(
+                Sms.CONTENT_URI,
+                values,
+                smsSelection,
+                null/*selectionArgs*/);
+        final String mmsSelection = String.format(
+                Locale.US,
+                "%s=%d AND %s<=%d AND %s=0",
+                Mms.THREAD_ID,
+                threadId,
+                Mms.DATE,
+                timestampInMillis / 1000L,
+                Mms.READ);
+        resolver.update(
+                Mms.CONTENT_URI,
+                values,
+                mmsSelection,
+                null/*selectionArgs*/);
+    }
+
+    /**
+     * Update the read status of a single MMS message by its URI
+     *
+     * @param mmsUri
+     * @param read
+     */
+    public static void updateReadStatusForMmsMessage(final Uri mmsUri, final boolean read) {
+        final ContentResolver resolver = Factory.get().getApplicationContext().getContentResolver();
+        final ContentValues values = new ContentValues();
+        values.put(Mms.READ, read ? 1 : 0);
+        resolver.update(mmsUri, values, null/*where*/, null/*selectionArgs*/);
+    }
+
+    public static class AttachmentInfo {
+        public String mUrl;
+        public String mContentType;
+        public int mWidth;
+        public int mHeight;
+    }
+
+    /**
+     * Convert byte array to Java String using a charset name
+     *
+     * @param bytes
+     * @param charsetName
+     * @return
+     */
+    public static String bytesToString(final byte[] bytes, final String charsetName) {
+        if (bytes == null) {
+            return null;
+        }
+        try {
+            return new String(bytes, charsetName);
+        } catch (final UnsupportedEncodingException e) {
+            LogUtil.e(TAG, "MmsUtils.bytesToString: " + e, e);
+            return new String(bytes);
+        }
+    }
+
+    /**
+     * Convert a Java String to byte array using a charset name
+     *
+     * @param string
+     * @param charsetName
+     * @return
+     */
+    public static byte[] stringToBytes(final String string, final String charsetName) {
+        if (string == null) {
+            return null;
+        }
+        try {
+            return string.getBytes(charsetName);
+        } catch (final UnsupportedEncodingException e) {
+            LogUtil.e(TAG, "MmsUtils.stringToBytes: " + e, e);
+            return string.getBytes();
+        }
+    }
+
+    private static final String[] TEST_DATE_SENT_PROJECTION = new String[] { Sms.DATE_SENT };
+    private static Boolean sHasSmsDateSentColumn = null;
+    /**
+     * Check if date_sent column exists on ICS and above devices. We need to do a test
+     * query to figure that out since on some ICS+ devices, somehow the date_sent column does
+     * not exist. http://b/17629135 tracks the associated compliance test.
+     *
+     * @return Whether "date_sent" column exists in sms table
+     */
+    public static boolean hasSmsDateSentColumn() {
+        if (sHasSmsDateSentColumn == null) {
+            Cursor cursor = null;
+            try {
+                final Context context = Factory.get().getApplicationContext();
+                final ContentResolver resolver = context.getContentResolver();
+                cursor = SqliteWrapper.query(
+                        context,
+                        resolver,
+                        Sms.CONTENT_URI,
+                        TEST_DATE_SENT_PROJECTION,
+                        null/*selection*/,
+                        null/*selectionArgs*/,
+                        Sms.DATE_SENT + " ASC LIMIT 1");
+                sHasSmsDateSentColumn = true;
+            } catch (final SQLiteException e) {
+                LogUtil.w(TAG, "date_sent in sms table does not exist", e);
+                sHasSmsDateSentColumn = false;
+            } finally {
+                if (cursor != null) {
+                    cursor.close();
+                }
+            }
+        }
+        return sHasSmsDateSentColumn;
+    }
+
+    private static final String[] TEST_CARRIERS_PROJECTION =
+            new String[] { Telephony.Carriers.MMSC };
+    private static Boolean sUseSystemApn = null;
+    /**
+     * Check if we can access the APN data in the Telephony provider. Access was restricted in
+     * JB MR1 (and some JB MR2) devices. If we can't access the APN, we have to fall back and use
+     * a private table in our own app.
+     *
+     * @return Whether we can access the system APN table
+     */
+    public static boolean useSystemApnTable() {
+        if (sUseSystemApn == null) {
+            Cursor cursor = null;
+            try {
+                final Context context = Factory.get().getApplicationContext();
+                final ContentResolver resolver = context.getContentResolver();
+                cursor = SqliteWrapper.query(
+                        context,
+                        resolver,
+                        Telephony.Carriers.CONTENT_URI,
+                        TEST_CARRIERS_PROJECTION,
+                        null/*selection*/,
+                        null/*selectionArgs*/,
+                        null);
+                sUseSystemApn = true;
+            } catch (final SecurityException e) {
+                LogUtil.w(TAG, "Can't access system APN, using internal table", e);
+                sUseSystemApn = false;
+            } finally {
+                if (cursor != null) {
+                    cursor.close();
+                }
+            }
+        }
+        return sUseSystemApn;
+    }
+
+    // For the internal debugger only
+    public static void setUseSystemApnTable(final boolean turnOn) {
+        if (!turnOn) {
+            // We're not turning on to the system table. Instead, we're using our internal table.
+            final int osVersion = OsUtil.getApiVersion();
+            if (osVersion != android.os.Build.VERSION_CODES.JELLY_BEAN_MR1) {
+                // We're turning on local APNs on a device where we wouldn't normally have the
+                // local APN table. Build it here.
+
+                final SQLiteDatabase database = ApnDatabase.getApnDatabase().getWritableDatabase();
+
+                // Do we already have the table?
+                Cursor cursor = null;
+                try {
+                    cursor = database.query(ApnDatabase.APN_TABLE,
+                            ApnDatabase.APN_PROJECTION,
+                            null, null, null, null, null, null);
+                } catch (final Exception e) {
+                    // Apparently there's no table, create it now.
+                    ApnDatabase.forceBuildAndLoadApnTables();
+                } finally {
+                    if (cursor != null) {
+                        cursor.close();
+                    }
+                }
+            }
+        }
+        sUseSystemApn = turnOn;
+    }
+
+    /**
+     * Checks if we should dump sms, based on both the setting and the global debug
+     * flag
+     *
+     * @return if dump sms is enabled
+     */
+    public static boolean isDumpSmsEnabled() {
+        if (!DebugUtils.isDebugEnabled()) {
+            return false;
+        }
+        return getDumpSmsOrMmsPref(R.string.dump_sms_pref_key, R.bool.dump_sms_pref_default);
+    }
+
+    /**
+     * Checks if we should dump mms, based on both the setting and the global debug
+     * flag
+     *
+     * @return if dump mms is enabled
+     */
+    public static boolean isDumpMmsEnabled() {
+        if (!DebugUtils.isDebugEnabled()) {
+            return false;
+        }
+        return getDumpSmsOrMmsPref(R.string.dump_mms_pref_key, R.bool.dump_mms_pref_default);
+    }
+
+    /**
+     * Load the value of dump sms or mms setting preference
+     */
+    private static boolean getDumpSmsOrMmsPref(final int prefKeyRes, final int defaultKeyRes) {
+        final Context context = Factory.get().getApplicationContext();
+        final Resources resources = context.getResources();
+        final BuglePrefs prefs = BuglePrefs.getApplicationPrefs();
+        final String key = resources.getString(prefKeyRes);
+        final boolean defaultValue = resources.getBoolean(defaultKeyRes);
+        return prefs.getBoolean(key, defaultValue);
+    }
+
+    public static final Uri MMS_PART_CONTENT_URI = Uri.parse("content://mms/part");
+
+    /**
+     * Load MMS from telephony
+     *
+     * @param mmsUri The MMS pdu Uri
+     * @return A memory copy of the MMS pdu including parts (but not addresses)
+     */
+    public static DatabaseMessages.MmsMessage loadMms(final Uri mmsUri) {
+        final Context context = Factory.get().getApplicationContext();
+        final ContentResolver resolver = context.getContentResolver();
+        DatabaseMessages.MmsMessage mms = null;
+        Cursor cursor = null;
+        // Load pdu first
+        try {
+            cursor = SqliteWrapper.query(context, resolver,
+                    mmsUri,
+                    DatabaseMessages.MmsMessage.getProjection(),
+                    null/*selection*/, null/*selectionArgs*/, null/*sortOrder*/);
+            if (cursor != null && cursor.moveToFirst()) {
+                mms = DatabaseMessages.MmsMessage.get(cursor);
+            }
+        } catch (final SQLiteException e) {
+            LogUtil.e(TAG, "MmsLoader: query pdu failure: " + e, e);
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+        if (mms == null) {
+            return null;
+        }
+        // Load parts except SMIL
+        // TODO: we may need to load SMIL part in the future.
+        final long rowId = MmsUtils.parseRowIdFromMessageUri(mmsUri);
+        final String selection = String.format(
+                Locale.US,
+                "%s != '%s' AND %s = ?",
+                Mms.Part.CONTENT_TYPE,
+                ContentType.APP_SMIL,
+                Mms.Part.MSG_ID);
+        cursor = null;
+        try {
+            cursor = SqliteWrapper.query(context, resolver,
+                    MMS_PART_CONTENT_URI,
+                    DatabaseMessages.MmsPart.PROJECTION,
+                    selection,
+                    new String[] { Long.toString(rowId) },
+                    null/*sortOrder*/);
+            if (cursor != null) {
+                while (cursor.moveToNext()) {
+                    mms.addPart(DatabaseMessages.MmsPart.get(cursor, true/*loadMedia*/));
+                }
+            }
+        } catch (final SQLiteException e) {
+            LogUtil.e(TAG, "MmsLoader: query parts failure: " + e, e);
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+        return mms;
+    }
+
+    /**
+     * Get the sender of an MMS message
+     *
+     * @param recipients The recipient list of the message
+     * @param mmsUri The pdu uri of the MMS
+     * @return The sender phone number of the MMS
+     */
+    public static String getMmsSender(final List<String> recipients, final String mmsUri) {
+        final Context context = Factory.get().getApplicationContext();
+        // We try to avoid the database query.
+        // If this is a 1v1 conv., then the other party is the sender
+        if (recipients != null && recipients.size() == 1) {
+            return recipients.get(0);
+        }
+        // Otherwise, we have to query the MMS addr table for sender address
+        // This should only be done for a received group mms message
+        final Cursor cursor = SqliteWrapper.query(
+                context,
+                context.getContentResolver(),
+                Uri.withAppendedPath(Uri.parse(mmsUri), "addr"),
+                new String[] { Mms.Addr.ADDRESS, Mms.Addr.CHARSET },
+                Mms.Addr.TYPE + "=" + PduHeaders.FROM,
+                null/*selectionArgs*/,
+                null/*sortOrder*/);
+        if (cursor != null) {
+            try {
+                if (cursor.moveToFirst()) {
+                    return DatabaseMessages.MmsAddr.get(cursor);
+                }
+            } finally {
+                cursor.close();
+            }
+        }
+        return null;
+    }
+
+    public static int bugleStatusForMms(final boolean isOutgoing, final boolean isNotification,
+            final int messageBox) {
+        int bugleStatus = MessageData.BUGLE_STATUS_UNKNOWN;
+        // For a message we sync either
+        if (isOutgoing) {
+            if (messageBox == Mms.MESSAGE_BOX_OUTBOX || messageBox == Mms.MESSAGE_BOX_FAILED) {
+                // Not sent counts as failed and available for manual resend
+                bugleStatus = MessageData.BUGLE_STATUS_OUTGOING_FAILED;
+            } else {
+                // Otherwise outgoing message is complete
+                bugleStatus = MessageData.BUGLE_STATUS_OUTGOING_COMPLETE;
+            }
+        } else if (isNotification) {
+            // Incoming MMS notifications we sync count as failed and available for manual download
+            bugleStatus = MessageData.BUGLE_STATUS_INCOMING_YET_TO_MANUAL_DOWNLOAD;
+        } else {
+            // Other incoming MMS messages are complete
+            bugleStatus = MessageData.BUGLE_STATUS_INCOMING_COMPLETE;
+        }
+        return bugleStatus;
+    }
+
+    public static MessageData createMmsMessage(final DatabaseMessages.MmsMessage mms,
+            final String conversationId, final String participantId, final String selfId,
+            final int bugleStatus) {
+        Assert.notNull(mms);
+        final boolean isNotification = (mms.mMmsMessageType ==
+                PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND);
+        final int rawMmsStatus = (bugleStatus < MessageData.BUGLE_STATUS_FIRST_INCOMING
+                ? mms.mRetrieveStatus : mms.mResponseStatus);
+
+        final MessageData message = MessageData.createMmsMessage(mms.getUri(),
+                participantId, selfId, conversationId, isNotification, bugleStatus,
+                mms.mContentLocation, mms.mTransactionId, mms.mPriority, mms.mSubject,
+                mms.mSeen, mms.mRead, mms.getSize(), rawMmsStatus,
+                mms.mExpiryInMillis, mms.mSentTimestampInMillis, mms.mTimestampInMillis);
+
+        for (final DatabaseMessages.MmsPart part : mms.mParts) {
+            final ArrayList<MessagePartData> messagePartList = MmsUtils.createMmsMessagePart(part);
+            // Import media and text parts (skip SMIL and others)
+            for (MessagePartData p : messagePartList) {
+                if (p != null) {
+                    message.addPart(p);
+                }
+            }
+        }
+
+        if (!message.getParts().iterator().hasNext()) {
+            message.addPart(MessagePartData.createEmptyMessagePart());
+        }
+
+        return message;
+    }
+
+    /*Modify by SPRD for Bug550257  2016.04.14 Start*/
+    public static ArrayList<MessagePartData> createMmsMessagePart(final DatabaseMessages.MmsPart part) {
+        ArrayList<MessagePartData> messagePartList = new ArrayList<MessagePartData>();
+        if (part.isText()) {
+            final int mmsTextLengthLimit =
+                    BugleGservices.get().getInt(BugleGservicesKeys.MMS_TEXT_LIMIT,
+                            BugleGservicesKeys.MMS_TEXT_LIMIT_DEFAULT);
+            String text = part.mText;
+            if (text != null && text.length() > mmsTextLengthLimit) {
+                // Limit the text to a reasonable value. We ran into a situation where a vcard
+                // with a photo was sent as plain text. The massive amount of text caused the
+                // app to hang, ANR, and eventually crash in native text code.
+                int partLen = 0;
+                String textPart;
+                for (int lastList = text.length(); lastList > 0; lastList -= mmsTextLengthLimit) {
+                    textPart = text.substring(partLen,
+                            lastList < mmsTextLengthLimit ? (lastList + partLen) : (partLen + mmsTextLengthLimit));
+                    messagePartList.add(MessagePartData.createTextMessagePart(textPart));
+                    partLen += mmsTextLengthLimit;
+                }
+            } else if (text != null) {
+                messagePartList.add(MessagePartData.createTextMessagePart(text));
+            }
+        } else if (part.isMedia()) {
+            messagePartList.add(MessagePartData.createMediaMessagePart(part.mContentType,
+                    part.getDataUri(), MessagePartData.UNSPECIFIED_SIZE,
+                    MessagePartData.UNSPECIFIED_SIZE));
+        }else{
+            messagePartList.add(MessagePartData.createMediaMessagePart(part.mContentType,
+                    part.getDataUri(), MessagePartData.UNSPECIFIED_SIZE,
+                    MessagePartData.UNSPECIFIED_SIZE));
+        }
+        return messagePartList;
+    }
+    /*Modify by SPRD for Bug550257  2016.04.14 End*/
+
+    public static class StatusPlusUri {
+        // The request status to be as the result of the operation
+        // e.g. MMS_REQUEST_MANUAL_RETRY
+        public final int status;
+        // The raw telephony status
+        public final int rawStatus;
+        // The raw telephony URI
+        public final Uri uri;
+        // The operation result code from system api invocation (sent by system)
+        // or mapped from internal exception (sent by app)
+        public final int resultCode;
+
+        public StatusPlusUri(final int status, final int rawStatus, final Uri uri) {
+            this.status = status;
+            this.rawStatus = rawStatus;
+            this.uri = uri;
+            resultCode = MessageData.UNKNOWN_RESULT_CODE;
+        }
+
+        public StatusPlusUri(final int status, final int rawStatus, final Uri uri,
+                final int resultCode) {
+            this.status = status;
+            this.rawStatus = rawStatus;
+            this.uri = uri;
+            this.resultCode = resultCode;
+        }
+    }
+
+    public static class SendReqResp {
+        public SendReq mSendReq;
+        public SendConf mSendConf;
+
+        public SendReqResp(final SendReq sendReq, final SendConf sendConf) {
+            mSendReq = sendReq;
+            mSendConf = sendConf;
+        }
+    }
+
+    /**
+     * Returned when sending/downloading MMS via platform APIs. In that case, we have to wait to
+     * receive the pending intent to determine status.
+     */
+    public static final StatusPlusUri STATUS_PENDING = new StatusPlusUri(-1, -1, null);
+
+    public static StatusPlusUri downloadMmsMessage(final Context context, final Uri notificationUri,
+            final int subId, final String subPhoneNumber, final String transactionId,
+            final String contentLocation, final boolean autoDownload,
+            final long receivedTimestampInSeconds, Bundle extras) {
+        if (TextUtils.isEmpty(contentLocation)) {
+            LogUtil.e(TAG, "MmsUtils: Download from empty content location URL");
+            return new StatusPlusUri(
+                    MMS_REQUEST_NO_RETRY, MessageData.RAW_TELEPHONY_STATUS_UNDEFINED, null);
+        }
+
+        if (!isMmsDataAvailable(subId)) {
+            LogUtil.e(TAG,
+                    "MmsUtils: failed to download message, no data available");
+            return new StatusPlusUri(MMS_REQUEST_MANUAL_RETRY,
+                    MessageData.RAW_TELEPHONY_STATUS_UNDEFINED,
+                    null,
+                    SmsManager.MMS_ERROR_NO_DATA_NETWORK);
+        }
+        int status = MMS_REQUEST_MANUAL_RETRY;
+        try {
+            RetrieveConf retrieveConf = null;
+            if (DebugUtils.isDebugEnabled() &&
+                    MediaScratchFileProvider
+                            .isMediaScratchSpaceUri(Uri.parse(contentLocation))) {
+                if (LogUtil.isLoggable(TAG, LogUtil.DEBUG)) {
+                    LogUtil.d(TAG, "MmsUtils: Reading MMS from dump file: " + contentLocation);
+                }
+                final String fileName = Uri.parse(contentLocation).getPathSegments().get(1);
+                final byte[] data = DebugUtils.receiveFromDumpFile(fileName);
+                retrieveConf = receiveFromDumpFile(data);
+            } else {
+                if (LogUtil.isLoggable(TAG, LogUtil.DEBUG)) {
+                    LogUtil.d(TAG, "MmsUtils: Downloading MMS via MMS lib API; notification "
+                            + "message: " + notificationUri);
+                }
+                if (OsUtil.isAtLeastL_MR1()) {
+                    if (subId < 0) {
+                        LogUtil.e(TAG, "MmsUtils: Incoming MMS came from unknown SIM");
+                        throw new MmsFailureException(MMS_REQUEST_NO_RETRY,
+                                "Message from unknown SIM");
+                    }
+                } else {
+                    Assert.isTrue(subId == ParticipantData.DEFAULT_SELF_SUB_ID);
+                }
+                if (extras == null) {
+                    extras = new Bundle();
+                }
+                extras.putParcelable(DownloadMmsAction.EXTRA_NOTIFICATION_URI, notificationUri);
+                extras.putInt(DownloadMmsAction.EXTRA_SUB_ID, subId);
+                extras.putString(DownloadMmsAction.EXTRA_SUB_PHONE_NUMBER, subPhoneNumber);
+                extras.putString(DownloadMmsAction.EXTRA_TRANSACTION_ID, transactionId);
+                extras.putString(DownloadMmsAction.EXTRA_CONTENT_LOCATION, contentLocation);
+                extras.putBoolean(DownloadMmsAction.EXTRA_AUTO_DOWNLOAD, autoDownload);
+                extras.putLong(DownloadMmsAction.EXTRA_RECEIVED_TIMESTAMP,
+                        receivedTimestampInSeconds);
+
+                MmsSender.downloadMms(context, subId, contentLocation, extras);
+                return STATUS_PENDING; // Download happens asynchronously; no status to return
+            }
+            return insertDownloadedMessageAndSendResponse(context, notificationUri, subId,
+                    subPhoneNumber, transactionId, contentLocation, autoDownload,
+                    receivedTimestampInSeconds, retrieveConf);
+
+        } catch (final MmsFailureException e) {
+            LogUtil.e(TAG, "MmsUtils: failed to download message " + notificationUri, e);
+            status = e.retryHint;
+        } catch (final InvalidHeaderValueException e) {
+            LogUtil.e(TAG, "MmsUtils: failed to download message " + notificationUri, e);
+        }
+        return new StatusPlusUri(status, PDU_HEADER_VALUE_UNDEFINED, null);
+    }
+
+    public static StatusPlusUri insertDownloadedMessageAndSendResponse(final Context context,
+            final Uri notificationUri, final int subId, final String subPhoneNumber,
+            final String transactionId, final String contentLocation,
+            final boolean autoDownload, final long receivedTimestampInSeconds,
+            final RetrieveConf retrieveConf) {
+        final byte[] transactionIdBytes = stringToBytes(transactionId, "UTF-8");
+        Uri messageUri = null;
+        int status = MMS_REQUEST_MANUAL_RETRY;
+        int retrieveStatus = PDU_HEADER_VALUE_UNDEFINED;
+
+        retrieveStatus = retrieveConf.getRetrieveStatus();
+        if (retrieveStatus == PduHeaders.RETRIEVE_STATUS_OK) {
+            status = MMS_REQUEST_SUCCEEDED;
+        } else if (retrieveStatus >= PduHeaders.RETRIEVE_STATUS_ERROR_TRANSIENT_FAILURE &&
+                retrieveStatus < PduHeaders.RETRIEVE_STATUS_ERROR_PERMANENT_FAILURE) {
+            status = MMS_REQUEST_AUTO_RETRY;
+        } else {
+            // else not meant to retry download
+            status = MMS_REQUEST_NO_RETRY;
+            LogUtil.e(TAG, "MmsUtils: failed to retrieve message; retrieveStatus: "
+                    + retrieveStatus);
+        }
+        final ContentValues values = new ContentValues(1);
+        values.put(Mms.RETRIEVE_STATUS, retrieveConf.getRetrieveStatus());
+        SqliteWrapper.update(context, context.getContentResolver(),
+                notificationUri, values, null, null);
+
+        if (status == MMS_REQUEST_SUCCEEDED) {
+            // Send response of the notification
+            if (autoDownload) {
+                sendNotifyResponseForMmsDownload(context, subId, transactionIdBytes,
+                        contentLocation, PduHeaders.STATUS_RETRIEVED);
+            } else {
+                sendAcknowledgeForMmsDownload(context, subId, transactionIdBytes, contentLocation);
+            }
+
+            // Insert downloaded message into telephony
+            final Uri inboxUri = MmsUtils.insertReceivedMmsMessage(context, retrieveConf, subId,
+                    subPhoneNumber, receivedTimestampInSeconds, contentLocation);
+            messageUri = ContentUris.withAppendedId(Mms.CONTENT_URI, ContentUris.parseId(inboxUri));
+        } else if (status == MMS_REQUEST_AUTO_RETRY) {
+            // For a retry do nothing
+        } else if (status == MMS_REQUEST_MANUAL_RETRY && autoDownload) {
+            // Failure from autodownload - just treat like manual download
+            sendNotifyResponseForMmsDownload(context, subId, transactionIdBytes,
+                    contentLocation, PduHeaders.STATUS_DEFERRED);
+        }
+        return new StatusPlusUri(status, retrieveStatus, messageUri);
+    }
+
+    /**
+     * Send response for MMS download - catches and ignores errors
+     */
+    public static void sendNotifyResponseForMmsDownload(final Context context, final int subId,
+            final byte[] transactionId, final String contentLocation, final int status) {
+        try {
+            if (LogUtil.isLoggable(TAG, LogUtil.DEBUG)) {
+                LogUtil.d(TAG, "MmsUtils: Sending M-NotifyResp.ind for received MMS, status: "
+                        + String.format("0x%X", status));
+            }
+            if (contentLocation == null) {
+                LogUtil.w(TAG, "MmsUtils: Can't send NotifyResp; contentLocation is null");
+                return;
+            }
+            if (transactionId == null) {
+                LogUtil.w(TAG, "MmsUtils: Can't send NotifyResp; transaction id is null");
+                return;
+            }
+            if (!isMmsDataAvailable(subId)) {
+                LogUtil.w(TAG, "MmsUtils: Can't send NotifyResp; no data available");
+                return;
+            }
+            MmsSender.sendNotifyResponseForMmsDownload(
+                    context, subId, transactionId, contentLocation, status);
+        } catch (final MmsFailureException e) {
+            LogUtil.e(TAG, "sendNotifyResponseForMmsDownload: failed to retrieve message " + e, e);
+        } catch (final InvalidHeaderValueException e) {
+            LogUtil.e(TAG, "sendNotifyResponseForMmsDownload: failed to retrieve message " + e, e);
+        }
+    }
+
+    /**
+     * Send acknowledge for mms download - catched and ignores errors
+     */
+    public static void sendAcknowledgeForMmsDownload(final Context context, final int subId,
+            final byte[] transactionId, final String contentLocation) {
+        try {
+            if (LogUtil.isLoggable(TAG, LogUtil.DEBUG)) {
+                LogUtil.d(TAG, "MmsUtils: Sending M-Acknowledge.ind for received MMS");
+            }
+            if (contentLocation == null) {
+                LogUtil.w(TAG, "MmsUtils: Can't send AckInd; contentLocation is null");
+                return;
+            }
+            if (transactionId == null) {
+                LogUtil.w(TAG, "MmsUtils: Can't send AckInd; transaction id is null");
+                return;
+            }
+            if (!isMmsDataAvailable(subId)) {
+                LogUtil.w(TAG, "MmsUtils: Can't send AckInd; no data available");
+                return;
+            }
+            MmsSender.sendAcknowledgeForMmsDownload(context, subId, transactionId, contentLocation);
+        } catch (final MmsFailureException e) {
+            LogUtil.e(TAG, "sendAcknowledgeForMmsDownload: failed to retrieve message " + e, e);
+        } catch (final InvalidHeaderValueException e) {
+            LogUtil.e(TAG, "sendAcknowledgeForMmsDownload: failed to retrieve message " + e, e);
+        }
+    }
+
+    /**
+     * Try parsing a PDU without knowing the carrier. This is useful for importing
+     * MMS or storing draft when carrier info is not available
+     *
+     * @param data The PDU data
+     * @return Parsed PDU, null if failed to parse
+     */
+    private static GenericPdu parsePduForAnyCarrier(final byte[] data) {
+        GenericPdu pdu = null;
+        try {
+            pdu = (new PduParser(data, true/*parseContentDisposition*/)).parse();
+        } catch (final RuntimeException e) {
+            LogUtil.d(TAG, "parsePduForAnyCarrier: Failed to parse PDU with content disposition",
+                    e);
+        }
+        if (pdu == null) {
+            try {
+                pdu = (new PduParser(data, false/*parseContentDisposition*/)).parse();
+            } catch (final RuntimeException e) {
+                LogUtil.d(TAG,
+                        "parsePduForAnyCarrier: Failed to parse PDU without content disposition",
+                        e);
+            }
+        }
+        return pdu;
+    }
+
+    private static RetrieveConf receiveFromDumpFile(final byte[] data) throws MmsFailureException {
+        final GenericPdu pdu = parsePduForAnyCarrier(data);
+        if (pdu == null || !(pdu instanceof RetrieveConf)) {
+            LogUtil.e(TAG, "receiveFromDumpFile: Parsing retrieved PDU failure");
+            throw new MmsFailureException(MMS_REQUEST_MANUAL_RETRY, "Failed reading dump file");
+        }
+        return (RetrieveConf) pdu;
+    }
+
+    private static boolean isMmsDataAvailable(final int subId) {
+       /* if (OsUtil.isAtLeastL_MR1()) {
+            // L_MR1 above may support sending mms via wifi
+            return true;
+        }*/
+        final PhoneUtils phoneUtils = PhoneUtils.get(subId);
+        return !phoneUtils.isAirplaneModeOn() && /*phoneUtils.isMobileDataEnabled() &&*/ phoneUtils.hasSim();
+
+    }
+
+    private static boolean isSmsDataAvailable(final int subId) {
+       /* if (OsUtil.isAtLeastL_MR1()) {
+            // L_MR1 above may support sending sms via wifi
+            return true;
+        }*/
+        final PhoneUtils phoneUtils = PhoneUtils.get(subId);
+        return !phoneUtils.isAirplaneModeOn() && phoneUtils.hasSim();
+    }
+
+    public static boolean isMobileDataEnabled(final int subId) {
+        final PhoneUtils phoneUtils = PhoneUtils.get(subId);
+        return phoneUtils.isMobileDataEnabled();
+    }
+
+    public static boolean isAirplaneModeOn(final int subId) {
+        final PhoneUtils phoneUtils = PhoneUtils.get(subId);
+        return phoneUtils.isAirplaneModeOn();
+    }
+
+    public static StatusPlusUri sendMmsMessage(final Context context, final int subId,
+            final Uri messageUri, final Bundle extras) {
+        int status = MMS_REQUEST_MANUAL_RETRY;
+
+        int rawStatus = MessageData.RAW_TELEPHONY_STATUS_UNDEFINED;
+
+        if (!isMmsDataAvailable(subId)) {
+            LogUtil.w(TAG, "MmsUtils: failed to send message, no data available");
+            return new StatusPlusUri(MMS_REQUEST_MANUAL_RETRY,
+                    MessageData.RAW_TELEPHONY_STATUS_UNDEFINED,
+                    messageUri,
+                    SmsManager.MMS_ERROR_NO_DATA_NETWORK);
+        }
+        final PduPersister persister = PduPersister.getPduPersister(context);
+        try {
+            final SendReq sendReq = (SendReq) persister.load(messageUri);
+            if (sendReq == null) {
+                LogUtil.w(TAG, "MmsUtils: Sending MMS was deleted; uri = " + messageUri);
+                return new StatusPlusUri(MMS_REQUEST_NO_RETRY,
+                        MessageData.RAW_TELEPHONY_STATUS_UNDEFINED, messageUri);
+            }
+            if (LogUtil.isLoggable(TAG, LogUtil.DEBUG)) {
+                LogUtil.d(TAG, String.format("MmsUtils: Sending MMS, message uri: %s", messageUri));
+            }
+            extras.putInt(SendMessageAction.KEY_SUB_ID, subId);
+            MmsSender.sendMms(context, subId, messageUri, sendReq, extras);
+            return STATUS_PENDING;
+        }catch (final IllegalArgumentException e) {
+//            android.util.Log.d("jinqiming","IllegalArgumentException");
+//            if (e.getMessage().contains("Invalid FDN destinationAddress")) {
+//                //LogUtil.e(TAG, "MmsUtils: Invalid FDN destinationAddress " + e, e);
+//                android.util.Log.d("jinqiming","sendMmsMessage");
+//                // fdn feature toast end
+//                boolean showToat = true ;
+//                if (GlobleUtil.mGropMmsMessagingTotalCount ==0) {
+//                    showToat = false;
+//                }
+//                android.util.Log.d("jinqiming","showToat ="+showToat);
+//                if (showToat) {
+//                    GlobleUtil.mGropMmsMessagingTotalCount = 0;
+//                    Message msgflag = GlobleUtil.mGlobleHandler.obtainMessage();
+//                    msgflag.what = GlobleUtil.FDN_TOAST_MSG;
+//                    msgflag.obj = Factory.get().getApplicationContext()
+//                            .getString(R.string.fdn_check_failure);
+//                    GlobleUtil.mGlobleHandler.sendMessage(msgflag);
+//                }
+//                //status = SendResult.FAILURE_LEVEL_PERMANENT;
+//            }
+            LogUtil.e(TAG, "MmsUtils: invalid message to send " + e, e);
+        } catch (final MmsFailureException e) {
+            status = e.retryHint;
+            rawStatus = e.rawStatus;
+            LogUtil.e(TAG, "MmsUtils: failed to send message " + e, e);
+        } catch (final InvalidHeaderValueException e) {
+            LogUtil.e(TAG, "MmsUtils: failed to send message " + e, e);
+        } catch (final MmsException e) {
+            LogUtil.e(TAG, "MmsUtils: failed to send message " + e, e);
+        }
+        // If we get here, some exception occurred
+        return new StatusPlusUri(status, rawStatus, messageUri);
+    }
+
+    //489220 begin
+    public static String getFrom(Context context, Uri uri) {
+        String msgId = uri.getLastPathSegment();
+        Uri.Builder builder = Mms.CONTENT_URI.buildUpon();
+
+        builder.appendPath(msgId).appendPath("addr");
+
+        Cursor cursor = SqliteWrapper.query(context, context.getContentResolver(),
+                builder.build(), new String[] {Addr.ADDRESS, Addr.CHARSET},
+                Addr.TYPE + "=" + PduHeaders.FROM, null, null);
+
+        if (cursor != null) {
+            try {
+                if (cursor.moveToFirst()) {
+                    String from = cursor.getString(0);
+
+                    if (!TextUtils.isEmpty(from)) {
+                        byte[] bytes = PduPersister.getBytes(from);
+                        int charset = cursor.getInt(1);
+                        return new EncodedStringValue(charset, bytes)
+                                .getString();
+                    }
+                }
+            } finally {
+                cursor.close();
+            }
+        }
+        return context.getString(R.string.hidden_sender_address);
+    }
+
+    public static void sendReadRec(final Context context, final int subId, String to, String messageId, int status) {
+        EncodedStringValue[] sender = new EncodedStringValue[1];
+        sender[0] = new EncodedStringValue(to);
+        try {
+            final ReadRecInd readRec = new ReadRecInd(
+                    new EncodedStringValue(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR.getBytes()),
+                    messageId.getBytes(),
+                    PduHeaders.CURRENT_MMS_VERSION,
+                    status,
+                    sender);
+
+            readRec.setDate(System.currentTimeMillis() / 1000);
+
+            MmsSender.sendMmsReadRec(context, subId, null, readRec, null);
+        } catch (InvalidHeaderValueException e) {
+            LogUtil.e(TAG, "Invalide header value", e);
+        } catch (MmsFailureException e) {
+            LogUtil.e(TAG, "sendReadRec message failed", e);
+        }
+    }
+
+    private static long findThreadId(Context context, GenericPdu pdu, int type) {
+        String messageId;
+
+        if (type == PduHeaders.MESSAGE_TYPE_DELIVERY_IND) {
+            messageId = new String(((DeliveryInd) pdu).getMessageId());
+        } else {
+            messageId = new String(((ReadOrigInd) pdu).getMessageId());
+        }
+        StringBuilder sb = new StringBuilder('(');
+        sb.append(Mms.MESSAGE_ID);
+        sb.append('=');
+        sb.append(DatabaseUtils.sqlEscapeString(messageId));
+        sb.append(" AND ");
+        sb.append(Mms.MESSAGE_TYPE);
+        sb.append('=');
+        sb.append(PduHeaders.MESSAGE_TYPE_SEND_REQ);
+
+        Cursor cursor = SqliteWrapper.query(context,
+                context.getContentResolver(), Mms.CONTENT_URI,
+                new String[] { Mms.THREAD_ID }, sb.toString(), null, null);
+        if (cursor != null) {
+            try {
+                if ((cursor.getCount() == 1) && cursor.moveToFirst()) {
+                    return cursor.getLong(0);
+                }
+            } finally {
+                cursor.close();
+            }
+        }
+
+        return -1;
+    }
+
+    /**
+     * Try to find transactionId in Telephony DB by a DeliveryInd pdu
+     * @param context
+     * @param pdu
+     * @param type pdu type
+     * @return The transactionId if found or null
+     */
+    private static String findTransactionId(Context context, GenericPdu pdu,
+            int type) {
+        String transactionId;
+        String messageId;
+        if (type == PduHeaders.MESSAGE_TYPE_DELIVERY_IND) {
+            messageId = new String(((DeliveryInd) pdu).getMessageId());
+        } else {
+            LogUtil.e(TAG, "findTransactionId: Wrong pdu type!");
+            return null;
+        }
+        StringBuilder selection = new StringBuilder(128);
+        selection.append(Mms.MESSAGE_ID);
+        selection.append('=');
+        selection.append(DatabaseUtils.sqlEscapeString(messageId));
+        selection.append(" AND ");
+        selection.append(Mms.MESSAGE_TYPE);
+        selection.append('=');
+        selection.append(PduHeaders.MESSAGE_TYPE_SEND_REQ);
+
+        Cursor cursor = SqliteWrapper.query(context,
+                context.getContentResolver(), Mms.CONTENT_URI,
+                new String[] { Mms.TRANSACTION_ID }, selection.toString(),
+                null, null);
+        if (cursor != null) {
+            try {
+                if ((cursor.getCount() == 1) && cursor.moveToFirst()) {
+                    return cursor.getString(0);
+                }
+            } finally {
+                cursor.close();
+            }
+        }
+        return null;
+    }
+    /**
+     * Try to find the smsMessageUri in Messaging DB by given transactionId
+     * @param transactionId
+     * @return The smsMessageUri if found or null
+     */
+    private static Uri findSmsMessageUriByTransactionId(String transactionId) {
+        final DatabaseWrapper db = DataModel.get().getDatabase();
+        if (null == transactionId) {
+            LogUtil.e(TAG,
+                    "findSmsMessageUriByTransactionId: transactionId is null!");
+            return null;
+        }
+        Cursor cursor = db.query(DatabaseHelper.MESSAGES_TABLE, // searchTable
+                new String[] { DatabaseHelper.MessageColumns.SMS_MESSAGE_URI }, // projection
+                DatabaseHelper.MessageColumns.MMS_TRANSACTION_ID + "= ?", // selection
+                new String[] { transactionId }, // selectionArgs
+                null, null, null);
+        if (cursor != null) {
+            try {
+                if ((cursor.getCount() == 1) && cursor.moveToFirst()) {
+                    return Uri.parse(cursor.getString(0));
+                }
+            } finally {
+                cursor.close();
+            }
+        }
+        LogUtil.e(TAG,
+                "findSmsMessageUriByTransactionId: Can't find SmsMessageUri!");
+        return null;
+    }
+    // 489220 end
+
+    public static StatusPlusUri updateSentMmsMessageStatus(final Context context,
+            final Uri messageUri, final SendConf sendConf) {
+        int status = MMS_REQUEST_MANUAL_RETRY;
+        final int respStatus = sendConf.getResponseStatus();
+
+        final ContentValues values = new ContentValues(2);
+        values.put(Mms.RESPONSE_STATUS, respStatus);
+        final byte[] messageId = sendConf.getMessageId();
+        if (messageId != null && messageId.length > 0) {
+            values.put(Mms.MESSAGE_ID, PduPersister.toIsoString(messageId));
+        }
+        SqliteWrapper.update(context, context.getContentResolver(),
+                messageUri, values, null, null);
+        if (respStatus == PduHeaders.RESPONSE_STATUS_OK) {
+            status = MMS_REQUEST_SUCCEEDED;
+        } else if (respStatus == PduHeaders.RESPONSE_STATUS_ERROR_TRANSIENT_FAILURE ||
+                respStatus == PduHeaders.RESPONSE_STATUS_ERROR_TRANSIENT_NETWORK_PROBLEM ||
+                respStatus == PduHeaders.RESPONSE_STATUS_ERROR_TRANSIENT_PARTIAL_SUCCESS) {
+            status = MMS_REQUEST_AUTO_RETRY;
+        } else {
+            // else permanent failure
+            LogUtil.e(TAG, "MmsUtils: failed to send message; respStatus = "
+                    + String.format("0x%X", respStatus));
+        }
+        return new StatusPlusUri(status, respStatus, messageUri);
+    }
+
+    public static void clearMmsStatus(final Context context, final Uri uri) {
+        // Messaging application can leave invalid values in STATUS field of M-Notification.ind
+        // messages.  Take this opportunity to clear it.
+        // Downloading status just kept in local db and not reflected into telephony.
+        final ContentValues values = new ContentValues(1);
+        values.putNull(Mms.STATUS);
+        SqliteWrapper.update(context, context.getContentResolver(),
+                    uri, values, null, null);
+    }
+
+    // Selection for new dedup algorithm:
+    // ((m_type<>130) OR (exp>NOW)) AND (date>NOW-7d) AND (date<NOW+7d) AND (ct_l=xxxxxx)
+    // i.e. If it is NotificationInd and not expired or not NotificationInd
+    //      AND message is received with +/- 7 days from now
+    //      AND content location is the input URL
+    private static final String DUP_NOTIFICATION_QUERY_SELECTION =
+            "((" + Mms.MESSAGE_TYPE + "<>?) OR (" + Mms.EXPIRY + ">?)) AND ("
+                    + Mms.DATE + ">?) AND (" + Mms.DATE + "<?) AND (" + Mms.CONTENT_LOCATION +
+                    "=?)";
+    // Selection for old behavior: only checks NotificationInd and its content location
+    private static final String DUP_NOTIFICATION_QUERY_SELECTION_OLD =
+            "(" + Mms.MESSAGE_TYPE + "=?) AND (" + Mms.CONTENT_LOCATION + "=?)";
+
+    private static final int MAX_RETURN = 32;
+    private static String[] getDupNotifications(final Context context, final NotificationInd nInd) {
+        final byte[] rawLocation = nInd.getContentLocation();
+        if (rawLocation != null) {
+            final String location = new String(rawLocation);
+            // We can not be sure if the content location of an MMS is globally and historically
+            // unique. So we limit the dedup time within the last 7 days
+            // (or configured by gservices remotely). If the same content location shows up after
+            // that, we will download regardless. Duplicated message is better than no message.
+            String selection;
+            String[] selectionArgs;
+            final long timeLimit = BugleGservices.get().getLong(
+                    BugleGservicesKeys.MMS_WAP_PUSH_DEDUP_TIME_LIMIT_SECS,
+                    BugleGservicesKeys.MMS_WAP_PUSH_DEDUP_TIME_LIMIT_SECS_DEFAULT);
+            if (timeLimit > 0) {
+                // New dedup algorithm
+                selection = DUP_NOTIFICATION_QUERY_SELECTION;
+                final long nowSecs = System.currentTimeMillis() / 1000;
+                final long timeLowerBoundSecs = nowSecs - timeLimit;
+                // Need upper bound to protect against clock change so that a message has a time
+                // stamp in the future
+                final long timeUpperBoundSecs = nowSecs + timeLimit;
+                selectionArgs = new String[] {
+                        Integer.toString(PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND),
+                        Long.toString(nowSecs),
+                        Long.toString(timeLowerBoundSecs),
+                        Long.toString(timeUpperBoundSecs),
+                        location
+                };
+            } else {
+                // If time limit is 0, we revert back to old behavior in case the new
+                // dedup algorithm behaves badly
+                selection = DUP_NOTIFICATION_QUERY_SELECTION_OLD;
+                selectionArgs = new String[] {
+                        Integer.toString(PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND),
+                        location
+                };
+            }
+            Cursor cursor = null;
+            try {
+                cursor = SqliteWrapper.query(
+                        context, context.getContentResolver(),
+                        Mms.CONTENT_URI, new String[] { Mms._ID },
+                        selection, selectionArgs, null);
+                final int dupCount = cursor.getCount();
+                if (dupCount > 0) {
+                    // We already received the same notification before.
+                    // Don't want to return too many dups. It is only for debugging.
+                    final int returnCount = dupCount < MAX_RETURN ? dupCount : MAX_RETURN;
+                    final String[] dups = new String[returnCount];
+                    for (int i = 0; cursor.moveToNext() && i < returnCount; i++) {
+                        dups[i] = cursor.getString(0);
+                    }
+                    return dups;
+                }
+            } catch (final SQLiteException e) {
+                LogUtil.e(TAG, "query failure: " + e, e);
+            } finally {
+                cursor.close();
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Try parse the address using RFC822 format. If it fails to parse, then return the
+     * original address
+     *
+     * @param address The MMS ind sender address to parse
+     * @return The real address. If in RFC822 format, returns the correct email.
+     */
+    private static String parsePotentialRfc822EmailAddress(final String address) {
+        if (address == null || !address.contains("@") || !address.contains("<")) {
+            return address;
+        }
+        final Rfc822Token[] tokens = Rfc822Tokenizer.tokenize(address);
+        if (tokens != null && tokens.length > 0) {
+            for (final Rfc822Token token : tokens) {
+                if (token != null && !TextUtils.isEmpty(token.getAddress())) {
+                    return token.getAddress();
+                }
+            }
+        }
+        return address;
+    }
+
+    public static DatabaseMessages.MmsMessage processReceivedPdu(final Context context,
+            final byte[] pushData, final int subId, final String subPhoneNumber) {
+        // Parse data
+
+        // Insert placeholder row to telephony and local db
+        // Get raw PDU push-data from the message and parse it
+        final PduParser parser = new PduParser(pushData,
+                MmsConfig.get(subId).getSupportMmsContentDisposition());
+        final GenericPdu pdu = parser.parse();
+
+        if (null == pdu) {
+            LogUtil.e(TAG, "Invalid PUSH data");
+            return null;
+        }
+
+        final PduPersister p = PduPersister.getPduPersister(context);
+        // 489220 begin
+        ContentResolver cr = context.getContentResolver();
+        // 489220 end
+        final int type = pdu.getMessageType();
+
+        Uri messageUri = null;
+
+        // 489220 begin
+        try {
+            switch (type) {
+            case PduHeaders.MESSAGE_TYPE_DELIVERY_IND:
+            case PduHeaders.MESSAGE_TYPE_READ_ORIG_IND: {
+
+                long threadId = findThreadId(context, pdu, type);
+                LogUtil.d(TAG, "threadId:[" + threadId + "] type:[" + type
+                        + "]");
+
+                /* Add by SPRD for bug 531941 Start */
+                String transactionId = findTransactionId(context, pdu, type);
+                LogUtil.d(TAG, "find TransactionId from DeliveryInd dup: "
+                        + "transactionId = " + transactionId);
+                /* Add by SPRD for bug 531941 End */
+                if (threadId == -1) {
+                    // The associated SendReq isn't found, therefore skip
+                    // processing this PDU.
+                    LogUtil.d(TAG,
+                            "The associated SendReq isn't found, therefore skip processing this PDU");
+                    break;
+                }
+
+                Uri uri = p.persist(pdu, Mms.Inbox.CONTENT_URI, subId,
+                        subPhoneNumber, null);
+                // Update thread ID for ReadOrigInd & DeliveryInd.
+                ContentValues values = new ContentValues(1);
+                values.put(Mms.THREAD_ID, threadId);
+                SqliteWrapper.update(context, cr, uri, values, null, null);
+                LogUtil.d(TAG, "uri = " + uri);
+
+                EncodedStringValue encodedStringValue = null;
+                String report = null;
+                String address = null;
+                if (type == PduHeaders.MESSAGE_TYPE_DELIVERY_IND) {
+                    DeliveryInd deliveryInd = (DeliveryInd) pdu;
+                    if (null != deliveryInd.getTo()) {
+                        encodedStringValue = (deliveryInd.getTo())[0];
+                        if (null != encodedStringValue) {
+                            // address =
+                            // Contact.get(encodedStringValue.getString(),
+                            // true).getName();
+                            address = encodedStringValue.getString();
+                        }
+                    }
+                    int status = deliveryInd.getStatus();
+                    if (status == PduHeaders.STATUS_FORWARDED
+                            || status == PduHeaders.STATUS_RETRIEVED) {
+                        /* Add by SPRD for bug 531941 Start */
+                        Uri smsMessageUri = findSmsMessageUriByTransactionId(transactionId);
+                        LogUtil.d(
+                                TAG,
+                                "processReceivedPdu: type = MESSAGE_TYPE_DELIVERY_IND, "
+                                        + "findSmsMessageUriByTransactionId: smsMessageUri = "
+                                        + smsMessageUri);
+                        if (smsMessageUri != null) {
+                            ProcessDeliveryReportAction.deliveryReportReceived(
+                                    smsMessageUri, 0);
+                        }
+                        /* Add by SPRD for bug 531941 End */
+                        report = context
+                                .getString(R.string.delivery_toast_body);
+                    } else if (status == PduHeaders.STATUS_EXPIRED) {
+                        report = context
+                                .getString(R.string.delivery_toast_body_expired);
+                    } else if (status == PduHeaders.STATUS_REJECTED) {
+                        report = context
+                                .getString(R.string.delivery_toast_body_fail_rejected);
+                    } else {
+                        report = context
+                                .getString(R.string.delivery_toast_body_fail);
+                    }
+                } else {
+                    ReadOrigInd readOrigInd = (ReadOrigInd) pdu;
+                    if (null != readOrigInd.getTo()) {
+                        encodedStringValue = (readOrigInd.getTo())[0];
+                        if (null != encodedStringValue) {
+                            // address =
+                            // Contact.get(encodedStringValue.getString(),
+                            // true).getName();
+                            address = encodedStringValue.getString();
+                        }
+                    }
+                    int status = readOrigInd.getReadStatus();
+                    if (status == PduHeaders.READ_STATUS_READ) {
+                        report = context
+                                .getString(R.string.read_report_toast_body);
+                    } else {
+                        report = context
+                                .getString(R.string.read_report_toast_body_fail);
+                    }
+                }
+                    /* Add by SPRD for bug 589352 Start */
+                    showReportWithContactName(context, address, report);
+                    /* Add by SPRD for bug 589352 end */
+                break;
+            }
+            case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND: {
+                final NotificationInd nInd = (NotificationInd) pdu;
+
+                if (MmsConfig.get(subId).getTransIdEnabled()) {
+                    final byte[] contentLocationTemp = nInd
+                            .getContentLocation();
+                    if ('=' == contentLocationTemp[contentLocationTemp.length - 1]) {
+                        final byte[] transactionIdTemp = nInd
+                                .getTransactionId();
+                        final byte[] contentLocationWithId = new byte[contentLocationTemp.length
+                                + transactionIdTemp.length];
+                        System.arraycopy(contentLocationTemp, 0,
+                                contentLocationWithId, 0,
+                                contentLocationTemp.length);
+                        System.arraycopy(transactionIdTemp, 0,
+                                contentLocationWithId,
+                                contentLocationTemp.length,
+                                transactionIdTemp.length);
+                        nInd.setContentLocation(contentLocationWithId);
+                    }
+                }
+                final String[] dups = getDupNotifications(context, nInd);
+                if (dups == null) {
+                    // TODO: Do we handle Rfc822 Email Addresses?
+                    // final String contentLocation =
+                    // MmsUtils.bytesToString(nInd.getContentLocation(),
+                    // "UTF-8");
+                    // final byte[] transactionId = nInd.getTransactionId();
+                    // final long messageSize = nInd.getMessageSize();
+                    // final long expiry = nInd.getExpiry();
+                    // final String transactionIdString =
+                    // MmsUtils.bytesToString(transactionId, "UTF-8");
+
+                    // final EncodedStringValue fromEncoded = nInd.getFrom();
+                    // An mms ind received from email address will have from
+                    // address shown as
+                    // "John Doe <johndoe@foobar.com>" but the actual received
+                    // message will only
+                    // have the email address. So let's try to parse the RFC822
+                    // format to get the
+                    // real email. Otherwise we will create two conversations
+                    // for the MMS
+                    // notification and the actual MMS message if auto retrieve
+                    // is disabled.
+                    // final String from = parsePotentialRfc822EmailAddress(
+                    // fromEncoded != null ? fromEncoded.getString() : null);
+
+                    Uri inboxUri = null;
+                    try {
+                        inboxUri = p.persist(pdu, Mms.Inbox.CONTENT_URI, subId,
+                                subPhoneNumber, null);
+                        messageUri = ContentUris.withAppendedId(
+                                Mms.CONTENT_URI, ContentUris.parseId(inboxUri));
+                    } catch (final MmsException e) {
+                        LogUtil.e(TAG,
+                                "Failed to save the data from PUSH: type="
+                                        + type, e);
+                    }
+                } else {
+                    LogUtil.w(TAG,
+                            "Received WAP Push is a dup: "
+                                    + Joiner.on(',').join(dups));
+                    if (LogUtil.isLoggable(TAG, LogUtil.VERBOSE)) {
+                        LogUtil.w(
+                                TAG,
+                                "Dup WAP Push url="
+                                        + new String(nInd.getContentLocation()));
+                    }
+                }
+                break;
+            }
+            default:
+                LogUtil.e(TAG, "Received unrecognized WAP Push, type=" + type);
+            }
+        } catch (MmsException e) {
+            LogUtil.e(TAG, "Failed to save the data from PUSH: type=" + type, e);
+        } catch (RuntimeException e) {
+            LogUtil.e(TAG, "Unexpected RuntimeException.", e);
+        }
+        // 489220 end
+
+        DatabaseMessages.MmsMessage mms = null;
+        if (messageUri != null) {
+            mms = MmsUtils.loadMms(messageUri);
+        }
+        return mms;
+    }
+
+    /* Add by SPRD for bug 589352 Start */
+    private static HandlerThread mGetDisplayNameHandlerThread = null;
+
+    private static HandlerThread getHandlerThread() {
+        if (null == mGetDisplayNameHandlerThread) {
+            mGetDisplayNameHandlerThread = new HandlerThread("display_name");
+        }
+        return mGetDisplayNameHandlerThread;
+    }
+
+    public static void showReportWithContactName(final Context context, final String address, final String report) {
+        HandlerThread handlerThread = getHandlerThread();
+        handlerThread.start();
+        Handler handler = new Handler(handlerThread.getLooper()) {
+            @Override
+            public void handleMessage(Message msg) {
+                String reportString;
+                String displayName = null;
+                super.handleMessage(msg);
+                CursorQueryData cursorQueryData = ContactUtil.lookupDestination(context, address);
+                Cursor cursor = cursorQueryData.performSynchronousQuery();
+                if (cursor == null) {
+                    displayName = null;
+                } else {
+                    try {
+                        for (int i = 0; i < cursor.getCount(); i++) {
+                            cursor.moveToPosition(i);
+
+                            int nameFieldColumnIndex = cursor.getColumnIndex(ContactsContract.PhoneLookup.DISPLAY_NAME);
+                            displayName = cursor.getString(nameFieldColumnIndex);
+                            break;
+                        }
+                    } finally {
+                        if (!cursor.isClosed()) {
+                            cursor.close();
+                        }
+                    }
+                }
+
+                if (displayName != null) {
+                    reportString = String.format(report, displayName);
+                } else {
+                    reportString = String.format(report, address);
+                }
+
+                LogUtil.d(TAG, "Report message is: " + report);
+                Intent notify = new Intent(NOTIFY_SHOW_MMS_SMS_REPORT_ACTION);
+                notify.putExtra("report", reportString);
+                context.sendBroadcast(notify);
+                quitHandlerThread();
+            }
+        };
+
+        Message msg = handler.obtainMessage();
+        msg.sendToTarget();
+    }
+
+    private static void quitHandlerThread() {
+        if (null != mGetDisplayNameHandlerThread) {
+            mGetDisplayNameHandlerThread.quitSafely();
+            mGetDisplayNameHandlerThread = null;
+        }
+    }
+    /* Add by SPRD for bug 589352 end */
+
+    public static Uri insertSendingMmsMessage(final Context context, final List<String> recipients,
+            final MessageData content, final int subId, final String subPhoneNumber,
+            final long timestamp) {
+        final SendReq sendReq = createMmsSendReq(
+                context, subId, recipients.toArray(new String[recipients.size()]), content,
+                //DEFAULT_DELIVERY_REPORT_MODE,
+                //DEFAULT_READ_REPORT_MODE,
+                //489220 begin 
+                isMmsDeliveryReportRequired(subId),
+                isMmsReadReportRequired(subId),
+                //489220 end 
+                DEFAULT_EXPIRY_TIME_IN_SECONDS,
+                DEFAULT_PRIORITY,
+                timestamp);
+        Uri messageUri = null;
+        if (sendReq != null) {
+            final Uri outboxUri = MmsUtils.insertSendReq(context, sendReq, subId, subPhoneNumber);
+            if (outboxUri != null) {
+                messageUri = ContentUris.withAppendedId(Telephony.Mms.CONTENT_URI,
+                        ContentUris.parseId(outboxUri));
+                if (LogUtil.isLoggable(TAG, LogUtil.DEBUG)) {
+                    LogUtil.d(TAG, "Mmsutils: Inserted sending MMS message into telephony, uri: "
+                            + outboxUri);
+                }
+            } else {
+                LogUtil.e(TAG, "insertSendingMmsMessage: failed to persist message into telephony");
+            }
+        }
+        return messageUri;
+    }
+
+    public static MessageData readSendingMmsMessage(final Uri messageUri,
+            final String conversationId, final String participantId, final String selfId) {
+        MessageData message = null;
+        if (messageUri != null) {
+            final DatabaseMessages.MmsMessage mms = MmsUtils.loadMms(messageUri);
+
+            // Make sure that the message has not been deleted from the Telephony DB
+            if (mms != null) {
+                // Transform the message
+                message = MmsUtils.createMmsMessage(mms, conversationId, participantId, selfId,
+                        MessageData.BUGLE_STATUS_OUTGOING_RESENDING);
+            }
+        }
+        return message;
+    }
+
+    /**
+     * Create an MMS message with subject, text and image
+     *
+     * @return Both the M-Send.req and the M-Send.conf for processing in the caller
+     * @throws MmsException
+     */
+    private static SendReq createMmsSendReq(final Context context, final int subId,
+            final String[] recipients, final MessageData message,
+            final boolean requireDeliveryReport, final boolean requireReadReport,
+            final long expiryTime, final int priority, final long timestampMillis) {
+        Assert.notNull(context);
+        if (recipients == null || recipients.length < 1) {
+            throw new IllegalArgumentException("MMS sendReq no recipient");
+        }
+
+        // Make a copy so we don't propagate changes to recipients to outside of this method
+        final String[] recipientsCopy = new String[recipients.length];
+        // Don't send phone number as is since some received phone number is malformed
+        // for sending. We need to strip the separators.
+        for (int i = 0; i < recipients.length; i++) {
+            final String recipient = recipients[i];
+            if (EmailAddress.isValidEmail(recipients[i])) {
+                // Don't do stripping for emails
+                recipientsCopy[i] = recipient;
+            } else {
+                recipientsCopy[i] = stripPhoneNumberSeparators(recipient);
+            }
+        }
+        
+       
+        //feature fdn begin for Mms
+//        SmsManager  smsManager = SmsManager.getDefault();
+//        List<String> listContacts = new ArrayList<String>(recipientsCopy.length);
+//        for(String contactnumber : recipients){
+//            listContacts.add(contactnumber);
+//        }
+//        List<String> templist = new ArrayList<String>();
+//        boolean[] sendFilter = smsManager.checkFdnContacts(listContacts);
+//        for(int i = 0 ; i < sendFilter.length ; i++){
+//             if(sendFilter[i]){
+//                 templist.add(listContacts.get(i));
+//             }
+//        }
+//        if(templist.size() > 0 ){
+//            /* Delete by SPRD for bug 558251 2016/05/11 Start */
+//            //String tempt = "";
+//            //for (int i = 0; i < templist.size(); i++) {
+//            //    tempt = tempt +"["+templist.get(i)+"]";
+//            //}
+//            /* Delete by SPRD for bug 558251 2016/05/11 End */
+//            Message msgflag = GlobleUtil.mGlobleHandler.obtainMessage();
+//            msgflag.what = GlobleUtil.FDN_TOAST_MSG;
+//            //msgflag.obj = "Fdn limit for contacts :"+tempt;
+//            msgflag.obj = context.getString(R.string.fdn_check_failure);
+//            GlobleUtil.mGlobleHandler.sendMessage(msgflag);
+//            //tempt = null;
+//            return null;
+//        /* Add by SPRD for bug 558251 2016/05/11 Start */
+//        } else {
+//            listContacts.clear();
+//            listContacts.add("*99#");
+//            sendFilter = smsManager.checkFdnContacts(listContacts);
+//            if (sendFilter[0]) {
+//                Message msgflag = GlobleUtil.mGlobleHandler.obtainMessage();
+//                msgflag.what = GlobleUtil.FDN_TOAST_MSG;
+//                msgflag.obj = context.getString(R.string.data_call_fdn_check_failure);
+//                GlobleUtil.mGlobleHandler.sendMessage(msgflag);
+//                return null;
+//            }
+//        }
+//        listContacts = null;
+//        sendFilter = null;
+//        templist = null;
+        /* Add by SPRD for bug 558251 2016/05/11 End */
+        //feature fdn end for Mms
+ 
+        SendReq sendReq = null;
+        try {
+            sendReq = createSendReq(context, subId, recipientsCopy,
+                    message, requireDeliveryReport,
+                    requireReadReport, expiryTime, priority, timestampMillis);
+        } catch (final InvalidHeaderValueException e) {
+            LogUtil.e(TAG, "InvalidHeaderValue creating sendReq PDU");
+        } catch (final OutOfMemoryError e) {
+            LogUtil.e(TAG, "Out of memory error creating sendReq PDU");
+        }
+        return sendReq;
+    }
+
+    /**
+     * Stripping out the invalid characters in a phone number before sending
+     * MMS. We only keep alphanumeric and '*', '#', '+'.
+     */
+    private static String stripPhoneNumberSeparators(final String phoneNumber) {
+        if (phoneNumber == null) {
+            return null;
+        }
+        final int len = phoneNumber.length();
+        final StringBuilder ret = new StringBuilder(len);
+        for (int i = 0; i < len; i++) {
+            final char c = phoneNumber.charAt(i);
+            if (Character.isLetterOrDigit(c) || c == '+' || c == '*' || c == '#') {
+                ret.append(c);
+            }
+        }
+        return ret.toString();
+    }
+
+    /**
+     * Create M-Send.req for the MMS message to be sent.
+     *
+     * @return the M-Send.req
+     * @throws InvalidHeaderValueException if there is any error in parsing the input
+     */
+    static SendReq createSendReq(final Context context, final int subId,
+            final String[] recipients, final MessageData message,
+            final boolean requireDeliveryReport,
+            final boolean requireReadReport, final long expiryTime, final int priority,
+            final long timestampMillis)
+            throws InvalidHeaderValueException {
+        final SendReq req = new SendReq();
+        // From, per spec
+        final String lineNumber = PhoneUtils.get(subId).getCanonicalForSelf(true/*allowOverride*/);
+        if (!TextUtils.isEmpty(lineNumber)) {
+            req.setFrom(new EncodedStringValue(lineNumber));
+        }
+        // To
+        final EncodedStringValue[] encodedNumbers = EncodedStringValue.encodeStrings(recipients);
+        if (encodedNumbers != null) {
+            req.setTo(encodedNumbers);
+            //req.setSubID(int subId);
+        }
+        // Subject
+        if (!TextUtils.isEmpty(message.getMmsSubject())) {
+            req.setSubject(new EncodedStringValue(message.getMmsSubject()));
+        }
+        // Date
+        req.setDate(timestampMillis / 1000L);
+        // Body
+        
+        
+        String smil = null;
+        final MmsInfo bodyInfo;
+        for (Iterator<MessagePartData> it = message.getParts().iterator(); it.hasNext();) {
+            MessagePartData part = it.next();
+            if (ContentType.APP_SMIL.equals(part.getContentType())) {
+                Log.e("smil-s", "MmsUtils.createSendReq: delete smil part from MessageData.");
+                smil = part.getText();
+                Log.e("smil-s", "MmsUtils.createSendReq: smil = "+smil);
+                it.remove();
+                break;
+            }
+        }
+        if (!TextUtils.isEmpty(smil)) {
+            bodyInfo = MmsUtils.makePduBodyEx(context, message, subId, smil);
+        } else {
+            bodyInfo = MmsUtils.makePduBody(context, message, subId);
+        }
+        
+        
+        req.setBody(bodyInfo.mPduBody);
+        // Message size
+        req.setMessageSize(bodyInfo.mMessageSize);
+        // Message class
+        req.setMessageClass(PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes());
+        // Expiry
+        long expiry = getMmsValidity(expiryTime, subId);
+        req.setExpiry(expiry);
+        // Priority
+        req.setPriority(priority);
+        // Delivery report
+        req.setDeliveryReport(requireDeliveryReport ? PduHeaders.VALUE_YES : PduHeaders.VALUE_NO);
+        // Read report
+        req.setReadReport(requireReadReport ? PduHeaders.VALUE_YES : PduHeaders.VALUE_NO);
+        return req;
+    }
+
+    public static boolean isDeliveryReportRequired(final int subId) {
+        if (!MmsConfig.get(subId).getSMSDeliveryReportsEnabled()) {
+            return false;
+        }
+        final Context context = Factory.get().getApplicationContext();
+        final Resources res = context.getResources();
+        final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
+        final String deliveryReportKey = res.getString(R.string.delivery_reports_pref_key);
+        final boolean defaultValue = res.getBoolean(R.bool.delivery_reports_pref_default);
+        return prefs.getBoolean(deliveryReportKey, defaultValue);
+    }
+
+    // 489220 begin
+    public static boolean isMmsDeliveryReportRequired(final int subId) {
+        final Context context = Factory.get().getApplicationContext();
+        final Resources res = context.getResources();
+        final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
+        final String mmsDeliveryReportKey = res
+                .getString(R.string.mms_delivery_reports_pref_key);
+        final boolean defaultValue = res
+                .getBoolean(R.bool.mms_delivery_reports_pref_default);
+        return prefs.getBoolean(mmsDeliveryReportKey, defaultValue);
+    }
+
+    public static boolean isMmsReadReportRequired(final int subId) {
+        final Context context = Factory.get().getApplicationContext();
+        final Resources res = context.getResources();
+        final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
+        final String mmsReadReportKey = res
+                .getString(R.string.mms_read_reports_pref_key);
+        final boolean defaultValue = res
+                .getBoolean(R.bool.mms_read_reports_pref_default);
+        return prefs.getBoolean(mmsReadReportKey, defaultValue);
+    }
+
+    public static boolean isEnabelReturnMmsReadReport(final int subId) {
+
+        final Context context = Factory.get().getApplicationContext();
+        final Resources res = context.getResources();
+        final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
+        final String enableReturnMmsReadReportKey = res
+                .getString(R.string.enable_return_mms_read_reports_pref_key);
+        final boolean defaultValue = res
+                .getBoolean(R.bool.enable_return_mms_read_reports_pref_default);
+        return prefs.getBoolean(enableReturnMmsReadReportKey, defaultValue);
+    }
+
+    public static boolean isEnabelReturnMmsDeliveryReport(final int subId) {
+
+        final Context context = Factory.get().getApplicationContext();
+        final Resources res = context.getResources();
+        final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
+        final String enableReturnMmsDeliveryReportKey = res
+                .getString(R.string.enable_return_mms_delivery_reports_pref_key);
+        final boolean defaultValue = res
+                .getBoolean(R.bool.enable_return_mms_delivery_reports_pref_default);
+        return prefs.getBoolean(enableReturnMmsDeliveryReportKey, defaultValue);
+    }
+    // 489220 end
+
+    public static boolean isEnabelMmsSendReport(final int subId) {
+
+        final Context context = Factory.get().getApplicationContext();
+        final Resources res = context.getResources();
+        final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
+        final String enableMmsSendReportKey = res.getString(R.string.mms_send_reports_pref_key);
+        final boolean defaultValue = res.getBoolean(R.bool.mms_send_reports_pref_default);
+        return prefs.getBoolean(enableMmsSendReportKey, defaultValue);
+    }
+
+    public static boolean isEnabelSmsSendReport(final int subId) {
+
+        final Context context = Factory.get().getApplicationContext();
+        final Resources res = context.getResources();
+        final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
+        final String enableSmsSendReportKey = res.getString(R.string.send_reports_pref_key);
+        final boolean defaultValue = res.getBoolean(R.bool.send_reports_pref_default);
+        return prefs.getBoolean(enableSmsSendReportKey, defaultValue);
+    }
+
+    public static int sendSmsMessage(final String recipient, final String messageText,
+            final Uri requestUri, final int subId,
+            final String smsServiceCenter, final boolean requireDeliveryReport) {
+        if(!Utils.isVowifiSmsEnable(subId)){
+            if (!isSmsDataAvailable(subId)) {
+            LogUtil.w(TAG, "MmsUtils: can't send SMS without radio");
+            return MMS_REQUEST_MANUAL_RETRY;
+            }
+         }
+        final Context context = Factory.get().getApplicationContext();
+        int status = MMS_REQUEST_MANUAL_RETRY;
+        try {
+            // Send a single message
+            final SendResult result = SmsSender.sendMessage(
+                    context,
+                    subId,
+                    recipient,
+                    messageText,
+                    smsServiceCenter,
+                    requireDeliveryReport,
+                    requestUri);
+            if (!result.hasPending()) {
+                // not timed out, check failures
+                final int failureLevel = result.getHighestFailureLevel();
+                switch (failureLevel) {
+                    case SendResult.FAILURE_LEVEL_NONE:
+                        status = MMS_REQUEST_SUCCEEDED;
+                        break;
+                    case SendResult.FAILURE_LEVEL_TEMPORARY:
+                        status = MMS_REQUEST_AUTO_RETRY;
+                        LogUtil.e(TAG, "MmsUtils: SMS temporary failure");
+                        break;
+                    case SendResult.FAILURE_LEVEL_PERMANENT:
+                        LogUtil.e(TAG, "MmsUtils: SMS permanent failure");
+                        break;
+                }
+            } else {
+                // Timed out
+                LogUtil.e(TAG, "MmsUtils: sending SMS timed out");
+            }
+        // sprd: 596495 fdn feature begin
+        }catch(IllegalArgumentException e){
+            if (e.getMessage().contains("Invalid FDN destinationAddress")) {
+                Log.i("xuexue", "GlobleUtil.mGropMessagingTotalCount--->   "+GlobleUtil.mGropMessagingTotalCount);
+                // fdn feature toast end
+                boolean showToat = false;
+                if (GlobleUtil.mGropMessagingTotalCount > 1
+                        || GlobleUtil.mGropMessagingTotalCount == 1) {
+                    showToat = true;
+                    GlobleUtil.mGropMessagingTotalCount = 0;
+                }
+
+                //if (showToat) {
+                    Message msgflag = GlobleUtil.mGlobleHandler.obtainMessage();
+                    msgflag.what = GlobleUtil.FDN_TOAST_MSG;
+                    msgflag.obj = Factory.get().getApplicationContext()
+                            .getString(R.string.fdn_check_failure);
+                    GlobleUtil.mGlobleHandler.sendMessage(msgflag);
+                //}
+                status = SendResult.FAILURE_LEVEL_PERMANENT;
+            }
+          //sprd: 596495 fdn feature toast end
+        }catch (SmsException e) {
+            // sprd add for smsc
+            if (SmsSender.SMSC_EMPTY_FAILURE.equals(e.getMessage())) {
+                final boolean hasActiveSubscription =
+                        SubscriptionManager.from(context).getActiveSubscriptionInfoCount() > 0;
+                new Thread() {
+                    @Override
+                    public void run() {
+                        Looper.prepare();
+                        int errInfoId;
+                        if (hasActiveSubscription) {
+                            errInfoId = R.string.smsc_list_empty_toast;
+                        } else {
+                            errInfoId = R.string.err_sent_no_sim;
+                        }
+                        Toast.makeText(context, errInfoId, Toast.LENGTH_LONG).show();
+                        Looper.loop();
+                    }
+                }.start();
+                if (hasActiveSubscription) {
+                    BugleNotifications.notifySmscEmpty(subId);
+                }
+            }
+            // sprd add for smsc
+        } catch (final Exception e) {
+            LogUtil.e(TAG, "MmsUtils: failed to send SMS " + e, e);
+        }
+        return status;
+    }
+
+    /**
+     * Delete SMS and MMS messages in a particular thread
+     *
+     * @return the number of messages deleted
+     */
+
+    private static String getMaxCondition(  final long  smax, final long mmax){
+        if(smax >0 && mmax >0 ){
+       return " maxSms="+smax+" & maxMms="+ mmax+" ";
+        }
+        else if(smax >0 )
+        {
+            return " maxSms="+smax+" ";
+        }
+        else if( mmax > 0 ){
+            return  " maxMms="+ mmax +" ";
+        }
+        else{
+            return  null;
+        }
+    }
+
+    private static String  getThread( final long[]  threadId, final int nLimit, Integer nStart){
+             if( threadId == null || threadId.length <=0){
+                 return null;
+             }
+             int nStartPoint = nStart;
+             int nStringLen = 0;
+             String szRet = new String("");
+             for(; nStartPoint <( nStart + nLimit); ++nStartPoint){
+                 if(nStartPoint == nStart ){
+                 szRet = szRet + " thread_id  in (" + threadId[nStartPoint] +",";
+                 }else
+                 {
+                     szRet = szRet + " " + threadId[nStartPoint] +",";
+                 }
+             }
+             nStart =  nStart + nLimit;
+             nStringLen = szRet.length() -1;
+             return szRet.substring(0, nStringLen);
+    }
+    private static final int MAX_LIMIT = 100;
+    private static  String[] getThreadCondition(final long[]  threadId, final int nLimit ){
+           if(threadId == null || threadId.length <=0 || threadId[0] == -1)  {
+               return null;
+           }
+           int nRom = 0;
+           int nIndex =0;
+           int nLen = threadId.length;
+           int nRetLen = nLen / nLimit +( (nLen %  nLimit) ==0 ? 0 :1);
+           Integer nStart = new Integer(0);
+           String szRet[] = new String[nRetLen];
+           for(   nIndex =0; nIndex <nRetLen -1; ){
+               szRet[nIndex++]= getThread(threadId, MAX_LIMIT, nStart);
+               nStart = nStart + MAX_LIMIT;
+           }
+           nRom =  nLen % MAX_LIMIT;
+           if( nRom != 0){
+                 szRet[nIndex]= getThread(threadId, nRom, nStart);
+           }
+           if(nRetLen >= 1 && nRom == 0){
+               szRet[nIndex]= getThread(threadId, MAX_LIMIT, nStart);
+           }
+           return szRet;
+    }
+
+    public static int deleteMultiThread(final long[]  threadId, final long cutOffTimestampInMillis,  final long  smax, final long mmax) {
+        final ContentResolver resolver = Factory.get().getApplicationContext().getContentResolver();
+        LogUtil.i(TAG,"jessica enter deleteMultiThread ");
+        String szSingleThreadCondition = "";
+        String[] szThreadCondition = getThreadCondition(threadId, MAX_LIMIT);
+        String    szMaxCondition = getMaxCondition(smax, mmax);
+        String[] szMax = (szMaxCondition ==null)? null  :  new String[]{szMaxCondition};
+        LogUtil.i(TAG,"jessica enter deleteMultiThread szMaxCondition = " + szMaxCondition);
+        int szRet = -1;
+        try{
+         if(szThreadCondition == null ){
+            szRet = resolver.delete( Telephony.Threads.CONTENT_URI,  "_id <= ?" ,   szMax);
+         }else
+         {
+         for( String szCondition  : szThreadCondition){
+             if( !TextUtils.isEmpty(szCondition)){
+                 if(smax == 0 && mmax == 0){
+                      szSingleThreadCondition = szCondition + ")" ;
+                 }else
+                 {
+                     szSingleThreadCondition = szCondition +")  and _id <= ?" ;
+                 }
+                LogUtil.i(TAG,"jessica enter deleteMultiThread szSingleThreadCondition = " + szSingleThreadCondition);
+                szRet = resolver.delete(Telephony.Threads.CONTENT_URI,  szSingleThreadCondition,  szMax);
+             }
+           }
+         }
+        }
+        catch(Exception e){
+            e.printStackTrace();
+        }
+        LogUtil.i(TAG,"jessica enter deleteMultiThread szRet = " + szRet);
+    return szRet;
+    }
+
+    /**
+     * Delete SMS and MMS messages in a particular thread
+     *
+     * @return the number of messages deleted
+     */
+    public static int deleteThread(final long threadId, final long cutOffTimestampInMillis) {
+        final ContentResolver resolver = Factory.get().getApplicationContext().getContentResolver();
+        final Uri threadUri = ContentUris.withAppendedId(Telephony.Threads.CONTENT_URI, threadId);
+        if (cutOffTimestampInMillis < Long.MAX_VALUE) {
+            return resolver.delete(threadUri, Sms.DATE + "<=?",
+                    new String[] { Long.toString(cutOffTimestampInMillis) });
+        } else {
+            return resolver.delete(threadUri, null /* smsSelection */, null /* selectionArgs */);
+        }
+    }
+
+    /**
+     * Delete single SMS and MMS message
+     *
+     * @return number of rows deleted (should be 1 or 0)
+     */
+    public static int deleteMessage(final Uri messageUri) {
+        final ContentResolver resolver = Factory.get().getApplicationContext().getContentResolver();
+        return resolver.delete(messageUri, null /* selection */, null /* selectionArgs */);
+    }
+
+    public static byte[] createDebugNotificationInd(final String fileName) {
+        byte[] pduData = null;
+        try {
+            final Context context = Factory.get().getApplicationContext();
+            // Load the message file
+            final byte[] data = DebugUtils.receiveFromDumpFile(fileName);
+            final RetrieveConf retrieveConf = receiveFromDumpFile(data);
+            // Create the notification
+            final NotificationInd notification = new NotificationInd();
+            final long expiry = System.currentTimeMillis() / 1000 + 600;
+            notification.setTransactionId(fileName.getBytes());
+            notification.setMmsVersion(retrieveConf.getMmsVersion());
+            notification.setFrom(retrieveConf.getFrom());
+            notification.setSubject(retrieveConf.getSubject());
+            notification.setExpiry(expiry);
+            notification.setMessageSize(data.length);
+            notification.setMessageClass(retrieveConf.getMessageClass());
+
+            final Uri.Builder builder = MediaScratchFileProvider.getUriBuilder();
+            builder.appendPath(fileName);
+            final Uri contentLocation = builder.build();
+            notification.setContentLocation(contentLocation.toString().getBytes());
+
+            // Serialize
+            pduData = new PduComposer(context, notification).make();
+            if (pduData == null || pduData.length < 1) {
+                throw new IllegalArgumentException("Empty or zero length PDU data");
+            }
+        } catch (final MmsFailureException e) {
+            // Nothing to do
+        } catch (final InvalidHeaderValueException e) {
+            // Nothing to do
+        }
+        return pduData;
+    }
+
+    public static int mapRawStatusToErrorResourceId(final int bugleStatus, final int rawStatus) {
+        int stringResId = R.string.message_status_send_failed;
+        switch (rawStatus) {
+            case PduHeaders.RESPONSE_STATUS_ERROR_SERVICE_DENIED:
+                stringResId = R.string.user_not_exist;
+                break;
+            case PduHeaders.RESPONSE_STATUS_ERROR_PERMANENT_SERVICE_DENIED:
+            //case PduHeaders.RESPONSE_STATUS_ERROR_PERMANENT_REPLY_CHARGING_LIMITATIONS_NOT_MET:
+            //case PduHeaders.RESPONSE_STATUS_ERROR_PERMANENT_REPLY_CHARGING_REQUEST_NOT_ACCEPTED:
+            //case PduHeaders.RESPONSE_STATUS_ERROR_PERMANENT_REPLY_CHARGING_FORWARDING_DENIED:
+            //case PduHeaders.RESPONSE_STATUS_ERROR_PERMANENT_REPLY_CHARGING_NOT_SUPPORTED:
+            //case PduHeaders.RESPONSE_STATUS_ERROR_PERMANENT_ADDRESS_HIDING_NOT_SUPPORTED:
+            //case PduHeaders.RESPONSE_STATUS_ERROR_PERMANENT_LACK_OF_PREPAID:
+                stringResId = R.string.mms_failure_outgoing_service;
+                break;
+            case PduHeaders.RESPONSE_STATUS_ERROR_SENDING_ADDRESS_UNRESOLVED:
+            case PduHeaders.RESPONSE_STATUS_ERROR_TRANSIENT_SENDNG_ADDRESS_UNRESOLVED:
+            case PduHeaders.RESPONSE_STATUS_ERROR_PERMANENT_SENDING_ADDRESS_UNRESOLVED:
+                stringResId = R.string.mms_failure_outgoing_address;
+                break;
+            case PduHeaders.RESPONSE_STATUS_ERROR_MESSAGE_FORMAT_CORRUPT:
+            case PduHeaders.RESPONSE_STATUS_ERROR_PERMANENT_MESSAGE_FORMAT_CORRUPT:
+                stringResId = R.string.mms_failure_outgoing_corrupt;
+                break;
+            case PduHeaders.RESPONSE_STATUS_ERROR_CONTENT_NOT_ACCEPTED:
+            case PduHeaders.RESPONSE_STATUS_ERROR_PERMANENT_CONTENT_NOT_ACCEPTED:
+                stringResId = R.string.mms_failure_outgoing_content;
+                break;
+            case PduHeaders.RESPONSE_STATUS_ERROR_UNSUPPORTED_MESSAGE:
+            //case PduHeaders.RESPONSE_STATUS_ERROR_MESSAGE_NOT_FOUND:
+            //case PduHeaders.RESPONSE_STATUS_ERROR_TRANSIENT_MESSAGE_NOT_FOUND:
+                stringResId = R.string.mms_failure_outgoing_unsupported;
+                break;
+            case MessageData.RAW_TELEPHONY_STATUS_MESSAGE_TOO_BIG:
+                stringResId = R.string.mms_failure_outgoing_too_large;
+                break;
+        }
+        return stringResId;
+    }
+
+    /**
+     * The absence of a connection type.
+     */
+    public static final int TYPE_NONE = -1;
+
+    public static int getConnectivityEventNetworkType(final Context context, final Intent intent) {
+        final ConnectivityManager connMgr = (ConnectivityManager)
+                context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        if (OsUtil.isAtLeastJB_MR1()) {
+            return intent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, TYPE_NONE);
+        } else {
+            final NetworkInfo info = (NetworkInfo) intent.getParcelableExtra(
+                    ConnectivityManager.EXTRA_NETWORK_INFO);
+            if (info != null) {
+                return info.getType();
+            }
+        }
+        return TYPE_NONE;
+    }
+
+    /**
+     * Dump the raw MMS data into a file
+     *
+     * @param rawPdu The raw pdu data
+     * @param pdu The parsed pdu, used to construct a dump file name
+     */
+    public static void dumpPdu(final byte[] rawPdu, final GenericPdu pdu) {
+        if (rawPdu == null || rawPdu.length < 1) {
+            return;
+        }
+        final String dumpFileName = MmsUtils.MMS_DUMP_PREFIX + getDumpFileId(pdu);
+        final File dumpFile = DebugUtils.getDebugFile(dumpFileName, true);
+        if (dumpFile != null) {
+            try {
+                final FileOutputStream fos = new FileOutputStream(dumpFile);
+                final BufferedOutputStream bos = new BufferedOutputStream(fos);
+                try {
+                    bos.write(rawPdu);
+                    bos.flush();
+                } finally {
+                    bos.close();
+                }
+                DebugUtils.ensureReadable(dumpFile);
+            } catch (final IOException e) {
+                LogUtil.e(TAG, "dumpPdu: " + e, e);
+            }
+        }
+    }
+
+    /**
+     * Get the dump file id based on the parsed PDU
+     * 1. Use message id if not empty
+     * 2. Use transaction id if message id is empty
+     * 3. If all above is empty, use random UUID
+     *
+     * @param pdu the parsed PDU
+     * @return the id of the dump file
+     */
+    private static String getDumpFileId(final GenericPdu pdu) {
+        String fileId = null;
+        if (pdu != null && pdu instanceof RetrieveConf) {
+            final RetrieveConf retrieveConf = (RetrieveConf) pdu;
+            if (retrieveConf.getMessageId() != null) {
+                fileId = new String(retrieveConf.getMessageId());
+            } else if (retrieveConf.getTransactionId() != null) {
+                fileId = new String(retrieveConf.getTransactionId());
+            }
+        }
+        if (TextUtils.isEmpty(fileId)) {
+            fileId = UUID.randomUUID().toString();
+        }
+        return fileId;
+    }
+
+    private static long getMmsValidity(long expiryTime, int subId) {
+        long expiry = expiryTime;
+        String expiryStr = null;
+        final Context context = Factory.get().getApplicationContext();
+        expiryStr = Settings.Global.getString(context.getContentResolver(), "persist.radio.mmstime" + subId);
+        LogUtil.i(TAG, "getMmsValidity()--->>      validity = " + expiryStr + ", subId = "
+                + subId);
+        try {
+            expiry = Long.parseLong(expiryStr);
+        } catch (NumberFormatException exception) {
+            LogUtil.e(TAG, "getMmsValidity  Exception : " + exception);
+        }
+        return expiry;
+    }
+
+    //489223 begin
+    public static void copySmsMessageToSim(List<String> smsUriList, int subId) {
+        final Context context = Factory.get().getApplicationContext();
+        ContentResolver resolver = context.getContentResolver();
+        final ContentValues values = new ContentValues(1);
+        values.put("sub_id", String.valueOf(subId));
+        for (String smsUri : smsUriList) {
+            SqliteWrapper.insert(context, resolver, Uri.parse(smsUri), values);
+        }
+    }
+
+    public static int deleteSimSmsMessage(final Uri messageUri) {
+        final ContentResolver resolver = Factory.get().getApplicationContext().getContentResolver();
+        return resolver.delete(messageUri, null /* selection */, null /* selectionArgs */);
+    }
+    //489223 end
+
+    // sprd #542214 start
+    public static int tanslatePhoneIdToSubId(Context context, int phoneId) {
+        if (!(phoneId >= 0 && phoneId < TelephonyManager.getDefault()
+                .getSimCount())) {
+            Log.d(TAG, "this phoneId:" + phoneId + " is invalid.");
+            return -1;
+        }
+        int[] subId = null;
+        try {
+            ISub iSub = ISub.Stub
+                    .asInterface(ServiceManager.getService("isub"));
+            if (iSub != null) {
+                subId = iSub.getSubId(phoneId);
+            }
+        } catch (RemoteException ex) {
+//            // ignore it
+        }
+
+        return subId[0];	
+    }
+
+    public static int tanslateSubIdToPhoneId(Context context, int subId) {
+        int phoneId = SystemAdapter.getInstance().getPhoneId(subId);
+        return phoneId;
+    }
+    // sprd #542214 end
+    // add for bug 551694 begin
+    public static boolean isSubjectNeedUtf8() {
+        Locale l = Locale.getDefault();
+        String language = l.getLanguage();
+        String country = l.getCountry().toLowerCase();
+        boolean bool = "zh".equalsIgnoreCase(language)
+                || "en".equalsIgnoreCase(language);
+        System.out.println("isSubjectNeedUtf8 = [" + bool + "] language = ["
+                + language + "], country = [" + country + "]");
+        return bool;
+    }
+
+    public static String toUtf8String(String str) {
+        if (str == null) {
+            System.out.println("enter toutf8String, str is null");
+            return "";
+        }
+        String strTemp = str;
+        try {
+            if (str.equals(new String(strTemp.getBytes("iso-8859-1"),
+                    "iso-8859-1"))) {
+                System.out.println("str is iso-8859-1,will decode to UTF-8");
+                return new String(str.getBytes("iso-8859-1"), "UTF-8");
+            } else if (str.equals(new String(str.getBytes("UTF-8"), "UTF-8"))) {
+                System.out.println("the str is utf8");
+                return str;
+            }
+            System.out.println("the str is other encode");
+            return str;
+        } catch (final Exception e) {
+            // Impossible to reach here!
+            Log.e(TAG, "UTF_8 must be supported!", e);
+            return "";
+        }
+    }
+    // add for bug 551694 end
+    //sprd 581016  start
+    public static Bundle pduBobyToBundle(PduBody body){
+        Bundle bundle = new Bundle();
+        if (body == null){
+            return bundle;
+        }
+        int partNum = body.getPartsNum();
+        bundle.putInt("partNum", partNum);
+        for(int j=0; j<partNum; j++){
+            Log.d("smil_show","\r\n<<<=========" +
+                    "======"+j + "  Start ============================>>>");
+            PduPart part = body.getPart(j);
+            bundle.putInt("Charset"+j,part.getCharset());
+            bundle.putByteArray("ContentLocation"+j, part.getContentLocation());
+            bundle.putByteArray("ContentType"+j, part.getContentType());
+            bundle.putByteArray("ContentDisposition"+j, part.getContentDisposition());
+            bundle.putByteArray("ContentTransferEncoding"+j, part.getContentTransferEncoding());
+            bundle.putByteArray("Name"+j, part.getName());
+            bundle.putByteArray("Filename"+j, part.getFilename());
+            bundle.putByteArray("Data"+j, part.getData());
+            bundle.putByteArray("ContentId"+j, part.getContentId());
+            Uri uri = part.getDataUri();
+            String sztype = new String(part.getContentType());
+            if (uri != null){
+                bundle.putString("DataUri"+j, uri.toString());
+            }else if(sztype != null && sztype.startsWith("image")){
+                Log.d("smil_show",  "["+j +"]th  Uri is empty because  Resize");
+                bundle.putString("DataUri"+j, "context://resize/image");
+            }
+            else if(sztype != null && sztype.startsWith("text/plain")){
+                Log.d("smil_show",  "["+j +"]th  Uri is empty because  Text View ");
+                bundle.putString("DataUri"+j, "context://text/plain/empty");
+            }else if(sztype != null && sztype.startsWith("application/smil")){
+                Log.d("smil_show", "smil ["+new String( part.getData())+"]");
+            }
+            else{
+                Log.d("smil_show",  "["+j +"]th  Uri is empty");  
+                bundle.putString("DataUri"+j, "");
+            }
+            Log.d("smil_show", "["+j +"]th Mime Type is ["+sztype+"]");
+            Log.d("smil_show", "["+j +"]th uri is ["+ part.getDataUri()+"]");
+            Log.d("smil_show","\r\n<<<=============="+j + " End ============================>>>");
+        }
+        return bundle;
+    }
+    //sprd 581016 end
+    // add for bug 616653  start
+    public static long getCursorLongValue(Cursor cursor, String columnName) {
+        final int index = cursor.getColumnIndex(columnName);
+        if (index == -1) return -1;
+        final String value = cursor.getString(index);
+        if (value == null) return -1;
+        try {
+            return Long.parseLong(value);
+        } catch (NumberFormatException e) {
+            return -1;
+        }
+    }
+    // add for bug 616653  end
+    // add for bug 620391  start
+    public static long getTotalLength(Uri uri,final Context context){
+        Cursor cursor = null;
+        long totalLength=0;
+        String SIZE = "_size";
+        try {
+            cursor = context.getContentResolver().query(uri, null,
+                    null, null, null);
+            if (cursor != null&& cursor.moveToFirst()) {
+                totalLength=getCursorLongValue(cursor, SIZE);
+            }
+        } catch (final Exception exception){
+            LogUtil.e(TAG,"uri com.android.externalstorage.documents exception="+exception);
+        }finally {
+            if (cursor != null){
+                cursor.close();
+            }
+            return totalLength;
+        }
+
+    }
+    // add for bug 620391  end
+    //sprd 623241 start
+    public static void setImageWidthHeight(MessagePartData data,Uri uri){
+        final Context context = Factory.get().getApplicationContext();
+        final ContentResolver cr = context.getContentResolver();
+        BitmapFactory.Options options = new BitmapFactory.Options();
+        InputStream inputStream = null;
+        // Find incoming image size
+        try {
+            options.inJustDecodeBounds = true;
+            inputStream = cr.openInputStream(uri);
+            BitmapFactory.decodeStream(inputStream, null, options);
+            data.setWith(options.outWidth);
+            data.setHeight(options.outHeight);
+            options.inJustDecodeBounds = false;
+        } catch (final FileNotFoundException e) {
+            LogUtil.e(TAG, "Could not open file corresponding to uri " + uri, e);
+        } catch (final NullPointerException e) {
+            LogUtil.e(TAG, "NPE trying to open the uri " + uri, e);
+        } finally {
+            if (inputStream != null) {
+                try {
+                    inputStream.close();
+                } catch (final IOException e) {
+                    // Nothing to do
+                }
+            }
+        }
+    }
+    //sprd 623241 end
+    //bug 633234 : six queues begin
+	public static ArrayList<Integer> getSubIds() {
+        final SubscriptionManager subscriptionManager = SubscriptionManager.from(Factory.get().getApplicationContext());
+        if(subscriptionManager == null){
+            Log.d(TAG, "subscriptionManager == null");
+            return null;
+        }
+        List<SubscriptionInfo> subInfoList = subscriptionManager.getActiveSubscriptionInfoList();
+        if(subInfoList == null){
+            Log.d(TAG, "subInfoList == null");
+            return null;
+        }
+        Iterator<SubscriptionInfo> iterator = subInfoList.iterator();
+        if (iterator == null) {
+            Log.d(TAG, "iterator == null");
+            return null;
+        }
+
+        ArrayList<Integer> arrayList = new ArrayList<Integer>(
+                subInfoList.size());
+        while (iterator.hasNext()) {
+            SubscriptionInfo subInfo = iterator.next();
+            int phoneId = subInfo.getSimSlotIndex();
+            arrayList.add(subInfo.getSubscriptionId());
+        }
+        return arrayList;
+    }
+	public static int getSlotId(int subId) {
+        final SubscriptionManager subscriptionManager = SubscriptionManager.from(Factory.get().getApplicationContext());
+        if(subscriptionManager == null){
+            return -1;
+        }
+        return subscriptionManager.getSlotId(subId);
+    }
+    //bug 633234 : six queues end
+}
Index: vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/receiver/MmsWapPushDeliverReceiver.java
===================================================================
--- vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/receiver/MmsWapPushDeliverReceiver.java	(revision 0)
+++ vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/receiver/MmsWapPushDeliverReceiver.java	(revision 173004)
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.messaging.receiver;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.provider.Telephony;
+
+import com.android.messaging.util.ContentType;
+import com.android.messaging.util.PhoneUtils;
+
+/**
+ * Class that handles MMS WAP push intent from telephony on KLP+ Devices.
+ */
+public class MmsWapPushDeliverReceiver extends BroadcastReceiver {
+
+    @Override
+    public void onReceive(final Context context, final Intent intent) {
+        if (Telephony.Sms.Intents.WAP_PUSH_DELIVER_ACTION.equals(intent.getAction())
+                && ContentType.MMS_MESSAGE.equals(intent.getType())) {
+            // Always convert negative subIds into -1
+            int subId = PhoneUtils.getDefault().getEffectiveIncomingSubIdFromSystem(
+                    intent, MmsWapPushReceiver.EXTRA_SUBSCRIPTION);
+            byte[] data = intent.getByteArrayExtra(MmsWapPushReceiver.EXTRA_DATA);
+            MmsWapPushReceiver.mmsReceived(subId, data);
+        }
+    }
+}
Index: vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/receiver/MmsWapPushReceiver.java
===================================================================
--- vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/receiver/MmsWapPushReceiver.java	(revision 0)
+++ vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/receiver/MmsWapPushReceiver.java	(revision 173004)
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.messaging.receiver;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.provider.Telephony;
+
+import com.android.messaging.datamodel.action.ReceiveMmsMessageAction;
+import com.android.messaging.util.ContentType;
+import com.android.messaging.util.PhoneUtils;
+
+/**
+ * Class that handles MMS WAP push intent from telephony on pre-KLP Devices.
+ */
+public class MmsWapPushReceiver extends BroadcastReceiver {
+    static final String EXTRA_SUBSCRIPTION = "subscription";
+    static final String EXTRA_DATA = "data";
+
+    @Override
+    public void onReceive(final Context context, final Intent intent) {
+        if (Telephony.Sms.Intents.WAP_PUSH_RECEIVED_ACTION.equals(intent.getAction())
+                && ContentType.MMS_MESSAGE.equals(intent.getType())) {
+            if (PhoneUtils.getDefault().isSmsEnabled()) {
+                // Always convert negative subIds into -1
+                final int subId = PhoneUtils.getDefault().getEffectiveIncomingSubIdFromSystem(
+                        intent, MmsWapPushReceiver.EXTRA_SUBSCRIPTION);
+                final byte[] data = intent.getByteArrayExtra(MmsWapPushReceiver.EXTRA_DATA);
+                mmsReceived(subId, data);
+            }
+        }
+    }
+
+    static void mmsReceived(final int subId, final byte[] data) {
+        if (!PhoneUtils.getDefault().isSmsEnabled()) {
+            return;
+        }
+
+        final ReceiveMmsMessageAction action = new ReceiveMmsMessageAction(subId, data);
+        action.start();
+    }
+}
+
Index: vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/datamodel/action/SendMessageAction.java
===================================================================
--- vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/datamodel/action/SendMessageAction.java	(revision 0)
+++ vendor/custom/cts/packages/apps/Messaging/src/com/android/messaging/datamodel/action/SendMessageAction.java	(revision 173004)
@@ -0,0 +1,488 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.messaging.datamodel.action;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.provider.Telephony.Mms;
+import android.provider.Telephony.Sms;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.util.Log;
+
+import com.android.messaging.Factory;
+import com.android.messaging.datamodel.BugleDatabaseOperations;
+import com.android.messaging.datamodel.DataModel;
+import com.android.messaging.datamodel.DatabaseHelper.MessageColumns;
+import com.android.messaging.datamodel.DatabaseWrapper;
+import com.android.messaging.datamodel.MessagingContentProvider;
+import com.android.messaging.datamodel.SyncManager;
+import com.android.messaging.datamodel.data.MessageData;
+import com.android.messaging.datamodel.data.ParticipantData;
+import com.android.messaging.sms.MmsUtils;
+import com.android.messaging.util.Assert;
+import com.android.messaging.util.LogUtil;
+import com.sprd.messaging.ui.smsc.SmscManager;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * Action used to send an outgoing message. It writes MMS messages to the telephony db
+ * ({@link InsertNewMessageAction}) writes SMS messages to the telephony db). It also
+ * initiates the actual sending. It will all be used for re-sending a failed message.
+ * NOTE: This action must queue a ProcessPendingMessagesAction when it is done (success or failure).
+ * <p>
+ * This class is public (not package-private) because the SMS/MMS (e.g. MmsUtils) classes need to
+ * access the EXTRA_* fields for setting up the 'sent' pending intent.
+ */
+public class SendMessageAction extends Action implements Parcelable {
+    private static final String TAG = LogUtil.BUGLE_DATAMODEL_TAG;
+
+    /**
+     * Queue sending of existing message (can only be called during execute of action)
+     */
+    //bug 633234 : six queues begin
+    private int mSubId=-1;
+    public int getSubId(){
+        return mSubId;
+    }
+    private int mProtocol=-1;
+    public int getProtocol(){
+        return mProtocol;
+    }
+    //bug 633234 : six queues end
+    static boolean queueForSendInBackground(final String messageId,
+            final Action processingAction) {
+        final SendMessageAction action = new SendMessageAction();
+        return action.queueAction(messageId, processingAction);
+    }
+
+    public static final boolean DEFAULT_DELIVERY_REPORT_MODE  = false;
+    public static final int MAX_SMS_RETRY = 3;
+
+    // Core parameters needed for all types of message
+    private static final String KEY_MESSAGE_ID = "message_id";
+    private static final String KEY_MESSAGE = "message";
+    private static final String KEY_MESSAGE_URI = "message_uri";
+    private static final String KEY_SUB_PHONE_NUMBER = "sub_phone_number";
+
+    // For sms messages a few extra values are included in the bundle
+    private static final String KEY_RECIPIENT = "recipient";
+    private static final String KEY_RECIPIENTS = "recipients";
+    private static final String KEY_SMS_SERVICE_CENTER = "sms_service_center";
+
+    // Values we attach to the pending intent that's fired when the message is sent.
+    // Only applicable when sending via the platform APIs on L+.
+    public static final String KEY_SUB_ID = "sub_id";
+    public static final String EXTRA_MESSAGE_ID = "message_id";
+    public static final String EXTRA_UPDATED_MESSAGE_URI = "updated_message_uri";
+    public static final String EXTRA_CONTENT_URI = "content_uri";
+    public static final String EXTRA_RESPONSE_IMPORTANT = "response_important";
+
+    /**
+     * Constructor used for retrying sending in the background (only message id available)
+     */
+    private SendMessageAction() {
+        super();
+    }
+
+    /**
+     * Read message from database and queue actual sending
+     */
+    private boolean queueAction(final String messageId, final Action processingAction) {
+        actionParameters.putString(KEY_MESSAGE_ID, messageId);
+
+        final long timestamp = System.currentTimeMillis();
+        final DatabaseWrapper db = DataModel.get().getDatabase();
+
+        final MessageData message = BugleDatabaseOperations.readMessage(db, messageId);
+        // Check message can be resent
+        if (message != null && message.canSendMessage()) {
+            final boolean isSms = (message.getProtocol() == MessageData.PROTOCOL_SMS);
+            mProtocol=message.getProtocol();
+            final ParticipantData self = BugleDatabaseOperations.getExistingParticipant(
+                    db, message.getSelfId());
+            final Uri messageUri = message.getSmsMessageUri();
+            final String conversationId = message.getConversationId();
+
+            // Update message status
+            if (message.getYetToSend()) {
+                // Initial sending of message
+                message.markMessageSending(timestamp);
+            } else {
+                // Automatic resend of message
+                message.markMessageResending(timestamp);
+            }
+            if (!updateMessageAndStatus(isSms, message, null /* messageUri */, false /*notify*/)) {
+                // If message is missing in the telephony database we don't need to send it
+                return false;
+            }
+
+            final ArrayList<String> recipients =
+                    BugleDatabaseOperations.getRecipientsForConversation(db, conversationId);
+
+            // Update action state with parameters needed for background sending
+            actionParameters.putParcelable(KEY_MESSAGE_URI, messageUri);
+            actionParameters.putParcelable(KEY_MESSAGE, message);
+            actionParameters.putStringArrayList(KEY_RECIPIENTS, recipients);
+            actionParameters.putInt(KEY_SUB_ID, self.getSubId());
+            mSubId=self.getSubId();
+            actionParameters.putString(KEY_SUB_PHONE_NUMBER, self.getNormalizedDestination());
+
+            if (isSms) {
+                final String smsc = BugleDatabaseOperations.getSmsServiceCenterForConversation(
+                        db, conversationId);
+                actionParameters.putString(KEY_SMS_SERVICE_CENTER, smsc);
+
+                if (recipients.size() == 1) {
+                    final String recipient = recipients.get(0);
+
+                    actionParameters.putString(KEY_RECIPIENT, recipient);
+                    // Queue actual sending for SMS
+                    processingAction.requestBackgroundWork(this);
+
+                    if (LogUtil.isLoggable(TAG, LogUtil.DEBUG)) {
+                        LogUtil.d(TAG, "SendMessageAction: Queued SMS message " + messageId
+                                + " for sending");
+                    }
+                    return true;
+                } else {
+                    LogUtil.wtf(TAG, "Trying to resend a broadcast SMS - not allowed");
+                }
+            } else {
+                // Queue actual sending for MMS
+                processingAction.requestBackgroundWork(this);
+
+                if (LogUtil.isLoggable(TAG, LogUtil.DEBUG)) {
+                    LogUtil.d(TAG, "SendMessageAction: Queued MMS message " + messageId
+                            + " for sending");
+                }
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+
+    /**
+     * Never called
+     */
+    @Override
+    protected Object executeAction() {
+        Assert.fail("SendMessageAction must be queued rather than started");
+        return null;
+    }
+
+    /**
+     * Send message on background worker thread
+     */
+    @Override
+    protected Bundle doBackgroundWork() {
+        final MessageData message = actionParameters.getParcelable(KEY_MESSAGE);
+        final String messageId = actionParameters.getString(KEY_MESSAGE_ID);
+        Uri messageUri = actionParameters.getParcelable(KEY_MESSAGE_URI);
+        Uri updatedMessageUri = null;
+        final boolean isSms = message.getProtocol() == MessageData.PROTOCOL_SMS;
+        int subId = actionParameters.getInt(KEY_SUB_ID, ParticipantData.DEFAULT_SELF_SUB_ID);
+        final String subPhoneNumber = actionParameters.getString(KEY_SUB_PHONE_NUMBER);
+
+        LogUtil.i(TAG, "SendMessageAction: Sending " + (isSms ? "SMS" : "MMS") + " message "
+                + messageId + " in conversation " + message.getConversationId());
+
+        try {
+            if (subId == -1) {
+                List<SubscriptionInfo> subInfos = SubscriptionManager.from(Factory.get().getApplicationContext()).getActiveSubscriptionInfoList();
+                if (subInfos != null && subInfos.size() == 1){
+                    subId = subInfos.get(0).getSubscriptionId();
+                }
+            }
+        }catch(Exception ex){
+
+        }
+        Log.d(TAG, " subId is "+subId);
+        int status;
+        int rawStatus = MessageData.RAW_TELEPHONY_STATUS_UNDEFINED;
+        int resultCode = MessageData.UNKNOWN_RESULT_CODE;
+        if (isSms) {
+            Assert.notNull(messageUri);
+            final String recipient = actionParameters.getString(KEY_RECIPIENT);
+            final String messageText = message.getMessageText();
+            //final String smsServiceCenter = actionParameters.getString(KEY_SMS_SERVICE_CENTER);
+            final String smsServiceCenter = getSmsServiceCenter(subId);//sprd add for smsc
+            final boolean deliveryReportRequired = MmsUtils.isDeliveryReportRequired(subId);
+
+            status = MmsUtils.sendSmsMessage(recipient, messageText, messageUri, subId,
+                    smsServiceCenter, deliveryReportRequired);
+        } else {
+            final Context context = Factory.get().getApplicationContext();
+            final ArrayList<String> recipients =
+                    actionParameters.getStringArrayList(KEY_RECIPIENTS);
+            if (messageUri == null) {
+                final long timestamp = message.getReceivedTimeStamp();
+
+                // Inform sync that message has been added at local received timestamp
+                final SyncManager syncManager = DataModel.get().getSyncManager();
+                syncManager.onNewMessageInserted(timestamp);
+
+                // For MMS messages first need to write to telephony (resizing images if needed)
+                updatedMessageUri = MmsUtils.insertSendingMmsMessage(context, recipients,
+                        message, subId, subPhoneNumber, timestamp);
+                if (updatedMessageUri != null) {
+                    messageUri = updatedMessageUri;
+                    // To prevent Sync seeing inconsistent state must write to DB on this thread
+                    updateMessageUri(messageId, updatedMessageUri);
+
+                    if (LogUtil.isLoggable(TAG, LogUtil.VERBOSE)) {
+                        LogUtil.v(TAG, "SendMessageAction: Updated message " + messageId
+                                + " with new uri " + messageUri);
+                    }
+                 }
+            }
+            if (messageUri != null) {
+                // Actually send the MMS
+                final Bundle extras = new Bundle();
+                extras.putString(EXTRA_MESSAGE_ID, messageId);
+                extras.putParcelable(EXTRA_UPDATED_MESSAGE_URI, updatedMessageUri);
+                final MmsUtils.StatusPlusUri result = MmsUtils.sendMmsMessage(context, subId,
+                        messageUri, extras);
+                if (result == MmsUtils.STATUS_PENDING) {
+                    // Async send, so no status yet
+                    LogUtil.d(TAG, "SendMessageAction: Sending MMS message " + messageId
+                            + " asynchronously; waiting for callback to finish processing");
+                    return null;
+                }
+                status = result.status;
+                rawStatus = result.rawStatus;
+                resultCode = result.resultCode;
+            } else {
+                status = MmsUtils.MMS_REQUEST_MANUAL_RETRY;
+            }
+        }
+
+        // When we fast-fail before calling the MMS lib APIs (e.g. airplane mode,
+        // sending message is deleted).
+        ProcessSentMessageAction.processMessageSentFastFailed(messageId, messageUri,
+                updatedMessageUri, subId, isSms, status, rawStatus, resultCode);
+        return null;
+    }
+
+    // sprd add for smsc begin
+    private String getSmsServiceCenter(int subId) {
+        String smscStr = actionParameters.getString(KEY_SMS_SERVICE_CENTER);
+        final Context context = Factory.get().getApplicationContext();
+        if (smscStr == null || smscStr == "") {
+            smscStr = SmscManager.getSmscString(context, subId);
+        }
+        return smscStr;
+    }
+    // sprd add for smsc end
+    
+    private void updateMessageUri(final String messageId, final Uri updatedMessageUri) {
+        final DatabaseWrapper db = DataModel.get().getDatabase();
+        db.beginTransaction();
+        try {
+            final ContentValues values = new ContentValues();
+            values.put(MessageColumns.SMS_MESSAGE_URI, updatedMessageUri.toString());
+            BugleDatabaseOperations.updateMessageRow(db, messageId, values);
+            db.setTransactionSuccessful();
+        } finally {
+            db.endTransaction();
+        }
+    }
+
+    @Override
+    protected Object processBackgroundResponse(final Bundle response) {
+        // Nothing to do here, post-send tasks handled by ProcessSentMessageAction
+        return null;
+    }
+
+    /**
+     * Update message status to reflect success or failure
+     */
+    @Override
+    protected Object processBackgroundFailure() {
+        final String messageId = actionParameters.getString(KEY_MESSAGE_ID);
+        final MessageData message = actionParameters.getParcelable(KEY_MESSAGE);
+        final boolean isSms = message.getProtocol() == MessageData.PROTOCOL_SMS;
+        final int subId = actionParameters.getInt(KEY_SUB_ID, ParticipantData.DEFAULT_SELF_SUB_ID);
+        final int resultCode = actionParameters.getInt(ProcessSentMessageAction.KEY_RESULT_CODE);
+        final int httpStatusCode =
+                actionParameters.getInt(ProcessSentMessageAction.KEY_HTTP_STATUS_CODE);
+
+        ProcessSentMessageAction.processResult(messageId, null /* updatedMessageUri */,
+                MmsUtils.MMS_REQUEST_MANUAL_RETRY, MessageData.RAW_TELEPHONY_STATUS_UNDEFINED,
+                isSms, this, subId, resultCode, httpStatusCode);
+
+        // Whether we succeeded or failed we will check and maybe schedule some more work
+        ProcessPendingMessagesAction.scheduleProcessPendingMessagesAction(true, this);
+
+        return null;
+    }
+
+    /**
+     * Update the message status (and message itself if necessary)
+     * @param isSms whether this is an SMS or MMS
+     * @param message message to update
+     * @param updatedMessageUri message uri for newly-inserted messages; null otherwise
+     * @param clearSeen whether the message 'seen' status should be reset if error occurs
+     */
+    public static boolean updateMessageAndStatus(final boolean isSms, final MessageData message,
+            final Uri updatedMessageUri, final boolean clearSeen) {
+        final Context context = Factory.get().getApplicationContext();
+        final DatabaseWrapper db = DataModel.get().getDatabase();
+
+        // TODO: We're optimistically setting the type/box of outgoing messages to
+        // 'SENT' even before they actually are. We should technically be using QUEUED or OUTBOX
+        // instead, but if we do that, it's possible that the Messaging app will try to send them
+        // as part of its clean-up logic that runs when it starts (http://b/18155366).
+        //
+        // We also use the wrong status when inserting queued SMS messages in
+        // InsertNewMessageAction.insertBroadcastSmsMessage and insertSendingSmsMessage (should be
+        // QUEUED or OUTBOX), and in MmsUtils.insertSendReq (should be OUTBOX).
+
+        boolean updatedTelephony = true;
+        int messageBox;
+        int type;
+        switch(message.getStatus()) {
+            case MessageData.BUGLE_STATUS_OUTGOING_COMPLETE:
+            case MessageData.BUGLE_STATUS_OUTGOING_DELIVERED:
+                type = Sms.MESSAGE_TYPE_SENT;
+                messageBox = Mms.MESSAGE_BOX_SENT;
+                break;
+            case MessageData.BUGLE_STATUS_OUTGOING_YET_TO_SEND:
+            case MessageData.BUGLE_STATUS_OUTGOING_AWAITING_RETRY:
+                type = Sms.MESSAGE_TYPE_SENT;
+                messageBox = Mms.MESSAGE_BOX_SENT;
+                break;
+            case MessageData.BUGLE_STATUS_OUTGOING_SENDING:
+            case MessageData.BUGLE_STATUS_OUTGOING_RESENDING:
+                type = Sms.MESSAGE_TYPE_SENT;
+                messageBox = Mms.MESSAGE_BOX_SENT;
+                break;
+            case MessageData.BUGLE_STATUS_OUTGOING_FAILED:
+            case MessageData.BUGLE_STATUS_OUTGOING_FAILED_EMERGENCY_NUMBER:
+                type = Sms.MESSAGE_TYPE_FAILED;
+                messageBox = Mms.MESSAGE_BOX_FAILED;
+                break;
+            default:
+                type = Sms.MESSAGE_TYPE_ALL;
+                messageBox = Mms.MESSAGE_BOX_ALL;
+                break;
+        }
+        // First in the telephony DB
+        if (isSms) {
+            // Ignore update message Uri
+            if (type != Sms.MESSAGE_TYPE_ALL) {
+                if (!MmsUtils.updateSmsMessageSendingStatus(context, message.getSmsMessageUri(),
+                        type, message.getReceivedTimeStamp())) {
+                    message.markMessageFailed(message.getSentTimeStamp());
+                    updatedTelephony = false;
+                }
+            }
+        } else if (message.getSmsMessageUri() != null) {
+            if (messageBox != Mms.MESSAGE_BOX_ALL) {
+                if (!MmsUtils.updateMmsMessageSendingStatus(context, message.getSmsMessageUri(),
+                        messageBox, message.getReceivedTimeStamp())) {
+                    message.markMessageFailed(message.getSentTimeStamp());
+                    updatedTelephony = false;
+                }
+            }
+        }
+        if (updatedTelephony) {
+            if (LogUtil.isLoggable(TAG, LogUtil.VERBOSE)) {
+                LogUtil.v(TAG, "SendMessageAction: Updated " + (isSms ? "SMS" : "MMS")
+                        + " message " + message.getMessageId()
+                        + " in telephony (" + message.getSmsMessageUri() + ")");
+            }
+        } else {
+            LogUtil.w(TAG, "SendMessageAction: Failed to update " + (isSms ? "SMS" : "MMS")
+                    + " message " + message.getMessageId()
+                    + " in telephony (" + message.getSmsMessageUri() + "); marking message failed");
+        }
+
+        // Update the local DB
+        db.beginTransaction();
+        try {
+            if (updatedMessageUri != null) {
+                // Update all message and part fields
+                BugleDatabaseOperations.updateMessageInTransaction(db, message);
+                BugleDatabaseOperations.refreshConversationMetadataInTransaction(
+                        db, message.getConversationId(), false/* shouldAutoSwitchSelfId */,
+                        false/*archived*/);
+            } else {
+                final ContentValues values = new ContentValues();
+                values.put(MessageColumns.STATUS, message.getStatus());
+
+                if (clearSeen) {
+                    // When a message fails to send, the message needs to
+                    // be unseen to be selected as an error notification.
+                    values.put(MessageColumns.SEEN, 0);
+                }
+                values.put(MessageColumns.RECEIVED_TIMESTAMP, message.getReceivedTimeStamp());
+                values.put(MessageColumns.RAW_TELEPHONY_STATUS, message.getRawTelephonyStatus());
+
+                BugleDatabaseOperations.updateMessageRowIfExists(db, message.getMessageId(),
+                        values);
+            }
+            db.setTransactionSuccessful();
+            if (LogUtil.isLoggable(TAG, LogUtil.VERBOSE)) {
+                LogUtil.v(TAG, "SendMessageAction: Updated " + (isSms ? "SMS" : "MMS")
+                        + " message " + message.getMessageId() + " in local db. Timestamp = "
+                        + message.getReceivedTimeStamp());
+            }
+        } finally {
+            db.endTransaction();
+        }
+
+        MessagingContentProvider.notifyMessagesChanged(message.getConversationId());
+        if (updatedMessageUri != null) {
+            MessagingContentProvider.notifyPartsChanged();
+        }
+
+        return updatedTelephony;
+    }
+
+    private SendMessageAction(final Parcel in) {
+        super(in);
+    }
+
+    public static final Parcelable.Creator<SendMessageAction> CREATOR
+            = new Parcelable.Creator<SendMessageAction>() {
+        @Override
+        public SendMessageAction createFromParcel(final Parcel in) {
+            return new SendMessageAction(in);
+        }
+
+        @Override
+        public SendMessageAction[] newArray(final int size) {
+            return new SendMessageAction[size];
+        }
+    };
+
+    @Override
+    public void writeToParcel(final Parcel parcel, final int flags) {
+        writeActionToParcel(parcel, flags);
+    }
+}
Index: vendor/custom/cts/packages/apps/Messaging/res/xml/preferences_per_subscription.xml
===================================================================
--- vendor/custom/cts/packages/apps/Messaging/res/xml/preferences_per_subscription.xml	(revision 0)
+++ vendor/custom/cts/packages/apps/Messaging/res/xml/preferences_per_subscription.xml	(revision 173004)
@@ -0,0 +1,98 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (C) 2015 The Android Open Source Project
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<!-- Preference screen definition for Bugle's subscription-specific settings -->
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <PreferenceCategory
+        android:key="@string/mms_messaging_category_pref_key"
+        android:title="@string/mms_messaging_category_pref_title">
+
+        <Preference
+            android:title="@string/group_mms_pref_title"
+            android:key="@string/group_mms_pref_key"/>
+
+        <com.android.messaging.ui.appsettings.PhoneNumberPreference
+            android:key="@string/mms_phone_number_pref_key"
+            android:title="@string/mms_phone_number_pref_title" />
+
+        <CheckBoxPreference
+            android:key="@string/auto_retrieve_mms_pref_key"
+            android:title="@string/auto_retrieve_mms_pref_title"
+            android:summary="@string/auto_retrieve_mms_pref_summary"
+            android:defaultValue="@bool/auto_retrieve_mms_pref_default" />
+
+        <CheckBoxPreference
+            android:key="@string/auto_retrieve_mms_when_roaming_pref_key"
+            android:dependency="@string/auto_retrieve_mms_pref_key"
+            android:title="@string/auto_retrieve_mms_when_roaming_pref_title"
+            android:summary="@string/auto_retrieve_mms_when_roaming_pref_summary"
+            android:defaultValue="@bool/auto_retrieve_mms_when_roaming_pref_default" />
+                <CheckBoxPreference
+            android:defaultValue="@bool/mms_send_reports_pref_default"
+            android:key="@string/mms_send_reports_pref_key"
+            android:summary="@string/mms_send_reports_pref_summary"
+            android:title="@string/mms_send_reports_pref_title" />
+        <!-- 489220 begin -->
+        <CheckBoxPreference
+            android:defaultValue="@bool/mms_delivery_reports_pref_default"
+            android:key="@string/mms_delivery_reports_pref_key"
+            android:summary="@string/mms_delivery_reports_pref_summary"
+            android:title="@string/mms_delivery_reports_pref_title" />
+        <CheckBoxPreference
+            android:defaultValue="false"
+            android:key="@string/enable_return_mms_delivery_reports_pref_key"
+            android:summary="@string/enable_return_mms_delivery_reports_pref_summary"
+            android:title="@string/enable_return_mms_delivery_reports_pref_title" />
+        <CheckBoxPreference
+            android:defaultValue="@bool/mms_read_reports_pref_default"
+            android:key="@string/mms_read_reports_pref_key"
+            android:summary="@string/mms_read_reports_pref_summary"
+            android:title="@string/mms_read_reports_pref_title" />
+        <CheckBoxPreference
+            android:defaultValue="false"
+            android:key="@string/enable_return_mms_read_reports_pref_key"
+            android:summary="@string/enable_return_mms_read_reports_pref_summary"
+            android:title="@string/enable_return_mms_read_reports_pref_title" />
+        <!-- 489220 end -->
+
+    </PreferenceCategory>
+
+    <PreferenceCategory
+        android:key="@string/advanced_category_pref_key"
+        android:title="@string/advanced_category_pref_title">
+
+<CheckBoxPreference
+            android:key="@string/send_reports_pref_key"
+            android:title="@string/send_reports_pref_title"
+            android:summary="@string/send_reports_pref_summary"
+            android:defaultValue="@bool/send_reports_pref_default" />
+        <CheckBoxPreference
+            android:key="@string/delivery_reports_pref_key"
+            android:title="@string/delivery_reports_pref_title"
+            android:summary="@string/delivery_reports_pref_summary"
+            android:defaultValue="@bool/delivery_reports_pref_default" />
+
+        <Preference
+            android:key="@string/wireless_alerts_key"
+            android:title="@string/wireless_alerts_title"/>
+
+        <PreferenceScreen
+            android:key="@string/sms_apns_key"
+            android:title="@string/sms_apns_title" />
+
+    </PreferenceCategory>
+</PreferenceScreen>
Index: vendor/custom/cts/packages/apps/Messaging/res/menu/conversation_menu.xml
===================================================================
--- vendor/custom/cts/packages/apps/Messaging/res/menu/conversation_menu.xml	(revision 0)
+++ vendor/custom/cts/packages/apps/Messaging/res/menu/conversation_menu.xml	(revision 173004)
@@ -0,0 +1,71 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+	Copyright (C) 2015 The Android Open Source Project
+
+	Licensed under the Apache License, Version 2.0 (the "License");
+	you may not use this file except in compliance with the License.
+	You may obtain a copy of the License at
+
+		 http://www.apache.org/licenses/LICENSE-2.0
+
+	Unless required by applicable law or agreed to in writing, software
+	distributed under the License is distributed on an "AS IS" BASIS,
+	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+	See the License for the specific language governing permissions and
+	limitations under the License.
+-->
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    xmlns:appcompat="http://schemas.android.com/apk/res-auto"
+    tools:context="com.android.messaging.ConversationActivity" >
+
+    <item
+        android:id="@+id/action_call"
+        android:icon="@drawable/ic_phone_small_light"
+        android:orderInCategory="80"
+        android:title="@string/action_call"
+        appcompat:showAsAction="ifRoom"/>
+    <item
+        android:id="@+id/action_add_contact"
+        android:icon="@drawable/ic_person_add_light"
+        android:orderInCategory="90"
+        android:showAsAction="never"
+        android:title="@string/action_add_contact"/>
+    <item
+        android:id="@+id/action_people_and_options"
+        android:orderInCategory="100"
+        android:title="@string/action_people_and_options"
+        appcompat:showAsAction="never"/>
+    <item
+        android:id="@+id/action_archive"
+        android:orderInCategory="120"
+        android:showAsAction="never"
+        android:title="@string/action_archive"/>
+    <item
+        android:id="@+id/action_unarchive"
+        android:orderInCategory="130"
+        android:showAsAction="never"
+        android:title="@string/action_unarchive"/>
+    <item
+        android:id="@+id/action_delete"
+        android:orderInCategory="140"
+        android:showAsAction="never"
+        android:title="@string/action_delete"/>
+    <item
+        android:id="@+id/action_add_phrase"
+        android:orderInCategory="110"
+        android:showAsAction="never"
+        android:title="@string/action_add_phrase"/>
+    <item
+        android:id="@+id/action_sms_merge_forward"
+        android:orderInCategory="150"
+        android:showAsAction="never"
+        android:title="@string/sms_forward"/>
+		<!--wqq modify for bug 92593-->
+    <!--<item
+        android:id="@+id/goto_smil"
+        android:orderInCategory="150"
+        android:showAsAction="never"
+        android:title="@string/goto_smil"/>-->
+
+</menu>
Index: vendor/custom/cts/packages/apps/Messaging/res/xml-v21/preferences_per_subscription.xml
===================================================================
--- vendor/custom/cts/packages/apps/Messaging/res/xml-v21/preferences_per_subscription.xml	(revision 0)
+++ vendor/custom/cts/packages/apps/Messaging/res/xml-v21/preferences_per_subscription.xml	(revision 173004)
@@ -0,0 +1,166 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (C) 2015 The Android Open Source Project
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<!-- Preference screen definition for Bugle's subscription-specific settings -->
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <PreferenceCategory
+        android:key="@string/mms_messaging_category_pref_key"
+        android:title="@string/mms_messaging_category_pref_title">
+
+        <Preference
+            android:title="@string/group_mms_pref_title"
+            android:key="@string/group_mms_pref_key"/>
+
+        <com.android.messaging.ui.appsettings.PhoneNumberPreference
+            android:key="@string/mms_phone_number_pref_key"
+            android:title="@string/mms_phone_number_pref_title" />
+
+        <SwitchPreference
+            android:key="@string/auto_retrieve_mms_pref_key"
+            android:title="@string/auto_retrieve_mms_pref_title"
+            android:summary="@string/auto_retrieve_mms_pref_summary"
+            android:defaultValue="@bool/auto_retrieve_mms_pref_default" />
+
+        <SwitchPreference
+            android:key="@string/auto_retrieve_mms_when_roaming_pref_key"
+            android:dependency="@string/auto_retrieve_mms_pref_key"
+            android:title="@string/auto_retrieve_mms_when_roaming_pref_title"
+            android:summary="@string/auto_retrieve_mms_when_roaming_pref_summary"
+            android:defaultValue="@bool/auto_retrieve_mms_when_roaming_pref_default" />
+
+        <!-- Modify by SPRD for bug 526653 Start -->
+        <ListPreference
+            android:key="@string/mms_validity_pref_key"
+            android:title="@string/mms_validity_pref_title"
+            android:entries="@array/mms_validity_pref_entries"
+            android:entryValues="@array/mms_validity_pref_entry_values"
+            android:dialogTitle="@string/mms_validity_pref_title" />
+        <!-- Modify by SPRD for bug 526653 End -->
+        <!-- Sprd add for sms and mms validity end -->
+
+<!-- 584079 begin -->
+        <SwitchPreference
+            android:defaultValue="@bool/mms_send_reports_pref_default"
+            android:key="@string/mms_send_reports_pref_key"
+            android:summary="@string/mms_send_reports_pref_summary"
+            android:title="@string/mms_send_reports_pref_title" />
+        <!-- 584079 end -->
+
+        <ListPreference android:key="pref_key_mms_size_limit"
+            android:title="@string/pref_title_mms_size_limit"
+            android:dialogTitle="@string/pref_title_mms_size_limit"
+            android:defaultValue="1024" android:entries="@array/pref_mms_size_limit_choices"
+            android:entryValues="@array/pref_mms_size_limit_values" />
+
+        <!-- 489220 begin -->
+        <SwitchPreference
+            android:defaultValue="@bool/mms_delivery_reports_pref_default"
+            android:key="@string/mms_delivery_reports_pref_key"
+            android:summary="@string/mms_delivery_reports_pref_summary"
+            android:title="@string/mms_delivery_reports_pref_title" />
+
+        <!-- Delete by SPRD for Bug531825  2016.03.17 Start-->
+        <!-- <SwitchPreference
+            android:defaultValue="false"
+            android:key="@string/enable_return_mms_delivery_reports_pref_key"
+            android:summary="@string/enable_return_mms_delivery_reports_pref_summary"
+            android:title="@string/enable_return_mms_delivery_reports_pref_title" /> -->
+        <!-- Delete by SPRD for Bug531825  2016.03.17 End-->
+
+        <SwitchPreference
+
+            android:defaultValue="@bool/mms_read_reports_pref_default"
+            android:key="@string/mms_read_reports_pref_key"
+            android:summary="@string/mms_read_reports_pref_summary"
+            android:title="@string/mms_read_reports_pref_title" />
+
+        <SwitchPreference
+            android:defaultValue="false"
+            android:key="@string/enable_return_mms_read_reports_pref_key"
+            android:summary="@string/enable_return_mms_read_reports_pref_summary"
+            android:title="@string/enable_return_mms_read_reports_pref_title" />
+        <!-- 489220 end -->
+
+    </PreferenceCategory>
+
+    <PreferenceCategory
+        android:key="@string/advanced_category_pref_key"
+        android:title="@string/advanced_category_pref_title">
+
+<!-- 584079 begin -->
+        <SwitchPreference
+            android:key="@string/send_reports_pref_key"
+            android:title="@string/send_reports_pref_title"
+            android:summary="@string/send_reports_pref_summary"
+            android:defaultValue="@bool/send_reports_pref_default" />
+        <!-- 584079 end -->
+        <SwitchPreference
+            android:key="@string/delivery_reports_pref_key"
+            android:title="@string/delivery_reports_pref_title"
+            android:summary="@string/delivery_reports_pref_summary"
+            android:defaultValue="@bool/delivery_reports_pref_default" />
+
+        <Preference
+            android:key="@string/smsc_pref_key"
+            android:title="@string/pref_title_manage_sim_smsc"/>
+
+<!-- sprd bug 497178 -->
+<!--        <Preference
+            android:key="@string/wireless_alerts_key"
+            android:title="@string/wireless_alerts_title"/>
+-->
+
+        <!-- add for bug 556265 begin -->
+        <Preference
+            android:key="@string/capacity_sim_message_key"
+            android:title="@string/capacity_sim_message_title"/>
+        <!-- add for bug 556265 end -->
+
+        <PreferenceScreen
+            android:key="@string/sms_apns_key"
+            android:title="@string/sms_apns_title" />
+        <SwitchPreference
+            android:key="@string/sms_retry_times_pref_key"
+            android:title="@string/pref_title_sms_retry_times"
+            android:defaultValue="true" /><!-- modify for bug 552911 -->
+
+        <!-- Sprd add for sms and mms validity start -->
+        <!-- Modify by SPRD for bug 526653 Start -->
+        <ListPreference
+            android:key="@string/sms_validity_pref_key"
+            android:title="@string/sms_validity_pref_title"
+            android:entries="@array/sms_validity_pref_entries"
+            android:entryValues="@array/sms_validity_pref_entry_values"
+            android:dialogTitle="@string/sms_validity_pref_title" />
+        <!-- Modify by SPRD for bug 526653 End -->
+        <!-- Sprd add for sms and mms validity end -->
+        
+        <!-- sprd #542214 start -->
+        <SwitchPreference
+            android:key="@string/sms_save_to_sim_pref_key"
+            android:title="@string/sms_save_to_sim_pref_title"
+            android:summary="@string/sms_save_to_sim_pref_summary"
+            android:defaultValue="@bool/sms_save_to_sim_pref_default"/>
+        <!-- sprd #542214 end -->
+
+        <SwitchPreference
+            android:key="@string/sms_wap_pref_key"
+            android:title="@string/sms_wap_pref_title"
+            android:summary="@string/sms_wap_pref_summary"
+            android:defaultValue="@bool/sms_wap_pref_default" />
+</PreferenceCategory>
+</PreferenceScreen>
Index: vendor/custom/cts/packages/apps/Messaging/res/layout/compose_message_view.xml
===================================================================
--- vendor/custom/cts/packages/apps/Messaging/res/layout/compose_message_view.xml	(revision 0)
+++ vendor/custom/cts/packages/apps/Messaging/res/layout/compose_message_view.xml	(revision 173004)
@@ -0,0 +1,259 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (C) 2015 The Android Open Source Project
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<com.android.messaging.ui.conversation.ComposeMessageView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:id="@+id/message_compose_view_container"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:orientation="vertical" >
+
+    <!-- Note it may seem off to have the layout_weight="1" on the compose bar and attachment view
+     when it's the media picker that expands, but this is correct because weight also works when
+     there's not enough space.  Any views with positive weights will be shrunk to make space.
+     When the media picker goes full screen, it fills the parent, leaving no room for the compose
+     bar -->
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_weight="1"
+        android:clipChildren="false"
+        android:clipToPadding="false"
+        android:orientation="vertical">
+
+        <View
+            android:id="@+id/top_margin"
+            android:layout_width="match_parent"
+            android:layout_height="16dp" />
+
+        <include layout="@layout/attachment_preview"
+            android:id="@+id/attachment_draft_view"
+            style="@style/ComposeMessageViewDraftViewStyle"
+            android:layout_width="match_parent"
+            android:layout_height="0dp"
+            android:layout_marginBottom="4dp"
+            android:layout_weight="1"
+            android:visibility="gone" />
+
+        <RelativeLayout
+            android:id="@+id/subject_view"
+            style="@style/SubjectViewStyle"
+            android:paddingTop="@dimen/compose_message_subject_top_padding"
+            android:paddingBottom="@dimen/compose_message_subject_bottom_padding"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:visibility="gone"
+            android:clipChildren="false"
+            android:clipToPadding="false"
+            android:orientation="horizontal">
+
+            <com.android.messaging.ui.PlainTextEditText
+                android:background="@drawable/subject_editor_bubble"
+                android:id="@+id/compose_subject_text"
+                style="@style/ConversationComposeSubjectText"
+                android:hint="@string/compose_message_view_subject_hint_text"
+                android:layout_height="wrap_content"
+                android:layout_width="match_parent"
+                android:imeOptions="flagNoExtractUi" />
+
+            <ImageButton
+                android:id="@+id/delete_subject_button"
+                style="@style/AttachmentPreviewCloseButtonStyle"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:background="@null"
+                android:src="@drawable/ic_remove_light"
+                android:translationY="@dimen/compose_message_subject_cancel_top_offset"
+                android:contentDescription="@string/delete_subject_content_description" />
+
+        </RelativeLayout>
+
+        <!-- Holds all views that create the actual compose box -->
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal">
+
+            <!-- Contains compose message bubble and character counter for SMS which should be left
+            aligned -->
+            <LinearLayout
+                android:layout_width="0dp"
+                android:layout_weight="1"
+                android:layout_height="wrap_content"
+                android:orientation="vertical">
+
+                <!-- Contains media button and compose message bubble whose centers should be
+                vertically aligned -->
+                <LinearLayout
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:orientation="horizontal">
+
+                    <ImageButton
+                        android:id="@+id/attach_media_button"
+                        style="@style/ComposeMessageViewAttachMediaButtonStyle"
+                        android:layout_width="wrap_content"
+                        android:layout_height="wrap_content"
+                        android:layout_gravity="center_vertical"
+                        android:src="@drawable/ic_attachment_dark"
+                        android:visibility="gone"
+                        android:paddingTop="@dimen/compose_message_attachment_padding_topBottom"
+                        android:paddingBottom="@dimen/compose_message_attachment_padding_topBottom"
+                        android:contentDescription="@string/attachMediaButtonContentDescription" />
+
+                    <LinearLayout
+                        android:layout_height="wrap_content"
+                        android:layout_width="match_parent"
+                        android:layout_gravity="center"
+                        android:background="@drawable/msg_bubble_input"
+                        android:layout_marginStart="8dp"
+                        android:orientation="vertical">
+
+                        <com.android.messaging.ui.PlainTextEditText
+                            android:id="@+id/compose_message_text"
+                            style="@style/ConversationComposeSendText"
+                            android:layout_height="wrap_content"
+                            android:layout_width="match_parent"
+                            android:layout_gravity="center"
+                            android:hint="@string/compose_message_view_hint_text"
+                            android:imeOptions="actionSend|flagNoEnterAction|flagNoExtractUi" />
+
+                        <TextView
+                            android:id="@+id/signature_indicator"
+                            style="@style/MmsIndicatorStyle"
+                            android:layout_width="match_parent"
+                            android:layout_height="wrap_content"
+                            android:layout_alignParentRight="true"
+                            android:layout_alignParentBottom="true"
+                            android:singleLine="true"
+                            android:maxLines="1"
+                            android:gravity="right"
+                            android:ellipsize="end" />
+
+                    </LinearLayout>
+
+                </LinearLayout>
+				
+				<LinearLayout
+					android:id="@+id/ll_two_sim"
+					android:orientation="horizontal"
+					android:layout_width="match_parent"
+					android:layout_height="wrap_content"
+					android:paddingTop="16dp">	
+					<RelativeLayout
+						android:orientation="horizontal"
+						android:layout_width="0dp"
+						android:layout_height="wrap_content"
+						android:layout_weight="1">
+						<ImageButton
+							android:id="@+id/select_sim_button"
+							android:layout_centerInParent="true"
+							android:layout_width="72dp"
+							android:layout_height="46dp"
+							android:layout_weight="1"
+							android:background="@drawable/button_click"/>
+					</RelativeLayout>	
+					<View  
+						android:layout_width="1dip" 
+						android:layout_height="@dimen/conversation_message_contact_icon_size"
+						android:background="#969696"
+						android:layout_gravity="center_horizontal"/>
+						
+					<RelativeLayout
+						android:orientation="horizontal"
+						android:layout_width="0dp"
+						android:layout_height="wrap_content"
+						android:layout_weight="1">	
+					
+						<TextView
+							android:id="@+id/char_counter1"
+							style="@style/ComposeMessageViewTextCounterStyle"
+							android:layout_width="wrap_content"
+							android:layout_height="wrap_content"
+							android:singleLine="true"
+							android:maxLines="1"
+							android:paddingLeft="8dp"
+							android:visibility="gone" />
+					
+						<ImageButton
+							android:id="@+id/send_sms_button"
+							android:layout_centerInParent="true"
+							android:layout_width="72dp"
+							android:layout_height="46dp"
+							android:background="@drawable/button_click"
+							android:contentDescription="@string/sendButtonContentDescription"/>
+					</RelativeLayout>
+				</LinearLayout>
+				<TextView
+                    android:id="@+id/char_counter"
+                    style="@style/ComposeMessageViewTextCounterStyle"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:singleLine="true"
+                    android:maxLines="1"
+                    android:visibility="gone" />
+            </LinearLayout>
+
+            <LinearLayout
+				android:id="@+id/ll_one_sim"
+                android:orientation="vertical"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content">
+
+                <FrameLayout
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    style="@style/ComposeMessageViewFrameLayoutStyle"
+                    android:layout_gravity="top" >
+                    <com.android.messaging.ui.conversation.SimIconView
+                        android:id="@+id/self_send_icon"
+                        android:layout_width="@dimen/conversation_message_contact_icon_size"
+                        android:layout_height="@dimen/conversation_message_contact_icon_size"
+                        android:importantForAccessibility="no"
+                        app:iconSize="normal"
+                        app:reveal="true"
+                        android:clickable="true" />
+                    <ImageButton
+                        android:id="@+id/send_message_button"
+                        android:layout_width="@dimen/conversation_message_contact_icon_size"
+                        android:layout_height="@dimen/conversation_message_contact_icon_size"
+                        android:src="@drawable/ic_send_light"
+                        android:background="@drawable/send_arrow_background"
+                        android:contentDescription="@string/sendButtonContentDescription"
+                        android:visibility="gone" />
+                </FrameLayout>
+
+                <TextView
+                    android:id="@+id/mms_indicator"
+                    style="@style/MmsIndicatorStyle"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:singleLine="true"
+                    android:maxLines="1"
+                    android:visibility="invisible"
+                    android:text="@string/mms_text" />
+            </LinearLayout>
+        </LinearLayout>
+    </LinearLayout>
+
+    <FrameLayout
+        android:id="@+id/mediapicker_container"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_weight="0" />
+
+</com.android.messaging.ui.conversation.ComposeMessageView>
Index: vendor/custom/cts/packages/services/Mms/src/com/android/mms/service/MmsService.java
===================================================================
--- vendor/custom/cts/packages/services/Mms/src/com/android/mms/service/MmsService.java	(revision 0)
+++ vendor/custom/cts/packages/services/Mms/src/com/android/mms/service/MmsService.java	(revision 173004)
@@ -0,0 +1,944 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.mms.service;
+
+import android.annotation.Nullable;
+import android.app.PendingIntent;
+import android.app.Service;
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.database.sqlite.SQLiteException;
+import android.net.Uri;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.ParcelFileDescriptor;
+import android.os.Process;
+import android.os.RemoteException;
+import android.provider.Telephony;
+import android.service.carrier.CarrierMessagingService;
+import android.telephony.SmsManager;
+import android.telephony.SmsManagerEx;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.SparseArray;
+import android.widget.Toast;
+import android.os.Handler;
+
+import com.android.internal.telephony.IMms;
+import com.google.android.mms.MmsException;
+import com.google.android.mms.pdu.DeliveryInd;
+import com.google.android.mms.pdu.EncodedStringValue;
+import com.google.android.mms.pdu.GenericPdu;
+import com.google.android.mms.pdu.NotificationInd;
+import com.google.android.mms.pdu.PduParser;
+import com.google.android.mms.pdu.PduPersister;
+import com.google.android.mms.pdu.ReadOrigInd;
+import com.google.android.mms.pdu.RetrieveConf;
+import com.google.android.mms.pdu.SendReq;
+import com.google.android.mms.util.SqliteWrapper;
+
+import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * System service to process MMS API requests
+ */
+public class MmsService extends Service implements MmsRequest.RequestManager {
+    public static final int QUEUE_INDEX_SEND = 0;
+    public static final int QUEUE_INDEX_DOWNLOAD = 1;
+
+    private static final String SHARED_PREFERENCES_NAME = "mmspref";
+    private static final String PREF_AUTO_PERSISTING = "autopersisting";
+
+    // Maximum time to spend waiting to read data from a content provider before failing with error.
+    private static final int TASK_TIMEOUT_MS = 30 * 1000;
+    // Maximum size of MMS service supports - used on occassions when MMS messages are processed
+    // in a carrier independent manner (for example for imports and drafts) and the carrier
+    // specific size limit should not be used (as it could be lower on some carriers).
+    private static final int MAX_MMS_FILE_SIZE = 8 * 1024 * 1024;
+
+    // The default number of threads allowed to run MMS requests in each queue
+    public static final int THREAD_POOL_SIZE = 4;
+
+    // Pending requests that are waiting for the SIM to be available
+    // If a different SIM is currently used by previous requests, the following
+    // requests will stay in this queue until that SIM finishes its current requests in
+    // RequestQueue.
+    // Requests are not reordered. So, e.g. if current SIM is SIM1, a request for SIM2 will be
+    // blocked in the queue. And a later request for SIM1 will be appended to the queue, ordered
+    // after the request for SIM2, instead of being put into the running queue.
+    // TODO: persist this in case MmsService crashes
+    private final Queue<MmsRequest> mPendingSimRequestQueue = new ArrayDeque<>();
+
+    // Thread pool for transferring PDU with MMS apps
+    private final ExecutorService mPduTransferExecutor = Executors.newCachedThreadPool();
+
+    // A cache of MmsNetworkManager for SIMs
+    private final SparseArray<MmsNetworkManager> mNetworkManagerCache = new SparseArray<>();
+
+    // The current SIM ID for the running requests. Only one SIM can send/download MMS at a time.
+    private int mCurrentSubId;
+    // The current running MmsRequest count.
+    private int mRunningRequestCount;
+
+    // Running request queues, one thread pool per queue
+    // 0: send queue
+    // 1: download queue
+    private final ExecutorService[] mRunningRequestExecutors = new ExecutorService[2];
+
+    private MmsNetworkManager getNetworkManager(int subId) {
+        synchronized (mNetworkManagerCache) {
+            MmsNetworkManager manager = mNetworkManagerCache.get(subId);
+            if (manager == null) {
+                manager = new MmsNetworkManager(this, subId);
+                mNetworkManagerCache.put(subId, manager);
+            }
+            return manager;
+        }
+    }
+
+    private void enforceSystemUid() {
+        if (Binder.getCallingUid() != Process.SYSTEM_UID) {
+            throw new SecurityException("Only system can call this service");
+        }
+    }
+
+    private int checkSubId(int subId) {
+        if (!SubscriptionManager.isValidSubscriptionId(subId)) {
+            throw new RuntimeException("Invalid subId " + subId);
+        }
+        if (subId == SubscriptionManager.DEFAULT_SUBSCRIPTION_ID) {
+            return SubscriptionManager.getDefaultSmsSubscriptionId();
+        }
+        return subId;
+    }
+
+    @Nullable
+    private String getCarrierMessagingServicePackageIfExists() {
+        Intent intent = new Intent(CarrierMessagingService.SERVICE_INTERFACE);
+        TelephonyManager telephonyManager =
+                (TelephonyManager) this.getSystemService(Context.TELEPHONY_SERVICE);
+        List<String> carrierPackages = telephonyManager.getCarrierPackageNamesForIntent(intent);
+
+        if (carrierPackages == null || carrierPackages.size() != 1) {
+            return null;
+        } else {
+            return carrierPackages.get(0);
+        }
+    }
+
+    /**
+     * get set value to make Fdn contacts check.
+     *@param value
+     *@hide
+     */
+    private boolean shoudStopMmsSending(EncodedStringValue[] value , int sub) {
+        ArrayList<String> listContacts = new ArrayList<String>(value.length);
+        int maxIndex = value.length - 1;
+        for (int i = 0; i <= maxIndex; i++) {
+            listContacts.add(value[i].getString());
+        }
+        if (listContacts.size() > 0) {
+            boolean needStop = true;
+            SmsManagerEx mSmsManagerEx = SmsManagerEx.getSubActivity(sub);
+            boolean[] sendFilter = mSmsManagerEx.checkFdnContacts(listContacts);
+            for (int j = 0; j < sendFilter.length; j++) {
+                needStop = needStop && sendFilter[j];
+            }
+            return needStop;
+        }
+        return false;
+    }
+
+    private Handler handler = new Handler();
+
+    private void showToast() {
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                Toast.makeText(getApplicationContext(),
+                        getResources().getString(R.string.fdn_check_failure),
+                        Toast.LENGTH_SHORT).show();
+
+            }
+        });
+    }
+
+    // sprd: 596495 fdn feature end
+    private IMms.Stub mStub = new IMms.Stub() {
+        @Override
+        public void sendMessage(int subId, String callingPkg, Uri contentUri,
+                String locationUrl, Bundle configOverrides, PendingIntent sentIntent)
+                        throws RemoteException {
+            enforceSystemUid();
+
+            // Make sure the subId is correct
+            subId = checkSubId(subId);
+
+            // Make sure the subId is active
+            if (!isActiveSubId(subId)) {
+                sendErrorInPendingIntent(sentIntent);
+                return;
+            }
+            //add for bug 648125--begin
+            byte[] pduData = readPduFromContentUri(contentUri, MAX_MMS_FILE_SIZE);
+            if (pduData == null|| pduData.length < 1){
+                return;
+            }else {
+                final GenericPdu pdu =parsePduForAnyCarrier(pduData);
+	         if (pdu instanceof SendReq){
+                    android.util.Log.d("MmsService","SendReq");
+                    EncodedStringValue[] value = ((SendReq)pdu).getTo();
+                    if (shoudStopMmsSending(value, subId)){
+                        LogUtil.d("sendMmsMessage: Invalid FDN destinationAddress");
+                        new Thread(new Runnable() {
+                            public void run() {
+                                showToast();
+                            }
+                        }).start();
+                        throw new IllegalArgumentException();
+                    }
+                }
+            }
+            //add for bug 648125--end
+            final SendRequest request = new SendRequest(MmsService.this, subId, contentUri,
+                    locationUrl, sentIntent, callingPkg, configOverrides, MmsService.this);
+
+            final String carrierMessagingServicePackage =
+                    getCarrierMessagingServicePackageIfExists();
+            if (carrierMessagingServicePackage != null) {
+                LogUtil.d(request.toString(), "sending message by carrier app");
+                request.trySendingByCarrierApp(MmsService.this, carrierMessagingServicePackage);
+            } else {
+                addSimRequest(request);
+            }
+        }
+
+        @Override
+        public void downloadMessage(int subId, String callingPkg, String locationUrl,
+                Uri contentUri, Bundle configOverrides,
+                PendingIntent downloadedIntent) throws RemoteException {
+            LogUtil.d("downloadMessage: " + MmsHttpClient.redactUrlForNonVerbose(locationUrl));
+            enforceSystemUid();
+
+            // Make sure the subId is correct
+            subId = checkSubId(subId);
+
+            // If the subId is no longer active it could be caused by
+            // an MVNO using multiple subIds, so we should try to
+            // download anyway.
+            // TODO: Fail fast when downloading will fail (i.e. SIM swapped)
+
+            final DownloadRequest request = new DownloadRequest(MmsService.this, subId, locationUrl,
+                    contentUri, downloadedIntent, callingPkg, configOverrides, MmsService.this);
+            final String carrierMessagingServicePackage =
+                    getCarrierMessagingServicePackageIfExists();
+            if (carrierMessagingServicePackage != null) {
+                LogUtil.d(request.toString(), "downloading message by carrier app");
+                request.tryDownloadingByCarrierApp(MmsService.this, carrierMessagingServicePackage);
+            } else {
+                addSimRequest(request);
+            }
+        }
+
+        public Bundle getCarrierConfigValues(int subId) {
+            LogUtil.d("getCarrierConfigValues");
+            // Make sure the subId is correct
+            subId = checkSubId(subId);
+            final Bundle mmsConfig = MmsConfigManager.getInstance().getMmsConfigBySubId(subId);
+            if (mmsConfig == null) {
+                return new Bundle();
+            }
+            return mmsConfig;
+        }
+
+        @Override
+        public Uri importTextMessage(String callingPkg, String address, int type, String text,
+                long timestampMillis, boolean seen, boolean read) {
+            LogUtil.d("importTextMessage");
+            enforceSystemUid();
+            return importSms(address, type, text, timestampMillis, seen, read, callingPkg);
+        }
+
+        @Override
+        public Uri importMultimediaMessage(String callingPkg, Uri contentUri,
+                String messageId, long timestampSecs, boolean seen, boolean read) {
+            LogUtil.d("importMultimediaMessage");
+            enforceSystemUid();
+            return importMms(contentUri, messageId, timestampSecs, seen, read, callingPkg);
+        }
+
+        @Override
+        public boolean deleteStoredMessage(String callingPkg, Uri messageUri)
+                throws RemoteException {
+            LogUtil.d("deleteStoredMessage " + messageUri);
+            enforceSystemUid();
+            if (!isSmsMmsContentUri(messageUri)) {
+                LogUtil.e("deleteStoredMessage: invalid message URI: " + messageUri.toString());
+                return false;
+            }
+            // Clear the calling identity and query the database using the phone user id
+            // Otherwise the AppOps check in TelephonyProvider would complain about mismatch
+            // between the calling uid and the package uid
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                if (getContentResolver().delete(
+                        messageUri, null/*where*/, null/*selectionArgs*/) != 1) {
+                    LogUtil.e("deleteStoredMessage: failed to delete");
+                    return false;
+                }
+            } catch (SQLiteException e) {
+                LogUtil.e("deleteStoredMessage: failed to delete", e);
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+            return true;
+        }
+
+        @Override
+        public boolean deleteStoredConversation(String callingPkg, long conversationId)
+                throws RemoteException {
+            LogUtil.d("deleteStoredConversation " + conversationId);
+            enforceSystemUid();
+            if (conversationId == -1) {
+                LogUtil.e("deleteStoredConversation: invalid thread id");
+                return false;
+            }
+            final Uri uri = ContentUris.withAppendedId(
+                    Telephony.Threads.CONTENT_URI, conversationId);
+            // Clear the calling identity and query the database using the phone user id
+            // Otherwise the AppOps check in TelephonyProvider would complain about mismatch
+            // between the calling uid and the package uid
+            final long identity = Binder.clearCallingIdentity();
+            try {
+                if (getContentResolver().delete(uri, null, null) != 1) {
+                    LogUtil.e("deleteStoredConversation: failed to delete");
+                    return false;
+                }
+            } catch (SQLiteException e) {
+                LogUtil.e("deleteStoredConversation: failed to delete", e);
+            } finally {
+                Binder.restoreCallingIdentity(identity);
+            }
+            return true;
+        }
+
+        @Override
+        public boolean updateStoredMessageStatus(String callingPkg, Uri messageUri,
+                ContentValues statusValues) throws RemoteException {
+            LogUtil.d("updateStoredMessageStatus " + messageUri);
+            enforceSystemUid();
+            return updateMessageStatus(messageUri, statusValues);
+        }
+
+        @Override
+        public boolean archiveStoredConversation(String callingPkg, long conversationId,
+                boolean archived) throws RemoteException {
+            LogUtil.d("archiveStoredConversation " + conversationId + " " + archived);
+            if (conversationId == -1) {
+                LogUtil.e("archiveStoredConversation: invalid thread id");
+                return false;
+            }
+            return archiveConversation(conversationId, archived);
+        }
+
+        @Override
+        public Uri addTextMessageDraft(String callingPkg, String address, String text)
+                throws RemoteException {
+            LogUtil.d("addTextMessageDraft");
+            enforceSystemUid();
+            return addSmsDraft(address, text, callingPkg);
+        }
+
+        @Override
+        public Uri addMultimediaMessageDraft(String callingPkg, Uri contentUri)
+                throws RemoteException {
+            LogUtil.d("addMultimediaMessageDraft");
+            enforceSystemUid();
+            return addMmsDraft(contentUri, callingPkg);
+        }
+
+        @Override
+        public void sendStoredMessage(int subId, String callingPkg, Uri messageUri,
+                Bundle configOverrides, PendingIntent sentIntent) throws RemoteException {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public void setAutoPersisting(String callingPkg, boolean enabled) throws RemoteException {
+            LogUtil.d("setAutoPersisting " + enabled);
+            enforceSystemUid();
+            final SharedPreferences preferences = getSharedPreferences(
+                    SHARED_PREFERENCES_NAME, MODE_PRIVATE);
+            final SharedPreferences.Editor editor = preferences.edit();
+            editor.putBoolean(PREF_AUTO_PERSISTING, enabled);
+            editor.apply();
+        }
+
+        @Override
+        public boolean getAutoPersisting() throws RemoteException {
+            LogUtil.d("getAutoPersisting");
+            return getAutoPersistingPref();
+        }
+
+        /*
+         * @return true if the subId is active.
+         */
+        private boolean isActiveSubId(int subId) {
+            return SubscriptionManager.from(MmsService.this).isActiveSubId(subId);
+        }
+
+        /*
+         * Calls the pending intent with <code>MMS_ERROR_NO_DATA_NETWORK</code>.
+         */
+        private void sendErrorInPendingIntent(@Nullable PendingIntent intent) {
+            if (intent != null) {
+                try {
+                    intent.send(SmsManager.MMS_ERROR_NO_DATA_NETWORK);
+                } catch (PendingIntent.CanceledException ex) {
+                }
+            }
+        }
+    };
+
+    @Override
+    public void addSimRequest(MmsRequest request) {
+        if (request == null) {
+            LogUtil.e("Add running or pending: empty request");
+            return;
+        }
+        LogUtil.d("Current running=" + mRunningRequestCount + ", "
+                + "current subId=" + mCurrentSubId + ", "
+                + "pending=" + mPendingSimRequestQueue.size());
+        synchronized (this) {
+            if (mPendingSimRequestQueue.size() > 0 ||
+                    (mRunningRequestCount > 0 && request.getSubId() != mCurrentSubId)) {
+                LogUtil.d("Add request to pending queue."
+                        + " Request subId=" + request.getSubId() + ","
+                        + " current subId=" + mCurrentSubId);
+                // Delete for bug 542996
+                // mPendingSimRequestQueue.add(request);
+                /* Add by SPRD for bug 542996 Start */
+                if (request.getSubId() != mCurrentSubId) {
+                    mPendingSimRequestQueue.add(request);
+                }
+                /* Add by SPRD for bug 542996 End */
+                if (mRunningRequestCount <= 0) {
+                    LogUtil.e("Nothing's running but queue's not empty");
+                    // Nothing is running but we are accumulating on pending queue.
+                    // This should not happen. But just in case...
+                    movePendingSimRequestsToRunningSynchronized();
+                }
+            } else {
+                addToRunningRequestQueueSynchronized(request);
+            }
+        }
+    }
+
+    private void addToRunningRequestQueueSynchronized(final MmsRequest request) {
+        LogUtil.d("Add request to running queue for subId " + request.getSubId());
+        // Update current state of running requests
+        final int queue = request.getQueueType();
+        if (queue < 0 || queue >= mRunningRequestExecutors.length) {
+            LogUtil.e("Invalid request queue index for running request");
+            return;
+        }
+        mRunningRequestCount++;
+        mCurrentSubId = request.getSubId();
+        // Send to the corresponding request queue for execution
+        mRunningRequestExecutors[queue].execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    request.execute(MmsService.this, getNetworkManager(request.getSubId()));
+                } finally {
+                    synchronized (MmsService.this) {
+                        mRunningRequestCount--;
+                        if (mRunningRequestCount <= 0) {
+                            movePendingSimRequestsToRunningSynchronized();
+                        }
+                    }
+                }
+            }
+        });
+    }
+
+    private void movePendingSimRequestsToRunningSynchronized() {
+        LogUtil.d("Schedule requests pending on SIM");
+        mCurrentSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
+        while (mPendingSimRequestQueue.size() > 0) {
+            final MmsRequest request = mPendingSimRequestQueue.peek();
+            if (request != null) {
+                if (!SubscriptionManager.isValidSubscriptionId(mCurrentSubId)
+                        || mCurrentSubId == request.getSubId()) {
+                    // First or subsequent requests with same SIM ID
+                    mPendingSimRequestQueue.remove();
+                    addToRunningRequestQueueSynchronized(request);
+                } else {
+                    // Stop if we see a different SIM ID
+                    break;
+                }
+            } else {
+                LogUtil.e("Schedule pending: found empty request");
+                mPendingSimRequestQueue.remove();
+            }
+        }
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return mStub;
+    }
+
+    public final IBinder asBinder() {
+        return mStub;
+    }
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        LogUtil.d("onCreate");
+        // Load mms_config
+        MmsConfigManager.getInstance().init(this);
+        // Initialize running request state
+        for (int i = 0; i < mRunningRequestExecutors.length; i++) {
+            mRunningRequestExecutors[i] = Executors.newFixedThreadPool(THREAD_POOL_SIZE);
+        }
+        synchronized (this) {
+            mCurrentSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
+            mRunningRequestCount = 0;
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        LogUtil.d("onDestroy");
+        for (ExecutorService executor : mRunningRequestExecutors) {
+            executor.shutdown();
+        }
+    }
+
+    private Uri importSms(String address, int type, String text, long timestampMillis,
+            boolean seen, boolean read, String creator) {
+        Uri insertUri = null;
+        switch (type) {
+            case SmsManager.SMS_TYPE_INCOMING:
+                insertUri = Telephony.Sms.Inbox.CONTENT_URI;
+
+                break;
+            case SmsManager.SMS_TYPE_OUTGOING:
+                insertUri = Telephony.Sms.Sent.CONTENT_URI;
+                break;
+        }
+        if (insertUri == null) {
+            LogUtil.e("importTextMessage: invalid message type for importing: " + type);
+            return null;
+        }
+        final ContentValues values = new ContentValues(6);
+        values.put(Telephony.Sms.ADDRESS, address);
+        values.put(Telephony.Sms.DATE, timestampMillis);
+        values.put(Telephony.Sms.SEEN, seen ? 1 : 0);
+        values.put(Telephony.Sms.READ, read ? 1 : 0);
+        values.put(Telephony.Sms.BODY, text);
+        if (!TextUtils.isEmpty(creator)) {
+            values.put(Telephony.Mms.CREATOR, creator);
+        }
+        // Clear the calling identity and query the database using the phone user id
+        // Otherwise the AppOps check in TelephonyProvider would complain about mismatch
+        // between the calling uid and the package uid
+        final long identity = Binder.clearCallingIdentity();
+        try {
+            return getContentResolver().insert(insertUri, values);
+        } catch (SQLiteException e) {
+            LogUtil.e("importTextMessage: failed to persist imported text message", e);
+        } finally {
+            Binder.restoreCallingIdentity(identity);
+        }
+        return null;
+    }
+
+    private Uri importMms(Uri contentUri, String messageId, long timestampSecs,
+            boolean seen, boolean read, String creator) {
+        byte[] pduData = readPduFromContentUri(contentUri, MAX_MMS_FILE_SIZE);
+        if (pduData == null || pduData.length < 1) {
+            LogUtil.e("importMessage: empty PDU");
+            return null;
+        }
+        // Clear the calling identity and query the database using the phone user id
+        // Otherwise the AppOps check in TelephonyProvider would complain about mismatch
+        // between the calling uid and the package uid
+        final long identity = Binder.clearCallingIdentity();
+        try {
+            final GenericPdu pdu = parsePduForAnyCarrier(pduData);
+            if (pdu == null) {
+                LogUtil.e("importMessage: can't parse input PDU");
+                return null;
+            }
+            Uri insertUri = null;
+            if (pdu instanceof SendReq) {
+                insertUri = Telephony.Mms.Sent.CONTENT_URI;
+            } else if (pdu instanceof RetrieveConf ||
+                    pdu instanceof NotificationInd ||
+                    pdu instanceof DeliveryInd ||
+                    pdu instanceof ReadOrigInd) {
+                insertUri = Telephony.Mms.Inbox.CONTENT_URI;
+            }
+            if (insertUri == null) {
+                LogUtil.e("importMessage; invalid MMS type: " + pdu.getClass().getCanonicalName());
+                return null;
+            }
+            final PduPersister persister = PduPersister.getPduPersister(this);
+            final Uri uri = persister.persist(
+                    pdu,
+                    insertUri,
+                    true/*createThreadId*/,
+                    true/*groupMmsEnabled*/,
+                    null/*preOpenedFiles*/);
+            if (uri == null) {
+                LogUtil.e("importMessage: failed to persist message");
+                return null;
+            }
+            final ContentValues values = new ContentValues(5);
+            if (!TextUtils.isEmpty(messageId)) {
+                values.put(Telephony.Mms.MESSAGE_ID, messageId);
+            }
+            if (timestampSecs != -1) {
+                values.put(Telephony.Mms.DATE, timestampSecs);
+            }
+            values.put(Telephony.Mms.READ, seen ? 1 : 0);
+            values.put(Telephony.Mms.SEEN, read ? 1 : 0);
+            if (!TextUtils.isEmpty(creator)) {
+                values.put(Telephony.Mms.CREATOR, creator);
+            }
+            if (SqliteWrapper.update(this, getContentResolver(), uri, values,
+                    null/*where*/, null/*selectionArg*/) != 1) {
+                LogUtil.e("importMessage: failed to update message");
+            }
+            return uri;
+        } catch (RuntimeException e) {
+            LogUtil.e("importMessage: failed to parse input PDU", e);
+        } catch (MmsException e) {
+            LogUtil.e("importMessage: failed to persist message", e);
+        } finally {
+            Binder.restoreCallingIdentity(identity);
+        }
+        return null;
+    }
+
+    private static boolean isSmsMmsContentUri(Uri uri) {
+        final String uriString = uri.toString();
+        if (!uriString.startsWith("content://sms/") && !uriString.startsWith("content://mms/")) {
+            return false;
+        }
+        if (ContentUris.parseId(uri) == -1) {
+            return false;
+        }
+        return true;
+    }
+
+    private boolean updateMessageStatus(Uri messageUri, ContentValues statusValues) {
+        if (!isSmsMmsContentUri(messageUri)) {
+            LogUtil.e("updateMessageStatus: invalid messageUri: " + messageUri.toString());
+            return false;
+        }
+        if (statusValues == null) {
+            LogUtil.w("updateMessageStatus: empty values to update");
+            return false;
+        }
+        final ContentValues values = new ContentValues();
+        if (statusValues.containsKey(SmsManager.MESSAGE_STATUS_READ)) {
+            final Integer val = statusValues.getAsInteger(SmsManager.MESSAGE_STATUS_READ);
+            if (val != null) {
+                // MMS uses the same column name
+                values.put(Telephony.Sms.READ, val);
+            }
+        } else if (statusValues.containsKey(SmsManager.MESSAGE_STATUS_SEEN)) {
+            final Integer val = statusValues.getAsInteger(SmsManager.MESSAGE_STATUS_SEEN);
+            if (val != null) {
+                // MMS uses the same column name
+                values.put(Telephony.Sms.SEEN, val);
+            }
+        }
+        if (values.size() < 1) {
+            LogUtil.w("updateMessageStatus: no value to update");
+            return false;
+        }
+        // Clear the calling identity and query the database using the phone user id
+        // Otherwise the AppOps check in TelephonyProvider would complain about mismatch
+        // between the calling uid and the package uid
+        final long identity = Binder.clearCallingIdentity();
+        try {
+            if (getContentResolver().update(
+                    messageUri, values, null/*where*/, null/*selectionArgs*/) != 1) {
+                LogUtil.e("updateMessageStatus: failed to update database");
+                return false;
+            }
+            return true;
+        } catch (SQLiteException e) {
+            LogUtil.e("updateMessageStatus: failed to update database", e);
+        } finally {
+            Binder.restoreCallingIdentity(identity);
+        }
+        return false;
+    }
+
+    private static final String ARCHIVE_CONVERSATION_SELECTION = Telephony.Threads._ID + "=?";
+    private boolean archiveConversation(long conversationId, boolean archived) {
+        final ContentValues values = new ContentValues(1);
+        values.put(Telephony.Threads.ARCHIVED, archived ? 1 : 0);
+        // Clear the calling identity and query the database using the phone user id
+        // Otherwise the AppOps check in TelephonyProvider would complain about mismatch
+        // between the calling uid and the package uid
+        final long identity = Binder.clearCallingIdentity();
+        try {
+            if (getContentResolver().update(
+                    Telephony.Threads.CONTENT_URI,
+                    values,
+                    ARCHIVE_CONVERSATION_SELECTION,
+                    new String[] { Long.toString(conversationId)}) != 1) {
+                LogUtil.e("archiveConversation: failed to update database");
+                return false;
+            }
+            return true;
+        } catch (SQLiteException e) {
+            LogUtil.e("archiveConversation: failed to update database", e);
+        } finally {
+            Binder.restoreCallingIdentity(identity);
+        }
+        return false;
+    }
+
+    private Uri addSmsDraft(String address, String text, String creator) {
+        final ContentValues values = new ContentValues(5);
+        values.put(Telephony.Sms.ADDRESS, address);
+        values.put(Telephony.Sms.BODY, text);
+        values.put(Telephony.Sms.READ, 1);
+        values.put(Telephony.Sms.SEEN, 1);
+        if (!TextUtils.isEmpty(creator)) {
+            values.put(Telephony.Mms.CREATOR, creator);
+        }
+        // Clear the calling identity and query the database using the phone user id
+        // Otherwise the AppOps check in TelephonyProvider would complain about mismatch
+        // between the calling uid and the package uid
+        final long identity = Binder.clearCallingIdentity();
+        try {
+            return getContentResolver().insert(Telephony.Sms.Draft.CONTENT_URI, values);
+        } catch (SQLiteException e) {
+            LogUtil.e("addSmsDraft: failed to store draft message", e);
+        } finally {
+            Binder.restoreCallingIdentity(identity);
+        }
+        return null;
+    }
+
+    private Uri addMmsDraft(Uri contentUri, String creator) {
+        byte[] pduData = readPduFromContentUri(contentUri, MAX_MMS_FILE_SIZE);
+        if (pduData == null || pduData.length < 1) {
+            LogUtil.e("addMmsDraft: empty PDU");
+            return null;
+        }
+        // Clear the calling identity and query the database using the phone user id
+        // Otherwise the AppOps check in TelephonyProvider would complain about mismatch
+        // between the calling uid and the package uid
+        final long identity = Binder.clearCallingIdentity();
+        try {
+            final GenericPdu pdu = parsePduForAnyCarrier(pduData);
+            if (pdu == null) {
+                LogUtil.e("addMmsDraft: can't parse input PDU");
+                return null;
+            }
+            if (!(pdu instanceof SendReq)) {
+                LogUtil.e("addMmsDraft; invalid MMS type: " + pdu.getClass().getCanonicalName());
+                return null;
+            }
+            final PduPersister persister = PduPersister.getPduPersister(this);
+            final Uri uri = persister.persist(
+                    pdu,
+                    Telephony.Mms.Draft.CONTENT_URI,
+                    true/*createThreadId*/,
+                    true/*groupMmsEnabled*/,
+                    null/*preOpenedFiles*/);
+            if (uri == null) {
+                LogUtil.e("addMmsDraft: failed to persist message");
+                return null;
+            }
+            final ContentValues values = new ContentValues(3);
+            values.put(Telephony.Mms.READ, 1);
+            values.put(Telephony.Mms.SEEN, 1);
+            if (!TextUtils.isEmpty(creator)) {
+                values.put(Telephony.Mms.CREATOR, creator);
+            }
+            if (SqliteWrapper.update(this, getContentResolver(), uri, values,
+                    null/*where*/, null/*selectionArg*/) != 1) {
+                LogUtil.e("addMmsDraft: failed to update message");
+            }
+            return uri;
+        } catch (RuntimeException e) {
+            LogUtil.e("addMmsDraft: failed to parse input PDU", e);
+        } catch (MmsException e) {
+            LogUtil.e("addMmsDraft: failed to persist message", e);
+        } finally {
+            Binder.restoreCallingIdentity(identity);
+        }
+        return null;
+    }
+
+    /**
+     * Try parsing a PDU without knowing the carrier. This is useful for importing
+     * MMS or storing draft when carrier info is not available
+     *
+     * @param data The PDU data
+     * @return Parsed PDU, null if failed to parse
+     */
+    private static GenericPdu parsePduForAnyCarrier(final byte[] data) {
+        GenericPdu pdu = null;
+        try {
+            pdu = (new PduParser(data, true/*parseContentDisposition*/)).parse();
+        } catch (RuntimeException e) {
+            LogUtil.w("parsePduForAnyCarrier: Failed to parse PDU with content disposition", e);
+        }
+        if (pdu == null) {
+            try {
+                pdu = (new PduParser(data, false/*parseContentDisposition*/)).parse();
+            } catch (RuntimeException e) {
+                LogUtil.w("parsePduForAnyCarrier: Failed to parse PDU without content disposition",
+                        e);
+            }
+        }
+        return pdu;
+    }
+
+    @Override
+    public boolean getAutoPersistingPref() {
+        final SharedPreferences preferences = getSharedPreferences(
+                SHARED_PREFERENCES_NAME, MODE_PRIVATE);
+        return preferences.getBoolean(PREF_AUTO_PERSISTING, false);
+    }
+
+    /**
+     * Read pdu from content provider uri
+     * @param contentUri content provider uri from which to read
+     * @param maxSize maximum number of bytes to read
+     * @return pdu bytes if succeeded else null
+     */
+    public byte[] readPduFromContentUri(final Uri contentUri, final int maxSize) {
+        if (contentUri == null) {
+            return null;
+        }
+        Callable<byte[]> copyPduToArray = new Callable<byte[]>() {
+            public byte[] call() {
+                ParcelFileDescriptor.AutoCloseInputStream inStream = null;
+                try {
+                    ContentResolver cr = MmsService.this.getContentResolver();
+                    ParcelFileDescriptor pduFd = cr.openFileDescriptor(contentUri, "r");
+                    inStream = new ParcelFileDescriptor.AutoCloseInputStream(pduFd);
+                    // Request one extra byte to make sure file not bigger than maxSize
+                    byte[] tempBody = new byte[maxSize+1];
+                    int bytesRead = inStream.read(tempBody, 0, maxSize+1);
+                    if (bytesRead == 0) {
+                        LogUtil.e("Read empty PDU");
+                        return null;
+                    }
+                    if (bytesRead <= maxSize) {
+                        return Arrays.copyOf(tempBody, bytesRead);
+                    }
+                    LogUtil.e("PDU read is too large");
+                    return null;
+                } catch (IOException ex) {
+                    LogUtil.e("IO exception reading PDU", ex);
+                    return null;
+                } finally {
+                    if (inStream != null) {
+                        try {
+                            inStream.close();
+                        } catch (IOException ex) {
+                        }
+                    }
+                }
+            }
+        };
+
+        final Future<byte[]> pendingResult = mPduTransferExecutor.submit(copyPduToArray);
+        try {
+            return pendingResult.get(TASK_TIMEOUT_MS, TimeUnit.MILLISECONDS);
+        } catch (Exception e) {
+            // Typically a timeout occurred - cancel task
+            pendingResult.cancel(true);
+        }
+        return null;
+    }
+
+    /**
+     * Write pdu bytes to content provider uri
+     * @param contentUri content provider uri to which bytes should be written
+     * @param pdu Bytes to write
+     * @return true if all bytes successfully written else false
+     */
+    public boolean writePduToContentUri(final Uri contentUri, final byte[] pdu) {
+        if (contentUri == null || pdu == null) {
+            return false;
+        }
+        final Callable<Boolean> copyDownloadedPduToOutput = new Callable<Boolean>() {
+            public Boolean call() {
+                ParcelFileDescriptor.AutoCloseOutputStream outStream = null;
+                try {
+                    ContentResolver cr = MmsService.this.getContentResolver();
+                    ParcelFileDescriptor pduFd = cr.openFileDescriptor(contentUri, "w");
+                    outStream = new ParcelFileDescriptor.AutoCloseOutputStream(pduFd);
+                    outStream.write(pdu);
+                    return Boolean.TRUE;
+                } catch (IOException ex) {
+                    LogUtil.e("IO exception writing PDU", ex);
+                    return Boolean.FALSE;
+                } finally {
+                    if (outStream != null) {
+                        try {
+                            outStream.close();
+                        } catch (IOException ex) {
+                        }
+                    }
+                }
+            }
+        };
+
+        final Future<Boolean> pendingResult =
+                mPduTransferExecutor.submit(copyDownloadedPduToOutput);
+        try {
+            return pendingResult.get(TASK_TIMEOUT_MS, TimeUnit.MILLISECONDS);
+        } catch (Exception e) {
+            // Typically a timeout occurred - cancel task
+            pendingResult.cancel(true);
+        }
+        return false;
+    }
+}
Index: vendor/custom/cts/frameworks/opt/telephony/src/java/com/android/internal/telephony/InboundSmsHandler.java
===================================================================
--- vendor/custom/cts/frameworks/opt/telephony/src/java/com/android/internal/telephony/InboundSmsHandler.java	(revision 0)
+++ vendor/custom/cts/frameworks/opt/telephony/src/java/com/android/internal/telephony/InboundSmsHandler.java	(revision 173004)
@@ -0,0 +1,1565 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static android.telephony.TelephonyManager.PHONE_TYPE_CDMA;
+import static android.service.carrier.CarrierMessagingService.RECEIVE_OPTIONS_SKIP_NOTIFY_WHEN_CREDENTIAL_PROTECTED_STORAGE_UNAVAILABLE;
+
+import android.app.Activity;
+import android.app.ActivityManagerNative;
+import android.app.AppOpsManager;
+import android.app.BroadcastOptions;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.PendingIntent.CanceledException;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.pm.UserInfo;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.net.Uri;
+import android.os.storage.StorageManager;
+import android.os.AsyncResult;
+import android.os.Binder;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.IDeviceIdleController;
+import android.os.Message;
+import android.os.PowerManager;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.provider.Telephony;
+import android.provider.Telephony.Sms.Intents;
+import android.service.carrier.CarrierMessagingService;
+import android.service.carrier.ICarrierMessagingCallback;
+import android.service.carrier.ICarrierMessagingService;
+import android.service.carrier.MessagePdu;
+import android.service.notification.StatusBarNotification;
+import android.telephony.CarrierMessagingServiceManager;
+import android.telephony.Rlog;
+import android.telephony.SmsManager;
+import android.telephony.SmsMessage;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+
+import com.android.internal.R;
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.telephony.uicc.UiccCard;
+import com.android.internal.telephony.uicc.UiccController;
+import com.android.internal.util.HexDump;
+import com.android.internal.util.State;
+import com.android.internal.util.StateMachine;
+
+import java.io.ByteArrayOutputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import com.android.internal.telephony.plugin.BlockInboundSmsHandlerUtils;
+
+/**
+ * This class broadcasts incoming SMS messages to interested apps after storing them in
+ * the SmsProvider "raw" table and ACKing them to the SMSC. After each message has been
+ * broadcast, its parts are removed from the raw table. If the device crashes after ACKing
+ * but before the broadcast completes, the pending messages will be rebroadcast on the next boot.
+ *
+ * <p>The state machine starts in {@link IdleState} state. When the {@link SMSDispatcher} receives a
+ * new SMS from the radio, it calls {@link #dispatchNormalMessage},
+ * which sends a message to the state machine, causing the wakelock to be acquired in
+ * {@link #haltedProcessMessage}, which transitions to {@link DeliveringState} state, where the message
+ * is saved to the raw table, then acknowledged via the {@link SMSDispatcher} which called us.
+ *
+ * <p>After saving the SMS, if the message is complete (either single-part or the final segment
+ * of a multi-part SMS), we broadcast the completed PDUs as an ordered broadcast, then transition to
+ * {@link WaitingState} state to wait for the broadcast to complete. When the local
+ * {@link BroadcastReceiver} is called with the result, it sends {@link #EVENT_BROADCAST_COMPLETE}
+ * to the state machine, causing us to either broadcast the next pending message (if one has
+ * arrived while waiting for the broadcast to complete), or to transition back to the halted state
+ * after all messages are processed. Then the wakelock is released and we wait for the next SMS.
+ */
+public abstract class InboundSmsHandler extends StateMachine {
+    protected static final boolean DBG = true;
+    private static final boolean VDBG = false; // STOPSHIP if true, logs user data
+
+    /** Query projection for checking for duplicate message segments. */
+    private static final String[] PDU_PROJECTION = {
+            "pdu"
+    };
+
+    /** Query projection for combining concatenated message segments. */
+    private static final String[] PDU_SEQUENCE_PORT_PROJECTION = {
+            "pdu",
+            "sequence",
+            "destination_port"
+    };
+
+    public static final int PDU_COLUMN = 0;
+    public static final int SEQUENCE_COLUMN = 1;
+    public static final int DESTINATION_PORT_COLUMN = 2;
+    public static final int DATE_COLUMN = 3;
+    public static final int REFERENCE_NUMBER_COLUMN = 4;
+    public static final int COUNT_COLUMN = 5;
+    public static final int ADDRESS_COLUMN = 6;
+    public static final int ID_COLUMN = 7;
+    public static final int MESSAGE_BODY_COLUMN = 8;
+
+    public static final String SELECT_BY_ID = "_id=?";
+    public static final String SELECT_BY_REFERENCE = "address=? AND reference_number=? AND " +
+            "count=? AND deleted=0";
+
+    /** New SMS received as an AsyncResult. */
+    public static final int EVENT_NEW_SMS = 1;
+
+    /** Message type containing a {@link InboundSmsTracker} ready to broadcast to listeners. */
+    public static final int EVENT_BROADCAST_SMS = 2;
+
+    /** Message from resultReceiver notifying {@link WaitingState} of a completed broadcast. */
+    private static final int EVENT_BROADCAST_COMPLETE = 3;
+
+    /** Sent on exit from {@link WaitingState} to return to idle after sending all broadcasts. */
+    private static final int EVENT_RETURN_TO_IDLE = 4;
+
+    /** Release wakelock after a short timeout when returning to idle state. */
+    private static final int EVENT_RELEASE_WAKELOCK = 5;
+
+    /** Sent by {@link SmsBroadcastUndelivered} after cleaning the raw table. */
+    public static final int EVENT_START_ACCEPTING_SMS = 6;
+
+    /** Update phone object */
+    private static final int EVENT_UPDATE_PHONE_OBJECT = 7;
+
+    /** New SMS received as an AsyncResult. */
+    public static final int EVENT_INJECT_SMS = 8;
+
+    /** Wakelock release delay when returning to idle state. */
+    private static final int WAKELOCK_TIMEOUT = 3000;
+
+    // The notitfication tag used when showing a notification. The combination of notification tag
+    // and notification id should be unique within the phone app.
+    private static final String NOTIFICATION_TAG = "InboundSmsHandler";
+    private static final int NOTIFICATION_ID_NEW_MESSAGE = 1;
+
+    /** URI for raw table of SMS provider. */
+    protected static final Uri sRawUri = Uri.withAppendedPath(Telephony.Sms.CONTENT_URI, "raw");
+    protected static final Uri sRawUriPermanentDelete =
+            Uri.withAppendedPath(Telephony.Sms.CONTENT_URI, "raw/permanentDelete");
+
+    protected final Context mContext;
+    private final ContentResolver mResolver;
+
+    /** Special handler for WAP push messages. */
+    private final WapPushOverSms mWapPush;
+
+    /** Wake lock to ensure device stays awake while dispatching the SMS intents. */
+    private final PowerManager.WakeLock mWakeLock;
+
+    /** DefaultState throws an exception or logs an error for unhandled message types. */
+    private final DefaultState mDefaultState = new DefaultState();
+
+    /** Startup state. Waiting for {@link SmsBroadcastUndelivered} to complete. */
+    private final StartupState mStartupState = new StartupState();
+
+    /** Idle state. Waiting for messages to process. */
+    private final IdleState mIdleState = new IdleState();
+
+    /** Delivering state. Saves the PDU in the raw table and acknowledges to SMSC. */
+    private final DeliveringState mDeliveringState = new DeliveringState();
+
+    /** Broadcasting state. Waits for current broadcast to complete before delivering next. */
+    private final WaitingState mWaitingState = new WaitingState();
+
+    /** Helper class to check whether storage is available for incoming messages. */
+    protected SmsStorageMonitor mStorageMonitor;
+
+    private final boolean mSmsReceiveDisabled;
+
+    protected Phone mPhone;
+
+    protected CellBroadcastHandler mCellBroadcastHandler;
+
+    private UserManager mUserManager;
+
+    IDeviceIdleController mDeviceIdleController;
+
+    // Delete permanently from raw table
+    private final int DELETE_PERMANENTLY = 1;
+    // Only mark deleted, but keep in db for message de-duping
+    private final int MARK_DELETED = 2;
+    private static int MARK_SMS_BLOCK_TYPE = 2;
+
+    /**
+     * Create a new SMS broadcast helper.
+     * @param name the class name for logging
+     * @param context the context of the phone app
+     * @param storageMonitor the SmsStorageMonitor to check for storage availability
+     */
+    protected InboundSmsHandler(String name, Context context, SmsStorageMonitor storageMonitor,
+            Phone phone, CellBroadcastHandler cellBroadcastHandler) {
+        super(name);
+
+        mContext = context;
+        mStorageMonitor = storageMonitor;
+        mPhone = phone;
+        mCellBroadcastHandler = cellBroadcastHandler;
+        mResolver = context.getContentResolver();
+        mWapPush = new WapPushOverSms(context);
+
+        boolean smsCapable = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_sms_capable);
+        mSmsReceiveDisabled = !TelephonyManager.from(mContext).getSmsReceiveCapableForPhone(
+                mPhone.getPhoneId(), smsCapable);
+
+        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
+        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, name);
+        mWakeLock.acquire();    // wake lock released after we enter idle state
+        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
+        mDeviceIdleController = TelephonyComponentFactory.getInstance().getIDeviceIdleController();
+
+        addState(mDefaultState);
+        addState(mStartupState, mDefaultState);
+        addState(mIdleState, mDefaultState);
+        addState(mDeliveringState, mDefaultState);
+            addState(mWaitingState, mDeliveringState);
+
+        setInitialState(mStartupState);
+        if (DBG) log("created InboundSmsHandler");
+    }
+
+    /**
+     * Tell the state machine to quit after processing all messages.
+     */
+    public void dispose() {
+        quit();
+    }
+
+    /**
+     * Update the phone object when it changes.
+     */
+    public void updatePhoneObject(Phone phone) {
+        sendMessage(EVENT_UPDATE_PHONE_OBJECT, phone);
+    }
+
+    /**
+     * Dispose of the WAP push object and release the wakelock.
+     */
+    @Override
+    protected void onQuitting() {
+        mWapPush.dispose();
+
+        while (mWakeLock.isHeld()) {
+            mWakeLock.release();
+        }
+    }
+
+    // CAF_MSIM Is this used anywhere ? if not remove it
+    public Phone getPhone() {
+        return mPhone;
+    }
+
+    /**
+     * This parent state throws an exception (for debug builds) or prints an error for unhandled
+     * message types.
+     */
+    private class DefaultState extends State {
+        @Override
+        public boolean processMessage(Message msg) {
+            switch (msg.what) {
+                case EVENT_UPDATE_PHONE_OBJECT: {
+                    onUpdatePhoneObject((Phone) msg.obj);
+                    break;
+                }
+                default: {
+                    String errorText = "processMessage: unhandled message type " + msg.what +
+                        " currState=" + getCurrentState().getName();
+                    if (Build.IS_DEBUGGABLE) {
+                        loge("---- Dumping InboundSmsHandler ----");
+                        loge("Total records=" + getLogRecCount());
+                        for (int i = Math.max(getLogRecSize() - 20, 0); i < getLogRecSize(); i++) {
+                            loge("Rec[%d]: %s\n" + i + getLogRec(i).toString());
+                        }
+                        loge("---- Dumped InboundSmsHandler ----");
+
+                        throw new RuntimeException(errorText);
+                    } else {
+                        loge(errorText);
+                    }
+                    break;
+                }
+            }
+            return HANDLED;
+        }
+    }
+
+    /**
+     * The Startup state waits for {@link SmsBroadcastUndelivered} to process the raw table and
+     * notify the state machine to broadcast any complete PDUs that might not have been broadcast.
+     */
+    private class StartupState extends State {
+        @Override
+        public boolean processMessage(Message msg) {
+            log("StartupState.processMessage:" + msg.what);
+            switch (msg.what) {
+                case EVENT_NEW_SMS:
+                case EVENT_INJECT_SMS:
+                case EVENT_BROADCAST_SMS:
+                    deferMessage(msg);
+                    return HANDLED;
+
+                case EVENT_START_ACCEPTING_SMS:
+                    transitionTo(mIdleState);
+                    return HANDLED;
+
+                case EVENT_BROADCAST_COMPLETE:
+                case EVENT_RETURN_TO_IDLE:
+                case EVENT_RELEASE_WAKELOCK:
+                default:
+                    // let DefaultState handle these unexpected message types
+                    return NOT_HANDLED;
+            }
+        }
+    }
+
+    /**
+     * In the idle state the wakelock is released until a new SM arrives, then we transition
+     * to Delivering mode to handle it, acquiring the wakelock on exit.
+     */
+    private class IdleState extends State {
+        @Override
+        public void enter() {
+            if (DBG) log("entering Idle state");
+            sendMessageDelayed(EVENT_RELEASE_WAKELOCK, WAKELOCK_TIMEOUT);
+        }
+
+        @Override
+        public void exit() {
+            mWakeLock.acquire();
+            if (DBG) log("acquired wakelock, leaving Idle state");
+        }
+
+        @Override
+        public boolean processMessage(Message msg) {
+            log("IdleState.processMessage:" + msg.what);
+            if (DBG) log("Idle state processing message type " + msg.what);
+            switch (msg.what) {
+                case EVENT_NEW_SMS:
+                case EVENT_INJECT_SMS:
+                case EVENT_BROADCAST_SMS:
+                    deferMessage(msg);
+                    transitionTo(mDeliveringState);
+                    return HANDLED;
+
+                case EVENT_RELEASE_WAKELOCK:
+                    mWakeLock.release();
+                    if (DBG) {
+                        if (mWakeLock.isHeld()) {
+                            // this is okay as long as we call release() for every acquire()
+                            log("mWakeLock is still held after release");
+                        } else {
+                            log("mWakeLock released");
+                        }
+                    }
+                    return HANDLED;
+
+                case EVENT_RETURN_TO_IDLE:
+                    // already in idle state; ignore
+                    return HANDLED;
+
+                case EVENT_BROADCAST_COMPLETE:
+                case EVENT_START_ACCEPTING_SMS:
+                default:
+                    // let DefaultState handle these unexpected message types
+                    return NOT_HANDLED;
+            }
+        }
+    }
+
+    /**
+     * In the delivering state, the inbound SMS is processed and stored in the raw table.
+     * The message is acknowledged before we exit this state. If there is a message to broadcast,
+     * transition to {@link WaitingState} state to send the ordered broadcast and wait for the
+     * results. When all messages have been processed, the halting state will release the wakelock.
+     */
+    private class DeliveringState extends State {
+        @Override
+        public void enter() {
+            if (DBG) log("entering Delivering state");
+        }
+
+        @Override
+        public void exit() {
+            if (DBG) log("leaving Delivering state");
+        }
+
+        @Override
+        public boolean processMessage(Message msg) {
+            log("DeliveringState.processMessage:" + msg.what);
+            switch (msg.what) {
+                case EVENT_NEW_SMS:
+                    // handle new SMS from RIL
+                    handleNewSms((AsyncResult) msg.obj);
+                    sendMessage(EVENT_RETURN_TO_IDLE);
+                    return HANDLED;
+
+                case EVENT_INJECT_SMS:
+                    // handle new injected SMS
+                    handleInjectSms((AsyncResult) msg.obj);
+                    sendMessage(EVENT_RETURN_TO_IDLE);
+                    return HANDLED;
+
+                case EVENT_BROADCAST_SMS:
+                    // if any broadcasts were sent, transition to waiting state
+                    InboundSmsTracker inboundSmsTracker = (InboundSmsTracker) msg.obj;
+                    if (processMessagePart(inboundSmsTracker)) {
+                        transitionTo(mWaitingState);
+                    } else {
+                        // if event is sent from SmsBroadcastUndelivered.broadcastSms(), and
+                        // processMessagePart() returns false, the state machine will be stuck in
+                        // DeliveringState until next message is received. Send message to
+                        // transition to idle to avoid that so that wakelock can be released
+                        log("No broadcast sent on processing EVENT_BROADCAST_SMS in Delivering " +
+                                "state. Return to Idle state");
+                        sendMessage(EVENT_RETURN_TO_IDLE);
+                    }
+                    return HANDLED;
+
+                case EVENT_RETURN_TO_IDLE:
+                    // return to idle after processing all other messages
+                    transitionTo(mIdleState);
+                    return HANDLED;
+
+                case EVENT_RELEASE_WAKELOCK:
+                    mWakeLock.release();    // decrement wakelock from previous entry to Idle
+                    if (!mWakeLock.isHeld()) {
+                        // wakelock should still be held until 3 seconds after we enter Idle
+                        loge("mWakeLock released while delivering/broadcasting!");
+                    }
+                    return HANDLED;
+
+                // we shouldn't get this message type in this state, log error and halt.
+                case EVENT_BROADCAST_COMPLETE:
+                case EVENT_START_ACCEPTING_SMS:
+                default:
+                    // let DefaultState handle these unexpected message types
+                    return NOT_HANDLED;
+            }
+        }
+    }
+
+    /**
+     * The waiting state delegates handling of new SMS to parent {@link DeliveringState}, but
+     * defers handling of the {@link #EVENT_BROADCAST_SMS} phase until after the current
+     * result receiver sends {@link #EVENT_BROADCAST_COMPLETE}. Before transitioning to
+     * {@link DeliveringState}, {@link #EVENT_RETURN_TO_IDLE} is sent to transition to
+     * {@link IdleState} after any deferred {@link #EVENT_BROADCAST_SMS} messages are handled.
+     */
+    private class WaitingState extends State {
+        @Override
+        public boolean processMessage(Message msg) {
+            log("WaitingState.processMessage:" + msg.what);
+            switch (msg.what) {
+                case EVENT_BROADCAST_SMS:
+                    // defer until the current broadcast completes
+                    deferMessage(msg);
+                    return HANDLED;
+
+                case EVENT_BROADCAST_COMPLETE:
+                    // return to idle after handling all deferred messages
+                    sendMessage(EVENT_RETURN_TO_IDLE);
+                    transitionTo(mDeliveringState);
+                    return HANDLED;
+
+                case EVENT_RETURN_TO_IDLE:
+                    // not ready to return to idle; ignore
+                    return HANDLED;
+
+                default:
+                    // parent state handles the other message types
+                    return NOT_HANDLED;
+            }
+        }
+    }
+
+    private void handleNewSms(AsyncResult ar) {
+        if (ar.exception != null) {
+            loge("Exception processing incoming SMS: " + ar.exception);
+            return;
+        }
+
+        int result;
+        try {
+            SmsMessage sms = (SmsMessage) ar.result;
+            result = dispatchMessage(sms.mWrappedSmsMessage);
+        } catch (RuntimeException ex) {
+            loge("Exception dispatching message", ex);
+            result = Intents.RESULT_SMS_GENERIC_ERROR;
+        }
+
+        // RESULT_OK means that the SMS will be acknowledged by special handling,
+        // e.g. for SMS-PP data download. Any other result, we should ack here.
+        if (result != Activity.RESULT_OK) {
+            boolean handled = (result == Intents.RESULT_SMS_HANDLED);
+            // Add for Vowifi SMS begin
+            boolean isFromVowifi = false;
+            try{
+                  if (ar.userObj !=null){
+                      String auth = (String)ar.userObj;
+                      if ("fromVowifi".equals(auth)){
+                           isFromVowifi = true;
+                      }
+                 }
+            }catch(Exception ex){
+                 loge("GsmSMSDispatcher ar.user convert error", ex);
+            }
+
+            log("isFromVowifi:"+isFromVowifi);
+
+            if(isFromVowifi){
+                 Message message = obtainMessage(0, "fromVowifi");
+                 notifyAndAcknowledgeLastIncomingSms(handled, result, message);
+            } else {
+                notifyAndAcknowledgeLastIncomingSms(handled, result, null);
+            }
+            // Add for Vowifi SMS end
+        }
+    }
+
+    /**
+     * This method is called when a new SMS PDU is injected into application framework.
+     * @param ar is the AsyncResult that has the SMS PDU to be injected.
+     */
+    private void handleInjectSms(AsyncResult ar) {
+        int result;
+        PendingIntent receivedIntent = null;
+        try {
+            receivedIntent = (PendingIntent) ar.userObj;
+            SmsMessage sms = (SmsMessage) ar.result;
+            if (sms == null) {
+              result = Intents.RESULT_SMS_GENERIC_ERROR;
+            } else {
+              result = dispatchMessage(sms.mWrappedSmsMessage);
+            }
+        } catch (RuntimeException ex) {
+            loge("Exception dispatching message", ex);
+            result = Intents.RESULT_SMS_GENERIC_ERROR;
+        }
+
+        if (receivedIntent != null) {
+            try {
+                receivedIntent.send(result);
+            } catch (CanceledException e) { }
+        }
+    }
+
+    /**
+     * Process an SMS message from the RIL, calling subclass methods to handle 3GPP and
+     * 3GPP2-specific message types.
+     *
+     * @param smsb the SmsMessageBase object from the RIL
+     * @return a result code from {@link android.provider.Telephony.Sms.Intents},
+     *  or {@link Activity#RESULT_OK} for delayed acknowledgment to SMSC
+     */
+    private int dispatchMessage(SmsMessageBase smsb) {
+        // If sms is null, there was a parsing error.
+        if (smsb == null) {
+            loge("dispatchSmsMessage: message is null");
+            return Intents.RESULT_SMS_GENERIC_ERROR;
+        }
+
+        if (mSmsReceiveDisabled) {
+            // Device doesn't support receiving SMS,
+            log("Received short message on device which doesn't support "
+                    + "receiving SMS. Ignored.");
+            return Intents.RESULT_SMS_HANDLED;
+        }
+
+        // onlyCore indicates if the device is in cryptkeeper
+        boolean onlyCore = false;
+        try {
+            onlyCore = IPackageManager.Stub.asInterface(ServiceManager.getService("package")).
+                    isOnlyCoreApps();
+        } catch (RemoteException e) {
+        }
+        if (onlyCore) {
+            // Device is unable to receive SMS in encrypted state
+            log("Received a short message in encrypted state. Rejecting.");
+            return Intents.RESULT_SMS_GENERIC_ERROR;
+        }
+
+        return dispatchMessageRadioSpecific(smsb);
+    }
+
+    /**
+     * Process voicemail notification, SMS-PP data download, CDMA CMAS, CDMA WAP push, and other
+     * 3GPP/3GPP2-specific messages. Regular SMS messages are handled by calling the shared
+     * {@link #dispatchNormalMessage} from this class.
+     *
+     * @param smsb the SmsMessageBase object from the RIL
+     * @return a result code from {@link android.provider.Telephony.Sms.Intents},
+     *  or {@link Activity#RESULT_OK} for delayed acknowledgment to SMSC
+     */
+    protected abstract int dispatchMessageRadioSpecific(SmsMessageBase smsb);
+
+    /**
+     * Send an acknowledge message to the SMSC.
+     * @param success indicates that last message was successfully received.
+     * @param result result code indicating any error
+     * @param response callback message sent when operation completes.
+     */
+    protected abstract void acknowledgeLastIncomingSms(boolean success,
+            int result, Message response);
+
+    /**
+     * Called when the phone changes the default method updates mPhone
+     * mStorageMonitor and mCellBroadcastHandler.updatePhoneObject.
+     * Override if different or other behavior is desired.
+     *
+     * @param phone
+     */
+    protected void onUpdatePhoneObject(Phone phone) {
+        mPhone = phone;
+        mStorageMonitor = mPhone.mSmsStorageMonitor;
+        log("onUpdatePhoneObject: phone=" + mPhone.getClass().getSimpleName());
+    }
+
+    /**
+     * Notify interested apps if the framework has rejected an incoming SMS,
+     * and send an acknowledge message to the network.
+     * @param success indicates that last message was successfully received.
+     * @param result result code indicating any error
+     * @param response callback message sent when operation completes.
+     */
+    private void notifyAndAcknowledgeLastIncomingSms(boolean success,
+            int result, Message response) {
+        if (!success) {
+            // broadcast SMS_REJECTED_ACTION intent
+            Intent intent = new Intent(Intents.SMS_REJECTED_ACTION);
+            intent.putExtra("result", result);
+            mContext.sendBroadcast(intent, android.Manifest.permission.RECEIVE_SMS);
+        }
+        acknowledgeLastIncomingSms(success, result, response);
+    }
+
+    /**
+     * Return true if this handler is for 3GPP2 messages; false for 3GPP format.
+     * @return true for the 3GPP2 handler; false for the 3GPP handler
+     */
+    protected abstract boolean is3gpp2();
+
+    /**
+     * Dispatch a normal incoming SMS. This is called from {@link #dispatchMessageRadioSpecific}
+     * if no format-specific handling was required. Saves the PDU to the SMS provider raw table,
+     * creates an {@link InboundSmsTracker}, then sends it to the state machine as an
+     * {@link #EVENT_BROADCAST_SMS}. Returns {@link Intents#RESULT_SMS_HANDLED} or an error value.
+     *
+     * @param sms the message to dispatch
+     * @return {@link Intents#RESULT_SMS_HANDLED} if the message was accepted, or an error status
+     */
+    protected int dispatchNormalMessage(SmsMessageBase sms) {
+        SmsHeader smsHeader = sms.getUserDataHeader();
+        InboundSmsTracker tracker;
+
+        if ((smsHeader == null) || (smsHeader.concatRef == null)) {
+            // Message is not concatenated.
+            int destPort = -1;
+            if (smsHeader != null && smsHeader.portAddrs != null) {
+                // The message was sent to a port.
+                destPort = smsHeader.portAddrs.destPort;
+                if (DBG) log("destination port: " + destPort);
+            }
+
+            tracker = TelephonyComponentFactory.getInstance().makeInboundSmsTracker(sms.getPdu(),
+                    sms.getTimestampMillis(), destPort, is3gpp2(), false,
+                    sms.getDisplayOriginatingAddress(), sms.getMessageBody());
+        } else {
+            // Create a tracker for this message segment.
+            SmsHeader.ConcatRef concatRef = smsHeader.concatRef;
+            SmsHeader.PortAddrs portAddrs = smsHeader.portAddrs;
+            int destPort = (portAddrs != null ? portAddrs.destPort : -1);
+
+            tracker = TelephonyComponentFactory.getInstance().makeInboundSmsTracker(sms.getPdu(),
+                    sms.getTimestampMillis(), destPort, is3gpp2(),
+                    sms.getDisplayOriginatingAddress(), concatRef.refNumber, concatRef.seqNumber,
+                    concatRef.msgCount, false, sms.getMessageBody());
+        }
+
+        if (VDBG) log("created tracker: " + tracker);
+
+        // de-duping is done only for text messages
+        // destPort = -1 indicates text messages, otherwise it's a data sms
+        return addTrackerToRawTableAndSendMessage(tracker,
+                tracker.getDestPort() == -1 /* de-dup if text message */);
+    }
+
+    /**
+     * Helper to add the tracker to the raw table and then send a message to broadcast it, if
+     * successful. Returns the SMS intent status to return to the SMSC.
+     * @param tracker the tracker to save to the raw table and then deliver
+     * @return {@link Intents#RESULT_SMS_HANDLED} or {@link Intents#RESULT_SMS_GENERIC_ERROR}
+     * or {@link Intents#RESULT_SMS_DUPLICATED}
+     */
+    protected int addTrackerToRawTableAndSendMessage(InboundSmsTracker tracker, boolean deDup) {
+        switch(addTrackerToRawTable(tracker, deDup)) {
+        case Intents.RESULT_SMS_HANDLED:
+            sendMessage(EVENT_BROADCAST_SMS, tracker);
+            return Intents.RESULT_SMS_HANDLED;
+
+        case Intents.RESULT_SMS_DUPLICATED:
+            return Intents.RESULT_SMS_HANDLED;
+
+        case Intents.RESULT_SMS_GENERIC_ERROR:
+        default:
+            return Intents.RESULT_SMS_GENERIC_ERROR;
+        }
+    }
+
+    /**
+     * Process the inbound SMS segment. If the message is complete, send it as an ordered
+     * broadcast to interested receivers and return true. If the message is a segment of an
+     * incomplete multi-part SMS, return false.
+     * @param tracker the tracker containing the message segment to process
+     * @return true if an ordered broadcast was sent; false if waiting for more message segments
+     */
+    private boolean processMessagePart(InboundSmsTracker tracker) {
+        int messageCount = tracker.getMessageCount();
+        byte[][] pdus;
+        int destPort = tracker.getDestPort();
+
+        if (messageCount == 1) {
+            // single-part message
+            pdus = new byte[][]{tracker.getPdu()};
+        } else {
+            // multi-part message
+            Cursor cursor = null;
+            try {
+                // used by several query selection arguments
+                String address = tracker.getAddress();
+                String refNumber = Integer.toString(tracker.getReferenceNumber());
+                String count = Integer.toString(tracker.getMessageCount());
+
+                // query for all segments and broadcast message if we have all the parts
+                String[] whereArgs = {address, refNumber, count};
+                cursor = mResolver.query(sRawUri, PDU_SEQUENCE_PORT_PROJECTION,
+                        SELECT_BY_REFERENCE, whereArgs, null);
+
+                int cursorCount = cursor.getCount();
+                if (cursorCount < messageCount) {
+                    // Wait for the other message parts to arrive. It's also possible for the last
+                    // segment to arrive before processing the EVENT_BROADCAST_SMS for one of the
+                    // earlier segments. In that case, the broadcast will be sent as soon as all
+                    // segments are in the table, and any later EVENT_BROADCAST_SMS messages will
+                    // get a row count of 0 and return.
+                    return false;
+                }
+
+                // All the parts are in place, deal with them
+                pdus = new byte[messageCount][];
+                while (cursor.moveToNext()) {
+                    // subtract offset to convert sequence to 0-based array index
+                    int index = cursor.getInt(SEQUENCE_COLUMN) - tracker.getIndexOffset();
+
+                    pdus[index] = HexDump.hexStringToByteArray(cursor.getString(PDU_COLUMN));
+
+                    // Read the destination port from the first segment (needed for CDMA WAP PDU).
+                    // It's not a bad idea to prefer the port from the first segment in other cases.
+                    if (index == 0 && !cursor.isNull(DESTINATION_PORT_COLUMN)) {
+                        int port = cursor.getInt(DESTINATION_PORT_COLUMN);
+                        // strip format flags and convert to real port number, or -1
+                        port = InboundSmsTracker.getRealDestPort(port);
+                        if (port != -1) {
+                            destPort = port;
+                        }
+                    }
+                }
+            } catch (SQLException e) {
+                loge("Can't access multipart SMS database", e);
+                return false;
+            } finally {
+                if (cursor != null) {
+                    cursor.close();
+                }
+            }
+        }
+
+        // Do not process null pdu(s). Check for that and return false in that case.
+        List<byte[]> pduList = Arrays.asList(pdus);
+        if (pduList.size() == 0 || pduList.contains(null)) {
+            loge("processMessagePart: returning false due to " +
+                    (pduList.size() == 0 ? "pduList.size() == 0" : "pduList.contains(null)"));
+            return false;
+        }
+
+        if (!mUserManager.isUserUnlocked()) {
+            return processMessagePartWithUserLocked(tracker, pdus, destPort);
+        }
+
+        SmsBroadcastReceiver resultReceiver = new SmsBroadcastReceiver(tracker);
+
+        if (destPort == SmsHeader.PORT_WAP_PUSH) {
+            // Build up the data stream
+            ByteArrayOutputStream output = new ByteArrayOutputStream();
+            for (byte[] pdu : pdus) {
+                // 3GPP needs to extract the User Data from the PDU; 3GPP2 has already done this
+                if (!tracker.is3gpp2()) {
+                    SmsMessage msg = SmsMessage.createFromPdu(pdu, SmsConstants.FORMAT_3GPP);
+                    if (msg != null) {
+                        pdu = msg.getUserData();
+                    } else {
+                        loge("processMessagePart: SmsMessage.createFromPdu returned null");
+                        return false;
+                    }
+                }
+                output.write(pdu, 0, pdu.length);
+            }
+//            int result = mWapPush.dispatchWapPdu(output.toByteArray(), resultReceiver, this);
+            int result = mWapPush.dispatchWapPdu(output.toByteArray(), resultReceiver, this , pdus);
+            if (DBG) log("dispatchWapPdu() returned " + result);
+            // result is Activity.RESULT_OK if an ordered broadcast was sent
+            if (result == Activity.RESULT_OK) {
+                return true;
+            } else {
+                deleteFromRawTable(tracker.getDeleteWhere(), tracker.getDeleteWhereArgs(),
+                        MARK_DELETED);
+                return false;
+            }
+        }
+
+        /* SPRD: modify for CallFireWall @{*/
+        int blocktype = MARK_SMS_BLOCK_TYPE;
+        if (BlockChecker.isBlocked(mContext, tracker.getAddress(), blocktype)) {
+            Intent intent = new Intent("android.provider.Telephony.SMS_FILTER");
+            intent.putExtra("pdus", pdus);
+            intent.putExtra("format", tracker.getFormat());
+            BlockInboundSmsHandlerUtils.getInstance(mContext).
+                    blockSms(tracker.getAddress(), intent);
+                deleteFromRawTable(tracker.getDeleteWhere(), tracker.getDeleteWhereArgs(),
+                        DELETE_PERMANENTLY);
+            return false;
+        }
+        /* @} */
+
+        boolean carrierAppInvoked = filterSmsWithCarrierOrSystemApp(
+            pdus, destPort, tracker, resultReceiver, true /* userUnlocked */);
+
+        if (!carrierAppInvoked) {
+            dispatchSmsDeliveryIntent(pdus, tracker.getFormat(), destPort, resultReceiver);
+        }
+
+        return true;
+    }
+
+    /**
+     * Processes the message part while the credential-encrypted storage is still locked.
+     *
+     * <p>If the message is a regular MMS, show a new message notification. If the message is a
+     * SMS, ask the carrier app to filter it and show the new message notification if the carrier
+     * app asks to keep the message.
+     *
+     * @return true if an ordered broadcast was sent to the carrier app; false otherwise.
+     */
+    private boolean processMessagePartWithUserLocked(InboundSmsTracker tracker,
+            byte[][] pdus, int destPort) {
+        log("Credential-encrypted storage not available. Port: " + destPort);
+        if (destPort == SmsHeader.PORT_WAP_PUSH && mWapPush.isWapPushForMms(pdus[0], this)) {
+            showNewMessageNotification();
+            return false;
+        }
+        if (destPort == -1) {
+            // This is a regular SMS - hand it to the carrier or system app for filtering.
+            boolean carrierAppInvoked = filterSmsWithCarrierOrSystemApp(
+                pdus, destPort, tracker, null, false /* userUnlocked */);
+            if (carrierAppInvoked) {
+                // Carrier app invoked, wait for it to return the result.
+                return true;
+            } else {
+                // Carrier app not invoked, show the notification and do nothing further.
+                showNewMessageNotification();
+                return false;
+            }
+        }
+        return false;
+    }
+
+    private void showNewMessageNotification() {
+        // Do not show the notification on non-FBE devices.
+        if (!StorageManager.isFileEncryptedNativeOrEmulated()) {
+            return;
+        }
+        log("Show new message notification.");
+        Intent intent = Intent.makeMainSelectorActivity(
+            Intent.ACTION_MAIN, Intent.CATEGORY_APP_MESSAGING);
+        Notification.Builder mBuilder = new Notification.Builder(mContext)
+                .setSmallIcon(com.android.internal.R.drawable.sym_action_chat)
+                .setAutoCancel(true)
+                .setVisibility(Notification.VISIBILITY_PUBLIC)
+                .setDefaults(Notification.DEFAULT_ALL)
+                .setContentTitle(mContext.getString(R.string.new_sms_notification_title))
+                .setContentText(mContext.getString(R.string.new_sms_notification_content))
+                .setContentIntent(PendingIntent.getActivity(mContext, 1, intent, 0));
+        NotificationManager mNotificationManager =
+            (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
+        mNotificationManager.notify(
+                NOTIFICATION_TAG, NOTIFICATION_ID_NEW_MESSAGE, mBuilder.build());
+    }
+
+    static void cancelNewMessageNotification(Context context) {
+        NotificationManager mNotificationManager =
+            (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+        mNotificationManager.cancel(InboundSmsHandler.NOTIFICATION_TAG,
+            InboundSmsHandler.NOTIFICATION_ID_NEW_MESSAGE);
+    }
+
+    /**
+     * Filters the SMS with carrier or system app.
+     * @return true if the carrier or system app is invoked, false otherwise.
+     */
+    private boolean filterSmsWithCarrierOrSystemApp(byte[][] pdus, int destPort,
+        InboundSmsTracker tracker, SmsBroadcastReceiver resultReceiver, boolean userUnlocked) {
+        List<String> carrierPackages = null;
+        UiccCard card = UiccController.getInstance().getUiccCard(mPhone.getPhoneId());
+        if (card != null) {
+            carrierPackages = card.getCarrierPackageNamesForIntent(
+                    mContext.getPackageManager(),
+                    new Intent(CarrierMessagingService.SERVICE_INTERFACE));
+        } else {
+            loge("UiccCard not initialized.");
+        }
+        List<String> systemPackages =
+            getSystemAppForIntent(new Intent(CarrierMessagingService.SERVICE_INTERFACE));
+
+        if (carrierPackages != null && carrierPackages.size() == 1) {
+            log("Found carrier package.");
+            CarrierSmsFilter smsFilter = new CarrierSmsFilter(pdus, destPort,
+                    tracker.getFormat(), resultReceiver);
+            CarrierSmsFilterCallback smsFilterCallback = new CarrierSmsFilterCallback(smsFilter, userUnlocked);
+            smsFilter.filterSms(carrierPackages.get(0), smsFilterCallback);
+            return true;
+        } else if (systemPackages != null && systemPackages.size() == 1) {
+            log("Found system package.");
+            CarrierSmsFilter smsFilter = new CarrierSmsFilter(pdus, destPort,
+                    tracker.getFormat(), resultReceiver);
+            CarrierSmsFilterCallback smsFilterCallback = new CarrierSmsFilterCallback(smsFilter, userUnlocked);
+            smsFilter.filterSms(systemPackages.get(0), smsFilterCallback);
+            return true;
+        }
+        logv("Unable to find carrier package: " + carrierPackages
+                + ", nor systemPackages: " + systemPackages);
+        return false;
+    }
+
+    private List<String> getSystemAppForIntent(Intent intent) {
+        List<String> packages = new ArrayList<String>();
+        PackageManager packageManager = mContext.getPackageManager();
+        List<ResolveInfo> receivers = packageManager.queryIntentServices(intent, 0);
+        String carrierFilterSmsPerm = "android.permission.CARRIER_FILTER_SMS";
+
+        for (ResolveInfo info : receivers) {
+            if (info.serviceInfo == null) {
+                loge("Can't get service information from " + info);
+                continue;
+            }
+            String packageName = info.serviceInfo.packageName;
+                if (packageManager.checkPermission(carrierFilterSmsPerm, packageName) ==
+                        packageManager.PERMISSION_GRANTED) {
+                    packages.add(packageName);
+                    if (DBG) log("getSystemAppForIntent: added package "+ packageName);
+                }
+        }
+        return packages;
+    }
+
+    /**
+     * Dispatch the intent with the specified permission, appOp, and result receiver, using
+     * this state machine's handler thread to run the result receiver.
+     *
+     * @param intent the intent to broadcast
+     * @param permission receivers are required to have this permission
+     * @param appOp app op that is being performed when dispatching to a receiver
+     * @param user user to deliver the intent to
+     */
+    public void dispatchIntent(Intent intent, String permission, int appOp,
+            Bundle opts, BroadcastReceiver resultReceiver, UserHandle user) {
+        intent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT);
+        final String action = intent.getAction();
+        if (Intents.SMS_DELIVER_ACTION.equals(action)
+                || Intents.SMS_RECEIVED_ACTION.equals(action)
+                || Intents.WAP_PUSH_DELIVER_ACTION.equals(action)
+                || Intents.WAP_PUSH_RECEIVED_ACTION.equals(action)) {
+            // Some intents need to be delivered with high priority:
+            // SMS_DELIVER, SMS_RECEIVED, WAP_PUSH_DELIVER, WAP_PUSH_RECEIVED
+            // In some situations, like after boot up or system under load, normal
+            // intent delivery could take a long time.
+            // This flag should only be set for intents for visible, timely operations
+            // which is true for the intents above.
+            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
+        }
+        SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
+        if (user.equals(UserHandle.ALL)) {
+            // Get a list of currently started users.
+            int[] users = null;
+            try {
+                users = ActivityManagerNative.getDefault().getRunningUserIds();
+            } catch (RemoteException re) {
+            }
+            if (users == null) {
+                users = new int[] {user.getIdentifier()};
+            }
+            // Deliver the broadcast only to those running users that are permitted
+            // by user policy.
+            for (int i = users.length - 1; i >= 0; i--) {
+                UserHandle targetUser = new UserHandle(users[i]);
+                if (users[i] != UserHandle.USER_SYSTEM) {
+                    // Is the user not allowed to use SMS?
+                    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_SMS, targetUser)) {
+                        continue;
+                    }
+                    // Skip unknown users and managed profiles as well
+                    UserInfo info = mUserManager.getUserInfo(users[i]);
+                    if (info == null || info.isManagedProfile()) {
+                        continue;
+                    }
+                }
+                // Only pass in the resultReceiver when the USER_SYSTEM is processed.
+                mContext.sendOrderedBroadcastAsUser(intent, targetUser, permission, appOp, opts,
+                        users[i] == UserHandle.USER_SYSTEM ? resultReceiver : null,
+                        getHandler(), Activity.RESULT_OK, null, null);
+            }
+        } else {
+            mContext.sendOrderedBroadcastAsUser(intent, user, permission, appOp, opts,
+                    resultReceiver, getHandler(), Activity.RESULT_OK, null, null);
+        }
+    }
+
+    /**
+     * Helper for {@link SmsBroadcastUndelivered} to delete an old message in the raw table.
+     */
+    private void deleteFromRawTable(String deleteWhere, String[] deleteWhereArgs,
+                                    int deleteType) {
+        Uri uri = deleteType == DELETE_PERMANENTLY ? sRawUriPermanentDelete : sRawUri;
+        int rows = mResolver.delete(uri, deleteWhere, deleteWhereArgs);
+        if (rows == 0) {
+            loge("No rows were deleted from raw table!");
+        } else if (DBG) {
+            log("Deleted " + rows + " rows from raw table.");
+        }
+    }
+
+    private Bundle handleSmsWhitelisting(ComponentName target) {
+        String pkgName;
+        String reason;
+        if (target != null) {
+            pkgName = target.getPackageName();
+            reason = "sms-app";
+        } else {
+            pkgName = mContext.getPackageName();
+            reason = "sms-broadcast";
+        }
+        try {
+            long duration = mDeviceIdleController.addPowerSaveTempWhitelistAppForSms(
+                    pkgName, 0, reason);
+            BroadcastOptions bopts = BroadcastOptions.makeBasic();
+            bopts.setTemporaryAppWhitelistDuration(duration);
+            return bopts.toBundle();
+        } catch (RemoteException e) {
+        }
+
+        return null;
+    }
+
+    /**
+     * Creates and dispatches the intent to the default SMS app or the appropriate port.
+     *
+     * @param pdus message pdus
+     * @param format the message format, typically "3gpp" or "3gpp2"
+     * @param destPort the destination port
+     * @param resultReceiver the receiver handling the delivery result
+     */
+    private void dispatchSmsDeliveryIntent(byte[][] pdus, String format, int destPort,
+            BroadcastReceiver resultReceiver) {
+        Intent intent = new Intent();
+        intent.putExtra("pdus", pdus);
+        intent.putExtra("format", format);
+
+        if (destPort == -1) {
+            intent.setAction(Intents.SMS_DELIVER_ACTION);
+            // Direct the intent to only the default SMS app. If we can't find a default SMS app
+            // then sent it to all broadcast receivers.
+            // We are deliberately delivering to the primary user's default SMS App.
+            ComponentName componentName = SmsApplication.getDefaultSmsApplication(mContext, true);
+            if (componentName != null) {
+                // Deliver SMS message only to this receiver.
+                intent.setComponent(componentName);
+                log("Delivering SMS to: " + componentName.getPackageName() +
+                    " " + componentName.getClassName());
+            } else {
+                intent.setComponent(null);
+            }
+
+            // TODO: Validate that this is the right place to store the SMS.
+            if (SmsManager.getDefault().getAutoPersisting()) {
+                final Uri uri = writeInboxMessage(intent);
+                if (uri != null) {
+                    // Pass this to SMS apps so that they know where it is stored
+                    intent.putExtra("uri", uri.toString());
+                }
+            }
+        } else {
+            intent.setAction(Intents.DATA_SMS_RECEIVED_ACTION);
+            Uri uri = Uri.parse("sms://localhost:" + destPort);
+            intent.setData(uri);
+            intent.setComponent(null);
+        }
+
+        Bundle options = handleSmsWhitelisting(intent.getComponent());
+        dispatchIntent(intent, android.Manifest.permission.RECEIVE_SMS,
+                AppOpsManager.OP_RECEIVE_SMS, options, resultReceiver, UserHandle.SYSTEM);
+    }
+
+    /**
+     * Insert a message PDU into the raw table so we can acknowledge it immediately.
+     * If the device crashes before the broadcast to listeners completes, it will be delivered
+     * from the raw table on the next device boot. For single-part messages, the deleteWhere
+     * and deleteWhereArgs fields of the tracker will be set to delete the correct row after
+     * the ordered broadcast completes.
+     *
+     * @param tracker the tracker to add to the raw table
+     * @return true on success; false on failure to write to database
+     */
+    private int addTrackerToRawTable(InboundSmsTracker tracker, boolean deDup) {
+        String address = tracker.getAddress();
+        String refNumber = Integer.toString(tracker.getReferenceNumber());
+        String count = Integer.toString(tracker.getMessageCount());
+        if (deDup) {
+            // check for duplicate message segments
+            Cursor cursor = null;
+            try {
+                // sequence numbers are 1-based except for CDMA WAP, which is 0-based
+                int sequence = tracker.getSequenceNumber();
+
+                // convert to strings for query
+                String seqNumber = Integer.toString(sequence);
+                String date = Long.toString(tracker.getTimestamp());
+                String messageBody = tracker.getMessageBody();
+
+                // Check for duplicate message segments
+                cursor = mResolver.query(sRawUri, PDU_PROJECTION,
+                        "address=? AND reference_number=? AND count=? AND sequence=? AND date=? " +
+                                "AND message_body=?",
+                        new String[]{address, refNumber, count, seqNumber, date, messageBody},
+                        null);
+
+                // moveToNext() returns false if no duplicates were found
+                if (cursor.moveToNext()) {
+                    loge("Discarding duplicate message segment, refNumber=" + refNumber
+                            + " seqNumber=" + seqNumber + " count=" + count);
+                    if (VDBG) {
+                        loge("address=" + address + " date=" + date + " messageBody=" +
+                                messageBody);
+                    }
+                    String oldPduString = cursor.getString(PDU_COLUMN);
+                    byte[] pdu = tracker.getPdu();
+                    byte[] oldPdu = HexDump.hexStringToByteArray(oldPduString);
+                    if (!Arrays.equals(oldPdu, tracker.getPdu())) {
+                        loge("Warning: dup message segment PDU of length " + pdu.length
+                                + " is different from existing PDU of length " + oldPdu.length);
+                    }
+                    return Intents.RESULT_SMS_DUPLICATED;   // reject message
+                }
+            } catch (SQLException e) {
+                loge("Can't access SMS database", e);
+                return Intents.RESULT_SMS_GENERIC_ERROR;    // reject message
+            } finally {
+                if (cursor != null) {
+                    cursor.close();
+                }
+            }
+        } else {
+            logd("Skipped message de-duping logic");
+        }
+
+        ContentValues values = tracker.getContentValues();
+
+        if (VDBG) log("adding content values to raw table: " + values.toString());
+        Uri newUri = mResolver.insert(sRawUri, values);
+        if (DBG) log("URI of new row -> " + newUri);
+
+        try {
+            long rowId = ContentUris.parseId(newUri);
+            if (tracker.getMessageCount() == 1) {
+                // set the delete selection args for single-part message
+                tracker.setDeleteWhere(SELECT_BY_ID, new String[]{Long.toString(rowId)});
+            } else {
+                // set the delete selection args for multi-part message
+                String[] deleteWhereArgs = {address, refNumber, count};
+                tracker.setDeleteWhere(SELECT_BY_REFERENCE, deleteWhereArgs);
+            }
+            return Intents.RESULT_SMS_HANDLED;
+        } catch (Exception e) {
+            loge("error parsing URI for new row: " + newUri, e);
+            return Intents.RESULT_SMS_GENERIC_ERROR;
+        }
+    }
+
+    /**
+     * Returns whether the default message format for the current radio technology is 3GPP2.
+     * @return true if the radio technology uses 3GPP2 format by default, false for 3GPP format
+     */
+    static boolean isCurrentFormat3gpp2() {
+        int activePhone = TelephonyManager.getDefault().getCurrentPhoneType();
+        return (PHONE_TYPE_CDMA == activePhone);
+    }
+
+    /**
+     * Handler for an {@link InboundSmsTracker} broadcast. Deletes PDUs from the raw table and
+     * logs the broadcast duration (as an error if the other receivers were especially slow).
+     */
+    private final class SmsBroadcastReceiver extends BroadcastReceiver {
+        private final String mDeleteWhere;
+        private final String[] mDeleteWhereArgs;
+        private long mBroadcastTimeNano;
+
+        SmsBroadcastReceiver(InboundSmsTracker tracker) {
+            mDeleteWhere = tracker.getDeleteWhere();
+            mDeleteWhereArgs = tracker.getDeleteWhereArgs();
+            mBroadcastTimeNano = System.nanoTime();
+        }
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals(Intents.SMS_DELIVER_ACTION)) {
+                // Now dispatch the notification only intent
+                intent.setAction(Intents.SMS_RECEIVED_ACTION);
+                intent.setComponent(null);
+                // All running users will be notified of the received sms.
+                Bundle options = handleSmsWhitelisting(null);
+                dispatchIntent(intent, android.Manifest.permission.RECEIVE_SMS,
+                        AppOpsManager.OP_RECEIVE_SMS, options, this, UserHandle.ALL);
+            } else if (action.equals(Intents.WAP_PUSH_DELIVER_ACTION)) {
+                // Now dispatch the notification only intent
+                intent.setAction(Intents.WAP_PUSH_RECEIVED_ACTION);
+                intent.setComponent(null);
+                // Only the primary user will receive notification of incoming mms.
+                // That app will do the actual downloading of the mms.
+                Bundle options = null;
+                try {
+                    long duration = mDeviceIdleController.addPowerSaveTempWhitelistAppForMms(
+                            mContext.getPackageName(), 0, "mms-broadcast");
+                    BroadcastOptions bopts = BroadcastOptions.makeBasic();
+                    bopts.setTemporaryAppWhitelistDuration(duration);
+                    options = bopts.toBundle();
+                } catch (RemoteException e) {
+                }
+
+                String mimeType = intent.getType();
+                dispatchIntent(intent, WapPushOverSms.getPermissionForType(mimeType),
+                        WapPushOverSms.getAppOpsPermissionForIntent(mimeType), options, this,
+                        UserHandle.SYSTEM);
+            } else {
+                // Now that the intents have been deleted we can clean up the PDU data.
+                if (!Intents.DATA_SMS_RECEIVED_ACTION.equals(action)
+                        && !Intents.SMS_RECEIVED_ACTION.equals(action)
+                        && !Intents.DATA_SMS_RECEIVED_ACTION.equals(action)
+                        && !Intents.WAP_PUSH_RECEIVED_ACTION.equals(action)) {
+                    loge("unexpected BroadcastReceiver action: " + action);
+                }
+
+                int rc = getResultCode();
+                if ((rc != Activity.RESULT_OK) && (rc != Intents.RESULT_SMS_HANDLED)) {
+                    loge("a broadcast receiver set the result code to " + rc
+                            + ", deleting from raw table anyway!");
+                } else if (DBG) {
+                    log("successful broadcast, deleting from raw table.");
+                }
+
+                deleteFromRawTable(mDeleteWhere, mDeleteWhereArgs, MARK_DELETED);
+                sendMessage(EVENT_BROADCAST_COMPLETE);
+
+                int durationMillis = (int) ((System.nanoTime() - mBroadcastTimeNano) / 1000000);
+                if (durationMillis >= 5000) {
+                    loge("Slow ordered broadcast completion time: " + durationMillis + " ms");
+                } else if (DBG) {
+                    log("ordered broadcast completed in: " + durationMillis + " ms");
+                }
+            }
+        }
+    }
+
+    /**
+     * Asynchronously binds to the carrier messaging service, and filters out the message if
+     * instructed to do so by the carrier messaging service. A new instance must be used for every
+     * message.
+     */
+    private final class CarrierSmsFilter extends CarrierMessagingServiceManager {
+        private final byte[][] mPdus;
+        private final int mDestPort;
+        private final String mSmsFormat;
+        private final SmsBroadcastReceiver mSmsBroadcastReceiver;
+        // Instantiated in filterSms.
+        private volatile CarrierSmsFilterCallback mSmsFilterCallback;
+
+        CarrierSmsFilter(byte[][] pdus, int destPort, String smsFormat,
+                SmsBroadcastReceiver smsBroadcastReceiver) {
+            mPdus = pdus;
+            mDestPort = destPort;
+            mSmsFormat = smsFormat;
+            mSmsBroadcastReceiver = smsBroadcastReceiver;
+        }
+
+        /**
+         * Attempts to bind to a {@link ICarrierMessagingService}. Filtering is initiated
+         * asynchronously once the service is ready using {@link #onServiceReady}.
+         */
+        void filterSms(String carrierPackageName, CarrierSmsFilterCallback smsFilterCallback) {
+            mSmsFilterCallback = smsFilterCallback;
+            if (!bindToCarrierMessagingService(mContext, carrierPackageName)) {
+                loge("bindService() for carrier messaging service failed");
+                smsFilterCallback.onFilterComplete(CarrierMessagingService.RECEIVE_OPTIONS_DEFAULT);
+            } else {
+                logv("bindService() for carrier messaging service succeeded");
+            }
+        }
+
+        /**
+         * Invokes the {@code carrierMessagingService} to filter messages. The filtering result is
+         * delivered to {@code smsFilterCallback}.
+         */
+        @Override
+        protected void onServiceReady(ICarrierMessagingService carrierMessagingService) {
+            try {
+                carrierMessagingService.filterSms(
+                        new MessagePdu(Arrays.asList(mPdus)), mSmsFormat, mDestPort,
+                        mPhone.getSubId(), mSmsFilterCallback);
+            } catch (RemoteException e) {
+                loge("Exception filtering the SMS: " + e);
+                mSmsFilterCallback.onFilterComplete(
+                    CarrierMessagingService.RECEIVE_OPTIONS_DEFAULT);
+            }
+        }
+    }
+
+    /**
+     * A callback used to notify the platform of the carrier messaging app filtering result. Once
+     * the result is ready, the carrier messaging service connection is disposed.
+     */
+    private final class CarrierSmsFilterCallback extends ICarrierMessagingCallback.Stub {
+        private final CarrierSmsFilter mSmsFilter;
+        private final boolean mUserUnlocked;
+
+        CarrierSmsFilterCallback(CarrierSmsFilter smsFilter, boolean userUnlocked) {
+            mSmsFilter = smsFilter;
+            mUserUnlocked = userUnlocked;
+        }
+
+        /**
+         * This method should be called only once.
+         */
+        @Override
+        public void onFilterComplete(int result) {
+            mSmsFilter.disposeConnection(mContext);
+
+            logv("onFilterComplete: result is "+ result);
+            if ((result & CarrierMessagingService.RECEIVE_OPTIONS_DROP) == 0) {
+                if (mUserUnlocked) {
+                    dispatchSmsDeliveryIntent(mSmsFilter.mPdus, mSmsFilter.mSmsFormat,
+                            mSmsFilter.mDestPort, mSmsFilter.mSmsBroadcastReceiver);
+                } else {
+                    // Don't do anything further, leave the message in the raw table if the
+                    // credential-encrypted storage is still locked and show the new message
+                    // notification if the message is visible to the user.
+                    if (!isSkipNotifyFlagSet(result)) {
+                        showNewMessageNotification();
+                    }
+                    sendMessage(EVENT_BROADCAST_COMPLETE);
+                }
+            } else {
+                // Drop this SMS.
+                final long token = Binder.clearCallingIdentity();
+                try {
+                    // Needs phone package permissions.
+                    deleteFromRawTable(mSmsFilter.mSmsBroadcastReceiver.mDeleteWhere,
+                            mSmsFilter.mSmsBroadcastReceiver.mDeleteWhereArgs, MARK_DELETED);
+                } finally {
+                    Binder.restoreCallingIdentity(token);
+                }
+                sendMessage(EVENT_BROADCAST_COMPLETE);
+            }
+        }
+
+        @Override
+        public void onSendSmsComplete(int result, int messageRef) {
+            loge("Unexpected onSendSmsComplete call with result: " + result);
+        }
+
+        @Override
+        public void onSendMultipartSmsComplete(int result, int[] messageRefs) {
+            loge("Unexpected onSendMultipartSmsComplete call with result: " + result);
+        }
+
+        @Override
+        public void onSendMmsComplete(int result, byte[] sendConfPdu) {
+            loge("Unexpected onSendMmsComplete call with result: " + result);
+        }
+
+        @Override
+        public void onDownloadMmsComplete(int result) {
+            loge("Unexpected onDownloadMmsComplete call with result: " + result);
+        }
+    }
+
+    /** Checks whether the flag to skip new message notification is set in the bitmask returned
+     *  from the carrier app.
+     */
+    private boolean isSkipNotifyFlagSet(int callbackResult) {
+        return (callbackResult
+            & RECEIVE_OPTIONS_SKIP_NOTIFY_WHEN_CREDENTIAL_PROTECTED_STORAGE_UNAVAILABLE) > 0;
+    }
+
+    /**
+     * Log with debug level.
+     * @param s the string to log
+     */
+    @Override
+    protected void log(String s) {
+        Rlog.d(getName(), s);
+    }
+
+    /**
+     * Log with error level.
+     * @param s the string to log
+     */
+    @Override
+    protected void loge(String s) {
+        Rlog.e(getName(), s);
+    }
+
+    /**
+     * Log with error level.
+     * @param s the string to log
+     * @param e is a Throwable which logs additional information.
+     */
+    @Override
+    protected void loge(String s, Throwable e) {
+        Rlog.e(getName(), s, e);
+    }
+
+    /**
+     * Store a received SMS into Telephony provider
+     *
+     * @param intent The intent containing the received SMS
+     * @return The URI of written message
+     */
+    private Uri writeInboxMessage(Intent intent) {
+        final SmsMessage[] messages = Telephony.Sms.Intents.getMessagesFromIntent(intent);
+        if (messages == null || messages.length < 1) {
+            loge("Failed to parse SMS pdu");
+            return null;
+        }
+        // Sometimes, SmsMessage.mWrappedSmsMessage is null causing NPE when we access
+        // the methods on it although the SmsMessage itself is not null. So do this check
+        // before we do anything on the parsed SmsMessages.
+        for (final SmsMessage sms : messages) {
+            try {
+                sms.getDisplayMessageBody();
+            } catch (NullPointerException e) {
+                loge("NPE inside SmsMessage");
+                return null;
+            }
+        }
+        final ContentValues values = parseSmsMessage(messages);
+        final long identity = Binder.clearCallingIdentity();
+        try {
+            return mContext.getContentResolver().insert(Telephony.Sms.Inbox.CONTENT_URI, values);
+        } catch (Exception e) {
+            loge("Failed to persist inbox message", e);
+        } finally {
+            Binder.restoreCallingIdentity(identity);
+        }
+        return null;
+    }
+
+    /**
+     * Convert SmsMessage[] into SMS database schema columns
+     *
+     * @param msgs The SmsMessage array of the received SMS
+     * @return ContentValues representing the columns of parsed SMS
+     */
+    private static ContentValues parseSmsMessage(SmsMessage[] msgs) {
+        final SmsMessage sms = msgs[0];
+        final ContentValues values = new ContentValues();
+        values.put(Telephony.Sms.Inbox.ADDRESS, sms.getDisplayOriginatingAddress());
+        values.put(Telephony.Sms.Inbox.BODY, buildMessageBodyFromPdus(msgs));
+        values.put(Telephony.Sms.Inbox.DATE_SENT, sms.getTimestampMillis());
+        values.put(Telephony.Sms.Inbox.DATE, System.currentTimeMillis());
+        values.put(Telephony.Sms.Inbox.PROTOCOL, sms.getProtocolIdentifier());
+        values.put(Telephony.Sms.Inbox.SEEN, 0);
+        values.put(Telephony.Sms.Inbox.READ, 0);
+        final String subject = sms.getPseudoSubject();
+        if (!TextUtils.isEmpty(subject)) {
+            values.put(Telephony.Sms.Inbox.SUBJECT, subject);
+        }
+        values.put(Telephony.Sms.Inbox.REPLY_PATH_PRESENT, sms.isReplyPathPresent() ? 1 : 0);
+        values.put(Telephony.Sms.Inbox.SERVICE_CENTER, sms.getServiceCenterAddress());
+        return values;
+    }
+
+    /**
+     * Build up the SMS message body from the SmsMessage array of received SMS
+     *
+     * @param msgs The SmsMessage array of the received SMS
+     * @return The text message body
+     */
+    private static String buildMessageBodyFromPdus(SmsMessage[] msgs) {
+        if (msgs.length == 1) {
+            // There is only one part, so grab the body directly.
+            return replaceFormFeeds(msgs[0].getDisplayMessageBody());
+        } else {
+            // Build up the body from the parts.
+            StringBuilder body = new StringBuilder();
+            for (SmsMessage msg: msgs) {
+                // getDisplayMessageBody() can NPE if mWrappedMessage inside is null.
+                body.append(msg.getDisplayMessageBody());
+            }
+            return replaceFormFeeds(body.toString());
+        }
+    }
+
+    // Some providers send formfeeds in their messages. Convert those formfeeds to newlines.
+    private static String replaceFormFeeds(String s) {
+        return s == null ? "" : s.replace('\f', '\n');
+    }
+
+    @VisibleForTesting
+    public PowerManager.WakeLock getWakeLock() {
+        return mWakeLock;
+    }
+
+    @VisibleForTesting
+    public int getWakeLockTimeout() {
+        return WAKELOCK_TIMEOUT;
+    }
+}
