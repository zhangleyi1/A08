Index: kernel/drivers/input/touchscreen/Makefile
===================================================================
--- kernel/drivers/input/touchscreen/Makefile	(revision 166571)
+++ kernel/drivers/input/touchscreen/Makefile	(revision 166572)
@@ -86,6 +86,7 @@
 obj-$(CONFIG_TOUCHSCREEN_MMS134)    += mms100s_ts.o
 obj-$(CONFIG_TOUCHSCREEN_MMS134S)    += mms134s/
 obj-$(CONFIG_TOUCHSCREEN_MSG2138)	+= msg2138/
+obj-$(CONFIG_TOUCHSCREEN_MSG5846)	+= msg5846/
 obj-$(CONFIG_TOUCHSCREEN_ZT7554)    += zt7554_ts.o
 obj-$(CONFIG_TOUCHSCREEN_BT541_TS)    += zinitix_bt541_ts.o
 obj-$(CONFIG_TOUCHSCREEN_MELFAS_MCS6000)	+= melfas_mip4/
Index: kernel/drivers/input/touchscreen/Kconfig
===================================================================
--- kernel/drivers/input/touchscreen/Kconfig	(revision 166571)
+++ kernel/drivers/input/touchscreen/Kconfig	(revision 166572)
@@ -1061,8 +1061,20 @@
              If unsure, say N.
 
              To compile this driver as a module, choose M here: the
-             module will be called msg2138.c.             
+             module will be called msg2138.c.        
+             
+config TOUCHSCREEN_MSG5846
+        tristate "MSG5846 touchscreen driver"
+        depends on I2C
+           help
+             Say Y here if you have a MSG5846 based touchscreen
+             controller.
 
+             If unsure, say N.
+
+             To compile this driver as a module, choose M here: the
+             module will be called msg5846.c.        
+
 config TOUCHSCREEN_BT541_TS
         tristate "ZINITIX BT541 I2C Touchscreen"
 	depends on I2C
Index: kernel/drivers/input/touchscreen/focaltech/focaltech.c
===================================================================
--- kernel/drivers/input/touchscreen/focaltech/focaltech.c	(revision 166571)
+++ kernel/drivers/input/touchscreen/focaltech/focaltech.c	(revision 166572)
@@ -28,6 +28,7 @@
 #include <linux/slab.h>
 #include <linux/i2c.h>
 #include <linux/input.h>
+#include <linux/irq.h>
 #include <asm/uaccess.h>
 #include <linux/gpio.h>
 #include <linux/regulator/consumer.h>
@@ -37,6 +38,7 @@
 #include <linux/of_device.h>
 #include <linux/of_address.h>
 #include <linux/of_gpio.h>
+#include <linux/of_irq.h>
 
 #include <linux/sched.h>
 #include <linux/kthread.h>
@@ -51,16 +53,20 @@
 #include <linux/earlysuspend.h>
 #endif
 
-//#define FT53X6_DBG
-#ifdef FT53X6_DBG
-#define ENTER printk(KERN_INFO "[FT53X6_DBG] func: %s  line: %04d\n", __func__, __LINE__);
-#define PRINT_DBG(x...)  printk(KERN_INFO "[FT53X6_DBG] " x)
+#define TP_READ_VER
+
+
+#define FT53X6_pr_info
+
+#ifdef FT53X6_pr_info
+#define ENTER printk(KERN_INFO "[FT53X6_pr_info] func: %s  line: %04d\n", __func__, __LINE__);
+#define PRINT_pr_info(x...)  printk(KERN_INFO "[FT53X6_pr_info] " x)
 #define PRINT_INFO(x...)  printk(KERN_INFO "[FT53X6_INFO] " x)
 #define PRINT_WARN(x...)  printk(KERN_INFO "[FT53X6_WARN] " x)
 #define PRINT_ERR(format,x...)  printk(KERN_ERR "[FT53X6_ERR] func: %s  line: %04d  info: " format, __func__, __LINE__, ## x)
 #else
 #define ENTER
-#define PRINT_DBG(x...)
+#define PRINT_pr_info(x...)
 #define PRINT_INFO(x...)  printk(KERN_INFO "[FT53X6_INFO] " x)
 #define PRINT_WARN(x...)  printk(KERN_INFO "[FT53X6_WARN] " x)
 #define PRINT_ERR(format,x...)  printk(KERN_ERR "[FT53X6_ERR] func: %s  line: %04d  info: " format, __func__, __LINE__, ## x)
@@ -67,13 +73,34 @@
 #endif
 
 #define APK_DEBUG
-#define SPRD_AUTO_UPGRADE
+//#define SPRD_AUTO_UPGRADE
+//#define FT6x36_DOWNLOAD
 #define SYSFS_DEBUG
 #define FTS_CTL_IIC
+//#define TPD_PROXIMITY
+#define FTS_GESTRUE
+#ifdef TPD_PROXIMITY
+#define WAKE_LOCK_LPSENSOR
+#endif
 #include <linux/i2c/focaltech.h>
 #include <linux/i2c/focaltech_ex_fun.h>
 #include <linux/i2c/focaltech_ctl.h>
 
+#ifdef TPD_PROXIMITY
+#include <linux/miscdevice.h>
+#ifdef WAKE_LOCK_LPSENSOR
+#include <linux/wakelock.h>
+#endif
+#endif
+
+#ifdef TP_READ_VER
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/proc_fs.h>
+
+#define TP_VER_PROC_FILE	    "tp_ver"
+
+#endif
 #define	USE_WAIT_QUEUE	1
 #define	USE_THREADED_IRQ	0
 #define	USE_WORK_QUEUE	0
@@ -80,13 +107,27 @@
 
 #define	TOUCH_VIRTUAL_KEYS
 #define	MULTI_PROTOCOL_TYPE_B	1
-#ifdef CONFIG_ARCH_SCX35LT8
-#define	TS_MAX_FINGER		2
-#else
 #define	TS_MAX_FINGER		5
-#endif
+
 #define	FTS_PACKET_LENGTH	128
 
+
+#ifdef FT6x36_DOWNLOAD
+
+#include "ft6x36_download_lib.h"
+static struct i2c_client *g_i2c_client = NULL;
+static unsigned char CTPM_MAIN_FW1[]=
+{
+    #include "FT6336_C20-1_C1243_FWVGA_0x1a_all.i"
+};
+static unsigned char CTPM_MAIN_FW2[]=
+{
+	#include "FT6336_C20-1_GS00390F045_FWVGA_0x14_all.i"
+};
+static int TP_VOL;
+
+#endif
+
 #if USE_WAIT_QUEUE
 static struct task_struct *thread = NULL;
 static DECLARE_WAIT_QUEUE_HEAD(waiter);
@@ -93,6 +134,22 @@
 static int tpd_flag = 0;
 #endif
 
+#ifdef TOUCH_VIRTUAL_KEYS
+#define MAX_VIRTUAL_KEY		3
+//#define CTP_EXCHANGE_KEY
+
+#ifdef CTP_EXCHANGE_KEY
+static unsigned int tp_setkey_define = 1;
+#endif
+
+static unsigned int virtual_last_keymap = 0;
+
+static u8 virtual_keycode_array[MAX_VIRTUAL_KEY] = {KEY_MENU, KEY_HOMEPAGE, KEY_BACK};
+#ifdef CTP_EXCHANGE_KEY
+static u8 virtual_keycode_exchange_array[MAX_VIRTUAL_KEY] = {KEY_BACK, KEY_HOMEPAGE, KEY_MENU};
+#endif
+#endif
+
 #if 0
 static unsigned char FT5316_FW[]=
 {
@@ -106,18 +163,26 @@
 
 static unsigned char *CTPM_FW = FT5306_FW;
 #endif
-//static int fw_size;
+static int fw_size;
 
 static struct ft5x0x_ts_data *g_ft5x0x_ts;
 static struct i2c_client *this_client;
 
-//static unsigned char suspend_flag = 0;
+static unsigned char suspend_flag = 0;
 
+//#define TOUCH_USE_SIM2_POWER
 
+#ifdef TOUCH_USE_SIM2_POWER
+static struct regulator *vddsim2_regulator = NULL;
+#endif
+#ifdef TP_READ_VER
+static struct proc_dir_entry *tp_ver_proc = NULL;
+#endif
+
  struct Upgrade_Info fts_updateinfo[] =
 {
-        {0x55,"FT5x06",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x03, 1, 2000},
-        {0x08,"FT5606",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x06, 100, 2000},
+    {0x55,"FT5x06",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x03, 1, 2000},
+    {0x08,"FT5606",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x06, 100, 2000},
 	{0x0a,"FT5x16",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x07, 1, 1500},
 	{0x05,"FT6208",TPD_MAX_POINTS_2,AUTO_CLB_NONEED,60, 30, 0x79, 0x05, 10, 2000},
 	{0x06,"FT6x06",TPD_MAX_POINTS_2,AUTO_CLB_NONEED,100, 30, 0x79, 0x08, 10, 2000},
@@ -126,9 +191,85 @@
 	{0x13,"FT3316",TPD_MAX_POINTS_5,AUTO_CLB_NEED,30, 30, 0x79, 0x11, 10, 2000},
 	{0x12,"FT5436i",TPD_MAX_POINTS_5,AUTO_CLB_NEED,30, 30, 0x79, 0x11, 10, 2000},
 	{0x11,"FT5336i",TPD_MAX_POINTS_5,AUTO_CLB_NEED,30, 30, 0x79, 0x11, 10, 2000},
+	{0x36,"FT6x36/FT3207",TPD_MAX_POINTS_2,AUTO_CLB_NONEED,100, 30, 0x79, 0x18, 10, 2000},
+	{0x64,"FT6336U",TPD_MAX_POINTS_2,AUTO_CLB_NONEED,100, 30, 0x79, 0x18, 10, 2000},
+	{0x54,"FT5x46/FT3427",TPD_MAX_POINTS_5,AUTO_CLB_NONEED,2, 2, 0x54, 0x2c, 10, 2000},
 };
-				
+
 struct Upgrade_Info fts_updateinfo_curr;
+
+#ifdef TPD_PROXIMITY
+//#define FT53X6_DBG
+#ifdef FT53X6_DBG
+#define APS_ERR(fmt,arg...)           	printk("<<proximity>> "fmt"\n",##arg)
+#define TPD_PROXIMITY_DEBUG(fmt,arg...) printk("<<proximity>> "fmt"\n",##arg)
+#define TPD_PROXIMITY_DMESG(fmt,arg...) printk("<<proximity>> "fmt"\n",##arg)
+#else
+#define APS_ERR(fmt,arg...)
+#define TPD_PROXIMITY_DEBUG(fmt,arg...)
+#define TPD_PROXIMITY_DMESG(fmt,arg...)
+#endif
+
+#define FOCALTECH_PLS_DEVICE_NAME		"ltr_558als"
+#define FOCALTECH_PLS_INPUT_NAME			"alps_pxy"
+#define FOCALTECH_IOCTL_MAGIC			0x1C
+#define FOCALTECH_IOCTL_GET_PFLAG		_IOR(FOCALTECH_IOCTL_MAGIC, 1, int)
+#define FOCALTECH_IOCTL_GET_LFLAG		_IOR(FOCALTECH_IOCTL_MAGIC, 2, int)
+#define FOCALTECH_IOCTL_SET_PFLAG		_IOW(FOCALTECH_IOCTL_MAGIC, 3, int)
+#define FOCALTECH_IOCTL_SET_LFLAG		_IOW(FOCALTECH_IOCTL_MAGIC, 4, int)
+#define FOCALTECH_IOCTL_GET_CHIPINFO   _IOR(FOCALTECH_IOCTL_MAGIC, 6, char)
+
+static u8 tpd_proximity_flag 			= 0;
+static u8 tpd_proximity_suspend 		= 0;
+static u8 tpd_proximity_detect 		= 1;//0-->close ; 1--> far away
+static u8 tpd_proximity_detect_prev	= 0xff;//0-->close ; 1--> far away
+static struct input_dev *focaltech_pls_input_dev;
+static int focaltech_pls_opened=0;
+#ifdef WAKE_LOCK_LPSENSOR
+static struct wake_lock pls_delayed_work_wake_lock;
+#endif
+
+static int tpd_enable_ps(int enable);
+static int tpd_read_ps(void);
+static int tpd_get_ps_value(void);
+#endif
+
+#ifdef FTS_GESTRUE
+#define GESTURE_LEFT		0x20
+#define GESTURE_RIGHT		0x21
+#define GESTURE_UP		    0x22
+#define GESTURE_DOWN		0x23
+#define GESTURE_DOUBLECLICK	0x24
+#define GESTURE_O		    0x30
+#define GESTURE_W		    0x31
+#define GESTURE_M		    0x32
+#define GESTURE_E		    0x33
+#define GESTURE_C		    0x34
+#define GESTURE_S		    0x46
+#define GESTURE_V		    0x54
+#define GESTURE_Z		    0x65
+#define GESTURE_A		    0x36
+
+//#include "ft_gesture_lib.h"
+static bool TP_gesture_Switch = false;
+static bool TP_gesture_double_click_en = true;
+static unsigned long TP_gesture_value = 0x0;
+
+#define GESTURE_SWITCH_FILE 		"/data/data/com.android.settings/shared_prefs/gesture_open.xml"
+
+#define FTS_GESTRUE_POINTS 255
+#define FTS_GESTRUE_POINTS_ONETIME  62
+#define FTS_GESTRUE_POINTS_HEADER 8
+#define FTS_GESTURE_OUTPUT_ADRESS 0xD3
+#define FTS_GESTURE_OUTPUT_UNIT_LENGTH 4
+
+//suspend_state_t get_suspend_state(void);
+
+unsigned short coordinate_x[150] = {0};
+unsigned short coordinate_y[150] = {0};
+#endif
+
+
 #if 0//dennis
 /* Attribute */
 static ssize_t ft5x0x_show_suspend(struct device* cd,struct device_attribute *attr, char* buf);
@@ -136,7 +277,7 @@
 static ssize_t ft5x0x_show_version(struct device* cd,struct device_attribute *attr, char* buf);
 static ssize_t ft5x0x_update(struct device* cd, struct device_attribute *attr, const char* buf, size_t len);
 #endif
-//static unsigned char ft5x0x_read_fw_ver(void);
+static unsigned char ft5x0x_read_fw_ver(void);
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
 static void ft5x0x_ts_suspend(struct early_suspend *handler);
@@ -143,7 +284,7 @@
 static void ft5x0x_ts_resume(struct early_suspend *handler);
 #endif
 //static int fts_ctpm_fw_update(void);
-//static int fts_ctpm_fw_upgrade_with_i_file(void);
+static int fts_ctpm_fw_upgrade_with_i_file(void);
 
 struct ts_event {
 	u16	x1;
@@ -381,13 +522,12 @@
 
 
 #ifdef TOUCH_VIRTUAL_KEYS
-
 static ssize_t virtual_keys_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
 {
 	struct ft5x0x_ts_data *data = i2c_get_clientdata(this_client);
 	struct ft5x0x_ts_platform_data *pdata = data->platform_data;
 	return sprintf(buf,"%s:%s:%d:%d:%d:%d:%s:%s:%d:%d:%d:%d:%s:%s:%d:%d:%d:%d\n"
-		,__stringify(EV_KEY), __stringify(KEY_APPSELECT),pdata ->virtualkeys[0],pdata ->virtualkeys[1],pdata ->virtualkeys[2],pdata ->virtualkeys[3]
+		,__stringify(EV_KEY), __stringify(KEY_MENU),pdata ->virtualkeys[0],pdata ->virtualkeys[1],pdata ->virtualkeys[2],pdata ->virtualkeys[3]
 		,__stringify(EV_KEY), __stringify(KEY_HOMEPAGE),pdata ->virtualkeys[4],pdata ->virtualkeys[5],pdata ->virtualkeys[6],pdata ->virtualkeys[7]
 		,__stringify(EV_KEY), __stringify(KEY_BACK),pdata ->virtualkeys[8],pdata ->virtualkeys[9],pdata ->virtualkeys[10],pdata ->virtualkeys[11]);
 }
@@ -436,32 +576,365 @@
 function	:	 read TP firmware version
 
 ***********************************************************************************************/
-/*static unsigned char ft5x0x_read_fw_ver(void)
+static unsigned char ft5x0x_read_fw_ver(void)
 {
 	unsigned char ver;
 	ft5x0x_read_reg(FT5X0X_REG_FIRMID, &ver);
 	return(ver);
 }
-*/
 
 
+
 static void ft5x0x_clear_report_data(struct ft5x0x_ts_data *ft5x0x_ts)
 {
 	int i;
 
+#if 0 //def TOUCH_VIRTUAL_KEYS
+		if(virtual_last_keymap != 0)
+		{
+			int i;
+			u8 key_code;
+
+			for(i=0; i<MAX_VIRTUAL_KEY; i++)
+			{
+				if(virtual_last_keymap & (1<<i))
+				{
+#ifdef CTP_EXCHANGE_KEY
+					if(tp_setkey_define)
+					{
+						key_code = virtual_keycode_exchange_array[i];
+					}
+					else
+#endif
+					key_code = virtual_keycode_array[i];
+					input_report_key(ft5x0x_ts->input_dev, BTN_TOUCH, 0);
+					input_report_key(ft5x0x_ts->input_dev, key_code, 0);
+				}
+			}
+			virtual_last_keymap = 0;
+#if !MULTI_PROTOCOL_TYPE_B
+//			input_mt_sync(ft5x0x_ts->input_dev);
+#endif
+			input_sync(ft5x0x_ts->input_dev);
+		}
+#endif
+
 	for(i = 0; i < TS_MAX_FINGER; i++) {
-	#if MULTI_PROTOCOL_TYPE_B
+#if MULTI_PROTOCOL_TYPE_B
 		input_mt_slot(ft5x0x_ts->input_dev, i);
 		input_mt_report_slot_state(ft5x0x_ts->input_dev, MT_TOOL_FINGER, false);
-	#endif
+#endif
 	}
 	input_report_key(ft5x0x_ts->input_dev, BTN_TOUCH, 0);
-	#if !MULTI_PROTOCOL_TYPE_B
-		input_mt_sync(ft5x0x_ts->input_dev);
-	#endif
+#if !MULTI_PROTOCOL_TYPE_B
+	input_mt_sync(ft5x0x_ts->input_dev);
+#endif
 	input_sync(ft5x0x_ts->input_dev);
 }
 
+#ifdef FTS_GESTRUE
+static void check_gesture(int gesture_id)
+{
+	printk("kaka gesture_id==0x%x\n ",gesture_id);
+
+
+	/*
+	bit7  O
+	bit6  V
+	bit5  double click
+	bit4  right
+	bit3  left
+	bit2  down
+	bit1  up
+	bit0  total switch
+	*/	
+
+	switch(gesture_id)
+	{
+		case GESTURE_LEFT:	
+		if(TP_gesture_value & 0x8){
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 0);
+			input_sync(g_ft5x0x_ts->input_dev);		    
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_LEFT, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_LEFT, 0);
+			input_sync(g_ft5x0x_ts->input_dev);
+		}
+			break;
+		case GESTURE_RIGHT:	
+		if(TP_gesture_value & 0x10){
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 0);
+			input_sync(g_ft5x0x_ts->input_dev);		    
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_RIGHT, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_RIGHT, 0);
+			input_sync(g_ft5x0x_ts->input_dev);
+		}
+			break;
+		case GESTURE_UP:
+		if(TP_gesture_value & 0x2){
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 0);
+			input_sync(g_ft5x0x_ts->input_dev);		    
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_UP, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_UP, 0);
+			input_sync(g_ft5x0x_ts->input_dev);
+		}
+			break;
+		case GESTURE_DOWN:	
+		if(TP_gesture_value & 0x4){
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 0);
+			input_sync(g_ft5x0x_ts->input_dev);		    
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_DOWN, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_DOWN, 0);
+			input_sync(g_ft5x0x_ts->input_dev);	
+		}
+			break;
+		case GESTURE_DOUBLECLICK:
+		if(TP_gesture_value & 0x20){
+				input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 1);
+				input_sync(g_ft5x0x_ts->input_dev);
+				input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 0);
+				input_sync(g_ft5x0x_ts->input_dev);
+				input_report_key(g_ft5x0x_ts->input_dev, KEY_P, 1);
+				input_sync(g_ft5x0x_ts->input_dev);
+				input_report_key(g_ft5x0x_ts->input_dev, KEY_P, 0);
+				input_sync(g_ft5x0x_ts->input_dev);
+			}
+			break;
+		case GESTURE_O:	
+		if(TP_gesture_value & 0x80){
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 0);
+			input_sync(g_ft5x0x_ts->input_dev);		    
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_O, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_O, 0);
+			input_sync(g_ft5x0x_ts->input_dev);
+		}
+			break;
+#if 0
+		case GESTURE_W:			
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 0);
+			input_sync(g_ft5x0x_ts->input_dev);		    
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_W, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_W, 0);
+			input_sync(g_ft5x0x_ts->input_dev);
+			break;
+		case GESTURE_M:		
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 0);
+			input_sync(g_ft5x0x_ts->input_dev);		    
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_M, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_M, 0);
+			input_sync(g_ft5x0x_ts->input_dev);
+			break;
+		case GESTURE_E:		
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 0);
+			input_sync(g_ft5x0x_ts->input_dev);		    
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_E, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_E, 0);
+			input_sync(g_ft5x0x_ts->input_dev);			    
+			break;
+		case GESTURE_C:		
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 0);
+			input_sync(g_ft5x0x_ts->input_dev);		    
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_C, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_C, 0);
+			input_sync(g_ft5x0x_ts->input_dev);
+			break;
+		case GESTURE_S:		
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 0);
+			input_sync(g_ft5x0x_ts->input_dev);		    
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_S, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_S, 0);
+			input_sync(g_ft5x0x_ts->input_dev);
+			break;
+#endif
+		case GESTURE_V:
+		if(TP_gesture_value & 0x40){
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 0);
+			input_sync(g_ft5x0x_ts->input_dev);		    
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_V, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_V, 0);
+			input_sync(g_ft5x0x_ts->input_dev);
+		}
+			break;
+#if 0
+		case GESTURE_Z:	
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 0);
+			input_sync(g_ft5x0x_ts->input_dev);		    
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_Z, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_Z, 0);
+			input_sync(g_ft5x0x_ts->input_dev);
+			break;
+	case GESTURE_A:	
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_POWER, 0);
+			input_sync(g_ft5x0x_ts->input_dev);		    
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_A, 1);
+			input_sync(g_ft5x0x_ts->input_dev);
+			input_report_key(g_ft5x0x_ts->input_dev, KEY_A, 0);
+			input_sync(g_ft5x0x_ts->input_dev);
+			break;
+		default:
+			break;
+#endif
+	}
+}
+
+
+static int ft5x0x_read_Touchdata(void)
+{
+	unsigned char buf[FTS_GESTRUE_POINTS * 4] = { 0 };
+	int ret = -1;
+	int i = 0;
+	int j = 0;
+	buf[0] = 0xd3;
+	int gestrue_id = 0;
+	short pointnum = 0;
+
+	ret = fts_i2c_Read(this_client, buf, 1, buf, FTS_GESTRUE_POINTS_HEADER);
+	if (ret < 0)
+	{
+		printk( "%s read touchdata failed.\n", __func__);
+		return ret;
+	}
+
+	if (buf[0] != 0xfe)
+	{
+		gestrue_id =  buf[0];
+		check_gesture(gestrue_id);
+		return 0;
+	}
+
+#if 0
+	pointnum = (short)(buf[1]) & 0xff;
+	buf[0] = 0xd3;
+
+	//printk( "yedongyue1 ----%s  buf[0] = %d,pointnum = %d\n", __func__,buf[0],pointnum);
+	if((pointnum * 4 + 2+6)<255)
+	{
+		ret = fts_i2c_Read(this_client, buf, 1, buf, (pointnum * 4 + 2 + 6));
+	}
+	else
+	{
+		ret = fts_i2c_Read(this_client, buf, 1, buf, 255);
+		ret = fts_i2c_Read(this_client, buf, 0, buf+255, (pointnum * 4 + 2 +6)-255);
+	}
+	if (ret < 0)
+	{
+		printk( "%s read touchdata failed.\n", __func__);
+		return ret;
+	}
+	//	printk( "yedongyue2 ----%s  buf[0] = %d,pointnum = %d\n", __func__,buf[0],pointnum);
+	//gestrue_id = fetch_object_sample(buf, pointnum);
+	//	printk( "yedongyue3  ----%s   buf[0] = %d,pointnum = %d,gestrue_id = %d\n", __func__,buf[0],pointnum,gestrue_id);
+	for(i = 0;i < pointnum;i++)
+	{
+		coordinate_x[i] =  (((s16) buf[0 + (4 * i)]) & 0x0F) <<
+		8 | (((s16) buf[1 + (4 * i)])& 0xFF);
+		coordinate_y[i] = (((s16) buf[2 + (4 * i)]) & 0x0F) <<
+		8 | (((s16) buf[3 + (4 * i)]) & 0xFF);
+		//	printk( "yedongyue  -------   x=%d ,y=%d----------\n",buf[0],coordinate_x[i],coordinate_y[i]);
+	}
+
+	check_gesture(gestrue_id);
+#endif
+	return -1;
+}
+
+static ssize_t fts_gestrue_write(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
+{
+	unsigned int gesture_switch;
+	char temp[8] = {0};
+
+	if(copy_from_user(temp, buffer, sizeof(temp)))
+	{
+		printk("ft_gesture_write: call copy_from_user() fail!!\r\n");
+		return -EFAULT;
+	}
+
+
+	TP_gesture_value = simple_strtoul(temp, NULL, 10);
+	TP_gesture_Switch = ((TP_gesture_value & 0x1) ? true:false);	
+
+	printk("tp_gesture_switch = %d,TP_gesture_value:0x%x\n", TP_gesture_Switch,TP_gesture_value);
+	return count;
+}
+
+static ssize_t fts_gestrue_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
+{
+	unsigned int gesture_switch;
+	char buff[8] = {0};
+
+	sprintf(buff, "%d\n", TP_gesture_value);
+	if(copy_to_user(buffer, (void *)&gesture_switch, sizeof(gesture_switch)))
+	{
+		printk("%s copy_to_user fial!!\r\n", __func__);
+		return -EFAULT;
+	}
+	printk("tp_gesture_switch = %d,TP_gesture_value:0x%x\n", gesture_switch,TP_gesture_value);
+	return count;
+}
+
+static int fts_gestrue_open(struct inode *inode, struct file *f)
+{
+	return 0;
+}
+
+static int fts_gestrue_release(struct inode *inode, struct file *f)
+{
+	return 0;
+}
+
+static const struct file_operations fts_gestrue_fops =
+{
+	.owner = THIS_MODULE,
+	.open = fts_gestrue_open,
+	.write = fts_gestrue_write,
+	.read = fts_gestrue_read,
+	.release = fts_gestrue_release
+};
+
+static struct miscdevice fts_gestrue_struct = {
+	.name = "tp_gesture_switch",
+	.fops = &fts_gestrue_fops,
+	.minor = MISC_DYNAMIC_MINOR,
+};
+#endif
+
 static int ft5x0x_update_data(void)
 {
 	struct ft5x0x_ts_data *data = i2c_get_clientdata(this_client);
@@ -472,10 +945,107 @@
 	u16 x , y;
 	u8 ft_pressure , ft_size;
 
-	ret = ft5x0x_i2c_rxdata(buf, 33);
+#ifdef TOUCH_VIRTUAL_KEYS
+	unsigned int virtual_keymap = 0;
+#endif
 
-	if (ret < 0) {
-		pr_err("%s read_data i2c_rxdata failed: %d\n", __func__, ret);
+#ifdef TPD_PROXIMITY
+	int err;
+	u8 proximity_status;
+	u8 state;
+#endif
+
+#ifdef FTS_GESTRUE
+	u8 sta;
+	i2c_smbus_read_i2c_block_data(this_client, 0xd0, 1, &sta);
+	// if((get_suspend_state() == PM_SUSPEND_MEM) && (state ==1))
+	 if(sta == 1)
+	{
+		ft5x0x_read_Touchdata();
+		return 0;
+	}
+#endif
+
+{
+//wangcq327 add when charging write 0x01 to 0x8b start
+//wangcq327 add start
+	struct filp * fp=NULL;
+	mm_segment_t fs;
+	loff_t pos = 0;
+	char buf[200]={0};
+	char *p=NULL;
+	fp = filp_open("/sys/class/power_supply/battery/status",O_RDONLY , 0);
+	if(IS_ERR(fp)){
+		printk("wangcq327 --- touchpanle Open file fail error!!\n");
+	}else{
+		//read start
+		fs = get_fs();//get old fs;
+		set_fs(KERNEL_DS);
+		vfs_read(fp,buf,sizeof(buf),&pos);
+		//printk("wangcq327 --- read == %s\n",buf);
+		//read end
+
+		if(0 == strncmp("Charging",buf,8)){
+			fts_write_reg(this_client, 0x8b, 0x01);
+			//printk("wangcq327 --- Charging\n");
+		}else{
+    		fts_write_reg(this_client, 0x8b, 0x00);
+			//printk("wangcq327 --- NO Charging\n");
+		}
+//		printk("wangcq327 --- *p == %c\n",*p);
+	//	printk("wangcq327 --- TP_gesture_Switch == %d\n",(TP_gesture_Switch==true)?1:0);
+
+		filp_close(fp,NULL);
+		set_fs(fs);
+	}
+//wangcq327 add end
+//wangcq327 add when charging write 0x01 to 0x8b end
+}
+
+#ifdef TPD_PROXIMITY
+		if (tpd_proximity_flag == 1)
+		{
+			i2c_smbus_read_i2c_block_data(this_client, 0xB0, 1, &state);
+			TPD_PROXIMITY_DEBUG("proxi_5206 0xB0 state value is 1131 0x%02X\n", state);
+
+			if(!(state&0x01))
+			{
+				tpd_enable_ps(1);
+			}
+
+			i2c_smbus_read_i2c_block_data(this_client, 0x01, 1, &proximity_status);
+			TPD_PROXIMITY_DEBUG("proxi_5206 0x01 value is 1139 0x%02X\n", proximity_status);
+
+			if (proximity_status == 0xC0)
+			{
+				tpd_proximity_detect = 0;	
+			}
+			else if(proximity_status == 0xE0)
+			{
+				tpd_proximity_detect = 1;
+			}
+
+			TPD_PROXIMITY_DEBUG("tpd_proximity_detect 1149 = %d\n", tpd_proximity_detect);
+
+			if ((err = tpd_read_ps()))
+			{
+//				TPD_PROXIMITY_DMESG("proxi_5206 read ps data 1156: %d\n", err);	
+			}
+
+			if(tpd_proximity_detect != tpd_proximity_detect_prev)
+			{
+				tpd_proximity_detect_prev = tpd_proximity_detect;
+				input_report_abs(focaltech_pls_input_dev, ABS_DISTANCE, tpd_get_ps_value());
+				input_sync(focaltech_pls_input_dev);
+			}
+		}  
+#endif
+
+	ret = ft5x0x_i2c_rxdata(buf, 31);
+
+	if (ret < 0)
+	{
+		printk("%s read_data i2c_rxdata failed: %d\n", __func__, ret);
 		return ret;
 	}
 
@@ -482,48 +1052,153 @@
 	memset(event, 0, sizeof(struct ts_event));
 	event->touch_point = buf[2] & 0x07;
 
-	for(i = 0; i < TS_MAX_FINGER; i++) {
+	for(i = 0; i < TS_MAX_FINGER; i++)
+	{
 		if((buf[6*i+3] & 0xc0) == 0xc0)
 			continue;
 		x = (s16)(buf[6*i+3] & 0x0F)<<8 | (s16)buf[6*i+4];	
 		y = (s16)(buf[6*i+5] & 0x0F)<<8 | (s16)buf[6*i+6];
-		ft_pressure = buf[6*i+7];
-		if(ft_pressure > 127)
-			ft_pressure = 127;
-		ft_size = (buf[6*i+8]>>4) & 0x0F;
-		if((buf[6*i+3] & 0x40) == 0x0) {
-		#if MULTI_PROTOCOL_TYPE_B
-			input_mt_slot(data->input_dev, buf[6*i+5]>>4);
-			input_mt_report_slot_state(data->input_dev, MT_TOOL_FINGER, true);
-		#endif
-			input_report_abs(data->input_dev, ABS_MT_POSITION_X, x);
-			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, y);
-			input_report_key(data->input_dev, BTN_TOUCH, 1);
-		#if !MULTI_PROTOCOL_TYPE_B
-			input_mt_sync(data->input_dev);
-		#endif
+		if((buf[6*i+3] & 0x40) == 0x0)
+		{
+
+#if 0 //def TOUCH_VIRTUAL_KEYS
+
+			int key1_xstart, key2_xstart, key_ystart, key_width;
+
+			key1_xstart = g_ft5x0x_ts->platform_data->virtualkeys[0];
+			key2_xstart = g_ft5x0x_ts->platform_data->virtualkeys[4];
+			key_width = g_ft5x0x_ts->platform_data->virtualkeys[2];
+			key_ystart = g_ft5x0x_ts->platform_data->virtualkeys[1];
+			if(y >= key_ystart)
+			{
+				if(x <= (key1_xstart+key_width))
+				{
+					virtual_keymap |= 0x1;
+				}
+				else if(x <= (key2_xstart+key_width))
+				{
+					virtual_keymap |= 0x2;
+				}
+				else
+				{
+					virtual_keymap |= 0x4;
+				}
+			}
+			else
+			{
+#endif
+#if MULTI_PROTOCOL_TYPE_B
+				input_mt_slot(data->input_dev, buf[6*i+5]>>4);
+				input_mt_report_slot_state(data->input_dev, MT_TOOL_FINGER, true);
+#else
+				input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, buf[6*i+5]>>4);
+#endif
+				input_report_abs(data->input_dev, ABS_MT_POSITION_X, x);
+				input_report_abs(data->input_dev, ABS_MT_POSITION_Y, y);
+				input_report_key(data->input_dev, BTN_TOUCH, 1);
+#if !MULTI_PROTOCOL_TYPE_B
+				input_mt_sync(data->input_dev);
+#endif
+#if 0 //def TOUCH_VIRTUAL_KEYS
+			}
+#endif
 			pr_debug("===x%d = %d,y%d = %d ====",i, x, i, y);
+			//printk("ft5x0x_update_data  x%d = %d,y%d = %d   \n",i, x, i, y);
 		}
-		else {
-		#if MULTI_PROTOCOL_TYPE_B
+		else
+		{
+#if MULTI_PROTOCOL_TYPE_B
 			input_mt_slot(data->input_dev, buf[6*i+5]>>4);
 			input_mt_report_slot_state(data->input_dev, MT_TOOL_FINGER, false);
-		#endif
+#endif
 		}
 	}
-	if(0 == event->touch_point) {
-		for(i = 0; i < TS_MAX_FINGER; i ++) {
-			#if MULTI_PROTOCOL_TYPE_B
-                            input_mt_slot(data->input_dev, i);
-                            input_mt_report_slot_state(data->input_dev, MT_TOOL_FINGER, false);
-			#endif
+
+#if 0 //def TOUCH_VIRTUAL_KEYS
+	if((event->touch_point != 0) && (virtual_keymap != virtual_last_keymap))
+	{
+		int i;
+		u8 key_code;
+
+		for(i=0; i<MAX_VIRTUAL_KEY; i++)
+		{
+			if((virtual_keymap & (1<<i)) != (virtual_last_keymap & (1<<i)))
+			{
+#ifdef CTP_EXCHANGE_KEY
+				if(tp_setkey_define)
+				{
+					key_code = virtual_keycode_exchange_array[i];
+				}
+				else
+#endif
+				key_code = virtual_keycode_array[i];
+				if(virtual_keymap & (1<<i))
+				{
+					printk("ft5x0x_update_data  key_code=%d, press\n", key_code);
+					input_report_key(data->input_dev, BTN_TOUCH, 1);
+					input_report_key(data->input_dev, key_code, 1);
+				}
+				else
+				{
+					printk("ft5x0x_update_data  key_code=%d, release\n", key_code);
+					input_report_key(data->input_dev, BTN_TOUCH, 0);
+					input_report_key(data->input_dev, key_code, 0);
+				}
+			}
 		}
+		virtual_last_keymap = virtual_keymap;
+#if !MULTI_PROTOCOL_TYPE_B
+//		input_mt_sync(data->input_dev);
+#endif
+	}
+#endif
+
+	if(0 == event->touch_point)
+	{
+#if 0 //def TOUCH_VIRTUAL_KEYS
+		if(virtual_last_keymap != 0)
+		{
+			int i;
+			u8 key_code;
+
+			for(i=0; i<MAX_VIRTUAL_KEY; i++)
+			{
+				if(virtual_last_keymap & (1<<i))
+				{
+#ifdef CTP_EXCHANGE_KEY
+					if(tp_setkey_define)
+					{
+						key_code = virtual_keycode_exchange_array[i];
+					}
+					else
+#endif
+					key_code = virtual_keycode_array[i];
+					input_report_key(data->input_dev, BTN_TOUCH, 0);
+					input_report_key(data->input_dev, key_code, 0);
+				}
+			}
+			virtual_last_keymap = 0;
+#if !MULTI_PROTOCOL_TYPE_B
+//			input_mt_sync(data->input_dev);
+#endif
+			input_sync(data->input_dev);
+		}
+#endif
+
+		for(i = 0; i < TS_MAX_FINGER; i ++)
+		{
+#if MULTI_PROTOCOL_TYPE_B
+			input_mt_slot(data->input_dev, i);
+			input_mt_report_slot_state(data->input_dev, MT_TOOL_FINGER, false);
+#endif
+		}
 		input_report_key(data->input_dev, BTN_TOUCH, 0);
-		#if !MULTI_PROTOCOL_TYPE_B
-			input_mt_sync(data->input_dev);
-		#endif
+#if !MULTI_PROTOCOL_TYPE_B
+		input_mt_sync(data->input_dev);
+#endif
 
 	}
+
 	input_sync(data->input_dev);
 
 	return 0;
@@ -580,16 +1255,28 @@
 
 }
 
+static void ft5x0x_ts_reset_init(void)
+{
+	struct ft5x0x_ts_platform_data *pdata = g_ft5x0x_ts->platform_data;
+
+	gpio_direction_output(pdata->reset_gpio_number, 1);
+	mdelay(10);
+	gpio_set_value(pdata->reset_gpio_number, 0);
+	mdelay(50);
+	gpio_set_value(pdata->reset_gpio_number, 1);
+	mdelay(200);
+}
+
 static void ft5x0x_ts_reset(void)
 {
 	struct ft5x0x_ts_platform_data *pdata = g_ft5x0x_ts->platform_data;
 
 	gpio_direction_output(pdata->reset_gpio_number, 1);
-	msleep(1);
+	msleep(10);
 	gpio_set_value(pdata->reset_gpio_number, 0);
-	msleep(10);
+	msleep(50);
 	gpio_set_value(pdata->reset_gpio_number, 1);
-	msleep(200);
+	msleep(150);
 }
 
 #if 0
@@ -624,11 +1311,211 @@
 }
 #endif
 
+#ifdef TPD_PROXIMITY
+static int tpd_read_ps(void)
+{
+//	tpd_proximity_detect;
+	return 0;    
+}
+
+static int tpd_get_ps_value(void)
+{
+	return tpd_proximity_detect;
+}
+
+static int tpd_enable_ps(int enable)
+{
+	u8 state;
+	int ret = -1;
+
+	i2c_smbus_read_i2c_block_data(this_client, 0xB0, 1, &state);
+	TPD_PROXIMITY_DEBUG("[proxi_5206]read: 999 0xb0's value is 0x%02X\n", state);
+	if (enable){
+#ifdef WAKE_LOCK_LPSENSOR
+		wake_lock(&pls_delayed_work_wake_lock);
+#endif
+		state |= 0x01;
+		tpd_proximity_flag = 1;
+		TPD_PROXIMITY_DEBUG("[proxi_5206]ps function is on\n");	
+		
+	}else{
+		state &= 0x00;	
+		tpd_proximity_flag = 0;
+#ifdef WAKE_LOCK_LPSENSOR
+		wake_unlock(&pls_delayed_work_wake_lock);
+#endif
+		TPD_PROXIMITY_DEBUG("[proxi_5206]ps function is off\n");
+		
+	}
+
+	ret = i2c_smbus_write_i2c_block_data(this_client, 0xB0, 1, &state);
+	TPD_PROXIMITY_DEBUG("[proxi_5206]write: 0xB0's value is 0x%02X\n", state);
+	return 0;
+}
+
+static int focaltech_pls_open(struct inode *inode, struct file *file)
+{
+	TPD_PROXIMITY_DEBUG("%s", __func__);
+	if (focaltech_pls_opened)
+		return -EBUSY;
+	focaltech_pls_opened = 1;
+	return 0;
+}
+static int focaltech_pls_release(struct inode *inode, struct file *file)
+{
+	TPD_PROXIMITY_DEBUG("%s", __func__);
+	focaltech_pls_opened = 0;
+	return 0;//ap3212c_pls_disable(AP3212C_PLS_BOTH);
+}
+static long focaltech_pls_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	int flag;
+	int err = 0;
+
+	TPD_PROXIMITY_DEBUG("%s: cmd %d", __func__, _IOC_NR(cmd));
+
+	switch (cmd)
+	{
+		case FOCALTECH_IOCTL_SET_PFLAG:
+			if (copy_from_user(&flag, argp, sizeof(flag)))
+				return -EFAULT;
+			TPD_PROXIMITY_DEBUG("FOCALTECH_IOCTL_SET_PFLAG");
+			if(flag)
+			{
+				if((err=tpd_enable_ps(1)) != 0)
+				{
+					APS_ERR("enable ps fail: %d\n", err); 
+					return -EFAULT;
+				}
+			}
+			else
+			{
+				if((err=tpd_enable_ps(0)) != 0)
+				{
+					APS_ERR("disable ps fail: %d\n", err); 
+					return -EFAULT;
+				}
+			}
+			break;
+
+		case FOCALTECH_IOCTL_SET_LFLAG:
+			break;
+
+		case FOCALTECH_IOCTL_GET_PFLAG:
+			flag = tpd_proximity_flag;
+			if (copy_to_user(argp, &flag, sizeof(flag)))
+				return -EFAULT;
+			break;
+
+		case FOCALTECH_IOCTL_GET_LFLAG:
+			flag = 0;
+			if (copy_to_user(argp, &flag, sizeof(flag)))
+				return -EFAULT;
+			break;
+
+		case FOCALTECH_IOCTL_GET_CHIPINFO:
+			{
+				char strbuf[256];
+
+				sprintf(strbuf, "LTR558ALS");
+				if(copy_to_user(argp, strbuf, strlen(strbuf)+1))
+					return -EFAULT;
+			}
+			break;
+
+		default:
+			TPD_PROXIMITY_DEBUG("%s: invalid cmd %d", __func__, _IOC_NR(cmd));
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+ static struct file_operations focaltech_pls_fops = {
+	 .owner 			 = THIS_MODULE,
+	 .open				 = focaltech_pls_open,
+	 .release			 = focaltech_pls_release,
+	 .unlocked_ioctl 	 = focaltech_pls_ioctl,
+ };
+ static struct miscdevice focaltech_pls_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = FOCALTECH_PLS_DEVICE_NAME,
+	.fops = &focaltech_pls_fops,
+};
+#endif	//#ifdef TPD_PROXIMITY
+
+
 #ifdef CONFIG_HAS_EARLYSUSPEND
 static void ft5x0x_ts_suspend(struct early_suspend *handler)
 {
 	int ret = -1;
-	pr_info("==%s==\n", __FUNCTION__);
+
+	printk("==%s==\n", __FUNCTION__);
+
+#if 0//def FTS_GESTRUE	
+	//wangcq327 add start
+	struct filp * fp=NULL;
+	mm_segment_t fs;
+	loff_t pos = 0;
+	char buf[200]={0};
+	char *p=NULL;
+
+	fp = filp_open(GESTURE_SWITCH_FILE , O_RDONLY , 0);
+	if(IS_ERR(fp))
+	{
+		printk("wangcq327 --- touchpanle Open file fail !!\n");
+		TP_gesture_Switch = true;
+	}
+	else
+	{
+		//read start
+		fs = get_fs();//get old fs;
+		set_fs(KERNEL_DS);
+		vfs_read(fp,buf,sizeof(buf),&pos);
+		//printk("wangcq327 --- read == %s\n",buf);
+		//read end
+
+		p = strstr(buf,"value=");//value="1"
+		p += 7;
+
+		//printk("wangcq327 --- *p == %c\n",*p);
+		if(*p == '1'){
+			TP_gesture_Switch = true;
+		}else{
+			TP_gesture_Switch = false;
+		}
+		//printk("wangcq327 --- TP_gesture_Switch == %d\n",(TP_gesture_Switch==true)?1:0);
+		
+		filp_close(fp,NULL);
+		set_fs(fs);
+	}
+	//wangcq327 add end
+#endif
+
+#ifdef TPD_PROXIMITY
+	if (tpd_proximity_flag == 1)
+	{
+		tpd_proximity_suspend = 0;	
+		return;
+	}
+	else
+	{
+		tpd_proximity_suspend = 1;
+	}
+#endif
+
+#ifdef FTS_GESTRUE
+	if(true == TP_gesture_Switch)
+	{//wangcq327 add
+		fts_write_reg(this_client, 0xd0, 0x01);
+		irq_set_irq_type(this_client->irq, IRQF_TRIGGER_LOW);
+		//fts_write_reg(this_client, 0xd1, 0x1f);
+		// fts_write_reg(this_client, 0xd2, 0x1f);
+		//tpd_halt = 1;
+		return;
+	}
+#endif
 	ret = ft5x0x_write_reg(FT5X0X_REG_PMODE, PMODE_HIBERNATE);
 	if(ret){
 		PRINT_ERR("==ft5x0x_ts_suspend==  ft5x0x_write_reg fail\n");
@@ -641,14 +1528,28 @@
 static void ft5x0x_ts_resume(struct early_suspend *handler)
 {
 	struct ft5x0x_ts_data  *ft5x0x_ts = (struct ft5x0x_ts_data *)i2c_get_clientdata(this_client);
+	
+#ifdef TPD_PROXIMITY	
+	if (tpd_proximity_suspend == 0)
+	{
+		return;
+	}
+	else
+	{
+		tpd_proximity_suspend = 0;
+	}
+#endif	
+
 	queue_work(ft5x0x_ts->ts_resume_workqueue, &ft5x0x_ts->resume_work);
 }
 
 static void ft5x0x_ts_resume_work(struct work_struct *work)
 {
-	pr_info("==%s==\n", __FUNCTION__);
+	printk("==%s==\n", __FUNCTION__);
+
+	irq_set_irq_type(this_client->irq, IRQF_TRIGGER_FALLING);
 	ft5x0x_ts_reset();
-	//ft5x0x_write_reg(FT5X0X_REG_PERIODACTIVE, 7);
+	ft5x0x_write_reg(FT5X0X_REG_PERIODACTIVE, 7);
 	enable_irq(this_client->irq);
 	msleep(2);
 	ft5x0x_clear_report_data(g_ft5x0x_ts);
@@ -655,16 +1556,30 @@
 }
 #endif
 
-static void ft5x0x_ts_hw_init(struct ft5x0x_ts_data *ft5x0x_ts)
+static int ft5x0x_ts_hw_init(struct ft5x0x_ts_data *ft5x0x_ts)
 {
-	struct regulator *reg_vdd;
+	struct regulator *reg_vdd,*reg_vdd1v8;
 	struct i2c_client *client = ft5x0x_ts->client;
 	struct ft5x0x_ts_platform_data *pdata = ft5x0x_ts->platform_data;
 
-	pr_info("[FST] %s [irq=%d];[rst=%d]\n",__func__,
+	printk("ft5x0x_ts_hw_init %s [irq=%d];[rst=%d]\n",__func__,
 		pdata->irq_gpio_number,pdata->reset_gpio_number);
-	gpio_request(pdata->irq_gpio_number, "ts_irq_pin");
-	gpio_request(pdata->reset_gpio_number, "ts_rst_pin");
+	if(gpio_request(pdata->irq_gpio_number, "ts_irq_pin") < 0)
+	{
+		printk("ft5x0x_ts_hw_init  request=%d fail!\n",pdata->irq_gpio_number);
+		return -1;
+	}
+	if(gpio_request(pdata->reset_gpio_number, "ts_rst_pin") < 0)
+	{
+		printk("ft5x0x_ts_hw_init  request=%d fail!\n",pdata->reset_gpio_number);
+		gpio_free(pdata->irq_gpio_number);
+		return -1;
+	}
+	
+#ifdef CONFIG_I2C_SPRD
+	sprd_i2c_ctl_chg_clk(client->adapter->nr, 100000);
+#endif
+
 	gpio_direction_output(pdata->reset_gpio_number, 1);
 	gpio_direction_input(pdata->irq_gpio_number);
 
@@ -676,8 +1591,15 @@
 			regulator_set_voltage(reg_vdd, 2800000, 2800000);
 		regulator_enable(reg_vdd);
 	}
+
+	reg_vdd1v8 = regulator_get(&client->dev, "vdd18");
+	if (!WARN(IS_ERR(reg_vdd1v8), "[FST] ft5x0x_ts_hw_init regulator: failed to get vdd18.\n")) {
+		regulator_set_voltage(reg_vdd1v8,1800000,1800000);
+		regulator_enable(reg_vdd1v8);
+	}
 	msleep(100);
-	ft5x0x_ts_reset();
+	ft5x0x_ts_reset_init();
+	return 0;
 }
 
 void focaltech_get_upgrade_array(struct i2c_client *client)
@@ -688,7 +1610,7 @@
 
 	i2c_smbus_read_i2c_block_data(client,FT_REG_CHIP_ID,1,&chip_id);
 
-	printk("%s chip_id = %x\n", __func__, chip_id);
+	printk("%s chip_id = 0x%x\n", __func__, chip_id);
 
 	for(i=0;i<sizeof(fts_updateinfo)/sizeof(struct Upgrade_Info);i++)
 	{
@@ -698,7 +1620,7 @@
 			break;
 		}
 	}
-
+	printk("%s chip_id = 0x%x, i = %d\n", __func__, chip_id,i);
 	if(i >= sizeof(fts_updateinfo)/sizeof(struct Upgrade_Info))
 	{
 		memcpy(&fts_updateinfo_curr, &fts_updateinfo[0], sizeof(struct Upgrade_Info));
@@ -705,14 +1627,81 @@
 	}
 }
 
+#if 0
+extern char * get_tp_module_info(void);
+
+static void ft5x0x_set_module_info(void)
+{
+	char * module_info;
+	unsigned char minor = 0xff;
+	char err=0;
+
+	module_info = get_tp_module_info();
+
+	strcpy(module_info, fts_updateinfo_curr.FTS_NAME);
+	module_info += strlen(fts_updateinfo_curr.FTS_NAME);
+	*module_info++ = 0x20;
+
+	err = ft5x0x_read_reg(FT_REG_FW_VER, &minor);
+	if (err < 0)
+	{
+		*module_info = '\0';
+		printk("[FST] %s read FW version error %d\n", __func__, err);
+	}
+	else
+	{
+		sprintf(module_info, "Firmware Version 0x%x", minor);
+	}
+}
+#endif
+#ifdef CTP_EXCHANGE_KEY
+static ssize_t ctp_key_define_write(struct file *f, char __user *buf, size_t count, loff_t *pos)
+{
+	if(copy_from_user(&tp_setkey_define, buf, sizeof(tp_setkey_define)))
+	{
+		printk("__ctp_key_define_write__: call copy_from_user() fail!!\r\n");
+		return -EFAULT;
+	}
+
+	printk("__ctp_key_define_write__: tp_setkey_define = %d\r\n", tp_setkey_define);
+
+	tp_setkey_define &= 0x1;
+
+	return count;
+}
+
+
+static int ctp_key_define_open(struct inode *inode, struct file *f)
+{
+	return 0;
+}
+
+static int ctp_key_define_release(struct inode *inode, struct file *f)
+{
+	return 0;
+}
+
+static const struct file_operations ctp_key_define_fops = {
+	.owner = THIS_MODULE,
+	.open = ctp_key_define_open,
+	.release = ctp_key_define_release,
+	.write = ctp_key_define_write,
+};
+
+static struct miscdevice ctp_key_define_struct = {
+	.name = "tp_setkey",
+	.fops = &ctp_key_define_fops,
+	.minor = MISC_DYNAMIC_MINOR,
+};
+#endif
+
 #ifdef CONFIG_OF
 static struct ft5x0x_ts_platform_data *ft5x0x_ts_parse_dt(struct device *dev)
 {
 	struct ft5x0x_ts_platform_data *pdata;
 	struct device_node *np = dev->of_node;
-	int ret,i = 0;
-	u32 data[12] = {0};
-	u32 tmp_val_u32;
+	int ret;
+
 	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
 	if (!pdata) {
 		dev_err(dev, "Could not allocate struct ft5x0x_ts_platform_data");
@@ -733,26 +1722,22 @@
 		dev_err(dev, "fail to get vdd_name\n");
 		goto fail;
 	}
-	ret = of_property_read_u32_array(np, "virtualkeys", data,12);
+	ret = of_property_read_u32_array(np, "virtualkeys", &pdata->virtualkeys,12);
 	if(ret){
 		dev_err(dev, "fail to get virtualkeys\n");
 		goto fail;
 	}
-	for(i = 0; i < 12; i ++){
-		pdata->virtualkeys[i] = data[i];
-	}
-	ret = of_property_read_u32(np, "TP_MAX_X", &tmp_val_u32);
+	ret = of_property_read_u32(np, "TP_MAX_X", &pdata->TP_MAX_X);
 	if(ret){
 		dev_err(dev, "fail to get TP_MAX_X\n");
 		goto fail;
 	}
-	pdata->TP_MAX_X = tmp_val_u32;
-	ret = of_property_read_u32(np, "TP_MAX_Y", &tmp_val_u32);
+	ret = of_property_read_u32(np, "TP_MAX_Y", &pdata->TP_MAX_Y);
 	if(ret){
 		dev_err(dev, "fail to get TP_MAX_Y\n");
 		goto fail;
 	}
-	pdata->TP_MAX_Y = tmp_val_u32;
+
 	return pdata;
 fail:
 	kfree(pdata);
@@ -761,6 +1746,197 @@
 #endif
 
 
+#ifdef FT6x36_DOWNLOAD
+
+int ft5x0x_download_i2c_Read(unsigned char *writebuf,
+            int writelen, unsigned char *readbuf, int readlen)
+{
+    int ret;
+
+	ret=fts_i2c_Read(g_i2c_client, writebuf,writelen,readbuf,readlen);
+  
+    return ret;
+}
+/*write data by i2c*/
+int ft5x0x_download_i2c_Write(unsigned char *writebuf, int writelen)
+{
+    int ret;
+
+   ret=fts_i2c_Write(g_i2c_client, writebuf,writelen);
+
+    return ret;
+}
+
+
+int ft6x36_Enter_Debug(void)
+{
+    ft5x0x_ts_reset();
+   // msleep(2); 
+	pr_info("ft6x36_Enter_Debug\n");
+    return ft6x36_Lib_Enter_Download_Mode();
+}
+//if return 0, main flash is ok, else download.
+int ft6x36_IsDownloadMain(void)
+{
+    //add condition to check main flash
+    return -1;
+}
+int ft6x36_DownloadMain(void)
+{
+    unsigned short fwlen = 0;
+	pr_info("ft6x36_DownloadMain 1");
+    if (ft6x36_Enter_Debug() < 0) {
+        pr_info("-----enter debug mode failed\n");
+        return -1;
+    }
+	pr_info("ft6x36_DownloadMain 2");
+	if(1 == TP_VOL){
+	    fwlen = sizeof(CTPM_MAIN_FW1);
+	    pr_info("wangcq327 ---1 ----fwlen=%d\n", fwlen);
+
+	    //return ft6x06_Lib_DownloadMain(CTPM_MAIN_FW, fwlen);
+	    return ft6x36_Lib_DownloadMain(CTPM_MAIN_FW1,fwlen);
+	}else if(0 == TP_VOL){
+	    fwlen = sizeof(CTPM_MAIN_FW2);
+	    pr_info("wangcq327 ---2 ----fwlen=%d\n", fwlen);
+
+	    //return ft6x06_Lib_DownloadMain(CTPM_MAIN_FW, fwlen);
+	    return ft6x36_Lib_DownloadMain(CTPM_MAIN_FW2,fwlen);	
+	}
+	return -1;
+}
+
+#if 1
+//wangcq327 --- add start
+int Check_TP_ID(void)
+{
+		int data[4] = {0};
+		int res = 0;
+		int rawdata = 0;
+		int tp_vol = 0;
+#define AUXADC_TP_VOLTAGE_CHANNEL 1
+#ifdef AUXADC_TP_VOLTAGE_CHANNEL
+		extern int sci_adc_get_value(unsigned chan, int scale);
+		rawdata = sci_adc_get_value(AUXADC_TP_VOLTAGE_CHANNEL,false);
+		if(rawdata < 0)
+		{ 
+#ifdef BUILD_LK
+				printf("[adc_uboot]: get data error\n");
+#endif
+				return 0;
+
+		}
+#endif
+		//tp_vol = data[0]*1000+data[1]*10;
+		//printk("wangcq327 --- data[0]:%d  data[1]:%d  tp_vol:%d\n",data[0],data[1],tp_vol);
+		printk("yedongyue ----------adc value= %d----------\n",rawdata);
+		if(rawdata >2700 && rawdata < 3300){
+			return TP_VOL = 0;
+		}
+		else if(rawdata < 4400 && rawdata > 3800){
+			return TP_VOL = 1;
+		}
+		else{
+			return TP_VOL = -1;
+		}
+}
+//wangcq327 --- add end
+#endif
+int fts_ctpm_auto_download(struct i2c_client *client)
+{
+	u8 uc_host_fm_ver = FT_REG_FW_VER;
+	u8 uc_tp_fm_ver;
+	u8 uc_host_vendor_id = FT_REG_VENDOR_ID;
+	u8 uc_tp_vendor_id=0;
+	int i_ret;
+
+    //fts_read_reg(client, FT_REG_VENDOR_ID, &uc_tp_vendor_id);
+	//uc_host_vendor_id = fts_ctpm_get_i_file_vendor();
+	//if(uc_tp_vendor_id!=uc_host_vendor_id)return 0;
+	//wangcq327 --- add start	   
+	fts_read_reg(client, FT_REG_VENDOR_ID,&uc_tp_vendor_id);
+	printk("  yedongyue wangcq327 --- uc_tp_vendor_id == %d\n",uc_tp_vendor_id);
+	printk("wangcq327 --- ID_pin_vol == %d \n",Check_TP_ID());
+	//TP_VOL = 1;
+	if(TP_VOL == 1){
+			fts_read_reg(client, FT_REG_FW_VER, &uc_tp_fm_ver);
+			uc_host_fm_ver =CTPM_MAIN_FW1[0x90a];// fts_ctpm_get_i_file_ver();
+			uc_host_vendor_id=CTPM_MAIN_FW1[0x908];
+			pr_info("wangcq327 --- [FTS] uc_tp_fm_ver = 0x%x, uc_host_fm_ver = 0x%x\n",uc_tp_fm_ver, uc_host_fm_ver);
+			if(uc_tp_fm_ver >= uc_host_fm_ver && uc_tp_vendor_id == uc_host_vendor_id)  return -1;
+		//}else if(uc_tp_vendor_id != 0x49) {
+			//return -1;
+		//};
+
+	}else if(0 == TP_VOL){
+		//if(uc_tp_vendor_id == 0x49) {
+			fts_read_reg(client, FT_REG_FW_VER, &uc_tp_fm_ver);
+			uc_host_fm_ver =CTPM_MAIN_FW2[0x90a];// fts_ctpm_get_i_file_ver();
+			uc_host_vendor_id=CTPM_MAIN_FW2[0x908];
+			if(uc_tp_fm_ver >= uc_host_fm_ver && uc_tp_vendor_id == uc_host_vendor_id )  return -1;
+		//}else if(uc_tp_vendor_id != 0xd1){
+	//		return -1;
+		//};
+
+	}else{
+		printk("wangcq327 --- ID_pin_vol error!!! \n");
+		return -1;
+	}
+//wangcq327 --- add end
+       pr_info("wangcq327 --- [FTS] uc_tp_fm_ver = 0x%x, uc_host_fm_ver = 0x%x\n",uc_tp_fm_ver, uc_host_fm_ver);
+
+#if 0 
+	   if (/*the firmware in touch panel maybe corrupted */
+		uc_tp_fm_ver == FT_REG_FW_VER ||
+		/*the firmware in host flash is new, need upgrade */
+	     uc_tp_fm_ver < uc_host_fm_ver ||
+
+	    ) 
+#endif
+	    {
+			g_i2c_client = client;
+        	FTS_I2c_Read_Function fun_i2c_read = ft5x0x_download_i2c_Read;
+        	FTS_I2c_Write_Function fun_i2c_write = ft5x0x_download_i2c_Write;
+        	Init_I2C_Read_Func(fun_i2c_read);
+        	Init_I2C_Write_Func(fun_i2c_write);
+        	 if(ft6x36_IsDownloadMain() < 0)
+        	 {
+				#if 1
+					pr_info("--------FTS---------download main\n");
+					if(ft6x36_DownloadMain()<0)
+					{
+						pr_info("---------FTS---------Download main failed\n");
+					}
+				#endif
+        	 } else
+        		pr_info("--------FTS---------no download main\n");
+		}
+
+	return 0;
+}
+#endif
+#ifdef TP_READ_VER
+static int get_tp_ver_proc(struct file *file, char *buffer, size_t count, loff_t *ppos)
+{
+	int data;
+	long err = 0;
+	 printk("focal_fn: firmware_version_store\n");
+	data=ft5x0x_read_fw_ver();
+	 printk("***FW Version tpd_info_read = %d***\n", data);
+
+	if(copy_to_user(buffer, &data, sizeof(data)))
+	{
+		return -EFAULT;
+	}
+        printk("tp_ver:0x%x\n",data);
+	return count;
+}
+
+static const struct file_operations gt_tp_ver_proc_fops = { 
+    .read = get_tp_ver_proc
+};
+#endif
+
 static int ft5x0x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
 	struct ft5x0x_ts_data *ft5x0x_ts;
@@ -768,11 +1944,12 @@
 	struct ft5x0x_ts_platform_data *pdata = client->dev.platform_data;
 	int err = 0;
 	unsigned char uc_reg_value;
-	//u8 chip_id,i;
+	u8 chip_id,i;
 
-	pr_info("[FST] %s: probe\n",__func__);
+	printk("ft5x0x_ts_probe   probe\n");
 #ifdef CONFIG_OF
-	if (client->dev.of_node && !pdata){
+	struct device_node *np = client->dev.of_node;
+	if (np && !pdata){
 		pdata = ft5x0x_ts_parse_dt(&client->dev);
 		if(pdata){
 			client->dev.platform_data = pdata;
@@ -785,9 +1962,22 @@
 #endif
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
 		err = -ENODEV;
+		printk("ft5x0x_ts_probe  ic2 error!\n");
 		goto exit_check_functionality_failed;
 	}
 
+#ifdef TOUCH_USE_SIM2_POWER
+	vddsim2_regulator = regulator_get(NULL, "vddsim2");
+	if (IS_ERR(vddsim2_regulator))
+	{
+		printk("ft5x0x_ts_probe: regulator_get vddsim2 error!!\n");
+		goto exit_check_functionality_failed;
+	}
+
+	regulator_set_voltage(vddsim2_regulator, 2800000, 2800000);
+	regulator_enable(vddsim2_regulator);
+#endif
+
 	ft5x0x_ts = kzalloc(sizeof(*ft5x0x_ts), GFP_KERNEL);
 	if (!ft5x0x_ts)	{
 		err = -ENOMEM;
@@ -798,24 +1988,26 @@
 	ft5x0x_ts->platform_data = pdata;
 	this_client = client;
 	ft5x0x_ts->client = client;
-	ft5x0x_ts_hw_init(ft5x0x_ts);
+
+	if(ft5x0x_ts_hw_init(ft5x0x_ts) < 0)
+	{
+		printk("ft5x0x_ts_probe: hw_init error!\n");
+		err = -ENOMEM;
+		goto exit_chip_init_hw_failed;
+	}
 	i2c_set_clientdata(client, ft5x0x_ts);
 	client->irq = gpio_to_irq(pdata->irq_gpio_number);
 
-	#if(defined(CONFIG_I2C_SPRD) || defined(CONFIG_I2C_SPRD_V1))
-	sprd_i2c_ctl_chg_clk(client->adapter->nr, 400000);
-	#endif
-
 	err = ft5x0x_read_reg(FT5X0X_REG_CIPHER, &uc_reg_value);
 	if (err < 0)
 	{
-		pr_err("[FST] read chip id error %x\n", uc_reg_value);
+		printk("ft5x0x_ts_probe read chip id error %x\n", uc_reg_value);
 		err = -ENODEV;
 		goto exit_chip_check_failed;
 	}
-       
+
 	/* set report rate, about 70HZ */
-	//ft5x0x_write_reg(FT5X0X_REG_PERIODACTIVE, 7);
+	ft5x0x_write_reg(FT5X0X_REG_PERIODACTIVE, 7);
 #if USE_WORK_QUEUE
 	INIT_WORK(&ft5x0x_ts->pen_event_work, ft5x0x_ts_pen_irq_work);
 
@@ -852,6 +2044,22 @@
 	__set_bit(KEY_MENU,  input_dev->keybit);
 	__set_bit(KEY_BACK,  input_dev->keybit);
 	__set_bit(KEY_HOMEPAGE,  input_dev->keybit);
+	__set_bit(KEY_POWER,  input_dev->keybit);
+	__set_bit(KEY_LEFT,  input_dev->keybit);
+	__set_bit(KEY_RIGHT,  input_dev->keybit);
+	__set_bit(KEY_UP,  input_dev->keybit);
+	__set_bit(KEY_DOWN,  input_dev->keybit);
+	__set_bit(KEY_U,  input_dev->keybit);
+	__set_bit(KEY_O,  input_dev->keybit);
+	__set_bit(KEY_W,  input_dev->keybit);
+	__set_bit(KEY_M,  input_dev->keybit);
+	__set_bit(KEY_E,  input_dev->keybit);
+	__set_bit(KEY_C,  input_dev->keybit);
+	__set_bit(KEY_P,  input_dev->keybit);
+	__set_bit(KEY_S,  input_dev->keybit);
+	__set_bit(KEY_V,  input_dev->keybit);
+	__set_bit(KEY_Z,  input_dev->keybit);
+	__set_bit(KEY_A,  input_dev->keybit);
 	__set_bit(BTN_TOUCH, input_dev->keybit);
 
 #if MULTI_PROTOCOL_TYPE_B
@@ -884,21 +2092,25 @@
 	set_bit(EV_ABS, input_dev->evbit);
 	set_bit(EV_KEY, input_dev->evbit);
 
+	input_set_capability(input_dev, EV_KEY, KEY_MENU);
+	input_set_capability(input_dev, EV_KEY, KEY_BACK);
+	input_set_capability(input_dev, EV_KEY, KEY_HOMEPAGE);
+
+	virtual_last_keymap = 0;
+
 	input_dev->name = FOCALTECH_TS_NAME;
 	err = input_register_device(input_dev);
 	if (err) {
-		dev_err(&client->dev,
-		"[FST] ft5x0x_ts_probe: failed to register input device: %s\n",
-		dev_name(&client->dev));
+		printk("ft5x0x_ts_probe: failed to register input device: %s\n", input_dev->name);
 		goto exit_input_register_device_failed;
 	}
 
 #if USE_THREADED_IRQ
 	err = request_threaded_irq(client->irq, NULL, ft5x0x_ts_interrupt, 
-		IRQF_TRIGGER_FALLING | IRQF_ONESHOT, client->name, ft5x0x_ts);
+		IRQF_TRIGGER_FALLING | IRQF_ONESHOT | IRQF_NO_SUSPEND, client->name, ft5x0x_ts);
 #else
 	err = request_irq(client->irq, ft5x0x_ts_interrupt,
-		IRQF_TRIGGER_FALLING | IRQF_ONESHOT, client->name, ft5x0x_ts);
+		IRQF_TRIGGER_FALLING | IRQF_ONESHOT | IRQF_NO_SUSPEND, client->name, ft5x0x_ts);
 #endif
 	if (err < 0) {
 		dev_err(&client->dev, "[FST] ft5x0x_probe: request irq failed %d\n",err);
@@ -912,24 +2124,52 @@
 	register_early_suspend(&ft5x0x_ts->early_suspend);
 #endif
 
-focaltech_get_upgrade_array(client);
+	focaltech_get_upgrade_array(client);
 
 #ifdef SYSFS_DEBUG	
-fts_create_sysfs(client);
+	fts_create_sysfs(client);
 #endif
 
 #ifdef FTS_CTL_IIC	
-if (ft_rw_iic_drv_init(client) < 0)	
-{
-	dev_err(&client->dev, "%s:[FTS] create fts control iic driver failed\n",	__func__);
-}
+	if (ft_rw_iic_drv_init(client) < 0)	
+	{
+		dev_err(&client->dev, "%s:[FTS] create fts control iic driver failed\n",	__func__);
+	}
 #endif
 
+#ifdef FTS_GESTRUE
+	if (misc_register(&fts_gestrue_struct) < 0)
+	{
+		printk("%s: Creat fts_gestrue_struct device file error!!\n", __func__);
+	}
+#endif
+
+#ifdef TP_READ_VER
+    //Get firmware version
+	tp_ver_proc = proc_create(TP_VER_PROC_FILE, 0664, NULL, &gt_tp_ver_proc_fops);
+	if (tp_ver_proc == NULL)
+	{
+		printk("create_proc_entry %s failed\n", TP_VER_PROC_FILE);
+	}
+
+#endif
+
+#ifdef CTP_EXCHANGE_KEY
+	if (misc_register(&ctp_key_define_struct) < 0)
+	{
+		printk("Creat ctp_key_define_struct device file error!!\n");
+	}
+#endif
+
 #ifdef SPRD_AUTO_UPGRADE
 	printk("********************Enter CTP Auto Upgrade********************\n");
 	fts_ctpm_auto_upgrade(client);
 #endif   
 
+#ifdef FT6x36_DOWNLOAD
+	fts_ctpm_auto_download(client);
+#endif
+
 #ifdef APK_DEBUG
 	ft5x0x_create_apk_debug_channel(client);
 #endif
@@ -943,6 +2183,42 @@
 	}
 #endif
 
+#ifdef TPD_PROXIMITY
+	err = misc_register(&focaltech_pls_device);
+	if (err)
+	{
+		APS_ERR("%s: focaltech_pls_device register failed err = %d \n", __func__,err);
+	}
+	focaltech_pls_input_dev = input_allocate_device();
+	if (!focaltech_pls_input_dev) 
+	{
+		APS_ERR("%s: input allocate device failed\n", __func__);
+	}
+	else
+	{
+		focaltech_pls_input_dev->name = FOCALTECH_PLS_INPUT_NAME;
+		focaltech_pls_input_dev->phys  = FOCALTECH_PLS_INPUT_NAME;
+		focaltech_pls_input_dev->id.bustype = BUS_I2C;
+		focaltech_pls_input_dev->dev.parent = &client->dev;
+		focaltech_pls_input_dev->id.vendor = 0x0001;
+		focaltech_pls_input_dev->id.product = 0x0001;
+		focaltech_pls_input_dev->id.version = 0x0010;
+		__set_bit(EV_ABS, focaltech_pls_input_dev->evbit);	
+		input_set_abs_params(focaltech_pls_input_dev, ABS_DISTANCE, 0, 1, 0, 0);
+		input_set_abs_params(focaltech_pls_input_dev, ABS_MISC, 0, 100001, 0, 0);
+		err = input_register_device(focaltech_pls_input_dev);
+		if (err < 0)
+		{
+			APS_ERR("%s: input device regist failed err = %d \n", __func__,err);
+		}
+#ifdef WAKE_LOCK_LPSENSOR
+		wake_lock_init(&pls_delayed_work_wake_lock, WAKE_LOCK_SUSPEND, "pm_pls_delayed_wakelock_focaltech");
+#endif
+	}
+#endif
+
+	//ft5x0x_set_module_info();
+
 	return 0;
 
 exit_irq_request_failed:
@@ -954,8 +2230,14 @@
 exit_chip_check_failed:
 	gpio_free(pdata->irq_gpio_number);
 	gpio_free(pdata->reset_gpio_number);
+exit_chip_init_hw_failed:
 	kfree(ft5x0x_ts);
 exit_alloc_data_failed:
+#ifdef TOUCH_USE_SIM2_POWER
+	regulator_disable(vddsim2_regulator);
+	regulator_put(vddsim2_regulator);
+	vddsim2_regulator = NULL;
+#endif
 exit_check_functionality_failed:
 	ft5x0x_ts = NULL;
 	i2c_set_clientdata(client, ft5x0x_ts);
@@ -997,12 +2279,28 @@
 	ft5x0x_ts = NULL;
 	i2c_set_clientdata(client, ft5x0x_ts);
 
+#ifdef TOUCH_USE_SIM2_POWER
+	regulator_disable(vddsim2_regulator);
+	regulator_put(vddsim2_regulator);
+	vddsim2_regulator = NULL;
+#endif
+
+#ifdef TPD_PROXIMITY
+	misc_deregister(&focaltech_pls_device);
+	input_unregister_device(focaltech_pls_input_dev);
+	input_free_device(focaltech_pls_input_dev);
+	focaltech_pls_input_dev = NULL;
+#ifdef WAKE_LOCK_LPSENSOR
+	wake_lock_destroy(&pls_delayed_work_wake_lock);
+#endif
+#endif
+
 	return 0;
 }
 
-static const struct i2c_device_id ft5x0x_ts_id[] = {
-	{ FOCALTECH_TS_NAME, 0 },{ }
-};
+//static const struct i2c_device_id ft5x0x_ts_id[] = {
+//	{ FOCALTECH_TS_NAME, 0 },{ }
+//};
 
 static int ft5x0x_suspend(struct i2c_client *client, pm_message_t mesg)
 {
@@ -1015,13 +2313,17 @@
 	return 0;
 }
 
+static const struct i2c_device_id ft5x0x_ts_id[] = {
+	{FOCALTECH_TS_NAME, FOCALTECH_TS_ADDR},
+	{ }
+};
 MODULE_DEVICE_TABLE(i2c, ft5x0x_ts_id);
 
-static const struct of_device_id focaltech_of_match[] = {
+static const struct of_device_id ft5x0x_of_match[] = {
        { .compatible = "focaltech,focaltech_ts", },
        { }
 };
-MODULE_DEVICE_TABLE(of, focaltech_of_match);
+MODULE_DEVICE_TABLE(of, ft5x0x_of_match);
 static struct i2c_driver ft5x0x_ts_driver = {
 	.probe		= ft5x0x_ts_probe,
 	.remove		= ft5x0x_ts_remove,
@@ -1029,7 +2331,7 @@
 	.driver	= {
 		.name	= FOCALTECH_TS_NAME,
 		.owner	= THIS_MODULE,
-		.of_match_table = focaltech_of_match,
+		.of_match_table = ft5x0x_of_match,
 	},
 	.suspend = NULL,
 	.resume = NULL,
Index: kernel/drivers/input/touchscreen/focaltech/focaltech_ex_fun.c
===================================================================
--- kernel/drivers/input/touchscreen/focaltech/focaltech_ex_fun.c	(revision 166571)
+++ kernel/drivers/input/touchscreen/focaltech/focaltech_ex_fun.c	(revision 166572)
@@ -1,3 +1,4 @@
+
 /*
  *drivers/input/touchscreen/ft5x06_ex_fun.c
  *
@@ -18,15 +19,23 @@
  */
 
 //#include "tpd.h"
+
 //#include "tpd_custom_fts.h"
+
+
+
 #include <linux/netdevice.h>
 #include <linux/mount.h>
 //#include <linux/netdevice.h>
 #include <linux/proc_fs.h>
+
 #include <linux/i2c/focaltech.h>
 #include <linux/i2c/focaltech_ex_fun.h>
 #include <linux/i2c/focaltech_ctl.h>
 
+
+
+
 static struct mutex g_device_mutex;
 extern void mt65xx_eint_unmask(unsigned int line);
 extern void mt65xx_eint_mask(unsigned int line);
@@ -36,34 +45,16 @@
 
 extern struct Upgrade_Info fts_updateinfo_curr;
 
+#ifdef SPRD_AUTO_UPGRADE
 int fts_ctpm_fw_upgrade(struct i2c_client *client, u8 *pbt_buf,
 			  u32 dw_lenth);
 
-static unsigned char FT6306_FW[] = {
-#include "FT6x06_4Column_Ver0x12_20150227_app.h"
+static unsigned char CTPM_FW[] = {
+#include "FT6336S_L50A_CBF4952-4.5_Ver0X11_20150324_app.i"
 };
 
-static unsigned char FT5316_FW[] = {
-#include "Ft5x16_720P_Ver0x23_test_app.h"
-};
-
-#define CONFIG_TOUCHSCREEN_FIRMWARE_UPGRADE
-static unsigned char LIANCHUANG_FW[] = {
-#include "lianchuang_Ver0x39__20151130_app.h"
-};
-
-#ifdef CONFIG_MACH_SPWHALE_5MODEB
-static unsigned char SPWHALE_FW[] = {
-#include "FT5336_TD-LTE9620_Ver0x11_20140311_app.h"
-};
 #endif
 
-static unsigned char FT_FW_NULL[] = {
-};
-
-static unsigned char *CTPM_FW = FT_FW_NULL;
-static u32 fw_size = 0;
-
 static DEFINE_MUTEX(g_device_mutex);
 
 /*
@@ -288,55 +279,473 @@
 }
 
 
-/*
-upgrade with *.i file
-*/
-int fts_ctpm_fw_upgrade_with_i_file(struct i2c_client *client)
+int hid_to_i2c(struct i2c_client * client)
 {
-	u8 *pbt_buf = NULL;
+	u8 auc_i2c_write_buf[5] = {0};
+	int bRet = 0;
+
+	auc_i2c_write_buf[0] = 0xeb;
+	auc_i2c_write_buf[1] = 0xaa;
+	auc_i2c_write_buf[2] = 0x09;
+
+	fts_i2c_Write(client, auc_i2c_write_buf, 3);
+
+	msleep(10);
+
+	auc_i2c_write_buf[0] = auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = 0;
+
+	fts_i2c_Read(client, auc_i2c_write_buf, 0, auc_i2c_write_buf, 3);
+
+	if(0xeb==auc_i2c_write_buf[0] && 0xaa==auc_i2c_write_buf[1] && 0x08==auc_i2c_write_buf[2])
+	{
+		bRet = 1;		
+	}
+	else bRet = 0;
+
+	return bRet;
+	
+}
+
+
+int  fts_5x46_ctpm_fw_upgrade(struct i2c_client * client, u8* pbt_buf, u32 dw_lenth)
+{
+	
+	u8 reg_val[4] = {0};
+	u32 i = 0;
+	u32 packet_number;
+	u32 j;
+	u32 temp;
+	u32 lenght;
+	u8 packet_buf[FTS_PACKET_LENGTH + 6];
+	u8 auc_i2c_write_buf[10];
+	u8 bt_ecc;
 	int i_ret;
-	//int fw_len = sizeof(CTPM_FW);
 
-	/*judge the fw that will be upgraded
-	* if illegal, then stop upgrade and return.
-	*/
-	if (fw_size < 8 || fw_size > 32 * 1024) {
-		dev_err(&client->dev, "%s:FW length error\n", __func__);
+	i_ret = hid_to_i2c(client);
+
+	if(i_ret == 0)
+	{
+		printk("[FTS] hid change to i2c fail ! \n");
+	}
+
+	for (i = 0; i < FTS_UPGRADE_LOOP; i++) {
+		/*********Step 1:Reset  CTPM *****/
+		/*write 0xaa to register 0xfc */
+		fts_write_reg(client, 0xfc, FT_UPGRADE_AA);
+		msleep(fts_updateinfo_curr.delay_aa);
+
+		//write 0x55 to register 0xfc 
+		fts_write_reg(client, 0xfc, FT_UPGRADE_55);
+		msleep(200);
+		/*********Step 2:Enter upgrade mode *****/
+		i_ret = hid_to_i2c(client);
+
+		if(i_ret == 0)
+		{
+			printk("[FTS] hid change to i2c fail ! \n");
+			continue;
+		}
+		msleep(10);
+		auc_i2c_write_buf[0] = FT_UPGRADE_55;
+		auc_i2c_write_buf[1] = FT_UPGRADE_AA;
+		i_ret = fts_i2c_Write(client, auc_i2c_write_buf, 2);
+		if(i_ret < 0)
+		{
+			printk("[FTS] failed writing  0x55 and 0xaa ! \n");
+			continue;
+		}
+
+		/*********Step 3:check READ-ID***********************/
+		msleep(1);
+		auc_i2c_write_buf[0] = 0x90;
+		auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = auc_i2c_write_buf[3] =
+			0x00;
+		
+		reg_val[0] = reg_val[1] = 0x00;
+		
+		fts_i2c_Read(client, auc_i2c_write_buf, 4, reg_val, 2);
+
+		if (reg_val[0] == fts_updateinfo_curr.upgrade_id_1
+			&& reg_val[1] == fts_updateinfo_curr.upgrade_id_2) {
+			printk("[FTS] Step 3: READ OK CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+			break;
+		} else {
+			dev_err(&client->dev, "[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+			
+			continue;
+		}
+	}
+	if (i >= FTS_UPGRADE_LOOP )
 		return -EIO;
+
+	/*Step 4:erase app and panel paramenter area*/
+	printk("Step 4:erase app and panel paramenter area\n");
+	auc_i2c_write_buf[0] = 0x61;
+	fts_i2c_Write(client, auc_i2c_write_buf, 1);	//erase app area 
+	msleep(1350);
+
+	for(i = 0;i < 15;i++)
+	{
+		auc_i2c_write_buf[0] = 0x6a;
+		reg_val[0] = reg_val[1] = 0x00;
+		fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 2);
+
+		if(0xF0==reg_val[0] && 0xAA==reg_val[1])
+		{
+			break;
+		}
+		msleep(50);
+		
 	}
 
-	if ((CTPM_FW[fw_size - 8] ^ CTPM_FW[fw_size - 6]) == 0xFF
-		&& (CTPM_FW[fw_size - 7] ^ CTPM_FW[fw_size - 5]) == 0xFF
-		&& (CTPM_FW[fw_size - 3] ^ CTPM_FW[fw_size - 4]) == 0xFF) {
-		/*FW upgrade */
-		pbt_buf = CTPM_FW;
-		/*call the upgrade function */
-		i_ret = fts_ctpm_fw_upgrade(client, pbt_buf, fw_size);
-		if (i_ret != 0)
-			dev_err(&client->dev, "%s:upgrade failed. err.\n",
-					__func__);
-		else if(fts_updateinfo_curr.AUTO_CLB==AUTO_CLB_NEED)
-			fts_ctpm_auto_clb(client);	/*start auto CLB */
+	auc_i2c_write_buf[0] = 0xB0;
+	auc_i2c_write_buf[1] = (u8) ((dw_lenth >> 16) & 0xFF);
+	auc_i2c_write_buf[2] = (u8) ((dw_lenth >> 8) & 0xFF);
+	auc_i2c_write_buf[3] = (u8) (dw_lenth & 0xFF);
 
-	} else {
-		dev_err(&client->dev, "%s:FW format error\n", __func__);
-		return -EBADFD;
+	fts_i2c_Write(client, auc_i2c_write_buf, 4);
+
+	/*********Step 5:write firmware(FW) to ctpm flash*********/
+	bt_ecc = 0;
+	printk("Step 5:write firmware(FW) to ctpm flash\n");
+	temp = 0;
+	packet_number = (dw_lenth) / FTS_PACKET_LENGTH;
+	packet_buf[0] = 0xbf;
+	packet_buf[1] = 0x00;
+
+	for (j = 0; j < packet_number; j++) {
+		temp = j * FTS_PACKET_LENGTH;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		lenght = FTS_PACKET_LENGTH;
+		packet_buf[4] = (u8) (lenght >> 8);
+		packet_buf[5] = (u8) lenght;
+
+		for (i = 0; i < FTS_PACKET_LENGTH; i++) {
+			packet_buf[6 + i] = pbt_buf[j * FTS_PACKET_LENGTH + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}
+		fts_i2c_Write(client, packet_buf, FTS_PACKET_LENGTH + 6);
+
+		for(i = 0;i < 30;i++)
+		{
+			auc_i2c_write_buf[0] = 0x6a;
+			reg_val[0] = reg_val[1] = 0x00;
+			fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 2);
+
+			if ((j + 0x1000) == (((reg_val[0]) << 8) | reg_val[1]))
+			{
+				break;
+			}
+			msleep(1);
+			
+		}
 	}
 
-	return i_ret;
+	if ((dw_lenth) % FTS_PACKET_LENGTH > 0) {
+		temp = packet_number * FTS_PACKET_LENGTH;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		temp = (dw_lenth) % FTS_PACKET_LENGTH;
+		packet_buf[4] = (u8) (temp >> 8);
+		packet_buf[5] = (u8) temp;
+
+		for (i = 0; i < temp; i++) {
+			packet_buf[6 + i] = pbt_buf[packet_number * FTS_PACKET_LENGTH + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}	
+		fts_i2c_Write(client, packet_buf, temp + 6);
+
+		for(i = 0;i < 30;i++)
+		{
+			auc_i2c_write_buf[0] = 0x6a;
+			reg_val[0] = reg_val[1] = 0x00;
+			fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 2);
+
+			if ((j + 0x1000) == (((reg_val[0]) << 8) | reg_val[1]))
+			{
+				break;
+			}
+			msleep(1);
+			
+		}
+	}
+
+	msleep(50);
+	
+	/*********Step 6: read out checksum***********************/
+	/*send the opration head */
+	printk("Step 6: read out checksum\n");
+	auc_i2c_write_buf[0] = 0x64;
+	fts_i2c_Write(client, auc_i2c_write_buf, 1); 
+	msleep(300);
+
+	temp = 0;
+	auc_i2c_write_buf[0] = 0x65;
+	auc_i2c_write_buf[1] = (u8)(temp >> 16);
+	auc_i2c_write_buf[2] = (u8)(temp >> 8);
+	auc_i2c_write_buf[3] = (u8)(temp);
+	temp = dw_lenth;
+	auc_i2c_write_buf[4] = (u8)(temp >> 8);
+	auc_i2c_write_buf[5] = (u8)(temp);
+	i_ret = fts_i2c_Write(client, auc_i2c_write_buf, 6); 
+	msleep(dw_lenth/256);
+
+	for(i = 0;i < 100;i++)
+	{
+		auc_i2c_write_buf[0] = 0x6a;
+		reg_val[0] = reg_val[1] = 0x00;
+		fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 2);
+
+		if (0xF0==reg_val[0] && 0x55==reg_val[1])
+		{
+			break;
+		}
+		msleep(1);
+			
+	}
+	auc_i2c_write_buf[0] = 0x66;
+	fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 1);
+	if (reg_val[0] != bt_ecc) 
+	{
+		dev_err(&client->dev, "[FTS]--ecc error! FW=%02x bt_ecc=%02x\n",
+					reg_val[0],
+					bt_ecc);
+				
+		return -EIO;
+	}
+	printk("checksum %X %X \n",reg_val[0],bt_ecc);	
+	/*********Step 7: reset the new FW***********************/
+	printk("Step 7: reset the new FW\n");
+	auc_i2c_write_buf[0] = 0x07;
+	fts_i2c_Write(client, auc_i2c_write_buf, 1);
+	msleep(130);	//make sure CTP startup normally 
+
+	return 0;
 }
 
-u8 fts_ctpm_get_i_file_ver(void)
+int fts_6x36_ctpm_fw_upgrade(struct i2c_client *client, u8 *pbt_buf,
+			  u32 dw_lenth)
 {
-	u16 ui_sz;
-	//ui_sz = sizeof(CTPM_FW);
-	ui_sz = fw_size;
-	if (ui_sz > 2)
-		return CTPM_FW[ui_sz - 2];
+	u8 reg_val[2] = {0};
+	u32 i = 0;
+	u32 packet_number;
+	u32 j;
+	u32 temp;
+	u32 lenght;
+	u32 fw_length;
+	u8 packet_buf[FTS_PACKET_LENGTH + 6];
+	u8 auc_i2c_write_buf[10];
+	u8 bt_ecc;
+	int i_ret;
 
-	return 0x00;	/*default value */
+
+	if(pbt_buf[0] != 0x02)
+	{
+		printk("[FTS] FW first byte is not 0x02. so it is invalid \n");
+		return -1;
+	}
+
+	if(dw_lenth > 0x11f)
+	{
+		fw_length = ((u32)pbt_buf[0x100]<<8) + pbt_buf[0x101];
+		if(dw_lenth < fw_length)
+		{
+			printk("[FTS] Fw length is invalid \n");
+			return -1;
+		}
+	}
+	else
+	{
+		printk("[FTS] Fw length is invalid \n");
+		return -1;
+	}
+	
+	for (i = 0; i < FTS_UPGRADE_LOOP; i++) {
+		/*********Step 1:Reset  CTPM *****/
+		/*write 0xaa to register 0xbc */
+		
+		fts_write_reg(client, 0xbc, FT_UPGRADE_AA);
+		msleep(fts_updateinfo_curr.delay_aa);
+
+		/*write 0x55 to register 0xbc */
+		fts_write_reg(client, 0xbc, FT_UPGRADE_55);
+
+		//msleep(fts_updateinfo_curr.delay_55);
+		if(i<=15)
+		{
+		msleep(fts_updateinfo_curr.delay_55+i*3);
+		}
+		else
+		{
+		msleep(fts_updateinfo_curr.delay_55-(i-15)*2);
+		}
+
+
+		/*********Step 2:Enter upgrade mode *****/
+		auc_i2c_write_buf[0] = FT_UPGRADE_55;
+		fts_i2c_Write(client, auc_i2c_write_buf, 1);
+
+		auc_i2c_write_buf[0] = FT_UPGRADE_AA;
+		fts_i2c_Write(client, auc_i2c_write_buf, 1);
+		msleep(fts_updateinfo_curr.delay_readid);
+
+		/*********Step 3:check READ-ID***********************/		
+		auc_i2c_write_buf[0] = 0x90;
+		auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = auc_i2c_write_buf[3] =
+			0x00;
+		reg_val[0] = 0x00;
+		reg_val[1] = 0x00;
+		fts_i2c_Read(client, auc_i2c_write_buf, 4, reg_val, 2);
+
+
+		if (reg_val[0] == fts_updateinfo_curr.upgrade_id_1
+			&& reg_val[1] == fts_updateinfo_curr.upgrade_id_2) {
+			printk("[FTS] Step 3: GET CTPM ID OK,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+			break;
+		} else {
+			dev_err(&client->dev, "[FTS] Step 3: GET CTPM ID FAIL,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+		}
+	}
+	if (i >= FTS_UPGRADE_LOOP)
+		return -EIO;
+
+	auc_i2c_write_buf[0] = 0x90;
+	auc_i2c_write_buf[1] = 0x00;
+	auc_i2c_write_buf[2] = 0x00;
+	auc_i2c_write_buf[3] = 0x00;
+	auc_i2c_write_buf[4] = 0x00;
+	fts_i2c_Write(client, auc_i2c_write_buf, 5);
+	
+	//auc_i2c_write_buf[0] = 0xcd;
+	//fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 1);
+
+
+	/*Step 4:erase app and panel paramenter area*/
+	printk("Step 4:erase app and panel paramenter area\n");
+	auc_i2c_write_buf[0] = 0x61;
+	fts_i2c_Write(client, auc_i2c_write_buf, 1);	/*erase app area */
+	msleep(fts_updateinfo_curr.delay_earse_flash);
+
+	for(i = 0;i < 200;i++)
+	{
+		auc_i2c_write_buf[0] = 0x6a;
+		auc_i2c_write_buf[1] = 0x00;
+		auc_i2c_write_buf[2] = 0x00;
+		auc_i2c_write_buf[3] = 0x00;
+		reg_val[0] = 0x00;
+		reg_val[1] = 0x00;
+		fts_i2c_Read(client, auc_i2c_write_buf, 4, reg_val, 2);
+		if(0xb0 == reg_val[0] && 0x02 == reg_val[1])
+		{
+			printk("[FTS] erase app finished \n");
+			break;
+		}
+		msleep(50);
+	}
+
+	/*********Step 5:write firmware(FW) to ctpm flash*********/
+	bt_ecc = 0;
+	printk("Step 5:write firmware(FW) to ctpm flash\n");
+
+	dw_lenth = fw_length;
+	packet_number = (dw_lenth) / FTS_PACKET_LENGTH;
+	packet_buf[0] = 0xbf;
+	packet_buf[1] = 0x00;
+
+	for (j = 0; j < packet_number; j++) {
+		temp = j * FTS_PACKET_LENGTH;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		lenght = FTS_PACKET_LENGTH;
+		packet_buf[4] = (u8) (lenght >> 8);
+		packet_buf[5] = (u8) lenght;
+
+		for (i = 0; i < FTS_PACKET_LENGTH; i++) {
+			packet_buf[6 + i] = pbt_buf[j * FTS_PACKET_LENGTH + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}
+		
+		fts_i2c_Write(client, packet_buf, FTS_PACKET_LENGTH + 6);
+		
+		for(i = 0;i < 30;i++)
+		{
+			auc_i2c_write_buf[0] = 0x6a;
+			auc_i2c_write_buf[1] = 0x00;
+			auc_i2c_write_buf[2] = 0x00;
+			auc_i2c_write_buf[3] = 0x00;
+			reg_val[0] = 0x00;
+			reg_val[1] = 0x00;
+			fts_i2c_Read(client, auc_i2c_write_buf, 4, reg_val, 2);
+			if(0xb0 == (reg_val[0] & 0xf0) && (0x03 + (j % 0x0ffd)) == (((reg_val[0] & 0x0f) << 8) |reg_val[1]))
+			{
+				printk("[FTS] write a block data finished \n");
+				break;
+			}
+			msleep(1);
+		}
+	}
+
+	if ((dw_lenth) % FTS_PACKET_LENGTH > 0) {
+		temp = packet_number * FTS_PACKET_LENGTH;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		temp = (dw_lenth) % FTS_PACKET_LENGTH;
+		packet_buf[4] = (u8) (temp >> 8);
+		packet_buf[5] = (u8) temp;
+
+		for (i = 0; i < temp; i++) {
+			packet_buf[6 + i] = pbt_buf[packet_number * FTS_PACKET_LENGTH + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}
+
+		fts_i2c_Write(client, packet_buf, temp + 6);
+
+		for(i = 0;i < 30;i++)
+		{
+			auc_i2c_write_buf[0] = 0x6a;
+			auc_i2c_write_buf[1] = 0x00;
+			auc_i2c_write_buf[2] = 0x00;
+			auc_i2c_write_buf[3] = 0x00;
+			reg_val[0] = 0x00;
+			reg_val[1] = 0x00;
+			fts_i2c_Read(client, auc_i2c_write_buf, 4, reg_val, 2);
+			if(0xb0 == (reg_val[0] & 0xf0) && (0x03 + (j % 0x0ffd)) == (((reg_val[0] & 0x0f) << 8) |reg_val[1]))
+			{
+				printk("[FTS] write a block data finished \n");
+				break;
+			}
+			msleep(1);
+		}
+	}
+
+
+	/*********Step 6: read out checksum***********************/
+	/*send the opration head */
+	printk("Step 6: read out checksum\n");
+	auc_i2c_write_buf[0] = 0xcc;
+	fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 1);
+	if (reg_val[0] != bt_ecc) {
+		dev_err(&client->dev, "[FTS]--ecc error! FW=%02x bt_ecc=%02x\n",
+					reg_val[0],
+					bt_ecc);
+		return -EIO;
+	}
+
+	/*********Step 7: reset the new FW***********************/
+	printk("Step 7: reset the new FW\n");
+	auc_i2c_write_buf[0] = 0x07;
+	fts_i2c_Write(client, auc_i2c_write_buf, 1);
+	msleep(300);	/*make sure CTP startup normally */
+
+	return 0;
 }
 
+
 /*update project setting
 *only update these settings for COB project, or for some special case
 */
@@ -439,75 +848,22 @@
 	return 0;
 }
 
-
+#ifdef SPRD_AUTO_UPGRADE
 int fts_ctpm_auto_upgrade(struct i2c_client *client)
 {
 	u8 uc_host_fm_ver = FT_REG_FW_VER;
 	u8 uc_tp_fm_ver;
-    int i_ret;
-	unsigned char uc_reg_value;
+	int i_ret;
 
-	fts_read_reg(client, FT5X0X_REG_CIPHER, &uc_reg_value);
-	printk("[FTS] read chip id is %x\n",uc_reg_value);
-#ifdef CONFIG_TOUCHSCREEN_FIRMWARE_UPGRADE
-/*the chip id of FT6306 is 0x06*/
-    /*
-	if (uc_reg_value == 0x06)
-	{
-		CTPM_FW = FT6306_FW;
-		fw_size = sizeof(FT6306_FW);
-	}
-	if (uc_reg_value == 0x0a)
-	{
-		CTPM_FW = FT5316_FW;
-		fw_size = sizeof(FT5316_FW);
-	}
-    */
-#ifdef CONFIG_MACH_SP9838AEA_2342A
-    /* for sharklt8 upgrade */
-    if (uc_reg_value == 0x14)
-    {
-        CTPM_FW = LIANCHUANG_FW;
-        fw_size = sizeof(LIANCHUANG_FW);
-        /* sharklt8 use 0x39 firmware */
-    }
-#endif
-
-#ifdef CONFIG_MACH_SPWHALE_5MODEA
-    if (uc_reg_value == 0x14) {
-        CTPM_FW = SPWHALE_FW;
-        fw_size = sizeof(SPWHALE_FW);
-        /* spwhale use 0x11 firmware */
-    }
-#endif
-
-#ifdef CONFIG_MACH_SPWHALE_5MODEB
-    if (uc_reg_value == 0x14) {
-        CTPM_FW = SPWHALE_FW;
-        fw_size = sizeof(SPWHALE_FW);
-        /* spwhale use 0x11 firmware */
-    }
-#endif
-#endif
 	fts_read_reg(client, FT_REG_FW_VER, &uc_tp_fm_ver);
 	uc_host_fm_ver = fts_ctpm_get_i_file_ver();
 
        printk("[FTS] uc_tp_fm_ver = 0x%x, uc_host_fm_ver = 0x%x\n",uc_tp_fm_ver, uc_host_fm_ver);
-/*
-*avoid the old module about 500pcs to upgrade the firmware,
-*the firmware version of old module is from 0x01 to 0x03,
-*but the new module firmware version is more than 0x10.
-*bug385939
-*/
-	if (uc_reg_value == 0x06) {
-		if (uc_tp_fm_ver < 0x04)
-			 return 0;
-	}
-
+	   
 	if (/*the firmware in touch panel maybe corrupted */
 		uc_tp_fm_ver == FT_REG_FW_VER ||
 		/*the firmware in host flash is new, need upgrade */
-	     uc_tp_fm_ver != uc_host_fm_ver
+	     uc_tp_fm_ver < uc_host_fm_ver
 	    ) {
 		msleep(100);
 		dev_dbg(&client->dev, "[FTS] uc_tp_fm_ver = 0x%x, uc_host_fm_ver = 0x%x\n",
@@ -527,6 +883,105 @@
 	return 0;
 }
 
+
+/*
+upgrade with *.i file
+*/
+int fts_ctpm_fw_upgrade_with_i_file(struct i2c_client *client)
+{
+	u8 *pbt_buf = NULL;
+	int i_ret;
+	int fw_len = sizeof(CTPM_FW);
+
+	pbt_buf = CTPM_FW;
+	
+	if ((fts_updateinfo_curr.CHIP_ID==0x54))
+	{
+		if (fw_len < 8 || fw_len > 54 * 1024) 
+		{
+			dev_err(&client->dev, "%s:FW length error\n", __func__);
+			return -EIO;
+		}
+
+		
+		i_ret = fts_5x46_ctpm_fw_upgrade(client, pbt_buf, sizeof(CTPM_FW));
+		if (i_ret != 0)
+			dev_err(&client->dev, "%s:upgrade failed. err.\n",
+					__func__);
+		return i_ret;
+	}
+
+	 if ((fts_updateinfo_curr.CHIP_ID==0x36))
+	{
+		i_ret = fts_6x36_ctpm_fw_upgrade(client, pbt_buf, sizeof(CTPM_FW));
+		if (i_ret != 0)
+			dev_err(&client->dev, "%s:upgrade failed. err.\n",
+					__func__);
+		return i_ret;
+	}
+	/*judge the fw that will be upgraded
+	* if illegal, then stop upgrade and return.
+	*/
+	if (fw_len < 8 || fw_len > 32 * 1024) {
+		dev_err(&client->dev, "%s:FW length error\n", __func__);
+		return -EIO;
+	}
+
+	//if ((CTPM_FW[fw_len - 8] ^ CTPM_FW[fw_len - 6]) == 0xFF
+		//&& (CTPM_FW[fw_len - 7] ^ CTPM_FW[fw_len - 5]) == 0xFF
+		//&& (CTPM_FW[fw_len - 3] ^ CTPM_FW[fw_len - 4]) == 0xFF) {
+	if (1){
+		/*FW upgrade */
+		pbt_buf = CTPM_FW;
+		/*call the upgrade function */
+		i_ret = fts_ctpm_fw_upgrade(client, pbt_buf, sizeof(CTPM_FW));
+		if (i_ret != 0)
+			dev_err(&client->dev, "%s:upgrade failed. err.\n",
+					__func__);
+		else if(fts_updateinfo_curr.AUTO_CLB==AUTO_CLB_NEED)
+			fts_ctpm_auto_clb(client);	/*start auto CLB */
+
+	} 
+	else {
+		dev_err(&client->dev, "%s:FW format error\n", __func__);
+		return -EBADFD;
+	}
+
+	return i_ret;
+}
+
+u8 fts_ctpm_get_i_file_ver(void)
+{
+	u16 ui_sz;
+	ui_sz = sizeof(CTPM_FW);
+	if (ui_sz > 2)
+	{
+	    if(fts_updateinfo_curr.CHIP_ID==0x36)
+                return CTPM_FW[0x10a];
+	    else
+		return CTPM_FW[ui_sz - 2];
+
+	}
+
+	return 0x00;	/*default value */
+}
+
+u8 fts_ctpm_get_i_file_vendor(void)
+{
+	u16 ui_sz;
+	ui_sz = sizeof(CTPM_FW);
+	if (ui_sz > 1)
+	{
+	    if(fts_updateinfo_curr.CHIP_ID==0x36)
+                return CTPM_FW[0x108];
+	    else
+		return CTPM_FW[ui_sz - 1];
+
+	}
+
+	return 0x00;	/*default value */
+}
+#endif
 void delay_qt_ms(unsigned long  w_ms)
 {
 	unsigned long i;
@@ -543,6 +998,8 @@
 
 extern void focaltech_get_upgrade_array(struct i2c_client *client);
 
+
+
 int fts_ctpm_fw_upgrade(struct i2c_client *client, u8 *pbt_buf,
 			  u32 dw_lenth)
 {
@@ -579,7 +1036,7 @@
 		/*********Step 1:Reset  CTPM *****/
 		/*write 0xaa to register 0xfc */
 		//if (DEVICE_IC_TYPE == IC_FT6208 || DEVICE_IC_TYPE == IC_FT6x06)
-		if(fts_updateinfo_curr.CHIP_ID==0x05 || fts_updateinfo_curr.CHIP_ID==0x06 ) 
+		if(fts_updateinfo_curr.CHIP_ID==0x36 || fts_updateinfo_curr.CHIP_ID==0x06 ) 
 			fts_write_reg(client, 0xbc, FT_UPGRADE_AA);
 		else
 			fts_write_reg(client, 0xfc, FT_UPGRADE_AA);
@@ -588,7 +1045,7 @@
 
 		/*write 0x55 to register 0xfc */
 		//if(DEVICE_IC_TYPE == IC_FT6208 || DEVICE_IC_TYPE == IC_FT6x06)
-		if(fts_updateinfo_curr.CHIP_ID==0x05 || fts_updateinfo_curr.CHIP_ID==0x06 )
+		if(fts_updateinfo_curr.CHIP_ID==0x36 || fts_updateinfo_curr.CHIP_ID==0x06 )
 			fts_write_reg(client, 0xbc, FT_UPGRADE_55);
 		else
 			fts_write_reg(client, 0xfc, FT_UPGRADE_55);
@@ -928,7 +1385,7 @@
 		return -EIO;
 	}
 
-	if (fwsize < 8 || fwsize > 32 * 1024) {
+	if (fwsize < 8 || fwsize > 54 * 1024) {
 		dev_dbg(&client->dev, "%s:FW length error\n", __func__);
 		return -EIO;
 	}
@@ -948,7 +1405,18 @@
 	}
 	
 	/*call the upgrade function */
-	i_ret = fts_ctpm_fw_upgrade(client, pbt_buf, fwsize);
+	if ((fts_updateinfo_curr.CHIP_ID==0x54))
+	{
+		i_ret = fts_5x46_ctpm_fw_upgrade(client, pbt_buf, fwsize);
+	}
+	else if ((fts_updateinfo_curr.CHIP_ID==0x36))
+	{
+		i_ret = fts_6x36_ctpm_fw_upgrade(client, pbt_buf, fwsize);
+	}
+	else
+	{
+	        i_ret = fts_ctpm_fw_upgrade(client, pbt_buf, fwsize);
+	}
 	if (i_ret != 0)
 		dev_err(&client->dev, "%s() - ERROR:[FTS] upgrade failed..\n",
 					__func__);
@@ -1075,6 +1543,8 @@
 					struct device_attribute *attr,
 					const char *buf, size_t count)
 {
+
+#if 0
 	//struct fts_ts_data *data = NULL;
 	u8 uc_host_fm_ver;
 	int i_ret;
@@ -1101,6 +1571,8 @@
 	mutex_unlock(&g_device_mutex);
 
 	return count;
+
+	#endif
 }
 
 static ssize_t fts_fwupgradeapp_show(struct device *dev,
@@ -1219,11 +1691,16 @@
 }
 /*create apk debug channel*/
 
+
+
 #define PROC_UPGRADE			0
 #define PROC_READ_REGISTER		1
 #define PROC_WRITE_REGISTER	2
 #define PROC_RAWDATA			3
 #define PROC_AUTOCLB			4
+#define PROC_UPGRADE_INFO		5
+#define PROC_WRITE_DATA		6
+#define PROC_READ_DATA			7
 
 #define PROC_NAME	"ft5x0x-debug"
 static unsigned char proc_operate_mode = PROC_RAWDATA;
@@ -1284,7 +1761,15 @@
 	case PROC_AUTOCLB:
 		fts_ctpm_auto_clb(client);
 		break;
-	
+	case PROC_READ_DATA:
+	case PROC_WRITE_DATA:
+		writelen = len - 1;
+		ret = fts_i2c_Write(client, writebuf + 1, writelen);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s:write iic error\n", __func__);
+			return ret;
+		}
+		break;
 	default:
 		break;
 	}
@@ -1328,6 +1813,18 @@
 		break;
 	case PROC_RAWDATA:
 		break;
+	case PROC_READ_DATA:
+		readlen = len;
+		ret = fts_i2c_Read(client, NULL, 0, buf, readlen);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s:read iic error\n", __func__);
+			return ret;
+		}
+		
+		num_read_chars = readlen;
+		break;
+	case PROC_WRITE_DATA:
+		break;
 	default:
 		break;
 	}
@@ -1336,6 +1833,9 @@
 
 	return num_read_chars;
 }
+		
+	
+
 static struct file_operations proc_ops = {
 	.read = ft5x0x_debug_read,
 	.write = ft5x0x_debug_write,
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_mp_test.h
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_mp_test.h	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_mp_test.h	(revision 166572)
@@ -0,0 +1,144 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_mp_test.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_MP_TEST_H__
+#define __MSTAR_DRV_MP_TEST_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+#define CTP_MP_TEST_RETRY_COUNT (3)
+
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG22XX)
+/*--------- Constant defined for MSG21xxA/MSG22xx ---------*/
+#define SELF_IC_OPEN_TEST_NON_BORDER_AREA_THRESHOLD (35) // range : 25~60
+#define SELF_IC_OPEN_TEST_BORDER_AREA_THRESHOLD     (40) // range : 25~60
+
+#define	SELF_IC_SHORT_TEST_THRESHOLD                (3500)
+#define SELF_IC_MAX_CHANNEL_NUM   (48)
+#define SELF_IC_FIQ_E_FRAME_READY_MASK      (1 << 8)
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA || CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+// Constant defined for MSG21xxA
+#define MSG21XXA_PIN_GUARD_RING    (46) 
+#define MSG21XXA_GPO_SETTING_SIZE  (3)  
+#define MSG21XXA_REG_INTR_FIQ_MASK (0x04)          
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+// Constant defined for MSG22xx
+#define MSG22XX_RIU_BASE_ADDR       (0)   
+#define MSG22XX_RIU_WRITE_LENGTH    (144)  
+#define MSG22XX_CSUB_REF            (0) //(18)   
+#define MSG22XX_CSUB_REF_MAX        (0x3F) 
+
+#define MSG22XX_MAX_SUBFRAME_NUM    (24)
+#define MSG22XX_MAX_AFE_NUM         (4)
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG26XXM) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG28XX)
+/*--------- Constant defined for MSG26xxM/MSG28xx ---------*/
+#define MUTUAL_IC_MAX_CHANNEL_NUM  38
+#define MUTUAL_IC_MAX_MUTUAL_NUM  (MUTUAL_IC_MAX_CHANNEL_DRV * MUTUAL_IC_MAX_CHANNEL_SEN)
+
+#define MUTUAL_IC_FIR_RATIO    50 //25
+#define MUTUAL_IC_IIR_MAX		32600
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM || CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+// Constant defined for MSG26xxM
+#define MUTUAL_IC_MAX_CHANNEL_DRV  28
+#define MUTUAL_IC_MAX_CHANNEL_SEN  14
+
+#define MSG26XXM_ANA3_MUTUAL_CSUB_NUMBER (192) //192 = 14 * 13 + 10
+#define MSG26XXM_ANA4_MUTUAL_CSUB_NUMBER (MUTUAL_IC_MAX_MUTUAL_NUM - MSG26XXM_ANA3_MUTUAL_CSUB_NUMBER) //200 = 392 - 192
+#define MSG26XXM_FILTER1_MUTUAL_DELTA_C_NUMBER (190) //190 = (6 * 14 + 11) * 2
+#define MSG26XXM_FILTER2_MUTUAL_DELTA_C_NUMBER (594) //594 = (MUTUAL_IC_MAX_MUTUAL_NUM - (6 * 14 + 11)) * 2
+#define MSG26XXM_FIR_THRESHOLD    6553
+#define MSG26XXM_SHORT_VALUE	2000
+#define MSG26XXM_PIN_GUARD_RING    (38)
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+// Constant defined for MSG28xx
+#define MUTUAL_IC_MAX_CHANNEL_DRV  30
+#define MUTUAL_IC_MAX_CHANNEL_SEN  20
+
+#define MSG28XX_SHORT_VALUE  3000
+#define MSG28XX_WATER_VALUE  20000
+#define MSG28XX_DC_RANGE  30
+#define MSG28XX_DC_RATIO  10
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR MACRO DEFINITION                                            */
+/*--------------------------------------------------------------------------*/
+
+/*--------------------------------------------------------------------------*/
+/* DATA TYPE DEFINITION                                                     */
+/*--------------------------------------------------------------------------*/
+
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG26XXM) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG28XX)
+typedef struct
+{
+    u8 nMy;
+    u8 nMx;
+    u8 nKeyNum;
+} TestScopeInfo_t;
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM || CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL VARIABLE DEFINITION                                               */
+/*--------------------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG26XXM) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG28XX)
+extern void DrvMpTestGetTestScope(TestScopeInfo_t *pInfo);
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM || CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+extern void DrvMpTestCreateMpTestWorkQueue(void);
+extern void DrvMpTestGetTestDataLog(ItoTestMode_e eItoTestMode, u8 *pDataLog, u32 *pLength);
+extern void DrvMpTestGetTestFailChannel(ItoTestMode_e eItoTestMode, u8 *pFailChannel, u32 *pFailChannelCount);
+extern s32 DrvMpTestGetTestResult(void);
+extern void DrvMpTestScheduleMpTestWork(ItoTestMode_e eItoTestMode);
+
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+#endif  /* __MSTAR_DRV_MP_TEST_H__ */
\ No newline at end of file
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_fw_control.h
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_fw_control.h	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_fw_control.h	(revision 166572)
@@ -0,0 +1,288 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_fw_control.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_FW_CONTROL_H__
+#define __MSTAR_DRV_FW_CONTROL_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+#ifdef CONFIG_ENABLE_HOTKNOT
+#include "mstar_drv_hotknot.h"
+#endif //CONFIG_ENABLE_HOTKNOT
+
+/*--------------------------------------------------------------------------*/
+/* COMPILE OPTION DEFINITION                                                */
+/*--------------------------------------------------------------------------*/
+
+/* The below 3 define are used for MSG21xxA/MSG22xx */
+//#define CONFIG_SWAP_X_Y
+
+//#define CONFIG_REVERSE_X
+//#define CONFIG_REVERSE_Y
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+#define MUTUAL_DEMO_MODE_PACKET_LENGTH    (43) // for MSG26xxM/MSG28xx
+#define SELF_DEMO_MODE_PACKET_LENGTH    (8) // for MSG21xxA/MSG22xx
+
+#define MUTUAL_MAX_TOUCH_NUM           (10) // for MSG26xxM/MSG28xx    
+#define SELF_MAX_TOUCH_NUM           (2) // for MSG21xxA/MSG22xx     
+
+#define MUTUAL_DEBUG_MODE_PACKET_LENGTH    (1280) // for MSG26xxM/MSG28xx. It is a predefined maximum packet length, not the actual packet length which queried from firmware.
+#define SELF_DEBUG_MODE_PACKET_LENGTH    (128) //  for MSG21xxA/MSG22xx
+
+
+#define MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE (32) //32K
+#define MSG21XXA_FIRMWARE_INFO_BLOCK_SIZE (1)  //1K
+#define MSG21XXA_FIRMWARE_WHOLE_SIZE (MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE+MSG21XXA_FIRMWARE_INFO_BLOCK_SIZE) //33K
+
+#define MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE (48)  //48K
+#define MSG22XX_FIRMWARE_INFO_BLOCK_SIZE (512) //512Byte
+
+//#define MSG21XXA_FIRMWARE_MODE_UNKNOWN_MODE   (0xFF)
+#define MSG21XXA_FIRMWARE_MODE_DEMO_MODE      (0x00)
+#define MSG21XXA_FIRMWARE_MODE_DEBUG_MODE     (0x01)
+#define MSG21XXA_FIRMWARE_MODE_RAW_DATA_MODE  (0x02)
+
+//#define MSG22XX_FIRMWARE_MODE_UNKNOWN_MODE    (0xFF)
+#define MSG22XX_FIRMWARE_MODE_DEMO_MODE       (0x00)
+#define MSG22XX_FIRMWARE_MODE_DEBUG_MODE      (0x01)
+#define MSG22XX_FIRMWARE_MODE_RAW_DATA_MODE   (0x02)
+
+#define MSG22XX_MAX_ERASE_EFLASH_TIMES   (2) // for update firmware of MSG22xx 
+
+
+#define MSG26XXM_FIRMWARE_MAIN_BLOCK_SIZE (32) //32K
+#define MSG26XXM_FIRMWARE_INFO_BLOCK_SIZE (8) //8K
+#define MSG26XXM_FIRMWARE_WHOLE_SIZE (MSG26XXM_FIRMWARE_MAIN_BLOCK_SIZE+MSG26XXM_FIRMWARE_INFO_BLOCK_SIZE) //40K
+
+#define MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE (128) //128K
+#define MSG28XX_FIRMWARE_INFO_BLOCK_SIZE (2) //2K
+#define MSG28XX_FIRMWARE_WHOLE_SIZE (MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE+MSG28XX_FIRMWARE_INFO_BLOCK_SIZE) //130K
+
+#define MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE  (128)
+#define MSG28XX_EMEM_SIZE_BYTES_ONE_WORD  (4)
+
+#define MSG28XX_EMEM_MAIN_MAX_ADDR  (0x3FFF) //0~0x3FFF = 0x4000 = 16384 = 65536/4
+#define MSG28XX_EMEM_INFO_MAX_ADDR  (0x1FF) //0~0x1FF = 0x200 = 512 = 2048/4
+
+
+#define MSG26XXM_FIRMWARE_MODE_UNKNOWN_MODE (0xFFFF)
+#define MSG26XXM_FIRMWARE_MODE_DEMO_MODE    (0x0005)
+#define MSG26XXM_FIRMWARE_MODE_DEBUG_MODE   (0x0105)
+
+#define MSG28XX_FIRMWARE_MODE_UNKNOWN_MODE (0xFF)
+#define MSG28XX_FIRMWARE_MODE_DEMO_MODE    (0x00)
+#define MSG28XX_FIRMWARE_MODE_DEBUG_MODE   (0x01)
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+#define UPDATE_FIRMWARE_RETRY_COUNT (2)
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+#define FIRMWARE_GESTURE_INFORMATION_MODE_A	(0x00)
+#define FIRMWARE_GESTURE_INFORMATION_MODE_B	(0x01)
+#define FIRMWARE_GESTURE_INFORMATION_MODE_C	(0x02)
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*--------------------------------------------------------------------------*/
+/* DATA TYPE DEFINITION                                                     */
+/*--------------------------------------------------------------------------*/
+
+typedef struct
+{
+    u16 nX;
+    u16 nY;
+} SelfTouchPoint_t;
+
+typedef struct
+{
+    u8 nTouchKeyMode;
+    u8 nTouchKeyCode;
+    u8 nFingerNum;
+    SelfTouchPoint_t tPoint[2];
+} SelfTouchInfo_t;
+
+typedef struct
+{
+    u8 nFirmwareMode;
+    u8 nLogModePacketHeader;
+    u16 nLogModePacketLength;
+    u8 nIsCanChangeFirmwareMode;
+} SelfFirmwareInfo_t;
+
+typedef struct
+{
+    u16 nId;
+    u16 nX;
+    u16 nY;
+    u16 nP;
+} MutualTouchPoint_t;
+
+/// max 80+1+1 = 82 bytes
+typedef struct
+{
+    u8 nCount;
+    u8 nKeyCode;
+    MutualTouchPoint_t tPoint[10];
+} MutualTouchInfo_t;
+
+typedef struct
+{
+    u16 nFirmwareMode;
+    u8 nType;
+    u8 nLogModePacketHeader;
+    u8 nMy;
+    u8 nMx;
+    u8 nSd;
+    u8 nSs;
+    u16 nLogModePacketLength;
+} MutualFirmwareInfo_t;
+
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+/*
+ * Note.
+ * The following is sw id enum definition for MSG21XXA.
+ * SW_ID_UNDEFINED is a reserved enum value, do not delete it or modify it.
+ * Please modify the SW ID of the below enum value depends on the TP vendor that you are using.
+ */
+typedef enum {
+    MSG21XXA_SW_ID_XXXX = 0,  
+    MSG21XXA_SW_ID_YYYY,
+    MSG21XXA_SW_ID_UNDEFINED
+} Msg21xxaSwId_e;
+
+/*
+ * Note.
+ * The following is sw id enum definition for MSG22XX.
+ * 0x0000 and 0xFFFF are not allowed to be defined as SW ID.
+ * SW_ID_UNDEFINED is a reserved enum value, do not delete it or modify it.
+ * Please modify the SW ID of the below enum value depends on the TP vendor that you are using.
+ */
+typedef enum {
+    MSG22XX_SW_ID_XXXX = 0x0001,
+    MSG22XX_SW_ID_YYYY = 0x0002,  
+    MSG22XX_SW_ID_UNDEFINED = 0xFFFF
+} Msg22xxSwId_e;
+
+/*
+ * Note.
+ * The following is sw id enum definition for MSG26XXM.
+ * 0x0000 and 0xFFFF are not allowed to be defined as SW ID.
+ * SW_ID_UNDEFINED is a reserved enum value, do not delete it or modify it.
+ * Please modify the SW ID of the below enum value depends on the TP vendor that you are using.
+ */
+typedef enum {
+    MSG26XXM_SW_ID_XXXX = 0x0001,
+    MSG26XXM_SW_ID_YYYY = 0x0002,
+    MSG26XXM_SW_ID_UNDEFINED = 0xFFFF
+} Msg26xxmSwId_e;
+
+/*
+ * Note.
+ * The following is sw id enum definition for MSG28XX.
+ * 0x0000 and 0xFFFF are not allowed to be defined as SW ID.
+ * SW_ID_UNDEFINED is a reserved enum value, do not delete it or modify it.
+ * Please modify the SW ID of the below enum value depends on the TP vendor that you are using.
+ */
+typedef enum {
+    MSG28XX_SW_ID_XXXX = 0x0001,
+    MSG28XX_SW_ID_YYYY = 0x0002,
+    MSG28XX_SW_ID_UNDEFINED = 0xFFFF
+} Msg28xxSwId_e;
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern void DrvFwCtrlOpenGestureWakeup(u32 *pMode);
+extern void DrvFwCtrlCloseGestureWakeup(void);
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+extern void DrvFwCtrlOpenGestureDebugMode(u8 nGestureFlag);
+extern void DrvFwCtrlCloseGestureDebugMode(void);
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+extern u32 DrvFwCtrlReadDQMemValue(u16 nAddr);
+extern void DrvFwCtrlWriteDQMemValue(u16 nAddr, u32 nData);
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+extern void DrvFwCtrlCheckFirmwareUpdateBySwId(void);
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+extern u16 DrvFwCtrlChangeFirmwareMode(u16 nMode);
+extern void DrvFwCtrlSelfGetFirmwareInfo(SelfFirmwareInfo_t *pInfo);
+extern void DrvFwCtrlMutualGetFirmwareInfo(MutualFirmwareInfo_t *pInfo);
+extern u16 DrvFwCtrlGetFirmwareMode(void);
+extern void DrvFwCtrlRestoreFirmwareModeToLogDataMode(void);
+
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+extern void DrvFwCtrlGetTouchPacketAddress(u16 *pDataAddress, u16 *pFlagAddress);
+#endif //CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+extern s32 DrvFwCtrlEnableProximity(void);
+extern s32 DrvFwCtrlDisableProximity(void);
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+extern void DrvFwCtrlVariableInitialize(void);
+extern void DrvFwCtrlOptimizeCurrentConsumption(void);
+extern u8 DrvFwCtrlGetChipType(void);
+extern void DrvFwCtrlGetCustomerFirmwareVersionByDbBus(EmemType_e eEmemType, u16 *pMajor, u16 *pMinor, u8 **ppVersion);
+extern void DrvFwCtrlGetCustomerFirmwareVersion(u16 *pMajor, u16 *pMinor, u8 **ppVersion);
+extern void DrvFwCtrlGetPlatformFirmwareVersion(u8 **ppVersion);
+extern void DrvFwCtrlHandleFingerTouch(void);
+extern s32 DrvFwCtrlUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType);
+extern s32 DrvFwCtrlUpdateFirmwareBySdCard(const char *pFilePath);
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+extern void ReportHotKnotCmd(u8 *pPacket, u16 nLength);
+#endif //CONFIG_ENABLE_HOTKNOT
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+extern void DrvFwCtrlOpenGloveMode(void);
+extern void DrvFwCtrlCloseGloveMode(void);
+extern void DrvFwCtrlGetGloveInfo(u8 *pGloveMode);
+#endif //CONFIG_ENABLE_GLOVE_MODE
+
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION
+extern void DrvFwCtrlChargerDetection(u8 nChargerStatus);
+#endif //CONFIG_ENABLE_CHARGER_DETECTION
+
+        
+#endif  /* __MSTAR_DRV_FW_CONTROL_H__ */
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_platform_porting_layer.c
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_platform_porting_layer.c	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_platform_porting_layer.c	(revision 166572)
@@ -0,0 +1,2111 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_platform_porting_layer.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+ 
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_platform_porting_layer.h"
+#include "mstar_drv_ic_fw_porting_layer.h"
+#include "mstar_drv_platform_interface.h"
+#include "mstar_drv_utility_adaption.h"
+#include "mstar_drv_main.h"
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+#include "mstar_drv_hotknot_queue.h"
+#endif //CONFIG_ENABLE_HOTKNOT
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+#include "mstar_drv_jni_interface.h"
+#endif //CONFIG_ENABLE_JNI_INTERFACE
+
+/*=============================================================*/
+// EXTREN VARIABLE DECLARATION
+/*=============================================================*/
+
+extern struct i2c_client *g_I2cClient;
+
+extern struct kset *g_TouchKSet;
+extern struct kobject *g_TouchKObj;
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+extern struct kset *g_GestureKSet;
+extern struct kobject *g_GestureKObj;
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+extern u8 g_FaceClosingTp;
+extern u8 g_EnableTpProximity;
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+extern struct tpd_device *tpd;
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+extern struct regulator *g_ReguVdd;
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+extern struct of_device_id touch_dt_match_table[];
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+extern struct regulator *g_ReguVdd;
+extern struct regulator *g_ReguVcc_i2c;
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM || CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+extern struct miscdevice hotknot_miscdevice;
+extern u8 g_HotKnotState;
+#endif //CONFIG_ENABLE_HOTKNOT
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+extern u32 g_IsInMpTest;
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+extern u32 SLAVE_I2C_ID_DWI2C;
+extern u8 g_IsUpdateFirmware;
+extern u8 g_IsHwResetByDriver;
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+
+extern u8 IS_FIRMWARE_DATA_LOG_ENABLED;
+
+extern u8 g_ChipType;
+
+/*=============================================================*/
+// LOCAL VARIABLE DEFINITION
+/*=============================================================*/
+
+static spinlock_t _gIrqLock;
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+static struct work_struct _gFingerTouchWork;
+static int _gIrq = -1;
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+#ifdef CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+static struct work_struct _gFingerTouchWork;
+#endif //CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+static int _gIrq = -1;
+
+//static int MS_TS_MSG_IC_GPIO_RST = 0; // Must set a value other than 1
+//static int MS_TS_MSG_IC_GPIO_INT = 1; // Must set value as 1
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#endif
+
+static int _gInterruptFlag = 0;
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+static int _gGpioRst = 0;
+static int _gGpioIrq = 0;
+static int MS_TS_MSG_IC_GPIO_RST = 0;
+static int MS_TS_MSG_IC_GPIO_INT = 0;
+
+static struct pinctrl *_gTsPinCtrl = NULL;
+static struct pinctrl_state *_gPinCtrlStateActive = NULL;
+static struct pinctrl_state *_gPinCtrlStateSuspend = NULL;
+static struct pinctrl_state *_gPinCtrlStateRelease = NULL;
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM || CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+#ifdef CONFIG_ENABLE_NOTIFIER_FB
+static struct notifier_block _gFbNotifier;
+#else
+static struct early_suspend _gEarlySuspend;
+#endif //CONFIG_ENABLE_NOTIFIER_FB
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM || CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+static atomic_t _gPsFlag;
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+static struct sensors_classdev _gProximityCdev;
+
+static struct sensors_classdev sensors_proximity_cdev = {
+    .name = "msg2xxx-proximity",
+    .vendor = "MStar",
+    .version = 1,
+    .handle = SENSORS_PROXIMITY_HANDLE,
+    .type = SENSOR_TYPE_PROXIMITY,
+    .max_range = "5.0",
+    .resolution = "5.0",
+    .sensor_power = "0.1",
+    .min_delay = 0,
+    .fifo_reserved_event_count = 0,
+    .fifo_max_event_count = 0,
+    .enabled = 0,
+    .delay_msec = 200,
+    .sensors_enable = NULL,
+    .sensors_poll_delay = NULL,
+};
+#endif 
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifndef CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+static DECLARE_WAIT_QUEUE_HEAD(_gWaiter);
+static struct task_struct *_gThread = NULL;
+static int _gTpdFlag = 0;
+#endif //CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+/*=============================================================*/
+// GLOBAL VARIABLE DEFINITION
+/*=============================================================*/
+
+#ifdef CONFIG_TP_HAVE_KEY
+int g_TpVirtualKey[] = {TOUCH_KEY_MENU, TOUCH_KEY_BACK, TOUCH_KEY_HOME, TOUCH_KEY_SEARCH};
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+struct kobject *g_PropertiesKObj = NULL;
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+#define BUTTON_W (100)
+#define BUTTON_H (100)
+
+int g_TpVirtualKeyDimLocal[MAX_KEY_NUM][4] = {{BUTTON_W/2*1,TOUCH_SCREEN_Y_MAX+BUTTON_H/2,BUTTON_W,BUTTON_H},
+                                                    {BUTTON_W/2*3,TOUCH_SCREEN_Y_MAX+BUTTON_H/2,BUTTON_W,BUTTON_H},
+                                                    {BUTTON_W/2*5,TOUCH_SCREEN_Y_MAX+BUTTON_H/2,BUTTON_W,BUTTON_H},
+                                                    {BUTTON_W/2*7,TOUCH_SCREEN_Y_MAX+BUTTON_H/2,BUTTON_W,BUTTON_H}};
+#endif 
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_TP_HAVE_KEY
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+struct input_dev *g_ProximityInputDevice = NULL;
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM || CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+int g_IsEnableEsdCheck = 1;
+struct delayed_work g_EsdCheckWork;
+struct workqueue_struct *g_EsdCheckWorkqueue = NULL;
+void DrvPlatformLyrEsdCheck(struct work_struct *pWork);
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+
+struct input_dev *g_InputDevice = NULL;
+struct mutex g_Mutex;
+
+/*=============================================================*/
+// GLOBAL FUNCTION DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+void DrvPlatformLyrTpPsEnable(int nEnable);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+int DrvPlatformLyrTpPsEnable(struct sensors_classdev* pProximityCdev, unsigned int nEnable);
+#endif
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+/*=============================================================*/
+// LOCAL FUNCTION DEFINITION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+
+static int _DrvPlatformLyrProximityOpen(struct inode *inode, struct file *file)
+{
+    int nRetVal = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    nRetVal = nonseekable_open(inode, file);
+    if (nRetVal < 0)
+    {
+        return nRetVal;
+    }
+
+    file->private_data = i2c_get_clientdata(g_I2cClient);
+    
+    return 0;
+}
+
+static int _DrvPlatformLyrProximityRelease(struct inode *inode, struct file *file)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    return 0;
+}
+
+static long _DrvPlatformLyrProximityIoctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+#if 0
+    DBG(&g_I2cClient->dev, "*** %s() *** cmd = %d\n", __func__, _IOC_NR(cmd)); 
+
+    switch (cmd)
+    {
+        case GTP_IOCTL_PROX_ON:
+            DrvPlatformLyrTpPsEnable(1);
+            break;
+        case GTP_IOCTL_PROX_OFF:
+            DrvPlatformLyrTpPsEnable(0);
+            break;
+        default:
+            return -EINVAL;
+    }
+#else
+    void __user *argp = (void __user *)arg;
+    int flag;
+    unsigned char data;
+    
+    DBG(&g_I2cClient->dev, "*** %s() *** cmd = %d\n", __func__, _IOC_NR(cmd)); 
+    
+    switch (cmd)
+    {
+        case LTR_IOCTL_SET_PFLAG:
+            if (copy_from_user(&flag, argp, sizeof(flag)))
+            {
+                return -EFAULT;
+            }
+		
+            if (flag < 0 || flag > 1)
+            {
+                return -EINVAL;
+            }
+            DBG(&g_I2cClient->dev, "flag = %d", flag); 
+                
+            atomic_set(&_gPsFlag, flag);	
+            
+            if (flag == 1)
+            {
+                DrvPlatformLyrTpPsEnable(1);
+            }
+            else if (flag == 0)
+            {
+                DrvPlatformLyrTpPsEnable(0);
+            }		
+            break;
+		
+        case LTR_IOCTL_GET_PFLAG:
+            flag = atomic_read(&_gPsFlag);
+            
+            if (copy_to_user(argp, &flag, sizeof(flag))) 
+            {
+                return -EFAULT;
+            }
+            DBG(&g_I2cClient->dev, "flag = %d", flag); 
+            break;
+
+        case LTR_IOCTL_GET_DATA:
+            if (copy_to_user(argp, &data, sizeof(data)))
+            {
+                return -EFAULT;
+            }
+            DBG(&g_I2cClient->dev, "flag = %d", flag); 
+            break;
+
+        case GTP_IOCTL_PROX_ON:
+            DrvPlatformLyrTpPsEnable(1);
+            break;
+        
+        case GTP_IOCTL_PROX_OFF:
+            DrvPlatformLyrTpPsEnable(0);
+            break;
+
+        default:
+            DBG(&g_I2cClient->dev, "*** %s() *** Invalid cmd = %d\n", __func__, _IOC_NR(cmd)); 
+            return -EINVAL;
+        } 
+#endif
+
+    return 0;
+}
+
+static const struct file_operations gtp_proximity_fops = {
+    .owner = THIS_MODULE,
+    .open = _DrvPlatformLyrProximityOpen,
+    .release = NULL, //_DrvPlatformLyrProximityRelease,
+    .unlocked_ioctl = _DrvPlatformLyrProximityIoctl,
+};
+
+static struct miscdevice gtp_proximity_misc = {
+    .minor = MISC_DYNAMIC_MINOR,
+    .name = "ltr_558als", // Match the hal's name
+    .fops = &gtp_proximity_fops,
+};
+
+static int _DrvPlatformLyrProximityInputDeviceInit(struct i2c_client *pClient)
+{
+    int nRetVal = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    nRetVal = misc_register(&gtp_proximity_misc);
+    if (nRetVal)
+    {
+        DBG(&g_I2cClient->dev, "*** Failed to misc_register() for proximity *** nRetVal=%d\n", nRetVal); 
+        goto ERROR_MISC_REGISTER_FAILED;
+    }
+
+    g_ProximityInputDevice = input_allocate_device();
+    if (g_ProximityInputDevice == NULL)
+    {
+        DBG(&g_I2cClient->dev, "*** Failed to allocate proximity input device ***\n"); 
+        nRetVal = -ENOMEM;
+        goto ERROR_INPUT_DEVICE_ALLOCATE_FAILED;
+    }
+
+    g_ProximityInputDevice->name = "alps_pxy";
+    g_ProximityInputDevice->phys  = "alps_pxy";
+    g_ProximityInputDevice->id.bustype = BUS_I2C;
+    g_ProximityInputDevice->dev.parent = &pClient->dev;
+    g_ProximityInputDevice->id.vendor = 0x0001;
+    g_ProximityInputDevice->id.product = 0x0001;
+    g_ProximityInputDevice->id.version = 0x0010;
+
+    set_bit(EV_ABS, g_ProximityInputDevice->evbit);
+	
+    input_set_abs_params(g_ProximityInputDevice, ABS_DISTANCE, 0, 1, 0, 0);
+
+    nRetVal = input_register_device(g_ProximityInputDevice);
+    if (nRetVal < 0) {
+        DBG(&g_I2cClient->dev, "*** Unable to register proximity input device *** nRetVal=%d\n", nRetVal); 
+        goto ERROR_INPUT_DEVICE_REGISTER_FAILED;
+    }
+    
+    return 0;
+
+ERROR_INPUT_DEVICE_REGISTER_FAILED:
+    if (g_ProximityInputDevice)
+    {
+        input_free_device(g_ProximityInputDevice);
+        g_ProximityInputDevice = NULL;
+    }
+ERROR_INPUT_DEVICE_ALLOCATE_FAILED:
+    misc_deregister(&gtp_proximity_misc);
+ERROR_MISC_REGISTER_FAILED:
+
+    return nRetVal;
+}
+
+static int _DrvPlatformLyrProximityInputDeviceUnInit(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    misc_deregister(&gtp_proximity_misc);
+
+    if (g_ProximityInputDevice)
+    {
+        input_unregister_device(g_ProximityInputDevice);
+        g_ProximityInputDevice = NULL;
+    }
+    
+    return 0;
+}
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+
+static ssize_t _DrvPlatformLyrProximityDetectionShow(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    DBG(&g_I2cClient->dev, "*** Tp Proximity State = %s ***\n", g_EnableTpProximity ? "open" : "close"); 
+    
+    return sprintf(buf, "%s\n", g_EnableTpProximity ? "open" : "close");
+}
+
+static ssize_t _DrvPlatformLyrProximityDetectionStore(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    if (buf != NULL)
+    {
+        if (sysfs_streq(buf, "1"))
+        {
+            DrvPlatformLyrTpPsEnable(&_gProximityCdev, 1);
+        }
+        else if (sysfs_streq(buf, "0"))
+        {
+            DrvPlatformLyrTpPsEnable(&_gProximityCdev, 0);
+        }
+    }
+
+    return size;
+}
+
+static struct device_attribute proximity_attribute = __ATTR(proximity, 0666/*0664*/, _DrvPlatformLyrProximityDetectionShow, _DrvPlatformLyrProximityDetectionStore);
+
+static struct attribute *proximity_detection_attrs[] =
+{
+    &proximity_attribute.attr,
+    NULL
+};
+
+static struct attribute_group proximity_detection_attribute_group = {
+    .name = "Driver",
+    .attrs = proximity_detection_attrs,
+};
+
+static int _DrvPlatformLyrProximityInputDeviceInit(struct i2c_client *pClient)
+{
+    int nRetVal = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    g_ProximityInputDevice = input_allocate_device();
+    if (g_ProximityInputDevice == NULL)
+    {
+        DBG(&g_I2cClient->dev, "*** Failed to allocate proximity input device ***\n"); 
+        nRetVal = -ENOMEM;
+        goto ERROR_INPUT_DEVICE_ALLOCATE_FAILED;
+    }
+
+    g_ProximityInputDevice->name = "msg2xxx-ps";
+    g_ProximityInputDevice->phys = "I2C";
+    g_ProximityInputDevice->dev.parent = &pClient->dev;
+    g_ProximityInputDevice->id.bustype = BUS_I2C;
+
+    set_bit(EV_ABS, g_ProximityInputDevice->evbit);
+
+    input_set_abs_params(g_ProximityInputDevice, ABS_DISTANCE, 0, 1, 0, 0);
+    
+    nRetVal = input_register_device(g_ProximityInputDevice);
+    if (nRetVal < 0) {
+        DBG(&g_I2cClient->dev, "*** Unable to register proximity input device *** nRetVal=%d\n", nRetVal); 
+        goto ERROR_INPUT_DEVICE_REGISTER_FAILED;
+    }
+
+    mdelay(10);
+
+    nRetVal = sysfs_create_group(&g_ProximityInputDevice->dev.kobj, &proximity_detection_attribute_group);
+    if (nRetVal < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Failed to sysfs_create_group() for proximity *** nRetVal=%d\n", nRetVal); 
+        goto ERROR_SYSFS_CREATE_GROUP_FAILED;
+    }
+
+    input_set_drvdata(g_ProximityInputDevice, NULL);
+
+    sensors_proximity_cdev.sensors_enable = DrvPlatformLyrTpPsEnable;
+    nRetVal = sensors_classdev_register(&pClient->dev, &sensors_proximity_cdev);
+    if (nRetVal < 0) {
+        DBG(&g_I2cClient->dev, "*** Failed to sensors_classdev_register() for proximity *** nRetVal=%d\n", nRetVal); 
+        goto ERROR_SENSORS_CLASSDEV_REGISTER_FAILED;
+    }
+
+    return 0;
+
+ERROR_SENSORS_CLASSDEV_REGISTER_FAILED:
+ERROR_SYSFS_CREATE_GROUP_FAILED:
+    if (g_ProximityInputDevice)
+    {
+        input_unregister_device(g_ProximityInputDevice);
+        g_ProximityInputDevice = NULL;
+    }
+ERROR_INPUT_DEVICE_REGISTER_FAILED:
+    if (g_ProximityInputDevice)
+    {
+        input_free_device(g_ProximityInputDevice);
+        g_ProximityInputDevice = NULL;
+    }
+ERROR_INPUT_DEVICE_ALLOCATE_FAILED:
+
+    return nRetVal;
+}
+
+static int _DrvPlatformLyrProximityInputDeviceUnInit(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    if (g_ProximityInputDevice)
+    {
+        input_unregister_device(g_ProximityInputDevice);
+        g_ProximityInputDevice = NULL;
+    }
+
+    sensors_classdev_unregister(&sensors_proximity_cdev);
+    
+    return 0;
+}
+
+#endif
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+
+#ifdef CONFIG_TP_HAVE_KEY
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+static ssize_t _DrvPlatformLyrVirtualKeysShow(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    return sprintf(buf,
+        __stringify(EV_KEY) ":" __stringify(KEY_HOMEPAGE) ":50:1330:100:100"
+        ":" __stringify(EV_KEY) ":" __stringify(KEY_MENU) ":150:1330:100:100"
+        ":" __stringify(EV_KEY) ":" __stringify(KEY_BACK) ":250:1330:100:100"
+        ":" __stringify(EV_KEY) ":" __stringify(KEY_SEARCH) ":350:1330:100:100"
+        "\n");
+}
+
+static struct kobj_attribute virtual_keys_attr = {
+    .attr = {
+        .name = "virtualkeys.msg2xxx_ts",
+        .mode = S_IRUGO,
+    },
+    .show = &_DrvPlatformLyrVirtualKeysShow,
+};
+
+static struct attribute *properties_attrs[] = {
+    &virtual_keys_attr.attr,
+    NULL
+};
+
+static struct attribute_group properties_attr_group = {
+    .attrs = properties_attrs,
+};
+
+static void _DrvPlatformLyrVirtualKeysInit(void)
+{
+    s32 nRetVal = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    g_PropertiesKObj = kobject_create_and_add("board_properties", NULL);
+    if (g_PropertiesKObj == NULL)
+    {
+        DBG(&g_I2cClient->dev, "*** Failed to kobject_create_and_add() for virtual keys *** nRetVal=%d\n", nRetVal); 
+        return;
+    }
+    
+    nRetVal = sysfs_create_group(g_PropertiesKObj, &properties_attr_group);
+    if (nRetVal < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Failed to sysfs_create_group() for virtual keys *** nRetVal=%d\n", nRetVal); 
+
+        kobject_put(g_PropertiesKObj);
+        g_PropertiesKObj = NULL;
+    }
+}
+
+static void _DrvPlatformLyrVirtualKeysUnInit(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    if (g_PropertiesKObj)
+    {
+        kobject_put(g_PropertiesKObj);
+        g_PropertiesKObj = NULL;
+    }
+}
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_TP_HAVE_KEY
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+static s32 _DrvPlatformLyrTouchPinCtrlInit(struct i2c_client *pClient)
+{
+    s32 nRetVal = 0;
+    u32 nFlag = 0;
+    struct device_node *pDeviceNode = pClient->dev.of_node;
+	
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+    
+    _gGpioRst = of_get_named_gpio_flags(pDeviceNode, "mstar,rst-gpio",	0, &nFlag);
+    
+    MS_TS_MSG_IC_GPIO_RST = _gGpioRst;
+    
+    if (_gGpioRst < 0)
+    {
+        return _gGpioRst;
+    }
+
+    _gGpioIrq = of_get_named_gpio_flags(pDeviceNode, "mstar,irq-gpio",	0, &nFlag);
+    
+    MS_TS_MSG_IC_GPIO_INT = _gGpioIrq;
+	
+    DBG(&g_I2cClient->dev, "_gGpioRst = %d, _gGpioIrq = %d\n", _gGpioRst, _gGpioIrq); 
+    
+    if (_gGpioIrq < 0)
+    {
+        return _gGpioIrq;
+    }
+	
+    /* Get pinctrl if target uses pinctrl */
+    _gTsPinCtrl = devm_pinctrl_get(&(pClient->dev));
+    if (IS_ERR_OR_NULL(_gTsPinCtrl)) 
+    {
+        nRetVal = PTR_ERR(_gTsPinCtrl);
+        DBG(&g_I2cClient->dev, "Target does not use pinctrl nRetVal=%d\n", nRetVal); 
+        goto ERROR_PINCTRL_GET;
+    }
+
+    _gPinCtrlStateActive = pinctrl_lookup_state(_gTsPinCtrl, PINCTRL_STATE_ACTIVE);
+    if (IS_ERR_OR_NULL(_gPinCtrlStateActive)) 
+    {
+        nRetVal = PTR_ERR(_gPinCtrlStateActive);
+        DBG(&g_I2cClient->dev, "Can not lookup %s pinstate nRetVal=%d\n", PINCTRL_STATE_ACTIVE, nRetVal); 
+        goto ERROR_PINCTRL_LOOKUP;
+    }
+
+    _gPinCtrlStateSuspend = pinctrl_lookup_state(_gTsPinCtrl, PINCTRL_STATE_SUSPEND);
+    if (IS_ERR_OR_NULL(_gPinCtrlStateSuspend)) 
+    {
+        nRetVal = PTR_ERR(_gPinCtrlStateSuspend);
+        DBG(&g_I2cClient->dev, "Can not lookup %s pinstate nRetVal=%d\n", PINCTRL_STATE_SUSPEND, nRetVal); 
+        goto ERROR_PINCTRL_LOOKUP;
+    }
+
+    _gPinCtrlStateRelease = pinctrl_lookup_state(_gTsPinCtrl, PINCTRL_STATE_RELEASE);
+    if (IS_ERR_OR_NULL(_gPinCtrlStateRelease)) 
+    {
+        nRetVal = PTR_ERR(_gPinCtrlStateRelease);
+        DBG(&g_I2cClient->dev, "Can not lookup %s pinstate nRetVal=%d\n", PINCTRL_STATE_RELEASE, nRetVal); 
+    }
+    
+    pinctrl_select_state(_gTsPinCtrl, _gPinCtrlStateActive);
+    
+    return 0;
+
+ERROR_PINCTRL_LOOKUP:
+    devm_pinctrl_put(_gTsPinCtrl);
+ERROR_PINCTRL_GET:
+    _gTsPinCtrl = NULL;
+	
+    return nRetVal;
+}
+
+static void _DrvPlatformLyrTouchPinCtrlUnInit(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    if (_gTsPinCtrl)
+    {
+        devm_pinctrl_put(_gTsPinCtrl);
+        _gTsPinCtrl = NULL;
+    }
+}
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+/* read data through I2C then report data to input sub-system when interrupt occurred */
+static void _DrvPlatformLyrFingerTouchDoWork(struct work_struct *pWork)
+{
+    unsigned long nIrqFlag;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvIcFwLyrHandleFingerTouch(NULL, 0);
+
+    DBG(&g_I2cClient->dev, "*** %s() _gInterruptFlag = %d ***\n", __func__, _gInterruptFlag);  // add for debug
+
+    spin_lock_irqsave(&_gIrqLock, nIrqFlag);
+
+    if (_gInterruptFlag == 0
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+        && g_IsInMpTest == 0
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+    ) 
+    {
+        enable_irq(_gIrq);
+
+        _gInterruptFlag = 1;
+    } 
+        
+    spin_unlock_irqrestore(&_gIrqLock, nIrqFlag);
+}
+
+/* The interrupt service routine will be triggered when interrupt occurred */
+static irqreturn_t _DrvPlatformLyrFingerTouchInterruptHandler(s32 nIrq, void *pDeviceId)
+{
+    unsigned long nIrqFlag;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    DBG(&g_I2cClient->dev, "*** %s() _gInterruptFlag = %d ***\n", __func__, _gInterruptFlag); 
+
+    spin_lock_irqsave(&_gIrqLock, nIrqFlag);
+
+    if (_gInterruptFlag == 1
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+        && g_IsInMpTest == 0
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+    ) 
+    {
+        disable_irq_nosync(_gIrq);
+
+        _gInterruptFlag = 0;
+
+        schedule_work(&_gFingerTouchWork);
+    }
+
+    spin_unlock_irqrestore(&_gIrqLock, nIrqFlag);
+    
+    return IRQ_HANDLED;
+}
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+/*
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+static s32 _DrvPlatformLyrTouchPinCtrlInit(struct i2c_client *pClient)
+{
+    struct device_node *pDeviceNode = pClient->dev.of_node;
+	
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (pDeviceNode) {
+        const struct of_device_id *pMatchDevice;
+
+        pMatchDevice = of_match_device(of_match_ptr(touch_dt_match_table), &pClient->dev);
+        if (!pMatchDevice) {
+            DBG(&g_I2cClient->dev, "No device match found!\n");
+            return -ENODEV;
+        }
+    }
+    
+    _gGpioRst = of_get_named_gpio(pDeviceNode, "mstar,rst-gpio", 0);
+    
+    MS_TS_MSG_IC_GPIO_RST = _gGpioRst;
+    
+    if (_gGpioRst < 0)
+    {
+        return _gGpioRst;
+    }
+
+    _gGpioIrq = of_get_named_gpio(pDeviceNode, "mstar,irq-gpio", 0);
+    
+    MS_TS_MSG_IC_GPIO_INT = _gGpioIrq;
+	
+    DBG(&g_I2cClient->dev, "_gGpioRst = %d, _gGpioIrq = %d\n", _gGpioRst, _gGpioIrq);
+    
+    if (_gGpioIrq < 0)
+    {
+        return _gGpioIrq;
+    }
+    
+    return 0;
+}
+
+static void _DrvPlatformLyrTouchPinCtrlUnInit(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+}
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+*/
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+//static irqreturn_t _DrvPlatformLyrFingerTouchInterruptHandler(s32 nIrq, struct irq_desc *desc)
+static irqreturn_t _DrvPlatformLyrFingerTouchInterruptHandler(s32 nIrq, void *pDeviceId)
+#else
+static void _DrvPlatformLyrFingerTouchInterruptHandler(void)
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+{
+    unsigned long nIrqFlag;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    DBG(&g_I2cClient->dev, "*** %s() _gInterruptFlag = %d ***\n", __func__, _gInterruptFlag); 
+
+    spin_lock_irqsave(&_gIrqLock, nIrqFlag);
+
+#ifdef CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+
+    if (_gInterruptFlag == 1
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+        && g_IsInMpTest == 0
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+    ) 
+    {
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+        disable_irq_nosync(_gIrq);
+#else
+        mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+        _gInterruptFlag = 0;
+
+        schedule_work(&_gFingerTouchWork);
+    }
+
+#else    
+
+    if (_gInterruptFlag == 1
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+        && g_IsInMpTest == 0
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+    )
+    {    
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+        disable_irq_nosync(_gIrq);
+#else
+        mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+        _gInterruptFlag = 0;
+
+        _gTpdFlag = 1;
+        wake_up_interruptible(&_gWaiter);
+    }        
+#endif //CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+
+    spin_unlock_irqrestore(&_gIrqLock, nIrqFlag);
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+    return IRQ_HANDLED;
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+}
+
+#ifdef CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+/* read data through I2C then report data to input sub-system when interrupt occurred */
+static void _DrvPlatformLyrFingerTouchDoWork(struct work_struct *pWork)
+{
+    unsigned long nIrqFlag;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvIcFwLyrHandleFingerTouch(NULL, 0);
+
+    DBG(&g_I2cClient->dev, "*** %s() _gInterruptFlag = %d ***\n", __func__, _gInterruptFlag);  // add for debug
+
+    spin_lock_irqsave(&_gIrqLock, nIrqFlag);
+
+    if (_gInterruptFlag == 0
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+        && g_IsInMpTest == 0
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+    ) 
+    {
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+        enable_irq(_gIrq);
+#else
+        mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+        _gInterruptFlag = 1;
+    }
+
+    spin_unlock_irqrestore(&_gIrqLock, nIrqFlag);
+}
+
+#else
+
+static int _DrvPlatformLyrFingerTouchHandler(void *pUnUsed)
+{
+    unsigned long nIrqFlag;
+    struct sched_param param = { .sched_priority = RTPM_PRIO_TPD };
+    sched_setscheduler(current, SCHED_RR, &param);
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+	
+    do
+    {
+        set_current_state(TASK_INTERRUPTIBLE);
+        wait_event_interruptible(_gWaiter, _gTpdFlag != 0);
+        _gTpdFlag = 0;
+        
+        set_current_state(TASK_RUNNING);
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+        if (g_IsInMpTest == 0)
+        {
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+            DrvIcFwLyrHandleFingerTouch(NULL, 0);
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+        }
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+        DBG(&g_I2cClient->dev, "*** %s() _gInterruptFlag = %d ***\n", __func__, _gInterruptFlag); 
+
+        spin_lock_irqsave(&_gIrqLock, nIrqFlag);
+
+        if (_gInterruptFlag == 0       
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+            && g_IsInMpTest == 0
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+        )
+        {
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+            enable_irq(_gIrq);
+#else
+            mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+            _gInterruptFlag = 1;
+        } 
+
+        spin_unlock_irqrestore(&_gIrqLock, nIrqFlag);
+		
+    } while (!kthread_should_stop());
+	
+    return 0;
+}
+#endif //CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+#endif
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+void DrvPlatformLyrTouchDeviceRegulatorPowerOn(bool nFlag)
+{
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    s32 nRetVal = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    if (nFlag == true)
+    {
+        nRetVal = regulator_enable(g_ReguVdd);
+        if (nRetVal)
+        {
+            DBG(&g_I2cClient->dev, "regulator_enable(g_ReguVdd) failed. nRetVal=%d\n", nRetVal); 
+        }
+        mdelay(20);
+
+        nRetVal = regulator_enable(g_ReguVcc_i2c);
+        if (nRetVal)
+        {
+            DBG(&g_I2cClient->dev, "regulator_enable(g_ReguVcc_i2c) failed. nRetVal=%d\n", nRetVal); 
+        }
+        mdelay(20);
+    }
+    else
+    {
+        nRetVal = regulator_disable(g_ReguVdd);
+        if (nRetVal)
+        {
+            DBG(&g_I2cClient->dev, "regulator_disable(g_ReguVdd) failed. nRetVal=%d\n", nRetVal); 
+        }
+        mdelay(20);
+
+        nRetVal = regulator_disable(g_ReguVcc_i2c);
+        if (nRetVal)
+        {
+            DBG(&g_I2cClient->dev, "regulator_disable(g_ReguVcc_i2c) failed. nRetVal=%d\n", nRetVal); 
+        }
+        mdelay(20);
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+    s32 nRetVal = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (nFlag == true)
+    {
+        nRetVal = regulator_enable(g_ReguVdd);
+        if (nRetVal)
+        {
+            DBG(&g_I2cClient->dev, "regulator_enable(g_ReguVdd) failed. nRetVal=%d\n", nRetVal);
+        }
+        mdelay(20);
+    }
+    else
+    {
+        nRetVal = regulator_disable(g_ReguVdd);
+        if (nRetVal)
+        {
+            DBG(&g_I2cClient->dev, "regulator_disable(g_ReguVdd) failed. nRetVal=%d\n", nRetVal);
+        }
+        mdelay(20);
+    }
+#else
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+//    hwPowerOn(MT6323_POWER_LDO_VGP1, VOL_2800, "TP"); // For specific MTK BB chip(ex. MT6582), need to enable this function call for correctly power on Touch IC.
+    hwPowerOn(PMIC_APP_CAP_TOUCH_VDD, VOL_2800, "TP"); // For specific MTK BB chip(ex. MT6735), need to enable this function call for correctly power on Touch IC.
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+#endif
+}
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+void DrvPlatformLyrTouchDevicePowerOn(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+    
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    gpio_direction_output(MS_TS_MSG_IC_GPIO_RST, 1);
+//    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 1); 
+    udelay(100); 
+    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 0);
+    mdelay(100);
+    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 1);
+    mdelay(25); 
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+    tpd_gpio_output(MS_TS_MSG_IC_GPIO_RST, 1);
+    udelay(100);
+    tpd_gpio_output(MS_TS_MSG_IC_GPIO_RST, 0);
+    mdelay(100);
+    tpd_gpio_output(MS_TS_MSG_IC_GPIO_RST, 1);
+    mdelay(25); 
+#else
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ONE);  
+    udelay(100); 
+
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ZERO);  
+    mdelay(100);
+
+#ifdef TPD_CLOSE_POWER_IN_SLEEP
+    hwPowerDown(TPD_POWER_SOURCE, "TP"); 
+    mdelay(100);
+    hwPowerOn(TPD_POWER_SOURCE, VOL_2800, "TP"); 
+    mdelay(10);  // reset pulse
+#endif //TPD_CLOSE_POWER_IN_SLEEP
+
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ONE);
+    mdelay(25); 
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD    
+#endif
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+    g_IsEnableEsdCheck = 1;
+    g_IsHwResetByDriver = 1; // Indicate HwReset is triggered by Device Driver instead of Firmware or Touch IC
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+}
+
+void DrvPlatformLyrTouchDevicePowerOff(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+    
+    DrvIcFwLyrOptimizeCurrentConsumption();
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+//    gpio_direction_output(MS_TS_MSG_IC_GPIO_RST, 0);
+    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 0);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+    tpd_gpio_output(MS_TS_MSG_IC_GPIO_RST, 0);
+#else
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ZERO);  
+
+#ifdef TPD_CLOSE_POWER_IN_SLEEP
+    hwPowerDown(TPD_POWER_SOURCE, "TP");
+#endif //TPD_CLOSE_POWER_IN_SLEEP
+
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#endif    
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+    g_IsEnableEsdCheck = 0;
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+}
+
+void DrvPlatformLyrTouchDeviceResetHw(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+    
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    gpio_direction_output(MS_TS_MSG_IC_GPIO_RST, 1);
+//    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 1); 
+    udelay(100); 
+    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 0);
+    mdelay(100);
+    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 1);
+    mdelay(25); 
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+    tpd_gpio_output(MS_TS_MSG_IC_GPIO_RST, 1);
+    udelay(100);
+    tpd_gpio_output(MS_TS_MSG_IC_GPIO_RST, 0);
+    mdelay(100);
+    tpd_gpio_output(MS_TS_MSG_IC_GPIO_RST, 1);
+    mdelay(25); 
+#else
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ONE);
+    udelay(100); 
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ZERO);  
+    mdelay(100);
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ONE);
+    mdelay(25); 
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#endif
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+    g_IsEnableEsdCheck = 1;
+    g_IsHwResetByDriver = 1; // Indicate HwReset is triggered by Device Driver instead of Firmware or Touch IC
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+}
+
+void DrvPlatformLyrDisableFingerTouchReport(void)
+{
+    unsigned long nIrqFlag;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    DBG(&g_I2cClient->dev, "*** %s() _gInterruptFlag = %d ***\n", __func__, _gInterruptFlag); 
+
+    spin_lock_irqsave(&_gIrqLock, nIrqFlag);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+    if (g_HotKnotState != HOTKNOT_TRANS_STATE && g_HotKnotState != HOTKNOT_BEFORE_TRANS_STATE)
+#endif //CONFIG_ENABLE_HOTKNOT
+    {
+        if (_gInterruptFlag == 1)  
+        {
+            disable_irq(_gIrq);
+
+            _gInterruptFlag = 0;
+        }
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+    if (g_HotKnotState != HOTKNOT_TRANS_STATE && g_HotKnotState != HOTKNOT_BEFORE_TRANS_STATE)
+#endif //CONFIG_ENABLE_HOTKNOT           
+    {
+        if (_gInterruptFlag == 1) 
+        {
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+            disable_irq(_gIrq);
+#else
+            mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD            
+
+            _gInterruptFlag = 0;
+        }
+    }
+#endif
+
+    spin_unlock_irqrestore(&_gIrqLock, nIrqFlag);
+}
+
+void DrvPlatformLyrEnableFingerTouchReport(void)
+{
+    unsigned long nIrqFlag;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    DBG(&g_I2cClient->dev, "*** %s() _gInterruptFlag = %d ***\n", __func__, _gInterruptFlag); 
+
+    spin_lock_irqsave(&_gIrqLock, nIrqFlag);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+
+    if (_gInterruptFlag == 0) 
+    {
+        enable_irq(_gIrq);
+
+        _gInterruptFlag = 1;        
+    }
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+
+    if (_gInterruptFlag == 0) 
+    {
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+        enable_irq(_gIrq);
+#else
+        mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+        _gInterruptFlag = 1;        
+    }
+
+#endif
+
+    spin_unlock_irqrestore(&_gIrqLock, nIrqFlag);
+}
+
+void DrvPlatformLyrFingerTouchPressed(s32 nX, s32 nY, s32 nPressure, s32 nId)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+    DBG(&g_I2cClient->dev, "point touch pressed\n"); 
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL // TYPE B PROTOCOL
+    input_mt_slot(g_InputDevice, nId);
+    input_mt_report_slot_state(g_InputDevice, MT_TOOL_FINGER, true);
+    input_report_abs(g_InputDevice, ABS_MT_POSITION_X, nX);
+    input_report_abs(g_InputDevice, ABS_MT_POSITION_Y, nY);
+#ifdef CONFIG_ENABLE_FORCE_TOUCH
+    input_report_abs(g_InputDevice, ABS_MT_PRESSURE, nPressure);
+#endif //CONFIG_ENABLE_FORCE_TOUCH
+
+    DBG(&g_I2cClient->dev, "nId=%d, nX=%d, nY=%d\n", nId, nX, nY); // TODO : add for debug
+#else // TYPE A PROTOCOL
+    input_report_key(g_InputDevice, BTN_TOUCH, 1);
+    if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        input_report_abs(g_InputDevice, ABS_MT_TRACKING_ID, nId); // ABS_MT_TRACKING_ID is used for MSG26xxM/MSG28xx only
+    }
+    input_report_abs(g_InputDevice, ABS_MT_TOUCH_MAJOR, 1);
+    input_report_abs(g_InputDevice, ABS_MT_WIDTH_MAJOR, 1);
+    input_report_abs(g_InputDevice, ABS_MT_POSITION_X, nX);
+    input_report_abs(g_InputDevice, ABS_MT_POSITION_Y, nY);
+#ifdef CONFIG_ENABLE_FORCE_TOUCH
+    input_report_abs(g_InputDevice, ABS_MT_PRESSURE, nPressure);
+#endif //CONFIG_ENABLE_FORCE_TOUCH
+
+    input_mt_sync(g_InputDevice);
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#ifdef CONFIG_MTK_BOOT
+    if (tpd_dts_data.use_tpd_button)
+    {
+        if (FACTORY_BOOT == get_boot_mode() || RECOVERY_BOOT == get_boot_mode())
+        {   
+            tpd_button(nX, nY, 1);  
+        }
+    }
+#endif //CONFIG_MTK_BOOT
+#else
+#ifdef CONFIG_TP_HAVE_KEY    
+    if (FACTORY_BOOT == get_boot_mode() || RECOVERY_BOOT == get_boot_mode())
+    {   
+        tpd_button(nX, nY, 1);  
+    }
+#endif //CONFIG_TP_HAVE_KEY
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+    TPD_EM_PRINT(nX, nY, nX, nY, nId, 1);
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+}
+
+void DrvPlatformLyrFingerTouchReleased(s32 nX, s32 nY, s32 nId)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+    DBG(&g_I2cClient->dev, "point touch released\n"); 
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL // TYPE B PROTOCOL
+    input_mt_slot(g_InputDevice, nId);
+    input_mt_report_slot_state(g_InputDevice, MT_TOOL_FINGER, false);
+
+    DBG(&g_I2cClient->dev, "nId=%d\n", nId); // TODO : add for debug
+#else // TYPE A PROTOCOL
+    input_report_key(g_InputDevice, BTN_TOUCH, 0);
+    input_mt_sync(g_InputDevice);
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#ifdef CONFIG_MTK_BOOT
+    if (tpd_dts_data.use_tpd_button)
+    {
+        if (FACTORY_BOOT == get_boot_mode() || RECOVERY_BOOT == get_boot_mode())
+        {   
+            tpd_button(nX, nY, 0); 
+        }            
+    }
+#endif //CONFIG_MTK_BOOT  
+#else
+#ifdef CONFIG_TP_HAVE_KEY 
+    if (FACTORY_BOOT == get_boot_mode() || RECOVERY_BOOT == get_boot_mode())
+    {   
+       tpd_button(nX, nY, 0); 
+    }            
+#endif //CONFIG_TP_HAVE_KEY    
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+    TPD_EM_PRINT(nX, nY, nX, nY, 0, 0);
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+}
+
+void DrvPlatformLyrVariableInitialize(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    mutex_init(&g_Mutex);
+    spin_lock_init(&_gIrqLock);
+}
+
+s32 DrvPlatformLyrInputDeviceInitialize(struct i2c_client *pClient)
+{
+    s32 nRetVal = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    /* allocate an input device */
+    g_InputDevice = input_allocate_device();
+    if (g_InputDevice == NULL)
+    {
+        DBG(&g_I2cClient->dev, "*** Failed to allocate touch input device ***\n"); 
+        return -ENOMEM;
+    }
+
+    g_InputDevice->name = pClient->name;
+    g_InputDevice->phys = "I2C";
+    g_InputDevice->dev.parent = &pClient->dev;
+    g_InputDevice->id.bustype = BUS_I2C;
+    
+    /* set the supported event type for input device */
+    set_bit(EV_ABS, g_InputDevice->evbit);
+    set_bit(EV_SYN, g_InputDevice->evbit);
+    set_bit(EV_KEY, g_InputDevice->evbit);
+    set_bit(BTN_TOUCH, g_InputDevice->keybit);
+    set_bit(INPUT_PROP_DIRECT, g_InputDevice->propbit);
+
+#ifdef CONFIG_TP_HAVE_KEY
+    // Method 1.
+    { 
+        u32 i;
+        for (i = 0; i < MAX_KEY_NUM; i ++)
+        {
+            input_set_capability(g_InputDevice, EV_KEY, g_TpVirtualKey[i]);
+        }
+    }
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+    _DrvPlatformLyrVirtualKeysInit(); // Initialize virtual keys for specific SPRC/QCOM platform.
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_TP_HAVE_KEY
+
+/*  
+#ifdef CONFIG_TP_HAVE_KEY
+    // Method 2.
+    set_bit(TOUCH_KEY_MENU, g_InputDevice->keybit); //Menu
+    set_bit(TOUCH_KEY_HOME, g_InputDevice->keybit); //Home
+    set_bit(TOUCH_KEY_BACK, g_InputDevice->keybit); //Back
+    set_bit(TOUCH_KEY_SEARCH, g_InputDevice->keybit); //Search
+#endif //CONFIG_TP_HAVE_KEY
+*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    input_set_capability(g_InputDevice, EV_KEY, KEY_POWER);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_UP);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_DOWN);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_LEFT);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_RIGHT);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_W);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_Z);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_V);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_O);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_M);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_C);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_E);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_S);
+	input_set_capability(g_InputDevice, EV_KEY, KEY_P);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+    if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        input_set_abs_params(g_InputDevice, ABS_MT_TRACKING_ID, 0, (MUTUAL_MAX_TOUCH_NUM-1), 0, 0); // ABS_MT_TRACKING_ID is used for MSG26xxM/MSG28xx only
+    }
+
+#ifndef CONFIG_ENABLE_TYPE_B_PROTOCOL
+    input_set_abs_params(g_InputDevice, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_WIDTH_MAJOR, 0, 15, 0, 0);
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+    input_set_abs_params(g_InputDevice, ABS_MT_POSITION_X, TOUCH_SCREEN_X_MIN, TOUCH_SCREEN_X_MAX, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_POSITION_Y, TOUCH_SCREEN_Y_MIN, TOUCH_SCREEN_Y_MAX, 0, 0);
+#ifdef CONFIG_ENABLE_FORCE_TOUCH
+    input_set_abs_params(g_InputDevice, ABS_MT_PRESSURE, 0, 255, 0, 0);
+#endif //CONFIG_ENABLE_FORCE_TOUCH
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+    if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        set_bit(BTN_TOOL_FINGER, g_InputDevice->keybit);
+        input_mt_init_slots(g_InputDevice, SELF_MAX_TOUCH_NUM, 0); // for MSG21xxA/MSG22xx
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        set_bit(BTN_TOOL_FINGER, g_InputDevice->keybit);
+        input_mt_init_slots(g_InputDevice, MUTUAL_MAX_TOUCH_NUM, 0);  // for MSG26xxM/MSG28xx 
+    }
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+    /* register the input device to input sub-system */
+    nRetVal = input_register_device(g_InputDevice);
+    if (nRetVal < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Unable to register touch input device *** nRetVal=%d\n", nRetVal); 
+        return nRetVal;
+    }
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+    nRetVal = _DrvPlatformLyrProximityInputDeviceInit(pClient);
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    g_InputDevice = tpd->dev;
+/*
+    g_InputDevice->phys = "I2C";
+    g_InputDevice->dev.parent = &pClient->dev;
+    g_InputDevice->id.bustype = BUS_I2C;
+    
+    // set the supported event type for input device 
+    set_bit(EV_ABS, g_InputDevice->evbit);
+    set_bit(EV_SYN, g_InputDevice->evbit);
+    set_bit(EV_KEY, g_InputDevice->evbit);
+    set_bit(BTN_TOUCH, g_InputDevice->keybit);
+    set_bit(INPUT_PROP_DIRECT, g_InputDevice->propbit);
+*/
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+    if (tpd_dts_data.use_tpd_button)
+    {
+        u32 i;
+
+        for (i = 0; i < tpd_dts_data.tpd_key_num; i ++)
+        {
+            input_set_capability(g_InputDevice, EV_KEY, tpd_dts_data.tpd_key_local[i]);
+        }
+    }
+#else
+#ifdef CONFIG_TP_HAVE_KEY
+    {
+        u32 i;
+        
+        for (i = 0; i < MAX_KEY_NUM; i ++)
+        {
+            input_set_capability(g_InputDevice, EV_KEY, g_TpVirtualKey[i]);
+        }
+    }
+#endif //CONFIG_TP_HAVE_KEY
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    input_set_capability(g_InputDevice, EV_KEY, KEY_POWER);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_UP);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_DOWN);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_LEFT);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_RIGHT);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_W);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_Z);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_V);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_O);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_M);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_C);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_E);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_S);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+    if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        input_set_abs_params(g_InputDevice, ABS_MT_TRACKING_ID, 0, (MUTUAL_MAX_TOUCH_NUM-1), 0, 0); // ABS_MT_TRACKING_ID is used for MSG26xxM/MSG28xx only
+    }
+#ifdef CONFIG_ENABLE_FORCE_TOUCH
+    input_set_abs_params(g_InputDevice, ABS_MT_PRESSURE, 0, 255, 0, 0);
+#endif //CONFIG_ENABLE_FORCE_TOUCH
+
+/*
+#ifndef CONFIG_ENABLE_TYPE_B_PROTOCOL
+    input_set_abs_params(g_InputDevice, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_WIDTH_MAJOR, 0, 15, 0, 0);
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+    input_set_abs_params(g_InputDevice, ABS_MT_POSITION_X, TOUCH_SCREEN_X_MIN, TOUCH_SCREEN_X_MAX, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_POSITION_Y, TOUCH_SCREEN_Y_MIN, TOUCH_SCREEN_Y_MAX, 0, 0);
+*/
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+    if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        set_bit(BTN_TOOL_FINGER, g_InputDevice->keybit);
+        input_mt_init_slots(g_InputDevice, SELF_MAX_TOUCH_NUM, 0); // for MSG21xxA/MSG22xx
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        set_bit(BTN_TOOL_FINGER, g_InputDevice->keybit);
+        input_mt_init_slots(g_InputDevice, MUTUAL_MAX_TOUCH_NUM, 0); // for MSG26xxM/MSG28xx
+    }
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+#endif
+
+    return nRetVal;    
+}
+
+s32 DrvPlatformLyrTouchDeviceRequestGPIO(struct i2c_client *pClient)
+{
+    s32 nRetVal = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+    
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+    _DrvPlatformLyrTouchPinCtrlInit(pClient);
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+    nRetVal = gpio_request(MS_TS_MSG_IC_GPIO_RST, "C_TP_RST");     
+    if (nRetVal < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Failed to request GPIO %d, error %d ***\n", MS_TS_MSG_IC_GPIO_RST, nRetVal); 
+    }
+
+    nRetVal = gpio_request(MS_TS_MSG_IC_GPIO_INT, "C_TP_INT");    
+    if (nRetVal < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Failed to request GPIO %d, error %d ***\n", MS_TS_MSG_IC_GPIO_INT, nRetVal); 
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+/*
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+    _DrvPlatformLyrTouchPinCtrlInit(pClient);
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+//    nRetVal = gpio_request(MS_TS_MSG_IC_GPIO_RST, "C_TP_RST");     
+    nRetVal = gpio_request_one(MS_TS_MSG_IC_GPIO_RST, GPIOF_OUT_INIT_LOW, "C_TP_RST");     
+    if (nRetVal < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Failed to request GPIO %d, error %d ***\n", MS_TS_MSG_IC_GPIO_RST, nRetVal);
+    }
+
+//    nRetVal = gpio_request(MS_TS_MSG_IC_GPIO_INT, "C_TP_INT");    
+    nRetVal = gpio_request_one(MS_TS_MSG_IC_GPIO_INT, GPIOF_IN, "C_TP_INT");    
+    if (nRetVal < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Failed to request GPIO %d, error %d ***\n", MS_TS_MSG_IC_GPIO_INT, nRetVal);
+    }
+*/
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+#endif
+
+    return nRetVal;    
+}
+extern int gpio_isr;
+s32 DrvPlatformLyrTouchDeviceRegisterFingerTouchInterruptHandler(void)
+{
+    s32 nRetVal = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+    if (DrvIcFwLyrIsRegisterFingerTouchInterruptHandler())
+    {    	
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+        /* initialize the finger touch work queue */ 
+        INIT_WORK(&_gFingerTouchWork, _DrvPlatformLyrFingerTouchDoWork);
+
+        _gIrq = gpio_to_irq(MS_TS_MSG_IC_GPIO_INT);
+		gpio_isr = _gIrq;
+
+        /* request an irq and register the isr */
+        nRetVal = request_threaded_irq(_gIrq, NULL, _DrvPlatformLyrFingerTouchInterruptHandler,
+                      IRQF_TRIGGER_RISING| IRQF_ONESHOT | IRQF_NO_SUSPEND ,"msg2xxx", NULL); 
+
+        _gInterruptFlag = 1;
+        
+        if (nRetVal != 0)
+        {
+            DBG(&g_I2cClient->dev, "*** Unable to claim irq %d; error %d ***\n", _gIrq, nRetVal); 
+        }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+        {
+            struct device_node *pDeviceNode = NULL;
+            u32 ints[2] = {0,0};
+
+            tpd_gpio_as_int(MS_TS_MSG_IC_GPIO_INT);
+
+//            pDeviceNode = of_find_compatible_node(NULL, NULL, "mediatek,touch_panel-eint"); //"mediatek,cap_touch"
+            pDeviceNode = of_find_matching_node(pDeviceNode, touch_of_match);
+            
+            if (pDeviceNode)
+            {
+                of_property_read_u32_array(pDeviceNode, "debounce", ints, ARRAY_SIZE(ints));
+                gpio_set_debounce(ints[0], ints[1]);
+                
+                _gIrq = irq_of_parse_and_map(pDeviceNode, 0);
+                if (_gIrq == 0)
+                {
+                    DBG(&g_I2cClient->dev, "*** Unable to irq_of_parse_and_map() ***\n");
+                }
+
+                /* request an irq and register the isr */
+                nRetVal = request_threaded_irq(_gIrq/*MS_TS_MSG_IC_GPIO_INT*/, NULL, _DrvPlatformLyrFingerTouchInterruptHandler,
+                      IRQF_TRIGGER_RISING /* IRQF_TRIGGER_FALLING *//*IRQF_TRIGGER_NONE */| IRQF_ONESHOT/* | IRQF_NO_SUSPEND */,
+                      "touch_panel-eint", NULL); 
+
+//                nRetVal = request_irq(_gIrq/*MS_TS_MSG_IC_GPIO_INT*/, _DrvPlatformLyrFingerTouchInterruptHandler,
+//                      IRQF_TRIGGER_RISING /* IRQF_TRIGGER_FALLING *//*IRQF_TRIGGER_NONE *//* | IRQF_NO_SUSPEND */,
+//                      "touch_panel-eint", NULL); 
+
+                if (nRetVal != 0)
+                {
+                    DBG(&g_I2cClient->dev, "*** Unable to claim irq %d; error %d ***\n", _gIrq, nRetVal);
+                    DBG(&g_I2cClient->dev, "*** gpio_pin=%d, debounce=%d ***\n", ints[0], ints[1]);
+                }
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "*** request_irq() can not find touch eint device node! ***\n");
+            }
+
+//            enable_irq(_gIrq);
+        }
+#else
+        mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_INT, GPIO_CTP_EINT_PIN_M_EINT);
+        mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_INT, GPIO_DIR_IN);
+        mt_set_gpio_pull_enable(MS_TS_MSG_IC_GPIO_INT, GPIO_PULL_ENABLE);
+        mt_set_gpio_pull_select(MS_TS_MSG_IC_GPIO_INT, GPIO_PULL_UP);
+
+        mt_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN);
+        mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_TYPE/* EINTF_TRIGGER_RISING */, _DrvPlatformLyrFingerTouchInterruptHandler, 1);
+
+        mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+        _gInterruptFlag = 1;
+
+#ifdef CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+        /* initialize the finger touch work queue */ 
+        INIT_WORK(&_gFingerTouchWork, _DrvPlatformLyrFingerTouchDoWork);
+#else
+        _gThread = kthread_run(_DrvPlatformLyrFingerTouchHandler, 0, TPD_DEVICE);
+        if (IS_ERR(_gThread))
+        { 
+            nRetVal = PTR_ERR(_gThread);
+            DBG(&g_I2cClient->dev, "Failed to create kernel thread: %d\n", nRetVal); 
+        }
+#endif //CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+#endif
+    }
+    
+    return nRetVal;    
+}	
+
+void DrvPlatformLyrTouchDeviceRegisterEarlySuspend(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+#ifdef CONFIG_ENABLE_NOTIFIER_FB
+    _gFbNotifier.notifier_call = MsDrvInterfaceTouchDeviceFbNotifierCallback;
+    fb_register_client(&_gFbNotifier);
+#else
+    _gEarlySuspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+    _gEarlySuspend.suspend = MsDrvInterfaceTouchDeviceSuspend;
+    _gEarlySuspend.resume = MsDrvInterfaceTouchDeviceResume;
+    register_early_suspend(&_gEarlySuspend);
+#endif //CONFIG_ENABLE_NOTIFIER_FB   
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM || CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM
+}
+
+/* remove function is triggered when the input device is removed from input sub-system */
+s32 DrvPlatformLyrTouchDeviceRemove(struct i2c_client *pClient)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__); 
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    gpio_free(MS_TS_MSG_IC_GPIO_INT);
+    gpio_free(MS_TS_MSG_IC_GPIO_RST);
+    
+    if (g_InputDevice)
+    {
+        free_irq(_gIrq, g_InputDevice);
+
+        input_unregister_device(g_InputDevice);
+        g_InputDevice = NULL;
+    }
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+    _DrvPlatformLyrTouchPinCtrlUnInit();
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+#ifdef CONFIG_TP_HAVE_KEY
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+    _DrvPlatformLyrVirtualKeysUnInit();
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_TP_HAVE_KEY
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+    _DrvPlatformLyrProximityInputDeviceUnInit();
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION   
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+//    gpio_free(MS_TS_MSG_IC_GPIO_INT);
+//    gpio_free(MS_TS_MSG_IC_GPIO_RST);
+/*
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+    _DrvPlatformLyrTouchPinCtrlUnInit();
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+*/
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+#endif    
+
+    if (IS_FIRMWARE_DATA_LOG_ENABLED)
+    {    	
+        if (g_TouchKSet)
+        {
+            kset_unregister(g_TouchKSet);
+            g_TouchKSet = NULL;
+        }
+    
+        if (g_TouchKObj)
+        {
+            kobject_put(g_TouchKObj);
+            g_TouchKObj = NULL;
+        }
+    } //IS_FIRMWARE_DATA_LOG_ENABLED
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+    if (g_GestureKSet)
+    {
+        kset_unregister(g_GestureKSet);
+        g_GestureKSet = NULL;
+    }
+    
+    if (g_GestureKObj)
+    {
+        kobject_put(g_GestureKObj);
+        g_GestureKObj = NULL;
+    }
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+    DrvMainRemoveProcfsDirEntry();
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+    DeleteQueue();
+    DeleteHotKnotMem();
+    DBG(&g_I2cClient->dev, "Deregister hotknot misc device.\n"); 
+    misc_deregister(&hotknot_miscdevice);   
+#endif //CONFIG_ENABLE_HOTKNOT
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+    DeleteMsgToolMem();
+#endif //CONFIG_ENABLE_JNI_INTERFACE
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+    if (g_EsdCheckWorkqueue)
+    {
+        destroy_workqueue(g_EsdCheckWorkqueue);
+        g_EsdCheckWorkqueue = NULL;
+    }
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaFree();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    return 0;
+}
+
+void DrvPlatformLyrSetIicDataRate(struct i2c_client *pClient, u32 nIicDataRate)
+{
+    DBG(&g_I2cClient->dev, "*** %s() nIicDataRate = %d ***\n", __func__, nIicDataRate); 
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+    // TODO : Please FAE colleague to confirm with customer device driver engineer for how to set i2c data rate on SPRD platform
+    sprd_i2c_ctl_chg_clk(pClient->adapter->nr, nIicDataRate); 
+    mdelay(100);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    // TODO : Please FAE colleague to confirm with customer device driver engineer for how to set i2c data rate on QCOM platform
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    pClient->timing = nIicDataRate/1000;
+#endif
+}
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+
+int DrvPlatformLyrGetTpPsData(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() g_FaceClosingTp = %d ***\n", __func__, g_FaceClosingTp); 
+	
+    return g_FaceClosingTp;
+}
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+void DrvPlatformLyrTpPsEnable(int nEnable)
+{
+    DBG(&g_I2cClient->dev, "*** %s() nEnable = %d ***\n", __func__, nEnable); 
+
+    if (nEnable)
+    {
+        DrvIcFwLyrEnableProximity();
+    }
+    else
+    {
+        DrvIcFwLyrDisableProximity();
+    }
+}
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+int DrvPlatformLyrTpPsEnable(struct sensors_classdev* pProximityCdev, unsigned int nEnable)
+{
+    DBG(&g_I2cClient->dev, "*** %s() nEnable = %d ***\n", __func__, nEnable); 
+
+    if (nEnable)
+    {
+        DrvIcFwLyrEnableProximity();
+    }
+    else
+    {
+        DrvIcFwLyrDisableProximity();
+    }
+    
+    return 0;
+}
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+int DrvPlatformLyrTpPsOperate(void* pSelf, u32 nCommand, void* pBuffIn, int nSizeIn,
+				   void* pBuffOut, int nSizeOut, int* pActualOut)
+{
+    int nErr = 0;
+    int nValue;
+    hwm_sensor_data *pSensorData;
+
+    switch (nCommand)
+    {
+        case SENSOR_DELAY:
+            if ((pBuffIn == NULL) || (nSizeIn < sizeof(int)))
+            {
+                nErr = -EINVAL;
+            }
+            // Do nothing
+            break;
+
+        case SENSOR_ENABLE:
+            if ((pBuffIn == NULL) || (nSizeIn < sizeof(int)))
+            {
+                nErr = -EINVAL;
+            }
+            else
+            {
+                nValue = *(int *)pBuffIn;
+                if (nValue)
+                {
+                    if (DrvIcFwLyrEnableProximity() < 0)
+                    {
+                        DBG(&g_I2cClient->dev, "Enable ps fail: %d\n", nErr); 
+                        return -1;
+                    }
+                }
+                else
+                {
+                    if (DrvIcFwLyrDisableProximity() < 0)
+                    {
+                        DBG(&g_I2cClient->dev, "Disable ps fail: %d\n", nErr); 
+                        return -1;
+                    }
+                }
+            }
+            break;
+
+        case SENSOR_GET_DATA:
+            if ((pBuffOut == NULL) || (nSizeOut < sizeof(hwm_sensor_data)))
+            {
+                DBG(&g_I2cClient->dev, "Get sensor data parameter error!\n"); 
+                nErr = -EINVAL;
+            }
+            else
+            {
+                pSensorData = (hwm_sensor_data *)pBuffOut;
+
+                pSensorData->values[0] = DrvPlatformLyrGetTpPsData();
+                pSensorData->value_divide = 1;
+                pSensorData->status = SENSOR_STATUS_ACCURACY_MEDIUM;
+            }
+            break;
+
+       default:
+           DBG(&g_I2cClient->dev, "Un-recognized parameter %d!\n", nCommand); 
+           nErr = -1;
+           break;
+    }
+
+    return nErr;
+}
+#endif
+
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+void DrvPlatformLyrEsdCheck(struct work_struct *pWork)
+{
+#ifdef CONFIG_ENABLE_ESD_CHECK_COMMAND_BY_FIRMWARE
+    static u8 szEsdCheckValue[8];
+    u8 szTxData[3] = {0};
+    u8 szRxData[8] = {0};
+    u32 i = 0;
+    s32 retW = -1;
+    s32 retR = -1;
+#else
+    u8 szData[MUTUAL_DEMO_MODE_PACKET_LENGTH] = {0xFF};
+    u32 i = 0;
+    s32 rc = 0;
+#endif //CONFIG_ENABLE_ESD_CHECK_COMMAND_BY_FIRMWARE
+
+    DBG(&g_I2cClient->dev, "*** %s() g_IsEnableEsdCheck = %d ***\n", __func__, g_IsEnableEsdCheck); 
+
+    if (g_IsEnableEsdCheck == 0)
+    {
+        return;
+    }
+
+    if (_gInterruptFlag == 0) // Skip ESD check while finger touch
+    {
+        DBG(&g_I2cClient->dev, "Not allow to do ESD check while finger touch.\n");
+        goto EsdCheckEnd;
+    }
+    	
+    if (g_IsUpdateFirmware != 0) // Check whether update frimware is finished
+    {
+        DBG(&g_I2cClient->dev, "Not allow to do ESD check while update firmware is proceeding.\n");
+        goto EsdCheckEnd;
+    }
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+    if (g_IsInMpTest == 1) // Check whether mp test is proceeding
+    {
+        DBG(&g_I2cClient->dev, "Not allow to do ESD check while mp test is proceeding.\n");
+        goto EsdCheckEnd;
+    }
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+#ifdef CONFIG_ENABLE_ESD_CHECK_COMMAND_BY_FIRMWARE /* Method 1. Require the new ESD check command(CmdId:0x55) support from firmware which is currently implemented for MSG22XX only. So default is not supported. */
+    szTxData[0] = 0x55;
+    szTxData[1] = 0xAA;
+    szTxData[2] = 0x55;
+
+    mutex_lock(&g_Mutex);
+
+    retW = IicWriteData(SLAVE_I2C_ID_DWI2C, &szTxData[0], 3);
+    retR = IicReadData(SLAVE_I2C_ID_DWI2C, &szRxData[0], 8);
+
+    mutex_unlock(&g_Mutex);
+
+    DBG(&g_I2cClient->dev, "szRxData[] : 0x%x  0x%x  0x%x  0x%x  0x%x  0x%x  0x%x  0x%x\n", \
+            szRxData[0], szRxData[1], szRxData[2], szRxData[3],szRxData[4], szRxData[5], szRxData[6], szRxData[7]);
+
+    DBG(&g_I2cClient->dev, "retW = %d, retR = %d\n", retW, retR);
+
+    if (retW > 0 && retR > 0)
+    {
+        while (i < 8)
+        {
+            if (szEsdCheckValue[i] != szRxData[i])
+            {
+                break;
+            }
+            i ++;
+        }
+        
+        if (i == 8)
+        {
+            if (szRxData[0] == 0 && szRxData[1] == 0 && szRxData[2] == 0 && szRxData[3] == 0 && szRxData[4] == 0 && szRxData[5] == 0 && szRxData[6] == 0 && szRxData[7] == 0)
+            {
+                DBG(&g_I2cClient->dev, "Firmware not support ESD check command.\n");
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "ESD check failed case1.\n");
+                
+                DrvPlatformLyrTouchDeviceResetHw();
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "ESD check success.\n");
+        } 
+
+        for (i = 0; i < 8; i ++)
+        {
+            szEsdCheckValue[i] = szRxData[i];
+        }
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "ESD check failed case2.\n");
+
+        DrvPlatformLyrTouchDeviceResetHw();
+    }
+#else /* Method 2. Use read finger touch data for checking whether I2C connection is still available under ESD testing. */
+    mutex_lock(&g_Mutex);
+    
+    while (i < 3)
+    {
+        mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+        if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)
+        {
+            rc = IicReadData(SLAVE_I2C_ID_DWI2C, &szData[0], MUTUAL_DEMO_MODE_PACKET_LENGTH); // for MSG26xxM/MSG28xx
+            DBG(&g_I2cClient->dev, "szData[0] = 0x%x\n", szData[0]);
+        }
+        else if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX)
+        {
+            rc = IicReadData(SLAVE_I2C_ID_DWI2C, &szData[0], SELF_DEMO_MODE_PACKET_LENGTH); // for MSG21xxA/MSG22xx
+            DBG(&g_I2cClient->dev, "szData[0] = 0x%x\n", szData[0]);
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "Un-recognized chip type = 0x%x\n", g_ChipType);
+            break;
+        }
+        	
+        if (rc > 0)
+        {
+            DBG(&g_I2cClient->dev, "ESD check success\n");
+            break;
+        }
+     
+        i++;
+    }
+    if (i == 3)
+    {
+        DBG(&g_I2cClient->dev, "ESD check failed, rc = %d\n", rc);
+    }
+
+    mutex_unlock(&g_Mutex);
+
+    if (i >= 3)
+    {
+        DrvPlatformLyrTouchDeviceResetHw();
+    }
+#endif //CONFIG_ENABLE_ESD_CHECK_COMMAND_BY_FIRMWARE
+
+EsdCheckEnd :
+
+    if (g_IsEnableEsdCheck == 1)
+    {
+        queue_delayed_work(g_EsdCheckWorkqueue, &g_EsdCheckWork, ESD_PROTECT_CHECK_PERIOD);
+    }
+}
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+//------------------------------------------------------------------------------//
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_utility_adaption.c
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_utility_adaption.c	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_utility_adaption.c	(revision 166572)
@@ -0,0 +1,1186 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_utility_adaption.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+////////////////////////////////////////////////////////////
+/// Included Files
+////////////////////////////////////////////////////////////
+#include "mstar_drv_utility_adaption.h"
+
+////////////////////////////////////////////////////////////
+/// Data Types
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Constant
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Variables
+////////////////////////////////////////////////////////////
+extern u32 SLAVE_I2C_ID_DBBUS;
+extern u32 SLAVE_I2C_ID_DWI2C;
+
+extern struct i2c_client *g_I2cClient;
+extern struct input_dev *g_InputDevice;
+extern struct mutex g_Mutex;
+
+extern u8 g_ChipType;
+extern u8 g_IsUpdateFirmware;
+extern u8 g_IsBypassHotknot;
+
+////////////////////////////////////////////////////////////
+/// Macro
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Function Prototypes
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Function Implementation
+////////////////////////////////////////////////////////////
+
+
+#ifdef CONFIG_ENABLE_DMA_IIC
+#include <linux/dma-mapping.h>
+#include <linux/mm_types.h>
+#include <linux/mm.h>
+#include <asm/uaccess.h>
+#include <asm/page.h>
+#include <linux/vmalloc.h>
+
+static unsigned char *I2CDMABuf_va = NULL;
+static dma_addr_t I2CDMABuf_pa = 0;
+
+void DmaAlloc(void)
+{
+    if (NULL == I2CDMABuf_va)
+    {
+        if (NULL != g_InputDevice)
+        {
+            g_InputDevice->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+            I2CDMABuf_va = (u8 *)dma_alloc_coherent(&g_InputDevice->dev, MAX_I2C_TRANSACTION_LENGTH_LIMIT, &I2CDMABuf_pa, GFP_KERNEL);
+        }
+    }
+    
+    if (NULL == I2CDMABuf_va)
+    {
+        DBG(&g_I2cClient->dev, "DmaAlloc FAILED!\n");
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "DmaAlloc SUCCESS!\n");
+    }
+}
+
+void DmaReset(void)
+{
+    DBG(&g_I2cClient->dev, "Dma memory reset!\n");
+
+    memset(I2CDMABuf_va, 0, MAX_I2C_TRANSACTION_LENGTH_LIMIT);
+}
+
+void DmaFree(void)
+{
+    if (NULL != I2CDMABuf_va)
+    {
+	      if (NULL != g_InputDevice)
+	      {
+	          dma_free_coherent(&g_InputDevice->dev, MAX_I2C_TRANSACTION_LENGTH_LIMIT, I2CDMABuf_va, I2CDMABuf_pa);
+	      }
+	      I2CDMABuf_va = NULL;
+	      I2CDMABuf_pa = 0;
+
+        DBG(&g_I2cClient->dev, "DmaFree SUCCESS!\n");
+    }
+}
+#endif //CONFIG_ENABLE_DMA_IIC
+
+//------------------------------------------------------------------------------//
+
+u16 RegGet16BitValue(u16 nAddr)
+{
+    u8 tx_data[3] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF};
+    u8 rx_data[2] = {0};
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+    IicReadData(SLAVE_I2C_ID_DBBUS, &rx_data[0], 2);
+
+    return (rx_data[1] << 8 | rx_data[0]);
+}
+
+u8 RegGetLByteValue(u16 nAddr)
+{
+    u8 tx_data[3] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF};
+    u8 rx_data = {0};
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+    IicReadData(SLAVE_I2C_ID_DBBUS, &rx_data, 1);
+
+    return (rx_data);
+}
+
+u8 RegGetHByteValue(u16 nAddr)
+{
+    u8 tx_data[3] = {0x10, (nAddr >> 8) & 0xFF, (nAddr & 0xFF) + 1};
+    u8 rx_data = {0};
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+    IicReadData(SLAVE_I2C_ID_DBBUS, &rx_data, 1);
+
+    return (rx_data);
+}
+
+void RegGetXBitValue(u16 nAddr, u8 * pRxData, u16 nLength, u16 nMaxI2cLengthLimit)
+{
+    u16 nReadAddr = nAddr;    
+    u16 nReadSize = 0;
+    u16 nLeft = nLength;    
+    u16 nOffset = 0; 
+    u8 tx_data[3] = {0};
+
+    tx_data[0] = 0x10;
+
+    mutex_lock(&g_Mutex);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    while(nLeft > 0)
+    {
+        if(nLeft >= nMaxI2cLengthLimit)
+        {
+            nReadSize = nMaxI2cLengthLimit;
+            //DBG("*** RegGetXBitValue# Length >= I2cMax   nReadAddr=%x, nReadSize=%d ***\n", nReadAddr, nReadSize);
+
+            tx_data[1] = (nReadAddr >> 8) & 0xFF;
+            tx_data[2] = nReadAddr & 0xFF;            
+        
+            IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+            IicReadData(SLAVE_I2C_ID_DBBUS, &pRxData[nOffset], nReadSize);
+        
+            nReadAddr = nReadAddr + nReadSize;    //set next read address
+            nLeft = nLeft - nReadSize;
+            nOffset = nOffset + nReadSize;
+            //DBG("*** RegGetXBitValue# Length >= I2cMax   nLeft=%d, nOffset=%d ***\n", nLeft, nOffset);
+        }
+        else
+        {
+            nReadSize = nLeft;
+            //DBG("*** RegGetXBitValue# Length < I2cMax   nReadAddr=%x, nReadSize=%d ***\n", nReadAddr, nReadSize);
+
+            tx_data[1] = (nReadAddr >> 8) & 0xFF;
+            tx_data[2] = nReadAddr & 0xFF;            
+        
+            IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+            IicReadData(SLAVE_I2C_ID_DBBUS, &pRxData[nOffset], nReadSize);
+            
+            nLeft = 0;
+            nOffset = nOffset + nReadSize;            
+            //DBG("*** RegGetXBitValue# Length < I2cMax   nLeft=%d, nOffset=%d ***\n", nLeft, nOffset);
+        }
+    }
+
+    mutex_unlock(&g_Mutex);    
+}
+
+void RegSet16BitValue(u16 nAddr, u16 nData)
+{
+    u8 tx_data[5] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF, nData & 0xFF, nData >> 8};
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 5);
+}
+
+void RegSetLByteValue(u16 nAddr, u8 nData)
+{
+    u8 tx_data[4] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF, nData};
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 4);
+}
+
+void RegSetHByteValue(u16 nAddr, u8 nData)
+{
+    u8 tx_data[4] = {0x10, (nAddr >> 8) & 0xFF, (nAddr & 0xFF) + 1, nData};
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 4);
+}
+
+void RegSet16BitValueOn(u16 nAddr, u16 nData) //Set bit on nData from 0 to 1
+{
+    u16 rData = RegGet16BitValue(nAddr);
+    rData |= nData;
+    RegSet16BitValue(nAddr, rData);
+}
+
+void RegSet16BitValueOff(u16 nAddr, u16 nData) //Set bit on nData from 1 to 0
+{
+    u16 rData = RegGet16BitValue(nAddr);
+    rData &= (~nData);
+    RegSet16BitValue(nAddr, rData);
+}
+
+u16 RegGet16BitValueByAddressMode(u16 nAddr, AddressMode_e eAddressMode)
+{
+    u16 nData = 0;
+    
+    if (eAddressMode == ADDRESS_MODE_16BIT)
+    {
+        nAddr = nAddr - (nAddr & 0xFF) + ((nAddr & 0xFF) << 1);
+    }
+    
+    nData = RegGet16BitValue(nAddr);
+    
+    return nData;
+}
+	
+void RegSet16BitValueByAddressMode(u16 nAddr, u16 nData, AddressMode_e eAddressMode)
+{
+    if (eAddressMode == ADDRESS_MODE_16BIT)
+    {
+        nAddr = nAddr - (nAddr & 0xFF) + ((nAddr & 0xFF) << 1);
+    }
+    
+    RegSet16BitValue(nAddr, nData);
+}
+
+void RegMask16BitValue(u16 nAddr, u16 nMask, u16 nData, AddressMode_e eAddressMode) 
+{
+    u16 nTmpData = 0;
+    
+    if (nData > nMask)
+    {
+        return;
+    }
+
+    nTmpData = RegGet16BitValueByAddressMode(nAddr, eAddressMode);
+    nTmpData = (nTmpData & (~nMask));
+    nTmpData = (nTmpData | nData);
+    RegSet16BitValueByAddressMode(nAddr, nTmpData, eAddressMode);
+}
+
+s32 DbBusEnterSerialDebugMode(void)
+{
+    s32 rc = 0;
+    u8 data[5];
+
+    // Enter the Serial Debug Mode
+    data[0] = 0x53;
+    data[1] = 0x45;
+    data[2] = 0x52;
+    data[3] = 0x44;
+    data[4] = 0x42;
+
+    rc = IicWriteData(SLAVE_I2C_ID_DBBUS, data, 5);
+    
+    return rc;
+}
+
+void DbBusExitSerialDebugMode(void)
+{
+    u8 data[1];
+
+    // Exit the Serial Debug Mode
+    data[0] = 0x45;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+
+    // Delay some interval to guard the next transaction
+//    udelay(200);        // delay about 0.2ms
+}
+
+void DbBusIICUseBus(void)
+{
+    u8 data[1];
+
+    // IIC Use Bus
+    data[0] = 0x35;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusIICNotUseBus(void)
+{
+    u8 data[1];
+
+    // IIC Not Use Bus
+    data[0] = 0x34;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusIICReshape(void)
+{
+    u8 data[1];
+
+    // IIC Re-shape
+    data[0] = 0x71;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusStopMCU(void)
+{
+    u8 data[1];
+
+    // Stop the MCU
+    data[0] = 0x37;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusNotStopMCU(void)
+{
+    u8 data[1];
+
+    // Not Stop the MCU
+    data[0] = 0x36;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusResetSlave(void)
+{
+    u8 data[1];
+
+    // IIC Reset Slave
+    data[0] = 0x00;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusWaitMCU(void)
+{
+    u8 data[1];
+
+    // Stop the MCU
+    data[0] = 0x37;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+
+    data[0] = 0x61;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);    
+}
+
+s32 IicWriteData(u8 nSlaveId, u8* pBuf, u16 nSize)
+{
+    s32 rc = 0;
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    struct i2c_msg msgs[] =
+    {
+        {
+            .addr = nSlaveId,
+            .flags = 0, // if read flag is undefined, then it means write flag.
+            .len = nSize,
+            .buf = pBuf,
+        },
+    };
+
+    /* If everything went ok (i.e. 1 msg transmitted), return #bytes
+       transmitted, else error code. */
+    if (g_I2cClient != NULL)
+    {
+        if (g_ChipType == CHIP_TYPE_MSG28XX && nSlaveId == SLAVE_I2C_ID_DWI2C && (g_IsUpdateFirmware != 0 || g_IsBypassHotknot != 0))
+        {
+            PRINTF_ERR("Not allow to execute SmBus command while update firmware.\n");
+        }
+        else
+        {
+            rc = i2c_transfer(g_I2cClient->adapter, msgs, 1);
+
+            if (rc == 1)
+            {
+                rc = nSize;
+            }
+            else // rc < 0
+            {
+                PRINTF_ERR("IicWriteData() error %d\n", rc);
+            }
+        }
+    }
+    else
+    {
+        PRINTF_ERR("i2c client is NULL\n");
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    if (g_I2cClient != NULL)
+    {
+        if (g_ChipType == CHIP_TYPE_MSG28XX && nSlaveId == SLAVE_I2C_ID_DWI2C && (g_IsUpdateFirmware != 0 || g_IsBypassHotknot != 0))
+        {
+            PRINTF_ERR("Not allow to execute SmBus command while update firmware.\n");
+        }
+        else
+        {
+            u8 nAddrBefore = g_I2cClient->addr;
+            g_I2cClient->addr = nSlaveId;
+
+#ifdef CONFIG_ENABLE_DMA_IIC
+            if (nSize > 8 && NULL != I2CDMABuf_va)
+            {
+                s32 i = 0;
+	          
+                for (i = 0; i < nSize; i ++)
+                {
+                    I2CDMABuf_va[i] = pBuf[i];
+                }
+                g_I2cClient->ext_flag = g_I2cClient->ext_flag | I2C_DMA_FLAG;
+                rc = i2c_master_send(g_I2cClient, (unsigned char *)I2CDMABuf_pa, nSize);
+            }
+            else
+            {
+                g_I2cClient->ext_flag = g_I2cClient->ext_flag & (~I2C_DMA_FLAG);	
+                rc = i2c_master_send(g_I2cClient, pBuf, nSize);
+            }
+#else
+            rc = i2c_master_send(g_I2cClient, pBuf, nSize);
+#endif //CONFIG_ENABLE_DMA_IIC
+            g_I2cClient->addr = nAddrBefore;
+
+            if (rc < 0)
+            {
+                PRINTF_ERR("IicWriteData() error %d, nSlaveId=%d, nSize=%d\n", rc, nSlaveId, nSize);
+            }
+        }            
+    }
+    else
+    {
+        PRINTF_ERR("i2c client is NULL\n");
+    }
+#endif
+    
+    return rc;
+}
+
+s32 IicReadData(u8 nSlaveId, u8* pBuf, u16 nSize)
+{
+    s32 rc = 0;
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    struct i2c_msg msgs[] =
+    {
+        {
+            .addr = nSlaveId,
+            .flags = I2C_M_RD, // read flag
+            .len = nSize,
+            .buf = pBuf,
+        },
+    };
+
+    /* If everything went ok (i.e. 1 msg transmitted), return #bytes
+       transmitted, else error code. */
+    if (g_I2cClient != NULL)
+    {
+        if (g_ChipType == CHIP_TYPE_MSG28XX && nSlaveId == SLAVE_I2C_ID_DWI2C && (g_IsUpdateFirmware != 0 || g_IsBypassHotknot != 0))
+        {
+            PRINTF_ERR("Not allow to execute SmBus command while update firmware.\n");
+        }
+        else
+        {
+            rc = i2c_transfer(g_I2cClient->adapter, msgs, 1);
+        
+            if (rc == 1)
+            {
+                rc = nSize;
+            }
+            else // rc < 0
+            {
+                PRINTF_ERR("IicReadData() error %d\n", rc);
+            }
+        }
+    }
+    else
+    {
+        PRINTF_ERR("i2c client is NULL\n");
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    if (g_I2cClient != NULL)
+    {
+        if (g_ChipType == CHIP_TYPE_MSG28XX && nSlaveId == SLAVE_I2C_ID_DWI2C && (g_IsUpdateFirmware != 0 || g_IsBypassHotknot != 0))
+        {
+            PRINTF_ERR("Not allow to execute SmBus command while update firmware.\n");
+        }
+        else
+        {
+            u8 nAddrBefore = g_I2cClient->addr;
+            g_I2cClient->addr = nSlaveId;
+
+#ifdef CONFIG_ENABLE_DMA_IIC
+            if (nSize > 8 && NULL != I2CDMABuf_va)
+            {
+                s32 i = 0;
+        
+                g_I2cClient->ext_flag = g_I2cClient->ext_flag | I2C_DMA_FLAG;
+                rc = i2c_master_recv(g_I2cClient, (unsigned char *)I2CDMABuf_pa, nSize);
+        
+                for (i = 0; i < nSize; i ++)
+                {
+                    pBuf[i] = I2CDMABuf_va[i];
+                }
+            }
+            else
+            {
+                g_I2cClient->ext_flag = g_I2cClient->ext_flag & (~I2C_DMA_FLAG);	
+                rc = i2c_master_recv(g_I2cClient, pBuf, nSize);
+            }
+#else
+            rc = i2c_master_recv(g_I2cClient, pBuf, nSize);
+#endif //CONFIG_ENABLE_DMA_IIC
+            g_I2cClient->addr = nAddrBefore;
+
+            if (rc < 0)
+            {
+                PRINTF_ERR("IicReadData() error %d, nSlaveId=%d, nSize=%d\n", rc, nSlaveId, nSize);
+            }
+        }            
+    }
+    else
+    {
+        PRINTF_ERR("i2c client is NULL\n");
+    }
+#endif
+    
+    return rc;
+}
+
+s32 IicSegmentReadDataByDbBus(u8 nRegBank, u8 nRegAddr, u8* pBuf, u16 nSize, u16 nMaxI2cLengthLimit)
+{
+    s32 rc = 0;
+    u16 nLeft = nSize;
+    u16 nOffset = 0;
+    u16 nSegmentLength = 0;
+    u16 nReadSize = 0;
+    u16 nOver = 0;
+    u8  szWriteBuf[3] = {0};
+    u8  nNextRegBank = nRegBank;
+    u8  nNextRegAddr = nRegAddr;
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    struct i2c_msg msgs[2] =
+    {
+        {
+            .addr = SLAVE_I2C_ID_DBBUS,
+            .flags = 0, // write flag
+            .len = 3,
+            .buf = szWriteBuf,
+        },
+        {
+            .addr = SLAVE_I2C_ID_DBBUS,
+            .flags =  I2C_M_RD, // read flag
+        },
+    };
+
+    // If everything went ok (i.e. 1 msg transmitted), return #bytes transmitted, else error code. 
+    if (g_I2cClient != NULL)
+    {
+        if (nMaxI2cLengthLimit >= 256)
+        {
+            nSegmentLength = 256;
+        }
+        else
+        {
+            nSegmentLength = 128;
+        }
+        
+        PRINTF_ERR("nSegmentLength = %d\n", nSegmentLength);	// add for debug
+
+        while (nLeft > 0)
+        {
+            szWriteBuf[0] = 0x10;
+            nRegBank = nNextRegBank;
+            szWriteBuf[1] = nRegBank;
+            nRegAddr = nNextRegAddr;
+            szWriteBuf[2] = nRegAddr;
+
+            PRINTF_ERR("nRegBank = 0x%x\n", nRegBank);	// add for debug
+            PRINTF_ERR("nRegAddr = 0x%x\n", nRegAddr);	// add for debug
+
+            msgs[1].buf = &pBuf[nOffset];
+
+            if (nLeft > nSegmentLength)
+            {
+                if ((nRegAddr + nSegmentLength) < MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                {
+                    nNextRegAddr = nRegAddr + nSegmentLength; 
+                    
+                    PRINTF_ERR("nNextRegAddr = 0x%x\n", nNextRegAddr);	// add for debug
+
+                    msgs[1].len = nSegmentLength;
+                    nLeft -= nSegmentLength;
+                    nOffset += msgs[1].len;
+                }
+                else if ((nRegAddr + nSegmentLength) == MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                {
+                    nNextRegAddr = 0x00; 		
+                    nNextRegBank = nRegBank + 1; // shift to read data from next register bank
+
+                    PRINTF_ERR("nNextRegBank = 0x%x\n", nNextRegBank);	// add for debug
+
+                    msgs[1].len = nSegmentLength;
+                    nLeft -= nSegmentLength;
+                    nOffset += msgs[1].len;
+                }
+                else // ((nRegAddr + nSegmentLength) > MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                {
+                    nNextRegAddr = 0x00;
+                    nNextRegBank = nRegBank + 1; // shift to read data from next register bank
+
+                    PRINTF_INFO("nNextRegBank = 0x%x\n", nNextRegBank);	// add for debug
+                    
+                    nOver = (nRegAddr + nSegmentLength) - MAX_TOUCH_IC_REGISTER_BANK_SIZE;
+
+                    PRINTF_ERR("nOver = 0x%x\n", nOver);	// add for debug
+
+                    msgs[1].len = nSegmentLength - nOver; 		
+                    nLeft -= msgs[1].len;
+                    nOffset += msgs[1].len;
+                }
+            }
+            else
+            {
+                if ((nRegAddr + nLeft) < MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                {
+                    nNextRegAddr = nRegAddr + nLeft; 
+                    
+                    PRINTF_ERR("nNextRegAddr = 0x%x\n", nNextRegAddr);	// add for debug
+
+                    msgs[1].len = nLeft;
+                    nLeft = 0;
+//                    nOffset += msgs[1].len;
+                }
+                else if ((nRegAddr + nLeft) == MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                {
+                    nNextRegAddr = 0x00; 		
+                    nNextRegBank = nRegBank + 1; // shift to read data from next register bank
+
+                    PRINTF_ERR("nNextRegBank = 0x%x\n", nNextRegBank);	// add for debug
+
+                    msgs[1].len = nLeft;
+                    nLeft = 0;
+//                    nOffset += msgs[1].len;
+                }
+                else // ((nRegAddr + nLeft) > MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                {
+                    nNextRegAddr = 0x00;
+                    nNextRegBank = nRegBank + 1; // shift to read data from next register bank
+
+                    PRINTF_ERR("nNextRegBank = 0x%x\n", nNextRegBank);	// add for debug
+                    
+                    nOver = (nRegAddr + nLeft) - MAX_TOUCH_IC_REGISTER_BANK_SIZE;
+
+                    PRINTF_ERR("nOver = 0x%x\n", nOver);	// add for debug
+
+                    msgs[1].len = nLeft - nOver; 		
+                    nLeft -= msgs[1].len;
+                    nOffset += msgs[1].len;
+                }
+            }
+
+            rc = i2c_transfer(g_I2cClient->adapter, &msgs[0], 2);
+            if (rc == 2)
+            {
+                nReadSize = nReadSize + msgs[1].len;
+            }
+            else // rc < 0
+            {
+                PRINTF_ERR("IicSegmentReadDataByDbBus() -> i2c_transfer() error %d\n", rc);
+                
+                return rc;
+            }
+        }
+    }
+    else
+    {
+        PRINTF_ERR("i2c client is NULL\n");
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    if (g_I2cClient != NULL)
+    {
+#ifndef CONFIG_ENABLE_DMA_IIC
+        u8 *pReadBuf = NULL;
+#endif //CONFIG_ENABLE_DMA_IIC
+        u16 nLength = 0;
+        u8 nAddrBefore = g_I2cClient->addr;
+        
+        g_I2cClient->addr = SLAVE_I2C_ID_DBBUS;
+
+        if (nMaxI2cLengthLimit >= 256)
+        {
+            nSegmentLength = 256;
+        }
+        else
+        {
+            nSegmentLength = 128;
+        }
+
+        PRINTF_ERR("nSegmentLength = %d\n", nSegmentLength);	// add for debug
+
+#ifdef CONFIG_ENABLE_DMA_IIC
+        if (NULL != I2CDMABuf_va)
+        {
+            s32 i = 0;
+
+            while (nLeft > 0)
+            {
+                szWriteBuf[0] = 0x10;
+                nRegBank = nNextRegBank;
+                szWriteBuf[1] = nRegBank;
+                nRegAddr = nNextRegAddr;
+                szWriteBuf[2] = nRegAddr;
+
+                PRINTF_ERR("nRegBank = 0x%x\n", nRegBank);	// add for debug
+                PRINTF_ERR("nRegAddr = 0x%x\n", nRegAddr);	// add for debug
+
+                if (nLeft > nSegmentLength)
+                {
+                    if ((nRegAddr + nSegmentLength) < MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                    {
+                        nNextRegAddr = nRegAddr + nSegmentLength; 
+                    
+                        PRINTF_ERR("nNextRegAddr = 0x%x\n", nNextRegAddr);	// add for debug
+
+                        nLength = nSegmentLength;
+                        nLeft -= nSegmentLength;
+                    }
+                    else if ((nRegAddr + nSegmentLength) == MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                    {
+                        nNextRegAddr = 0x00; 		
+                        nNextRegBank = nRegBank + 1; // shift to read data from next register bank
+
+                        PRINTF_ERR("nNextRegBank = 0x%x\n", nNextRegBank);	// add for debug
+
+                        nLength = nSegmentLength;
+                        nLeft -= nSegmentLength;
+                    }
+                    else // ((nRegAddr + nSegmentLength) > MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                    {
+                        nNextRegAddr = 0x00;
+                        nNextRegBank = nRegBank + 1; // shift to read data from next register bank
+
+                        PRINTF_INFO("nNextRegBank = 0x%x\n", nNextRegBank);	// add for debug
+                    
+                        nOver = (nRegAddr + nSegmentLength) - MAX_TOUCH_IC_REGISTER_BANK_SIZE;
+
+                        PRINTF_ERR("nOver = 0x%x\n", nOver);	// add for debug
+
+                        nLength = nSegmentLength - nOver; 		
+                        nLeft -= nLength;
+                    }
+                }
+                else
+                {
+                    if ((nRegAddr + nLeft) < MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                    {
+                        nNextRegAddr = nRegAddr + nLeft; 
+                    
+                        PRINTF_ERR("nNextRegAddr = 0x%x\n", nNextRegAddr);	// add for debug
+
+                        nLength = nLeft;
+                        nLeft = 0;
+                    }
+                    else if ((nRegAddr + nLeft) == MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                    {
+                        nNextRegAddr = 0x00; 		
+                        nNextRegBank = nRegBank + 1; // shift to read data from next register bank
+
+                        PRINTF_ERR("nNextRegBank = 0x%x\n", nNextRegBank);	// add for debug
+
+                        nLength = nLeft;
+                        nLeft = 0;
+                    }
+                    else // ((nRegAddr + nLeft) > MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                    {
+                        nNextRegAddr = 0x00;
+                        nNextRegBank = nRegBank + 1; // shift to read data from next register bank
+
+                        PRINTF_ERR("nNextRegBank = 0x%x\n", nNextRegBank);	// add for debug
+                    
+                        nOver = (nRegAddr + nLeft) - MAX_TOUCH_IC_REGISTER_BANK_SIZE;
+
+                        PRINTF_ERR("nOver = 0x%x\n", nOver);	// add for debug
+
+                        nLength = nLeft - nOver; 		
+                        nLeft -= nLength;
+                    }
+                }
+
+                g_I2cClient->ext_flag = g_I2cClient->ext_flag & (~I2C_DMA_FLAG);
+                rc = i2c_master_send(g_I2cClient, &szWriteBuf[0], 3);
+                if (rc < 0)
+                {
+                    PRINTF_ERR("IicSegmentReadDataByDbBus() -> i2c_master_send() error %d\n", rc);
+
+                    return rc;
+                }
+
+                g_I2cClient->ext_flag = g_I2cClient->ext_flag | I2C_DMA_FLAG;
+                rc = i2c_master_recv(g_I2cClient, (unsigned char *)I2CDMABuf_pa, nLength);
+                if (rc < 0)
+                {
+                    PRINTF_ERR("IicSegmentReadDataByDbBus() -> i2c_master_recv() error %d\n", rc);
+                    
+                    return rc;
+                }
+                else
+                {
+                    for (i = 0; i < nLength; i ++)
+                    {
+                        pBuf[i+nOffset] = I2CDMABuf_va[i];
+                    }
+                    nOffset += nLength;
+
+                    nReadSize = nReadSize + nLength;
+                }
+            }
+        }
+        else
+        {
+            PRINTF_ERR("IicSegmentReadDataByDbBus() -> I2CDMABuf_va is NULL\n");
+        }
+#else
+        while (nLeft > 0)
+        {
+            szWriteBuf[0] = 0x10;
+            nRegBank = nNextRegBank;
+            szWriteBuf[1] = nRegBank;
+            nRegAddr = nNextRegAddr;
+            szWriteBuf[2] = nRegAddr;
+
+            PRINTF_ERR("nRegBank = 0x%x\n", nRegBank);	// add for debug
+            PRINTF_ERR("nRegAddr = 0x%x\n", nRegAddr);	// add for debug
+
+            pReadBuf = &pBuf[nOffset];
+
+            if (nLeft > nSegmentLength)
+            {
+                if ((nRegAddr + nSegmentLength) < MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                {
+                    nNextRegAddr = nRegAddr + nSegmentLength; 
+                    
+                    PRINTF_ERR("nNextRegAddr = 0x%x\n", nNextRegAddr);	// add for debug
+
+                    nLength = nSegmentLength;
+                    nLeft -= nSegmentLength;
+                    nOffset += nLength;
+                }
+                else if ((nRegAddr + nSegmentLength) == MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                {
+                    nNextRegAddr = 0x00; 		
+                    nNextRegBank = nRegBank + 1; // shift to read data from next register bank
+
+                    PRINTF_ERR("nNextRegBank = 0x%x\n", nNextRegBank);	// add for debug
+
+                    nLength = nSegmentLength;
+                    nLeft -= nSegmentLength;
+                    nOffset += nLength;
+                }
+                else // ((nRegAddr + nSegmentLength) > MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                {
+                    nNextRegAddr = 0x00;
+                    nNextRegBank = nRegBank + 1; // shift to read data from next register bank
+
+                    PRINTF_INFO("nNextRegBank = 0x%x\n", nNextRegBank);	// add for debug
+                    
+                    nOver = (nRegAddr + nSegmentLength) - MAX_TOUCH_IC_REGISTER_BANK_SIZE;
+
+                    PRINTF_ERR("nOver = 0x%x\n", nOver);	// add for debug
+
+                    nLength = nSegmentLength - nOver; 		
+                    nLeft -= nLength;
+                    nOffset += nLength;
+                }
+            }
+            else
+            {
+                if ((nRegAddr + nLeft) < MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                {
+                    nNextRegAddr = nRegAddr + nLeft; 
+                    
+                    PRINTF_ERR("nNextRegAddr = 0x%x\n", nNextRegAddr);	// add for debug
+
+                    nLength = nLeft;
+                    nLeft = 0;
+//                    nOffset += nLength;
+                }
+                else if ((nRegAddr + nLeft) == MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                {
+                    nNextRegAddr = 0x00; 		
+                    nNextRegBank = nRegBank + 1; // shift to read data from next register bank
+
+                    PRINTF_ERR("nNextRegBank = 0x%x\n", nNextRegBank);	// add for debug
+
+                    nLength = nLeft;
+                    nLeft = 0;
+//                    nOffset += nLength;
+                }
+                else // ((nRegAddr + nLeft) > MAX_TOUCH_IC_REGISTER_BANK_SIZE)
+                {
+                    nNextRegAddr = 0x00;
+                    nNextRegBank = nRegBank + 1; // shift to read data from next register bank
+
+                    PRINTF_ERR("nNextRegBank = 0x%x\n", nNextRegBank);	// add for debug
+                    
+                    nOver = (nRegAddr + nLeft) - MAX_TOUCH_IC_REGISTER_BANK_SIZE;
+
+                    PRINTF_ERR("nOver = 0x%x\n", nOver);	// add for debug
+
+                    nLength = nLeft - nOver; 		
+                    nLeft -= nLength;
+                    nOffset += nLength;
+                }
+            }
+
+            rc = i2c_master_send(g_I2cClient, &szWriteBuf[0], 3);
+            if (rc < 0)
+            {
+                PRINTF_ERR("IicSegmentReadDataByDbBus() -> i2c_master_send() error %d\n", rc);
+
+                return rc;
+            }
+
+            rc = i2c_master_recv(g_I2cClient, pReadBuf, nLength);
+            if (rc < 0)
+            {
+                PRINTF_ERR("IicSegmentReadDataByDbBus() -> i2c_master_recv() error %d\n", rc);
+
+                return rc;
+            }
+            else
+            {
+                nReadSize = nReadSize + nLength;
+            }
+        }
+#endif //CONFIG_ENABLE_DMA_IIC
+        g_I2cClient->addr = nAddrBefore;
+    }
+    else
+    {
+        PRINTF_ERR("i2c client is NULL\n");
+    }
+#endif
+    
+    return nReadSize;
+}
+
+s32 IicSegmentReadDataBySmBus(u16 nAddr, u8* pBuf, u16 nSize, u16 nMaxI2cLengthLimit)
+{
+    s32 rc = 0;
+    u16 nLeft = nSize;
+    u16 nOffset = 0;
+    u16 nReadSize = 0;
+    u8  szWriteBuf[3] = {0};
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    struct i2c_msg msgs[2] =
+    {
+        {
+            .addr = SLAVE_I2C_ID_DWI2C,
+            .flags = 0, // write flag
+            .len = 3,
+            .buf = szWriteBuf,
+        },
+        {
+            .addr = SLAVE_I2C_ID_DWI2C,
+            .flags =  I2C_M_RD, // read flag
+        },
+    };
+
+    // If everything went ok (i.e. 1 msg transmitted), return #bytes transmitted, else error code. 
+    if (g_I2cClient != NULL)
+    {
+        while (nLeft > 0)
+        {
+            szWriteBuf[0] = 0x53;
+            szWriteBuf[1] = ((nAddr + nOffset) >> 8) & 0xFF;
+            szWriteBuf[2] = (nAddr + nOffset) & 0xFF;
+
+            msgs[1].buf = &pBuf[nOffset];
+
+            if (nLeft > nMaxI2cLengthLimit)
+            {
+                msgs[1].len = nMaxI2cLengthLimit;
+                nLeft -= nMaxI2cLengthLimit;
+                nOffset += msgs[1].len;
+            }
+            else
+            {
+                msgs[1].len = nLeft;
+                nLeft = 0;
+//                nOffset += msgs[1].len;
+            }
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM
+            mdelay(I2C_SMBUS_WRITE_COMMAND_DELAY_FOR_QCOM_PLATFORM);
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM
+
+            rc = i2c_transfer(g_I2cClient->adapter, &msgs[0], 2);
+            if (rc == 2)
+            {
+                nReadSize = nReadSize + msgs[1].len;
+            }
+            else // rc < 0
+            {
+                PRINTF_ERR("IicSegmentReadDataBySmBus() -> i2c_transfer() error %d\n", rc);
+                
+                return rc;
+            }
+        }
+    }
+    else
+    {
+        PRINTF_ERR("i2c client is NULL\n");
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    if (g_I2cClient != NULL)
+    {
+#ifndef CONFIG_ENABLE_DMA_IIC
+        u8 *pReadBuf = NULL;
+#endif //CONFIG_ENABLE_DMA_IIC
+        u16 nLength = 0;
+        u8 nAddrBefore = g_I2cClient->addr;
+        
+        g_I2cClient->addr = SLAVE_I2C_ID_DWI2C;
+
+#ifdef CONFIG_ENABLE_DMA_IIC
+        while (nLeft > 0)
+        {
+            s32 i = 0;
+
+            szWriteBuf[0] = 0x53;
+            szWriteBuf[1] = ((nAddr + nOffset) >> 8) & 0xFF;
+            szWriteBuf[2] = (nAddr + nOffset) & 0xFF;
+
+            if (nLeft > nMaxI2cLengthLimit)
+            {
+                nLength = nMaxI2cLengthLimit;
+                nLeft -= nMaxI2cLengthLimit;
+            }
+            else
+            {
+                nLength = nLeft;
+                nLeft = 0;
+            }
+            
+            g_I2cClient->ext_flag = g_I2cClient->ext_flag & (~I2C_DMA_FLAG);
+            rc = i2c_master_send(g_I2cClient, &szWriteBuf[0], 3);
+            if (rc < 0)
+            {
+                PRINTF_ERR("IicSegmentReadDataBySmBus() -> i2c_master_send() error %d\n", rc);
+
+                return rc;
+            }
+
+            g_I2cClient->ext_flag = g_I2cClient->ext_flag | I2C_DMA_FLAG;
+            rc = i2c_master_recv(g_I2cClient, (unsigned char *)I2CDMABuf_pa, nLength);
+            if (rc < 0)
+            {
+                PRINTF_ERR("IicSegmentReadDataBySmBus() -> i2c_master_recv() error %d\n", rc);
+
+                return rc;
+            }
+            else
+            {
+                for (i = 0; i < nLength; i ++)
+                {
+                    pBuf[i+nOffset] = I2CDMABuf_va[i];
+                }
+                nOffset += nLength;
+
+                nReadSize = nReadSize + nLength;
+            }
+        }
+#else
+        while (nLeft > 0)
+        {
+            szWriteBuf[0] = 0x53;
+            szWriteBuf[1] = ((nAddr + nOffset) >> 8) & 0xFF;
+            szWriteBuf[2] = (nAddr + nOffset) & 0xFF;
+
+            pReadBuf = &pBuf[nOffset];
+
+            if (nLeft > nMaxI2cLengthLimit)
+            {
+                nLength = nMaxI2cLengthLimit;
+                nLeft -= nMaxI2cLengthLimit;
+                nOffset += nLength;
+            }
+            else
+            {
+                nLength = nLeft;
+                nLeft = 0;
+//                nOffset += nLength;
+            }
+            
+            rc = i2c_master_send(g_I2cClient, &szWriteBuf[0], 3);
+            if (rc < 0)
+            {
+                PRINTF_ERR("IicSegmentReadDataBySmBus() -> i2c_master_send() error %d\n", rc);
+
+                return rc;
+            }
+
+            rc = i2c_master_recv(g_I2cClient, pReadBuf, nLength);
+            if (rc < 0)
+            {
+                PRINTF_ERR("IicSegmentReadDataBySmBus() -> i2c_master_recv() error %d\n", rc);
+
+                return rc;
+            }
+            else
+            {
+                nReadSize = nReadSize + nLength;
+            }
+        }
+#endif //CONFIG_ENABLE_DMA_IIC
+        g_I2cClient->addr = nAddrBefore;
+   }
+   else
+   {
+       PRINTF_ERR("i2c client is NULL\n");
+   }
+#endif
+	
+   return nReadSize;
+}
+
+void mstpMemSet(void *pDst, s8 nVal, u32 nSize)
+{
+    memset(pDst, nVal, nSize);
+}
+
+void mstpMemCopy(void *pDst, void *pSource, u32 nSize)
+{
+    memcpy(pDst, pSource, nSize);
+}
+
+void mstpDelay(u32 nTime)
+{
+    mdelay(nTime);
+}
+
+//------------------------------------------------------------------------------//
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_platform_porting_layer.h.bak
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_platform_porting_layer.h.bak	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_platform_porting_layer.h.bak	(revision 166572)
@@ -0,0 +1,268 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_platform_porting_layer.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_PLATFORM_PORTING_LAYER_H__
+#define __MSTAR_DRV_PLATFORM_PORTING_LAYER_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+
+//#include <mach/board.h>
+//#include <mach/gpio.h>
+#include <soc/sprd/board.h>
+#include <soc/sprd/gpio.h>
+#include <soc/sprd/i2c-sprd.h>
+
+#include <linux/of_gpio.h>
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+#include <mach/regulator.h>
+//#include <soc/sprd/regulator.h>
+#include <linux/regulator/consumer.h>
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+//#include <linux/input/vir_ps.h> 
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+#include <linux/pinctrl/consumer.h>
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+
+#include <linux/of_gpio.h>
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+#include <linux/regulator/consumer.h>
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+#ifdef CONFIG_ENABLE_NOTIFIER_FB
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#endif //CONFIG_ENABLE_NOTIFIER_FB
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+//#include <linux/input/vir_ps.h> 
+#include <linux/sensors.h>
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+#include <linux/pinctrl/consumer.h>
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/rtpm_prio.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+
+#include <linux/namei.h>
+#include <linux/vmalloc.h>
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+#include <linux/hwmsensor.h>
+#include <linux/hwmsen_dev.h>
+#include <linux/sensors_io.h>
+#include <linux/hwmsen_helper.h>
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+/*
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+#include <linux/pinctrl/consumer.h>
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+*/
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/gpio.h>
+
+#ifdef TIMER_DEBUG
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/module.h>
+#endif //TIMER_DEBUG
+
+#ifdef CONFIG_MTK_SENSOR_HUB_SUPPORT
+#include <mach/md32_ipi.h>
+#include <mach/md32_helper.h>
+#endif //CONFIG_MTK_SENSOR_HUB_SUPPORT
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+#include <linux/regulator/consumer.h>
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+#ifdef CONFIG_MTK_BOOT
+#include "mt_boot_common.h"
+#endif //CONFIG_MTK_BOOT
+
+#else
+#include <mach/mt_pm_ldo.h>
+#include <mach/mt_typedefs.h>
+#include <mach/mt_boot.h>
+#include <mach/mt_gpio.h>
+
+#include <cust_eint.h>
+#include <pmic_drv.h>
+
+#include "cust_gpio_usage.h"
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+#include "tpd.h"
+
+#endif
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+/*
+ * Note.
+ * Please change the below GPIO pin setting to follow the platform that you are using(EX. MediaTek, Spreadtrum, Qualcomm).
+ */
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+
+#ifndef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+// TODO : Please FAE colleague to confirm with customer device driver engineer about the value of RST and INT GPIO setting
+#define MS_TS_MSG_IC_GPIO_RST   GPIO_TOUCH_RESET //53 //35 
+#define MS_TS_MSG_IC_GPIO_INT   GPIO_TOUCH_IRQ   //52 //37
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+#define PINCTRL_STATE_ACTIVE	"pmx_ts_active"
+#define PINCTRL_STATE_SUSPEND	"pmx_ts_suspend"
+#define PINCTRL_STATE_RELEASE	"pmx_ts_release"
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+#define GTP_ADDR_LENGTH       (2)
+#define GTP_IOCTL_MAGIC 			(0x1C)
+#define LTR_IOCTL_GET_PFLAG  	_IOR(GTP_IOCTL_MAGIC, 1, int)
+#define LTR_IOCTL_GET_LFLAG  	_IOR(GTP_IOCTL_MAGIC, 2, int)
+#define LTR_IOCTL_SET_PFLAG  	_IOW(GTP_IOCTL_MAGIC, 3, int)
+#define LTR_IOCTL_SET_LFLAG  	_IOW(GTP_IOCTL_MAGIC, 4, int)
+#define LTR_IOCTL_GET_DATA  	_IOW(GTP_IOCTL_MAGIC, 5, unsigned char)
+#define GTP_IOCTL_PROX_ON 		_IO(GTP_IOCTL_MAGIC, 7)
+#define GTP_IOCTL_PROX_OFF		_IO(GTP_IOCTL_MAGIC, 8)
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_TP_HAVE_KEY
+#define TOUCH_KEY_MENU (139) //229
+#define TOUCH_KEY_HOME (172) //102
+#define TOUCH_KEY_BACK (158)
+#define TOUCH_KEY_SEARCH (217)
+
+#define MAX_KEY_NUM (4)
+#endif //CONFIG_TP_HAVE_KEY
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+
+#ifndef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+// TODO : Please FAE colleague to confirm with customer device driver engineer about the value of RST and INT GPIO setting
+#define MS_TS_MSG_IC_GPIO_RST   0
+#define MS_TS_MSG_IC_GPIO_INT   1
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+#define PINCTRL_STATE_ACTIVE	"pmx_ts_active"
+#define PINCTRL_STATE_SUSPEND	"pmx_ts_suspend"
+#define PINCTRL_STATE_RELEASE	"pmx_ts_release"
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+#ifdef CONFIG_TP_HAVE_KEY
+#define TOUCH_KEY_MENU (139) //229
+#define TOUCH_KEY_HOME (172) //102
+#define TOUCH_KEY_BACK (158)
+#define TOUCH_KEY_SEARCH (217)
+
+#define MAX_KEY_NUM (4)
+#endif //CONFIG_TP_HAVE_KEY
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+
+#ifndef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#define MS_TS_MSG_IC_GPIO_RST   (GPIO_CTP_RST_PIN)
+#define MS_TS_MSG_IC_GPIO_INT   (GPIO_CTP_EINT_PIN)
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+#ifdef CONFIG_TP_HAVE_KEY
+#define TOUCH_KEY_MENU    KEY_MENU 
+#define TOUCH_KEY_HOME    KEY_HOMEPAGE 
+#define TOUCH_KEY_BACK    KEY_BACK
+#define TOUCH_KEY_SEARCH  KEY_SEARCH
+
+#define MAX_KEY_NUM (4)
+#endif //CONFIG_TP_HAVE_KEY
+
+#endif
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+extern void DrvPlatformLyrDisableFingerTouchReport(void);
+extern void DrvPlatformLyrEnableFingerTouchReport(void);
+extern void DrvPlatformLyrFingerTouchPressed(s32 nX, s32 nY, s32 nPressure, s32 nId);
+extern void DrvPlatformLyrFingerTouchReleased(s32 nX, s32 nY, s32 nId);
+extern void DrvPlatformLyrVariableInitialize(void);
+extern s32 DrvPlatformLyrInputDeviceInitialize(struct i2c_client *pClient);
+extern void DrvPlatformLyrSetIicDataRate(struct i2c_client *pClient, u32 nIicDataRate);
+extern void DrvPlatformLyrTouchDevicePowerOff(void);
+extern void DrvPlatformLyrTouchDevicePowerOn(void);
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+extern void DrvPlatformLyrTouchDeviceRegulatorPowerOn(bool nFlag);
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+extern void DrvPlatformLyrTouchDeviceRegisterEarlySuspend(void);
+extern s32 DrvPlatformLyrTouchDeviceRegisterFingerTouchInterruptHandler(void);
+extern s32 DrvPlatformLyrTouchDeviceRemove(struct i2c_client *pClient);
+extern s32 DrvPlatformLyrTouchDeviceRequestGPIO(struct i2c_client *pClient);        
+extern void DrvPlatformLyrTouchDeviceResetHw(void);
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+extern int DrvPlatformLyrGetTpPsData(void);
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+extern void DrvPlatformLyrTpPsEnable(int nEnable);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+extern int DrvPlatformLyrTpPsEnable(struct sensors_classdev* pProximityCdev, unsigned int nEnable);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+extern int DrvPlatformLyrTpPsOperate(void* pSelf, u32 nCommand, void* pBuffIn, int nSizeIn, void* pBuffOut, int nSizeOut, int* pActualOut);
+#endif
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+void DrvPlatformLyrEsdCheck(struct work_struct *pWork);
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+        
+#endif  /* __MSTAR_DRV_PLATFORM_PORTING_LAYER_H__ */
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_main.c
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_main.c	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_main.c	(revision 166572)
@@ -0,0 +1,3882 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_main.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_main.h"
+#include "mstar_drv_utility_adaption.h"
+#include "mstar_drv_platform_porting_layer.h"
+#include "mstar_drv_ic_fw_porting_layer.h"
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+#include "mstar_drv_hotknot.h"
+#include "mstar_drv_hotknot_queue.h"
+#endif //CONFIG_ENABLE_HOTKNOT
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+#include "mstar_drv_jni_interface.h"
+#endif //CONFIG_ENABLE_JNI_INTERFACE
+
+/*=============================================================*/
+// CONSTANT VALUE DEFINITION
+/*=============================================================*/
+
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+extern MutualFirmwareInfo_t g_MutualFirmwareInfo;
+extern SelfFirmwareInfo_t g_SelfFirmwareInfo;
+extern u8 g_DemoModePacket[MUTUAL_DEMO_MODE_PACKET_LENGTH]; // for MSG21xxA/MSG22xx : DEMO_MODE_PACKET_LENGTH = SELF_DEMO_MODE_PACKET_LENGTH, for MSG26xxM/MSG28xx : DEMO_MODE_PACKET_LENGTH = MUTUAL_DEMO_MODE_PACKET_LENGTH
+extern u8 g_LogModePacket[MUTUAL_DEBUG_MODE_PACKET_LENGTH]; // for MSG21xxA/MSG22xx : DEBUG_MODE_PACKET_LENGTH = SELF_DEBUG_MODE_PACKET_LENGTH, for MSG26xxM/MSG28xx : DEBUG_MODE_PACKET_LENGTH = MUTUAL_DEBUG_MODE_PACKET_LENGTH
+extern u16 g_FirmwareMode;
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern u32 g_GestureWakeupMode[2];
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+extern u8 g_LogGestureDebug[128];
+extern u8 g_GestureDebugFlag;
+extern u8 g_GestureDebugMode;
+
+extern struct input_dev *g_InputDevice;
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+extern u32 g_LogGestureInfor[GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH];
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+extern struct i2c_client *g_I2cClient;
+
+extern u8 g_ChipType;
+extern u8 g_Msg22xxChipRevision;
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG26XXM) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG28XX)
+extern TestScopeInfo_t g_TestScopeInfo;
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM || CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+/*=============================================================*/
+// LOCAL VARIABLE DEFINITION
+/*=============================================================*/
+
+static u16 _gDebugReg[MAX_DEBUG_REGISTER_NUM] = {0};
+static u16 _gDebugRegValue[MAX_DEBUG_REGISTER_NUM] = {0};
+static u32 _gDebugRegCount = 0;
+
+static u8 _gDebugCmdArgu[MAX_DEBUG_COMMAND_ARGUMENT_NUM] = {0};
+static u16 _gDebugCmdArguCount = 0;
+static u32 _gDebugReadDataSize = 0;
+
+static char _gDebugBuf[1024] = {0};
+
+static u8 *_gPlatformFwVersion = NULL; // internal use firmware version for MStar
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+static ItoTestMode_e _gItoTestMode = 0;
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+static u32 _gLogGestureCount = 0;
+static u8 _gLogGestureInforType = 0;
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+static u32 _gIsUpdateComplete = 0;
+
+static u8 *_gFwVersion = NULL; // customer firmware version
+
+static u32 _gFeatureSupportStatus = 0;
+
+static struct proc_dir_entry *_gProcClassEntry = NULL;
+static struct proc_dir_entry *_gProcMsTouchScreenMsg20xxEntry = NULL;
+static struct proc_dir_entry *_gProcDeviceEntry = NULL;
+static struct proc_dir_entry *_gProcChipTypeEntry = NULL;
+static struct proc_dir_entry *_gProcFirmwareDataEntry = NULL;
+static struct proc_dir_entry *_gProcApkFirmwareUpdateEntry = NULL;
+static struct proc_dir_entry *_gProcCustomerFirmwareVersionEntry = NULL;
+static struct proc_dir_entry *_gProcPlatformFirmwareVersionEntry = NULL;
+static struct proc_dir_entry *_gProcDeviceDriverVersionEntry = NULL;
+static struct proc_dir_entry *_gProcSdCardFirmwareUpdateEntry = NULL;
+static struct proc_dir_entry *_gProcFirmwareDebugEntry = NULL;
+static struct proc_dir_entry *_gProcFirmwareSetDebugValueEntry = NULL;
+static struct proc_dir_entry *_gProcFirmwareSmBusDebugEntry = NULL;
+static struct proc_dir_entry *_gProcFirmwareSetDQMemValueEntry = NULL;
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+static struct proc_dir_entry *_gProcMpTestEntry = NULL;
+static struct proc_dir_entry *_gProcMpTestLogEntry = NULL;
+static struct proc_dir_entry *_gProcMpTestFailChannelEntry = NULL;
+static struct proc_dir_entry *_gProcMpTestScopeEntry = NULL;
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+static struct proc_dir_entry *_gProcFirmwareModeEntry = NULL;
+static struct proc_dir_entry *_gProcFirmwareSensorEntry = NULL;
+static struct proc_dir_entry *_gProcFirmwarePacketHeaderEntry = NULL;
+static struct proc_dir_entry *_gProcQueryFeatureSupportStatusEntry = NULL;
+static struct proc_dir_entry *_gProcChangeFeatureSupportStatusEntry = NULL;
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+static struct proc_dir_entry *_gProcGestureWakeupModeEntry = NULL;
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+static struct proc_dir_entry *_gProcGestureDebugModeEntry = NULL;
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+static struct proc_dir_entry *_gProcGestureInforModeEntry = NULL;
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+static struct proc_dir_entry *_gProcReportRateEntry = NULL;
+#endif //CONFIG_ENABLE_COUNT_REPORT_RATE
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+static struct proc_dir_entry *_gProcGloveModeEntry = NULL;
+static struct proc_dir_entry *_gProcOpenGloveModeEntry = NULL;
+static struct proc_dir_entry *_gProcCloseGloveModeEntry = NULL;
+#endif //CONFIG_ENABLE_GLOVE_MODE
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+static struct proc_dir_entry *_gProcJniMethodEntry = NULL;
+#endif //CONFIG_ENABLE_JNI_INTERFACE
+static struct proc_dir_entry *_gProcSeLinuxLimitFirmwareUpdateEntry = NULL;
+static struct proc_dir_entry *_gProcForceFirmwareUpdateEntry = NULL;
+
+
+static const struct file_operations _gProcChipType = { 
+    .read = DrvMainProcfsChipTypeRead,
+    .write = DrvMainProcfsChipTypeWrite,
+};
+
+static const struct file_operations _gProcFirmwareData = { 
+    .read = DrvMainProcfsFirmwareDataRead,
+    .write = DrvMainProcfsFirmwareDataWrite,
+};
+
+static const struct file_operations _gProcApkFirmwareUpdate = { 
+    .read = DrvMainProcfsFirmwareUpdateRead,
+    .write = DrvMainProcfsFirmwareUpdateWrite,
+};
+
+static const struct file_operations _gProcCustomerFirmwareVersion = { 
+    .read = DrvMainProcfsCustomerFirmwareVersionRead,
+    .write = DrvMainProcfsCustomerFirmwareVersionWrite,
+};
+
+static const struct file_operations _gProcPlatformFirmwareVersion = { 
+    .read = DrvMainProcfsPlatformFirmwareVersionRead,
+    .write = DrvMainProcfsPlatformFirmwareVersionWrite,
+};
+
+static const struct file_operations _gProcDeviceDriverVersion = { 
+    .read = DrvMainProcfsDeviceDriverVersionRead,
+    .write = DrvMainProcfsDeviceDriverVersionWrite,
+};
+
+static const struct file_operations _gProcSdCardFirmwareUpdate = { 
+    .read = DrvMainProcfsSdCardFirmwareUpdateRead,
+    .write = DrvMainProcfsSdCardFirmwareUpdateWrite,
+};
+
+static const struct file_operations _gProcFirmwareDebug = { 
+    .read = DrvMainProcfsFirmwareDebugRead,
+    .write = DrvMainProcfsFirmwareDebugWrite,
+};
+
+static const struct file_operations _gProcFirmwareSetDebugValue = { 
+    .read = DrvMainProcfsFirmwareSetDebugValueRead,
+    .write = DrvMainProcfsFirmwareSetDebugValueWrite,
+};
+
+static const struct file_operations _gProcFirmwareSmBusDebug = { 
+    .read = DrvMainProcfsFirmwareSmBusDebugRead,
+    .write = DrvMainProcfsFirmwareSmBusDebugWrite,
+};
+
+static const struct file_operations _gProcFirmwareSetDQMemValue = {
+    .read = DrvMainProcfsFirmwareSetDQMemValueRead,
+    .write = DrvMainProcfsFirmwareSetDQMemValueWrite,
+};
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+static const struct file_operations _gProcMpTest = { 
+    .read = DrvMainProcfsMpTestRead,
+    .write = DrvMainProcfsMpTestWrite,
+};
+
+static const struct file_operations _gProcMpTestLog = { 
+    .read = DrvMainProcfsMpTestLogRead,
+    .write = DrvMainProcfsMpTestLogWrite,
+};
+
+static const struct file_operations _gProcMpTestFailChannel = { 
+    .read = DrvMainProcfsMpTestFailChannelRead,
+    .write = DrvMainProcfsMpTestFailChannelWrite,
+};
+
+static const struct file_operations _gProcMpTestScope = { 
+    .read = DrvMainProcfsMpTestScopeRead,
+    .write = DrvMainProcfsMpTestScopeWrite,
+};
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+
+static const struct file_operations _gProcFirmwareMode = { 
+    .read = DrvMainProcfsFirmwareModeRead,
+    .write = DrvMainProcfsFirmwareModeWrite,
+};
+
+static const struct file_operations _gProcFirmwareSensor = { 
+    .read = DrvMainProcfsFirmwareSensorRead,
+    .write = DrvMainProcfsFirmwareSensorWrite,
+};
+
+static const struct file_operations _gProcFirmwarePacketHeader = { 
+    .read = DrvMainProcfsFirmwarePacketHeaderRead,
+    .write = DrvMainProcfsFirmwarePacketHeaderWrite,
+};
+
+
+static const struct file_operations _gProcQueryFeatureSupportStatus = { 
+    .read = DrvMainProcfsQueryFeatureSupportStatusRead,
+    .write = DrvMainProcfsQueryFeatureSupportStatusWrite,
+};
+
+static const struct file_operations _gProcChangeFeatureSupportStatus = { 
+    .read = DrvMainProcfsChangeFeatureSupportStatusRead,
+    .write = DrvMainProcfsChangeFeatureSupportStatusWrite,
+};
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+static const struct file_operations _gProcGestureWakeupMode = { 
+    .read = DrvMainProcfsGestureWakeupModeRead,
+    .write = DrvMainProcfsGestureWakeupModeWrite,
+};
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+static const struct file_operations _gProcGestureDebugMode = { 
+    .read = DrvMainProcfsGestureDebugModeRead,
+    .write = DrvMainProcfsGestureDebugModeWrite,
+};
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+static const struct file_operations _gProcGestureInforMode = { 
+    .read = DrvMainProcfsGestureInforModeRead,
+    .write = DrvMainProcfsGestureInforModeWrite,
+};
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+static const struct file_operations _gProcReportRate = { 
+    .read = DrvMainProcfsReportRateRead,
+    .write = DrvMainProcfsReportRateWrite,
+};
+#endif //CONFIG_ENABLE_COUNT_REPORT_RATE
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+static const struct file_operations _gProcGloveMode= {
+    .read = DrvMainProcfsGloveModeRead,
+    .write = DrvMainProcfsGloveModeWrite,
+};
+
+static const struct file_operations _gProcOpenGloveMode= {
+    .read = DrvMainProcfsOpenGloveModeRead,
+};
+
+static const struct file_operations _gProcCloseGloveMode= {
+    .read = DrvMainProcfsCloseGloveModeRead,
+};
+#endif //CONFIG_ENABLE_GLOVE_MODE
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+static const struct file_operations _gProcJniMethod = {
+    .read = MsgToolRead,
+    .write = MsgToolWrite,
+    .unlocked_ioctl = MsgToolIoctl,    
+    .compat_ioctl = MsgToolIoctl,    
+};
+#endif //CONFIG_ENABLE_JNI_INTERFACE
+
+static const struct file_operations _gProcSeLinuxLimitFirmwareUpdate = { 
+    .read = DrvMainProcfsSeLinuxLimitFirmwareUpdateRead,
+};
+
+static const struct file_operations _gProcForceFirmwareUpdate = { 
+    .read = DrvMainProcfsForceFirmwareUpdateRead,
+};
+
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+struct mutex g_HKMutex;
+extern struct mutex g_QMutex;
+#endif //CONFIG_ENABLE_HOTKNOT
+
+/*=============================================================*/
+// GLOBAL VARIABLE DEFINITION
+/*=============================================================*/
+
+u32 SLAVE_I2C_ID_DBBUS = (0xC4>>1); //0x62 // for MSG21XX/MSG21XXA/MSG26XXM/MSG28XX
+//u32 SLAVE_I2C_ID_DBBUS = (0xB2>>1); //0x59 // for MSG22XX
+u32 SLAVE_I2C_ID_DWI2C = (0x4C>>1); //0x26 
+
+
+u16 FIRMWARE_MODE_UNKNOWN_MODE = 0xFFFF;
+u16 FIRMWARE_MODE_DEMO_MODE = 0xFFFF;
+u16 FIRMWARE_MODE_DEBUG_MODE = 0xFFFF;
+u16 FIRMWARE_MODE_RAW_DATA_MODE = 0xFFFF;
+
+u16 DEMO_MODE_PACKET_LENGTH = 0; // If project use MSG26xxM/MSG28xx, set MUTUAL_DEMO_MODE_PACKET_LENGTH as default. If project use MSG21xxA/MSG22xx, set SELF_DEMO_MODE_PACKET_LENGTH as default. 
+u16 DEBUG_MODE_PACKET_LENGTH = 0; // If project use MSG26xxM/MSG28xx, set MUTUAL_DEBUG_MODE_PACKET_LENGTH as default. If project use MSG21xxA/MSG22xx, set SELF_DEBUG_MODE_PACKET_LENGTH as default. 
+u16 MAX_TOUCH_NUM = 0; // If project use MSG26xxM/MSG28xx, set MUTUAL_MAX_TOUCH_NUM as default. If project use MSG21xxA/MSG22xx, set SELF_MAX_TOUCH_NUM as default. 
+
+
+struct kset *g_TouchKSet = NULL;
+struct kobject *g_TouchKObj = NULL;
+u8 g_IsSwitchModeByAPK = 0;
+
+
+u8 IS_GESTURE_WAKEUP_ENABLED = 0;
+u8 IS_GESTURE_DEBUG_MODE_ENABLED = 0;
+u8 IS_GESTURE_INFORMATION_MODE_ENABLED = 0;
+u8 IS_GESTURE_WAKEUP_MODE_SUPPORT_64_TYPES_ENABLED = 0;
+
+u8 TOUCH_DRIVER_DEBUG_LOG_LEVEL = CONFIG_TOUCH_DRIVER_DEBUG_LOG_LEVEL;
+u8 IS_FIRMWARE_DATA_LOG_ENABLED = CONFIG_ENABLE_FIRMWARE_DATA_LOG;
+u8 IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED = 0;
+
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+struct kset *g_GestureKSet = NULL;
+struct kobject *g_GestureKObj = NULL;
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+u16 g_FwPacketDataAddress = 0;
+u16 g_FwPacketFlagAddress = 0;
+u8 g_FwSupportSegment = 0;
+#endif //CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+u32 g_IsEnableReportRate = 0;
+u32 g_InterruptCount = 0;
+u32 g_ValidTouchCount = 0;
+u32 g_InterruptReportRate = 0;
+u32 g_ValidTouchReportRate = 0;
+
+struct timeval g_StartTime;
+#endif //CONFIG_ENABLE_COUNT_REPORT_RATE
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+u8 g_IsEnableGloveMode = 0;
+#endif //CONFIG_ENABLE_GLOVE_MODE
+
+u8 g_FwData[MAX_UPDATE_FIRMWARE_BUFFER_SIZE][1024];
+u32 g_FwDataCount = 0;
+
+u8 g_IsHotknotEnabled = 0;
+u8 g_IsBypassHotknot = 0;
+
+
+
+/*=============================================================*/
+// EXTERN FUNCTION DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION
+extern bool upmu_is_chr_det(void);
+#endif //CONFIG_ENABLE_CHARGER_DETECTION
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+/*=============================================================*/
+// LOCAL FUNCTION DEFINITION
+/*=============================================================*/
+
+static s32 _DrvMainCreateProcfsDirEntry(void);
+#ifdef CONFIG_ENABLE_HOTKNOT
+static s32 _DrvMainHotknotRegistry(void);
+#endif //CONFIG_ENABLE_HOTKNOT
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+//------------------------------------------------------------------------------//
+
+ssize_t DrvMainProcfsChipTypeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    nLength = sprintf(pBuffer, "%d", g_ChipType);
+
+    if (g_ChipType == CHIP_TYPE_MSG22XX)  // (0x7A)
+    {
+        DBG(&g_I2cClient->dev, "g_Msg22xxChipRevision = 0x%x\n", g_Msg22xxChipRevision); // TODO : add for debug
+    }
+
+    *pPos += nLength;
+
+    return nLength;
+}			  
+			  
+ssize_t DrvMainProcfsChipTypeWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+//    g_ChipType = DrvIcFwLyrGetChipType();
+
+    return nCount;
+}
+
+ssize_t DrvMainProcfsFirmwareDataRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    DBG(&g_I2cClient->dev, "*** %s() g_FwDataCount = %d ***\n", __func__, g_FwDataCount);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    *pPos += g_FwDataCount;
+
+    return g_FwDataCount;
+}			  
+			  
+ssize_t DrvMainProcfsFirmwareDataWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{
+    u32 nNum = nCount / 1024;
+    u32 nRemainder = nCount % 1024;
+    u32 i;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (nNum > 0) // nCount >= 1024
+    {
+        for (i = 0; i < nNum; i ++)
+        {
+            memcpy(g_FwData[g_FwDataCount], pBuffer+(i*1024), 1024);
+
+            g_FwDataCount ++;
+        }
+
+        if (nRemainder > 0) // Handle special firmware size like MSG22XX(48.5KB)
+        {
+            DBG(&g_I2cClient->dev, "nRemainder = %d\n", nRemainder);
+
+            memcpy(g_FwData[g_FwDataCount], pBuffer+(i*1024), nRemainder);
+
+            g_FwDataCount ++;
+        }
+    }
+    else // nCount < 1024
+    {
+        if (nCount > 0)
+        {
+            memcpy(g_FwData[g_FwDataCount], pBuffer, nCount);
+
+            g_FwDataCount ++;
+        }
+    }
+
+    DBG(&g_I2cClient->dev, "*** g_FwDataCount = %d ***\n", g_FwDataCount);
+
+    if (pBuffer != NULL)
+    {
+        DBG(&g_I2cClient->dev, "*** buf[0] = %c ***\n", pBuffer[0]);
+    }
+
+    return nCount;
+}
+
+ssize_t DrvMainProcfsFirmwareUpdateRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+    
+    nLength = sprintf(pBuffer, "%d", _gIsUpdateComplete);
+
+    DBG(&g_I2cClient->dev, "*** _gIsUpdateComplete = %d ***\n", _gIsUpdateComplete);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareUpdateWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    DrvPlatformLyrDisableFingerTouchReport();
+
+    DBG(&g_I2cClient->dev, "*** %s() g_FwDataCount = %d ***\n", __func__, g_FwDataCount);
+
+    if (0 != DrvIcFwLyrUpdateFirmware(g_FwData, EMEM_ALL))
+    {
+        _gIsUpdateComplete = 0;
+        DBG(&g_I2cClient->dev, "Update FAILED\n");
+    }
+    else
+    {
+        _gIsUpdateComplete = 1;
+        DBG(&g_I2cClient->dev, "Update SUCCESS\n");
+    }
+
+    DrvPlatformLyrEnableFingerTouchReport();
+
+    return nCount;
+}
+
+ssize_t DrvMainProcfsCustomerFirmwareVersionRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() _gFwVersion = %s ***\n", __func__, _gFwVersion);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    nLength = sprintf(pBuffer, "%s\n", _gFwVersion);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsCustomerFirmwareVersionWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    u16 nMajor = 0, nMinor = 0;
+
+    DrvIcFwLyrGetCustomerFirmwareVersion(&nMajor, &nMinor, &_gFwVersion);
+
+    DBG(&g_I2cClient->dev, "*** %s() _gFwVersion = %s ***\n", __func__, _gFwVersion);
+
+    return nCount;
+}
+
+ssize_t DrvMainProcfsPlatformFirmwareVersionRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() _gPlatformFwVersion = %s ***\n", __func__, _gPlatformFwVersion);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    nLength = sprintf(pBuffer, "%s\n", _gPlatformFwVersion);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsPlatformFirmwareVersionWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    DrvIcFwLyrGetPlatformFirmwareVersion(&_gPlatformFwVersion);
+
+    DBG(&g_I2cClient->dev, "*** %s() _gPlatformFwVersion = %s ***\n", __func__, _gPlatformFwVersion);
+
+    return nCount;
+}
+
+ssize_t DrvMainProcfsDeviceDriverVersionRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    nLength = sprintf(pBuffer, "%s", DEVICE_DRIVER_RELEASE_VERSION);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsDeviceDriverVersionWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return nCount;
+}
+
+ssize_t DrvMainProcfsSdCardFirmwareUpdateRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u16 nMajor = 0, nMinor = 0;
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    DrvIcFwLyrGetCustomerFirmwareVersion(&nMajor, &nMinor, &_gFwVersion);
+
+    DBG(&g_I2cClient->dev, "*** %s() _gFwVersion = %s ***\n", __func__, _gFwVersion);
+
+    nLength = sprintf(pBuffer, "%s\n", _gFwVersion);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsSdCardFirmwareUpdateWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    char *pValid = NULL;
+    char *pTmpFilePath = NULL;
+    char szFilePath[100] = {0};
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    DBG(&g_I2cClient->dev, "pBuffer = %s\n", pBuffer);
+
+    if (pBuffer != NULL)
+    {
+        pValid = strstr(pBuffer, ".bin");
+        
+        if (pValid)
+        {
+            pTmpFilePath = strsep((char **)&pBuffer, ".");
+            
+            DBG(&g_I2cClient->dev, "pTmpFilePath = %s\n", pTmpFilePath);
+
+            strcat(szFilePath, pTmpFilePath);
+            strcat(szFilePath, ".bin");
+
+            DBG(&g_I2cClient->dev, "szFilePath = %s\n", szFilePath);
+            
+            if (0 != DrvIcFwLyrUpdateFirmwareBySdCard(szFilePath))
+            {
+                DBG(&g_I2cClient->dev, "Update FAILED\n");
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "Update SUCCESS\n");
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "The file type of the update firmware bin file is not a .bin file.\n");
+        }
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "The file path of the update firmware bin file is NULL.\n");
+    }
+
+    return nCount;
+}
+
+ssize_t DrvMainProcfsSeLinuxLimitFirmwareUpdateRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    DBG(&g_I2cClient->dev, "FIRMWARE_FILE_PATH_ON_SD_CARD = %s\n", FIRMWARE_FILE_PATH_ON_SD_CARD);
+    
+    if (0 != DrvIcFwLyrUpdateFirmwareBySdCard(FIRMWARE_FILE_PATH_ON_SD_CARD))
+    {
+        _gIsUpdateComplete = 0;
+        DBG(&g_I2cClient->dev, "Update FAILED\n");
+    }
+    else
+    {
+        _gIsUpdateComplete = 1;
+        DBG(&g_I2cClient->dev, "Update SUCCESS\n");
+    }
+
+    nLength = sprintf(pBuffer, "%d", _gIsUpdateComplete);
+
+    DBG(&g_I2cClient->dev, "*** _gIsUpdateComplete = %d ***\n", _gIsUpdateComplete);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsForceFirmwareUpdateRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    DBG(&g_I2cClient->dev, "*** IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED = %d ***\n", IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED);
+
+    IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED = 1; // Enable force firmware update
+    _gFeatureSupportStatus = IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED;
+
+    nLength = sprintf(pBuffer, "%d", _gFeatureSupportStatus);
+
+    DBG(&g_I2cClient->dev, "*** _gFeatureSupportStatus = %d ***\n", _gFeatureSupportStatus);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareDebugRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 i, nLength = 0;
+    u8 nBank, nAddr;
+    u16 szRegData[MAX_DEBUG_REGISTER_NUM] = {0};
+    u8 szOut[MAX_DEBUG_REGISTER_NUM*25] = {0}, szValue[10] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+                
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    
+    for (i = 0; i < _gDebugRegCount; i ++)
+    {
+        szRegData[i] = RegGet16BitValue(_gDebugReg[i]);
+    }
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    for (i = 0; i < _gDebugRegCount; i ++)
+    {
+        nBank = (_gDebugReg[i] >> 8) & 0xFF;
+        nAddr = _gDebugReg[i] & 0xFF;
+    	  
+        DBG(&g_I2cClient->dev, "reg(0x%02X,0x%02X)=0x%04X\n", nBank, nAddr, szRegData[i]);
+
+        strcat(szOut, "reg(");
+        sprintf(szValue, "0x%02X", nBank);
+        strcat(szOut, szValue);
+        strcat(szOut, ",");
+        sprintf(szValue, "0x%02X", nAddr);
+        strcat(szOut, szValue);
+        strcat(szOut, ")=");
+        sprintf(szValue, "0x%04X", szRegData[i]);
+        strcat(szOut, szValue);
+        strcat(szOut, "\n");
+    }
+
+    nLength = sprintf(pBuffer, "%s\n", szOut);
+
+    *pPos += nLength;
+    
+    return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareDebugWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    u32 i;
+    char *pCh = NULL;
+    char *pStr = NULL;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (pBuffer != NULL)
+    {
+        DBG(&g_I2cClient->dev, "*** pBuffer[0] = %c ***\n", pBuffer[0]);
+        DBG(&g_I2cClient->dev, "*** pBuffer[1] = %c ***\n", pBuffer[1]);
+        DBG(&g_I2cClient->dev, "*** pBuffer[2] = %c ***\n", pBuffer[2]);
+        DBG(&g_I2cClient->dev, "*** pBuffer[3] = %c ***\n", pBuffer[3]);
+        DBG(&g_I2cClient->dev, "*** pBuffer[4] = %c ***\n", pBuffer[4]);
+        DBG(&g_I2cClient->dev, "*** pBuffer[5] = %c ***\n", pBuffer[5]);
+
+        DBG(&g_I2cClient->dev, "nCount = %d\n", (int)nCount);
+       
+        memset(_gDebugBuf, 0, 1024);
+
+        if (copy_from_user(_gDebugBuf, pBuffer, nCount))
+        {
+            DBG(&g_I2cClient->dev, "copy_from_user() failed\n");
+
+            return -EFAULT;
+        }
+
+        _gDebugBuf[nCount] = '\0';
+        pStr = _gDebugBuf;
+        
+        i = 0;
+
+        while ((pCh = strsep((char **)&pStr, " ,")) && (i < MAX_DEBUG_REGISTER_NUM))
+        {
+            DBG(&g_I2cClient->dev, "pCh = %s\n", pCh);
+            
+            _gDebugReg[i] = DrvCommonConvertCharToHexDigit(pCh, strlen(pCh));
+
+            DBG(&g_I2cClient->dev, "_gDebugReg[%d] = 0x%04X\n", i, _gDebugReg[i]);
+            i ++;
+        }
+        _gDebugRegCount = i;
+        
+        DBG(&g_I2cClient->dev, "_gDebugRegCount = %d\n", _gDebugRegCount);
+    }
+
+    return nCount;
+}
+
+ssize_t DrvMainProcfsFirmwareSetDebugValueRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 i, nLength = 0;
+    u8 nBank, nAddr;
+    u16 szRegData[MAX_DEBUG_REGISTER_NUM] = {0};
+    u8 szOut[MAX_DEBUG_REGISTER_NUM*25] = {0}, szValue[10] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+    
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    
+    for (i = 0; i < _gDebugRegCount; i ++)
+    {
+        szRegData[i] = RegGet16BitValue(_gDebugReg[i]);
+    }
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    for (i = 0; i < _gDebugRegCount; i ++)
+    {
+        nBank = (_gDebugReg[i] >> 8) & 0xFF;
+        nAddr = _gDebugReg[i] & 0xFF;
+    	  
+        DBG(&g_I2cClient->dev, "reg(0x%02X,0x%02X)=0x%04X\n", nBank, nAddr, szRegData[i]);
+
+        strcat(szOut, "reg(");
+        sprintf(szValue, "0x%02X", nBank);
+        strcat(szOut, szValue);
+        strcat(szOut, ",");
+        sprintf(szValue, "0x%02X", nAddr);
+        strcat(szOut, szValue);
+        strcat(szOut, ")=");
+        sprintf(szValue, "0x%04X", szRegData[i]);
+        strcat(szOut, szValue);
+        strcat(szOut, "\n");
+    }
+
+    nLength = sprintf(pBuffer, "%s\n", szOut);
+
+    *pPos += nLength;
+    
+    return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareSetDebugValueWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    u32 i, j, k;
+    char *pCh = NULL;
+    char *pStr = NULL;  
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (pBuffer != NULL)
+    {
+        DBG(&g_I2cClient->dev, "*** pBuffer[0] = %c ***\n", pBuffer[0]);
+        DBG(&g_I2cClient->dev, "*** pBuffer[1] = %c ***\n", pBuffer[1]);
+
+        DBG(&g_I2cClient->dev, "nCount = %d\n", (int)nCount);
+
+        memset(_gDebugBuf, 0, 1024);
+
+        if (copy_from_user(_gDebugBuf, pBuffer, nCount))
+        {
+            DBG(&g_I2cClient->dev, "copy_from_user() failed\n");
+
+            return -EFAULT;
+        }
+       
+        _gDebugBuf[nCount] = '\0';
+        pStr = _gDebugBuf;
+
+        i = 0;
+        j = 0;
+        k = 0;
+        
+        while ((pCh = strsep((char **)&pStr, " ,")) && (i < 2))
+        {
+            DBG(&g_I2cClient->dev, "pCh = %s\n", pCh);
+
+            if ((i%2) == 0)
+            {
+                _gDebugReg[j] = DrvCommonConvertCharToHexDigit(pCh, strlen(pCh));
+                DBG(&g_I2cClient->dev, "_gDebugReg[%d] = 0x%04X\n", j, _gDebugReg[j]);
+                j ++;
+            }
+            else // (i%2) == 1
+            {	
+                _gDebugRegValue[k] = DrvCommonConvertCharToHexDigit(pCh, strlen(pCh));
+                DBG(&g_I2cClient->dev, "_gDebugRegValue[%d] = 0x%04X\n", k, _gDebugRegValue[k]);
+                k ++;
+            }
+
+            i ++;
+        }
+        _gDebugRegCount = j;
+        
+        DBG(&g_I2cClient->dev, "_gDebugRegCount = %d\n", _gDebugRegCount);
+
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+    
+        for (i = 0; i < _gDebugRegCount; i ++)
+        {
+            RegSet16BitValue(_gDebugReg[i], _gDebugRegValue[i]);
+            DBG(&g_I2cClient->dev, "_gDebugReg[%d] = 0x%04X, _gDebugRegValue[%d] = 0x%04X\n", i, _gDebugReg[i], i , _gDebugRegValue[i]); // add for debug
+        }
+
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+    }
+    
+    return nCount;
+}
+
+ssize_t DrvMainProcfsFirmwareSmBusDebugRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 i, nLength = 0;
+    u8 szSmBusRxData[MAX_I2C_TRANSACTION_LENGTH_LIMIT] = {0};
+    u8 szOut[MAX_I2C_TRANSACTION_LENGTH_LIMIT*2] = {0};
+    u8 szValue[10] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    if (_gDebugCmdArguCount > 0) // Send write command
+    {
+        DBG(&g_I2cClient->dev, "Execute I2C SMBUS write command\n"); 
+
+        IicWriteData(SLAVE_I2C_ID_DWI2C, &_gDebugCmdArgu[0], _gDebugCmdArguCount);
+    }
+
+    if (_gDebugReadDataSize > 0) // Send read command
+    {
+        DBG(&g_I2cClient->dev, "Execute I2C SMBUS read command\n"); 
+
+        IicReadData(SLAVE_I2C_ID_DWI2C, &szSmBusRxData[0], _gDebugReadDataSize);
+    }
+
+    for (i = 0; i < _gDebugReadDataSize; i ++)
+    {
+        DBG(&g_I2cClient->dev, "szSmBusRxData[%d] = 0x%x\n", i, szSmBusRxData[i]); 
+
+        sprintf(szValue, "0x%02X", szSmBusRxData[i]);
+        strcat(szOut, szValue);
+        strcat(szOut, "\n");
+    }
+
+    nLength = sprintf(pBuffer, "%s\n", szOut);
+
+    *pPos += nLength;
+    
+    return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareSmBusDebugWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    u32 i, j;
+    char szCmdType[5] = {0};
+    char *pCh = NULL;
+    char *pStr = NULL;  
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (pBuffer != NULL)
+    {
+        DBG(&g_I2cClient->dev, "*** pBuffer[0] = %c ***\n", pBuffer[0]);
+        DBG(&g_I2cClient->dev, "*** pBuffer[1] = %c ***\n", pBuffer[1]);
+        DBG(&g_I2cClient->dev, "*** pBuffer[2] = %c ***\n", pBuffer[2]);
+        DBG(&g_I2cClient->dev, "*** pBuffer[3] = %c ***\n", pBuffer[3]);
+        DBG(&g_I2cClient->dev, "*** pBuffer[4] = %c ***\n", pBuffer[4]);
+        DBG(&g_I2cClient->dev, "*** pBuffer[5] = %c ***\n", pBuffer[5]);
+
+        DBG(&g_I2cClient->dev, "nCount = %d\n", (int)nCount);
+       
+        memset(_gDebugBuf, 0, 1024);
+
+        if (copy_from_user(_gDebugBuf, pBuffer, nCount))
+        {
+            DBG(&g_I2cClient->dev, "copy_from_user() failed\n");
+
+            return -EFAULT;
+        }
+
+        // Reset to 0 before parsing the adb command
+        _gDebugCmdArguCount = 0;
+        _gDebugReadDataSize = 0;
+        
+        _gDebugBuf[nCount] = '\0';
+        pStr = _gDebugBuf;
+
+        i = 0;
+        j = 0;
+
+        while ((pCh = strsep((char **)&pStr, " ,")) && (j < MAX_DEBUG_COMMAND_ARGUMENT_NUM))
+        {
+            DBG(&g_I2cClient->dev, "pCh = %s\n", pCh);
+            
+            if (strcmp(pCh, "w") == 0 || strcmp(pCh, "r") == 0)
+            {
+                memcpy(szCmdType, pCh, strlen(pCh));
+            }
+            else if (strcmp(szCmdType, "w") == 0)
+            {
+                _gDebugCmdArgu[j] = DrvCommonConvertCharToHexDigit(pCh, strlen(pCh));
+                DBG(&g_I2cClient->dev, "_gDebugCmdArgu[%d] = 0x%02X\n", j, _gDebugCmdArgu[j]);
+                
+                j ++;
+       
+                _gDebugCmdArguCount = j;
+                DBG(&g_I2cClient->dev, "_gDebugCmdArguCount = %d\n", _gDebugCmdArguCount);
+            }
+            else if (strcmp(szCmdType, "r") == 0)
+            {
+                sscanf(pCh, "%d", &_gDebugReadDataSize);   
+                DBG(&g_I2cClient->dev, "_gDebugReadDataSize = %d\n", _gDebugReadDataSize);
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "Un-supported adb command format!\n");
+            }
+
+            i ++;
+        }
+    }
+
+    return nCount;
+}
+
+ssize_t DrvMainProcfsFirmwareSetDQMemValueRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 i, nLength = 0;
+    u8 nBank, nAddr;
+    u32 szRegData[MAX_DEBUG_REGISTER_NUM] = {0};
+    u8 szOut[MAX_DEBUG_REGISTER_NUM*25] = {0}, szValue[10] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    for (i = 0; i < _gDebugRegCount; i ++)
+    {
+        szRegData[i] = DrvIcFwLyrReadDQMemValue(_gDebugReg[i]);
+    }
+
+    for (i = 0; i < _gDebugRegCount; i ++)
+    {
+        nBank = (_gDebugReg[i] >> 8) & 0xFF;
+        nAddr = _gDebugReg[i] & 0xFF;
+
+        DBG(&g_I2cClient->dev, "reg(0x%02X,0x%02X)=0x%08X\n", nBank, nAddr, szRegData[i]);
+
+        strcat(szOut, "reg(");
+        sprintf(szValue, "0x%02X", nBank);
+        strcat(szOut, szValue);
+        strcat(szOut, ",");
+        sprintf(szValue, "0x%02X", nAddr);
+        strcat(szOut, szValue);
+        strcat(szOut, ")=");
+        sprintf(szValue, "0x%04X", szRegData[i]);
+        strcat(szOut, szValue);
+        strcat(szOut, "\n");
+    }
+
+    nLength = sprintf(pBuffer, "%s\n", szOut);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareSetDQMemValueWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 i, j, k;
+    char *pCh = NULL;
+    char *pStr = NULL;
+    u16 nRealDQMemAddr = 0;
+    u32 nRealDQMemValue = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (pBuffer != NULL)
+    {
+        DBG(&g_I2cClient->dev, "*** pBuffer[0] = %c ***\n", pBuffer[0]);
+        DBG(&g_I2cClient->dev, "*** pBuffer[1] = %c ***\n", pBuffer[1]);
+
+        DBG(&g_I2cClient->dev, "nCount = %d\n", (int)nCount);
+
+        memset(_gDebugBuf, 0, 1024);
+
+        if (copy_from_user(_gDebugBuf, pBuffer, nCount))
+        {
+            DBG(&g_I2cClient->dev, "copy_from_user() failed\n");
+
+            return -EFAULT;
+        }
+
+        _gDebugBuf[nCount] = '\0';
+        pStr = _gDebugBuf;
+
+        i = 0;
+        j = 0;
+        k = 0;
+
+        while ((pCh = strsep((char **)&pStr, " ,")) && (i < 2))
+        {
+            DBG(&g_I2cClient->dev, "pCh = %s\n", pCh);
+
+            if ((i%2) == 0)
+            {
+                _gDebugReg[j] = DrvCommonConvertCharToHexDigit(pCh, strlen(pCh));
+                DBG(&g_I2cClient->dev, "_gDebugReg[%d] = 0x%04X\n", j, _gDebugReg[j]);
+                j ++;
+            }
+            else // (i%2) == 1
+            {
+                _gDebugRegValue[k] = DrvCommonConvertCharToHexDigit(pCh, strlen(pCh));
+                DBG(&g_I2cClient->dev, "_gDebugRegValue[%d] = 0x%04X\n", k, _gDebugRegValue[k]);
+                k ++;
+            }
+
+            i ++;
+        }
+        _gDebugRegCount = j;
+
+        DBG(&g_I2cClient->dev, "_gDebugRegCount = %d\n", _gDebugRegCount);
+
+        if ((_gDebugReg[0] % 4) == 0)
+        {
+            nRealDQMemAddr = _gDebugReg[0];
+            nRealDQMemValue = DrvIcFwLyrReadDQMemValue(nRealDQMemAddr);
+            _gDebugReg[0] = nRealDQMemAddr;
+            DBG(&g_I2cClient->dev, "nRealDQMemValue Raw = %X\n", nRealDQMemValue);
+            nRealDQMemValue &= 0xFFFF0000;
+            nRealDQMemValue |= _gDebugRegValue[0];
+            DBG(&g_I2cClient->dev, "nRealDQMemValue Modify = %X\n", nRealDQMemValue);
+            DrvIcFwLyrWriteDQMemValue(nRealDQMemAddr, nRealDQMemValue);
+        }
+        else if ((_gDebugReg[0] % 4) == 2)
+        {
+            nRealDQMemAddr = _gDebugReg[0] - 2;
+            nRealDQMemValue = DrvIcFwLyrReadDQMemValue(nRealDQMemAddr);
+            _gDebugReg[0] = nRealDQMemAddr;
+            DBG(&g_I2cClient->dev, "nRealDQMemValue Raw = %X\n", nRealDQMemValue);
+
+            nRealDQMemValue &= 0x0000FFFF;
+            nRealDQMemValue |= (_gDebugRegValue[0] << 16);
+            DBG(&g_I2cClient->dev, "nRealDQMemValue Modify = %X\n", nRealDQMemValue);
+            DrvIcFwLyrWriteDQMemValue(nRealDQMemAddr, nRealDQMemValue);
+        }
+    }
+
+    return nCount;
+}
+
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+
+ssize_t DrvMainProcfsMpTestRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    DBG(&g_I2cClient->dev, "*** ctp mp test status = %d ***\n", DrvIcFwLyrGetMpTestResult());
+
+    nLength = sprintf(pBuffer, "%d", DrvIcFwLyrGetMpTestResult());
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsMpTestWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    u32 nMode = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    if (pBuffer != NULL)
+    {
+        sscanf(pBuffer, "%x", &nMode);   
+
+        DBG(&g_I2cClient->dev, "Mp Test Mode = 0x%x\n", nMode);
+
+        if (nMode == ITO_TEST_MODE_OPEN_TEST) //open test
+        {
+            _gItoTestMode = ITO_TEST_MODE_OPEN_TEST;
+            DrvIcFwLyrScheduleMpTestWork(ITO_TEST_MODE_OPEN_TEST);
+        }
+        else if (nMode == ITO_TEST_MODE_SHORT_TEST) //short test
+        {
+            _gItoTestMode = ITO_TEST_MODE_SHORT_TEST;
+            DrvIcFwLyrScheduleMpTestWork(ITO_TEST_MODE_SHORT_TEST);
+        }
+        else if (nMode == ITO_TEST_MODE_WATERPROOF_TEST) //waterproof test
+        {
+            _gItoTestMode = ITO_TEST_MODE_WATERPROOF_TEST;
+            DrvIcFwLyrScheduleMpTestWork(ITO_TEST_MODE_WATERPROOF_TEST);
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "*** Undefined MP Test Mode ***\n");
+        }
+    }
+    
+    return nCount;
+}
+
+ssize_t DrvMainProcfsMpTestLogRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    DrvIcFwLyrGetMpTestDataLog(_gItoTestMode, pBuffer, &nLength);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsMpTestLogWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return nCount;
+}
+
+ssize_t DrvMainProcfsMpTestFailChannelRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    DrvIcFwLyrGetMpTestFailChannel(_gItoTestMode, pBuffer, &nLength);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsMpTestFailChannelWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return nCount;
+}
+
+ssize_t DrvMainProcfsMpTestScopeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG26XXM) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG28XX)
+    if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        DrvIcFwLyrGetMpTestScope(&g_TestScopeInfo);
+
+        nLength = sprintf(pBuffer, "%d,%d,%d", g_TestScopeInfo.nMx, g_TestScopeInfo.nMy, g_TestScopeInfo.nKeyNum);
+    }  
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM || CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+    
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsMpTestScopeWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return nCount;
+}
+
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+/*--------------------------------------------------------------------------*/
+
+ssize_t DrvMainProcfsFirmwareModeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    if (g_ChipType == CHIP_TYPE_MSG26XXM)
+    {
+        g_FirmwareMode = DrvIcFwLyrGetFirmwareMode();
+
+        DBG(&g_I2cClient->dev, "%s() firmware mode = 0x%x\n", __func__, g_FirmwareMode);
+
+        nLength = sprintf(pBuffer, "%x", g_FirmwareMode);
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        DrvIcFwLyrMutualGetFirmwareInfo(&g_MutualFirmwareInfo);
+        g_FirmwareMode = g_MutualFirmwareInfo.nFirmwareMode;
+
+        DBG(&g_I2cClient->dev, "%s() firmware mode = 0x%x\n", __func__, g_MutualFirmwareInfo.nFirmwareMode);
+
+        nLength = sprintf(pBuffer, "%x", g_MutualFirmwareInfo.nFirmwareMode);
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        DrvIcFwLyrSelfGetFirmwareInfo(&g_SelfFirmwareInfo);
+        g_FirmwareMode = g_SelfFirmwareInfo.nFirmwareMode;
+
+        DBG(&g_I2cClient->dev, "%s() firmware mode = 0x%x, can change firmware mode = %d\n", __func__, g_SelfFirmwareInfo.nFirmwareMode, g_SelfFirmwareInfo.nIsCanChangeFirmwareMode);
+
+        nLength = sprintf(pBuffer, "%x,%d", g_SelfFirmwareInfo.nFirmwareMode, g_SelfFirmwareInfo.nIsCanChangeFirmwareMode);
+    }
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareModeWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    u32 nMode;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    if (pBuffer != NULL)
+    {
+        sscanf(pBuffer, "%x", &nMode);   
+        DBG(&g_I2cClient->dev, "firmware mode = 0x%x\n", nMode);
+
+        g_IsSwitchModeByAPK = 0;
+
+        if (nMode == FIRMWARE_MODE_DEMO_MODE) //demo mode
+        {
+            g_FirmwareMode = DrvIcFwLyrChangeFirmwareMode(FIRMWARE_MODE_DEMO_MODE);
+        }
+        else if (nMode == FIRMWARE_MODE_DEBUG_MODE) //debug mode
+        {
+            g_FirmwareMode = DrvIcFwLyrChangeFirmwareMode(FIRMWARE_MODE_DEBUG_MODE);
+            g_IsSwitchModeByAPK = 1;
+        }
+        else if (nMode == FIRMWARE_MODE_RAW_DATA_MODE) //raw data mode
+        {
+            if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX)
+            {
+                g_FirmwareMode = DrvIcFwLyrChangeFirmwareMode(FIRMWARE_MODE_RAW_DATA_MODE);
+                g_IsSwitchModeByAPK = 1;
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "*** Undefined Firmware Mode ***\n");
+        }
+    }
+
+    DBG(&g_I2cClient->dev, "*** g_FirmwareMode = 0x%x ***\n", g_FirmwareMode);
+    
+    return nCount;
+}
+
+ssize_t DrvMainProcfsFirmwareSensorRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        if (g_MutualFirmwareInfo.nLogModePacketHeader == 0xA5 || g_MutualFirmwareInfo.nLogModePacketHeader == 0xAB)
+        {
+            nLength = sprintf(pBuffer, "%d,%d", g_MutualFirmwareInfo.nMx, g_MutualFirmwareInfo.nMy);
+        }
+        else if (g_MutualFirmwareInfo.nLogModePacketHeader == 0xA7)
+        {
+            nLength = sprintf(pBuffer, "%d,%d,%d,%d", g_MutualFirmwareInfo.nMx, g_MutualFirmwareInfo.nMy, g_MutualFirmwareInfo.nSs, g_MutualFirmwareInfo.nSd);
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "Undefined debug mode packet format : 0x%x\n", g_MutualFirmwareInfo.nLogModePacketHeader);
+            nLength = 0;
+        }
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        nLength = sprintf(pBuffer, "%d", g_SelfFirmwareInfo.nLogModePacketLength);
+    }
+    
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareSensorWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return nCount;
+}
+
+ssize_t DrvMainProcfsFirmwarePacketHeaderRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        nLength = sprintf(pBuffer, "%d", g_MutualFirmwareInfo.nLogModePacketHeader);
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        nLength = sprintf(pBuffer, "%d", g_SelfFirmwareInfo.nLogModePacketHeader);
+    }    
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwarePacketHeaderWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return nCount;
+}
+
+ssize_t DrvMainKObjectPacketShow(struct kobject *pKObj, struct kobj_attribute *pAttr, char *pBuf)
+{
+    u32 i = 0;
+    u32 nLength = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (strcmp(pAttr->attr.name, "packet") == 0)
+    {
+#ifdef CONFIG_ENABLE_APK_PRINT_FW_LOG
+extern u8 bCallApkToGetFwLog ;
+extern unsigned char szPrint[256];
+	if(bCallApkToGetFwLog==1)
+	{
+		nLength = strlen(szPrint);
+		 for (i = 0; i < nLength; i ++)
+                {
+                    pBuf[i] = szPrint[i];
+		      szPrint[i] = 0;
+                }
+		bCallApkToGetFwLog = 0;
+		return nLength;
+	}
+#endif
+        if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE)
+        {
+            if (g_DemoModePacket != NULL)
+            {
+                DBG(&g_I2cClient->dev, "g_FirmwareMode=%x, g_DemoModePacket[0]=%x, g_DemoModePacket[1]=%x\n", g_FirmwareMode, g_DemoModePacket[0], g_DemoModePacket[1]);
+                DBG(&g_I2cClient->dev, "g_DemoModePacket[2]=%x, g_DemoModePacket[3]=%x\n", g_DemoModePacket[2], g_DemoModePacket[3]);
+                DBG(&g_I2cClient->dev, "g_DemoModePacket[4]=%x, g_DemoModePacket[5]=%x\n", g_DemoModePacket[4], g_DemoModePacket[5]);
+                
+                for (i = 0; i < DEMO_MODE_PACKET_LENGTH; i ++)
+                {
+                    pBuf[i] = g_DemoModePacket[i];
+                }
+
+                nLength = DEMO_MODE_PACKET_LENGTH;
+                DBG(&g_I2cClient->dev, "nLength = %d\n", nLength);
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "g_DemoModePacket is NULL\n");
+            }
+        }
+        else //g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE || g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE
+        {
+            if (g_LogModePacket != NULL)
+            {
+                DBG(&g_I2cClient->dev, "g_FirmwareMode=%x, g_LogModePacket[0]=%x, g_LogModePacket[1]=%x\n", g_FirmwareMode, g_LogModePacket[0], g_LogModePacket[1]);
+                DBG(&g_I2cClient->dev, "g_LogModePacket[2]=%x, g_LogModePacket[3]=%x\n", g_LogModePacket[2], g_LogModePacket[3]);
+                DBG(&g_I2cClient->dev, "g_LogModePacket[4]=%x, g_LogModePacket[5]=%x\n", g_LogModePacket[4], g_LogModePacket[5]);
+
+                if ((g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX) && (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE) && (g_LogModePacket[0] == 0xA5 || g_LogModePacket[0] == 0xAB || g_LogModePacket[0] == 0xA7))
+                {
+                    for (i = 0; i < g_MutualFirmwareInfo.nLogModePacketLength; i ++)
+                    {
+                        pBuf[i] = g_LogModePacket[i];
+                    }
+
+                    nLength = g_MutualFirmwareInfo.nLogModePacketLength;
+                    DBG(&g_I2cClient->dev, "nLength = %d\n", nLength);
+                }
+                else if ((g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX) && (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE || g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE) && (g_LogModePacket[0] == 0x62))
+                {
+                    for (i = 0; i < g_SelfFirmwareInfo.nLogModePacketLength; i ++)
+                    {
+                        pBuf[i] = g_LogModePacket[i];
+                    }
+
+                    nLength = g_SelfFirmwareInfo.nLogModePacketLength;
+                    DBG(&g_I2cClient->dev, "nLength = %d\n", nLength);
+                }
+                else
+                {
+                    DBG(&g_I2cClient->dev, "CURRENT MODE IS NOT DEBUG MODE/WRONG DEBUG MODE HEADER\n");
+                }
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "g_LogModePacket is NULL\n");
+            }
+        }
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "pAttr->attr.name = %s \n", pAttr->attr.name);
+    }
+
+    return nLength;
+}
+
+ssize_t DrvMainKObjectPacketStore(struct kobject *pKObj, struct kobj_attribute *pAttr, const char *pBuf, size_t nCount)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+/*
+    if (strcmp(pAttr->attr.name, "packet") == 0)
+    {
+
+    }
+*/    	
+    return nCount;
+}
+
+static struct kobj_attribute packet_attr = __ATTR(packet, 0664, DrvMainKObjectPacketShow, DrvMainKObjectPacketStore);
+
+/* Create a group of attributes so that we can create and destroy them all at once. */
+static struct attribute *attrs[] = {
+    &packet_attr.attr,
+    NULL,	/* need to NULL terminate the list of attributes */
+};
+
+/*
+ * An unnamed attribute group will put all of the attributes directly in
+ * the kobject directory. If we specify a name, a subdirectory will be
+ * created for the attributes with the directory being the name of the
+ * attribute group.
+ */
+static struct attribute_group attr_group = {
+    .attrs = attrs,
+};
+
+
+//------------------------------------------------------------------------------//
+
+ssize_t DrvMainProcfsQueryFeatureSupportStatusRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    nLength = sprintf(pBuffer, "%d", _gFeatureSupportStatus);
+
+    DBG(&g_I2cClient->dev, "*** _gFeatureSupportStatus = %d ***\n", _gFeatureSupportStatus);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsQueryFeatureSupportStatusWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    u32 nFeature;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    if (pBuffer != NULL)
+    {
+        sscanf(pBuffer, "%x", &nFeature);   
+        DBG(&g_I2cClient->dev, "nFeature = 0x%x\n", nFeature);
+
+        if (nFeature == FEATURE_GESTURE_WAKEUP_MODE) 
+        {
+            _gFeatureSupportStatus = IS_GESTURE_WAKEUP_ENABLED;
+        }
+        else if (nFeature == FEATURE_GESTURE_DEBUG_MODE) 
+        {
+            _gFeatureSupportStatus = IS_GESTURE_DEBUG_MODE_ENABLED;
+        }
+        else if (nFeature == FEATURE_GESTURE_INFORMATION_MODE) 
+        {
+            _gFeatureSupportStatus = IS_GESTURE_INFORMATION_MODE_ENABLED;
+        }
+        else if (nFeature == FEATURE_TOUCH_DRIVER_DEBUG_LOG)
+        {
+            _gFeatureSupportStatus = TOUCH_DRIVER_DEBUG_LOG_LEVEL;
+        }
+        else if (nFeature == FEATURE_FIRMWARE_DATA_LOG)
+        {
+            _gFeatureSupportStatus = IS_FIRMWARE_DATA_LOG_ENABLED;
+            
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+            if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)
+            {
+                if (_gFeatureSupportStatus == 1) // If the debug mode data log function is supported, then get packet address and flag address for segment read finger touch data.
+                {
+                    DrvIcFwLyrGetTouchPacketAddress(&g_FwPacketDataAddress, &g_FwPacketFlagAddress);
+                }
+            }
+#endif //CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+        }
+        else if (nFeature == FEATURE_FORCE_TO_UPDATE_FIRMWARE)
+        {
+            _gFeatureSupportStatus = IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED;
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "*** Undefined Feature ***\n");
+        }
+    }
+
+    DBG(&g_I2cClient->dev, "*** _gFeatureSupportStatus = %d ***\n", _gFeatureSupportStatus);
+    
+    return nCount;
+}
+
+ssize_t DrvMainProcfsChangeFeatureSupportStatusRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    nLength = sprintf(pBuffer, "%d", _gFeatureSupportStatus);
+
+    DBG(&g_I2cClient->dev, "*** _gFeatureSupportStatus = %d ***\n", _gFeatureSupportStatus);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsChangeFeatureSupportStatusWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    u32 i;
+    u32 nFeature = 0, nNewValue = 0;
+    char *pCh = NULL;
+    char *pStr = NULL;  
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (pBuffer != NULL)
+    {
+        DBG(&g_I2cClient->dev, "nCount = %d\n", (int)nCount);
+
+        memset(_gDebugBuf, 0, 1024);
+
+        if (copy_from_user(_gDebugBuf, pBuffer, nCount))
+        {
+            DBG(&g_I2cClient->dev, "copy_from_user() failed\n");
+
+            return -EFAULT;
+        }
+       
+        _gDebugBuf[nCount] = '\0';
+        pStr = _gDebugBuf;
+        
+        i = 0;
+        
+        while ((pCh = strsep((char **)&pStr, " ,")) && (i < 3))
+        {
+            DBG(&g_I2cClient->dev, "pCh = %s\n", pCh);
+
+            if (i == 0)
+            {
+                nFeature = DrvCommonConvertCharToHexDigit(pCh, strlen(pCh));
+                DBG(&g_I2cClient->dev, "nFeature = 0x%04X\n", nFeature);
+            }
+            else if (i == 1)
+            {	
+                nNewValue = DrvCommonConvertCharToHexDigit(pCh, strlen(pCh));
+                DBG(&g_I2cClient->dev, "nNewValue = %d\n", nNewValue);
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "End of parsing adb command.\n");
+            }
+
+            i ++;
+        }
+
+        if (nFeature == FEATURE_GESTURE_WAKEUP_MODE) 
+        {
+            IS_GESTURE_WAKEUP_ENABLED = nNewValue;
+            _gFeatureSupportStatus = IS_GESTURE_WAKEUP_ENABLED;
+        }
+        else if (nFeature == FEATURE_GESTURE_DEBUG_MODE) 
+        {
+            IS_GESTURE_DEBUG_MODE_ENABLED = nNewValue;
+            _gFeatureSupportStatus = IS_GESTURE_DEBUG_MODE_ENABLED;
+        }
+        else if (nFeature == FEATURE_GESTURE_INFORMATION_MODE) 
+        {
+            IS_GESTURE_INFORMATION_MODE_ENABLED = nNewValue;
+            _gFeatureSupportStatus = IS_GESTURE_INFORMATION_MODE_ENABLED;
+        }
+        else if (nFeature == FEATURE_TOUCH_DRIVER_DEBUG_LOG)
+        {
+            TOUCH_DRIVER_DEBUG_LOG_LEVEL = nNewValue;
+            _gFeatureSupportStatus = TOUCH_DRIVER_DEBUG_LOG_LEVEL;
+        }
+        else if (nFeature == FEATURE_FIRMWARE_DATA_LOG)
+        {
+            IS_FIRMWARE_DATA_LOG_ENABLED = nNewValue;
+            _gFeatureSupportStatus = IS_FIRMWARE_DATA_LOG_ENABLED;
+        }
+        else if (nFeature == FEATURE_FORCE_TO_UPDATE_FIRMWARE)
+        {
+            IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED = nNewValue;
+            _gFeatureSupportStatus = IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED;
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "*** Undefined Feature ***\n");
+        }
+
+        DBG(&g_I2cClient->dev, "*** _gFeatureSupportStatus = %d ***\n", _gFeatureSupportStatus);
+    }
+    
+    return nCount;
+}
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+ssize_t DrvMainProcfsGestureWakeupModeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+#ifdef CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+    DBG(&g_I2cClient->dev, "g_GestureWakeupMode = 0x%x, 0x%x\n", g_GestureWakeupMode[0], g_GestureWakeupMode[1]);
+
+    nLength = sprintf(pBuffer, "%x,%x", g_GestureWakeupMode[0], g_GestureWakeupMode[1]);
+#else
+    DBG(&g_I2cClient->dev, "g_GestureWakeupMode = 0x%x\n", g_GestureWakeupMode[0]);
+
+    nLength = sprintf(pBuffer, "%x", g_GestureWakeupMode[0]);
+#endif //CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsGestureWakeupModeWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    u32 nLength;
+    u32 nWakeupMode[2] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (pBuffer != NULL)
+    {
+#ifdef CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+        u32 i;
+        char *pCh;
+
+        i = 0;
+        while ((pCh = strsep((char **)&pBuffer, " ,")) && (i < 2))
+        {
+            DBG(&g_I2cClient->dev, "pCh = %s\n", pCh);
+
+            nWakeupMode[i] = DrvCommonConvertCharToHexDigit(pCh, strlen(pCh));
+
+            DBG(&g_I2cClient->dev, "nWakeupMode[%d] = 0x%04X\n", i, nWakeupMode[i]);
+            i ++;
+        }
+#else
+        sscanf(pBuffer, "%x", &nWakeupMode[0]);
+        DBG(&g_I2cClient->dev, "nWakeupMode = 0x%x\n", nWakeupMode[0]);
+#endif //CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+
+        nLength = nCount;
+        DBG(&g_I2cClient->dev, "nLength = %d\n", nLength);
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG) == GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG) == GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG) == GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG) == GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG) == GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE1_FLAG) == GESTURE_WAKEUP_MODE_RESERVE1_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE1_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE1_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE2_FLAG) == GESTURE_WAKEUP_MODE_RESERVE2_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE2_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE2_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE3_FLAG) == GESTURE_WAKEUP_MODE_RESERVE3_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE3_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE3_FLAG);
+        }
+
+#ifdef CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE4_FLAG) == GESTURE_WAKEUP_MODE_RESERVE4_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE4_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE4_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE5_FLAG) == GESTURE_WAKEUP_MODE_RESERVE5_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE5_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE5_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE6_FLAG) == GESTURE_WAKEUP_MODE_RESERVE6_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE6_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE6_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE7_FLAG) == GESTURE_WAKEUP_MODE_RESERVE7_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE7_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE7_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE8_FLAG) == GESTURE_WAKEUP_MODE_RESERVE8_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE8_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE8_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE9_FLAG) == GESTURE_WAKEUP_MODE_RESERVE9_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE9_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE9_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE10_FLAG) == GESTURE_WAKEUP_MODE_RESERVE10_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE10_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE10_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE11_FLAG) == GESTURE_WAKEUP_MODE_RESERVE11_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE11_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE11_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE12_FLAG) == GESTURE_WAKEUP_MODE_RESERVE12_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE12_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE12_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE13_FLAG) == GESTURE_WAKEUP_MODE_RESERVE13_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE13_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE13_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE14_FLAG) == GESTURE_WAKEUP_MODE_RESERVE14_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE14_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE14_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE15_FLAG) == GESTURE_WAKEUP_MODE_RESERVE15_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE15_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE15_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE16_FLAG) == GESTURE_WAKEUP_MODE_RESERVE16_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE16_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE16_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE17_FLAG) == GESTURE_WAKEUP_MODE_RESERVE17_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE17_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE17_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE18_FLAG) == GESTURE_WAKEUP_MODE_RESERVE18_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE18_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE18_FLAG);
+        }
+
+        if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE19_FLAG) == GESTURE_WAKEUP_MODE_RESERVE19_FLAG)
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RESERVE19_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RESERVE19_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE20_FLAG) == GESTURE_WAKEUP_MODE_RESERVE20_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE20_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE20_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE21_FLAG) == GESTURE_WAKEUP_MODE_RESERVE21_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE21_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE21_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE22_FLAG) == GESTURE_WAKEUP_MODE_RESERVE22_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE22_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE22_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE23_FLAG) == GESTURE_WAKEUP_MODE_RESERVE23_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE23_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE23_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE24_FLAG) == GESTURE_WAKEUP_MODE_RESERVE24_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE24_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE24_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE25_FLAG) == GESTURE_WAKEUP_MODE_RESERVE25_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE25_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE25_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE26_FLAG) == GESTURE_WAKEUP_MODE_RESERVE26_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE26_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE26_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE27_FLAG) == GESTURE_WAKEUP_MODE_RESERVE27_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE27_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE27_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE28_FLAG) == GESTURE_WAKEUP_MODE_RESERVE28_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE28_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE28_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE29_FLAG) == GESTURE_WAKEUP_MODE_RESERVE29_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE29_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE29_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE30_FLAG) == GESTURE_WAKEUP_MODE_RESERVE30_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE30_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE30_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE31_FLAG) == GESTURE_WAKEUP_MODE_RESERVE31_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE31_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE31_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE32_FLAG) == GESTURE_WAKEUP_MODE_RESERVE32_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE32_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE32_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE33_FLAG) == GESTURE_WAKEUP_MODE_RESERVE33_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE33_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE33_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE34_FLAG) == GESTURE_WAKEUP_MODE_RESERVE34_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE34_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE34_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE35_FLAG) == GESTURE_WAKEUP_MODE_RESERVE35_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE35_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE35_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE36_FLAG) == GESTURE_WAKEUP_MODE_RESERVE36_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE36_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE36_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE37_FLAG) == GESTURE_WAKEUP_MODE_RESERVE37_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE37_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE37_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE38_FLAG) == GESTURE_WAKEUP_MODE_RESERVE38_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE38_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE38_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE39_FLAG) == GESTURE_WAKEUP_MODE_RESERVE39_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE39_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE39_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE40_FLAG) == GESTURE_WAKEUP_MODE_RESERVE40_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE40_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE40_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE41_FLAG) == GESTURE_WAKEUP_MODE_RESERVE41_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE41_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE41_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE42_FLAG) == GESTURE_WAKEUP_MODE_RESERVE42_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE42_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE42_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE43_FLAG) == GESTURE_WAKEUP_MODE_RESERVE43_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE43_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE43_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE44_FLAG) == GESTURE_WAKEUP_MODE_RESERVE44_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE44_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE44_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE45_FLAG) == GESTURE_WAKEUP_MODE_RESERVE45_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE45_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE45_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE46_FLAG) == GESTURE_WAKEUP_MODE_RESERVE46_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE46_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE46_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE47_FLAG) == GESTURE_WAKEUP_MODE_RESERVE47_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE47_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE47_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE48_FLAG) == GESTURE_WAKEUP_MODE_RESERVE48_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE48_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE48_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE49_FLAG) == GESTURE_WAKEUP_MODE_RESERVE49_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE49_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE49_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE50_FLAG) == GESTURE_WAKEUP_MODE_RESERVE50_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE50_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE50_FLAG);
+        }
+
+        if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE51_FLAG) == GESTURE_WAKEUP_MODE_RESERVE51_FLAG)
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] | GESTURE_WAKEUP_MODE_RESERVE51_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode[1] = g_GestureWakeupMode[1] & (~GESTURE_WAKEUP_MODE_RESERVE51_FLAG);
+        }
+#endif //CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+
+        DBG(&g_I2cClient->dev, "g_GestureWakeupMode = 0x%x,  0x%x\n", g_GestureWakeupMode[0], g_GestureWakeupMode[1]);
+    }
+       
+    return nCount;
+}
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+ssize_t DrvMainProcfsGestureDebugModeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+    
+    DBG(&g_I2cClient->dev, "g_GestureDebugMode = 0x%x\n", g_GestureDebugMode); // add for debug
+
+    nLength = sprintf(pBuffer, "%d", g_GestureDebugMode);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsGestureDebugModeWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    u8 ucGestureMode[2];
+    u8 i;
+    char *pCh;
+
+    if (pBuffer != NULL)
+    {
+        i = 0;
+        while ((pCh = strsep((char **)&pBuffer, " ,")) && (i < 2))
+        {
+            DBG(&g_I2cClient->dev, "pCh = %s\n", pCh);
+
+            ucGestureMode[i] = DrvCommonConvertCharToHexDigit(pCh, strlen(pCh));
+
+            DBG(&g_I2cClient->dev, "ucGestureMode[%d] = 0x%04X\n", i, ucGestureMode[i]);
+            i ++;
+        }
+
+        g_GestureDebugMode = ucGestureMode[0];
+        g_GestureDebugFlag = ucGestureMode[1];
+
+        DBG(&g_I2cClient->dev, "Gesture flag = 0x%x\n", g_GestureDebugFlag);
+
+        if (g_GestureDebugMode == 0x01) //open gesture debug mode
+        {
+            DrvIcFwLyrOpenGestureDebugMode(g_GestureDebugFlag);
+
+//            input_report_key(g_InputDevice, RESERVER42, 1);
+            input_report_key(g_InputDevice, KEY_POWER, 1);
+            input_sync(g_InputDevice);
+//            input_report_key(g_InputDevice, RESERVER42, 0);
+            input_report_key(g_InputDevice, KEY_POWER, 0);
+            input_sync(g_InputDevice);
+        }
+        else if (g_GestureDebugMode == 0x00) //close gesture debug mode
+        {
+            DrvIcFwLyrCloseGestureDebugMode();
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "*** Undefined Gesture Debug Mode ***\n");
+        }
+    }
+
+    return nCount;
+}
+
+ssize_t DrvMainKObjectGestureDebugShow(struct kobject *pKObj, struct kobj_attribute *pAttr, char *pBuf)
+{
+    u32 i = 0;
+    u32 nLength = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (strcmp(pAttr->attr.name, "gesture_debug") == 0)
+    {
+        if (g_LogGestureDebug != NULL)
+        {
+            DBG(&g_I2cClient->dev, "g_LogGestureDebug[0]=%x, g_LogGestureDebug[1]=%x\n", g_LogGestureDebug[0], g_LogGestureDebug[1]);
+            DBG(&g_I2cClient->dev, "g_LogGestureDebug[2]=%x, g_LogGestureDebug[3]=%x\n", g_LogGestureDebug[2], g_LogGestureDebug[3]);
+            DBG(&g_I2cClient->dev, "g_LogGestureDebug[4]=%x, g_LogGestureDebug[5]=%x\n", g_LogGestureDebug[4], g_LogGestureDebug[5]);
+
+            if (g_LogGestureDebug[0] == 0xA7 && g_LogGestureDebug[3] == 0x51)
+            {
+                for (i = 0; i < 0x80; i ++)
+                {
+                    pBuf[i] = g_LogGestureDebug[i];
+                }
+
+                nLength = 0x80;
+                DBG(&g_I2cClient->dev, "nLength = %d\n", nLength);
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "CURRENT MODE IS NOT GESTURE DEBUG MODE/WRONG GESTURE DEBUG MODE HEADER\n");
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "g_LogGestureDebug is NULL\n");
+        }
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "pAttr->attr.name = %s \n", pAttr->attr.name);
+    }
+
+    return nLength;
+}
+
+ssize_t DrvMainKObjectGestureDebugStore(struct kobject *pKObj, struct kobj_attribute *pAttr, const char *pBuf, size_t nCount)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+/*
+    if (strcmp(pAttr->attr.name, "gesture_debug") == 0)
+    {
+
+    }
+*/
+    return nCount;
+}
+
+static struct kobj_attribute gesture_attr = __ATTR(gesture_debug, 0664, DrvMainKObjectGestureDebugShow, DrvMainKObjectGestureDebugStore);
+
+/* Create a group of attributes so that we can create and destroy them all at once. */
+static struct attribute *gestureattrs[] = {
+    &gesture_attr.attr,
+    NULL,	/* need to NULL terminate the list of attributes */
+};
+
+/*
+ * An unnamed attribute group will put all of the attributes directly in
+ * the kobject directory. If we specify a name, a subdirectory will be
+ * created for the attributes with the directory being the name of the
+ * attribute group.
+ */
+struct attribute_group gestureattr_group = {
+    .attrs = gestureattrs,
+};
+
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+
+ssize_t DrvMainProcfsGestureInforModeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u8 szOut[GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH*5] = {0}, szValue[10] = {0};
+    u32 szLogGestureInfo[GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH] = {0};
+    u32 i = 0;
+    u32 nLength = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    _gLogGestureCount = 0;
+    if (_gLogGestureInforType == FIRMWARE_GESTURE_INFORMATION_MODE_A) //FIRMWARE_GESTURE_INFORMATION_MODE_A
+    {
+        for (i = 0; i < 2; i ++)//0 EventFlag; 1 RecordNum
+        {
+            szLogGestureInfo[_gLogGestureCount] = g_LogGestureInfor[4 + i];
+            _gLogGestureCount ++;
+        }
+
+        for (i = 2; i < 8; i ++)//2~3 Xst Yst; 4~5 Xend Yend; 6~7 char_width char_height
+        {
+            szLogGestureInfo[_gLogGestureCount] = g_LogGestureInfor[4 + i];
+            _gLogGestureCount ++;
+        }
+    }
+    else if (_gLogGestureInforType == FIRMWARE_GESTURE_INFORMATION_MODE_B) //FIRMWARE_GESTURE_INFORMATION_MODE_B
+    {
+        for (i = 0; i < 2; i ++)//0 EventFlag; 1 RecordNum
+        {
+            szLogGestureInfo[_gLogGestureCount] = g_LogGestureInfor[4 + i];
+            _gLogGestureCount ++;
+        }
+
+        for (i = 0; i < g_LogGestureInfor[5]*2 ; i ++)//(X and Y)*RecordNum
+        {
+            szLogGestureInfo[_gLogGestureCount] = g_LogGestureInfor[12 + i];
+            _gLogGestureCount ++;
+        }
+    }
+    else if (_gLogGestureInforType == FIRMWARE_GESTURE_INFORMATION_MODE_C) //FIRMWARE_GESTURE_INFORMATION_MODE_C
+    {
+        for (i = 0; i < 6; i ++)//header
+        {
+            szLogGestureInfo[_gLogGestureCount] = g_LogGestureInfor[i];
+            _gLogGestureCount ++;
+        }
+
+        for (i = 6; i < 86; i ++)
+        {
+            szLogGestureInfo[_gLogGestureCount] = g_LogGestureInfor[i];
+            _gLogGestureCount ++;
+        }
+
+        szLogGestureInfo[_gLogGestureCount] = g_LogGestureInfor[86];//dummy
+        _gLogGestureCount ++;
+        szLogGestureInfo[_gLogGestureCount] = g_LogGestureInfor[87];//checksum
+        _gLogGestureCount++;
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "*** Undefined GESTURE INFORMATION MODE ***\n");
+    }
+
+    for (i = 0; i < _gLogGestureCount; i ++)
+    {
+        sprintf(szValue, "%d", szLogGestureInfo[i]);
+        strcat(szOut, szValue);
+        strcat(szOut, ",");
+    }
+
+    nLength = sprintf(pBuffer, "%s\n", szOut);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsGestureInforModeWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    u32 nMode;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (pBuffer != NULL)
+    {
+        sscanf(pBuffer, "%x", &nMode);
+        _gLogGestureInforType = nMode;
+    }
+
+    DBG(&g_I2cClient->dev, "*** _gLogGestureInforType type = 0x%x ***\n", _gLogGestureInforType);
+
+    return nCount;
+}
+
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+ssize_t DrvMainProcfsReportRateRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    struct timeval tEndTime;
+    suseconds_t nStartTime, nEndTime, nElapsedTime;
+    u32 nLength = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DBG(&g_I2cClient->dev, "g_InterruptCount = %d, g_ValidTouchCount = %d\n", g_InterruptCount, g_ValidTouchCount);
+    
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    // Get end time
+    do_gettimeofday(&tEndTime);
+    
+    nStartTime = g_StartTime.tv_sec + g_StartTime.tv_usec/1000000;
+    nEndTime = tEndTime.tv_sec + tEndTime.tv_usec/1000000;
+
+    nElapsedTime = nEndTime - nStartTime;
+
+    DBG(&g_I2cClient->dev, "Start time : %lu sec, %lu msec\n", g_StartTime.tv_sec,  g_StartTime.tv_usec); 
+    DBG(&g_I2cClient->dev, "End time : %lu sec, %lu msec\n", tEndTime.tv_sec, tEndTime.tv_usec); 
+
+    DBG(&g_I2cClient->dev, "Elapsed time : %lu sec\n", nElapsedTime); 
+    
+    // Calculate report rate
+    if (nElapsedTime != 0)
+    {
+        g_InterruptReportRate = g_InterruptCount / nElapsedTime;
+        g_ValidTouchReportRate = g_ValidTouchCount / nElapsedTime;
+    }
+    else
+    {
+        g_InterruptReportRate = 0;		
+        g_ValidTouchReportRate = 0;		
+    }
+
+    DBG(&g_I2cClient->dev, "g_InterruptReportRate = %d, g_ValidTouchReportRate = %d\n", g_InterruptReportRate, g_ValidTouchReportRate);
+
+    g_InterruptCount = 0; // Reset count
+    g_ValidTouchCount = 0;
+
+    nLength = sprintf(pBuffer, "%d,%d", g_InterruptReportRate, g_ValidTouchReportRate);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsReportRateWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    if (pBuffer != NULL)
+    {
+        sscanf(pBuffer, "%d", &g_IsEnableReportRate);   
+
+        DBG(&g_I2cClient->dev, "g_IsEnableReportRate = %d\n", g_IsEnableReportRate); // 1 : enable report rate calculation, 0 : disable report rate calculation, 2 : reset count
+
+        g_InterruptCount = 0; // Reset count
+        g_ValidTouchCount = 0;
+    }
+    
+    return nCount;
+}
+#endif //CONFIG_ENABLE_COUNT_REPORT_RATE
+
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+ssize_t DrvMainProcfsGloveModeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+    u8 ucGloveMode = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    if (g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        DrvPlatformLyrDisableFingerTouchReport();
+
+        DrvIcFwLyrGetGloveInfo(&ucGloveMode);
+
+        DrvPlatformLyrEnableFingerTouchReport();
+
+        DBG(&g_I2cClient->dev, "Glove Mode = 0x%x\n", ucGloveMode);
+
+        nLength = sprintf(pBuffer, "%x", ucGloveMode);
+    }
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsGloveModeWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nGloveMode = 0;
+    u32 i = 0;
+    char *pCh = NULL;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (pBuffer != NULL)
+    {
+        i = 0;
+        while ((pCh = strsep((char **)&pBuffer, ",")) && (i < 1))
+        {
+            DBG(&g_I2cClient->dev, "pCh = %s\n", pCh);
+
+            nGloveMode = DrvCommonConvertCharToHexDigit(pCh, strlen(pCh));
+
+            i ++;
+        }
+
+        DBG(&g_I2cClient->dev, "Glove Mode = 0x%x\n", nGloveMode);
+
+        DrvPlatformLyrDisableFingerTouchReport();
+
+        if (nGloveMode == 0x01) //open glove mode
+        {
+            DrvIcFwLyrOpenGloveMode();
+            g_IsEnableGloveMode = 1;
+        }
+        else if (nGloveMode == 0x00) //close glove mode
+        {
+            DrvIcFwLyrCloseGloveMode();
+            g_IsEnableGloveMode = 0;
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "*** Undefined Glove Mode ***\n");
+        }
+        DBG(&g_I2cClient->dev, "g_IsEnableGloveMode = 0x%x\n", g_IsEnableGloveMode);
+
+        DrvPlatformLyrEnableFingerTouchReport();
+    }
+
+    return nCount;
+}
+
+ssize_t DrvMainProcfsOpenGloveModeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    if (g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        DrvPlatformLyrDisableFingerTouchReport();
+
+        DrvIcFwLyrOpenGloveMode();
+        g_IsEnableGloveMode = 1;
+
+        DrvPlatformLyrEnableFingerTouchReport();
+    }
+    DBG(&g_I2cClient->dev, "g_IsEnableGloveMode = 0x%x\n", g_IsEnableGloveMode);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+
+ssize_t DrvMainProcfsCloseGloveModeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    u32 nLength = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // If file position is non-zero, then assume the string has been read and indicate there is no more data to be read.
+    if (*pPos != 0)
+    {
+        return 0;
+    }
+
+    if (g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        DrvPlatformLyrDisableFingerTouchReport();
+
+        DrvIcFwLyrCloseGloveMode();
+        g_IsEnableGloveMode = 0;
+
+        DrvPlatformLyrEnableFingerTouchReport();
+    }
+    DBG(&g_I2cClient->dev, "g_IsEnableGloveMode = 0x%x\n", g_IsEnableGloveMode);
+
+    *pPos += nLength;
+
+    return nLength;
+}
+#endif //CONFIG_ENABLE_GLOVE_MODE
+
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+static long hotknot_ioctl( struct file *file, unsigned int cmd, unsigned long arg )
+{
+    long nRet = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s ***\n", __func__);
+    mutex_lock(&g_HKMutex);     
+    nRet = HotKnotIoctl(file, cmd, arg);              
+    mutex_unlock(&g_HKMutex);    
+	
+    return nRet;
+}
+
+static int hotknot_value;
+
+static ssize_t hotknot_value_show( struct kobject *kobj, struct kobj_attribute *attr, char *buf )
+{
+    return sprintf( buf, "%d\n", hotknot_value );
+}
+
+static ssize_t hotknot_value_store( struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count )
+{
+    sscanf( buf, "%d", &hotknot_value );
+    
+    return count;
+}
+
+static struct kobj_attribute hotknot_value_attr = __ATTR( hotknot_value, 0666, hotknot_value_show, hotknot_value_store );
+static struct attribute *hotknot_attrs[] =
+{
+    &hotknot_value_attr.attr, 0
+};
+
+static struct attribute_group hotknot_attr_group =
+{
+    .attrs = hotknot_attrs
+};
+
+static const struct file_operations hotknot_fops =
+{
+    .owner = THIS_MODULE,
+    .unlocked_ioctl = hotknot_ioctl
+};
+
+//static struct miscdevice hotknot_miscdevice =
+struct miscdevice hotknot_miscdevice =
+{
+    .minor = MISC_DYNAMIC_MINOR,
+    .name = "hotknot",
+    .nodename = "hotknot",
+    .mode = 0666,
+    .fops = &hotknot_fops
+};
+#endif //CONFIG_ENABLE_HOTKNOT
+
+//------------------------------------------------------------------------------//
+
+s32 DrvMainTouchDeviceInitialize(void)
+{
+    s32 nRetVal = 0;
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+    int nErr;
+    struct hwmsen_object tObjPs;
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    _DrvMainCreateProcfsDirEntry(); // Create procfs directory entry
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+    _DrvMainHotknotRegistry();    //register hotknot here...         
+#endif //CONFIG_ENABLE_HOTKNOT
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+    CreateMsgToolMem();
+#endif //CONFIG_ENABLE_JNI_INTERFACE
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+    DrvIcFwLyrCreateMpTestWorkQueue();
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+    
+    g_ChipType = DrvIcFwLyrGetChipType(); // Try to get chip type by SLAVE_I2C_ID_DBBUS(0x62) firstly.
+    
+    if (g_ChipType == 0) // If failed, try to get chip type by SLAVE_I2C_ID_DBBUS(0x59) again.
+    {
+        SLAVE_I2C_ID_DBBUS = (0xB2>>1); //0x59
+
+        g_ChipType = DrvIcFwLyrGetChipType(); 
+    }
+    
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    if (g_ChipType != 0) // To make sure TP is attached on cell phone.
+    {
+        if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)
+        {
+            memset(&g_MutualFirmwareInfo, 0x0, sizeof(MutualFirmwareInfo_t));
+        }
+        else if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX)
+        {
+            memset(&g_SelfFirmwareInfo, 0x0, sizeof(SelfFirmwareInfo_t));
+        }
+
+        DrvIcFwLyrVariableInitialize();
+
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION 
+        {
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+            u32 nChargerStatus = 0; 
+
+            nChargerStatus = upmu_is_chr_det();
+
+            DBG(&g_I2cClient->dev, "*** Battery Status : %d ***\n", nChargerStatus);
+            
+            if (nChargerStatus) // Charging
+            {
+                DrvFwCtrlChargerDetection(1); // charger plug-in
+            }
+            else // Not charging
+            {
+                DrvFwCtrlChargerDetection(0); // charger plug-out
+            }
+#else // CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM || CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM   
+            u8 szChargerStatus[20] = {0};
+     
+            DrvCommonReadFile("/sys/class/power_supply/battery/status", szChargerStatus, 20);
+            
+            DBG(&g_I2cClient->dev, "*** Battery Status : %s ***\n", szChargerStatus);
+            
+            if (strstr(szChargerStatus, "Charging") != NULL || strstr(szChargerStatus, "Full") != NULL || strstr(szChargerStatus, "Fully charged") != NULL) // Charging
+            {
+                DrvFwCtrlChargerDetection(1); // charger plug-in
+            }
+            else // Not charging
+            {
+                DrvFwCtrlChargerDetection(0); // charger plug-out
+            }
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+        }           
+#endif //CONFIG_ENABLE_CHARGER_DETECTION
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+//        tsps_assist_register_callback("msg2xxx", &DrvPlatformLyrTpPsEnable, &DrvPlatformLyrGetTpPsData);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        tObjPs.polling = 0; //interrupt mode
+        tObjPs.sensor_operate = DrvPlatformLyrTpPsOperate;
+    
+        if ((nErr = hwmsen_attach(ID_PROXIMITY, &tObjPs)))
+        {
+            DBG(&g_I2cClient->dev, "call hwmsen_attach() failed = %d\n", nErr);
+        }
+#endif
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+    }
+    else
+    {
+        nRetVal = -ENODEV;
+    }
+
+    return nRetVal;
+}
+
+void DrvMainRemoveProcfsDirEntry(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+    if (_gProcGloveModeEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_GLOVE_MODE, _gProcDeviceEntry);  
+        _gProcGloveModeEntry = NULL;  		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_GLOVE_MODE);
+    }
+
+    if (_gProcOpenGloveModeEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_OPEN_GLOVE_MODE, _gProcDeviceEntry);   
+        _gProcOpenGloveModeEntry = NULL; 		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_OPEN_GLOVE_MODE);
+    }
+
+    if (_gProcCloseGloveModeEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_CLOSE_GLOVE_MODE, _gProcDeviceEntry);   
+        _gProcCloseGloveModeEntry = NULL; 		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_CLOSE_GLOVE_MODE);
+    }
+#endif //CONFIG_ENABLE_GLOVE_MODE
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+    if (_gProcJniMethodEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_JNI_NODE, _gProcDeviceEntry);    		
+        _gProcJniMethodEntry = NULL;
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_JNI_NODE);
+    }
+#endif //CONFIG_ENABLE_JNI_INTERFACE	
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+    if (_gProcReportRateEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_REPORT_RATE, _gProcDeviceEntry);    	
+        _gProcReportRateEntry = NULL;	
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_REPORT_RATE);
+    }
+#endif //CONFIG_ENABLE_COUNT_REPORT_RATE
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (_gProcGestureWakeupModeEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_GESTURE_WAKEUP_MODE, _gProcDeviceEntry);  
+        _gProcGestureWakeupModeEntry = NULL;  		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_GESTURE_WAKEUP_MODE);
+    }
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+    if (_gProcGestureDebugModeEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_GESTURE_DEBUG_MODE, _gProcDeviceEntry);    	
+        _gProcGestureDebugModeEntry = NULL;	
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_GESTURE_DEBUG_MODE);
+    }
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+    if (_gProcGestureInforModeEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_GESTURE_INFORMATION_MODE, _gProcDeviceEntry);  
+        _gProcGestureInforModeEntry = NULL;  		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_GESTURE_INFORMATION_MODE);
+    }
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+    if (_gProcFirmwareModeEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_FIRMWARE_MODE, _gProcDeviceEntry);    
+        _gProcFirmwareModeEntry = NULL;		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_MODE);
+    }
+
+    if (_gProcFirmwareSensorEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_FIRMWARE_SENSOR, _gProcDeviceEntry);  
+        _gProcFirmwareSensorEntry = NULL; 		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_SENSOR);
+    }
+
+    if (_gProcFirmwarePacketHeaderEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_FIRMWARE_PACKET_HEADER, _gProcDeviceEntry);    		
+        _gProcFirmwarePacketHeaderEntry = NULL;
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_PACKET_HEADER);
+    }
+
+    if (_gProcQueryFeatureSupportStatusEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_QUERY_FEATURE_SUPPORT_STATUS, _gProcDeviceEntry);   
+        _gProcQueryFeatureSupportStatusEntry = NULL; 		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_QUERY_FEATURE_SUPPORT_STATUS);
+    }
+
+    if (_gProcChangeFeatureSupportStatusEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_CHANGE_FEATURE_SUPPORT_STATUS, _gProcDeviceEntry);  
+        _gProcChangeFeatureSupportStatusEntry = NULL;  		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_CHANGE_FEATURE_SUPPORT_STATUS);
+    }
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+    if (_gProcMpTestEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_MP_TEST, _gProcDeviceEntry);    		
+        _gProcMpTestEntry = NULL;
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_MP_TEST);
+    }
+
+    if (_gProcMpTestLogEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_MP_TEST_LOG, _gProcDeviceEntry);  
+        _gProcMpTestLogEntry = NULL;  		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_MP_TEST_LOG);
+    }
+
+    if (_gProcMpTestFailChannelEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_MP_TEST_FAIL_CHANNEL, _gProcDeviceEntry);    		
+        _gProcMpTestFailChannelEntry = NULL;
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_MP_TEST_FAIL_CHANNEL);
+    }
+
+    if (_gProcMpTestScopeEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_MP_TEST_SCOPE, _gProcDeviceEntry); 
+        _gProcMpTestScopeEntry = NULL;   		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_MP_TEST_SCOPE);
+    }
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+    if (_gProcFirmwareSetDQMemValueEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_FIRMWARE_SET_DQMEM_VALUE, _gProcDeviceEntry);    		
+        _gProcFirmwareSetDQMemValueEntry = NULL;
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_SET_DQMEM_VALUE);
+    }
+
+    if (_gProcFirmwareSmBusDebugEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_FIRMWARE_SMBUS_DEBUG, _gProcDeviceEntry);    
+        _gProcFirmwareSmBusDebugEntry = NULL;		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_SMBUS_DEBUG);
+    }
+
+    if (_gProcFirmwareSetDebugValueEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_FIRMWARE_SET_DEBUG_VALUE, _gProcDeviceEntry);  
+        _gProcFirmwareSetDebugValueEntry = NULL;  		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_SET_DEBUG_VALUE);
+    }
+
+    if (_gProcFirmwareDebugEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_FIRMWARE_DEBUG, _gProcDeviceEntry);    	
+        _gProcFirmwareDebugEntry = NULL;	
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_DEBUG);
+    }
+
+    if (_gProcSdCardFirmwareUpdateEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_SD_CARD_FIRMWARE_UPDATE, _gProcDeviceEntry);  
+        _gProcSdCardFirmwareUpdateEntry = NULL;  		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_SD_CARD_FIRMWARE_UPDATE);
+    }
+
+    if (_gProcSeLinuxLimitFirmwareUpdateEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_SELINUX_LIMIT_FIRMWARE_UPDATE, _gProcDeviceEntry);
+        _gProcSeLinuxLimitFirmwareUpdateEntry = NULL;    		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_SELINUX_LIMIT_FIRMWARE_UPDATE);
+    }
+
+    if (_gProcForceFirmwareUpdateEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_FORCE_FIRMWARE_UPDATE, _gProcDeviceEntry);
+        _gProcForceFirmwareUpdateEntry = NULL;    		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_FORCE_FIRMWARE_UPDATE);
+    }
+
+    if (_gProcDeviceDriverVersionEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_DEVICE_DRIVER_VERSION, _gProcDeviceEntry);
+        _gProcDeviceDriverVersionEntry = NULL;    		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_DEVICE_DRIVER_VERSION);
+    }
+
+    if (_gProcPlatformFirmwareVersionEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_PLATFORM_FIRMWARE_VERSION, _gProcDeviceEntry);
+        _gProcPlatformFirmwareVersionEntry = NULL;    		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_PLATFORM_FIRMWARE_VERSION);
+    }
+
+    if (_gProcCustomerFirmwareVersionEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_CUSTOMER_FIRMWARE_VERSION, _gProcDeviceEntry);
+        _gProcCustomerFirmwareVersionEntry = NULL;    		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_CUSTOMER_FIRMWARE_VERSION);
+    }
+
+    if (_gProcApkFirmwareUpdateEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_FIRMWARE_UPDATE, _gProcDeviceEntry);
+        _gProcApkFirmwareUpdateEntry = NULL;    		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_UPDATE);
+    }
+
+    if (_gProcFirmwareDataEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_FIRMWARE_DATA, _gProcDeviceEntry);
+        _gProcFirmwareDataEntry = NULL;    		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_DATA);
+    }
+
+    if (_gProcChipTypeEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_CHIP_TYPE, _gProcDeviceEntry);
+        _gProcChipTypeEntry = NULL;    		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_CHIP_TYPE);
+    }
+
+    if (_gProcDeviceEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_DEVICE, _gProcMsTouchScreenMsg20xxEntry);
+        _gProcDeviceEntry = NULL;    		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_DEVICE);
+    }
+
+    if (_gProcMsTouchScreenMsg20xxEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_MS_TOUCHSCREEN_MSG20XX, _gProcClassEntry);
+        _gProcMsTouchScreenMsg20xxEntry = NULL;    		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_MS_TOUCHSCREEN_MSG20XX);
+    }
+
+    if (_gProcClassEntry != NULL)
+    {
+        remove_proc_entry(PROC_NODE_CLASS, NULL);
+        _gProcClassEntry = NULL;    		
+        DBG(&g_I2cClient->dev, "Remove procfs file node(%s) OK!\n", PROC_NODE_CLASS);
+    }
+}
+
+/*=============================================================*/
+// LOCAL FUNCTION DEFINITION
+/*=============================================================*/
+
+static s32 _DrvMainCreateProcfsDirEntry(void)
+{
+    s32 nRetVal = 0;
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+    u8 *pGesturePath = NULL;
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+    u8 *pDevicePath = NULL;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    _gProcClassEntry = proc_mkdir(PROC_NODE_CLASS, NULL);
+
+    _gProcMsTouchScreenMsg20xxEntry = proc_mkdir(PROC_NODE_MS_TOUCHSCREEN_MSG20XX, _gProcClassEntry);
+
+    _gProcDeviceEntry = proc_mkdir(PROC_NODE_DEVICE, _gProcMsTouchScreenMsg20xxEntry);
+
+    _gProcChipTypeEntry = proc_create(PROC_NODE_CHIP_TYPE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcChipType);
+    if (NULL == _gProcChipTypeEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_CHIP_TYPE);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_CHIP_TYPE);
+    }
+
+    _gProcFirmwareDataEntry = proc_create(PROC_NODE_FIRMWARE_DATA, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcFirmwareData);
+    if (NULL == _gProcFirmwareDataEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_FIRMWARE_DATA);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_DATA);
+    }
+
+    _gProcApkFirmwareUpdateEntry = proc_create(PROC_NODE_FIRMWARE_UPDATE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcApkFirmwareUpdate);
+    if (NULL == _gProcApkFirmwareUpdateEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_FIRMWARE_UPDATE);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_UPDATE);
+    }
+
+    _gProcCustomerFirmwareVersionEntry = proc_create(PROC_NODE_CUSTOMER_FIRMWARE_VERSION, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcCustomerFirmwareVersion);
+    if (NULL == _gProcCustomerFirmwareVersionEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_CUSTOMER_FIRMWARE_VERSION);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_CUSTOMER_FIRMWARE_VERSION);
+    }
+
+    _gProcPlatformFirmwareVersionEntry = proc_create(PROC_NODE_PLATFORM_FIRMWARE_VERSION, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcPlatformFirmwareVersion);
+    if (NULL == _gProcPlatformFirmwareVersionEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_PLATFORM_FIRMWARE_VERSION);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_PLATFORM_FIRMWARE_VERSION);
+    }
+
+    _gProcDeviceDriverVersionEntry = proc_create(PROC_NODE_DEVICE_DRIVER_VERSION, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcDeviceDriverVersion);
+    if (NULL == _gProcDeviceDriverVersionEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_DEVICE_DRIVER_VERSION);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_DEVICE_DRIVER_VERSION);
+    }
+
+    _gProcSdCardFirmwareUpdateEntry = proc_create(PROC_NODE_SD_CARD_FIRMWARE_UPDATE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcSdCardFirmwareUpdate);
+    if (NULL == _gProcSdCardFirmwareUpdateEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_SD_CARD_FIRMWARE_UPDATE);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_SD_CARD_FIRMWARE_UPDATE);
+    }
+
+    _gProcFirmwareDebugEntry = proc_create(PROC_NODE_FIRMWARE_DEBUG, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcFirmwareDebug);
+    if (NULL == _gProcFirmwareDebugEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_FIRMWARE_DEBUG);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_DEBUG);
+    }
+
+    _gProcFirmwareSetDebugValueEntry = proc_create(PROC_NODE_FIRMWARE_SET_DEBUG_VALUE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcFirmwareSetDebugValue);
+    if (NULL == _gProcFirmwareSetDebugValueEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_FIRMWARE_SET_DEBUG_VALUE);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_SET_DEBUG_VALUE);
+    }
+
+    _gProcFirmwareSmBusDebugEntry = proc_create(PROC_NODE_FIRMWARE_SMBUS_DEBUG, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcFirmwareSmBusDebug);
+    if (NULL == _gProcFirmwareSmBusDebugEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_FIRMWARE_SMBUS_DEBUG);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_SMBUS_DEBUG);
+    }
+
+    _gProcFirmwareSetDQMemValueEntry = proc_create(PROC_NODE_FIRMWARE_SET_DQMEM_VALUE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcFirmwareSetDQMemValue);
+    if (NULL == _gProcFirmwareSetDQMemValueEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_FIRMWARE_SET_DQMEM_VALUE);
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_SET_DQMEM_VALUE);
+    }
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+    _gProcMpTestEntry = proc_create(PROC_NODE_MP_TEST, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcMpTest);
+    if (NULL == _gProcMpTestEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_MP_TEST);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_MP_TEST);
+    }
+
+    _gProcMpTestLogEntry = proc_create(PROC_NODE_MP_TEST_LOG, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcMpTestLog);
+    if (NULL == _gProcMpTestLogEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_MP_TEST_LOG);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_MP_TEST_LOG);
+    }
+
+    _gProcMpTestFailChannelEntry = proc_create(PROC_NODE_MP_TEST_FAIL_CHANNEL, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcMpTestFailChannel);
+    if (NULL == _gProcMpTestFailChannelEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_MP_TEST_FAIL_CHANNEL);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_MP_TEST_FAIL_CHANNEL);
+    }
+
+    _gProcMpTestScopeEntry = proc_create(PROC_NODE_MP_TEST_SCOPE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcMpTestScope);
+    if (NULL == _gProcMpTestScopeEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_MP_TEST_SCOPE);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_MP_TEST_SCOPE);
+    }
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+    _gProcFirmwareModeEntry = proc_create(PROC_NODE_FIRMWARE_MODE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcFirmwareMode);
+    if (NULL == _gProcFirmwareModeEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_FIRMWARE_MODE);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_MODE);
+    }
+
+    _gProcFirmwareSensorEntry = proc_create(PROC_NODE_FIRMWARE_SENSOR, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcFirmwareSensor);
+    if (NULL == _gProcFirmwareSensorEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_FIRMWARE_SENSOR);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_SENSOR);
+    }
+
+    _gProcFirmwarePacketHeaderEntry = proc_create(PROC_NODE_FIRMWARE_PACKET_HEADER, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcFirmwarePacketHeader);
+    if (NULL == _gProcFirmwarePacketHeaderEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_FIRMWARE_PACKET_HEADER);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_FIRMWARE_PACKET_HEADER);
+    }
+
+    /* create a kset with the name of "kset_example" which is located under /sys/kernel/ */
+    g_TouchKSet = kset_create_and_add("kset_example", NULL, kernel_kobj);
+    if (!g_TouchKSet)
+    {
+        DBG(&g_I2cClient->dev, "*** kset_create_and_add() failed, nRetVal = %d ***\n", nRetVal);
+
+        nRetVal = -ENOMEM;
+    }
+
+    g_TouchKObj = kobject_create();
+    if (!g_TouchKObj)
+    {
+        DBG(&g_I2cClient->dev, "*** kobject_create() failed, nRetVal = %d ***\n", nRetVal);
+
+        nRetVal = -ENOMEM;
+        kset_unregister(g_TouchKSet);
+        g_TouchKSet = NULL;
+    }
+
+    g_TouchKObj->kset = g_TouchKSet;
+
+    nRetVal = kobject_add(g_TouchKObj, NULL, "%s", "kobject_example");
+    if (nRetVal != 0)
+    {
+        DBG(&g_I2cClient->dev, "*** kobject_add() failed, nRetVal = %d ***\n", nRetVal);
+
+        kobject_put(g_TouchKObj);
+        g_TouchKObj = NULL;
+        kset_unregister(g_TouchKSet);
+        g_TouchKSet = NULL;
+    }
+    
+    /* create the files associated with this kobject */
+    nRetVal = sysfs_create_group(g_TouchKObj, &attr_group);
+    if (nRetVal != 0)
+    {
+        DBG(&g_I2cClient->dev, "*** sysfs_create_file() failed, nRetVal = %d ***\n", nRetVal);
+
+        kobject_put(g_TouchKObj);
+        g_TouchKObj = NULL;
+        kset_unregister(g_TouchKSet);
+        g_TouchKSet = NULL;
+    }
+    
+    pDevicePath = kobject_get_path(g_TouchKObj, GFP_KERNEL);
+    DBG(&g_I2cClient->dev, "DEVPATH = %s\n", pDevicePath);
+
+
+    _gProcQueryFeatureSupportStatusEntry = proc_create(PROC_NODE_QUERY_FEATURE_SUPPORT_STATUS, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcQueryFeatureSupportStatus);
+    if (NULL == _gProcQueryFeatureSupportStatusEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_QUERY_FEATURE_SUPPORT_STATUS);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_QUERY_FEATURE_SUPPORT_STATUS);
+    }
+    
+    _gProcChangeFeatureSupportStatusEntry = proc_create(PROC_NODE_CHANGE_FEATURE_SUPPORT_STATUS, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcChangeFeatureSupportStatus);
+    if (NULL == _gProcChangeFeatureSupportStatusEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_CHANGE_FEATURE_SUPPORT_STATUS);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_CHANGE_FEATURE_SUPPORT_STATUS);
+    }
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    _gProcGestureWakeupModeEntry = proc_create(PROC_NODE_GESTURE_WAKEUP_MODE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcGestureWakeupMode);
+    if (NULL == _gProcGestureWakeupModeEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_GESTURE_WAKEUP_MODE);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_GESTURE_WAKEUP_MODE);
+    }
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+    _gProcGestureDebugModeEntry = proc_create(PROC_NODE_GESTURE_DEBUG_MODE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcGestureDebugMode);
+    if (NULL == _gProcGestureDebugModeEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_GESTURE_DEBUG_MODE);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_GESTURE_DEBUG_MODE);
+    }
+
+    /* create a kset with the name of "kset_gesture" which is located under /sys/kernel/ */
+    g_GestureKSet = kset_create_and_add("kset_gesture", NULL, kernel_kobj);
+    if (!g_GestureKSet)
+    {
+        DBG(&g_I2cClient->dev, "*** kset_create_and_add() failed, nRetVal = %d ***\n", nRetVal);
+        nRetVal = -ENOMEM;
+    }
+
+    g_GestureKObj = kobject_create();
+    if (!g_GestureKObj)
+    {
+        DBG(&g_I2cClient->dev, "*** kobject_create() failed, nRetVal = %d ***\n", nRetVal);
+
+        nRetVal = -ENOMEM;
+        kset_unregister(g_GestureKSet);
+        g_GestureKSet = NULL;
+    }
+
+    g_GestureKObj->kset = g_GestureKSet;
+
+    nRetVal = kobject_add(g_GestureKObj, NULL, "%s", "kobject_gesture");
+    if (nRetVal != 0)
+    {
+        DBG(&g_I2cClient->dev, "*** kobject_add() failed, nRetVal = %d ***\n", nRetVal);
+
+        kobject_put(g_GestureKObj);
+        g_GestureKObj = NULL;
+        kset_unregister(g_GestureKSet);
+        g_GestureKSet = NULL;
+    }
+
+    /* create the files associated with this g_GestureKObj */
+    nRetVal = sysfs_create_group(g_GestureKObj, &gestureattr_group);
+    if (nRetVal != 0)
+    {
+        DBG(&g_I2cClient->dev, "*** sysfs_create_file() failed, nRetVal = %d ***\n", nRetVal);
+
+        kobject_put(g_GestureKObj);
+        g_GestureKObj = NULL;
+        kset_unregister(g_GestureKSet);
+        g_GestureKSet = NULL;
+    }
+
+    pGesturePath = kobject_get_path(g_GestureKObj, GFP_KERNEL);
+    DBG(&g_I2cClient->dev, "DEVPATH = %s\n", pGesturePath);
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+    _gProcGestureInforModeEntry = proc_create(PROC_NODE_GESTURE_INFORMATION_MODE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcGestureInforMode);
+    if (NULL == _gProcGestureInforModeEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_GESTURE_INFORMATION_MODE);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_GESTURE_INFORMATION_MODE);
+    }
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+    _gProcReportRateEntry = proc_create(PROC_NODE_REPORT_RATE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcReportRate);
+    if (NULL == _gProcReportRateEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_REPORT_RATE);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_REPORT_RATE);
+    }
+#endif //CONFIG_ENABLE_COUNT_REPORT_RATE
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+    _gProcGloveModeEntry = proc_create(PROC_NODE_GLOVE_MODE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcGloveMode);
+    if (NULL == _gProcGloveModeEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_GLOVE_MODE);
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_GLOVE_MODE);
+    }
+
+    _gProcOpenGloveModeEntry = proc_create(PROC_NODE_OPEN_GLOVE_MODE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcOpenGloveMode);
+    if (NULL == _gProcOpenGloveModeEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_OPEN_GLOVE_MODE);
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_OPEN_GLOVE_MODE);
+    }
+
+    _gProcCloseGloveModeEntry = proc_create(PROC_NODE_CLOSE_GLOVE_MODE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcCloseGloveMode);
+    if (NULL == _gProcCloseGloveModeEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_CLOSE_GLOVE_MODE);
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_CLOSE_GLOVE_MODE);
+    }
+#endif //CONFIG_ENABLE_GLOVE_MODE
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+    _gProcJniMethodEntry = proc_create(PROC_NODE_JNI_NODE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcJniMethod);
+    if (NULL == _gProcJniMethodEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_JNI_NODE);
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_JNI_NODE);
+    }
+#endif //CONFIG_ENABLE_JNI_INTERFACE
+
+    _gProcSeLinuxLimitFirmwareUpdateEntry = proc_create(PROC_NODE_SELINUX_LIMIT_FIRMWARE_UPDATE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcSeLinuxLimitFirmwareUpdate);
+    if (NULL == _gProcSeLinuxLimitFirmwareUpdateEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_SELINUX_LIMIT_FIRMWARE_UPDATE);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_SELINUX_LIMIT_FIRMWARE_UPDATE);
+    }
+
+    _gProcForceFirmwareUpdateEntry = proc_create(PROC_NODE_FORCE_FIRMWARE_UPDATE, PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcForceFirmwareUpdate);
+    if (NULL == _gProcForceFirmwareUpdateEntry)
+    {
+        DBG(&g_I2cClient->dev, "Failed to create procfs file node(%s)!\n", PROC_NODE_FORCE_FIRMWARE_UPDATE);
+    }   
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Create procfs file node(%s) OK!\n", PROC_NODE_FORCE_FIRMWARE_UPDATE);
+    }
+
+    return nRetVal;
+}
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+//register hotknot ioctl handler
+static s32 _DrvMainHotknotRegistry(void)
+{
+    s32 nRetVal = 0;
+
+    nRetVal = misc_register( &hotknot_miscdevice );
+    if ( nRetVal < 0 )
+    {
+        DBG(&g_I2cClient->dev,  "Failed to register misc device. Err:%d\n", nRetVal );
+    }
+    DBG(&g_I2cClient->dev,  "*** Misc device registered ***\n" );
+
+    nRetVal = sysfs_create_group( &hotknot_miscdevice.this_device->kobj, &hotknot_attr_group );
+    if ( nRetVal < 0 )
+    {
+        DBG(&g_I2cClient->dev,  "Failed to create attribute group. Err:%d\n", nRetVal );    
+        //misc_deregister( &hotknot_miscdevice );
+    }
+    DBG(&g_I2cClient->dev,  "*** Attribute group created ***\n" );
+
+    mutex_init(&g_HKMutex);
+    mutex_init(&g_QMutex);     
+    CreateQueue();        
+    CreateHotKnotMem();
+
+    return nRetVal;    
+}
+#endif //CONFIG_ENABLE_HOTKNOT
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_ic_fw_porting_layer.c
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_ic_fw_porting_layer.c	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_ic_fw_porting_layer.c	(revision 166572)
@@ -0,0 +1,310 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_ic_fw_porting_layer.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+ 
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_ic_fw_porting_layer.h"
+
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+extern struct i2c_client *g_I2cClient;
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern u32 g_GestureWakeupMode[2];
+extern u8 g_GestureWakeupFlag;
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+void DrvIcFwLyrVariableInitialize(void)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlVariableInitialize();
+}
+
+void DrvIcFwLyrOptimizeCurrentConsumption(void)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlOptimizeCurrentConsumption();
+}
+
+u8 DrvIcFwLyrGetChipType(void)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return DrvFwCtrlGetChipType();
+}
+
+void DrvIcFwLyrGetCustomerFirmwareVersion(u16 *pMajor, u16 *pMinor, u8 **ppVersion)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlGetCustomerFirmwareVersion(pMajor, pMinor, ppVersion);
+}
+
+void DrvIcFwLyrGetPlatformFirmwareVersion(u8 **ppVersion)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlGetPlatformFirmwareVersion(ppVersion);
+}
+
+s32 DrvIcFwLyrUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return DrvFwCtrlUpdateFirmware(szFwData, eEmemType);
+}	
+
+s32 DrvIcFwLyrUpdateFirmwareBySdCard(const char *pFilePath)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return DrvFwCtrlUpdateFirmwareBySdCard(pFilePath);
+}
+
+u32 DrvIcFwLyrIsRegisterFingerTouchInterruptHandler(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return 1; // Indicate that it is necessary to register interrupt handler with GPIO INT pin when firmware is running on IC
+}
+
+void DrvIcFwLyrHandleFingerTouch(u8 *pPacket, u16 nLength)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlHandleFingerTouch();
+}
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+void DrvIcFwLyrOpenGestureWakeup(u32 *pWakeupMode)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlOpenGestureWakeup(pWakeupMode);
+}	
+
+void DrvIcFwLyrCloseGestureWakeup(void)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlCloseGestureWakeup();
+}	
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+void DrvIcFwLyrOpenGestureDebugMode(u8 nGestureFlag)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlOpenGestureDebugMode(nGestureFlag);
+}
+
+void DrvIcFwLyrCloseGestureDebugMode(void)
+{
+//	  DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlCloseGestureDebugMode();
+}
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+u32 DrvIcFwLyrReadDQMemValue(u16 nAddr)
+{
+//	  DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return DrvFwCtrlReadDQMemValue(nAddr);
+}
+
+void DrvIcFwLyrWriteDQMemValue(u16 nAddr, u32 nData)
+{
+//	  DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlWriteDQMemValue(nAddr, nData);
+}
+
+//------------------------------------------------------------------------------//
+
+u16 DrvIcFwLyrGetFirmwareMode(void) // used for MSG26xxM only
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return DrvFwCtrlGetFirmwareMode();
+}
+
+u16 DrvIcFwLyrChangeFirmwareMode(u16 nMode)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return DrvFwCtrlChangeFirmwareMode(nMode); 
+}
+
+void DrvIcFwLyrSelfGetFirmwareInfo(SelfFirmwareInfo_t *pInfo)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlSelfGetFirmwareInfo(pInfo);
+}
+
+void DrvIcFwLyrMutualGetFirmwareInfo(MutualFirmwareInfo_t *pInfo)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlMutualGetFirmwareInfo(pInfo);
+}
+
+void DrvIcFwLyrRestoreFirmwareModeToLogDataMode(void)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlRestoreFirmwareModeToLogDataMode();
+}	
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+void DrvIcFwLyrCheckFirmwareUpdateBySwId(void)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlCheckFirmwareUpdateBySwId();
+}
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG26XXM) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG28XX)
+void DrvIcFwLyrGetMpTestScope(TestScopeInfo_t *pInfo) // for MSG26xxM/MSG28xx
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return DrvMpTestGetTestScope(pInfo);
+}
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM || CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+void DrvIcFwLyrCreateMpTestWorkQueue(void)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+	
+    DrvMpTestCreateMpTestWorkQueue();
+}
+
+void DrvIcFwLyrScheduleMpTestWork(ItoTestMode_e eItoTestMode)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+	
+    DrvMpTestScheduleMpTestWork(eItoTestMode);
+}
+
+s32 DrvIcFwLyrGetMpTestResult(void)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+	
+    return DrvMpTestGetTestResult();
+}
+
+void DrvIcFwLyrGetMpTestFailChannel(ItoTestMode_e eItoTestMode, u8 *pFailChannel, u32 *pFailChannelCount)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+	
+    return DrvMpTestGetTestFailChannel(eItoTestMode, pFailChannel, pFailChannelCount);
+}
+
+void DrvIcFwLyrGetMpTestDataLog(ItoTestMode_e eItoTestMode, u8 *pDataLog, u32 *pLength)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return DrvMpTestGetTestDataLog(eItoTestMode, pDataLog, pLength);
+}
+#endif //CONFIG_ENABLE_ITO_MP_TEST		
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+void DrvIcFwLyrGetTouchPacketAddress(u16 *pDataAddress, u16 *pFlagAddress)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return DrvFwCtrlGetTouchPacketAddress(pDataAddress, pFlagAddress);
+}
+#endif //CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+s32 DrvIcFwLyrEnableProximity(void)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return DrvFwCtrlEnableProximity();
+}
+
+s32 DrvIcFwLyrDisableProximity(void)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return DrvFwCtrlDisableProximity();
+}
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+void DrvIcFwLyrOpenGloveMode(void)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlOpenGloveMode();
+}
+
+void DrvIcFwLyrCloseGloveMode(void)
+{
+//	  DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    DrvFwCtrlCloseGloveMode();
+}
+
+void DrvIcFwLyrGetGloveInfo(u8 *pGloveMode)
+{
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvFwCtrlGetGloveInfo(pGloveMode);
+}
+#endif //CONFIG_ENABLE_GLOVE_MODE
+//------------------------------------------------------------------------------//
+
+
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_hotknot.c
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_hotknot.c	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_hotknot.c	(revision 166572)
@@ -0,0 +1,874 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_hotknot.c
+ *
+ * @brief   This file defines the hotknot functions
+ *
+ *
+ */
+
+////////////////////////////////////////////////////////////
+/// Included Files
+////////////////////////////////////////////////////////////
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kthread.h>
+#include <asm/uaccess.h>
+#include "mstar_drv_hotknot.h"
+#include "mstar_drv_utility_adaption.h"
+#include "mstar_drv_hotknot_queue.h"
+#include "mstar_drv_fw_control.h"
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+////////////////////////////////////////////////////////////
+/// Data Types
+////////////////////////////////////////////////////////////
+
+
+/*=============================================================*/
+// GLOBAL VARIABLE DEFINITION
+/*=============================================================*/
+u8 g_HotKnotState;
+struct mutex g_QMutex;    //queue mutex
+
+
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+extern struct mutex g_Mutex;
+extern struct i2c_client *g_I2cClient;
+
+extern u32 SLAVE_I2C_ID_DBBUS;
+extern u32 SLAVE_I2C_ID_DWI2C;
+
+extern u16 FIRMWARE_MODE_UNKNOWN_MODE;
+extern u16 FIRMWARE_MODE_DEMO_MODE;
+extern u16 FIRMWARE_MODE_DEBUG_MODE;
+//extern u16 FIRMWARE_MODE_RAW_DATA_MODE;
+
+extern u16 g_FirmwareMode;
+
+extern u8 IS_FIRMWARE_DATA_LOG_ENABLED;
+
+extern u8 g_IsHotknotEnabled;
+extern u8 g_IsUpdateFirmware;
+extern u8 g_IsBypassHotknot;
+
+
+////////////////////////////////////////////////////////////
+/// LOCAL VARIABLE DEFINITION
+////////////////////////////////////////////////////////////
+DrvCmd_t * _gDrvCmdStack;
+unsigned long  _gArgStack;
+u8 * _gHKPacket; 
+u16  _gHKLength;
+
+static int _gHKFlag = 0;
+static DECLARE_WAIT_QUEUE_HEAD(_gHKWaiter);
+
+#ifdef CONFIG_ENABLE_HOTKNOT_RCV_BLOCKING
+static int _gHKRcvFlag = 0;
+static int _gHKRcvWaitEnable = 0;
+static DECLARE_WAIT_QUEUE_HEAD(_gHKRcvWaiter);
+#endif
+
+static DrvCmd_t * _gCmdIn = NULL;
+static u8 * _gSndData = NULL;
+static u8 * _gRcvData = NULL;
+static u16 * _gFwMode = NULL;
+
+
+////////////////////////////////////////////////////////////
+/// Macro
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Function Prototypes
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Function Implementation
+////////////////////////////////////////////////////////////
+
+u8 _GetCheckSum(u8 *pBuf, int nLen)
+{
+	  s32 nSum = 0;
+      int i;
+	  for(i=0; i < nLen; i++)
+	  {
+	  	  nSum += pBuf[i];
+	  }
+	  return (u8)(-nSum&0xFF);	
+}
+
+
+void _DebugShowArray(u8 *pBuf, u16 nLen)
+{
+    int i;
+
+    for(i=0; i < nLen; i++)
+    {
+        DBG(&g_I2cClient->dev, "%02X ", pBuf[i]);       
+
+        if(i%16==15){  
+            DBG(&g_I2cClient->dev, "\n");
+        }
+    }
+    DBG(&g_I2cClient->dev, "\n");    
+}
+
+
+int PushHotKnotData(u8 * pBuf, u16 nLength)
+{
+    int nQRet;
+    mutex_lock(&g_QMutex);
+    nQRet = PushQueue(pBuf, nLength);
+    mutex_unlock(&g_QMutex);
+    
+    return nQRet;
+}
+
+
+int PopHotKnotData(u8 * pBuf, u16 nLength)
+{
+    int nQRet;
+    mutex_lock(&g_QMutex);
+    nQRet = PopQueue(pBuf, nLength);
+    mutex_unlock(&g_QMutex); 
+    
+    return nQRet;
+}
+
+
+int ShowHotKnotData(u8 * pBuf, u16 nLength)
+{
+    int nQRet;
+    mutex_lock(&g_QMutex);
+    nQRet = ShowQueue(pBuf, nLength);
+    mutex_unlock(&g_QMutex);
+    
+    return nQRet;
+}
+
+
+void _HotKnotRcvInterruptHandler(u8 *pPacket, u16 nLength)    //receive hotknot packet in interrupt 
+{
+    u16 nPacketDataLen = 0;
+    u16 nQPushLen = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if(g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE)
+    { 
+        nPacketDataLen = (((DemoHotKnotRcvRet_t*)pPacket)->nActualDataLen_H << 8) | (((DemoHotKnotRcvRet_t*)pPacket)->nActualDataLen_L & 0xFF);
+        nQPushLen = ((((DemoHotKnotRcvRet_t*)pPacket)->szData)[0]&0x7F) + 1;
+        if(nPacketDataLen >= nQPushLen)
+        {
+            if(PushHotKnotData(((DemoHotKnotRcvRet_t*)pPacket)->szData, nQPushLen)<0)
+            {
+                DBG(&g_I2cClient->dev, "Error: HotKnot# Over push data into queue.");
+            }
+#ifdef CONFIG_ENABLE_HOTKNOT_RCV_BLOCKING
+            else
+            {
+                if(_gHKRcvWaitEnable == 1)
+                {
+                    _gHKRcvFlag = 1;    
+                    DBG(&g_I2cClient->dev, "*** wait up receive_wait. ***\n");                                        
+                    wake_up_interruptible(&_gHKRcvWaiter);
+                }
+            }
+#endif //CONFIG_ENABLE_HOTKNOT_RCV_BLOCKING   
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "Error: HotKnot# Receive data error.");
+        }        
+    }
+    else if(IS_FIRMWARE_DATA_LOG_ENABLED && (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE))
+    {
+        nPacketDataLen = (((DebugHotKnotRcvRet_t*)pPacket)->nActualDataLen_H << 8) | (((DebugHotKnotRcvRet_t*)pPacket)->nActualDataLen_L & 0xFF);
+        nQPushLen = ((((DemoHotKnotRcvRet_t*)pPacket)->szData)[0]&0x7F) + 1;
+
+        if(nPacketDataLen >= nQPushLen)
+        {        
+            if(PushHotKnotData(((DebugHotKnotRcvRet_t*)pPacket)->szData, nQPushLen)<0)
+            {
+                DBG(&g_I2cClient->dev, "Error: HotKnot# Over push data into queue.");
+            }  
+#ifdef CONFIG_ENABLE_HOTKNOT_RCV_BLOCKING
+            else
+            {
+                if(_gHKRcvWaitEnable == 1)
+                {
+                    _gHKRcvFlag = 1;    
+                    DBG(&g_I2cClient->dev, "*** wait up receive_wait. ***\n");                                        
+                    wake_up_interruptible(&_gHKRcvWaiter);
+                }
+            }
+#endif //CONFIG_ENABLE_HOTKNOT_RCV_BLOCKING                  
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "Error: HotKnot# Receive data error.");
+        }        
+    }
+}
+
+
+void ReportHotKnotCmd(u8 *pPacket, u16 nLength)
+{
+    //DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if(g_HotKnotState == HOTKNOT_TRANS_STATE && pPacket[0] == HOTKNOT_PACKET_ID && pPacket[3] == HOTKNOT_RECEIVE_PACKET_TYPE)
+    { 
+        _HotKnotRcvInterruptHandler(pPacket, nLength);
+    }
+    else if(_gDrvCmdStack!=NULL && _gArgStack!=0)
+    {
+        _gHKPacket = pPacket;
+        _gHKLength = nLength; 
+    
+        _gHKFlag = 1;    
+        wake_up_interruptible(&_gHKWaiter);
+    }    
+}
+
+
+void _HotKnotCmdInterruptHandler(u8 *pPacket, u16 nLength)
+{ 
+    //DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if(_gDrvCmdStack->nCmdId == HOTKNOT_CMD)
+    {        
+        if(g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE)
+        {
+            HotKnotCmd_t *pSnd = (HotKnotCmd_t*)_gDrvCmdStack->pSndData;
+            DemoHotKnotCmdRet_t *pRcv = (DemoHotKnotCmdRet_t*)pPacket;
+            if(pRcv->nHeader == DEMO_PD_PACKET_ID && pSnd->nInstruction == pRcv->nInstruction)
+            {                 
+                if(pRcv->nResult == RESULT_OK)
+                {
+                    if(pRcv->nInstruction == READ_PAIR_STATE)
+                    {
+                        g_HotKnotState = HOTKNOT_BEFORE_TRANS_STATE;
+                        ClearQueue();
+                    }                       
+                    else if(pRcv->nInstruction == ENTER_TRANSFER_MODE)
+                    {
+                        g_HotKnotState = HOTKNOT_TRANS_STATE;
+                    }
+                    else if(pRcv->nInstruction == EXIT_TRANSFER_MODE)
+                    {
+                        g_HotKnotState = HOTKNOT_AFTER_TRANS_STATE;
+                    }                      
+                    else if(pRcv->nInstruction == ENTER_SLAVE_MODE)
+                    {
+                        g_HotKnotState = HOTKNOT_NOT_TRANS_STATE;
+                    }           	    	
+
+                    if(pRcv->nInstruction == ENABLE_HOTKNOT || pRcv->nInstruction == ENTER_MASTER_MODE || pRcv->nInstruction == ENTER_SLAVE_MODE)
+                    {
+                        g_IsHotknotEnabled = 1;
+                        DBG(&g_I2cClient->dev, "*** g_IsHotknotEnabled = %d ***\n", g_IsHotknotEnabled);
+                    }                       
+                    else if(pRcv->nInstruction == DISABLE_HOTKNOT)
+                    {
+                        g_IsHotknotEnabled = 0;
+                        DBG(&g_I2cClient->dev, "*** g_IsHotknotEnabled = %d ***\n", g_IsHotknotEnabled);                        
+                    }                    
+                }
+                                        
+                memcpy(_gDrvCmdStack->pRcvData, pPacket, nLength);
+                //_gDrvCmdStack->nRcvLen = nLength;
+                *(_gDrvCmdStack->pFwMode) = FIRMWARE_MODE_DEMO_MODE;             
+            }
+        }
+        else if(IS_FIRMWARE_DATA_LOG_ENABLED && (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE))
+        {
+            HotKnotCmd_t *pSnd = (HotKnotCmd_t*)_gDrvCmdStack->pSndData;
+            DebugHotKnotCmdRet_t *pRcv = (DebugHotKnotCmdRet_t*)pPacket;
+            if(pRcv->nHeader == HOTKNOT_PACKET_ID && pSnd->nInstruction == pRcv->nInstruction)
+            {
+                if(pRcv->nResult == RESULT_OK)
+                {
+                    if(pRcv->nInstruction == READ_PAIR_STATE)
+                    {
+                        g_HotKnotState = HOTKNOT_BEFORE_TRANS_STATE;
+                        ClearQueue();
+                    }                       
+                    else if(pRcv->nInstruction == ENTER_TRANSFER_MODE)
+                    {
+                        g_HotKnotState = HOTKNOT_TRANS_STATE;
+                    }
+                    else if(pRcv->nInstruction == EXIT_TRANSFER_MODE)
+                    {
+                        g_HotKnotState = HOTKNOT_AFTER_TRANS_STATE;
+                    }                      
+                    else if(pRcv->nInstruction == ENTER_SLAVE_MODE)
+                    {
+                        g_HotKnotState = HOTKNOT_NOT_TRANS_STATE;
+                    }        	    	
+
+                    if(pRcv->nInstruction == ENABLE_HOTKNOT || pRcv->nInstruction == ENTER_MASTER_MODE || pRcv->nInstruction == ENTER_SLAVE_MODE)
+                    {
+                        g_IsHotknotEnabled = 1;
+                        DBG(&g_I2cClient->dev, "*** g_IsHotknotEnabled = %d ***\n", g_IsHotknotEnabled);
+                    }                       
+                    else if(pRcv->nInstruction == DISABLE_HOTKNOT)
+                    {
+                        g_IsHotknotEnabled = 0;
+                        DBG(&g_I2cClient->dev, "*** g_IsHotknotEnabled = %d ***\n", g_IsHotknotEnabled);                        
+                    }                     
+                }
+                                       
+                memcpy(_gDrvCmdStack->pRcvData, pPacket, nLength);
+		        //_gDrvCmdStack->nRcvLen = nLength;
+                *(_gDrvCmdStack->pFwMode) = FIRMWARE_MODE_DEBUG_MODE;   
+            }
+        }
+    }
+    else if(_gDrvCmdStack->nCmdId == HOTKNOT_SEND)
+    {
+        if(g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE)
+        {
+            HotKnotSnd_t *pSnd = (HotKnotSnd_t*)_gDrvCmdStack->pSndData;
+            DemoHotKnotSndRet_t *pRcv = (DemoHotKnotSndRet_t*)pPacket;
+            if(pRcv->nHeader == HOTKNOT_PACKET_ID && pRcv->nType == HOTKNOT_PACKET_TYPE && pSnd->nInstruction == pRcv->nInstruction)
+            {
+                //kthread_stop(_gHotKnotTask);                        
+                memcpy(_gDrvCmdStack->pRcvData, pPacket, nLength);
+		        //_gDrvCmdStack->nRcvLen = nLength;
+                *(_gDrvCmdStack->pFwMode) = FIRMWARE_MODE_DEMO_MODE;                         
+            } 
+        }
+        else if(IS_FIRMWARE_DATA_LOG_ENABLED && (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE))
+        {
+            HotKnotSnd_t *pSnd = (HotKnotSnd_t*)_gDrvCmdStack->pSndData;
+            DebugHotKnotSndRet_t *pRcv = (DebugHotKnotSndRet_t*)pPacket;
+            if(pRcv->nHeader == HOTKNOT_PACKET_ID && pRcv->nType == HOTKNOT_PACKET_TYPE && pSnd->nInstruction == pRcv->nInstruction)
+            {
+                //kthread_stop(_gHotKnotTask);                        
+                memcpy(_gDrvCmdStack->pRcvData, pPacket, nLength);
+		        //_gDrvCmdStack->nRcvLen = nLength;
+                *(_gDrvCmdStack->pFwMode) = FIRMWARE_MODE_DEBUG_MODE;                        
+            } 
+        }
+    }
+}
+
+
+void _HotKnotTimeOutHandler(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    //handle timeout case              
+    if(_gDrvCmdStack->nCmdId == HOTKNOT_CMD)
+    {        
+        if(g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE)
+        {
+            HotKnotSnd_t *pSnd = (HotKnotSnd_t*)_gDrvCmdStack->pSndData;
+            DemoHotKnotCmdRet_t *pRcv = (DemoHotKnotCmdRet_t*)_gDrvCmdStack->pRcvData;                
+            memset(pRcv, 0xFF, DEMO_PD_PACKET_RET_LEN);
+            pRcv->nHeader = DEMO_PD_PACKET_ID;
+            pRcv->nInstruction = pSnd->nInstruction;
+            pRcv->nResult = RESULT_TIMEOUT;                                        
+            pRcv->nIdentify = DEMO_PD_PACKET_IDENTIFY;                
+            pRcv->nCheckSum = _GetCheckSum((u8*)pRcv, DEMO_PD_PACKET_RET_LEN-1);
+            //_gDrvCmdStack->nRcvLen = DEMO_PD_PACKET_RET_LEN;
+            *(_gDrvCmdStack->pFwMode) = FIRMWARE_MODE_DEMO_MODE;
+        }
+        else if(IS_FIRMWARE_DATA_LOG_ENABLED && (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE))
+        {
+            HotKnotSnd_t *pSnd = (HotKnotSnd_t*)_gDrvCmdStack->pSndData;
+            DebugHotKnotCmdRet_t *pRcv = (DebugHotKnotCmdRet_t*)_gDrvCmdStack->pRcvData;                
+            memset(_gDrvCmdStack->pRcvData, 0xFF, MAX_PD_PACKET_RET_LEN);
+            pRcv->nHeader = HOTKNOT_PACKET_ID;
+            pRcv->nPacketLen_H = MAX_PD_PACKET_RET_LEN>>8;                   
+            pRcv->nPacketLen_L = MAX_PD_PACKET_RET_LEN&0xFF;
+            pRcv->nType = HOTKNOT_PACKET_TYPE;                
+            pRcv->nInstruction = pSnd->nInstruction;
+            pRcv->nResult = RESULT_TIMEOUT;
+            _gDrvCmdStack->pRcvData[MAX_PD_PACKET_RET_LEN-1] = _GetCheckSum((u8*)pRcv, MAX_PD_PACKET_RET_LEN-1);
+            //_gDrvCmdStack->nRcvLen = MAX_PD_PACKET_RET_LEN;
+            *(_gDrvCmdStack->pFwMode) = FIRMWARE_MODE_DEBUG_MODE;
+        }            
+    }
+    else if(_gDrvCmdStack->nCmdId == HOTKNOT_SEND)
+    {
+        if(g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE)
+        {
+            HotKnotSnd_t *pSnd = (HotKnotSnd_t*)_gDrvCmdStack->pSndData;
+            DemoHotKnotSndRet_t *pRcv = (DemoHotKnotSndRet_t*)_gDrvCmdStack->pRcvData;                 
+            memset(_gDrvCmdStack->pRcvData, 0, DEMO_HOTKNOT_SEND_RET_LEN);
+            pRcv->nHeader = HOTKNOT_PACKET_ID;
+            pRcv->nPacketLen_H = DEMO_HOTKNOT_SEND_RET_LEN>>8;
+            pRcv->nPacketLen_L = DEMO_HOTKNOT_SEND_RET_LEN&0xFF;
+            pRcv->nType = HOTKNOT_PACKET_TYPE;                                    
+            pRcv->nInstruction = pSnd->nInstruction;
+            pRcv->nResult = RESULT_TIMEOUT;                                        
+            pRcv->nCheckSum = _GetCheckSum((u8*)pRcv, DEMO_HOTKNOT_SEND_RET_LEN-1);
+            //_gDrvCmdStack->nRcvLen = DEMO_HOTKNOT_SEND_RET_LEN;
+            *(_gDrvCmdStack->pFwMode) = FIRMWARE_MODE_DEMO_MODE;
+        }
+        else if(IS_FIRMWARE_DATA_LOG_ENABLED && (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE))
+        {
+            HotKnotSnd_t *pSnd = (HotKnotSnd_t*)_gDrvCmdStack->pSndData;
+            DebugHotKnotSndRet_t *pRcv = (DebugHotKnotSndRet_t*)_gDrvCmdStack->pRcvData;                
+            memset(_gDrvCmdStack->pRcvData, 0, DEBUG_HOTKNOT_SEND_RET_LEN);
+            pRcv->nHeader = HOTKNOT_PACKET_ID;
+            pRcv->nPacketLen_H = DEBUG_HOTKNOT_SEND_RET_LEN>>8;
+            pRcv->nPacketLen_L = DEBUG_HOTKNOT_SEND_RET_LEN&0xFF;
+            pRcv->nType = HOTKNOT_PACKET_TYPE;                                    
+            pRcv->nInstruction = pSnd->nInstruction;
+            pRcv->nResult = RESULT_TIMEOUT;                                        
+            pRcv->nCheckSum = _GetCheckSum((u8*)pRcv, DEBUG_HOTKNOT_SEND_RET_LEN-1);
+            //_gDrvCmdStack->nRcvLen = DEBUG_HOTKNOT_SEND_RET_LEN;
+            *(_gDrvCmdStack->pFwMode) = FIRMWARE_MODE_DEBUG_MODE;
+        }               
+    }
+}
+
+
+int _DrvHandleHotKnotCmd(DrvCmd_t *pCmd, unsigned long nArg)
+{
+    long nRet;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    mutex_lock(&g_Mutex);
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    if (g_IsUpdateFirmware == 0 && g_IsBypassHotknot == 0)
+    {
+        DmaReset();
+    }
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    IicWriteData(SLAVE_I2C_ID_DWI2C, pCmd->pSndData, pCmd->nSndLen);    //send HOTKNOT_CMD to fw 
+
+    mutex_unlock(&g_Mutex);
+
+
+	_gDrvCmdStack = pCmd;
+	_gArgStack = nArg;
+	
+    set_current_state(TASK_INTERRUPTIBLE);  
+    nRet = wait_event_interruptible_timeout(_gHKWaiter, _gHKFlag != 0, pCmd->nTimeOut/1000 * HZ);
+    _gHKFlag = 0;
+    
+    if(nRet == 0)
+    {
+        _HotKnotTimeOutHandler();
+    }
+    else
+    {
+        _HotKnotCmdInterruptHandler(_gHKPacket, _gHKLength);    
+    }
+    
+    return 0;
+}
+
+
+void _DrvHandleHotKnotAuth(DrvCmd_t *pCmd)
+{    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    mutex_lock(&g_Mutex);
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    if (g_IsUpdateFirmware == 0 && g_IsBypassHotknot == 0)
+    {
+        DmaReset();
+    }
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    //for(i=0; i < pCmd->nSndLen; i++)
+    //{
+    //    DBG(&g_I2cClient->dev, "%02X ", pCmd->pSndData[i]); 
+    //}
+    
+    IicWriteData(SLAVE_I2C_ID_DWI2C, pCmd->pSndData, pCmd->nSndLen);
+    mdelay(20);
+    IicReadData(SLAVE_I2C_ID_DWI2C, pCmd->pRcvData, pCmd->nRcvLen);
+
+    //for(i=0; i < pCmd->nRcvLen; i++)
+    //{
+    //    DBG(&g_I2cClient->dev, "%02X ", pCmd->pRcvData[i]); 
+    //}    
+
+    mutex_unlock(&g_Mutex);
+}
+
+
+#ifdef CONFIG_ENABLE_HOTKNOT_RCV_BLOCKING
+void _DrvHandleHotKnotRcv(DrvCmd_t *pCmd)
+{
+    u8 nQueueData;
+    int nDataLen = -1;
+    long nRet;    
+    DemoHotKnotLibRcvRet_t *pRcv = NULL;  
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    pCmd->nRcvLen = DEMO_HOTKNOT_RECEIVE_RET_LEN;
+    pRcv = (DemoHotKnotLibRcvRet_t*)pCmd->pRcvData;  
+    memset(pRcv, 0, DEMO_HOTKNOT_RECEIVE_RET_LEN);
+    pRcv->nHeader = RECEIVE_DATA; 
+
+    if(ShowHotKnotData(&nQueueData, 1) <= 0)    //check how many bytes to fetch
+    {
+        DBG(&g_I2cClient->dev, "ShowHotKnotData: No hotknot data in first check.\n");
+    }
+    else
+    {
+        nDataLen = PopHotKnotData(pRcv->szData, (nQueueData&0x7F) + 1);
+    }
+    
+    if(nDataLen > 0)
+    {
+        pRcv->nActualHotKnotLen_H = nDataLen>>8;  
+        pRcv->nActualHotKnotLen_L = nDataLen&0xFF;         
+        pRcv->nCheckSum = _GetCheckSum((u8*)pRcv, DEMO_HOTKNOT_RECEIVE_RET_LEN-1);        
+        return;
+    }
+
+    _gHKRcvWaitEnable = 1;    //in wait status
+    DBG(&g_I2cClient->dev, "*** _gHKRcvWaitEnable = 1, receive_timeout = %d***\n", pCmd->nTimeOut * HZ/1000);    
+    set_current_state(TASK_INTERRUPTIBLE);  
+    nRet = wait_event_interruptible_timeout(_gHKRcvWaiter, _gHKRcvFlag != 0, pCmd->nTimeOut * HZ/1000);
+    _gHKRcvWaitEnable = 0;    //no wait
+    DBG(&g_I2cClient->dev, "*** _gHKRcvWaitEnable = 0 ***\n");        
+    _gHKRcvFlag = 0;
+
+
+    if(nRet == 0)    //timeout
+    {
+        DBG(&g_I2cClient->dev, "*** receive_timeout ***\n");     
+        pRcv->nActualHotKnotLen_H = 0;  
+        pRcv->nActualHotKnotLen_L = 0;          
+        pRcv->nCheckSum = _GetCheckSum((u8*)pRcv, DEMO_HOTKNOT_RECEIVE_RET_LEN-1);
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "*** receive_get_data ***\n");     
+        int nDataLen = -1;    
+        if(ShowHotKnotData(&nQueueData, 1) <= 0)    //check how many bytes to fetch
+        {
+            DBG(&g_I2cClient->dev, "ShowHotKnotData: No hotknot data\n");
+        }
+        else
+        {
+            nDataLen = PopHotKnotData(pRcv->szData, (nQueueData&0x7F) + 1);
+        }
+    
+        if(nDataLen < 0)
+        {
+            pRcv->nActualHotKnotLen_H = 0;  
+            pRcv->nActualHotKnotLen_L = 0;    		
+        }
+        else
+        {
+            pRcv->nActualHotKnotLen_H = nDataLen>>8;  
+            pRcv->nActualHotKnotLen_L = nDataLen&0xFF;         
+        }
+        pRcv->nCheckSum = _GetCheckSum((u8*)pRcv, DEMO_HOTKNOT_RECEIVE_RET_LEN-1); 
+    }    
+}
+#else
+void _DrvHandleHotKnotRcv(DrvCmd_t *pCmd)
+{
+    u8 nQueueData;
+    int nDataLen = -1;
+    DemoHotKnotLibRcvRet_t *pRcv = NULL;  
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    pCmd->nRcvLen = DEMO_HOTKNOT_RECEIVE_RET_LEN;
+    pRcv = (DemoHotKnotLibRcvRet_t*)pCmd->pRcvData;  
+    memset(pRcv, 0, DEMO_HOTKNOT_RECEIVE_RET_LEN);
+    pRcv->nHeader = RECEIVE_DATA; 
+
+    if(ShowHotKnotData(&nQueueData, 1) <= 0)    //check how many bytes to fetch
+    {
+        DBG(&g_I2cClient->dev, "ShowHotKnotData: No hotknot data\n");
+    }
+    else
+    {
+        nDataLen = PopHotKnotData(pRcv->szData, (nQueueData&0x7F) + 1);
+    }
+    
+    if(nDataLen < 0)
+    {
+        pRcv->nActualHotKnotLen_H = 0;  
+        pRcv->nActualHotKnotLen_L = 0;    		
+    }
+    else
+    {
+        pRcv->nActualHotKnotLen_H = nDataLen>>8;  
+        pRcv->nActualHotKnotLen_L = nDataLen&0xFF;         
+    }
+    pRcv->nCheckSum = _GetCheckSum((u8*)pRcv, DEMO_HOTKNOT_RECEIVE_RET_LEN-1);
+}
+#endif
+
+
+void _DrvHandleHotKnotGetQueue(DrvCmd_t *pCmd)
+{
+    DemoHotKnotGetQRet_t *pRcv = NULL;  
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    pCmd->nRcvLen = HOTKNOT_QUEUE_SIZE+6;
+    pRcv = (DemoHotKnotGetQRet_t*)pCmd->pRcvData;  
+    memset(pRcv, 0, HOTKNOT_QUEUE_SIZE+6);
+    pRcv->nHeader = GET_QUEUE; 
+    ShowAllQueue(pRcv->szData, &(pRcv->nFront), &(pRcv->nRear));
+    pRcv->nCheckSum = _GetCheckSum((u8*)pRcv, HOTKNOT_QUEUE_SIZE+5);
+}
+
+
+void _DrvHandleHotKnotSndTest(DrvCmd_t *pCmd)
+{
+    u16 nQPushLen = 0;
+    HotKnotSnd_t *pSnd = NULL;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+  
+    pSnd = (HotKnotSnd_t*)pCmd->pSndData;
+    nQPushLen = (pSnd->nDataLen_H << 8) | (pSnd->nDataLen_L & 0xFF);
+
+    DBG(&g_I2cClient->dev, "nQPushLen = %d\n", nQPushLen);
+    if(PushHotKnotData(pSnd->szData, nQPushLen)<0)
+    {
+        DBG(&g_I2cClient->dev, "Error: HotKnot# Over push data into queue.");
+    }  
+
+    //u8 * pShowArray = (u8*)kmalloc(sizeof(u8)* 256, GFP_KERNEL );
+    //ShowHotKnotData(pShowArray, 256);    //check queue data
+    //_DebugShowArray(pShowArray, 256);
+    //kfree(pShowArray);
+}
+
+
+/*
+static DrvCmd_t* _TransCmdFromUser( unsigned long nArg )
+{
+    long nRet; 
+    DrvCmd_t tCmdIn;
+    DrvCmd_t *pTransCmd = (DrvCmd_t*)kmalloc( sizeof( DrvCmd_t ), GFP_KERNEL );
+
+    nRet = copy_from_user( &tCmdIn, (void*)nArg, sizeof( DrvCmd_t ) );
+    pTransCmd->nCmdId = tCmdIn.nCmdId;
+	
+    pTransCmd->nSndLen = tCmdIn.nSndLen;
+	pTransCmd->pSndData = (u8*)kmalloc(sizeof(u8)*pTransCmd->nSndLen, GFP_KERNEL );	
+    nRet = copy_from_user( pTransCmd->pSndData, tCmdIn.pSndData, pTransCmd->nSndLen );    	
+
+	pTransCmd->nRcvLen = tCmdIn.nRcvLen;
+	pTransCmd->pRcvData = (u8*)kmalloc(sizeof(u8)*pTransCmd->nRcvLen, GFP_KERNEL );           
+
+	pTransCmd->pFwMode= (u16*)kmalloc(sizeof(u16), GFP_KERNEL );
+	pTransCmd->nTimeOut = tCmdIn.nTimeOut;
+  
+    return pTransCmd;
+}
+
+
+static void _TransCmdToUser( DrvCmd_t *pTransCmd, unsigned long nArg )
+{
+    DrvCmd_t tCmdOut;
+    long nRet;
+    
+    nRet = copy_from_user( &tCmdOut, (void*)nArg, sizeof( DrvCmd_t ) );   	
+    nRet = copy_to_user( tCmdOut.pRcvData, pTransCmd->pRcvData, tCmdOut.nRcvLen);
+    nRet = copy_to_user( tCmdOut.pFwMode, pTransCmd->pFwMode, sizeof(u16));
+    
+    if ( pTransCmd )
+    {
+        kfree( pTransCmd->pSndData );		
+        kfree( pTransCmd->pRcvData );
+        kfree( pTransCmd->pFwMode );		
+        kfree( pTransCmd );
+    }
+}
+*/
+
+
+void _ClearHotKnotMem(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+  
+    memset(_gCmdIn, 0, sizeof( DrvCmd_t ));
+    memset(_gSndData, 0, DEBUG_HOTKNOT_SEND_RET_LEN);
+    memset(_gRcvData, 0, DEBUG_HOTKNOT_RECEIVE_RET_LEN);
+    memset(_gFwMode, 0, sizeof(u16));    
+}
+
+
+static DrvCmd_t* _TransCmdFromUser( unsigned long nArg )
+{
+    long nRet; 
+    DrvCmd_t tCmdIn;    
+    DrvCmd_t *pTransCmd;
+
+    _ClearHotKnotMem();
+    pTransCmd = (DrvCmd_t *)_gCmdIn;    
+    nRet = copy_from_user( &tCmdIn, (void*)nArg, sizeof( DrvCmd_t ) );
+    pTransCmd->nCmdId = tCmdIn.nCmdId;
+	
+    pTransCmd->nSndLen = tCmdIn.nSndLen;
+	pTransCmd->pSndData = _gSndData;
+    nRet = copy_from_user( pTransCmd->pSndData, tCmdIn.pSndData, pTransCmd->nSndLen );    	
+
+	pTransCmd->nRcvLen = tCmdIn.nRcvLen;
+	pTransCmd->pRcvData = _gRcvData;	
+
+	pTransCmd->pFwMode= _gFwMode;	
+	pTransCmd->nTimeOut = tCmdIn.nTimeOut;
+  
+    return pTransCmd;
+}
+
+
+static void _TransCmdToUser( DrvCmd_t *pTransCmd, unsigned long nArg )
+{
+    DrvCmd_t tCmdOut;
+    long nRet;
+    
+    nRet = copy_from_user( &tCmdOut, (void*)nArg, sizeof( DrvCmd_t ) );   	
+    nRet = copy_to_user( tCmdOut.pRcvData, pTransCmd->pRcvData, tCmdOut.nRcvLen);
+    nRet = copy_to_user( tCmdOut.pFwMode, pTransCmd->pFwMode, sizeof(u16));
+}
+
+
+long HotKnotIoctl( struct file *pFile, unsigned int nCmd, unsigned long nArg )
+{
+    long nRet = 0;	
+	
+    switch ( nCmd )
+    {
+        case HOTKNOT_IOCTL_RUN_CMD:
+            {      
+                DrvCmd_t *pTransCmd;			
+
+                DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+                
+                pTransCmd = _TransCmdFromUser( nArg );
+
+                if(pTransCmd->nCmdId == HOTKNOT_CMD ||
+                  (pTransCmd->nCmdId == HOTKNOT_SEND && pTransCmd->pSndData[1] == SEND_DATA))
+                {
+				    _DrvHandleHotKnotCmd(pTransCmd, nArg);
+					_TransCmdToUser(_gDrvCmdStack, _gArgStack);
+      	            _gDrvCmdStack = NULL;
+                    _gArgStack = 0;						
+                } 					            
+                else if(pTransCmd->nCmdId == HOTKNOT_AUTH || 
+                       (pTransCmd->nCmdId == HOTKNOT_SEND && pTransCmd->pSndData[1] == AUTH_WRITECIPHER))
+                {
+				    _DrvHandleHotKnotAuth(pTransCmd);
+				    _TransCmdToUser(pTransCmd, nArg);                   
+                }
+                else if(pTransCmd->nCmdId == HOTKNOT_RECEIVE && pTransCmd->pSndData[1] == RECEIVE_DATA)
+                {
+				    _DrvHandleHotKnotRcv(pTransCmd);
+				    _TransCmdToUser(pTransCmd, nArg); 
+                }
+                else if(pTransCmd->nCmdId == HOTKNOT_RECEIVE && pTransCmd->pSndData[1] == GET_QUEUE)
+                {
+				    _DrvHandleHotKnotGetQueue(pTransCmd);
+				    _TransCmdToUser(pTransCmd, nArg); 
+                }                 
+                else if(pTransCmd->nCmdId == HOTKNOT_SEND && pTransCmd->pSndData[1] == SEND_DATA_TEST)
+                {
+				    _DrvHandleHotKnotSndTest(pTransCmd);						
+                }                
+            }   
+		    break;
+		
+        case HOTKNOT_IOCTL_QUERY_VENDOR:
+            {
+                 char szVendorName[30] = "msg28xx";
+
+                 DBG(&g_I2cClient->dev, "*** Query vendor name! ***\n"); 
+                 //_DebugShowArray(szVendorName,30);
+                 if(copy_to_user((void*)nArg, szVendorName, 30))
+                 {
+                     DBG(&g_I2cClient->dev, "*** Query vendor name failed! ***\n");                      
+                 }
+            }
+            break;
+        
+        default:
+            nRet = -EINVAL;
+            break;
+    }
+
+    return nRet;
+}
+
+
+void CreateHotKnotMem()
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    _gCmdIn = (DrvCmd_t*)kmalloc( sizeof( DrvCmd_t ), GFP_KERNEL );
+	_gSndData = (u8*)kmalloc(DEBUG_HOTKNOT_SEND_RET_LEN, GFP_KERNEL );	
+	_gRcvData = (u8*)kmalloc(DEBUG_HOTKNOT_RECEIVE_RET_LEN, GFP_KERNEL );           
+	_gFwMode= (u16*)kmalloc(sizeof(u16), GFP_KERNEL );
+}
+
+
+void DeleteHotKnotMem()
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+  
+    if (_gCmdIn)
+    {
+        kfree(_gCmdIn);
+        _gCmdIn = NULL;
+    }
+    
+    if (_gSndData)
+    {
+        kfree(_gSndData);
+        _gSndData = NULL;
+    }
+    
+    if (_gRcvData)
+    {
+        kfree(_gRcvData);
+        _gRcvData = NULL;
+    }
+    
+    if (_gFwMode)
+    {
+        kfree(_gFwMode);
+        _gFwMode = NULL;    
+    }
+}
+
+#endif //CONFIG_ENABLE_HOTKNOT)
Index: kernel/drivers/input/touchscreen/msg5846/msg22xx_xxxx_update_bin.h
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/msg22xx_xxxx_update_bin.h	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/msg22xx_xxxx_update_bin.h	(revision 166572)
@@ -0,0 +1,3106 @@
+u8 msg22xx_xxxx_update_bin[49664]={
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xF2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x52,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x36,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x1A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xFD,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xEF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xE1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xD3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xC5,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x1C,0x40,0x00,0x1C,
+0x60,0x00,0x1C,0x80,0x00,0x1C,0xA0,0x00,0x1C,0xC0,0x00,0x1C,0xE0,0x00,0x1D,0x00,
+0x00,0x1D,0x20,0x00,0x1D,0x40,0x00,0x1D,0x60,0x00,0x1D,0x80,0x00,0x1D,0xA0,0x00,
+0x1D,0xC0,0x00,0x1D,0xE0,0x00,0x1E,0x00,0x00,0x1E,0x20,0x00,0x1E,0x40,0x00,0x1E,
+0x60,0x00,0x1E,0x80,0x00,0x1E,0xA0,0x00,0x1E,0xC0,0x00,0x1E,0xE0,0x00,0x1F,0x00,
+0x00,0x1F,0x20,0x00,0x1F,0x40,0x00,0x1F,0x60,0x00,0x1F,0x80,0x00,0x1F,0xA0,0x00,
+0x1F,0xC0,0x00,0x1F,0xE0,0x00,0xC0,0x60,0x00,0x01,0xC8,0x63,0x9F,0xCC,0x84,0x69,
+0x80,0x01,0x90,0x00,0x90,0x00,0x90,0x00,0x90,0x00,0x90,0x00,0x90,0x00,0x90,0x00,
+0xFC,0x21,0xFF,0x60,0xEF,0xE1,0x00,0x80,0xFF,0xE1,0x00,0xA0,0x0F,0xE1,0x08,0xC3,
+0xE0,0x02,0x0F,0x0F,0xE1,0x00,0xC3,0xE0,0x04,0x0F,0x0F,0xE1,0x04,0xC3,0xE0,0x03,
+0x0F,0xEF,0xE1,0x00,0x84,0xC3,0xE0,0x05,0x0F,0xEF,0xE1,0x00,0x88,0xC3,0xE0,0x05,
+0x1F,0xEF,0xE1,0x00,0x8C,0xE4,0x01,0x3A,0xD1,0x90,0x00,0x90,0x00,0x90,0x00,0x90,
+0x00,0x90,0x00,0x90,0x00,0x90,0x00,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x30,0x44,0x0B,
+0x17,0x01,0x98,0x60,0x56,0xF8,0x01,0x4F,0x18,0x79,0x22,0xE0,0x14,0x98,0x62,0x23,
+0x00,0x18,0x58,0x77,0x01,0x85,0x29,0x1C,0x21,0xE0,0x0D,0x41,0x18,0x0D,0x81,0x10,
+0xC1,0x40,0x10,0x01,0x99,0x9E,0xFD,0x4A,0x03,0xB0,0x12,0xEA,0x00,0x46,0xEC,0xBC,
+0x0D,0x61,0x14,0x0D,0xA1,0x0C,0x0C,0x81,0x04,0x0C,0xC1,0x00,0x0D,0x21,0x1C,0x5D,
+0x63,0x00,0x89,0xA5,0x1A,0xEA,0x00,0xE7,0xFF,0xFF,0x60,0x0C,0x81,0x06,0x5C,0x63,
+0x00,0x0C,0xC1,0x02,0x20,0x60,0xD6,0x9A,0xE0,0x21,0x60,0x30,0x21,0x64,0x24,0x5D,
+0x60,0x41,0x4A,0xE1,0x01,0x5C,0x80,0x29,0x4A,0xF7,0x0A,0xD1,0xA1,0x05,0x9E,0xD0,
+0xC1,0x07,0xE6,0xC3,0x14,0x00,0x01,0xCB,0x18,0x3D,0x9C,0x0B,0x18,0x01,0xC3,0x00,
+0x5F,0xEE,0x20,0x03,0xA7,0xE4,0x00,0x01,0xB3,0xE7,0xFF,0xFE,0xDC,0x5C,0x63,0x00,
+0x20,0x64,0x62,0x9A,0xE0,0x21,0x60,0x30,0x21,0x64,0x24,0x5D,0x60,0x41,0x4A,0xE1,
+0x01,0x21,0xA5,0xF6,0xE4,0x00,0x01,0x75,0xE7,0xFF,0xFE,0x9E,0x5C,0x63,0x00,0xD0,
+0x62,0x06,0x4E,0x9A,0xE1,0x21,0x60,0x24,0x5D,0x60,0x21,0x4A,0xE1,0x01,0x21,0xA4,
+0x32,0x13,0x0A,0x00,0x53,0x18,0x01,0x1B,0x0A,0x00,0xC3,0x14,0x00,0x01,0xFD,0x8C,
+0x80,0x02,0xCB,0x38,0x23,0x78,0x0B,0x59,0x01,0x47,0x4C,0xD5,0x5F,0x5A,0x04,0x0F,
+0x59,0x01,0xCB,0x38,0x23,0x6C,0x0B,0x59,0x01,0xC7,0x5A,0x8F,0xFF,0x0F,0x59,0x01,
+0xCB,0x38,0x3C,0xD4,0x0B,0x59,0x01,0x47,0x4C,0xD5,0x5F,0x5A,0x04,0x0F,0x59,0x01,
+0xCB,0x38,0x3C,0xE0,0x0B,0x59,0x01,0xC7,0x5A,0x7F,0xFF,0x0F,0x59,0x01,0xCB,0x18,
+0x3C,0xEC,0x0B,0x38,0x01,0x45,0x8C,0xCD,0x5D,0x8C,0x04,0x0D,0x98,0x01,0x22,0xE5,
+0x6A,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x3C,0x68,0x0B,0x38,0x01,0xFF,0x20,0x11,0x11,
+0x0F,0x38,0x01,0xCB,0x17,0x3C,0x6C,0x0B,0x38,0x01,0xFF,0x20,0x22,0x22,0x0F,0x38,
+0x01,0xCB,0x17,0x3C,0x70,0x0B,0x38,0x01,0xFF,0x20,0x33,0x33,0x0F,0x38,0x01,0xCA,
+0xF7,0x78,0xC0,0xFF,0x00,0xAA,0x55,0x0F,0x17,0x01,0xE4,0x00,0x00,0x01,0x13,0x0A,
+0x00,0x53,0x18,0x01,0x1B,0x0A,0x00,0xE7,0xFF,0xFF,0x6F,0x13,0x0A,0x00,0x45,0x8C,
+0xC4,0x19,0x8A,0x00,0xE7,0xFF,0xFF,0x55,0x0D,0xA1,0x0E,0x0D,0x81,0x12,0x0D,0x61,
+0x16,0x0D,0x41,0x1A,0x0D,0x21,0x1E,0x1C,0x21,0x20,0x85,0x29,0xC2,0xE0,0x10,0x01,
+0xEC,0x77,0x03,0xD4,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x03,0xCC,0xC2,0xE0,0x10,0x01,
+0xEC,0xB7,0x03,0xD0,0xC2,0xE0,0x10,0x01,0xEC,0xD7,0x03,0xE8,0xC2,0xE0,0x10,0x01,
+0xEC,0xF7,0x03,0xE0,0xC2,0xE0,0x10,0x01,0x0F,0x01,0x02,0xED,0x17,0x03,0xE4,0xC2,
+0xE0,0x10,0x01,0xEF,0x17,0x03,0xF4,0xC2,0xE0,0x10,0x01,0x0F,0x01,0x06,0xEF,0x17,
+0x03,0xB8,0xC2,0xE0,0x10,0x01,0x0F,0x01,0x0A,0xEF,0x17,0x03,0xD8,0x85,0x29,0x5C,
+0x84,0x00,0xC2,0xE0,0x10,0x01,0x4C,0x84,0x10,0xFE,0xF7,0x03,0xEC,0x8E,0xE4,0x0C,
+0x77,0x00,0x85,0x29,0x5C,0x63,0x00,0x9B,0x00,0x24,0x68,0x25,0x1F,0x03,0xFE,0x5F,
+0x18,0x00,0xC2,0xE0,0x10,0x01,0xF3,0x57,0x0A,0xE8,0x1E,0xE3,0x01,0x1F,0x9A,0xFF,
+0x5F,0x3C,0x00,0xD7,0x97,0x00,0x50,0x1F,0x23,0x02,0x5F,0x39,0x00,0xC2,0xEF,0xFF,
+0xE1,0xCA,0xF7,0xFF,0xFF,0xE4,0x00,0x00,0x2F,0x4F,0x78,0x10,0x9F,0x01,0x8F,0x64,
+0x5F,0x18,0x00,0x0F,0x7B,0x02,0x5E,0xFB,0x15,0x4A,0xF7,0xD8,0xD7,0x19,0xFF,0x69,
+0x4F,0x03,0x10,0xC3,0x20,0x10,0x01,0x8F,0x04,0xEF,0x39,0x03,0xDA,0x0F,0x18,0x02,
+0xD7,0x38,0x01,0x41,0xC3,0x20,0x10,0x01,0xEF,0x79,0x03,0xD6,0xC3,0x20,0x10,0x01,
+0xEF,0xB9,0x03,0xCE,0xC3,0x20,0x10,0x01,0xEF,0xD9,0x03,0xD2,0xC3,0x20,0x10,0x01,
+0xEF,0x39,0x03,0xEA,0xE4,0x00,0x00,0x49,0xC3,0x20,0x10,0x01,0xEF,0x79,0x03,0xE2,
+0xC3,0x20,0x10,0x01,0xEF,0xB9,0x03,0xE6,0xC3,0x20,0x10,0x01,0xEF,0xD9,0x03,0xF6,
+0xC3,0x20,0x10,0x01,0xEF,0x39,0x03,0xBA,0x20,0x60,0xDE,0x0F,0x44,0x02,0x0F,0x84,
+0x06,0xCF,0x5A,0x00,0x32,0x40,0xE7,0xE3,0xD7,0x47,0x05,0xDC,0x42,0xF7,0x2D,0x40,
+0xA5,0xCB,0x43,0x77,0xDB,0x43,0x3B,0x2C,0xCC,0xC6,0x00,0x0A,0x9B,0x4A,0x8C,0xD9,
+0x98,0x61,0x40,0xC6,0xD0,0xD7,0x06,0x04,0xF4,0x98,0x60,0xE4,0x00,0x01,0x31,0x20,
+0x64,0x6A,0x0F,0x44,0x02,0x0F,0x64,0x06,0xCF,0x5A,0x00,0x32,0x40,0xE7,0xDB,0x98,
+0x60,0xD7,0x47,0x04,0x14,0xE4,0x00,0x00,0x55,0x1C,0xFA,0xFE,0xD4,0x67,0x01,0x9E,
+0x4C,0x63,0x10,0x9F,0x5F,0x4F,0x5A,0x10,0x8F,0x44,0x8C,0x83,0x0F,0x5A,0x02,0x0F,
+0x64,0x02,0xCF,0x5A,0x00,0x32,0x41,0x08,0xDB,0x98,0x60,0xD7,0x48,0x02,0xC4,0x42,
+0xF7,0x2D,0x40,0xA5,0xCB,0x43,0xB7,0xEB,0x43,0x3D,0x2C,0xE7,0xFF,0xFF,0x3B,0xD4,
+0x7C,0x01,0x3E,0x9F,0x5F,0x4C,0xE7,0x10,0x4F,0x5A,0x10,0x98,0x60,0x8F,0x44,0x8C,
+0x87,0x0F,0x5A,0x02,0x0F,0x84,0x02,0xCF,0x5A,0x00,0x32,0x41,0x08,0xE3,0xD7,0x48,
+0x01,0x2C,0xE7,0xFF,0xFE,0xD5,0x42,0xF7,0x2D,0xCC,0xC6,0x00,0x0A,0x43,0xD7,0xF3,
+0x40,0xA5,0xCB,0x9B,0x4A,0x43,0x3E,0x2C,0x8C,0xD9,0x40,0xC6,0xD0,0xD7,0x06,0xFB,
+0x60,0x98,0x61,0x85,0x29,0x5C,0xE7,0x00,0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x0A,0xE8,
+0x42,0xE7,0xBB,0x5E,0xF7,0x00,0x9B,0x00,0x8C,0xB7,0x8C,0xD7,0xC3,0x80,0x10,0x01,
+0xC3,0x40,0x10,0x01,0x5C,0xC6,0x00,0x5C,0xA5,0x00,0x8B,0x38,0x9A,0xE0,0xFF,0x9C,
+0x0B,0xC0,0xFF,0x5A,0x0D,0x04,0xE4,0x00,0x00,0x49,0x4F,0x65,0x10,0x43,0xBB,0xE4,
+0x0F,0xBD,0x02,0x9C,0xA1,0x8E,0xFD,0x5C,0xA5,0x00,0x8B,0xBB,0x8F,0x7A,0x8F,0xBA,
+0x0B,0x7B,0x00,0x0B,0xBD,0x02,0x8F,0x1B,0x8F,0x3D,0xD4,0xA6,0xFF,0x01,0x26,0xE0,
+0xE8,0x27,0x20,0xDC,0x27,0x00,0xD0,0xC3,0x40,0x10,0x01,0xFF,0x5A,0x03,0xEC,0x4C,
+0xE7,0x10,0xCF,0x18,0xFF,0xF6,0x8C,0xFA,0x0F,0x47,0x02,0x43,0x3A,0xCB,0x9F,0x56,
+0x8F,0x19,0x43,0x58,0xD0,0xCF,0x5A,0x07,0xFF,0x43,0x5A,0xB8,0x0F,0x43,0x01,0x0E,
+0xE4,0x00,0x98,0x61,0xE4,0x00,0x00,0x0D,0x98,0x60,0x85,0x29,0x9A,0xE3,0x9B,0x01,
+0xE4,0x00,0x00,0x11,0x8F,0x17,0x9E,0xE2,0xD7,0x03,0xFF,0xE1,0x4C,0x77,0x09,0x9C,
+0x7F,0x85,0x29,0xFF,0x00,0x7F,0xFF,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x03,0xBC,0x0F,
+0x17,0x01,0x0F,0x17,0x03,0x0F,0x17,0x05,0x0F,0x17,0x07,0x0F,0x17,0x09,0x0F,0x17,
+0x0B,0x85,0x29,0xC3,0x00,0x10,0x01,0xFE,0xF8,0x03,0xBC,0xC3,0x00,0x10,0x01,0x0B,
+0x37,0x08,0xFF,0x18,0x0C,0x08,0xC3,0x2F,0xFF,0xE0,0x20,0x00,0x41,0x0B,0x37,0x05,
+0x0F,0x37,0x09,0x0B,0x37,0x07,0xE4,0x00,0x00,0x1B,0x0B,0x38,0x17,0x0F,0x37,0x09,
+0x0B,0x38,0x19,0x0F,0x37,0x0B,0x0B,0x37,0x04,0xC3,0x2F,0xFF,0xE0,0x20,0x00,0x41,
+0x0B,0x37,0x01,0x0F,0x37,0x05,0x0B,0x37,0x03,0xE4,0x00,0x00,0x1B,0x0B,0x38,0x17,
+0x0F,0x37,0x05,0x0B,0x38,0x19,0x0F,0x37,0x07,0x0B,0x38,0x17,0x0B,0x18,0x19,0x0F,
+0x37,0x01,0x0F,0x17,0x03,0x85,0x29,0x1C,0x21,0xD8,0xC2,0xE0,0x10,0x01,0x0D,0x21,
+0x24,0x0D,0x41,0x20,0x0D,0x61,0x1C,0xFD,0x57,0x03,0xBC,0x0D,0x81,0x18,0x0D,0xA1,
+0x14,0x0D,0xC1,0x10,0x09,0xAA,0x07,0x0B,0x0A,0x03,0x43,0x18,0x6D,0x5F,0x18,0x06,
+0x0F,0x01,0x0B,0x43,0x18,0xC3,0xE9,0x97,0x03,0xBD,0x09,0xCA,0x05,0x41,0x8C,0x75,
+0x5D,0x8C,0x06,0x40,0x6C,0x63,0x8C,0x78,0xE7,0xFF,0xFE,0x48,0x0A,0xEA,0x09,0x41,
+0xCE,0xBD,0x0A,0xEA,0x0B,0x42,0xED,0xBD,0x5E,0xF7,0x06,0x0E,0xE1,0x0F,0x42,0xF7,
+0xBB,0x5D,0x63,0x06,0x5D,0x4E,0x06,0x40,0x6A,0x53,0x8C,0x77,0xE7,0xFF,0xFE,0x00,
+0x5E,0xE3,0x06,0x98,0x61,0x21,0x60,0xAC,0x22,0xE0,0xA0,0x43,0x0B,0xB8,0xD3,0x05,
+0x01,0x14,0x41,0x4C,0x53,0x0B,0x01,0x0E,0x09,0x81,0x0A,0x41,0x6B,0xBB,0x43,0x0C,
+0xC3,0x8D,0x58,0xCD,0x4A,0x00,0x64,0x42,0xEA,0x58,0x5E,0xE8,0xB1,0x48,0x61,0x01,
+0x0D,0xC1,0x12,0x0D,0xA1,0x16,0x0D,0x81,0x1A,0x0D,0x61,0x1E,0x0D,0x41,0x22,0x0D,
+0x21,0x26,0x1C,0x21,0x28,0x85,0x29,0x1C,0x21,0xE8,0xC2,0xE0,0x10,0x01,0x0D,0x41,
+0x10,0x0D,0x61,0x0C,0x0D,0x81,0x08,0x0D,0xC1,0x00,0xF1,0x97,0x0A,0x5F,0xC1,0x40,
+0x10,0x01,0x1D,0x6C,0xFF,0x0D,0x21,0x14,0x0D,0xA1,0x04,0x5D,0xC3,0x00,0x5D,0x6B,
+0x00,0xFD,0x4A,0x0C,0x08,0x4E,0xEE,0x5D,0x56,0xF7,0x01,0x22,0xE0,0xD4,0x8A,0xEB,
+0xE4,0x00,0x00,0x43,0xCC,0x77,0x00,0x30,0x1D,0xB7,0x01,0x8C,0x6A,0xCC,0x8D,0x00,
+0x30,0x9C,0x64,0x8C,0x8A,0x50,0xA0,0x30,0x9C,0x84,0xE4,0x00,0x59,0xE0,0x5E,0xED,
+0x00,0xD5,0x97,0xFF,0x1D,0x12,0xEA,0x00,0x22,0xE0,0x20,0x9E,0xFF,0x1A,0xEA,0x00,
+0x21,0x60,0x30,0x9D,0x7F,0x5D,0x6B,0x00,0xE7,0xFF,0xFF,0x7B,0x12,0xEA,0x00,0x22,
+0xE0,0x52,0xC2,0xE0,0x10,0x01,0x9B,0x37,0xEB,0x17,0x08,0x25,0x47,0x18,0xCC,0xEF,
+0x17,0x08,0x25,0x0D,0xC1,0x02,0x0D,0xA1,0x06,0x0D,0x81,0x0A,0x0D,0x61,0x0E,0x0D,
+0x41,0x12,0x0D,0x21,0x16,0x1C,0x21,0x18,0x85,0x29,0x5C,0x63,0x00,0x5C,0x84,0x00,
+0xC2,0xE0,0x10,0x01,0x43,0x64,0x1D,0xF2,0xF7,0x0A,0xE8,0x9F,0x61,0x40,0xA5,0xBB,
+0x5F,0x7B,0x00,0x5C,0xA5,0x00,0x20,0xE4,0x3E,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0A,
+0xF4,0xE4,0x00,0x00,0x19,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0D,0x04,0x43,0x23,0x2C,
+0x9B,0x00,0x4F,0x39,0x10,0x9F,0x22,0x8F,0x37,0xC2,0xEF,0xFF,0xE1,0xCA,0xF7,0xFF,
+0xFF,0xE4,0x00,0x00,0x3D,0x0B,0x99,0xFE,0x0B,0x59,0x00,0x9F,0x24,0x8F,0x5C,0x4F,
+0x98,0x10,0x5E,0xFA,0x15,0x8F,0x86,0x4A,0xF7,0xD0,0x0F,0x5C,0x00,0x9F,0x01,0x5F,
+0x58,0x00,0xD7,0x7A,0xFF,0x1D,0x9B,0x00,0xE4,0x00,0x00,0x29,0x0F,0x26,0x02,0x9F,
+0x01,0x43,0x39,0xBD,0x5F,0x18,0x00,0x0F,0x26,0x00,0x9C,0xC4,0xD7,0x78,0xFF,0x85,
+0x85,0x29,0x1C,0x21,0x88,0x0D,0x41,0x70,0x0D,0x61,0x6C,0x5D,0x44,0x00,0x0D,0x81,
+0x68,0x5C,0x85,0x00,0x0D,0xA1,0x64,0x88,0xA6,0x41,0xA4,0x55,0x0D,0x21,0x74,0x89,
+0x83,0x88,0xC1,0x88,0x6A,0xE7,0xFF,0xFE,0xAA,0xC2,0xE0,0x10,0x01,0x9D,0xA1,0xEB,
+0x57,0x01,0x70,0x9B,0x20,0x5D,0xAD,0x00,0x8B,0x19,0x9A,0xE0,0x89,0x61,0xE4,0x00,
+0x00,0x5B,0x4F,0x79,0x10,0x43,0x99,0x54,0x8F,0x6B,0x0F,0x7B,0x02,0x8E,0xFB,0x23,
+0x44,0x54,0x23,0x48,0x36,0xCF,0x9C,0x00,0x06,0x9F,0x9F,0xE4,0x00,0x00,0x13,0x4F,
+0x9C,0x08,0x9F,0x81,0x43,0x7C,0xDB,0x9F,0x21,0x8F,0x1B,0x5F,0x79,0x00,0xD5,0xBB,
+0xFE,0xA5,0x26,0xE1,0x34,0xC3,0x20,0x10,0x01,0xEB,0x39,0x0A,0xEF,0x43,0x18,0xCB,
+0x23,0x44,0x32,0x4F,0x37,0x0A,0x8F,0x19,0xE4,0x00,0x00,0x35,0x23,0x48,0x46,0xCF,
+0x37,0x00,0x03,0xCE,0xF7,0x00,0x06,0x8F,0x19,0xE4,0x00,0x00,0x13,0x8F,0x17,0x4E,
+0xF7,0x08,0x42,0xF8,0xB8,0xC2,0xE0,0xFF,0xE8,0xCB,0x00,0x07,0xFF,0x98,0x61,0x4A,
+0xF7,0xC0,0x5E,0xFF,0xF9,0x4A,0xF7,0x00,0x0E,0xEC,0x01,0xE4,0x00,0x00,0x0D,0x98,
+0x60,0x0D,0xA1,0x66,0x0D,0x81,0x6A,0x0D,0x61,0x6E,0x0D,0x41,0x72,0x0D,0x21,0x76,
+0x1C,0x21,0x78,0x85,0x29,0xFC,0x21,0xFF,0x78,0xED,0x41,0x00,0x80,0x0D,0x81,0x78,
+0x0D,0xA1,0x74,0x0D,0xC1,0x70,0x0D,0xE1,0x6C,0x0E,0x01,0x68,0x0E,0xC1,0x64,0xED,
+0x21,0x00,0x84,0x0D,0x61,0x7C,0xC1,0x40,0x10,0x01,0xFD,0x4A,0x0A,0xE4,0x11,0x6A,
+0x04,0x4E,0xEB,0x08,0x9E,0xE8,0xC6,0xF7,0x03,0xF8,0xFE,0xC1,0x00,0x88,0x5D,0xC4,
+0x00,0x5D,0xA5,0x00,0x8A,0x03,0x5C,0xA6,0x00,0x89,0xE1,0x41,0x65,0x5B,0x40,0x21,
+0xBD,0x88,0x6E,0x88,0x8D,0xFC,0xD6,0xFF,0x78,0xE7,0xFF,0xFC,0xA2,0xC3,0x40,0x10,
+0x01,0x89,0x81,0x5D,0x6B,0x00,0x13,0x2A,0x04,0x9A,0xE0,0xFF,0x5A,0x04,0x00,0xE4,
+0x00,0x00,0x29,0x4F,0x17,0x08,0x9E,0xE1,0x43,0x6C,0xC4,0x8F,0x1A,0x0B,0x18,0x03,
+0x0F,0x1B,0x01,0x5F,0x17,0x00,0xD7,0x38,0xFF,0x6D,0x43,0x4B,0x74,0x8D,0xAB,0x5F,
+0x5A,0x00,0x5D,0xAD,0x00,0x9A,0xE0,0x1F,0x2D,0x01,0x43,0x39,0xD5,0x5F,0x39,0x00,
+0xE4,0x00,0x00,0x33,0x4F,0x77,0x10,0xFF,0x96,0xFF,0x78,0x8F,0x7C,0x0F,0x7B,0x02,
+0x27,0x60,0x4A,0xD5,0xB8,0x03,0x19,0x9E,0xE1,0x5F,0x17,0x00,0xD7,0x38,0xFF,0x45,
+0x8B,0x1A,0x1F,0x36,0xD8,0x1F,0x76,0xD8,0x4E,0xF8,0x10,0x8E,0xF9,0x0F,0x37,0xA2,
+0x1E,0xF8,0x01,0x43,0x39,0xCB,0x4E,0xF7,0x10,0x8E,0xFB,0x0E,0xF7,0xA2,0x42,0xF7,
+0xBB,0x5F,0x37,0x15,0x4B,0x77,0xC8,0x27,0x60,0xBC,0x8F,0x1A,0x0B,0x6A,0x0B,0x41,
+0x78,0x5D,0x13,0x4A,0x0C,0x4D,0x6B,0x08,0x98,0x61,0x8D,0x8B,0x0B,0x0C,0x00,0x43,
+0x18,0xDB,0x43,0x77,0xDB,0x43,0x18,0xD0,0x8E,0xF9,0x42,0xFB,0xB8,0x8E,0xF8,0x0E,
+0xF0,0x01,0xE4,0x00,0x00,0x0D,0x98,0x60,0x88,0x2F,0x0E,0xC1,0x66,0x0E,0x01,0x6A,
+0x0D,0xE1,0x6E,0x0D,0xC1,0x72,0x0D,0xA1,0x76,0x0D,0x81,0x7A,0x0D,0x61,0x7E,0xED,
+0x41,0x00,0x82,0xED,0x21,0x00,0x86,0xFC,0x21,0x00,0x88,0x85,0x29,0x1C,0x21,0xB8,
+0x0D,0x41,0x40,0xC1,0x40,0x10,0x01,0x0D,0x61,0x3C,0x0D,0x81,0x38,0x0D,0xC1,0x30,
+0x0E,0x41,0x20,0x0E,0x61,0x1C,0x0E,0x81,0x18,0x0E,0xA1,0x14,0x0E,0xC1,0x10,0x0D,
+0x21,0x44,0x0D,0xA1,0x34,0x0D,0xE1,0x2C,0x0E,0x01,0x28,0x0E,0x21,0x24,0x5E,0x63,
+0x00,0x5E,0x44,0x00,0xC1,0xC0,0x10,0x01,0xF0,0x8A,0x0A,0xE4,0xFD,0xCE,0x08,0x26,
+0x98,0xA0,0x88,0x6E,0x99,0x80,0x8A,0xCA,0xE4,0x00,0xA9,0x6E,0xC1,0x40,0x10,0x01,
+0x89,0x6C,0xC2,0xA0,0x10,0x01,0x9A,0x81,0xFD,0x4A,0x0C,0x08,0xE4,0x00,0x01,0x19,
+0xCC,0x6B,0x00,0x30,0xEA,0xF5,0x07,0xDF,0x41,0xA3,0x54,0x56,0xF7,0x02,0x12,0x2D,
+0x04,0x12,0x0D,0x05,0x11,0xED,0x07,0x22,0xE1,0x0C,0x1C,0x61,0x04,0x88,0x91,0x88,
+0xB0,0x88,0xCF,0x98,0xE0,0xE7,0xFF,0xFA,0xDA,0x20,0x61,0x14,0x1C,0x61,0x06,0x88,
+0x91,0x88,0xB0,0x88,0xCF,0x98,0xE0,0xE7,0xFF,0xFC,0x5C,0x20,0x60,0xCC,0x0B,0x01,
+0x04,0xCF,0x18,0x00,0x07,0x0A,0xE1,0x06,0xCE,0xF7,0x00,0x03,0x8E,0xF8,0x9B,0x0A,
+0x42,0xF7,0xC0,0x0E,0xED,0x17,0xE4,0x00,0x00,0x43,0x8C,0x6A,0x88,0x91,0x1C,0x63,
+0x16,0x88,0xB0,0x88,0xCF,0x98,0xE0,0xE7,0xFF,0xFA,0x56,0x20,0x60,0x32,0x4E,0xF4,
+0x5C,0x45,0x8C,0xBD,0x5D,0x8C,0x00,0x88,0x6E,0xF0,0x96,0x0A,0xE4,0x98,0xA1,0x9D,
+0x61,0xE4,0x00,0xA8,0x3C,0x5D,0x6B,0x00,0x12,0xEA,0x00,0xD6,0xEB,0xFB,0xAD,0x88,
+0x6C,0xE7,0xFF,0xF7,0xAC,0x12,0xEA,0x00,0x22,0xE0,0x6C,0xC2,0xE0,0x10,0x01,0xEA,
+0xF7,0x09,0xB9,0x56,0xF7,0x40,0x22,0xE0,0x34,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x03,
+0xCA,0x86,0xE8,0xC2,0xE0,0x10,0x01,0x88,0x6E,0xF0,0x97,0x0A,0xE4,0x98,0xA1,0xE4,
+0x00,0xA7,0xC0,0xC2,0xE0,0x10,0x01,0x99,0x80,0xEA,0xF7,0x09,0xB9,0x89,0x6C,0x56,
+0xF7,0x80,0x99,0xA1,0x22,0xE0,0xFC,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x03,0xDE,0x86,
+0xE8,0xE4,0x00,0x00,0x7F,0xCE,0xEB,0x00,0x30,0x40,0x6A,0xBC,0x8A,0xE3,0x88,0x83,
+0x10,0xB7,0x04,0x1C,0x63,0x18,0x9C,0x8C,0x10,0xD7,0x05,0x10,0xF7,0x07,0xE7,0xFF,
+0xF3,0x0E,0x20,0x60,0x32,0x4E,0xED,0x5C,0x45,0x8C,0xBD,0x5D,0x8C,0x00,0x9D,0x61,
+0x5D,0x6B,0x00,0x12,0xEA,0x00,0xD6,0xEB,0xFE,0x7D,0x88,0x6C,0xE7,0xFF,0xF6,0x96,
+0x22,0x61,0x5C,0x22,0x40,0xFE,0xE4,0x00,0x00,0xA3,0xCD,0x6C,0x00,0x30,0x8D,0x6A,
+0x0A,0xEB,0x16,0x0E,0xE1,0x08,0x0A,0xEB,0x18,0x1C,0x61,0x08,0x0E,0xE1,0x0C,0x1C,
+0x81,0x0C,0xEE,0xED,0x03,0xFE,0x0C,0xAB,0x0E,0x88,0xCE,0x86,0xE8,0x0E,0xE1,0x0A,
+0x9D,0x81,0x0E,0xEB,0x17,0x5D,0x8C,0x00,0x0E,0xE1,0x0E,0x0E,0xEB,0x19,0xE4,0x00,
+0x00,0x25,0xC1,0xC0,0x10,0x01,0x99,0x80,0xC1,0xA0,0x10,0x01,0xFD,0xCE,0x01,0x58,
+0x12,0xEA,0x00,0xD6,0xEC,0xFD,0xBD,0xC2,0xE0,0x10,0x01,0x13,0x6A,0x00,0xEB,0x97,
+0x07,0xDF,0x9B,0x20,0xC2,0xE0,0x10,0x01,0x57,0x9C,0x01,0xFE,0xF7,0x0C,0x20,0xCB,
+0xA0,0x07,0xFF,0xE4,0x00,0x00,0x89,0x0B,0x57,0x01,0x13,0xD7,0xEF,0x5F,0x1A,0x06,
+0x47,0x18,0xC7,0x4F,0x18,0xFA,0x47,0x1A,0xC4,0x5F,0x58,0x06,0xC3,0x40,0xFF,0xE8,
+0x20,0x00,0x1D,0xFF,0x00,0x07,0xFF,0x0F,0x17,0x01,0x5F,0x58,0x06,0x23,0x80,0x48,
+0xCF,0x1A,0x03,0xFF,0x4F,0x5E,0x50,0x43,0x18,0xE8,0x8F,0x1A,0x0F,0x17,0x01,0x9F,
+0x21,0x1E,0xF7,0x30,0x5F,0x39,0x00,0xD7,0x3B,0xFE,0x06,0x0E,0xC1,0x12,0x0E,0xA1,
+0x16,0x0E,0x81,0x1A,0x0E,0x61,0x1E,0x0E,0x41,0x22,0x0E,0x21,0x26,0x0E,0x01,0x2A,
+0x0D,0xE1,0x2E,0x0D,0xC1,0x32,0x0D,0xA1,0x36,0x0D,0x81,0x3A,0x0D,0x61,0x3E,0x0D,
+0x41,0x42,0x0D,0x21,0x46,0x1C,0x21,0x48,0x85,0x29,0x1C,0x21,0xB0,0x0D,0x61,0x44,
+0x0D,0xC1,0x38,0x0D,0xE1,0x34,0x0E,0x61,0x24,0x0E,0xC1,0x18,0x0D,0x21,0x4C,0x0D,
+0x41,0x48,0x0D,0x81,0x40,0x0D,0xA1,0x3C,0x0E,0x01,0x30,0x0E,0x21,0x2C,0x0E,0x41,
+0x28,0x0E,0x81,0x20,0x0E,0xA1,0x1C,0x1E,0xC1,0x50,0xC2,0xE0,0x10,0x01,0x5C,0xC6,
+0x00,0x0C,0x36,0xC4,0x0C,0xD6,0xC0,0xF3,0xD7,0x0A,0xE8,0x8B,0x03,0x4F,0xBE,0x10,
+0x5E,0x64,0x00,0x1E,0xFD,0x0A,0x89,0xC5,0xC6,0xF7,0x07,0xF8,0x5D,0xE7,0x00,0x40,
+0x21,0xBD,0x89,0x61,0x20,0xA8,0x3E,0xC2,0xE0,0x10,0x01,0xEA,0xB7,0x04,0x38,0xE4,
+0x00,0x00,0x0F,0x0A,0xA3,0x1C,0xC3,0x40,0x10,0x01,0x8A,0xEB,0xFF,0x5A,0x0B,0xC0,
+0xCB,0x60,0x20,0x00,0x9B,0x80,0xE4,0x00,0x00,0x7D,0x21,0xC8,0x4A,0x41,0x1A,0xEC,
+0x0D,0x5A,0x02,0x0D,0x08,0x02,0x8D,0x0A,0xE4,0x00,0x00,0x29,0x22,0x60,0x2A,0x0D,
+0x1A,0x02,0xE4,0x00,0x00,0x15,0x41,0x1A,0xEC,0x0D,0x08,0x02,0x0D,0x17,0x00,0x9F,
+0x81,0x0D,0xB7,0x02,0x5F,0x9C,0x00,0x5D,0xBB,0x15,0x9E,0xE4,0x4B,0x6D,0xD8,0x9F,
+0x44,0x5F,0x7B,0x06,0xD7,0x9E,0xFE,0x36,0x45,0xBB,0xDF,0x99,0x40,0x4D,0xAD,0xFA,
+0xC2,0xE0,0x10,0x01,0xC2,0x40,0x10,0x01,0xFE,0x97,0x0C,0x08,0x45,0xAD,0xDC,0x8A,
+0x2A,0x99,0x80,0x8A,0x14,0xFE,0x52,0x0A,0xE4,0xE4,0x00,0x06,0x43,0x21,0xC8,0xBA,
+0xC2,0xE0,0x10,0x01,0x13,0xB4,0x00,0xFF,0x77,0x0C,0x0D,0x9B,0x80,0xE4,0x00,0x00,
+0x35,0x13,0xDB,0xFF,0xD7,0xCA,0x00,0x5D,0x13,0xDB,0x00,0xD5,0x5E,0x13,0xA1,0x9F,
+0x81,0x1F,0x7B,0x30,0x5F,0x9C,0x00,0xD7,0x9D,0xFF,0x56,0x21,0x41,0x52,0x0F,0x4B,
+0x02,0xD6,0xBA,0x12,0xF4,0x0F,0x6B,0x06,0xD7,0x5B,0x00,0x7C,0xD7,0x5B,0x12,0x9E,
+0x0F,0x6B,0x0A,0xD7,0x5B,0x12,0x60,0x08,0xF8,0x20,0x09,0x18,0x22,0x98,0x60,0x0F,
+0x16,0xB4,0x88,0x8B,0x88,0xAD,0x88,0xD5,0xE7,0xFF,0xEB,0x98,0x0F,0x16,0xB6,0xD0,
+0x60,0x11,0x82,0x13,0x54,0x00,0x9B,0x62,0x8F,0x4C,0x99,0x41,0xCF,0x5A,0x00,0x30,
+0x8F,0x54,0x18,0x1A,0x04,0x18,0x1A,0x06,0x1B,0x7A,0x05,0xE4,0x00,0x04,0x41,0x21,
+0x45,0x86,0x0F,0x4B,0x06,0xD6,0xBA,0x10,0x54,0x0F,0x6B,0x02,0xD7,0x7A,0x10,0x1C,
+0x0F,0x6B,0x0A,0xD7,0x5B,0x00,0x7C,0xD7,0x5B,0x0F,0xC6,0x0F,0x6B,0x0E,0xD7,0x5B,
+0x0F,0x88,0x08,0xF8,0x20,0x09,0x18,0x22,0x98,0x61,0x0F,0x16,0xB4,0x88,0x8B,0x88,
+0xAD,0x88,0xD5,0xE7,0xFF,0xEA,0xE2,0x0F,0x16,0xB6,0xD0,0x60,0x0E,0xAA,0x9B,0x61,
+0x13,0x54,0x00,0x5D,0xE0,0x21,0x8F,0x4C,0x99,0x42,0xCF,0x5A,0x00,0x30,0x8F,0x54,
+0x1B,0x7A,0x06,0x18,0x1A,0x04,0x4B,0x63,0x13,0x1B,0x7A,0x05,0xE4,0x00,0x03,0x7F,
+0xD1,0x41,0x06,0x41,0x1F,0x7A,0xFE,0xD7,0x6A,0x06,0x08,0x4F,0x4A,0x10,0x8F,0x4B,
+0x0F,0x5A,0x02,0xD6,0xBA,0x0C,0xE4,0x1F,0x6A,0xFF,0x4F,0x7B,0x10,0x8F,0x6B,0x0F,
+0x7B,0x02,0xD7,0x5B,0x01,0x34,0xD7,0x5B,0x0C,0x4E,0x1F,0x8A,0xFE,0x4F,0x9C,0x10,
+0x8F,0x8B,0x0F,0x9C,0x02,0xD7,0x5C,0x0B,0xD0,0x1F,0xAA,0x01,0x4F,0xBD,0x10,0x8F,
+0xAB,0x0F,0xBD,0x02,0xD7,0xBC,0x0B,0x58,0x1F,0x8A,0x01,0x4F,0x9C,0x10,0x8F,0x8B,
+0x0F,0x9C,0x02,0xD7,0x5C,0x00,0xDC,0xD7,0x5C,0x0A,0xC6,0x1F,0x8A,0x02,0x4F,0x9C,
+0x10,0x8F,0x8B,0x0F,0x9C,0x02,0xD7,0x5C,0x0A,0x48,0xD7,0x9B,0x0A,0x2C,0x08,0xF8,
+0x20,0x09,0x18,0x22,0x88,0x6A,0x0F,0x16,0xB4,0x88,0x8B,0x88,0xAD,0x88,0xD5,0xE7,
+0xFF,0xE9,0x8A,0x0F,0x16,0xB6,0xD0,0x60,0x09,0x4A,0x13,0x74,0x00,0x1F,0x8A,0xFF,
+0x8F,0x6C,0x5F,0x9C,0x00,0x21,0xE4,0x26,0x1F,0x8A,0xFE,0x5F,0x9C,0x00,0xCF,0x7B,
+0x00,0x30,0x43,0x5B,0x84,0x1B,0x9A,0x04,0x19,0x5A,0x06,0x1F,0x4A,0x01,0x5F,0x5A,
+0x00,0x21,0xE4,0x26,0x1F,0x4A,0x02,0x5F,0x5A,0x00,0x8F,0x74,0x9D,0x41,0x1B,0x5B,
+0x05,0x5D,0x4A,0x00,0xE4,0x00,0x01,0xEF,0x4F,0x6A,0x10,0x1F,0x9A,0xFE,0x8F,0x6B,
+0xD5,0x5C,0x04,0x06,0x0F,0x7B,0x02,0xD6,0xBB,0x06,0xC4,0x1F,0x9A,0xFF,0x4F,0x9C,
+0x10,0x8F,0x8B,0x0F,0x9C,0x02,0xD7,0x9B,0x06,0x4C,0x1F,0x9A,0xFD,0x4F,0x9C,0x10,
+0x8F,0x8B,0x0F,0x9C,0x02,0xD7,0x7C,0x00,0xB4,0xD7,0x7C,0x05,0xB6,0x9F,0x5C,0x4F,
+0x5A,0x10,0x8F,0x4B,0x0F,0x5A,0x02,0xD7,0x7A,0x05,0x40,0x08,0xF8,0x20,0x09,0x18,
+0x22,0x88,0x6A,0x0F,0x16,0xB4,0x88,0x8B,0x88,0xAD,0x88,0xD5,0xE7,0xFF,0xE8,0x50,
+0x0F,0x16,0xB6,0xD0,0x60,0x04,0x62,0x13,0x54,0x00,0x1F,0x6A,0xFF,0x8F,0x4C,0x5F,
+0x7B,0x00,0x21,0xE4,0x26,0x1F,0x6A,0xFE,0x5F,0x7B,0x00,0xCF,0x5A,0x00,0x30,0x8F,
+0x50,0x19,0x5A,0x06,0x1B,0x7A,0x04,0x9D,0x41,0x5D,0x4A,0x00,0xE4,0x00,0x00,0xB9,
+0x0F,0x5B,0x02,0xD6,0xBA,0x02,0xE4,0x1F,0x6A,0xFF,0x4F,0x7B,0x10,0x8F,0x6B,0x0F,
+0x7B,0x02,0xD7,0x5B,0x00,0xBC,0xD7,0x5B,0x02,0x4E,0x1F,0x6A,0xFE,0x4F,0x7B,0x10,
+0x8F,0x6B,0x0F,0x7B,0x02,0xD7,0x5B,0x01,0xD0,0x08,0xF8,0x20,0x09,0x18,0x22,0x88,
+0x6A,0x0F,0x16,0xB4,0x88,0x8B,0x88,0xAD,0x88,0xD5,0xE7,0xFF,0xE7,0x74,0x0F,0x16,
+0xB6,0x20,0x60,0x78,0x13,0x54,0x00,0x1F,0x6A,0xFE,0x8F,0x4C,0xCF,0x5A,0x00,0x30,
+0x8F,0x54,0x1B,0x7A,0x04,0x19,0x5A,0x06,0x19,0x5A,0x05,0xE4,0x00,0x00,0x21,0x9D,
+0x41,0x5D,0x4A,0x00,0x13,0x52,0x04,0xD7,0x4A,0xEB,0x35,0x13,0x52,0x04,0xD7,0x4A,
+0x03,0xE1,0x13,0x74,0x00,0x43,0x5B,0x64,0xCF,0xBA,0x00,0x30,0x8F,0xB4,0x13,0x9D,
+0x05,0xD5,0x5C,0x00,0x95,0x1D,0x5C,0x01,0x21,0xE0,0x20,0x11,0x5D,0x06,0x9D,0x42,
+0x5D,0x4A,0x00,0xCF,0x5A,0x00,0x30,0x8F,0x50,0x1A,0x7A,0x07,0x0D,0xDA,0x08,0x1F,
+0x4C,0x01,0x5F,0x5A,0x00,0x8A,0x3A,0x21,0xC9,0x06,0x8F,0x7A,0x1F,0x5B,0xFF,0xCF,
+0x7B,0x00,0x30,0xCF,0x5A,0x00,0x30,0x8F,0x50,0x42,0x3B,0x84,0x1C,0x9A,0x04,0x1C,
+0x71,0x04,0x0F,0x16,0xB4,0x0F,0x56,0xBC,0x50,0xA0,0x30,0xE4,0x00,0x47,0x7E,0x0F,
+0x56,0xBE,0x9B,0x61,0x13,0x5A,0x07,0x43,0x5B,0xD5,0x9D,0x82,0x1B,0x51,0x07,0x5F,
+0x4C,0x00,0x0F,0x16,0xB6,0x4E,0x3A,0x09,0x89,0x9A,0x13,0x52,0x04,0xD7,0x4A,0x00,
+0x69,0x0F,0x56,0xC2,0x8F,0x51,0xD3,0x41,0xFB,0x70,0x13,0x14,0x00,0x8D,0x98,0x88,
+0x71,0x19,0x94,0x00,0x0C,0x36,0xC6,0x0E,0xC1,0x1A,0x0E,0xA1,0x1E,0x0E,0x81,0x22,
+0x0E,0x61,0x26,0x0E,0x41,0x2A,0x0E,0x21,0x2E,0x0E,0x01,0x32,0x0D,0xE1,0x36,0x0D,
+0xC1,0x3A,0x0D,0xA1,0x3E,0x0D,0x81,0x42,0x0D,0x61,0x46,0x0D,0x41,0x4A,0x0D,0x21,
+0x4E,0x1C,0x21,0x50,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x04,0x37,0x85,0x29,
+0xC2,0xE0,0x10,0x01,0xEC,0x77,0x04,0x39,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,
+0x04,0x3B,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x04,0x3D,0x85,0x29,0xC2,0xE0,
+0x10,0x01,0xEC,0x77,0x04,0x3F,0x85,0x29,0xC2,0xE0,0x10,0x01,0xF8,0x77,0x04,0x40,
+0x85,0x29,0xC2,0xE0,0x10,0x01,0x1C,0x21,0xD0,0x0D,0x41,0x28,0x0D,0x61,0x24,0x0D,
+0xA1,0x1C,0x0D,0xE1,0x14,0x0E,0x21,0x0C,0x0E,0x41,0x08,0x0E,0x61,0x04,0x0E,0xC1,
+0x00,0x0D,0x21,0x2C,0x0D,0x81,0x20,0x0D,0xC1,0x18,0x0E,0x01,0x10,0xF3,0x37,0x0A,
+0xE5,0x1E,0xF9,0x07,0xC6,0xF7,0x01,0xF8,0x1E,0xC1,0x30,0x8A,0x21,0xC1,0xE0,0x10,
+0x01,0x40,0x21,0xBD,0xFD,0xEF,0x0B,0x34,0xC2,0x60,0x10,0x01,0x0A,0xEF,0x01,0x89,
+0xA3,0x8A,0x44,0x89,0x61,0x56,0xF7,0x10,0xFD,0x53,0x04,0x34,0x22,0xE0,0x20,0x9A,
+0xE1,0x1A,0xEA,0x00,0xC2,0xE0,0x10,0x01,0xC1,0xC0,0x10,0x01,0xF3,0x77,0x0A,0x5F,
+0xFD,0xCE,0x0C,0x08,0xC1,0x80,0x10,0x01,0x18,0x0E,0x00,0xFD,0x8C,0x0C,0x10,0x9B,
+0x00,0x8A,0xEC,0x9B,0x5F,0xE4,0x00,0x00,0x2B,0x0C,0x17,0x00,0x1B,0x57,0xFE,0x1B,
+0x57,0xFF,0x9F,0x01,0x1E,0xF7,0x30,0x5F,0x18,0x00,0xD7,0x1B,0xFF,0x7E,0xC2,0xE0,
+0x10,0x01,0x98,0x80,0xF0,0x77,0x0A,0xE8,0x40,0x79,0x1B,0xE4,0x00,0x99,0x60,0x98,
+0x80,0x98,0xA1,0x98,0xC0,0x10,0xEA,0x00,0x88,0x6D,0xE7,0xFF,0xF5,0x80,0x98,0x81,
+0x18,0x6B,0x00,0x5E,0x03,0x00,0x98,0xA1,0x88,0x6D,0x98,0xC0,0x10,0xEA,0x00,0xE7,
+0xFF,0xF5,0x56,0x18,0x6B,0x01,0x0B,0x0F,0x01,0x5E,0xE3,0x00,0x57,0x18,0x10,0x23,
+0x01,0xC8,0x26,0x04,0x33,0x26,0xE4,0x27,0x43,0x10,0xBC,0x23,0x09,0x9A,0x18,0x0A,
+0x00,0xC3,0x00,0x10,0x01,0xF3,0x18,0x09,0xB3,0x23,0x04,0x32,0x22,0x04,0x26,0x22,
+0xE4,0x1A,0x18,0x6A,0x00,0xC2,0xE0,0x10,0x01,0x18,0x0E,0x00,0xF3,0x37,0x0A,0x5F,
+0x9B,0x1F,0x9A,0xE0,0xE4,0x00,0x00,0x2B,0x0C,0x0C,0x00,0x1B,0x0C,0xFE,0x1B,0x0C,
+0xFF,0x9E,0xE1,0x1D,0x8C,0x30,0x5E,0xF7,0x00,0xD6,0xF9,0xFF,0x7E,0x98,0x80,0x98,
+0xA1,0x98,0xC0,0x10,0xEA,0x00,0x88,0x6D,0xE7,0xFF,0xF4,0x84,0x98,0x81,0x18,0x6B,
+0x00,0x98,0xA1,0x88,0x6D,0x98,0xC0,0x10,0xEA,0x00,0xE7,0xFF,0xF4,0x60,0x18,0x6B,
+0x01,0x0A,0xEF,0x01,0x56,0xF7,0x04,0xD2,0xE0,0x04,0xCA,0x13,0x0E,0x00,0xD3,0x01,
+0x04,0x91,0xC2,0xE0,0x10,0x01,0x98,0x60,0xF1,0xF7,0x0A,0xE8,0x1D,0x98,0xFF,0x8A,
+0xE3,0xC3,0x00,0x10,0x01,0x9A,0x01,0xFF,0x18,0x0B,0xC0,0xE4,0x00,0x00,0xDB,0xCF,
+0x37,0x00,0x30,0x8F,0x2E,0x11,0x19,0x07,0x13,0xB9,0x06,0x43,0x6F,0x43,0x5F,0x7B,
+0x00,0x43,0x9D,0xDC,0x4F,0x3C,0x10,0x8F,0x38,0x0A,0x72,0x00,0x0F,0x59,0x02,0x1F,
+0x37,0x01,0xCF,0xD9,0x00,0x30,0x8F,0xCE,0x10,0x9E,0x07,0xD4,0x88,0x01,0xC6,0x9F,
+0xA2,0x13,0xDE,0x06,0xD7,0xBE,0x01,0x7E,0x8F,0x7D,0x4F,0x7B,0x10,0x8F,0x78,0x0F,
+0x7B,0x02,0xD7,0x7A,0x01,0x0C,0x9F,0x81,0x43,0x5A,0x98,0x4F,0x9C,0x10,0x8F,0x98,
+0x0F,0x9C,0x02,0x43,0x7B,0xE5,0xD7,0x5B,0x00,0x68,0x4F,0x30,0xCC,0x44,0x63,0xCD,
+0x5C,0x63,0x00,0x9E,0xE1,0x5E,0xF7,0x00,0xD5,0x97,0xFC,0xBC,0xE7,0xFF,0xE7,0xD6,
+0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x0A,0xE5,0x26,0xE4,0x89,0x13,0x0B,0x00,0x27,0x04,
+0x73,0x12,0xEB,0x01,0x26,0xE4,0x5B,0x5F,0x17,0x17,0x88,0x6D,0x48,0xD7,0xC0,0x98,
+0x80,0x98,0xA2,0x10,0xEA,0x00,0xE7,0xFF,0xF2,0xC8,0x88,0x31,0x0E,0xC1,0x02,0x0E,
+0x61,0x06,0x0E,0x41,0x0A,0x0E,0x21,0x0E,0x0E,0x01,0x12,0x0D,0xE1,0x16,0x0D,0xC1,
+0x1A,0x0D,0xA1,0x1E,0x0D,0x81,0x22,0x0D,0x61,0x26,0x0D,0x41,0x2A,0x0D,0x21,0x2E,
+0x1C,0x21,0x30,0x85,0x29,0x1C,0x21,0x90,0x5C,0x63,0x00,0x0D,0x41,0x68,0x0D,0x61,
+0x64,0x0D,0x81,0x60,0x0D,0xA1,0x5C,0x0D,0xC1,0x58,0x0D,0xE1,0x54,0x0E,0x81,0x40,
+0x5D,0xE8,0x00,0x5C,0x84,0x00,0x5D,0xE1,0x3B,0xC2,0xE0,0x10,0x01,0xC1,0xA0,0x10,
+0x01,0xC1,0x80,0x10,0x01,0x0D,0x21,0x6C,0x0E,0x01,0x50,0x0E,0x21,0x4C,0x0E,0x41,
+0x48,0x0E,0x61,0x44,0x0E,0xA1,0x3C,0x0E,0xC1,0x38,0x0C,0x61,0x0C,0x0C,0x81,0x10,
+0x0C,0xC1,0x08,0x0C,0xE1,0x14,0x49,0xEF,0x52,0x99,0xC1,0x99,0x40,0x51,0x60,0xFF,
+0xFE,0x97,0x0C,0x08,0xFD,0xAD,0x0A,0xE4,0xFD,0x8C,0x04,0x36,0xE4,0x00,0x0A,0x13,
+0xE4,0x00,0x96,0xBE,0xCF,0x15,0x00,0x30,0x8F,0x14,0x0B,0x38,0x18,0x0B,0x58,0x16,
+0x0F,0x21,0x30,0x0F,0x41,0x28,0x0F,0x38,0x0E,0x0C,0x01,0x2C,0x0F,0x21,0x20,0x0C,
+0x01,0x34,0x0C,0x01,0x24,0x12,0x58,0x04,0x12,0x38,0x05,0x12,0x78,0x07,0x0F,0x38,
+0x0A,0xD3,0x20,0x2D,0x1A,0x23,0x25,0x3E,0x9B,0x0A,0x09,0x0D,0x0B,0x13,0xD4,0x00,
+0x41,0x0F,0x43,0x9A,0x01,0x41,0x08,0xC0,0x8B,0x0E,0xE4,0x00,0x00,0x65,0xCF,0x38,
+0x00,0x30,0x8F,0x34,0x13,0xB9,0x07,0x43,0xB0,0xED,0xD6,0x7D,0x00,0xEE,0x0F,0xB9,
+0x0A,0x23,0xA4,0x5A,0x0B,0xB9,0x16,0x43,0xBA,0xED,0x4F,0x3D,0xFA,0x47,0xB9,0xEE,
+0x43,0x3D,0xCD,0xD5,0x19,0x26,0x5C,0x9F,0x01,0x5F,0x18,0x00,0xD7,0xD8,0xFE,0x95,
+0xE4,0x00,0x0A,0x25,0x9A,0x00,0xD3,0x22,0x0B,0x7E,0x13,0xB4,0x00,0x8B,0x2E,0x9B,
+0xC1,0xE4,0x00,0x00,0x63,0xCF,0x59,0x00,0x30,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0C,
+0x08,0x8F,0x57,0x11,0x1A,0x07,0x41,0x1E,0x45,0xD6,0x68,0x00,0xA6,0x0D,0x1A,0x0A,
+0x21,0x08,0x36,0x11,0x18,0x06,0x13,0x5A,0x06,0xD5,0x1A,0x24,0x5A,0x9F,0x21,0x5F,
+0x39,0x00,0xD7,0xB9,0xFE,0x9D,0xE4,0x00,0x09,0xFB,0xEB,0x18,0x09,0xB9,0x57,0x18,
+0x80,0xD3,0x00,0x05,0x02,0xC3,0x00,0x10,0x01,0x1C,0x61,0x1C,0xEF,0x18,0x03,0xB6,
+0x08,0x81,0x19,0x88,0xB2,0x88,0xD1,0x88,0xF0,0x87,0x08,0xD0,0x60,0x07,0xEA,0xC2,
+0xF8,0x00,0x21,0xFE,0xF7,0xB6,0xFC,0x0C,0x77,0x02,0xC2,0xE0,0x10,0x01,0xFE,0xF7,
+0x01,0x58,0x98,0xA0,0x10,0x97,0x24,0xE4,0x00,0x95,0x90,0x13,0x0D,0x04,0x10,0x6D,
+0x01,0x98,0x81,0x40,0x63,0xC3,0xE4,0x00,0x93,0x2A,0x0E,0xE1,0x16,0x9E,0xC3,0x4E,
+0xD6,0x18,0x8E,0xD7,0x0B,0x16,0x04,0x0C,0x96,0x0A,0x40,0x84,0xC5,0x5C,0x9F,0xF9,
+0x0C,0x61,0x1E,0x48,0x84,0x00,0x88,0xB2,0x88,0xD1,0x88,0xF0,0xC3,0x00,0x10,0x01,
+0xEF,0x18,0x03,0xFA,0x87,0x08,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xB6,0xFC,0x0C,0x77,
+0x02,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x01,0x58,0x98,0xA1,0x10,0x97,0x24,0xE4,0x00,
+0x94,0xE2,0x13,0x0D,0x04,0x10,0x6D,0x01,0x98,0x81,0x40,0x63,0xC3,0xE4,0x00,0x92,
+0x7C,0x1C,0x61,0x1A,0x1C,0x81,0x24,0x88,0xB2,0x88,0xD1,0x88,0xF0,0xE7,0xFF,0xDF,
+0x90,0x20,0x61,0x9C,0x0B,0x01,0x18,0x0F,0x01,0x2C,0x0B,0x01,0x1A,0x0F,0x01,0x34,
+0x0E,0xE1,0x0E,0x22,0xE0,0x9C,0x0E,0xE1,0x12,0x22,0xE0,0x84,0xC2,0xF8,0x00,0x21,
+0xFE,0xF7,0xB7,0x00,0xC3,0x00,0x10,0x01,0x1C,0x61,0x2C,0xEF,0x18,0x03,0xFE,0x1C,
+0x81,0x34,0x0C,0xA1,0x26,0x0C,0xD7,0x02,0x87,0x08,0x0F,0x21,0x36,0x5F,0x3F,0xF9,
+0xCB,0x00,0x07,0xFF,0x4B,0x39,0x00,0xCF,0x53,0xFC,0x00,0xC3,0x20,0xFF,0xE8,0xFF,
+0x5A,0x04,0x00,0x4B,0x39,0xC0,0x9A,0x00,0xCF,0x39,0x03,0xFF,0x43,0x19,0xC0,0x8F,
+0x1A,0x0F,0x01,0x34,0xE4,0x00,0x00,0x23,0x0C,0x01,0x2C,0x0C,0x01,0x34,0x0C,0x01,
+0x24,0xE4,0x00,0x06,0x1F,0xC3,0x00,0x10,0x01,0x0F,0xA1,0x26,0xEA,0x38,0x0B,0x35,
+0x0E,0x41,0x22,0x57,0x11,0x02,0x23,0x00,0xE8,0x0E,0xE1,0x0A,0x0B,0x17,0x02,0xD6,
+0x58,0x00,0x44,0xD7,0xB8,0x01,0x38,0x53,0x00,0x64,0xD7,0xB2,0x00,0x5C,0x43,0x12,
+0xC0,0xE4,0x00,0x00,0x0F,0x43,0x1D,0xC0,0x0E,0xE1,0x0A,0x0B,0x37,0x05,0x43,0x18,
+0xCB,0x0B,0x2C,0x09,0x8F,0x19,0xE4,0x00,0x00,0x0F,0x0B,0x0C,0x09,0x0F,0x0C,0x07,
+0x0F,0x01,0x32,0x0F,0xC1,0x36,0x08,0x6C,0x07,0x42,0xD8,0xF5,0x8B,0x52,0x5E,0xD6,
+0x06,0x8B,0x3D,0x4D,0x16,0xFA,0x4C,0x63,0x08,0x46,0xC8,0xB6,0x41,0x16,0x45,0xD4,
+0x68,0x19,0x10,0xD6,0x5D,0x00,0x90,0x11,0x0C,0x0A,0x41,0x08,0xEB,0xD5,0x12,0x18,
+0xA0,0xE4,0x00,0x05,0xE7,0xD7,0xB2,0x18,0x60,0x11,0x0C,0x0A,0x41,0x08,0x93,0xD5,
+0x1D,0x18,0x10,0xE4,0x00,0x05,0xC3,0x89,0x16,0xD7,0xB2,0x00,0xD0,0x9B,0x21,0x43,
+0x99,0x9D,0x8B,0x38,0x89,0x11,0x8B,0x1E,0x5E,0x7C,0x00,0x8B,0xD9,0x8A,0x36,0x8B,
+0x5D,0x8B,0x32,0x40,0xBA,0xCC,0x40,0x68,0x8D,0x42,0x5A,0xCD,0x5C,0x7F,0xF9,0x4F,
+0xB2,0xFA,0x4A,0xDA,0xC8,0x46,0x5D,0x96,0x48,0x99,0xD0,0x42,0x52,0xED,0x9E,0x41,
+0x42,0x52,0x28,0x4C,0xA3,0xFA,0xCE,0x52,0xFF,0xF6,0x44,0x65,0x1E,0x9E,0x4A,0x40,
+0xA3,0x2D,0x26,0x44,0x17,0x9A,0x42,0x5F,0xB2,0x00,0x52,0x40,0x14,0x43,0xA5,0xE8,
+0x5F,0xBD,0x06,0x5F,0xA2,0x79,0x4B,0xBD,0x90,0x42,0x44,0xB4,0x26,0x41,0x10,0x8E,
+0x28,0x4C,0x71,0xFA,0x46,0x23,0x8E,0x42,0x31,0x1D,0x4E,0x31,0x0A,0x5C,0x71,0x06,
+0x40,0xA3,0xED,0x8C,0x7D,0x40,0x85,0x23,0x42,0xC3,0xB3,0x8E,0xC4,0x42,0x56,0x90,
+0x42,0x32,0x8D,0x5E,0x52,0x06,0x5E,0x31,0x06,0x4E,0xD1,0xFA,0x46,0x36,0x8E,0x42,
+0x31,0xB5,0x41,0x08,0x8B,0x42,0x3D,0x8D,0x42,0x52,0x8B,0x8D,0x12,0x41,0x08,0xE8,
+0xCF,0xB5,0x00,0x30,0x8F,0xB4,0x0D,0x1D,0x17,0xC3,0xA0,0x10,0x01,0xF3,0xBD,0x04,
+0x40,0x41,0x19,0xEB,0xD7,0x48,0x01,0x34,0x4D,0x19,0x08,0xD5,0x1A,0x01,0x0C,0x4D,
+0x1D,0x08,0xCE,0x3A,0xFF,0xFE,0x41,0x08,0xCB,0x9F,0xBE,0x8D,0x11,0x43,0xBD,0xD3,
+0x43,0x28,0xCB,0x43,0x39,0xE8,0xE4,0x00,0x00,0x0D,0x9B,0x20,0x22,0x60,0x26,0x8B,
+0x99,0x8B,0x3A,0x8B,0x5C,0x43,0xB8,0xF4,0x42,0x39,0xD4,0x4F,0x9D,0xFA,0x47,0xBC,
+0xEE,0x43,0xBD,0xE5,0x4F,0xBD,0x0A,0x5D,0x1D,0x06,0x26,0x21,0x54,0x43,0x98,0x45,
+0xFF,0x9C,0x01,0x2B,0xC3,0x80,0x4A,0xCE,0x20,0x01,0x1D,0x43,0xD8,0xF5,0x4F,0x9E,
+0xFA,0x47,0xDC,0xF6,0x43,0x9E,0xE5,0x4F,0x9C,0x0A,0x9F,0x81,0x5F,0x9C,0x06,0x43,
+0xC8,0xE5,0x8D,0x1C,0x43,0x48,0xD3,0x43,0x3E,0xCB,0x8F,0x3A,0x43,0x39,0x88,0x43,
+0xB9,0xED,0x5F,0x39,0x06,0x5F,0xBD,0x06,0x4F,0x5D,0xFA,0x47,0xBA,0xEE,0x43,0xBD,
+0xD5,0x43,0x18,0xEB,0x43,0xBC,0xED,0x43,0x39,0xEB,0x8F,0x19,0x43,0x18,0xE0,0xCF,
+0x35,0x00,0x30,0x8F,0x34,0x0F,0x19,0x19,0xE4,0x00,0x01,0x91,0xD7,0xB2,0x00,0xB0,
+0x9B,0x01,0x8B,0x32,0x43,0x98,0x9D,0x8B,0x5D,0x5E,0x7C,0x00,0x8B,0x1E,0xE4,0x00,
+0x00,0x11,0x8B,0x3D,0x8B,0x52,0xC3,0xC0,0x10,0x01,0xF3,0xDE,0x04,0x40,0x40,0x79,
+0xF3,0xD7,0x43,0x01,0x34,0x4C,0x79,0x08,0xD4,0x7A,0x01,0x0C,0x4C,0x7E,0x08,0xCC,
+0x9A,0xFF,0xFE,0x40,0x63,0xCB,0x9F,0xDE,0x8C,0x64,0x43,0xDE,0xD3,0x43,0x23,0xCB,
+0x43,0x39,0xF0,0xE4,0x00,0x00,0x0D,0x9B,0x20,0x22,0x60,0x26,0x8B,0x99,0x8B,0x3A,
+0x8B,0x5C,0x43,0x99,0xD4,0x27,0x81,0x50,0xC3,0x00,0x7F,0xEC,0x20,0x00,0x49,0xCB,
+0xC0,0x04,0x00,0x43,0xDE,0xC5,0xC3,0xC0,0x25,0x68,0xE4,0x00,0x00,0x11,0xC3,0x00,
+0xA5,0x68,0x4B,0xC1,0x01,0x23,0xC0,0xD0,0xCF,0x5A,0x04,0x50,0x53,0xC0,0x50,0xCF,
+0x39,0x03,0xB0,0x8F,0x3A,0x43,0x39,0xE0,0xFF,0x99,0xFC,0x00,0x5F,0x39,0x06,0x5F,
+0x9C,0x06,0x4F,0x5C,0xFA,0x47,0x9A,0xE6,0x43,0x9C,0xD5,0x43,0x18,0xE3,0x43,0x9E,
+0xE5,0x43,0x39,0xE3,0x8F,0x19,0x43,0x18,0xF0,0xCF,0x35,0x00,0x30,0x42,0x52,0xB3,
+0x8F,0x34,0x42,0x3D,0x8B,0x0F,0x19,0x19,0x8E,0x32,0x41,0x11,0x40,0x0D,0x19,0x17,
+0xCF,0x75,0x00,0x30,0x8F,0x74,0x0F,0x1B,0x0A,0x23,0x04,0x62,0x9B,0x22,0x0F,0x3B,
+0x08,0x22,0x00,0xFC,0xCF,0x2B,0x00,0x30,0x8F,0x34,0x0C,0x19,0x08,0xE4,0x00,0x00,
+0x55,0x23,0x08,0xBE,0xCF,0x0B,0x00,0x30,0x8F,0x14,0x0C,0x18,0x08,0x9B,0x01,0xE4,
+0x00,0x00,0x31,0x0C,0x18,0x08,0xCF,0x0B,0x00,0x30,0x8F,0x14,0x0C,0x18,0x08,0x9B,
+0x01,0x4F,0x78,0xAC,0x45,0x4A,0xDD,0x4F,0x18,0x5C,0x45,0x58,0x55,0x5D,0x4A,0x00,
+0x9D,0xC1,0x5D,0xCE,0x00,0x1F,0x6E,0xFF,0xC2,0xF8,0x00,0x21,0x5E,0xBB,0x00,0xFE,
+0xF7,0xB6,0xF8,0x13,0x14,0x00,0x0C,0x77,0x02,0x10,0x8D,0x00,0x98,0xA1,0xD7,0x15,
+0xD7,0x15,0xE4,0x00,0x8C,0x7A,0x88,0x6A,0xE7,0xFF,0xDB,0xFE,0x13,0x14,0x00,0x5F,
+0x38,0x00,0x27,0x28,0x15,0x9B,0x02,0x1B,0x14,0x00,0xE4,0x00,0x01,0x4D,0x89,0x78,
+0xE4,0x00,0x00,0x0D,0x89,0x79,0xCF,0x0B,0x00,0x30,0x8F,0x14,0x0B,0x38,0x16,0x9A,
+0x01,0x0F,0x21,0x2C,0x0B,0x38,0x18,0x0F,0x18,0x0E,0x0F,0x21,0x34,0x0F,0x01,0x24,
+0xE7,0xFF,0xF9,0x2B,0x41,0x12,0xEC,0xCE,0xD5,0x00,0x30,0x8E,0xD4,0x0D,0x16,0x0C,
+0x54,0x71,0x08,0x0E,0xC1,0x2A,0x0E,0x21,0x2E,0xD0,0x60,0xF3,0x9A,0xE7,0xFF,0xFA,
+0x15,0xCF,0x15,0x00,0x30,0x8F,0x14,0x0F,0x38,0x0A,0xD3,0x22,0xFB,0xB6,0xE7,0xFF,
+0xFE,0xAB,0xC3,0x00,0x10,0x01,0x9A,0xC1,0xE8,0xF8,0x09,0xB9,0x0F,0x01,0x04,0x42,
+0xD6,0x9D,0x54,0xE7,0x40,0x5E,0x16,0x00,0x1C,0x61,0x18,0x88,0x92,0x88,0xB1,0x88,
+0xD0,0x4C,0xE7,0x31,0xE7,0xFF,0xDD,0x3C,0x0F,0x01,0x06,0xD0,0x60,0xD8,0x7E,0xE7,
+0xFF,0xF8,0x53,0xCF,0x15,0x00,0x30,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0C,0x08,0x8F,
+0x17,0x0C,0x18,0x08,0x9B,0x01,0x4F,0x78,0xAC,0x45,0x4A,0xDD,0xE7,0xFF,0xFE,0x43,
+0x0E,0xC1,0x3A,0x0E,0xA1,0x3E,0x0E,0x81,0x42,0x0E,0x61,0x46,0x0E,0x41,0x4A,0x0E,
+0x21,0x4E,0x0E,0x01,0x52,0x0D,0xE1,0x56,0x0D,0xC1,0x5A,0x0D,0xA1,0x5E,0x0D,0x81,
+0x62,0x0D,0x61,0x66,0x0D,0x41,0x6A,0x0D,0x21,0x6E,0x1C,0x21,0x70,0x85,0x29,0x20,
+0x60,0x2E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x01,0x2C,0x85,0x29,0x20,0x60,0x4E,0xC2,
+0xE0,0x10,0x01,0xEC,0x97,0x00,0xF0,0xC2,0xE0,0x10,0x01,0xEC,0xB7,0x01,0x28,0x85,
+0x29,0x20,0x60,0x5E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x04,0x48,0xC2,0xE0,0x10,0x01,
+0xEC,0xB7,0x04,0x4C,0xE4,0x00,0x00,0x5D,0x20,0x64,0x5E,0xC2,0xE0,0x10,0x01,0xEC,
+0x97,0x04,0x7C,0xC2,0xE0,0x10,0x01,0xEC,0xB7,0x04,0x70,0xE4,0x00,0x00,0x2F,0x20,
+0x68,0x4E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x04,0x68,0xC2,0xE0,0x10,0x01,0xEC,0xB7,
+0x04,0x44,0x85,0x29,0x20,0x68,0x2E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x04,0x64,0x85,
+0x29,0x5C,0x84,0x04,0x20,0x60,0x3E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x01,0x33,0xE4,
+0x00,0x00,0x3D,0x20,0x64,0x3E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x01,0x15,0xE4,0x00,
+0x00,0x1F,0x20,0x68,0x2E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x01,0x35,0x85,0x29,0x5C,
+0x84,0x04,0x20,0x60,0x3E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x00,0xF5,0xE4,0x00,0x00,
+0x3D,0x20,0x64,0x3E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x01,0x31,0xE4,0x00,0x00,0x1F,
+0x20,0x68,0x2E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x01,0x0D,0x85,0x29,0x5C,0x84,0x04,
+0x20,0x68,0x2E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x01,0x0F,0x85,0x29,0x1C,0x21,0xC8,
+0x0D,0x21,0x34,0x0D,0x41,0x30,0x0D,0x61,0x2C,0x0D,0x81,0x28,0x0D,0xA1,0x24,0x0D,
+0xC1,0x20,0x0D,0xE1,0x1C,0x0E,0x01,0x18,0x0E,0x21,0x14,0x0E,0x41,0x10,0x0E,0x61,
+0x0C,0x0E,0x81,0x08,0x0E,0xA1,0x04,0x0E,0xC1,0x00,0x20,0x65,0x70,0x20,0x60,0x4C,
+0xD0,0x62,0x04,0x42,0x99,0xC0,0x89,0xEE,0xD0,0x63,0x06,0x66,0xE4,0x00,0x01,0x71,
+0xC2,0xE0,0x10,0x01,0xEE,0xD7,0x00,0xF2,0xC2,0xE0,0x10,0x01,0xEE,0xB7,0x01,0x2A,
+0xC2,0xE0,0x10,0x01,0xEE,0x97,0x04,0x4A,0xC2,0xE0,0x10,0x01,0xEE,0x77,0x04,0x4E,
+0xC2,0xE0,0x10,0x01,0xE9,0xF7,0x01,0x33,0xC2,0xE0,0x10,0x01,0x9A,0x00,0xE9,0xD7,
+0x00,0xF5,0x99,0xA0,0xC2,0xE0,0x10,0x01,0x9A,0x21,0xED,0x77,0x01,0x2E,0x9A,0x45,
+0x89,0x90,0xE4,0x00,0x00,0xD9,0xC2,0xE0,0x10,0x01,0xEE,0x97,0x04,0x7E,0xC2,0xE0,
+0x10,0x01,0xEE,0x77,0x04,0x72,0xC2,0xE0,0x10,0x01,0x99,0xA0,0xE9,0xF7,0x01,0x15,
+0x9A,0x00,0xC2,0xE0,0x10,0x01,0x8A,0x2D,0xE9,0xD7,0x01,0x31,0x9A,0x40,0x99,0x61,
+0x89,0x90,0x9A,0xA0,0xE4,0x00,0x00,0x71,0xC2,0xE0,0x10,0x01,0xEE,0x97,0x04,0x6A,
+0xC2,0xE0,0x10,0x01,0xEE,0x17,0x04,0x66,0xC2,0xE0,0x10,0x01,0xE9,0xF7,0x01,0x35,
+0xC2,0xE0,0x10,0x01,0x99,0x81,0xE9,0xD7,0x01,0x0D,0x9A,0x21,0xC2,0xE0,0x10,0x01,
+0x9A,0x40,0xE9,0xB7,0x01,0x0F,0x99,0x61,0x9A,0x60,0x8A,0xAC,0x9A,0xC1,0x99,0x41,
+0xE4,0x00,0x00,0x55,0xC2,0xE0,0x10,0x01,0xE9,0xF7,0x01,0x33,0xC2,0xE0,0x10,0x01,
+0xE9,0xD7,0x00,0xF5,0x99,0xA0,0x9A,0x40,0x9A,0x00,0x9A,0x80,0x9A,0xA0,0x8A,0x2D,
+0x89,0x72,0x8A,0x70,0x89,0x94,0x8A,0xD5,0x99,0x40,0x88,0x6A,0xE4,0x00,0xD7,0x98,
+0x88,0x6A,0xE4,0x00,0xD8,0x1A,0x88,0x76,0xE4,0x00,0xEB,0xC8,0x88,0x75,0xE4,0x00,
+0xEC,0x22,0x88,0x74,0xE4,0x00,0xD9,0x7A,0x88,0x73,0xE4,0x00,0xD9,0xC6,0x88,0x72,
+0xE4,0x00,0xD8,0xC8,0x88,0x71,0xE4,0x00,0xD8,0xF4,0x88,0x6A,0xE4,0x00,0xED,0x44,
+0x88,0x70,0xE4,0x00,0xED,0x9E,0x98,0x60,0xE4,0x00,0xED,0xEC,0x98,0x60,0xE4,0x00,
+0xEE,0x3A,0x98,0x60,0xE4,0x00,0xEE,0x88,0x98,0x60,0xE4,0x00,0xEE,0xD6,0x88,0x6F,
+0xE4,0x00,0xD9,0xC0,0x88,0x6E,0xE4,0x00,0xD9,0xEE,0x88,0x6D,0xE4,0x00,0xDA,0x22,
+0x88,0x6C,0xE4,0x00,0xDA,0x3C,0x88,0x6B,0x0E,0xC1,0x02,0x0E,0xA1,0x06,0x0E,0x81,
+0x0A,0x0E,0x61,0x0E,0x0E,0x41,0x12,0x0E,0x21,0x16,0x0E,0x01,0x1A,0x0D,0xE1,0x1E,
+0x0D,0xC1,0x22,0x0D,0xA1,0x26,0x0D,0x81,0x2A,0x0D,0x61,0x2E,0x0D,0x41,0x32,0x0D,
+0x21,0x36,0x1C,0x21,0x38,0xE4,0x00,0xD7,0x85,0xC2,0xE0,0x10,0x01,0xF0,0x77,0x04,
+0x60,0x85,0x29,0xC2,0xE0,0x10,0x01,0xF8,0x77,0x04,0x60,0x85,0x29,0xC2,0xE0,0x10,
+0x01,0xF3,0x17,0x04,0x60,0x9F,0x01,0xFB,0x17,0x04,0x60,0x85,0x29,0xC2,0xE0,0x10,
+0x01,0xF0,0x77,0x04,0x80,0x85,0x29,0xC2,0xE0,0x10,0x01,0xF8,0x77,0x04,0x80,0x85,
+0x29,0xC2,0xE0,0x10,0x01,0xF3,0x17,0x04,0x80,0x9F,0x01,0xFB,0x17,0x04,0x80,0x85,
+0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x01,0x08,0x85,0x29,0xC3,0x40,0x10,0x01,0xFF,
+0x5A,0x00,0xF8,0x0C,0x1A,0x00,0x9A,0xE1,0xC3,0x20,0x10,0x01,0xFF,0x39,0x01,0x18,
+0x0E,0xF9,0x00,0xC3,0x00,0x10,0x01,0xFF,0x18,0x04,0x50,0x0C,0x18,0x00,0x0C,0x1A,
+0x04,0x0E,0xF9,0x04,0x0C,0x18,0x04,0x0C,0x1A,0x08,0x0E,0xF9,0x08,0x0C,0x18,0x08,
+0x0C,0x1A,0x0C,0x0E,0xF9,0x0C,0x0C,0x18,0x0C,0xC3,0x00,0x10,0x01,0xEE,0xF8,0x01,
+0x10,0x85,0x29,0x9C,0x38,0x0D,0x41,0x04,0xC2,0xE0,0x10,0x01,0xC3,0x00,0x10,0x01,
+0x5C,0xA5,0x00,0x5C,0xC6,0x00,0xF3,0x37,0x04,0x78,0xFF,0x18,0x01,0x10,0xD7,0x25,
+0x00,0x6A,0xF8,0xB7,0x04,0x78,0x9A,0xE1,0x0E,0xF8,0x00,0xC3,0x80,0x10,0x01,0xC2,
+0xE0,0x10,0x01,0x0F,0x38,0x02,0xFF,0x9C,0x01,0x18,0xFE,0xF7,0x00,0xF8,0x23,0x24,
+0x9A,0x0B,0xA3,0x00,0x4F,0x46,0x18,0x43,0x77,0xD4,0x0F,0xBB,0x00,0x0B,0xA4,0x00,
+0x0F,0xBB,0x04,0x8F,0x5C,0x0F,0x3A,0x00,0x0F,0x3A,0x04,0x40,0xA5,0x35,0x20,0xA4,
+0x1A,0x0C,0x18,0x00,0x4F,0x46,0x18,0x8F,0x57,0x0F,0x3A,0x02,0x0F,0x5A,0x02,0x0B,
+0x03,0x00,0x8B,0x77,0x43,0x39,0xC5,0x27,0x3C,0x2A,0x43,0x58,0xD5,0xE4,0x00,0x00,
+0x0F,0x43,0x5A,0xC5,0x4F,0x26,0x18,0x8F,0x3B,0x0F,0x79,0x02,0x0F,0x39,0x02,0x43,
+0x7B,0xC5,0x27,0x7C,0x2A,0x43,0x18,0xCD,0xE4,0x00,0x00,0x0F,0x43,0x19,0xC5,0x43,
+0x7A,0xC3,0x4F,0x46,0x18,0x8F,0x57,0x0F,0x3A,0x06,0x0F,0x5A,0x06,0x0B,0x04,0x00,
+0x8B,0xB7,0x43,0x39,0xC5,0x27,0x3C,0x2A,0x43,0x58,0xD5,0xE4,0x00,0x00,0x0F,0x43,
+0x5A,0xC5,0x4F,0x26,0x18,0x8F,0x3D,0x0F,0xB9,0x06,0x0F,0x39,0x06,0x43,0xBD,0xC5,
+0x27,0xBC,0x2A,0x43,0x18,0xCD,0xE4,0x00,0x00,0x0F,0x43,0x19,0xC5,0x43,0x1A,0xC3,
+0x9B,0x23,0x8F,0x1B,0x9B,0x41,0xE4,0x00,0x00,0x11,0x8F,0x59,0x9F,0x22,0xD7,0x58,
+0xFF,0xE1,0x4F,0x19,0x09,0xC3,0x20,0x10,0x01,0x9F,0x1F,0x53,0x40,0x1E,0x5F,0x18,
+0x06,0xEF,0x19,0x04,0x74,0xC3,0x20,0x10,0x01,0x43,0x18,0xD1,0xEF,0x39,0x01,0x0A,
+0x43,0x18,0xC3,0x43,0x39,0xC5,0xC3,0x00,0x10,0x01,0x5F,0x23,0x11,0x20,0x00,0x1B,
+0x53,0x20,0x19,0xEF,0x38,0x04,0x6C,0xC3,0xA0,0x10,0x01,0xEC,0xB8,0x04,0x6E,0x4C,
+0xC6,0x08,0x9B,0x00,0xFF,0xBD,0x04,0x50,0xCB,0x40,0x10,0x00,0x43,0x26,0xC4,0x4F,
+0x39,0x10,0x43,0x7C,0xCC,0xC9,0x40,0xA0,0x00,0x0D,0x1B,0x02,0x0F,0xDB,0x02,0x43,
+0x68,0x53,0xCF,0xDE,0x00,0x0A,0x8F,0xC5,0x43,0xDB,0xF0,0x43,0x7D,0xCC,0x0F,0xDB,
+0x00,0x5F,0xD8,0x00,0x23,0xC0,0x92,0x43,0xD7,0xCC,0x0D,0x1E,0x02,0x0F,0x7B,0x02,
+0x0F,0x3E,0x02,0x0B,0xC3,0x00,0x43,0x3E,0xCD,0x43,0x3B,0xCB,0x43,0x39,0xD0,0x8F,
+0x28,0x0F,0x23,0x01,0xE4,0x00,0x00,0x43,0x43,0xD7,0xCC,0x0D,0x1E,0x02,0x0F,0x7B,
+0x02,0x0F,0x3E,0x02,0x0B,0xC4,0x00,0x43,0x3E,0xCD,0x43,0x3B,0xCB,0x43,0x39,0xD0,
+0x8F,0x28,0x0F,0x24,0x01,0x43,0x66,0xC4,0x4F,0x7B,0x10,0x43,0xD7,0xDC,0x0F,0x3E,
+0x00,0x43,0x3C,0xDC,0x8F,0x7D,0x0F,0xD9,0x02,0x0D,0x1B,0x02,0x0F,0x79,0x02,0x43,
+0x68,0xDB,0x43,0x7B,0xD0,0x43,0x7E,0xDD,0x0F,0x79,0x00,0x9F,0x01,0xD3,0x02,0xFB,
+0x7E,0x0D,0x41,0x06,0x9C,0x28,0x85,0x29,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x04,0xAE,
+0x13,0x17,0x20,0x43,0x37,0xC4,0x9F,0x01,0x18,0x79,0x00,0x5F,0x18,0x00,0x1B,0x17,
+0x20,0xC3,0x20,0x10,0x01,0xC2,0xE0,0x10,0x01,0x5F,0x04,0xDB,0xFF,0x39,0x05,0x30,
+0xFE,0xF7,0x05,0x82,0x20,0x00,0x91,0x4F,0x18,0x08,0xC3,0x40,0x10,0x01,0x8F,0x38,
+0xEB,0x5A,0x05,0x25,0x8F,0x17,0x0F,0x59,0x01,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x06,
+0x31,0x0E,0xF8,0x01,0xE4,0x00,0x00,0x1D,0xFF,0x00,0x7F,0xFF,0x0F,0x19,0x4F,0x0F,
+0x17,0x4F,0x85,0x29,0xC3,0x00,0x10,0x01,0x5C,0x84,0x02,0x9A,0xE0,0xFF,0x18,0x04,
+0xAE,0xE4,0x00,0x00,0x51,0x43,0x38,0xBC,0x43,0x63,0xBC,0x13,0x59,0x00,0x9E,0xE1,
+0x8F,0x44,0x5E,0xF7,0x00,0x1F,0x5A,0x40,0x4F,0x3A,0xFA,0x4F,0x39,0xD1,0x8F,0x59,
+0x57,0x5A,0x3F,0x43,0x3A,0xCD,0x1B,0x3B,0x00,0x13,0x38,0x20,0xD7,0x37,0xFE,0xCD,
+0x85,0x29,0xC3,0x18,0x00,0x21,0x5F,0x23,0x00,0xFF,0x18,0xB7,0x08,0x9A,0xE0,0x5C,
+0x77,0x00,0x0B,0x78,0x01,0x9B,0x5F,0x5C,0x62,0x01,0x20,0x00,0x19,0x0B,0x58,0x03,
+0xD7,0x64,0x01,0x7D,0xD7,0x44,0x01,0x59,0x23,0x24,0x36,0x40,0x60,0xBD,0x54,0x63,
+0x3F,0xE4,0x00,0x00,0x57,0x23,0x28,0x2A,0x1C,0x63,0x20,0xE4,0x00,0x00,0x1B,0x23,
+0x2C,0x76,0x52,0xE0,0x20,0x40,0x77,0x1D,0x5C,0x63,0x00,0xE4,0x00,0x00,0x23,0x9E,
+0xE1,0x9F,0x02,0x5E,0xE2,0x29,0x23,0xFE,0xE5,0x50,0x60,0xFF,0x85,0x29,0xC2,0xE0,
+0x10,0x01,0xFE,0xF7,0x04,0x8A,0x0B,0x17,0x07,0x0A,0xF7,0x01,0x40,0x63,0xC3,0x40,
+0x63,0xB8,0x9A,0xEA,0x40,0x63,0xB8,0x85,0x29,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x01,
+0x38,0x0B,0x17,0x06,0x0A,0xF7,0x04,0xD7,0x17,0x00,0x92,0xCC,0x63,0x07,0xD0,0x42,
+0xF8,0xBD,0x40,0x63,0xB8,0xE4,0x00,0x00,0x0D,0x98,0x60,0x85,0x29,0x8B,0x23,0x20,
+0x80,0x96,0xC2,0xE0,0x10,0x01,0x98,0x60,0xFE,0xF7,0x01,0x38,0x0B,0x17,0x02,0x0A,
+0xF7,0x00,0xD7,0x17,0x00,0xDA,0xCC,0x79,0x07,0xD0,0x42,0xF8,0xBD,0x40,0x63,0xB8,
+0xE4,0x00,0x00,0x1B,0x20,0x84,0x1E,0xE7,0xFF,0xFF,0x65,0x98,0x60,0x85,0x29,0x5C,
+0x84,0x00,0x5C,0xA5,0x00,0x4C,0x84,0x30,0x5C,0xC6,0x00,0x8C,0x85,0x4C,0x84,0x08,
+0x8C,0x64,0xD0,0xC8,0x00,0x59,0x0C,0x03,0x01,0xE4,0x00,0x00,0x3F,0x52,0xE0,0x64,
+0x20,0xC0,0x54,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xB7,0x04,0x9C,0xC1,0x4C,0xC6,0x0A,
+0x8C,0xD7,0x12,0xE6,0xFF,0x0E,0xE3,0x01,0x85,0x29,0xFC,0x21,0xFE,0x88,0xEE,0x21,
+0x01,0x54,0xEE,0x41,0x01,0x50,0xED,0x21,0x01,0x74,0xED,0x41,0x01,0x70,0xED,0x61,
+0x01,0x6C,0xED,0x81,0x01,0x68,0xED,0xA1,0x01,0x64,0xED,0xC1,0x01,0x60,0xED,0xE1,
+0x01,0x5C,0xEE,0x01,0x01,0x58,0xEE,0x61,0x01,0x4C,0xEE,0x81,0x01,0x48,0xEE,0xA1,
+0x01,0x44,0x5E,0x23,0x00,0x8A,0x44,0x5C,0xA5,0x00,0x4F,0x11,0x08,0x9A,0xE1,0xD4,
+0xB8,0x00,0x94,0x43,0x18,0x28,0x9A,0xE0,0x23,0x00,0x24,0x1E,0xF8,0x01,0x5E,0xF7,
+0x00,0x43,0x05,0xBB,0x5F,0x08,0x11,0x20,0x00,0x21,0x9E,0xFF,0x5E,0xF7,0x00,0x42,
+0x17,0x2B,0x8B,0x41,0x5E,0x10,0x00,0x9B,0x00,0x41,0xD0,0x8D,0x9D,0xC2,0x5D,0xCE,
+0x00,0xE4,0x00,0x00,0x4D,0x43,0x7A,0xCC,0x13,0xBC,0x00,0x9F,0x21,0x1B,0xBB,0x00,
+0xE4,0x00,0x00,0x13,0x9B,0x20,0x43,0x86,0xC4,0x5F,0x79,0x00,0xD6,0xFB,0xFF,0x4D,
+0x9F,0x01,0x8F,0x57,0x5F,0x18,0x00,0xD7,0x05,0xFF,0x6E,0x99,0x60,0x52,0x80,0x40,
+0xE4,0x00,0x01,0xC9,0x21,0x60,0x56,0x13,0x12,0x00,0x1E,0xE1,0x00,0x1F,0x18,0x40,
+0x8E,0xED,0x12,0xF7,0x00,0xE4,0x00,0x00,0x21,0x13,0x15,0x00,0x42,0xF3,0x6C,0x1F,
+0x18,0x40,0x12,0xF7,0xFF,0x43,0x18,0xBD,0x4E,0xF8,0xFA,0x4E,0xF7,0xD1,0x40,0xD8,
+0xBC,0x54,0xC6,0x3F,0x40,0xC6,0xBD,0x5C,0xC6,0x00,0x5C,0xC4,0x13,0x20,0x00,0x25,
+0x40,0xD4,0x35,0x5C,0xC6,0x00,0x1C,0x61,0x40,0x21,0x60,0x7A,0x98,0x80,0x88,0xAC,
+0xE7,0xFF,0xFD,0x9E,0x21,0x81,0x78,0x0B,0x0A,0x81,0xEA,0xEA,0xFF,0x7F,0x8E,0xF8,
+0x0E,0xEA,0x81,0xE4,0x00,0x00,0x9F,0x98,0x81,0x88,0xAC,0x21,0x64,0x56,0xE7,0xFF,
+0xFD,0x62,0x21,0x81,0x00,0x0B,0x0A,0xFF,0xEA,0xEA,0xFF,0x7F,0xE4,0x00,0x00,0x45,
+0xE7,0xFF,0xFD,0x3E,0x21,0x80,0x52,0xEB,0x01,0x00,0xC1,0x0A,0xE1,0x41,0x8E,0xF8,
+0xEE,0xE1,0x00,0xC1,0xE4,0x00,0x00,0x3D,0x0B,0x0A,0xFF,0x0A,0xEA,0x81,0x5F,0x57,
+0x04,0x5F,0x38,0x04,0xD7,0x3A,0x00,0x31,0x8A,0xF8,0x0B,0x0A,0x01,0x8E,0xF8,0x0E,
+0xEA,0x01,0x9D,0xA1,0x9D,0x42,0x5D,0x8D,0x00,0xD5,0xCC,0xFA,0x5D,0x21,0x60,0x76,
+0x9D,0x61,0x5D,0x6B,0x00,0xE4,0x00,0x00,0x3F,0x0B,0x0F,0x01,0x9E,0xE1,0x0F,0x0F,
+0x81,0x5E,0xF7,0x00,0x9D,0xE2,0xE4,0x00,0x00,0x0D,0x9A,0xE0,0xD6,0xEE,0xFF,0x6E,
+0xE7,0xFF,0xFF,0xC1,0xD5,0x71,0x00,0xC2,0xFD,0xE1,0x00,0xC0,0x1E,0x61,0x00,0x89,
+0x4F,0x99,0xA0,0x42,0xB2,0x5C,0x8E,0x6B,0xE7,0xFF,0xFF,0x7D,0x21,0x64,0x26,0x9D,
+0xDF,0xE4,0x00,0x00,0x0F,0x1D,0xCE,0x3F,0xFE,0xE1,0x01,0x40,0x4D,0xCE,0x08,0x8D,
+0xD7,0xE8,0x6E,0xFF,0x01,0x42,0x03,0x80,0xEE,0xA1,0x01,0x46,0x5C,0x70,0x00,0xEE,
+0x81,0x01,0x4A,0xEE,0x61,0x01,0x4E,0xEE,0x41,0x01,0x52,0xEE,0x21,0x01,0x56,0xEE,
+0x01,0x01,0x5A,0xED,0xE1,0x01,0x5E,0xED,0xC1,0x01,0x62,0xED,0xA1,0x01,0x66,0xED,
+0x81,0x01,0x6A,0xED,0x61,0x01,0x6E,0xED,0x41,0x01,0x72,0xED,0x21,0x01,0x76,0xFC,
+0x21,0x01,0x78,0x85,0x29,0x5C,0x84,0x06,0x5C,0xA5,0x06,0x43,0x24,0x2C,0x9B,0x02,
+0x43,0x19,0xC0,0x53,0x20,0x1E,0x5E,0xE3,0x06,0xC7,0x18,0xFF,0xFF,0x40,0x84,0x2D,
+0x98,0x60,0xCC,0x84,0x00,0x0A,0x40,0x84,0xC8,0xC4,0x84,0xFF,0xFF,0x43,0x38,0x25,
+0xD6,0xF9,0x00,0x60,0x8C,0x98,0x5C,0x97,0x1D,0x48,0x61,0x01,0x85,0x29,0x24,0x80,
+0x68,0x24,0x7C,0x34,0xCE,0xE3,0x03,0xE8,0x98,0x61,0xE4,0x00,0x00,0x49,0xCE,0xE3,
+0xFC,0x18,0x98,0x64,0xE4,0x00,0x00,0x35,0x20,0x80,0x74,0x24,0x7C,0x34,0xCE,0xE3,
+0xFC,0x18,0x98,0x62,0xE4,0x00,0x00,0x15,0xCE,0xE3,0x03,0xE8,0x98,0x63,0x40,0x97,
+0x20,0xE7,0xFF,0xF9,0x23,0x9A,0xE0,0x20,0x60,0x3C,0x5C,0x60,0x11,0x52,0xE0,0x30,
+0x53,0x00,0x10,0x4A,0xF8,0xB8,0x88,0x77,0x85,0x29,0x0A,0xE3,0x00,0x26,0xFC,0x60,
+0xC3,0x00,0x10,0x01,0xEB,0x18,0x04,0x91,0x5F,0x38,0x06,0x5E,0xF8,0x1D,0x4A,0xF9,
+0xB8,0xE4,0x00,0x00,0x0D,0x9A,0xE0,0x0E,0xE3,0x01,0xC3,0x00,0x10,0x01,0x0A,0xE4,
+0x00,0xFF,0x18,0x04,0x8A,0x26,0xFC,0x4C,0x0B,0x38,0x07,0x5F,0x59,0x06,0x5E,0xF9,
+0x1D,0x4A,0xFA,0xB8,0xE4,0x00,0x00,0x0D,0x9A,0xE0,0x0E,0xE4,0x01,0x13,0x38,0x04,
+0x23,0x28,0x64,0x23,0x2C,0x8C,0x23,0x20,0xA6,0x0B,0x23,0x00,0x0E,0xE3,0x01,0x0A,
+0xF8,0x07,0x42,0xF7,0xCD,0xE4,0x00,0x00,0x15,0x0B,0x18,0x09,0x42,0xF8,0xBD,0x0E,
+0xE4,0x01,0xE4,0x00,0x00,0x1B,0x0B,0x03,0x00,0x0E,0xE3,0x01,0x0F,0x04,0x01,0x85,
+0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x04,0x99,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x04,
+0xD1,0x85,0x29,0x1C,0x21,0xD0,0x0D,0x41,0x28,0x0D,0x61,0x24,0x0D,0x81,0x20,0x0D,
+0xA1,0x1C,0x0C,0x61,0x07,0x0C,0x81,0x05,0x0D,0x21,0x2C,0x0D,0xC1,0x18,0x0D,0xE1,
+0x14,0x0E,0x01,0x10,0x0E,0x21,0x0C,0x5D,0xA5,0x00,0x1C,0x61,0x06,0x1C,0x81,0x04,
+0xE7,0xFF,0xFE,0x94,0xC2,0xE0,0x10,0x01,0x09,0x81,0x04,0xFF,0x17,0x04,0x8A,0xEA,
+0xF7,0x04,0x8B,0x0B,0x18,0x03,0x41,0x8C,0xC3,0x41,0x8C,0xB8,0x5D,0x8C,0x06,0x0D,
+0x81,0x05,0xC1,0x40,0x10,0x01,0xC1,0x60,0x10,0x01,0xFD,0x4A,0x04,0xA0,0xFD,0x6B,
+0x04,0xAC,0xD1,0xA1,0x06,0x9E,0xC1,0xC0,0x10,0x01,0xC1,0xA0,0x10,0x01,0x0E,0xEA,
+0x02,0xFD,0xCE,0x04,0x9A,0xFD,0xAD,0x05,0x80,0x22,0xE4,0x68,0x22,0xE0,0x34,0x98,
+0x60,0xD2,0xE3,0x08,0x25,0xE4,0x00,0x00,0xD7,0x0A,0xE1,0x07,0x0E,0xED,0x01,0xE4,
+0x00,0x00,0xAB,0xC2,0xE0,0x10,0x01,0x0A,0x21,0x06,0xEE,0x37,0x04,0x89,0xC2,0xE0,
+0x10,0x01,0x09,0xED,0x00,0xED,0x97,0x05,0x29,0x41,0xEF,0x8D,0x4E,0xEF,0xFA,0x0A,
+0x0E,0x00,0x45,0xF7,0x7E,0x42,0x10,0x65,0x41,0xEF,0xBD,0x4E,0xF0,0xFA,0x46,0x17,
+0x86,0x42,0x10,0xBD,0xC2,0xE0,0x10,0x01,0xE8,0x77,0x04,0xD1,0xE7,0xFF,0xF7,0x04,
+0x42,0x10,0x83,0x41,0xEF,0x7B,0x40,0x63,0x1B,0x8D,0xF0,0x9A,0xE3,0xD5,0xE3,0x05,
+0x18,0x0E,0x2D,0x01,0x0D,0x8E,0x01,0x0C,0x0B,0x01,0x9A,0xE2,0xE4,0x00,0x01,0x29,
+0x0A,0xE1,0x06,0x09,0xAD,0x00,0x41,0xAD,0xBD,0x4E,0xED,0xFA,0x45,0xB7,0x6E,0x41,
+0xAD,0xBD,0x0A,0xEE,0x00,0x41,0x97,0x65,0x4E,0xEC,0xFA,0x45,0x97,0x66,0x41,0x8C,
+0xBD,0xC2,0xE0,0x10,0x01,0x41,0x8C,0x63,0xE8,0x77,0x04,0xD1,0x41,0xAD,0x6B,0xE7,
+0xFF,0xF6,0x5E,0x8D,0x8D,0x40,0x63,0x1B,0xD5,0x83,0x01,0x88,0x9A,0xE4,0x0E,0xEA,
+0x00,0xE4,0x00,0x00,0x51,0x21,0xA1,0x26,0x0E,0xEA,0x02,0x22,0xE8,0x60,0x26,0xE8,
+0x2B,0x22,0xE5,0x0A,0xE4,0x00,0x00,0x2B,0x22,0xEC,0x90,0xD2,0xE4,0x01,0xC6,0xE4,
+0x00,0x00,0x51,0x9A,0xE1,0xE4,0x00,0x00,0x57,0xC2,0xE0,0x10,0x01,0x0B,0x0B,0x01,
+0xEA,0xF7,0x04,0x99,0xD7,0x17,0x00,0xF9,0xE4,0x00,0x00,0x2D,0x9A,0xE4,0x98,0x61,
+0x0E,0xEA,0x00,0xE4,0x00,0x00,0x25,0x0C,0x0A,0x00,0xE4,0x00,0x00,0x13,0x9A,0xE4,
+0x0E,0xEA,0x00,0x98,0x60,0x0A,0xEB,0x01,0x0E,0x21,0x0E,0x9E,0xE1,0x0E,0x01,0x12,
+0x0E,0xEB,0x01,0x0D,0xE1,0x16,0x0D,0xC1,0x1A,0x0D,0xA1,0x1E,0x0D,0x81,0x22,0x0D,
+0x61,0x26,0x0D,0x41,0x2A,0x0D,0x21,0x2E,0x1C,0x21,0x30,0x85,0x29,0xC2,0xE0,0x10,
+0x01,0xEC,0x17,0x04,0xD3,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x05,0x2C,0x85,0x29,0x9B,
+0x01,0xC2,0xE0,0x10,0x01,0x1C,0x21,0xB0,0xFB,0x17,0x05,0xD4,0x0D,0x41,0x48,0x0D,
+0x61,0x44,0x0D,0x81,0x40,0x0E,0x01,0x30,0x0E,0x21,0x2C,0x0E,0x41,0x28,0x0E,0x61,
+0x24,0x0E,0x81,0x20,0x0E,0xA1,0x1C,0x0E,0xC1,0x18,0x0C,0x61,0x17,0x0C,0x81,0x15,
+0x0D,0x21,0x4C,0x0D,0xA1,0x3C,0x0D,0xC1,0x38,0x0D,0xE1,0x34,0x1C,0x61,0x16,0x1C,
+0x81,0x14,0xE7,0xFF,0xFA,0xF0,0xC2,0xE0,0x10,0x01,0x09,0x41,0x16,0xED,0x57,0x05,
+0x25,0xC2,0xE0,0x10,0x01,0xFF,0x17,0x04,0x8A,0xEA,0xF7,0x04,0x8B,0x0B,0x18,0x03,
+0x09,0x61,0x14,0x41,0x6B,0xC3,0x41,0x6B,0xB8,0xC2,0xE0,0x10,0x01,0xC3,0x00,0x10,
+0x01,0x5D,0x6B,0x06,0xED,0x77,0x06,0x31,0xEA,0xF8,0x04,0xD3,0x9E,0xE1,0x5E,0xF7,
+0x04,0xEE,0xF8,0x04,0xD3,0xC3,0x20,0x10,0x01,0xC2,0x60,0x10,0x01,0xC2,0x40,0x10,
+0x01,0xC2,0x80,0x10,0x01,0xC2,0xA0,0x10,0x01,0xC3,0x00,0x10,0x01,0xC2,0xC0,0x10,
+0x01,0xC3,0x40,0x10,0x01,0xFF,0x39,0x06,0x32,0xFE,0x73,0x05,0x26,0xFE,0x52,0x04,
+0x96,0xFE,0x34,0x05,0xD2,0xFE,0x15,0x06,0x26,0xFF,0x18,0x05,0xD6,0xFE,0xD6,0x04,
+0xD4,0xFD,0x9A,0x01,0x38,0xD2,0xE1,0x04,0x3E,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x04,
+0xCE,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x04,0xA4,0xC2,0xE0,0x10,0x01,0xC3,0x60,0x10,
+0x01,0xEC,0x17,0x05,0x2C,0xC3,0x40,0x10,0x01,0x0D,0x4C,0x01,0x0D,0x4C,0x03,0x0D,
+0x6C,0x05,0x0D,0x6C,0x07,0x0D,0x4C,0x09,0x0D,0x6C,0x0B,0x0C,0x0C,0x10,0x0C,0x0C,
+0x14,0x0D,0x53,0x01,0x0D,0x72,0x01,0x0D,0x51,0x01,0x0D,0x70,0x01,0x9A,0xE0,0xFF,
+0x7B,0x05,0x30,0xFF,0x5A,0x05,0x82,0x43,0x98,0xBC,0x0C,0x1C,0x01,0x43,0x96,0xBC,
+0x0C,0x1C,0x01,0x43,0x9B,0xBC,0x0C,0x1C,0x01,0x43,0x9A,0xBC,0x0C,0x1C,0x01,0x9E,
+0xE2,0x5E,0xEA,0x09,0x23,0xFF,0x8D,0x9A,0xE1,0x0D,0x58,0x01,0x0D,0x76,0x01,0x0D,
+0x5B,0x01,0x0D,0x7A,0x01,0x1A,0xF9,0x00,0xE4,0x00,0x03,0x49,0xC2,0xE0,0x10,0x01,
+0xF2,0xF7,0x04,0xCE,0x5E,0xE3,0xBB,0x20,0x04,0xF5,0x09,0xF3,0x00,0x40,0x8A,0x7D,
+0x0F,0x01,0x04,0x0C,0x81,0x0C,0x0F,0x21,0x08,0x50,0x60,0x23,0xE7,0xFF,0xF2,0x44,
+0x09,0xD2,0x00,0x0C,0x81,0x0E,0x41,0xAB,0x75,0x43,0x64,0x23,0x42,0xED,0x6B,0x40,
+0x63,0x1B,0x8E,0xFB,0x0F,0x01,0x06,0x0F,0x21,0x0A,0xD6,0xE3,0x0B,0x10,0x12,0xF9,
+0x00,0x5E,0xE4,0xDB,0x20,0x00,0x51,0x4F,0x77,0x08,0x8F,0x1B,0x8E,0xDB,0x0D,0x58,
+0x01,0x0D,0x76,0x01,0xE4,0x00,0x00,0x1D,0xFF,0x60,0x7F,0xFF,0x0F,0x78,0x4F,0x0F,
+0x76,0x4F,0x1E,0xD7,0x01,0x5E,0xD6,0x00,0x1A,0xD9,0x00,0x0A,0xEC,0x00,0xD6,0xEA,
+0x00,0x38,0x0D,0x4C,0x01,0x0B,0x0C,0x02,0x8A,0xEC,0xD5,0x58,0x00,0x38,0x0D,0x4C,
+0x03,0x0B,0x17,0x04,0xD7,0x0B,0x00,0x38,0x0D,0x77,0x05,0x0A,0xEC,0x06,0xD5,0x77,
+0x00,0x38,0x0D,0x6C,0x07,0x4E,0xE4,0xFA,0x47,0x17,0x26,0x42,0xF8,0xBD,0x0F,0x0C,
+0x12,0x8E,0xF8,0x0E,0xEC,0x10,0x4E,0xED,0xFA,0x47,0x17,0x6E,0x42,0xF8,0xBD,0x0F,
+0x0C,0x16,0x8E,0xF8,0x88,0x6D,0x0E,0xEC,0x14,0xE7,0xFF,0xF6,0xCA,0xC3,0x00,0x10,
+0x01,0xF8,0x78,0x04,0x9C,0xC1,0xA0,0x10,0x01,0x89,0x83,0x5E,0xE3,0x00,0xFD,0xAD,
+0x06,0x28,0x22,0xC9,0x94,0x26,0xC9,0x95,0x13,0x2D,0x00,0x1F,0x39,0x40,0x43,0x39,
+0xBD,0x4F,0x19,0xFA,0x4F,0x18,0xD1,0x42,0xF9,0xC4,0x56,0xF7,0x3F,0x42,0xD7,0xC5,
+0x5E,0xF6,0x00,0x0E,0xE1,0x10,0x26,0xEC,0x31,0x57,0x16,0xFF,0x5F,0x07,0x91,0x20,
+0x01,0x65,0xC3,0x00,0x10,0x01,0xF3,0x18,0x04,0xCE,0x23,0x00,0xC2,0x08,0x91,0x00,
+0x40,0x8F,0x25,0x08,0x70,0x00,0x40,0x6E,0x1D,0xE7,0xFF,0xF6,0x0A,0xE7,0xFF,0xEE,
+0x56,0x0E,0xE1,0x12,0xD2,0xE7,0x00,0x69,0x56,0xF6,0xFF,0x5E,0xE7,0x11,0x20,0x01,
+0x71,0x0D,0xF1,0x01,0x0D,0xD0,0x01,0x19,0x8D,0x00,0x0D,0x53,0x01,0x0D,0x72,0x01,
+0xE4,0x00,0x00,0xB9,0x5E,0xE3,0xC9,0x20,0x01,0x55,0x9B,0x01,0xC2,0xE0,0x10,0x01,
+0xEF,0x17,0x05,0x2C,0xE4,0x00,0x00,0x91,0x0B,0x10,0x00,0x0B,0x31,0x00,0x43,0x18,
+0x75,0x43,0x39,0x7D,0x0F,0x01,0x04,0x0F,0x21,0x08,0x50,0x60,0x23,0xE7,0xFF,0xEF,
+0xA2,0x0F,0x21,0x0A,0x0F,0x01,0x06,0x43,0x39,0xCB,0x43,0x18,0xC3,0x40,0x63,0x1B,
+0x8F,0x19,0xD7,0x03,0xFC,0x5C,0xE7,0xFF,0xFE,0xF9,0xC2,0xE0,0x10,0x01,0xF3,0x17,
+0x04,0xA4,0x9F,0x01,0xFB,0x17,0x04,0xA4,0xE7,0xFF,0xFF,0x33,0x0E,0xC1,0x1A,0x0E,
+0xA1,0x1E,0x0E,0x81,0x22,0x0E,0x61,0x26,0x0E,0x41,0x2A,0x0E,0x21,0x2E,0x0E,0x01,
+0x32,0x0D,0xE1,0x36,0x0D,0xC1,0x3A,0x0D,0xA1,0x3E,0x0D,0x81,0x42,0x0D,0x61,0x46,
+0x0D,0x41,0x4A,0x0D,0x21,0x4E,0x1C,0x21,0x50,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,
+0x97,0x04,0xA8,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x06,0x2C,0x85,0x29,0xFC,0x21,0xFF,
+0x58,0xED,0x61,0x00,0x9C,0x0E,0xC1,0x70,0xED,0x21,0x00,0xA4,0xED,0x41,0x00,0xA0,
+0xED,0x81,0x00,0x98,0xED,0xA1,0x00,0x94,0xED,0xC1,0x00,0x90,0xED,0xE1,0x00,0x8C,
+0xEE,0x01,0x00,0x88,0xEE,0x21,0x00,0x84,0xEE,0x41,0x00,0x80,0x0E,0x61,0x7C,0x0E,
+0x81,0x78,0x0E,0xA1,0x74,0xFE,0xC1,0x00,0xA8,0xC2,0xE0,0x10,0x01,0xC1,0x60,0x10,
+0x01,0xEA,0xF7,0x05,0x26,0xFD,0x6B,0x01,0x38,0xC3,0x00,0x10,0x01,0x0C,0x76,0xA0,
+0xEB,0x18,0x04,0x96,0x0C,0x36,0xA4,0x0E,0xEB,0x0D,0x0F,0x0B,0x0F,0xC3,0x20,0x10,
+0x01,0xF3,0x39,0x04,0xCE,0x5F,0x23,0xDB,0x20,0x00,0x85,0xC3,0x20,0x10,0x01,0xE8,
+0x79,0x06,0x26,0xC3,0x20,0x10,0x01,0xE8,0x99,0x05,0xD2,0x40,0x97,0x25,0x40,0x78,
+0x1D,0xE7,0xFF,0xF3,0x7A,0xE7,0xFF,0xEB,0xC6,0x0C,0x6B,0x12,0x0D,0x4B,0x16,0x98,
+0x80,0x0C,0x6B,0x18,0x0D,0x4B,0x1C,0xE7,0xFF,0xEE,0x0C,0x0C,0x6B,0x10,0x88,0x6A,
+0xE7,0xFF,0xED,0xB2,0x0B,0x0B,0x00,0x0C,0x6B,0x14,0xC2,0xE0,0x10,0x01,0x0B,0x2B,
+0x02,0xEA,0xF7,0x04,0x94,0x43,0x39,0xC5,0xC3,0x00,0x10,0x01,0xFE,0x38,0x04,0x84,
+0xD6,0xF9,0x00,0x88,0x0B,0x4B,0x06,0x0B,0x2B,0x04,0x43,0x3A,0xCD,0xD6,0xF9,0x00,
+0xEC,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x05,0x2E,0x22,0xE4,0x44,0xC2,0xE0,0x10,0x01,
+0xFD,0x57,0x04,0xAE,0x13,0x2A,0x20,0x27,0x24,0x5B,0xC2,0xE0,0x10,0x01,0xEC,0x16,
+0xFF,0x78,0xEC,0x17,0x05,0x2C,0x0C,0x16,0x80,0xE4,0x00,0x10,0x67,0x0C,0x36,0x9C,
+0x0F,0x31,0x02,0xEC,0x16,0xFF,0x78,0x0F,0x39,0x02,0x0C,0x16,0x80,0x0B,0x39,0x01,
+0x0C,0x16,0x90,0x9F,0x27,0x99,0x80,0x4F,0x39,0x19,0x4F,0x39,0x18,0x40,0x21,0xCD,
+0xEC,0x36,0xFF,0x70,0x40,0x21,0xCD,0xEC,0x36,0xFF,0x64,0xE4,0x00,0x0F,0xCB,0x4F,
+0x0C,0x20,0xEF,0x16,0xFF,0x68,0x0E,0xF7,0x06,0x8E,0xF8,0x11,0xB7,0x05,0x5D,0xA3,
+0xFB,0x20,0x00,0x45,0xC3,0x20,0x10,0x01,0xEF,0x19,0x04,0xAA,0x8B,0x2D,0xE4,0x00,
+0x00,0x25,0x1F,0x2D,0xE0,0xC3,0x40,0x10,0x01,0x5F,0x39,0x00,0xEF,0x1A,0x06,0x2E,
+0x9B,0x41,0x4F,0x3A,0xCC,0x47,0x19,0xC4,0xD3,0x00,0x0A,0x12,0x1F,0x0D,0xFF,0x27,
+0x0D,0x13,0x10,0xB7,0x04,0x0C,0xD7,0x02,0x10,0x6A,0x20,0x9A,0xE0,0x20,0xA0,0x30,
+0x88,0x8A,0xE7,0xFF,0xED,0x10,0x5E,0xE3,0x00,0xEF,0x16,0xFF,0x72,0x8F,0x0C,0x1A,
+0xF8,0x00,0x0E,0xF1,0x02,0xEF,0x16,0xFF,0x6A,0x0E,0xF7,0x06,0x8E,0xF8,0x10,0xAA,
+0x20,0x10,0x77,0x04,0x0C,0x97,0x02,0x88,0xCA,0x9A,0xE0,0xD0,0xA0,0x07,0x5E,0xE4,
+0x00,0x01,0xDD,0x99,0xC0,0x99,0xFB,0x8A,0x0E,0xD1,0xAA,0x03,0x66,0x99,0xE0,0x1C,
+0x76,0xA8,0x88,0x8F,0xE7,0xFF,0xEA,0x00,0x0E,0xF1,0x02,0xEF,0x36,0xFF,0x6A,0x0E,
+0xF7,0x06,0x10,0x6A,0x20,0x8E,0xF9,0x10,0xB7,0x04,0x0C,0xD7,0x02,0x20,0xA0,0x54,
+0x1C,0x96,0xA8,0xE7,0xFF,0xEC,0x4E,0x5C,0x63,0x00,0xD4,0x70,0x00,0x41,0x8A,0x03,
+0x89,0xCF,0x9D,0xE4,0x5D,0xEF,0x00,0x5D,0xE8,0x09,0x23,0xFF,0x15,0xEE,0xF6,0xFF,
+0x72,0x8E,0xEC,0x1A,0x17,0x00,0x5E,0x09,0x73,0x20,0x02,0xA9,0x1C,0x76,0xA8,0x88,
+0x8E,0xE7,0xFF,0xE9,0x66,0x0E,0xF1,0x02,0xEF,0x56,0xFF,0x6A,0x0E,0xF7,0x06,0x8E,
+0xFA,0xE4,0x00,0x00,0xC9,0x1C,0x76,0xA8,0x88,0x8F,0xE7,0xFF,0xE9,0x34,0x0E,0xF1,
+0x02,0xEF,0x16,0xFF,0x6A,0x0E,0xF7,0x06,0x10,0x6A,0x20,0x8E,0xF8,0x10,0xB7,0x04,
+0x0C,0xD7,0x02,0x20,0xA0,0x54,0x1C,0x96,0xA8,0xE7,0xFF,0xEB,0x82,0x5C,0x63,0x00,
+0xD4,0x70,0x00,0x41,0x8A,0x03,0x89,0xCF,0x9D,0xE1,0x5D,0xEF,0x02,0xD1,0xE6,0xFE,
+0x46,0xEE,0xF6,0xFF,0x72,0x8E,0xEC,0x1A,0x17,0x00,0x5E,0x09,0x73,0x20,0x01,0x19,
+0x1C,0x76,0xA8,0x88,0x8E,0xE7,0xFF,0xE8,0x9E,0x0E,0xF1,0x02,0xEF,0x36,0xFF,0x6A,
+0x0E,0xF7,0x06,0x8E,0xF9,0x10,0x77,0x04,0x0C,0x97,0x02,0x10,0xAA,0x20,0x9A,0xE0,
+0x20,0xA0,0x34,0x1C,0xD6,0xA8,0xE7,0xFF,0xEA,0xE8,0x5E,0xE3,0x00,0xEF,0x16,0xFF,
+0x66,0x8F,0x0C,0x1A,0xF8,0x00,0xE4,0x00,0x00,0x2D,0xEE,0xF6,0xFF,0x72,0x8E,0xEC,
+0x18,0x17,0x00,0xEE,0xF6,0xFF,0x66,0x8E,0xEC,0x18,0x17,0x00,0xEE,0xF6,0xFF,0x72,
+0x8E,0xEC,0x12,0xF7,0x00,0x0E,0xF6,0x94,0x5E,0xE9,0x53,0x20,0x19,0x01,0xEE,0xF6,
+0xFF,0x66,0x8E,0xEC,0x12,0xF7,0x00,0x0E,0xF6,0x98,0x5E,0xE8,0xB3,0x20,0x18,0xB9,
+0x0B,0x4B,0x08,0x0A,0xEB,0x02,0x0B,0x0B,0x00,0x0B,0x2B,0x06,0xEF,0x56,0xFF,0x58,
+0xEE,0xF6,0xFF,0x60,0xEF,0x16,0xFF,0x74,0xEF,0x36,0xFF,0x5C,0x0A,0x0B,0x0C,0x09,
+0xEB,0x0A,0x09,0xCB,0x0E,0x0A,0x6B,0x04,0xD1,0xA7,0x01,0x36,0xD5,0xEE,0x2F,0xF8,
+0x41,0xCE,0x7D,0x4C,0x6E,0xFA,0x45,0xC3,0x76,0x40,0x6E,0x1D,0xE7,0xFF,0xE8,0xBA,
+0xC0,0x60,0x18,0xE8,0x20,0x17,0x9D,0x12,0xEA,0x20,0xE4,0x00,0x08,0xB3,0xEF,0x56,
+0xFF,0x5A,0x43,0x5A,0x85,0x4E,0xFA,0xFA,0x0F,0x56,0x84,0x46,0x97,0xD6,0xEF,0x36,
+0xFF,0x62,0x42,0x94,0xBD,0xEF,0x56,0xFF,0x76,0x42,0xEF,0x75,0x43,0x39,0xD5,0xEE,
+0xF6,0xFF,0x7C,0xEF,0x36,0xFF,0x6C,0x4E,0xF7,0xFA,0xEF,0x16,0xFF,0x7E,0x46,0xB7,
+0xC6,0x42,0xB5,0xBD,0xEE,0xF6,0xFF,0x5E,0x42,0x57,0x9D,0xD1,0xA8,0x08,0x7E,0x40,
+0x77,0x7D,0xE7,0xFF,0xE8,0x0E,0xC0,0x60,0xCE,0x48,0x20,0x00,0x95,0xEF,0x16,0xFF,
+0x62,0x98,0x80,0x40,0x78,0x85,0xE7,0xFF,0xE8,0x2E,0xC0,0x60,0x19,0x08,0x20,0x00,
+0x45,0x12,0xEA,0x20,0x8E,0xEA,0x12,0xF7,0xFF,0x5E,0xE5,0xFB,0x20,0x15,0xBD,0x42,
+0xB5,0xAB,0x42,0x94,0xA3,0x42,0x52,0x93,0x8E,0x95,0xEF,0x36,0xFF,0x6E,0xCE,0x94,
+0x00,0x64,0x42,0xF9,0xCB,0x8E,0x57,0x4E,0x52,0x18,0xD6,0x54,0x00,0x91,0x40,0x6E,
+0x9D,0xE7,0xFF,0xE7,0x70,0xC0,0x60,0x18,0xE8,0x20,0x15,0x09,0xEF,0x56,0xFF,0x62,
+0xEE,0xF6,0xFF,0x5A,0x98,0x80,0x40,0x7A,0xBD,0xE7,0xFF,0xE7,0x88,0xC0,0x60,0x4A,
+0xE8,0x20,0x14,0xA9,0x11,0xEA,0x00,0x1E,0xEF,0xF0,0x5E,0xE3,0xDB,0x20,0x00,0x45,
+0x12,0xEA,0x01,0x9E,0xF0,0x5E,0xF7,0x00,0x5E,0xE3,0xD3,0x20,0x14,0x41,0xC3,0x20,
+0x10,0x01,0xFF,0x39,0x04,0xAE,0x13,0x19,0x20,0x8F,0x19,0x12,0xF8,0xFF,0x1F,0x37,
+0xEF,0x5F,0x23,0xDB,0x20,0x00,0x49,0x13,0x18,0xFE,0x5F,0x02,0x13,0x20,0x00,0x25,
+0x5F,0x05,0xF3,0x20,0x13,0xA1,0x9E,0xF4,0xD2,0xE6,0x00,0x9D,0xEC,0x76,0xFF,0x7E,
+0xE7,0xFF,0xE6,0x92,0xC0,0x60,0x9C,0x4C,0x20,0x13,0x4D,0x9D,0xF8,0xD1,0xE7,0x21,
+0xD5,0xEF,0x56,0xFF,0x5E,0x41,0xCE,0xD5,0x4C,0x6E,0xFA,0x45,0xC3,0x76,0x40,0x6E,
+0x1D,0xE7,0xFF,0xE6,0x50,0xC0,0x60,0x7C,0xEC,0x20,0x10,0x79,0xEE,0xF6,0xFF,0x62,
+0x98,0x80,0x42,0x10,0xBD,0x4C,0x70,0xFA,0x46,0x03,0x86,0x40,0x70,0x1D,0xE7,0xFF,
+0xE6,0x5E,0xC0,0x60,0x3E,0x68,0xE4,0x00,0x07,0xFD,0xD1,0xAA,0x0E,0xFE,0xEF,0x16,
+0xFF,0x5A,0x43,0x10,0xC5,0x4E,0xF8,0xFA,0x0F,0x16,0x88,0x44,0x77,0xC6,0x98,0x80,
+0x40,0x63,0xBD,0xE7,0xFF,0xE6,0x14,0x0C,0x76,0x8C,0xC0,0x60,0xAF,0x0C,0x20,0x00,
+0x69,0x40,0x6E,0x7D,0x4E,0xE3,0xFA,0x44,0x77,0x1E,0x40,0x63,0xBD,0xE7,0xFF,0xE5,
+0x98,0xC0,0x60,0xAF,0x08,0x20,0x00,0xF5,0xEF,0x36,0xFF,0x5E,0x88,0x6F,0x88,0x99,
+0x88,0xB3,0xE7,0xFF,0xEA,0x86,0x20,0x60,0x52,0xEF,0x56,0xFF,0x5E,0x88,0x6E,0x88,
+0x9A,0x88,0xB3,0xE7,0xFF,0xEA,0x64,0x20,0x60,0x6C,0xEE,0xF6,0xFF,0x5A,0xD6,0x17,
+0x00,0xA0,0x0C,0x76,0x8A,0x98,0x80,0xE7,0xFF,0xE5,0x6C,0xC0,0x60,0x32,0x0C,0x20,
+0x10,0x71,0xEF,0x16,0xFF,0x6E,0x42,0xF8,0xC3,0x42,0xB5,0xAB,0x42,0x94,0xA3,0x42,
+0x52,0x93,0x8E,0x95,0x8E,0x57,0xCE,0x94,0x00,0x64,0x4E,0xF2,0x18,0xD6,0x97,0x01,
+0xA1,0x40,0x6E,0x9D,0xE7,0xFF,0xE4,0xCA,0xC0,0x60,0x18,0xEC,0x20,0x00,0x95,0x12,
+0xEA,0x01,0x9E,0xF0,0x5E,0xF7,0x00,0x5E,0xE3,0xD3,0x20,0x00,0x5D,0xEF,0x36,0xFF,
+0x76,0x98,0x80,0x40,0x70,0xCD,0xE7,0xFF,0xE4,0xCE,0xC0,0x60,0x2B,0xCC,0x20,0x0F,
+0x35,0x12,0xAA,0x00,0x1E,0xF5,0xF8,0x5E,0xE6,0x13,0x20,0x00,0xAD,0xEF,0x56,0xFF,
+0x5E,0x40,0x7A,0x7D,0xE7,0xFF,0xE4,0x4A,0xC0,0x60,0xC7,0xEC,0x20,0x00,0x65,0x40,
+0x6F,0x9D,0xE7,0xFF,0xE4,0x2E,0xC0,0x60,0xC7,0xEC,0x20,0x00,0x2D,0xCE,0xF2,0x00,
+0x06,0xD6,0x97,0x1C,0xD5,0xCE,0x52,0x00,0x0C,0xD6,0x92,0x01,0x39,0x12,0xEA,0x01,
+0xD2,0xEF,0x01,0x05,0x0C,0x76,0x86,0x98,0x80,0xE7,0xFF,0xE4,0x28,0x5C,0x6C,0x91,
+0x20,0x00,0x41,0x40,0x6E,0x7D,0xE7,0xFF,0xE3,0xC6,0x5C,0x6C,0x99,0x20,0x0D,0xB9,
+0x1E,0xB5,0xDB,0x5E,0xA2,0x3B,0x20,0x00,0x85,0x12,0xEA,0x20,0x8E,0xEA,0x12,0xF7,
+0xFF,0x5E,0xE4,0x93,0x20,0x00,0x4D,0x5E,0xE6,0xDB,0x20,0x00,0x35,0x0E,0xF6,0x8E,
+0xC2,0xE0,0x7D,0x0C,0x20,0x0D,0x1D,0xEC,0x76,0xFF,0x7E,0xE7,0xFF,0xE3,0x5C,0xC0,
+0x60,0xBB,0x88,0x20,0x00,0x65,0xEF,0x16,0xFF,0x62,0xEF,0x36,0xFF,0x76,0x88,0x70,
+0x88,0x98,0x88,0xB9,0xE7,0xFF,0xE8,0x42,0xD0,0x60,0x19,0x1E,0x40,0x6E,0x7D,0x4E,
+0xE3,0xFA,0x44,0x77,0x1E,0x40,0x63,0xBD,0xE7,0xFF,0xE3,0x02,0xC0,0x60,0xBB,0x88,
+0x20,0x00,0x5D,0xEF,0x56,0xFF,0x5E,0xD5,0xFA,0x18,0x22,0xD5,0xF3,0x18,0x02,0xD5,
+0xDA,0x17,0xE2,0xD5,0xD3,0x17,0xC2,0x0E,0xF6,0x8E,0xC2,0xE0,0xBB,0x88,0x20,0x00,
+0x7D,0xEF,0x16,0xFF,0x5A,0xEF,0x36,0xFF,0x62,0xD7,0x19,0x17,0x12,0xEF,0x56,0xFF,
+0x76,0xD7,0x1A,0x16,0xD2,0xD6,0x19,0x16,0xB2,0xD6,0x1A,0x16,0x92,0xEE,0xF6,0xFF,
+0x62,0xEF,0x16,0xFF,0x5A,0x98,0x80,0x40,0x77,0xC5,0xE7,0xFF,0xE2,0xA6,0xC0,0x60,
+0xBB,0x8C,0x4A,0xE1,0x01,0xE4,0x00,0x04,0x49,0xC2,0xE0,0x10,0x01,0x1F,0x0D,0xFD,
+0xFE,0xF7,0x04,0x8A,0x27,0x04,0xE7,0x0B,0x17,0x03,0x0B,0x37,0x01,0xCF,0x18,0x01,
+0x2C,0x43,0x18,0xC8,0xD6,0x58,0x14,0xBC,0x0B,0x17,0x07,0xC2,0xE0,0x10,0x01,0xEE,
+0xF7,0x03,0x22,0x12,0xF7,0x00,0x42,0xF8,0xBB,0x53,0x00,0x64,0x42,0xF7,0xC0,0x0F,
+0x0B,0x1A,0xD6,0xF8,0x13,0xCC,0x0E,0xEB,0x12,0xE4,0x00,0x01,0x51,0x1F,0x0D,0xFF,
+0xD3,0x01,0x05,0x65,0x13,0x4A,0x20,0x13,0x2A,0x00,0x23,0x44,0x98,0x13,0x0A,0x01,
+0x43,0x99,0xC5,0x8F,0x38,0x4F,0x7C,0xFA,0x4F,0x39,0x0A,0x47,0x9B,0xE6,0x43,0x7C,
+0xDD,0x5F,0x7B,0x00,0x5F,0x63,0xFB,0x20,0x00,0x1B,0x1F,0x39,0x20,0x57,0x39,0x3F,
+0x9B,0x00,0x1F,0xB9,0x40,0x53,0xC0,0x40,0xE4,0x00,0x00,0x63,0x43,0x2A,0xC4,0x13,
+0x99,0x00,0x43,0x9D,0xE5,0x4F,0x7C,0xFA,0x4F,0x7B,0xD1,0x43,0x3C,0xDC,0x57,0x39,
+0x3F,0x43,0x39,0xDD,0x5F,0x39,0x00,0x5F,0x24,0x13,0x20,0x00,0x25,0x43,0x3E,0xCD,
+0x5F,0x39,0x00,0x9F,0x01,0xD3,0x24,0x10,0x35,0x5F,0x78,0x00,0xD7,0x5B,0xFE,0x85,
+0xE4,0x00,0x04,0x8D,0xC3,0x20,0x10,0x01,0xEF,0x19,0x03,0x1E,0x13,0x38,0x00,0x0B,
+0x17,0x09,0x43,0x39,0xC3,0x53,0x00,0x64,0x43,0x39,0xC1,0x0B,0x17,0x03,0x43,0x39,
+0xC3,0x0B,0x17,0x01,0x42,0xF9,0xC0,0x0F,0x0B,0x1E,0xD6,0xF8,0x0E,0x8C,0x0E,0xEB,
+0x16,0xC2,0xE1,0x06,0x8C,0x20,0x07,0x19,0xE4,0x00,0x02,0x5F,0xD1,0xA9,0x02,0x46,
+0xC3,0x40,0x10,0x01,0xF6,0xFA,0x04,0xA4,0xD2,0xE3,0x0D,0x9C,0xEE,0xF6,0xFF,0x5A,
+0x50,0x60,0x64,0x42,0x10,0xBD,0xE7,0xFF,0xDF,0xF0,0xD4,0x70,0x0D,0x0C,0x12,0xEA,
+0x20,0xD2,0xE5,0x08,0x31,0x13,0x0A,0x01,0x9F,0x10,0x5F,0x18,0x00,0x5F,0x03,0xDB,
+0x20,0x03,0xDD,0x8E,0xEA,0x12,0xF7,0xFE,0x9E,0xF0,0x5E,0xF7,0x00,0x5E,0xE3,0xD3,
+0xE4,0x00,0x01,0x35,0xD1,0xA5,0x01,0x16,0x40,0x6E,0x9D,0xE7,0xFF,0xDF,0xBC,0xC0,
+0x60,0xA2,0x88,0x20,0x03,0x51,0x12,0xEA,0x00,0x9E,0xF8,0x5E,0xF7,0x00,0xD2,0xEE,
+0x0A,0xE9,0xE4,0x00,0x01,0x8B,0xD1,0xA6,0x03,0xDE,0xEF,0x16,0xFF,0x5E,0x40,0x78,
+0x7D,0xE7,0xFF,0xDF,0x70,0xC0,0x60,0x9C,0x48,0x20,0x00,0x79,0x40,0x6E,0x9D,0xE7,
+0xFF,0xDF,0x54,0xC0,0x60,0x3E,0x6C,0x20,0x00,0x41,0x12,0xEA,0x00,0x1E,0xF7,0xD8,
+0x5E,0xF7,0x00,0xD2,0xEE,0x09,0x41,0xEF,0x36,0xFF,0x5E,0x40,0x79,0x75,0xE7,0xFF,
+0xDF,0x16,0xC0,0x60,0x7D,0x08,0x20,0x02,0x05,0x40,0x6F,0x9D,0xE7,0xFF,0xDE,0xFA,
+0xC0,0x60,0xE0,0xEC,0x20,0x01,0xCD,0x12,0xEA,0x20,0x8E,0xEA,0x13,0x17,0xFF,0xD3,
+0x07,0x00,0x7D,0x12,0xF7,0xFE,0xD2,0xE7,0x07,0xAD,0xE4,0x00,0x00,0xBB,0x5F,0x02,
+0xD3,0x20,0x03,0xA9,0x12,0xF7,0xFE,0x5E,0xE2,0xD3,0x20,0x03,0x85,0xE4,0x00,0x00,
+0x95,0x9A,0xE0,0xD1,0xAB,0x02,0x36,0xEF,0x56,0xFF,0x5A,0xD6,0x1A,0x00,0x40,0xD5,
+0xCF,0x06,0x64,0x41,0xCE,0x7D,0x4C,0x6E,0xFA,0x45,0xC3,0x76,0x40,0x6E,0x1D,0xE7,
+0xFF,0xDE,0x54,0xC0,0x60,0x25,0x6C,0x20,0x00,0x81,0xEE,0xF6,0xFF,0x5A,0x98,0x80,
+0x42,0x10,0xBD,0x4C,0x70,0xFA,0x46,0x03,0x86,0x40,0x70,0x1D,0xE7,0xFF,0xDE,0x62,
+0xC0,0x60,0x25,0x68,0x20,0x02,0x5D,0x9A,0xE0,0xEF,0x36,0xFF,0x6A,0x0F,0x11,0x02,
+0x0F,0x18,0x06,0x8F,0x19,0x0F,0x38,0x0A,0x23,0x25,0x92,0x0F,0x4B,0x12,0x23,0x41,
+0x78,0x0F,0x2B,0x16,0x23,0x21,0x60,0x11,0xD8,0x0C,0x13,0xD8,0x0D,0x97,0x63,0x11,
+0x18,0x0E,0xCB,0x7B,0x34,0x50,0x13,0xB8,0x0F,0x41,0xCE,0xDB,0xCF,0x9E,0x07,0xD0,
+0xCF,0x1D,0x07,0xD0,0xD1,0xAA,0x00,0xAE,0x22,0xE0,0x44,0xCF,0x9E,0x46,0x50,0xCF,
+0x1D,0x46,0x50,0x43,0x9C,0x69,0x43,0x18,0x69,0xCE,0xFA,0x07,0xD0,0xD6,0xEE,0x01,
+0xF5,0xCF,0x5A,0x00,0x14,0xD7,0x9A,0x01,0xB5,0xCE,0xF9,0x07,0xD0,0x43,0x68,0xDB,
+0xD6,0xFB,0x01,0x5D,0xCF,0x39,0x00,0x14,0xD7,0x19,0x01,0x1D,0x0E,0xF6,0x96,0x0F,
+0x56,0x9A,0x0F,0x16,0x92,0x8E,0xFA,0x4E,0xF7,0x0A,0xD6,0xF8,0x00,0x88,0x5E,0xF7,
+0x00,0x0D,0x96,0x80,0x0E,0xF6,0x90,0xEE,0xF6,0xFF,0x78,0x9D,0x81,0x5D,0x8C,0x00,
+0x0E,0xF1,0x02,0x0F,0x17,0x02,0x0B,0x18,0x01,0xD7,0x0C,0xC0,0xB5,0xC2,0xE0,0x10,
+0x01,0xEF,0x36,0xFF,0x7A,0x0C,0x36,0x9E,0xFB,0x37,0x04,0xCF,0xE7,0xFF,0xE7,0x22,
+0x98,0x62,0xEF,0x56,0xFF,0x7A,0x23,0x41,0x14,0x0E,0xF1,0x02,0x0F,0x36,0x82,0x0F,
+0x17,0x06,0x0F,0x56,0xA2,0x4E,0xF9,0x20,0x98,0x61,0x8E,0xF8,0x12,0xF7,0x05,0x0E,
+0xFA,0x00,0xE4,0x00,0x00,0x53,0xEF,0x36,0xFF,0x6E,0x4F,0x19,0xFA,0x46,0x78,0xCE,
+0x42,0x73,0xC5,0x4F,0x12,0xFA,0x46,0x58,0x96,0x42,0x52,0xC5,0x4E,0x52,0x12,0xFE,
+0x52,0x01,0x2C,0xD6,0x72,0xFC,0xC4,0xE7,0xFF,0xFB,0x3B,0x0C,0x36,0xA6,0x0E,0xC1,
+0x72,0x0E,0xA1,0x76,0x0E,0x81,0x7A,0x0E,0x61,0x7E,0xEE,0x41,0x00,0x82,0xEE,0x21,
+0x00,0x86,0xEE,0x01,0x00,0x8A,0xED,0xE1,0x00,0x8E,0xED,0xC1,0x00,0x92,0xED,0xA1,
+0x00,0x96,0xED,0x81,0x00,0x9A,0xED,0x61,0x00,0x9E,0xED,0x41,0x00,0xA2,0xED,0x21,
+0x00,0xA6,0xFC,0x21,0x00,0xA8,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x04,0x84,
+0xC2,0xE0,0x10,0x01,0x9C,0x38,0xEC,0x97,0x04,0x8B,0x0D,0x21,0x04,0x0D,0x41,0x00,
+0x08,0x61,0x09,0xFD,0x57,0x04,0x8A,0x0C,0xAA,0x03,0x0C,0xCA,0x07,0x0C,0xEA,0x09,
+0x19,0x0A,0x04,0xE7,0xFF,0xDA,0xF6,0x0D,0x21,0x06,0x0C,0x6A,0x0B,0x0D,0x41,0x02,
+0x9C,0x28,0x85,0x29,0x9C,0x30,0x5C,0x63,0x00,0x0D,0x41,0x08,0x0D,0x61,0x04,0x4C,
+0x63,0x08,0xC2,0xF8,0x00,0x21,0x0D,0x21,0x0C,0xFE,0xF7,0xB7,0x2C,0x99,0x40,0x8E,
+0xE3,0x09,0x77,0x01,0x88,0x6A,0x88,0x8B,0x9D,0x41,0xE4,0x00,0xAF,0x08,0x5D,0x4A,
+0x00,0xD1,0x44,0xFF,0x9E,0x0D,0x61,0x06,0x0D,0x41,0x0A,0x0D,0x21,0x0E,0x1C,0x21,
+0x10,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x06,0x35,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x06,0x3A,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x06,0x33,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x06,0x36,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x06,0x3D,0xC2,0xE0,0x10,0x01,0xEC,
+0x17,0x06,0x39,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x06,0x40,0x85,0x29,0xC2,0xE0,0x10,
+0x01,0xEC,0x77,0x06,0x35,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x06,0x33,0xC2,0xE0,0x10,
+0x01,0xF0,0x77,0x06,0x3A,0xC2,0xE0,0x10,0x01,0xF8,0x77,0x06,0x36,0xC2,0xE0,0x10,
+0x01,0xEC,0x17,0x06,0x3D,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x06,0x39,0xC2,0xE0,0x10,
+0x01,0xEC,0x17,0x06,0x40,0x24,0x6C,0x1F,0xE7,0xFF,0xFE,0x99,0x85,0x29,0xC2,0xE0,
+0x10,0x01,0xC3,0x00,0x10,0x01,0x5C,0x63,0x04,0xEC,0x77,0x06,0x39,0xC2,0xE0,0x10,
+0x01,0xEC,0x17,0x06,0x40,0xF3,0x78,0x06,0x33,0xC3,0x40,0x10,0x01,0xC3,0x20,0x10,
+0x01,0xC3,0x00,0x10,0x01,0xFF,0x5A,0x06,0x3A,0xFF,0x39,0x06,0x36,0x23,0x60,0x2C,
+0xEB,0x78,0x06,0x3D,0xD7,0x63,0x00,0xA1,0x13,0x5A,0x00,0xEC,0x78,0x06,0x3D,0x1B,
+0x59,0x00,0x9B,0x01,0xEF,0x17,0x06,0x40,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEB,0x17,
+0x06,0x39,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x06,0x35,0x5E,0xF8,0x1F,0x48,0x61,0x01,
+0x85,0x29,0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x06,0x33,0x5E,0xE0,0x5B,0x48,0x61,0x01,
+0x85,0x29,0xC2,0xE0,0x10,0x01,0xF3,0x17,0x06,0x33,0x27,0x08,0x7B,0x9F,0x01,0xFB,
+0x17,0x06,0x33,0xC2,0xE0,0x10,0x01,0xF0,0x77,0x06,0x3A,0x9C,0x61,0x54,0x63,0x03,
+0xF8,0x77,0x06,0x3A,0xE7,0xFF,0xFD,0x61,0x85,0x29,0x8B,0x03,0x56,0xE3,0x03,0x22,
+0xE0,0x98,0x9B,0x04,0x42,0xF8,0xBD,0x5F,0x44,0x00,0x5E,0xE5,0x17,0x4B,0x37,0x28,
+0x9A,0xE0,0xE4,0x00,0x00,0x13,0x1B,0x58,0x00,0x9E,0xE1,0x43,0x03,0xBC,0xD6,0xF9,
+0xFF,0xC6,0x40,0xA5,0xBD,0x4E,0xE4,0x80,0x4F,0x64,0xC0,0x47,0x7B,0xBD,0x4E,0xE4,
+0x40,0x47,0x7B,0x25,0x4F,0x45,0x11,0x47,0x7B,0xBD,0x9A,0xE0,0xE4,0x00,0x00,0x17,
+0x8F,0x38,0x9E,0xE1,0x0F,0x79,0x00,0x4F,0x37,0x10,0xD6,0xFA,0xFF,0xB6,0x8F,0x19,
+0x9A,0xE0,0x54,0xA5,0x03,0x5C,0x84,0x00,0xE4,0x00,0x00,0x19,0x43,0x37,0xC4,0x9E,
+0xE1,0x18,0x99,0x00,0xD4,0xB7,0xFF,0xC5,0x85,0x29,0x46,0xE4,0x1D,0x56,0xF7,0x03,
+0x22,0xE0,0x82,0x9A,0xFC,0x47,0x45,0xBC,0x9A,0xE0,0xE4,0x00,0x00,0x51,0x43,0x03,
+0xBC,0x43,0x24,0xBC,0x9E,0xE1,0x13,0x39,0x00,0x1B,0x38,0x00,0xE4,0x00,0x00,0x0D,
+0x9A,0xE0,0xD6,0xE5,0xFF,0x66,0xE4,0x00,0x00,0x63,0x0F,0x39,0x02,0x9E,0xE4,0x0F,
+0x38,0x00,0x43,0x03,0xBC,0x43,0x24,0xBC,0xD6,0xFA,0xFF,0x96,0x9A,0xE0,0x54,0xA5,
+0x03,0xE4,0x00,0x00,0x25,0x43,0x57,0xC4,0x43,0x77,0xCC,0x9E,0xE1,0x13,0x7B,0x00,
+0x1B,0x7A,0x00,0xD4,0xB7,0xFF,0x95,0x85,0x29,0x9C,0x30,0x0D,0x41,0x08,0x0D,0x61,
+0x04,0x0D,0x21,0x0C,0x89,0x63,0x99,0x40,0xE4,0x00,0x20,0xB4,0x20,0x64,0xD2,0xE4,
+0x00,0x22,0xE6,0x20,0x64,0x82,0xE4,0x00,0x22,0xC4,0xC2,0xE0,0x10,0x01,0xFF,0x20,
+0xFF,0x7F,0xEB,0x17,0x08,0x25,0x99,0x41,0x47,0x18,0xCC,0xEF,0x17,0x08,0x25,0xE4,
+0x00,0x00,0x23,0xE4,0x00,0x22,0xDA,0x20,0x67,0x7C,0x88,0x6B,0xE4,0x00,0x22,0x3A,
+0x88,0x6A,0x0D,0x61,0x06,0x0D,0x41,0x0A,0x0D,0x21,0x0E,0x1C,0x21,0x10,0x85,0x29,
+0x1C,0x21,0xD0,0x0D,0x21,0x2C,0x0D,0x41,0x28,0x0D,0x61,0x24,0x0D,0x81,0x20,0x0D,
+0xA1,0x1C,0x0D,0xC1,0x18,0x0D,0xE1,0x14,0x0E,0x01,0x10,0x0E,0x21,0x0C,0x0E,0x41,
+0x08,0x0E,0x61,0x04,0xE4,0x00,0x5F,0x1C,0xC1,0x80,0x10,0x01,0xC0,0x60,0x00,0x21,
+0xFD,0x4C,0x00,0xC4,0xFC,0x63,0xB0,0xE4,0xC0,0x80,0x10,0x01,0xC0,0xA0,0x10,0x01,
+0xFC,0x84,0x00,0x00,0xFC,0xA5,0x03,0x44,0x40,0xA5,0x25,0xE4,0x00,0x5A,0x00,0x0C,
+0x0A,0x01,0x0C,0x0A,0x03,0x0C,0x0A,0x05,0x0C,0x0A,0x08,0xC2,0xE0,0x10,0x01,0xEC,
+0x17,0x00,0xB3,0x0C,0x0A,0x0C,0x9A,0xEA,0xC1,0xC0,0x10,0x01,0x0E,0xEA,0x11,0xEC,
+0x0E,0x06,0x50,0x50,0x60,0x26,0xE4,0x00,0x22,0xD4,0xC8,0x80,0xE1,0x00,0x98,0x60,
+0xE4,0x00,0x2E,0xCE,0x98,0x63,0xE4,0x00,0x2D,0x56,0xE4,0x00,0x06,0xF0,0xC2,0xE0,
+0x10,0x01,0x9B,0x3C,0xF3,0x17,0x0C,0xD8,0x47,0x18,0xCC,0xFC,0x60,0x0B,0xB8,0xFB,
+0x17,0x0C,0xD8,0x05,0x60,0x5B,0xC9,0x6B,0x8D,0x80,0x88,0x8B,0xE4,0x00,0x2D,0x8E,
+0x98,0x61,0xC2,0x58,0x00,0x21,0x8A,0x6B,0xC1,0x80,0x10,0x01,0xC1,0xA0,0x10,0x01,
+0xC1,0x60,0x10,0x01,0xE4,0x00,0x2D,0x66,0xC2,0x00,0x10,0x01,0xC1,0xE0,0x10,0x01,
+0xC2,0x20,0x10,0x01,0xFE,0x52,0xB7,0x34,0xFD,0x8C,0x06,0x4A,0xFD,0xAD,0x08,0x24,
+0xFD,0x6B,0x06,0x44,0xE4,0x00,0x2D,0x16,0x0E,0xEA,0x0E,0x22,0xE5,0xA0,0x22,0xE0,
+0x2C,0xD2,0xE2,0x17,0xB6,0xE4,0x00,0x02,0x5F,0xE4,0x00,0x58,0xAC,0xE4,0x00,0x2D,
+0x2C,0x0C,0x6A,0x13,0xE4,0x00,0x2D,0x1E,0x0C,0x6A,0x17,0xE4,0x00,0x2D,0x10,0x0C,
+0x6A,0x1B,0xE4,0x00,0x2D,0x02,0x0C,0x6A,0x19,0x0A,0xEC,0x01,0xC6,0xF7,0xFF,0xDF,
+0x0E,0xEC,0x01,0x0A,0xEC,0x01,0xC6,0xF7,0xFF,0x7F,0x0E,0xEC,0x01,0x9A,0xE1,0x0E,
+0xEA,0x0C,0x0A,0xED,0x01,0x52,0xF7,0x80,0xEC,0x0E,0x06,0x50,0x0E,0xED,0x01,0x98,
+0x61,0xE4,0x00,0x1D,0x24,0x98,0x60,0xE4,0x00,0x30,0x0E,0xE4,0x00,0x2F,0x1C,0xE4,
+0x00,0x05,0x31,0xEE,0xF0,0x06,0x4E,0x22,0xE4,0x4E,0x9A,0xE2,0x0E,0xEA,0x0C,0x0C,
+0x0B,0x00,0xEC,0x10,0x06,0x4C,0xE4,0x00,0x05,0x03,0xEE,0xEE,0x06,0x52,0x22,0xE0,
+0x2C,0xD2,0xE1,0x13,0xB6,0xE4,0x00,0x00,0x3D,0x98,0x61,0xE7,0xFF,0xFC,0x5C,0xD0,
+0x61,0x13,0x46,0xEC,0x0F,0x0D,0x7C,0xEC,0x6E,0x06,0x50,0xE4,0x00,0x5F,0xEA,0xE4,
+0x00,0x02,0x81,0x0A,0xEA,0x01,0xC6,0xF7,0x01,0x00,0xD2,0xE0,0x12,0x6A,0xE4,0x00,
+0x2B,0xEA,0x0A,0xEA,0x13,0x0B,0x0A,0x11,0x40,0x63,0xBD,0x5E,0xE3,0x04,0xD7,0x17,
+0x11,0xCD,0xE4,0x00,0x2B,0xC2,0x0C,0x6A,0x13,0x0A,0xEA,0x01,0xC6,0xF7,0xFE,0xFF,
+0x0E,0xEA,0x01,0xE4,0x00,0x5A,0x2E,0xE4,0x00,0x5F,0xE2,0xE4,0x00,0x5F,0x12,0xEE,
+0xEF,0x0D,0x7E,0xEE,0xF1,0x09,0xA8,0xE4,0x00,0x5B,0x26,0x98,0x61,0xE4,0x00,0x8F,
+0x40,0xE4,0x00,0x5B,0xAA,0x98,0x61,0xE4,0x00,0x5C,0x02,0xE4,0x00,0x5C,0xBC,0xE4,
+0x00,0x81,0x14,0x0A,0xED,0x01,0x56,0xF7,0x80,0xD2,0xE0,0x0F,0x72,0x0A,0xEA,0x01,
+0xC6,0xF7,0x01,0x00,0x22,0xE3,0xE4,0x0A,0xEA,0x01,0xC6,0xF7,0xFE,0xFF,0x0E,0xEA,
+0x01,0x9A,0xE1,0x0E,0xEA,0x0C,0xEC,0x0E,0x06,0x50,0x98,0x61,0xE4,0x00,0x1B,0x6E,
+0xE4,0x00,0x03,0x8F,0x0E,0xEB,0x02,0xD2,0xE4,0x0E,0x05,0x4E,0xF7,0x10,0x8E,0xF2,
+0x0E,0xF7,0x02,0x86,0xE9,0x0A,0xEC,0x01,0xC6,0xF7,0xFF,0xDF,0x0E,0xEC,0x01,0x0A,
+0xEC,0x01,0xC6,0xF7,0xFF,0x7F,0xFF,0x00,0xFF,0x7F,0x0E,0xEC,0x01,0x0A,0xED,0x01,
+0x46,0xF7,0xC4,0x0E,0xED,0x01,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0D,0x58,0xC2,0xE0,
+0x10,0x01,0xF8,0x17,0x0C,0xF5,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0D,0x59,0xE4,0x00,
+0x5C,0xDE,0x98,0x62,0xE4,0x00,0x29,0xBE,0x50,0x60,0x40,0xE4,0x00,0x29,0xD0,0x50,
+0x60,0x19,0xE4,0x00,0x5A,0xBC,0xE4,0x00,0x04,0x04,0x50,0x60,0xC8,0xE4,0x00,0x2A,
+0x30,0xE4,0x00,0x62,0x40,0x50,0x60,0x40,0xE4,0x00,0x5A,0x88,0xC8,0x80,0x7D,0x00,
+0xFC,0x60,0x0B,0xB8,0xE4,0x00,0x29,0x9E,0xFC,0x60,0x06,0x00,0xE4,0x00,0x5A,0x70,
+0xE4,0x00,0x03,0xC0,0xE4,0x00,0x02,0x5D,0x98,0x60,0xE7,0xFF,0xF9,0xDE,0xD0,0x61,
+0x09,0x4E,0x9A,0xE2,0xEC,0x0F,0x0D,0x7C,0x0E,0xEB,0x00,0xE4,0x00,0x5D,0xCA,0xE4,
+0x00,0x5D,0x0A,0xE4,0x00,0x02,0x29,0x0A,0xEA,0x01,0xC6,0xF7,0x01,0x00,0xD2,0xE0,
+0x05,0x8A,0x0A,0xEA,0x01,0xC6,0xF7,0xFE,0xFF,0x0E,0xEA,0x01,0xE4,0x00,0x03,0x48,
+0x98,0x60,0x98,0x80,0xE4,0x00,0x28,0xA6,0xFC,0x60,0x0B,0xB8,0xC8,0x80,0x7D,0x00,
+0xE4,0x00,0x28,0xE6,0xE4,0x00,0x29,0x0E,0xFC,0x60,0x0B,0xB8,0x88,0x93,0xE4,0x00,
+0x28,0xCA,0x98,0x81,0x98,0x60,0xE4,0x00,0x28,0x62,0xE4,0x00,0x02,0xE4,0x98,0x62,
+0xE4,0x00,0x28,0xDE,0xE4,0x00,0x28,0xDE,0x0C,0x6A,0x13,0x0A,0xEA,0x01,0xC6,0xF7,
+0xFE,0xFF,0x0E,0xEA,0x01,0xE4,0x00,0x57,0x4A,0xE4,0x00,0x58,0x62,0xE4,0x00,0x8C,
+0xE2,0x98,0x80,0x98,0x64,0xE4,0x00,0x40,0x90,0xE4,0x00,0x5C,0x16,0xEE,0xEF,0x0D,
+0x7E,0xEE,0xF1,0x09,0xA8,0xE4,0x00,0x58,0xC2,0x98,0x60,0xE4,0x00,0x59,0x1A,0xE4,
+0x00,0x59,0xD4,0xE4,0x00,0x7E,0x2C,0x0A,0xED,0x01,0x56,0xF7,0x80,0x22,0xE0,0x88,
+0x0A,0xEA,0x01,0xC6,0xF7,0x01,0x00,0x22,0xE3,0xE4,0x0A,0xEA,0x01,0xC6,0xF7,0xFE,
+0xFF,0x0E,0xEA,0x01,0x9A,0xE1,0x98,0x60,0x0E,0xEB,0x00,0xE4,0x00,0x18,0x90,0xC2,
+0xE0,0x10,0x01,0xEA,0xF7,0x0D,0x61,0x5E,0xEB,0x01,0x20,0x00,0x29,0x1E,0xF7,0xA0,
+0xD2,0xEB,0x02,0x3D,0x9A,0xE3,0xE4,0x00,0x00,0x7D,0x98,0x63,0xE4,0x00,0x2B,0x44,
+0xE4,0x00,0x2A,0x52,0xE4,0x00,0x27,0xBE,0x9A,0xE4,0x0C,0x6A,0x17,0xE4,0x00,0x00,
+0x4F,0xE4,0x00,0x27,0xA4,0x0A,0xEA,0x17,0x40,0x63,0xBD,0x5E,0xE3,0x04,0xC2,0xE0,
+0x7C,0xEA,0x20,0x00,0x55,0x98,0x60,0xE4,0x00,0x26,0x9E,0xE4,0x00,0x27,0x70,0x0C,
+0x6A,0x17,0x9A,0xE2,0x0E,0xEB,0x00,0x0E,0xEA,0x0A,0xFC,0x60,0x1E,0x7F,0x9E,0xE1,
+0x0E,0xEA,0x08,0x0C,0x8A,0x0A,0xE4,0x00,0x29,0x12,0xE4,0x00,0x27,0xE2,0xE7,0xFF,
+0xF9,0xCD,0xE4,0x00,0xA3,0x49,0x9C,0x38,0x0D,0x21,0x04,0x0D,0x41,0x00,0xE4,0x00,
+0xA4,0xA4,0x98,0x68,0xE4,0x00,0x95,0x1E,0x98,0x60,0xFC,0x80,0x28,0x0A,0xE4,0x00,
+0x97,0x62,0x98,0x61,0xFC,0x80,0x28,0x0A,0xE4,0x00,0x97,0x4E,0x98,0x60,0x50,0x80,
+0x14,0xE4,0x00,0x9C,0x48,0x98,0x60,0x98,0x8C,0xE4,0x00,0x9B,0x6A,0x98,0x61,0x50,
+0x80,0x14,0xE4,0x00,0x9C,0x26,0x98,0x61,0x98,0x8C,0x99,0x40,0xE4,0x00,0x9B,0x44,
+0x88,0x6A,0x98,0x80,0x9D,0x41,0xE4,0x00,0xA1,0xB0,0x5D,0x4A,0x00,0xD1,0x44,0xFF,
+0x9E,0x98,0x60,0x05,0x40,0xFF,0xC9,0x4A,0xFF,0xFF,0x88,0x8A,0xE4,0x00,0x99,0x9E,
+0x88,0x8A,0x98,0x60,0xE4,0x00,0x97,0x26,0x88,0x8A,0x0D,0x21,0x06,0x0D,0x41,0x02,
+0x98,0x60,0x9C,0x28,0xE4,0x00,0x98,0x07,0xE4,0x00,0xA3,0xF3,0xE4,0x00,0xA5,0x97,
+0xE4,0x00,0xA6,0xC3,0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x06,0x77,0x1C,0x21,0xB0,0x0E,
+0xE1,0x10,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x06,0x54,0x0D,0x41,0x4C,0x0D,0x61,0x48,
+0x0D,0x81,0x44,0x0D,0xE1,0x38,0x0E,0x01,0x34,0x0E,0x21,0x30,0x0E,0x41,0x2C,0x0E,
+0x61,0x28,0x0E,0x81,0x24,0x0D,0xA1,0x40,0x0D,0xC1,0x3C,0x0E,0xA1,0x20,0x0E,0xC1,
+0x1C,0x0E,0xE1,0x0C,0xC2,0x60,0x10,0x01,0xC2,0x40,0x10,0x01,0xFE,0x73,0x06,0x74,
+0xFE,0x52,0x06,0x5C,0xC2,0x20,0x10,0x01,0xC2,0x00,0x10,0x01,0xFE,0x31,0x06,0x60,
+0xFE,0x10,0x06,0x64,0xC1,0xE0,0x10,0x01,0xC1,0x8F,0xFF,0xE1,0xFD,0xEF,0x06,0x70,
+0x9B,0x80,0xC2,0x98,0x00,0x21,0xC0,0xD8,0x00,0x21,0x13,0x53,0x00,0x0E,0xF2,0x02,
+0x0D,0x51,0x02,0x0F,0xB0,0x02,0x0F,0x6F,0x02,0x99,0x60,0xC9,0x8C,0xFF,0xFF,0x88,
+0xFC,0x53,0x20,0xFF,0xFE,0x94,0xB7,0x64,0xFC,0xC6,0xB8,0xB4,0xE4,0x00,0x01,0xC5,
+0x41,0x14,0xC4,0x9F,0x01,0x11,0x08,0x00,0x8D,0xA8,0x5D,0xAD,0x00,0xE4,0x00,0x00,
+0x11,0x9B,0x00,0x89,0xB8,0x5D,0x18,0x00,0xD7,0xC8,0xFF,0x45,0xC3,0x18,0x00,0x21,
+0xFF,0x18,0xB7,0x64,0x8F,0x0B,0x99,0x00,0x12,0xB8,0x00,0xCF,0x0D,0x00,0x0A,0x1E,
+0xD5,0xFF,0x8F,0x06,0x0E,0xC1,0x08,0x0F,0x01,0x14,0xE4,0x00,0x01,0x37,0x0F,0x01,
+0x16,0xCD,0xE8,0x00,0x0A,0x8D,0xF8,0x0A,0xCF,0x00,0x0E,0xC1,0x04,0x0F,0x01,0x0E,
+0x0E,0xC1,0x0A,0xD5,0x16,0x00,0x3A,0x0B,0x0F,0x0A,0x0D,0xE1,0x06,0xD5,0xE4,0x03,
+0xB4,0xD4,0x98,0x03,0x94,0x8D,0xCD,0x5D,0xCE,0x00,0xCF,0x0E,0x00,0x0A,0x8F,0x06,
+0x09,0xF8,0x06,0x0B,0x18,0x08,0x4F,0x18,0x50,0x41,0xEF,0x23,0x8D,0xF8,0xFD,0xEF,
+0x02,0x00,0x4D,0xEF,0x52,0x5D,0xEF,0x06,0x41,0xEF,0x7B,0x43,0x03,0x7D,0x4E,0xD8,
+0xFA,0x47,0x16,0xC6,0x43,0x18,0xB5,0xD7,0x0C,0x01,0x4C,0xC3,0x20,0x1F,0xE4,0x20,
+0x00,0x2D,0x89,0x5D,0x89,0x97,0x8B,0x3A,0x88,0xFC,0x8B,0xAA,0x8A,0xEC,0x8B,0x59,
+0x8B,0x87,0x8B,0x78,0x89,0x4F,0x89,0x98,0x88,0xEE,0x8B,0x3E,0xE4,0x00,0x00,0x2F,
+0xC3,0x40,0x1F,0xE0,0x20,0x00,0x1D,0xD6,0xF8,0x00,0x60,0x8B,0xAF,0x8A,0xF8,0x8B,
+0x5E,0x8B,0x8E,0x9D,0x01,0x5D,0xC8,0x00,0xD6,0xAE,0xFB,0x35,0x9D,0x61,0x5F,0xCB,
+0x00,0x0E,0xC1,0x12,0xD6,0xDE,0xF9,0x6D,0xC3,0x00,0x10,0x01,0x1B,0x53,0x00,0xFF,
+0x18,0x06,0x70,0x0E,0xF2,0x00,0x0D,0x51,0x00,0x0F,0xB0,0x00,0x0F,0x78,0x00,0xC3,
+0x20,0x1F,0xE0,0x20,0x01,0x55,0xCF,0x9C,0x00,0x0A,0xCC,0xE7,0x00,0x0A,0x8C,0xE6,
+0x0B,0x07,0x04,0x4F,0x18,0x50,0x8C,0xDC,0x08,0x67,0x02,0x0B,0x86,0x02,0x40,0x63,
+0x23,0x0B,0x46,0x04,0x8C,0x78,0x43,0x1B,0xBC,0xFC,0x63,0x02,0x00,0x4C,0x63,0x52,
+0x23,0x00,0xA8,0xC2,0xE0,0x1F,0xE0,0x20,0x00,0x8D,0x40,0x63,0xBB,0x40,0x9C,0x23,
+0x4E,0xFA,0x50,0x8E,0xE4,0xFE,0xF7,0x02,0x00,0x4E,0xF7,0x52,0x43,0x77,0xDB,0x8C,
+0x7B,0x40,0x63,0xC0,0xE4,0x00,0x00,0x0D,0x88,0x64,0x0E,0xC1,0x1E,0x0E,0xA1,0x22,
+0x0E,0x81,0x26,0x0E,0x61,0x2A,0x0E,0x41,0x2E,0x0E,0x21,0x32,0x0E,0x01,0x36,0x0D,
+0xE1,0x3A,0x0D,0xC1,0x3E,0x0D,0xA1,0x42,0x0D,0x81,0x46,0x0D,0x61,0x4A,0x0D,0x41,
+0x4E,0x1B,0x25,0x00,0x1C,0x21,0x50,0x85,0x29,0x8B,0x23,0xC2,0xE0,0x10,0x01,0x5C,
+0xA5,0x00,0xF2,0xF7,0x06,0x77,0x98,0x60,0xD6,0xE5,0x0C,0xB9,0xD3,0x3F,0x0C,0x98,
+0xC2,0xE0,0x10,0x01,0xC3,0x00,0x10,0x01,0xC3,0x60,0x10,0x01,0xF2,0xF7,0x06,0x76,
+0xFF,0x18,0x06,0x56,0xFF,0x7B,0x06,0x75,0x22,0xE8,0x42,0x13,0x18,0x00,0x5F,0x08,
+0x9B,0x20,0x00,0x51,0xE4,0x00,0x01,0x3B,0xD2,0xE1,0x04,0xCE,0x13,0x18,0x00,0x5F,
+0x05,0x93,0x20,0x02,0x3D,0x24,0xA4,0x4B,0x9B,0x43,0x43,0x5A,0x2D,0x4F,0x5A,0x08,
+0x5F,0x5A,0x00,0xE4,0x00,0x00,0x37,0x20,0xA8,0x54,0x9B,0x44,0x43,0x5A,0x2D,0x4F,
+0x5A,0x08,0x5F,0x5A,0x00,0x20,0xAC,0xEE,0xE4,0x00,0x00,0x51,0x9B,0x43,0x9A,0xE0,
+0x13,0x9B,0x00,0x8B,0x17,0xE4,0x00,0x00,0x27,0x4F,0xB8,0x08,0x9F,0x01,0x8F,0xBC,
+0x5F,0x18,0x00,0x8E,0xFD,0x5E,0xF7,0x00,0xD7,0x05,0xFF,0x8E,0xE4,0x00,0x00,0x49,
+0x5E,0xE0,0x21,0x53,0x00,0x1D,0x52,0xE0,0x2F,0x4A,0xF8,0xB8,0xE4,0x00,0x00,0x4B,
+0x5E,0xE0,0x29,0x53,0x00,0x41,0x52,0xE0,0x29,0x4A,0xF8,0xB8,0xE4,0x00,0x00,0x2B,
+0x27,0x04,0x33,0x9F,0x9F,0x4F,0x18,0x08,0xE4,0x00,0x00,0x8B,0x9B,0x0A,0x20,0xA9,
+0x10,0x13,0x1B,0x00,0x9C,0xBF,0x9F,0x1F,0x4C,0xA5,0x08,0x8F,0x05,0xE4,0x00,0x00,
+0x65,0x9B,0x43,0x13,0xBB,0x00,0x43,0x5A,0x2D,0x9A,0xE0,0x4F,0x5A,0x08,0x8B,0x77,
+0x5F,0x5A,0x00,0xE4,0x00,0x00,0x21,0x8F,0x9D,0x9F,0x61,0x8E,0xFC,0x5F,0x7B,0x00,
+0x5E,0xF7,0x00,0x4F,0x9B,0x08,0xD7,0x65,0xFF,0x8E,0x1F,0x1D,0xFF,0x8F,0x1C,0x5F,
+0x18,0x00,0x4F,0x5A,0x08,0xC3,0xB8,0x00,0x21,0xFF,0xBD,0xB7,0x48,0x8F,0xBA,0x9B,
+0x40,0xE4,0x00,0x01,0x0B,0x4F,0x7A,0x08,0x8F,0x7D,0x0B,0x9B,0x00,0xD7,0x3C,0x03,
+0xBC,0x0B,0x7B,0x02,0xD7,0x79,0x03,0x84,0x8E,0xFA,0xC3,0xB8,0x00,0x21,0xCF,0x17,
+0x00,0x06,0xFF,0xBD,0xB7,0x6A,0x8F,0x1D,0x1F,0x57,0x01,0x14,0xD8,0x00,0xCF,0x5A,
+0x00,0x06,0x09,0x18,0x02,0x8F,0x5D,0x98,0x60,0x0B,0xB8,0x04,0x14,0xBA,0x00,0x0B,
+0xDA,0x02,0x0B,0x1A,0x04,0xD7,0x9B,0x02,0x52,0x42,0xF9,0xDD,0x40,0x77,0x33,0x43,
+0x3C,0xCD,0x43,0x59,0x2B,0x43,0xD9,0xF3,0x8F,0x43,0x40,0x77,0x43,0x43,0x5A,0x23,
+0x8C,0x7E,0x8C,0x7A,0x42,0xF7,0xEB,0x40,0x83,0x23,0x97,0x41,0x43,0x39,0xC3,0xCB,
+0x5A,0x86,0xA0,0x8F,0x37,0x40,0x64,0xD0,0x43,0x7C,0xDD,0x8C,0x79,0x40,0x63,0xD8,
+0xE4,0x00,0x00,0x1F,0x9F,0x41,0x5F,0x7A,0x00,0xD7,0x1B,0xFB,0xE5,0x98,0x60,0x85,
+0x29,0xC2,0xE0,0x10,0x01,0xF8,0x77,0x06,0x76,0xC2,0xE0,0x10,0x01,0xF8,0x97,0x06,
+0x6C,0xC2,0xE0,0x10,0x01,0xF8,0xB7,0x06,0x56,0xC2,0xE0,0x10,0x01,0xF8,0xD7,0x06,
+0x75,0xC2,0xE0,0x10,0x01,0xEC,0xF7,0x06,0x55,0x85,0x29,0x9A,0xFF,0x1C,0x21,0xD8,
+0x0D,0xE1,0x0C,0x1A,0xE1,0x07,0xC1,0xE0,0x10,0x01,0xFD,0xEF,0x06,0x74,0x1A,0xEF,
+0x00,0x52,0xE0,0xFF,0xC3,0x00,0x10,0x01,0x0D,0x41,0x20,0x0D,0x61,0x1C,0x0D,0xA1,
+0x14,0x0D,0xC1,0x10,0xCB,0x20,0xFF,0xFF,0xC1,0xC0,0x10,0x01,0xEF,0x38,0x06,0x58,
+0xFD,0xCE,0x06,0x70,0xC1,0xA0,0x10,0x01,0x0E,0xEE,0x00,0xFD,0xAD,0x06,0x5C,0x0D,
+0x21,0x24,0x0E,0xED,0x00,0x0D,0x81,0x18,0xC2,0xE0,0x10,0x01,0x0E,0x01,0x08,0x89,
+0x63,0xF3,0x17,0x06,0x76,0x89,0x44,0x88,0x65,0xC2,0xE0,0x10,0x01,0x23,0x08,0x56,
+0xC3,0x00,0x10,0x01,0xF3,0x18,0x06,0x56,0x5F,0x08,0x9B,0x20,0x00,0x61,0xE4,0x00,
+0x00,0x37,0x23,0x04,0x5E,0xC3,0x00,0x10,0x01,0xF3,0x18,0x06,0x56,0x5F,0x05,0x93,
+0x20,0x00,0x25,0x9B,0x05,0xE4,0x00,0x00,0x0D,0x9B,0x04,0xFB,0x17,0x06,0x77,0xC2,
+0x00,0x10,0x01,0x0E,0xEB,0x02,0xEE,0xF0,0x06,0x58,0x0A,0xE6,0x0A,0x0C,0x8B,0x02,
+0xD4,0x97,0x04,0xCC,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x0C,0xDB,0x53,0x18,0x01,0x1C,
+0xA1,0x07,0xEF,0x17,0x0C,0xDB,0xE7,0xFF,0xF6,0x9C,0x0C,0x6B,0x00,0x0C,0x8A,0x02,
+0xED,0x90,0x06,0x5A,0x10,0xAF,0x00,0x88,0x6C,0xE7,0xFF,0xFA,0xC0,0xC2,0xE0,0x10,
+0x01,0x89,0x63,0xEC,0x77,0x06,0x68,0x10,0xA1,0x07,0x0C,0x8A,0x02,0x88,0x6C,0xE7,
+0xFF,0xFA,0x94,0xC3,0x00,0x10,0x01,0xEC,0x78,0x06,0x78,0x0F,0x6E,0x02,0x0F,0x2D,
+0x02,0x0F,0x4A,0x02,0x43,0x1B,0xCC,0x23,0x00,0xEC,0xC3,0x20,0x1F,0xE0,0x20,0x00,
+0xD1,0xC3,0x80,0x10,0x01,0xEF,0xBC,0x06,0x62,0xC3,0x80,0x10,0x01,0xEF,0x9C,0x06,
+0x66,0x43,0xBD,0xE5,0x4F,0x9D,0xFA,0x47,0xBC,0xEE,0x43,0x9D,0xE5,0xD7,0x1C,0x00,
+0xAC,0x41,0x6B,0xDB,0x42,0xE3,0xCB,0x8E,0xEB,0x43,0x17,0xC0,0x8F,0x58,0xE4,0x00,
+0x01,0x55,0x42,0xFA,0x1C,0xE4,0x00,0x01,0x5B,0xC9,0x80,0x07,0xFF,0x42,0xEC,0xBD,
+0xD6,0xE4,0x05,0x2C,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x0C,0xDB,0x53,0x18,0x01,0x40,
+0x8C,0x25,0xEF,0x17,0x0C,0xDB,0x1C,0xA1,0x07,0xE7,0xFF,0xF5,0x56,0x40,0x6C,0x1D,
+0x0C,0x6B,0x00,0xEE,0xF0,0x06,0x5A,0x0C,0x8A,0x02,0x41,0x8C,0xBD,0x10,0xAF,0x00,
+0x88,0x6C,0xE7,0xFF,0xF9,0x6E,0xC2,0xE0,0x10,0x01,0x89,0x63,0xEC,0x77,0x06,0x68,
+0x10,0xA1,0x07,0x0C,0x8A,0x02,0x88,0x6C,0xE7,0xFF,0xF9,0x42,0xC3,0x00,0x10,0x01,
+0xEC,0x78,0x06,0x78,0x0F,0x6E,0x02,0x0F,0x2D,0x02,0x0F,0x4A,0x02,0x43,0x1B,0xCC,
+0x23,0x00,0xFC,0xC3,0x20,0x1F,0xE0,0x20,0x00,0xE1,0xC3,0x80,0x10,0x01,0xEF,0xBC,
+0x06,0x62,0xC3,0x80,0x10,0x01,0xEF,0x9C,0x06,0x66,0x43,0xBD,0xE5,0x4F,0x9D,0xFA,
+0x47,0xBC,0xEE,0x43,0x9D,0xE5,0xD7,0x1C,0x00,0xCC,0x41,0x6B,0xDB,0x42,0xE3,0xCB,
+0x8E,0xEB,0x43,0x17,0xC0,0x43,0x5A,0xC5,0x0F,0x4A,0x00,0xE4,0x00,0x00,0x15,0x42,
+0xFA,0x1D,0x0E,0xEA,0x00,0x0E,0x01,0x0A,0x0D,0xE1,0x0E,0x0D,0xC1,0x12,0x0D,0xA1,
+0x16,0x0D,0x81,0x1A,0x0D,0x61,0x1E,0x0D,0x41,0x22,0x0D,0x21,0x26,0x1C,0x21,0x28,
+0x85,0x29,0x1C,0x21,0xD0,0x0D,0x41,0x28,0x0D,0x61,0x24,0x0D,0x81,0x20,0x0D,0xA1,
+0x1C,0x0D,0xC1,0x18,0x0D,0xE1,0x14,0x0E,0x01,0x10,0x0E,0x21,0x0C,0x0E,0x41,0x08,
+0x5E,0x23,0x00,0x0E,0x61,0x04,0x56,0x11,0x03,0x4E,0xF1,0x11,0x5E,0x00,0x09,0x99,
+0xC0,0x4A,0x41,0x01,0x99,0x80,0x9A,0x64,0x0D,0x21,0x2C,0x8E,0x57,0x89,0x44,0x89,
+0xAE,0x89,0x6C,0x99,0xE0,0x42,0x73,0x25,0xE4,0x00,0x00,0xF3,0x42,0xF3,0x54,0xD6,
+0xF1,0x01,0xD8,0x22,0x04,0x4A,0x51,0xC0,0x10,0x11,0x6A,0x00,0x89,0xAE,0x51,0x80,
+0x10,0xE4,0x00,0x00,0x6B,0x22,0x08,0x4A,0x51,0xC0,0x10,0x11,0x6A,0x00,0x11,0x8A,
+0x01,0x89,0xAE,0xE4,0x00,0x00,0x47,0x22,0x0C,0x7E,0x11,0x6A,0x00,0x11,0x8A,0x01,
+0x11,0xAA,0x02,0x51,0xC0,0x10,0xE4,0x00,0x00,0x21,0x11,0x6A,0x00,0x11,0x8A,0x01,
+0x11,0xAA,0x02,0x11,0xCA,0x03,0x4E,0xEC,0x80,0x4C,0x8C,0xC0,0x8C,0x97,0x4E,0xEE,
+0x80,0x4F,0x0B,0x40,0x4C,0xAE,0xC0,0x8C,0xB7,0x4E,0xED,0x40,0x88,0x6F,0x8C,0x8B,
+0x8C,0xAD,0x8C,0x98,0x8C,0xB7,0x9D,0xE1,0xE4,0x00,0x87,0xC6,0x5D,0xEF,0x00,0x9D,
+0x44,0xD5,0xF2,0xFC,0x5E,0x0E,0x61,0x06,0x0E,0x41,0x0A,0x0E,0x21,0x0E,0x0E,0x01,
+0x12,0x0D,0xE1,0x16,0x0D,0xC1,0x1A,0x0D,0xA1,0x1E,0x0D,0x81,0x22,0x0D,0x61,0x26,
+0x0D,0x41,0x2A,0x0D,0x21,0x2E,0x1C,0x21,0x30,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEE,
+0xF7,0x00,0xD2,0x5E,0xE0,0x41,0x1C,0x21,0xE8,0x0D,0x61,0x0C,0x0D,0x81,0x08,0x0D,
+0xA1,0x04,0x0D,0x21,0x14,0x0D,0x41,0x10,0x89,0x63,0x5D,0x84,0x00,0x49,0xA1,0x01,
+0xE4,0x00,0x4B,0x94,0xC3,0x14,0x00,0x01,0xCB,0x18,0x7A,0x30,0x0A,0xF8,0x01,0xC6,
+0xF7,0x01,0x00,0x5E,0xF7,0x04,0x22,0xE3,0xD8,0xFC,0x60,0x01,0x00,0x99,0x40,0xE4,
+0x00,0x17,0x58,0xE4,0x00,0x00,0x31,0x88,0x6A,0x98,0x81,0x88,0xAD,0x9D,0x41,0xE4,
+0x00,0x9C,0x94,0x5D,0x4A,0x00,0x0C,0x6B,0x01,0x9D,0x62,0xD5,0x4C,0xFF,0x66,0x0D,
+0xA1,0x06,0x0D,0x81,0x0A,0x0D,0x61,0x0E,0x0D,0x41,0x12,0x0D,0x21,0x16,0x1C,0x21,
+0x18,0x85,0x29,0xFC,0x21,0xFD,0xF0,0xED,0x41,0x02,0x08,0xED,0xE1,0x01,0xF4,0xEE,
+0x01,0x01,0xF0,0xED,0x21,0x02,0x0C,0xED,0x61,0x02,0x04,0xED,0x81,0x02,0x00,0xED,
+0xA1,0x01,0xFC,0xED,0xC1,0x01,0xF8,0xEE,0x21,0x01,0xEC,0xEE,0x41,0x01,0xE8,0xEE,
+0x61,0x01,0xE4,0xC2,0x00,0x10,0x01,0xC1,0xE0,0x10,0x01,0x89,0x43,0xFE,0x10,0x07,
+0xBC,0xFD,0xEF,0x07,0x64,0x20,0x60,0x30,0x20,0x68,0x84,0x20,0x64,0x30,0x24,0x64,
+0x5F,0x99,0x80,0xE4,0x00,0x00,0x0D,0x99,0x81,0x4D,0x8C,0x20,0x51,0x60,0x10,0x8D,
+0x90,0xE4,0x00,0x00,0x29,0xD0,0x64,0x00,0x62,0x99,0x80,0x89,0x6C,0xE4,0x00,0x00,
+0x11,0x89,0x8F,0x99,0x63,0x9A,0xE0,0x89,0xC1,0x53,0x20,0x10,0xE4,0x00,0x00,0x19,
+0x43,0x0E,0xBC,0x9E,0xE1,0x1B,0x38,0x00,0x5F,0x17,0x00,0xD5,0x78,0xFF,0xAD,0x88,
+0x6B,0x88,0x81,0x99,0xA3,0xE7,0xFF,0xFC,0x1A,0x89,0xC1,0xFE,0x20,0xFE,0xB0,0xCA,
+0x40,0x01,0x50,0x52,0x60,0x3F,0x1C,0x61,0x60,0x88,0x8B,0xE7,0xFF,0xFD,0xC0,0x1F,
+0x21,0x60,0x8B,0x01,0x9B,0x41,0xE4,0x00,0x00,0x93,0x0A,0xF9,0x00,0xC2,0xFF,0xD5,
+0xEC,0x20,0x00,0x39,0x43,0x71,0xBD,0xC3,0x60,0x2A,0x0C,0xE4,0x00,0x00,0x0F,0x5E,
+0xE0,0x19,0x4B,0x61,0x01,0x23,0x60,0x98,0xFE,0xF7,0x01,0x50,0x13,0x58,0x00,0x42,
+0xF7,0x90,0x8E,0xFA,0x5E,0xF7,0x06,0x26,0xFC,0x34,0x5E,0xE7,0xF1,0x4A,0xF7,0x98,
+0xE4,0x00,0x00,0x0D,0x9A,0xE0,0x1A,0xF8,0x00,0x9B,0x40,0x9F,0x01,0x9F,0x22,0x42,
+0xF8,0x75,0x5E,0xF7,0x00,0xD5,0x77,0xFD,0xAD,0x23,0x40,0x24,0x9A,0xE0,0xE4,0x00,
+0x00,0x51,0x88,0x6B,0x88,0x81,0x9D,0xBF,0xE7,0xFF,0xFB,0x14,0x5D,0xAD,0x00,0x21,
+0xA2,0x1E,0xE7,0xFF,0xFF,0xD5,0x43,0x0C,0xBC,0x1F,0x21,0x00,0x8F,0x37,0x9E,0xE1,
+0x13,0x39,0x00,0x1B,0x38,0x00,0x5F,0x17,0x00,0xD5,0x78,0xFF,0x6D,0x21,0x40,0x64,
+0x21,0x48,0x28,0x21,0x44,0x8C,0xD1,0x44,0x01,0xCA,0x99,0x60,0x99,0x80,0x88,0x8B,
+0x89,0x4C,0xE4,0x00,0x00,0x77,0xC1,0x80,0x10,0x01,0x99,0x60,0x88,0x90,0xFD,0x8C,
+0x0A,0x64,0xE4,0x00,0x00,0x2D,0xC0,0x80,0x10,0x01,0xC1,0x80,0x10,0x01,0x99,0x61,
+0xFC,0x84,0x07,0xCC,0xFD,0x8C,0x0A,0xA4,0x51,0x40,0x10,0xE4,0x00,0x00,0x25,0xC1,
+0x80,0x10,0x01,0x99,0x68,0x88,0x8F,0xFD,0x8C,0x0C,0xCC,0x99,0x43,0x88,0x6A,0xE7,
+0xFF,0xFA,0x26,0xFD,0xA1,0x01,0x20,0x88,0x8A,0x88,0x6D,0xE7,0xFF,0xFB,0xE0,0x9A,
+0xE0,0xE4,0x00,0x00,0x33,0x4F,0x17,0x10,0x4F,0x37,0x08,0x8F,0x0C,0x8F,0x2D,0x9E,
+0xE1,0x0B,0x39,0x00,0x4F,0x39,0x40,0x0F,0x38,0x00,0x5F,0x17,0x00,0xD5,0x58,0xFF,
+0x45,0x88,0x6B,0xE4,0x00,0x48,0xF4,0xED,0x21,0x02,0x0E,0xEE,0x61,0x01,0xE6,0xEE,
+0x41,0x01,0xEA,0xEE,0x21,0x01,0xEE,0xEE,0x01,0x01,0xF2,0xED,0xE1,0x01,0xF6,0xED,
+0xC1,0x01,0xFA,0xED,0xA1,0x01,0xFE,0xED,0x81,0x02,0x02,0xED,0x61,0x02,0x06,0xED,
+0x41,0x02,0x0A,0xFC,0x21,0x02,0x10,0x85,0x29,0x9C,0x38,0xC2,0xE0,0x10,0x01,0x0D,
+0x21,0x04,0xFE,0xF7,0x07,0xBC,0x9B,0x00,0x13,0x37,0x00,0x13,0x57,0x10,0x8F,0x3A,
+0x4F,0x39,0x08,0x9E,0xE1,0x8F,0x19,0xC3,0x20,0x10,0x01,0xFF,0x39,0x07,0xCC,0xD6,
+0xF9,0xFF,0x4E,0xC2,0xE0,0x10,0x01,0xF3,0x57,0x07,0x64,0xFE,0xF7,0x07,0x64,0x13,
+0x37,0x02,0x13,0x77,0x01,0x98,0x60,0x42,0xFB,0xD4,0x98,0x80,0x8E,0xF9,0x53,0x20,
+0x43,0x4E,0xF7,0x08,0x8E,0xF8,0x97,0x03,0x4E,0xF7,0x09,0xCB,0x18,0xD0,0x8F,0xCE,
+0xF7,0x03,0x5B,0x42,0xF7,0xC9,0xCE,0xF7,0x00,0x23,0xD6,0xF8,0x00,0xA1,0x97,0x2F,
+0x98,0x60,0xCB,0x39,0x42,0x3F,0x98,0x82,0xD6,0xF9,0x00,0x31,0x98,0x87,0xE4,0x00,
+0x91,0x8A,0x0D,0x21,0x06,0x98,0x61,0x98,0x80,0x9C,0x28,0xE4,0x00,0x91,0x71,0x9C,
+0x38,0x98,0x80,0x0D,0x21,0x04,0x98,0x66,0xE4,0x00,0x26,0x06,0x98,0x60,0xE7,0xFF,
+0xFA,0xEA,0x98,0x81,0x98,0x66,0xE4,0x00,0x25,0xEA,0x98,0x61,0xE7,0xFF,0xFA,0xCE,
+0x98,0x66,0x98,0x87,0xE4,0x00,0x25,0xCE,0x0D,0x21,0x06,0x98,0x64,0x9C,0x28,0xE7,
+0xFF,0xFA,0xA9,0xC2,0xE0,0x10,0x01,0x5C,0xA0,0x29,0xF3,0x37,0x0A,0xE4,0x53,0x40,
+0x6C,0x52,0xE0,0x36,0xC3,0x60,0x10,0x01,0x4B,0x5A,0xB8,0xFF,0x7B,0x0D,0x04,0x20,
+0x60,0x6C,0xE4,0x00,0x00,0x55,0x4F,0x17,0x08,0x9E,0xE1,0x8F,0x1B,0x0B,0x18,0x00,
+0xD7,0x58,0x00,0x78,0x98,0x61,0xE4,0x00,0x00,0xD9,0x9A,0xE0,0x43,0x40,0xD5,0x5F,
+0x17,0x00,0xD7,0x38,0xFF,0x25,0x98,0x60,0xE4,0x00,0x00,0xB5,0x20,0x67,0xEA,0x9A,
+0xE0,0x20,0x80,0xA6,0x9A,0xE0,0x43,0x80,0xD5,0xE4,0x00,0x00,0x7D,0x4F,0x17,0x08,
+0x8F,0x1B,0x0B,0x18,0x00,0x4F,0x98,0xFA,0x47,0x1C,0xC6,0x43,0x18,0xE5,0x0B,0x84,
+0x00,0xD7,0x1C,0x00,0x38,0x0F,0x04,0x01,0x9E,0xE1,0x5F,0x17,0x00,0xD7,0x38,0xFF,
+0x05,0xE7,0xFF,0xFF,0xA7,0x4F,0x17,0x08,0x8F,0x1B,0x0B,0x18,0x00,0xD7,0x98,0xFD,
+0x3C,0x9E,0xE1,0xD7,0x1A,0xFD,0x0C,0x5F,0x17,0x00,0xD7,0x38,0xFF,0x5D,0xE7,0xFF,
+0xFF,0x51,0x85,0x29,0xC2,0xE0,0x10,0x01,0xC3,0x00,0x10,0x01,0xF3,0xB7,0x0A,0xE4,
+0xC3,0xC0,0x10,0x01,0x9A,0xE0,0xFF,0x18,0x06,0x80,0x8B,0x37,0xFF,0xDE,0x0D,0x04,
+0xE4,0x00,0x00,0x5B,0x4F,0x57,0x08,0x0B,0x98,0x00,0x8F,0x5E,0x0B,0x5A,0x00,0x43,
+0x9A,0xE5,0x4F,0x7C,0xFA,0x47,0x9B,0xE6,0x43,0x7C,0xDD,0x5F,0x6A,0x31,0x20,0x00,
+0x21,0x9F,0x21,0x5F,0x39,0x00,0x0F,0x58,0x01,0x9E,0xE1,0x9F,0x02,0x5F,0x57,0x00,
+0xD7,0xBA,0xFE,0xA5,0x5F,0x21,0x13,0x48,0x61,0x01,0x85,0x29,0xC2,0xE0,0x10,0x01,
+0xC3,0x40,0x10,0x01,0xF3,0x37,0x0A,0xE4,0xC3,0x60,0x10,0x01,0x9A,0xE0,0xFF,0x5A,
+0x06,0x80,0xFF,0x7B,0x0D,0x04,0xE4,0x00,0x00,0x29,0x4F,0x17,0x08,0x9E,0xE1,0x43,
+0x9A,0xC4,0x8F,0x1B,0x0B,0x18,0x01,0x0F,0x1C,0x01,0x5F,0x17,0x00,0xD7,0x38,0xFF,
+0x6D,0x85,0x29,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0A,0xF2,0xC2,0xE0,0x10,0x01,0x9C,
+0x38,0xF8,0x17,0x09,0xC8,0x0D,0x21,0x04,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x07,0xDC,
+0x20,0x64,0x26,0x98,0x60,0xE4,0x00,0x00,0x0D,0x98,0x64,0x98,0x80,0xE4,0x00,0x27,
+0x20,0xC2,0xE0,0x10,0x01,0x0D,0x21,0x06,0xEC,0x17,0x06,0x7C,0x9C,0x28,0xE4,0x00,
+0x42,0x8D,0x1C,0x21,0xE8,0xC2,0xE0,0x10,0x01,0x0D,0x41,0x10,0xEB,0x17,0x00,0xC5,
+0x0D,0x21,0x14,0x0D,0x61,0x0C,0x0C,0x01,0x07,0x89,0x43,0xC7,0x18,0x01,0x00,0x98,
+0x60,0xD3,0x00,0x06,0x52,0xEB,0x17,0x00,0xC5,0xC7,0x18,0xFE,0xFF,0xEF,0x17,0x00,
+0xC5,0xE4,0x00,0x3D,0x32,0xE4,0x00,0x3E,0x4A,0x21,0x44,0x36,0x98,0x61,0xE4,0x00,
+0x72,0x5E,0xE4,0x00,0x00,0x11,0xE4,0x00,0x72,0xB0,0xC2,0xE0,0x10,0x01,0xED,0x77,
+0x06,0x7E,0x5D,0x60,0x01,0x0C,0x01,0x07,0x98,0x61,0x1C,0x81,0x06,0x98,0xA1,0x48,
+0x84,0x00,0x88,0xCA,0xE7,0xFF,0xFC,0x5E,0xC2,0xE0,0x10,0x01,0x20,0x60,0xEE,0xF3,
+0x17,0x0A,0xF2,0x9F,0x01,0xFB,0x17,0x0A,0xF2,0x0A,0xE1,0x06,0x5E,0xE3,0x59,0x20,
+0x00,0x45,0xC2,0xE0,0x10,0x01,0xF3,0x17,0x09,0xC8,0x9F,0x01,0xFB,0x17,0x09,0xC8,
+0x98,0x63,0x21,0x44,0x36,0x98,0x81,0xE4,0x00,0x6E,0xC6,0xE4,0x00,0x00,0x6D,0xE4,
+0x00,0x6F,0x3C,0xE4,0x00,0x00,0x5D,0xF8,0x17,0x0A,0xF2,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x09,0xC8,0x21,0x63,0x76,0x0A,0xE1,0x06,0xC2,0xE0,0x14,0x48,0x23,0xFF,0x4D,
+0x21,0x44,0x36,0x98,0x61,0xE4,0x00,0x46,0x66,0xE4,0x00,0x00,0x11,0xE4,0x00,0x46,
+0xB8,0x9B,0x01,0xC2,0xE0,0x10,0x01,0x98,0x61,0xEF,0x17,0x06,0x7C,0xC2,0xE0,0x10,
+0x01,0xF3,0x17,0x07,0xDC,0x9F,0x01,0xFB,0x17,0x07,0xDC,0x0D,0x61,0x0E,0x0D,0x41,
+0x12,0x0D,0x21,0x16,0x1C,0x21,0x18,0x85,0x29,0x9C,0x38,0x0D,0x21,0x04,0x20,0x64,
+0x26,0x98,0x60,0xE4,0x00,0x00,0x0D,0x98,0x64,0x98,0x80,0xE4,0x00,0x24,0xE4,0x0D,
+0x21,0x06,0x9C,0x28,0xE4,0x00,0x40,0x61,0x98,0x81,0x98,0x60,0x88,0xA4,0xE7,0xFF,
+0xA7,0x9D,0xC2,0xE0,0x10,0x01,0x98,0x61,0xF2,0xF7,0x0A,0xF2,0xD2,0xEA,0x00,0x95,
+0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x09,0xC8,0x5E,0xE0,0xBB,0x48,0x61,0x01,0x85,0x29,
+0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x07,0xDC,0x5E,0xE1,0xDB,0x48,0x61,0x01,0x85,0x29,
+0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x00,0x00,0x0C,0x17,0x00,0x0C,0x17,0x19,0x0C,0x17,
+0x1B,0xEC,0x17,0x00,0xA1,0xEC,0x17,0x00,0xA3,0xEC,0x17,0x00,0xA5,0xEC,0x17,0x00,
+0xA7,0xF8,0x17,0x00,0xA8,0xEC,0x17,0x00,0xAC,0x1F,0x17,0x08,0xEC,0x17,0x00,0xA1,
+0x0F,0x17,0x04,0x1F,0x17,0x20,0x0F,0x17,0x1C,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x00,
+0xC9,0x53,0x18,0x02,0xEF,0x17,0x00,0xC9,0x85,0x29,0xC3,0x20,0x10,0x01,0xFF,0x19,
+0x00,0x00,0x1E,0xF8,0x20,0x5C,0x63,0x04,0x0E,0xF8,0x1C,0x9A,0xE0,0xE4,0x00,0x00,
+0x29,0x0F,0x38,0x1E,0x43,0x44,0xBC,0x8F,0x37,0x13,0x5A,0x00,0x9E,0xE1,0x1B,0x59,
+0x00,0x5F,0x37,0x04,0xD4,0x79,0xFF,0x6D,0x9A,0xE1,0xEE,0xF8,0x00,0xAC,0x85,0x29,
+0x9C,0x38,0x0D,0x21,0x04,0x0D,0x41,0x00,0x5D,0x43,0x00,0xE7,0xFF,0xFE,0xEA,0x88,
+0x6A,0xE4,0x00,0x8D,0x44,0x0D,0x21,0x06,0x0D,0x41,0x02,0x9C,0x28,0x85,0x29,0x1C,
+0x21,0xE8,0x0D,0x41,0x10,0x0D,0x81,0x08,0x0D,0xC1,0x00,0x0D,0x21,0x14,0x0D,0x61,
+0x0C,0x0D,0xA1,0x04,0xC1,0x80,0x10,0x01,0xE4,0x00,0x8E,0xC2,0xC1,0xC0,0x10,0x01,
+0x5C,0x63,0x00,0xFD,0x8C,0x00,0xB8,0xFD,0x4E,0x00,0x00,0xD0,0x60,0x1C,0x12,0xE4,
+0x00,0x8E,0xE0,0x5C,0x63,0x00,0x20,0x60,0xDC,0x0C,0x0A,0x19,0xE4,0x00,0x8F,0x6C,
+0xE4,0x00,0x0A,0xA6,0xEC,0x6A,0x00,0xA5,0xE4,0x00,0x00,0x4B,0x0E,0xEA,0x06,0x09,
+0xAA,0x19,0x8D,0xB7,0xE4,0x00,0x8F,0x70,0x18,0x6D,0x00,0x0A,0xEA,0x19,0xD2,0xEE,
+0x00,0x8D,0x0A,0xEA,0x19,0x9E,0xE1,0x5E,0xF7,0x04,0x0E,0xEA,0x19,0x99,0x60,0xE4,
+0x00,0x8D,0xEE,0x5C,0x63,0x00,0x20,0x63,0x5A,0x0E,0xEA,0x06,0x13,0x17,0x00,0x5F,
+0x0A,0x09,0x20,0x00,0x61,0x0A,0xEA,0x19,0xD2,0xE4,0x03,0x06,0xE4,0x00,0x8E,0x98,
+0x0A,0xEA,0x19,0x22,0xE1,0xA2,0xE4,0x00,0x08,0x87,0x13,0x17,0x00,0x5F,0x0A,0x29,
+0x20,0x01,0x0B,0x13,0x17,0x00,0x5F,0x0A,0x49,0x23,0xFF,0x73,0x13,0x17,0x00,0x5F,
+0x0A,0x69,0x20,0x00,0xC3,0x13,0x17,0x00,0x5F,0x0A,0x89,0x20,0x00,0x9F,0x13,0x17,
+0x00,0x5F,0x0B,0x09,0x20,0x00,0x7B,0x13,0x17,0x00,0x5F,0x0B,0x29,0x23,0xFE,0xE3,
+0x13,0x17,0x00,0x5F,0x04,0x09,0x20,0x00,0x33,0x12,0xF7,0x00,0x5E,0xE4,0x29,0x20,
+0x00,0x25,0x0A,0xEA,0x19,0x22,0xEE,0x9C,0x98,0x61,0xE4,0x00,0x9F,0x20,0x9D,0x61,
+0xC1,0x64,0xE2,0x0E,0x23,0xFD,0xEF,0xE7,0xFF,0xFF,0x2B,0x0E,0xEA,0x06,0x13,0x17,
+0x00,0xD3,0x00,0x1E,0xC2,0x13,0x17,0x00,0x5F,0x0B,0x9B,0x20,0x0F,0x39,0x13,0x17,
+0x00,0x5F,0x0A,0x49,0x07,0x00,0x80,0x20,0x00,0xA5,0x0B,0x2A,0x19,0xD3,0x24,0x14,
+0x36,0x13,0x37,0x01,0x13,0x57,0x02,0x12,0xF7,0x03,0x4F,0x39,0x40,0x47,0x39,0xD5,
+0xC3,0x22,0x7F,0xEE,0x20,0x09,0xBD,0x8F,0x19,0x1A,0xF8,0x00,0xE4,0x00,0x04,0xCF,
+0x13,0x37,0x00,0x5F,0x2A,0x69,0x20,0x02,0xCD,0x0B,0x2A,0x19,0xD3,0x23,0x1C,0x6E,
+0x13,0x57,0x01,0x13,0x37,0x02,0x4E,0xFA,0x40,0x46,0xF7,0xCD,0xCB,0x20,0x14,0x00,
+0xC2,0xE2,0x80,0x0A,0x4A,0xF7,0xC8,0x8E,0xF8,0x0E,0xEA,0x1C,0xFE,0xE0,0x08,0x00,
+0xEE,0xEA,0x00,0xA1,0xE4,0x00,0x00,0x1D,0xE4,0x00,0x07,0xEE,0x98,0x61,0xE4,0x00,
+0x08,0x22,0xE4,0x00,0x8B,0xA2,0x5C,0x63,0x00,0x20,0x63,0xBC,0xEC,0x0A,0x00,0xA3,
+0xE4,0x00,0x8C,0xAA,0xE4,0x00,0x8C,0x3C,0xEB,0x0A,0x00,0xA3,0xEA,0xEA,0x00,0xA1,
+0xD7,0x17,0x01,0x26,0xEA,0xEA,0x00,0xA3,0xEA,0xEA,0x00,0xA1,0xE4,0x00,0x8C,0x32,
+0xE4,0x00,0x8C,0x9E,0xE4,0x00,0x8C,0x62,0xEC,0x0A,0x00,0xA3,0xEC,0x0A,0x00,0xA1,
+0xE4,0x00,0x06,0x33,0xE4,0x00,0x8B,0x90,0x5C,0x63,0x00,0x20,0x63,0x66,0xE4,0x00,
+0x8A,0xE4,0x5C,0x63,0x00,0x20,0x63,0x0C,0xEA,0xEA,0x00,0xA3,0x0F,0x0A,0x1E,0x8E,
+0xF8,0x10,0x77,0x00,0xE4,0x00,0x8A,0x5E,0xEA,0xEA,0x00,0xA3,0x9E,0xE1,0x5E,0xF7,
+0x04,0xEE,0xEA,0x00,0xA3,0xE7,0xFF,0xFF,0x47,0x13,0x17,0x00,0x5F,0x0B,0x01,0x20,
+0x00,0x31,0x13,0x17,0x00,0x5F,0x0B,0x29,0x20,0x04,0xB5,0x0B,0x0A,0x19,0x23,0x0C,
+0xB6,0xC3,0x00,0x10,0x01,0x9B,0x21,0xEF,0x38,0x06,0x4C,0x13,0x17,0x01,0x12,0xF7,
+0x02,0x4F,0x18,0x40,0x47,0x18,0xBD,0xC2,0xE0,0x10,0x01,0xEF,0x17,0x0D,0x54,0xC2,
+0xE0,0x10,0x01,0xEC,0x17,0x0D,0x74,0xE4,0x00,0x02,0xD9,0x0B,0x0A,0x19,0xD3,0x04,
+0x0B,0x2E,0xC3,0x00,0x10,0x01,0xEF,0x18,0x06,0xCA,0x23,0x00,0x68,0xEB,0x2A,0x00,
+0xA5,0xEB,0x0A,0x00,0xA7,0x43,0x19,0xC5,0xD3,0x0A,0x00,0x60,0xF3,0x0A,0x00,0xA8,
+0xF8,0x0A,0x00,0xA8,0x11,0xD7,0x01,0xC1,0xA0,0x10,0x01,0x13,0x57,0x02,0xFD,0x6D,
+0x06,0xCC,0x13,0x17,0x03,0x4E,0xEE,0x08,0x43,0x2B,0xBC,0x9E,0xE1,0x1B,0x59,0x00,
+0x8E,0xEB,0x1B,0x17,0x00,0xC2,0xE0,0x10,0x01,0x99,0x81,0xED,0x97,0x06,0xC8,0xE4,
+0x00,0x06,0x08,0xEC,0x6A,0x00,0xA7,0xF2,0xEA,0x00,0xA8,0x4D,0xCC,0x74,0x45,0xCE,
+0xBD,0x5D,0xCE,0x00,0xF9,0xCA,0x00,0xA8,0xF2,0xEA,0x00,0xA8,0x56,0xF7,0x01,0xD2,
+0xE0,0x07,0xA2,0xF2,0xEA,0x00,0xA8,0x56,0xF7,0x02,0xD2,0xE0,0x07,0x4A,0xF2,0xEA,
+0x00,0xA8,0x56,0xF7,0x04,0xD2,0xE0,0x06,0xF2,0xF2,0xEA,0x00,0xA8,0x56,0xF7,0x08,
+0xD2,0xE0,0x06,0x9A,0xF3,0x4D,0x06,0xCC,0x13,0x0B,0x01,0x12,0xEB,0x02,0x4E,0xF7,
+0x40,0x13,0x2B,0x03,0x4F,0x5A,0xC0,0x4F,0x18,0x80,0x47,0x1A,0xC5,0x47,0x18,0xCD,
+0x47,0x18,0xBD,0xC2,0xE0,0x10,0x01,0xEF,0x17,0x0D,0x74,0x13,0x4B,0x04,0x13,0x0B,
+0x05,0x12,0xEB,0x06,0x4E,0xF7,0x40,0x13,0x2B,0x07,0x4F,0x5A,0xC0,0x4F,0x18,0x80,
+0x47,0x1A,0xC5,0x47,0x18,0xCD,0x47,0x18,0xBD,0xC2,0xE0,0x10,0x01,0xEF,0x17,0x0D,
+0x54,0xF2,0xEA,0x00,0xA8,0xF8,0x0A,0x00,0xA8,0xC2,0xE0,0x10,0x01,0xED,0x97,0x06,
+0x4C,0xE4,0x00,0x00,0xE5,0x13,0x17,0x00,0x5F,0x04,0x09,0x20,0x00,0x99,0x0B,0x0A,
+0x19,0x23,0x0D,0x8A,0x13,0x37,0x01,0x13,0x17,0x02,0x4E,0xF9,0x40,0x46,0xF7,0xC5,
+0xC2,0xEB,0x54,0xA4,0x20,0x01,0x3D,0x12,0xEC,0x00,0x52,0xF7,0x03,0xE4,0x00,0x00,
+0x87,0x13,0x17,0x00,0x5F,0x04,0x29,0x20,0x05,0xC9,0x0B,0x0A,0x19,0x23,0x0C,0xDA,
+0x13,0x37,0x01,0x13,0x17,0x02,0x4E,0xF9,0x40,0x46,0xF7,0xC5,0xC3,0x00,0x10,0x01,
+0xEE,0xF8,0x00,0xBC,0x12,0xEC,0x00,0x57,0x37,0x01,0x23,0x20,0x64,0xEF,0x18,0x00,
+0xBE,0x23,0x00,0x32,0x9B,0x1B,0x46,0xF7,0xC4,0xE4,0x00,0x00,0x0F,0x52,0xF7,0x04,
+0x1A,0xEC,0x00,0x0C,0x0A,0x00,0x0C,0x0A,0x19,0xE4,0x00,0x02,0x61,0xE4,0x00,0x87,
+0x4C,0x5C,0x63,0x00,0xD0,0x60,0x09,0x2A,0xE4,0x00,0x88,0x8E,0xE4,0x00,0x88,0x52,
+0x50,0x60,0x20,0xE4,0x00,0x03,0x38,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x3D,0xF9,0x13,
+0x17,0x00,0xC2,0xE0,0x10,0x01,0xFD,0x77,0x00,0xB0,0x1B,0x0B,0x00,0x13,0x0B,0x00,
+0x23,0x00,0x42,0xC2,0xE0,0x10,0x01,0x99,0xA6,0xEE,0xF7,0x00,0xD2,0x22,0xE8,0xD8,
+0x12,0xEB,0x00,0x22,0xE0,0x4E,0x12,0xEC,0x00,0x56,0xF7,0x01,0x5E,0xE0,0x09,0x49,
+0xA4,0x43,0xE4,0x00,0x00,0x43,0x12,0xEB,0x00,0x22,0xE4,0x2A,0x51,0xA0,0x80,0xE4,
+0x00,0x00,0x29,0x12,0xEB,0x00,0x22,0xEB,0xD8,0x12,0xEB,0x00,0x22,0xEF,0xC0,0xC9,
+0xA0,0xFF,0xFF,0xEE,0xEA,0x00,0xAE,0x22,0xE4,0x2E,0xED,0xAA,0x00,0xA1,0xEC,0x0A,
+0x00,0xAC,0xE4,0x00,0x87,0x66,0xEA,0xEA,0x00,0xA1,0xD5,0xB7,0x03,0xF5,0xC2,0xE0,
+0x10,0x01,0xF3,0x17,0x0D,0x59,0x23,0x00,0x24,0x9F,0x1F,0xFB,0x17,0x0D,0x59,0xEC,
+0x0A,0x00,0xA3,0xE9,0x8A,0x00,0xA1,0xE4,0x00,0x00,0x73,0x12,0xEB,0x00,0x22,0xE0,
+0x92,0xEA,0xEA,0x00,0xA3,0x0F,0x0A,0x1E,0x8E,0xF8,0x10,0x77,0x00,0xE4,0x00,0x85,
+0x4C,0xEA,0xEA,0x00,0xA3,0x9E,0xE1,0x5E,0xF7,0x04,0xEE,0xEA,0x00,0xA3,0xE4,0x00,
+0x00,0x25,0xE4,0x00,0x85,0x56,0x5C,0x63,0x00,0x20,0x63,0xE4,0xE7,0xFF,0xFF,0xAB,
+0xEA,0xEA,0x00,0xA3,0xD6,0xEC,0xFE,0x3E,0xE4,0x00,0x86,0xCE,0xE4,0x00,0x86,0x92,
+0xEC,0x0A,0x00,0xA1,0xEC,0x0A,0x00,0xA3,0xE4,0x00,0x00,0x45,0x98,0x60,0x9D,0x61,
+0xE4,0x00,0x84,0xC6,0xE4,0x00,0x00,0x0D,0x99,0x60,0xD5,0xAB,0xFF,0x95,0xE4,0x00,
+0x86,0x82,0xE4,0x00,0x86,0x46,0xEC,0x0A,0x00,0xA1,0xC2,0xE0,0x10,0x01,0xEB,0x17,
+0x00,0xC9,0x53,0x18,0x02,0xEF,0x17,0x00,0xC9,0x0D,0xC1,0x02,0x0D,0xA1,0x06,0x0D,
+0x81,0x0A,0x0D,0x61,0x0E,0x0D,0x41,0x12,0x0D,0x21,0x16,0x1C,0x21,0x18,0x85,0x29,
+0x9C,0x38,0x0D,0x21,0x04,0xE4,0x00,0x8D,0x42,0x98,0x60,0x88,0x83,0xE4,0x00,0x8A,
+0x74,0x98,0x61,0x98,0x82,0xE4,0x00,0x8A,0x64,0x98,0x60,0xFC,0x80,0x28,0x0A,0xE4,
+0x00,0x86,0x50,0x98,0x61,0xFC,0x80,0x28,0x0A,0xE4,0x00,0x87,0xB6,0x0D,0x21,0x06,
+0x9C,0x28,0xE4,0x00,0x90,0x0D,0x20,0x64,0x1E,0xE4,0x00,0x91,0x37,0xE4,0x00,0x91,
+0x55,0x9C,0x38,0x0D,0x21,0x04,0xE4,0x00,0x91,0x6A,0x0D,0x21,0x06,0x9C,0x28,0xE4,
+0x00,0x91,0x31,0xE4,0x00,0x93,0x29,0xE4,0x00,0x92,0xBF,0xE4,0x00,0x93,0x89,0xE4,
+0x00,0x93,0xE5,0xE4,0x00,0x97,0xC3,0xE4,0x00,0x95,0x2D,0xE4,0x00,0x94,0x31,0xE4,
+0x00,0x94,0x67,0xE4,0x00,0x94,0x9D,0xE4,0x00,0x94,0xC1,0xE4,0x00,0x94,0xE5,0xE4,
+0x00,0x93,0x1B,0xE4,0x00,0x95,0x13,0x20,0x60,0x28,0x20,0x64,0x3E,0xE4,0x00,0x00,
+0x11,0xE4,0x00,0x95,0xAF,0xE4,0x00,0x95,0xC9,0x85,0x29,0xE4,0x00,0x98,0xC1,0xE4,
+0x00,0x95,0xD7,0xC2,0xE0,0x10,0x01,0xE8,0x77,0x00,0xB3,0xEB,0x17,0x00,0xB3,0xD4,
+0x78,0xFF,0xC6,0x85,0x29,0x9C,0x30,0x0D,0x41,0x08,0x0D,0x61,0x04,0x0D,0x21,0x0C,
+0x5D,0x43,0x04,0xE7,0xFF,0xFF,0xC0,0xC2,0xE0,0x10,0x01,0xFF,0x17,0x00,0xD6,0x89,
+0x77,0x0C,0x78,0x03,0xE7,0xFF,0xFF,0x9E,0xFF,0x0B,0x00,0xD6,0x0B,0x18,0x03,0x40,
+0x63,0xC5,0x5F,0x03,0x04,0xD5,0x58,0xFF,0x7D,0x0D,0x61,0x06,0x0D,0x41,0x0A,0x0D,
+0x21,0x0E,0x1C,0x21,0x10,0x85,0x29,0xE4,0x00,0x98,0xDD,0xC3,0x34,0x00,0x01,0xCA,
+0xF9,0x23,0xFC,0x0A,0xF7,0x00,0xD2,0xFF,0x04,0x3C,0xC3,0x00,0x10,0x01,0xF2,0xF8,
+0x06,0xD4,0x9E,0xE1,0x5E,0xF7,0x00,0xFA,0xF8,0x06,0xD4,0x22,0xE1,0xCA,0xC3,0x00,
+0x10,0x01,0xC3,0x60,0x10,0x01,0xFF,0x18,0x03,0x2A,0xCA,0xE0,0x11,0x7D,0xCB,0x39,
+0x22,0x00,0xFF,0x7B,0x0D,0x04,0x1F,0x57,0xFD,0x57,0x5A,0xFF,0x4F,0x5A,0x10,0x8F,
+0x59,0x0B,0x9A,0x01,0x4F,0x97,0x08,0x8F,0x9B,0xEB,0x9C,0xDD,0x47,0x0F,0x9A,0x01,
+0x5F,0x57,0x00,0x5F,0x4F,0xE9,0x57,0x57,0xFF,0x4F,0x5A,0x10,0x8F,0x59,0x0B,0x9A,
+0x01,0x20,0x00,0x6D,0xFF,0xA0,0x80,0x00,0x5F,0x9C,0x04,0x47,0x9C,0xEC,0x0B,0xB8,
+0x01,0xC7,0xBD,0x7F,0xFF,0x47,0x9C,0xED,0xE4,0x00,0x00,0x0F,0x0B,0x98,0x01,0x0F,
+0x9A,0x01,0x9E,0xE1,0x9F,0x02,0xC2,0xE2,0x30,0x04,0x23,0xFE,0xB1,0x85,0x29,0x5C,
+0x63,0x04,0xE4,0x00,0x97,0xAF,0x9A,0xE0,0x8B,0x17,0xE4,0x00,0x00,0x1D,0x43,0x23,
+0xBC,0x9E,0xE1,0x13,0x39,0x00,0x8F,0x19,0xD4,0x97,0xFF,0xB4,0x40,0x60,0xC5,0x85,
+0x29,0x9C,0x38,0x98,0x60,0x0D,0x21,0x04,0xE7,0xFF,0xFC,0xFC,0x98,0x61,0xE7,0xFF,
+0xFC,0xF0,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x00,0xD2,0x22,0xE8,0x3A,0x50,0x60,0xC8,
+0xE7,0xFF,0xFD,0xCA,0xE4,0x00,0x00,0x15,0x98,0x6F,0xE7,0xFF,0xFD,0x8A,0x0D,0x21,
+0x06,0x98,0x60,0x9C,0x28,0xE7,0xFF,0xFC,0xA3,0x9C,0x38,0xC2,0xE0,0x10,0x01,0x0D,
+0x21,0x04,0xEC,0x17,0x0D,0x61,0x0D,0x41,0x00,0xC2,0xE0,0x10,0x01,0xF3,0x17,0x00,
+0xB0,0x23,0x00,0x42,0xC3,0x00,0x10,0x01,0x98,0x66,0xEF,0x18,0x00,0xD2,0x23,0x08,
+0x78,0xF2,0xF7,0x00,0xB0,0x50,0x60,0x80,0x22,0xE0,0x52,0xC2,0xE0,0x10,0x01,0xF2,
+0xF7,0x00,0xB8,0x56,0xF7,0x01,0x5E,0xE0,0x09,0x48,0x64,0x43,0xC1,0x40,0x10,0x01,
+0xEA,0xEA,0x00,0xC9,0x56,0xF7,0x02,0x22,0xE0,0x6C,0xC0,0x80,0x10,0x01,0xFC,0x84,
+0x06,0xD5,0xE7,0xFF,0xF0,0xF0,0xEA,0xEA,0x00,0xC9,0xC6,0xF7,0xFF,0xFD,0xEE,0xEA,
+0x00,0xC9,0x0D,0x41,0x02,0x0D,0x21,0x06,0x9C,0x28,0xE7,0xFF,0xFE,0xAF,0xC2,0xF4,
+0x00,0x01,0xCB,0x17,0x3D,0xF9,0x1C,0x21,0xE0,0xCA,0xF7,0x3D,0xF8,0x0D,0x41,0x18,
+0x0D,0x61,0x14,0x0D,0x81,0x10,0x0D,0xA1,0x0C,0x0D,0xC1,0x08,0x0D,0xE1,0x04,0x0E,
+0x01,0x00,0x0D,0x21,0x1C,0xC1,0x60,0x10,0x01,0xFD,0x6B,0x08,0x24,0x0A,0x0B,0x01,
+0xC6,0x10,0x7F,0xFF,0x0E,0x0B,0x01,0x13,0x38,0x00,0xC3,0x00,0x10,0x01,0xFB,0x38,
+0x00,0xB0,0x13,0x37,0x00,0xC2,0xE0,0x10,0x01,0xFB,0x37,0x07,0x57,0xC1,0xC0,0x10,
+0x01,0xC1,0xA0,0x10,0x01,0xC3,0x40,0x10,0x01,0xC3,0x20,0x10,0x01,0x5D,0x83,0x00,
+0xFD,0xCE,0x0D,0x04,0xFD,0xAD,0x07,0x58,0xFD,0xE0,0x80,0x00,0xFD,0x5A,0x06,0xD5,
+0xFE,0xF9,0x0C,0x08,0xD1,0x81,0x12,0x76,0x0B,0xB7,0x19,0x45,0xF0,0x7D,0xCB,0x00,
+0x07,0xFF,0x0D,0xEB,0x01,0x43,0xB8,0xED,0x5F,0xBD,0x04,0x5F,0x7D,0x06,0x0F,0x77,
+0x19,0x13,0x57,0x00,0xD3,0x41,0x1D,0xB9,0x0B,0x77,0x49,0x43,0x18,0xDD,0x0F,0x17,
+0x49,0x0B,0x17,0x1D,0x43,0x00,0xC5,0x0F,0x17,0x1D,0x0B,0x17,0x46,0x0B,0x77,0x16,
+0x5F,0x1B,0x15,0x4B,0xA1,0x01,0xCF,0x1D,0x00,0x30,0x8F,0x17,0x4B,0x80,0x0A,0x0B,
+0x78,0x16,0x9B,0x00,0x27,0x7C,0x50,0xC3,0x00,0x10,0x01,0x5F,0xDB,0x04,0xEB,0x18,
+0x0A,0xEB,0x5F,0x78,0x15,0x4B,0x1E,0xC0,0x0F,0x17,0x13,0xCF,0xBD,0x00,0x30,0x9B,
+0x00,0x8F,0xB7,0x0B,0x7D,0x18,0x27,0x7C,0x50,0xC3,0x00,0x10,0x01,0x5F,0xBB,0x04,
+0xEB,0x18,0x0A,0xED,0x5F,0x78,0x15,0x4B,0x1D,0xC0,0x0F,0x17,0x15,0xCF,0x1C,0x00,
+0x30,0x8F,0x17,0x0B,0x78,0x16,0x9B,0x00,0x27,0x7C,0x50,0xC3,0x00,0x10,0x01,0x5F,
+0x3B,0x04,0xEB,0x18,0x0A,0xEB,0x5F,0x78,0x15,0x4B,0x19,0xC0,0x0F,0x17,0x43,0xCF,
+0x9C,0x00,0x30,0x9B,0x00,0x8F,0x97,0x0B,0x3C,0x18,0x27,0x3C,0x50,0xC3,0x00,0x10,
+0x01,0x5F,0x79,0x04,0xEB,0x18,0x0A,0xED,0x5F,0x38,0x15,0x4B,0x1B,0xC0,0x0B,0x77,
+0x43,0x0B,0x37,0x13,0x43,0x3B,0xCD,0x0F,0x17,0x45,0x0F,0x37,0x1B,0x0B,0x37,0x15,
+0x43,0x18,0xCD,0x0F,0x17,0x1D,0xE4,0x00,0x00,0x69,0xC3,0x00,0x10,0x01,0x5F,0xDC,
+0x04,0xEB,0x18,0x0A,0xEB,0x5F,0x98,0x15,0x4B,0x1E,0xC0,0x0F,0x17,0x13,0x9B,0x00,
+0x27,0x7C,0x44,0xC3,0x00,0x10,0x01,0xEB,0x18,0x0A,0xED,0x5F,0x78,0x1D,0x4B,0x18,
+0xE8,0x0F,0x17,0x15,0x0C,0x17,0x1B,0x0C,0x17,0x1D,0xC3,0x00,0x10,0x01,0xF3,0x18,
+0x00,0xB0,0x23,0x01,0x9E,0x53,0x00,0x52,0x0B,0x37,0x13,0x1B,0x0A,0x00,0x4F,0x99,
+0x41,0x0B,0x17,0x15,0x4F,0x9C,0x20,0x4F,0x78,0x41,0x1B,0x2A,0x02,0x57,0x7B,0x0F,
+0x1B,0x0A,0x03,0x47,0x7C,0xDD,0x1B,0x6A,0x01,0x27,0x44,0xA1,0x0B,0x17,0x1A,0x0A,
+0xF7,0x1C,0x4F,0x38,0x42,0x4F,0x57,0x42,0x5F,0x39,0x04,0x57,0x5A,0x0F,0x4F,0x39,
+0x20,0x1B,0x0A,0x05,0x47,0x39,0xD5,0x1A,0xEA,0x06,0x1B,0x2A,0x04,0xE4,0x00,0x00,
+0x1B,0x18,0x0A,0x04,0x18,0x0A,0x05,0x18,0x0A,0x06,0x88,0x6A,0x98,0x87,0xE7,0xFF,
+0xFA,0x90,0x18,0x6A,0x07,0xE4,0x00,0x01,0x81,0x8B,0x0A,0x18,0x18,0x00,0xC3,0x20,
+0x10,0x01,0x9F,0x01,0xFF,0x39,0x07,0x57,0xD7,0x19,0xFF,0x9E,0x53,0x00,0x62,0x1B,
+0x0A,0x00,0x0B,0x17,0x13,0x4F,0x38,0x41,0x1B,0x0A,0x02,0x0B,0x17,0x15,0x1B,0x2A,
+0x01,0x1B,0x0A,0x04,0x4F,0x38,0x41,0x57,0x1A,0x01,0x53,0x18,0x20,0x1B,0x0A,0x11,
+0x0B,0x17,0x1A,0x1B,0x2A,0x03,0x0A,0xF7,0x1C,0x4F,0x38,0x42,0x1B,0x0A,0x0E,0x4F,
+0x5A,0x20,0x4F,0x17,0x42,0x53,0x5A,0x02,0x1B,0x0A,0x0F,0x1B,0x4A,0x12,0x1A,0xEA,
+0x10,0x1B,0x2A,0x0D,0x88,0x6A,0x50,0x80,0x1F,0xE7,0xFF,0xF9,0xBA,0xC3,0x00,0x10,
+0x01,0x18,0x6A,0x1F,0xC3,0x60,0x10,0x01,0x1D,0x4A,0x20,0xFF,0x18,0x09,0xCC,0x9A,
+0xE0,0xC3,0x40,0x10,0x01,0xFF,0x7B,0x0B,0x36,0xF3,0x3A,0x07,0x57,0x23,0x24,0x34,
+0x23,0x28,0x68,0x43,0x37,0x74,0xE4,0x00,0x00,0x0F,0x43,0x37,0xDC,0x17,0x99,0x01,
+0x1B,0x8A,0x00,0x0B,0x39,0x01,0xE4,0x00,0x00,0x21,0x0F,0x38,0x02,0x4F,0x99,0x82,
+0x4F,0x39,0x42,0x1B,0x8A,0x00,0x1B,0x2A,0x01,0x9E,0xE2,0x9D,0x42,0x9F,0x04,0x5E,
+0xE8,0xC9,0x23,0xFF,0x1D,0x0A,0xEB,0x00,0xD2,0xFF,0x0D,0x04,0x9A,0xE1,0xE4,0x00,
+0x02,0x99,0x21,0x81,0xFA,0xF2,0xF8,0x00,0xB0,0x22,0xE0,0xB2,0x52,0xE0,0x52,0x1A,
+0xEA,0x00,0x9A,0xFF,0x88,0x6A,0x1A,0xEA,0x01,0x1A,0xEA,0x02,0x1A,0xEA,0x03,0x1A,
+0xEA,0x04,0x1A,0xEA,0x05,0x1A,0xEA,0x06,0x98,0x87,0xE7,0xFF,0xF8,0x98,0x18,0x6A,
+0x07,0xE4,0x00,0x00,0x7F,0x8A,0xEA,0x18,0x17,0x00,0xC3,0x00,0x10,0x01,0x9E,0xE1,
+0xFF,0x18,0x07,0x57,0xD6,0xF8,0xFF,0x9E,0x52,0xE0,0x62,0x9B,0x1F,0x1A,0xEA,0x00,
+0x1E,0xEA,0x01,0x1B,0x17,0x00,0xC3,0x20,0x10,0x01,0x9E,0xE1,0xFF,0x39,0x06,0xF4,
+0xD6,0xF9,0xFF,0x9E,0x88,0x6A,0x50,0x80,0x1F,0xE7,0xFF,0xF8,0x1A,0x18,0x6A,0x1F,
+0x0A,0xEB,0x01,0x0C,0x0D,0x00,0x45,0xEF,0xBD,0x0D,0xEB,0x01,0xE4,0x00,0x02,0x39,
+0xD1,0x82,0x06,0x8E,0xF3,0x18,0x00,0xB0,0x23,0x00,0xD2,0x52,0xE0,0x52,0xC3,0x00,
+0x10,0x01,0x1A,0xEA,0x00,0xEB,0x18,0x0D,0x61,0x9A,0xFF,0x1B,0x0A,0x05,0x1A,0xEA,
+0x01,0x1A,0xEA,0x02,0x1A,0xEA,0x03,0x1A,0xEA,0x04,0x1A,0xEA,0x06,0x88,0x6A,0x98,
+0x87,0xE7,0xFF,0xF7,0x8A,0x18,0x6A,0x07,0xE4,0x00,0x01,0x15,0x8B,0x0A,0x18,0x18,
+0x00,0xC3,0x20,0x10,0x01,0x9F,0x01,0xFF,0x39,0x07,0x57,0xD7,0x19,0xFF,0x9E,0x53,
+0x00,0x62,0x1B,0x0A,0x00,0x0B,0x17,0x13,0x4F,0x38,0x41,0x1B,0x0A,0x02,0x1B,0x2A,
+0x01,0x0B,0x17,0x15,0x4F,0x38,0x41,0x1B,0x0A,0x04,0x1B,0x2A,0x03,0x13,0x17,0x00,
+0x57,0x38,0x01,0x4F,0x18,0x20,0x53,0x18,0x02,0x53,0x39,0x20,0x1B,0x0A,0x12,0x0B,
+0x17,0x1A,0x1B,0x2A,0x11,0x0A,0xF7,0x1C,0x4F,0x38,0x42,0x1B,0x0A,0x0E,0x4F,0x17,
+0x42,0x1A,0xEA,0x10,0x1B,0x2A,0x0D,0x1B,0x0A,0x0F,0x88,0x6A,0x50,0x80,0x1F,0xE7,
+0xFF,0xF6,0xAE,0x9A,0xE0,0x18,0x6A,0x1F,0x43,0x17,0x74,0x0B,0x38,0x00,0x43,0x0A,
+0xBC,0x4F,0x59,0x42,0x1B,0x38,0x21,0x1B,0x58,0x20,0x9E,0xE2,0x5E,0xE8,0xC9,0x23,
+0xFF,0xA5,0x45,0xF0,0x7D,0x9A,0xE2,0x0D,0xEB,0x01,0x0E,0xED,0x00,0xE4,0x00,0x00,
+0x97,0x21,0x8D,0x1E,0x1E,0xE0,0xA7,0x1A,0xEA,0x00,0x9A,0xE6,0x1A,0xEA,0x02,0x52,
+0xE0,0x50,0x1A,0xEA,0x03,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x0D,0x61,0x45,0xF0,0x7D,
+0x18,0x0A,0x01,0x0D,0xEB,0x01,0x1A,0xEA,0x04,0x88,0x6A,0x98,0x85,0xE7,0xFF,0xF5,
+0xF2,0x0D,0x8D,0x00,0x18,0x6A,0x05,0xE4,0x00,0x00,0x23,0x0B,0x97,0x16,0x9B,0x00,
+0xD3,0x9F,0xE8,0xD8,0xE7,0xFF,0xFA,0x0D,0x0E,0x01,0x02,0x0D,0xE1,0x06,0x0D,0xC1,
+0x0A,0x0D,0xA1,0x0E,0x0D,0x81,0x12,0x0D,0x61,0x16,0x0D,0x41,0x1A,0x0D,0x21,0x1E,
+0x1C,0x21,0x20,0x85,0x29,0x1C,0x21,0xD0,0x0D,0x41,0x28,0x0D,0x81,0x20,0x5D,0x43,
+0x00,0x5D,0x84,0x00,0x42,0xEC,0x55,0x9E,0xE1,0x5E,0xF7,0x00,0x57,0x17,0x03,0x4E,
+0xF7,0x11,0x5F,0x00,0x09,0x0D,0x61,0x24,0x0D,0xA1,0x1C,0x0D,0xC1,0x18,0x49,0xA1,
+0x01,0x0D,0x21,0x2C,0x8D,0xB7,0xC1,0xD8,0x00,0x21,0xE4,0x00,0x5F,0xDE,0x99,0x60,
+0xFD,0xCE,0xBA,0xAF,0xE4,0x00,0x00,0xE3,0x88,0x61,0x50,0x80,0x22,0x50,0xA0,0x18,
+0xE7,0xFF,0xC1,0x94,0x9A,0xE4,0x43,0x0E,0x54,0x13,0x58,0x00,0x1F,0x01,0x18,0x4F,
+0x3A,0x09,0x57,0x5A,0x01,0x8F,0x19,0x17,0x18,0xE8,0x5F,0x40,0x01,0x4B,0x50,0x7B,
+0x47,0x5A,0xC4,0x5F,0x17,0x02,0x20,0x00,0x25,0x4F,0x17,0x20,0x5F,0x18,0x02,0x1F,
+0x61,0x18,0x47,0x18,0xD5,0x8F,0x3B,0x1B,0x19,0xE8,0x9D,0x41,0x5D,0x4A,0x00,0xD5,
+0x4C,0x00,0xE1,0x06,0xE0,0x81,0xCC,0x6B,0x00,0x18,0x88,0x81,0x8C,0x77,0x50,0xA0,
+0x18,0x9D,0x61,0xE7,0xFF,0xC1,0xCE,0xE4,0x00,0x00,0x1D,0x9E,0xE1,0xD2,0xE8,0xFD,
+0x4E,0xE7,0xFF,0xFF,0xC5,0x5E,0xEB,0x00,0xD5,0xB7,0xFC,0x85,0xE4,0x00,0x5F,0x00,
+0x0D,0x21,0x2E,0x0D,0xC1,0x1A,0x0D,0xA1,0x1E,0x0D,0x81,0x22,0x0D,0x61,0x26,0x0D,
+0x41,0x2A,0x1C,0x21,0x30,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x03,0x26,0x85,
+0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x07,0xBA,0x85,0x29,0x1C,0x21,0xD0,0x0D,0x21,
+0x2C,0x0D,0x41,0x28,0x0D,0x61,0x24,0xD0,0x69,0x0C,0x35,0x4F,0x03,0x10,0xC2,0xF8,
+0x00,0x21,0xC1,0x58,0x00,0x21,0xFE,0xF7,0xBA,0x48,0xFD,0x4A,0xBA,0xAF,0x8E,0xF8,
+0x0E,0xF7,0x02,0x86,0xE9,0x4C,0x83,0x20,0x88,0x64,0x9C,0x8F,0xE7,0xFF,0xFD,0xD2,
+0xE4,0x00,0x02,0xBB,0x0C,0x61,0x04,0xE4,0x00,0x5E,0x04,0x0C,0x61,0x06,0x1D,0x63,
+0xFE,0x5D,0x6B,0x00,0x4D,0x6B,0x20,0x8D,0x6A,0x05,0x40,0x81,0x1C,0x61,0x08,0x50,
+0x80,0x22,0x50,0xA0,0x18,0xE7,0xFF,0xBF,0xAA,0x9A,0xE4,0x43,0x0B,0xBC,0x13,0x58,
+0xFC,0x1F,0x01,0x20,0x4F,0x3A,0x09,0x57,0x5A,0x01,0x8F,0x19,0x13,0x18,0xE8,0x5F,
+0x40,0x01,0x4B,0x50,0x7B,0x47,0x5A,0xC4,0x5F,0x17,0x02,0x5F,0x5A,0x02,0x20,0x00,
+0x25,0x4F,0x17,0x20,0x5F,0x18,0x02,0x1F,0x61,0x20,0x47,0x18,0xD5,0x8F,0x3B,0x1B,
+0x19,0xE8,0x9E,0xE1,0xD2,0xE8,0xFE,0x3E,0x88,0x6A,0x1C,0x81,0x08,0x50,0xA0,0x18,
+0xE7,0xFF,0xBF,0xF4,0x07,0x80,0x81,0x1D,0x4A,0x18,0x9D,0x64,0x53,0x9C,0x60,0xD5,
+0x5C,0xFC,0xEE,0xE4,0x00,0x01,0xAD,0xE4,0x00,0x5D,0x04,0x1C,0x61,0x08,0x50,0x80,
+0x22,0x50,0xA0,0x18,0xE7,0xFF,0xBE,0xCC,0xC3,0x78,0x00,0x21,0x9A,0xE4,0xFF,0x7B,
+0xBA,0xAC,0xD2,0xE7,0x01,0xC2,0x43,0x1B,0xBC,0x13,0x58,0xFC,0x1F,0x01,0x20,0x4F,
+0x3A,0x09,0x57,0x5A,0x01,0x8F,0x19,0x17,0x18,0xE8,0x5F,0x40,0x01,0x4B,0x50,0x7B,
+0x47,0x5A,0xC4,0x5F,0x17,0x02,0x20,0x00,0x25,0x4F,0x17,0x20,0x5F,0x18,0x02,0x1F,
+0x81,0x20,0x47,0x18,0xD5,0x8F,0x3C,0x1B,0x19,0xE8,0x9E,0xE1,0xD2,0xE8,0xFE,0x36,
+0xE4,0x00,0x00,0xD9,0xE4,0x00,0x5C,0x4A,0x1C,0x61,0x08,0x50,0x80,0x22,0x50,0xA0,
+0x18,0xE7,0xFF,0xBE,0x12,0x8B,0x0A,0xE4,0x00,0x00,0x9F,0x43,0x38,0xBC,0x13,0x79,
+0xFC,0x1F,0x21,0x20,0x4F,0x5B,0x09,0x57,0x7B,0x01,0x8F,0x3A,0x13,0x39,0xE8,0x5F,
+0x60,0x01,0x4B,0x70,0x7B,0x47,0x7B,0xCC,0x5F,0x37,0x02,0x5F,0x7B,0x02,0x20,0x00,
+0x25,0x4F,0x37,0x20,0x5F,0x39,0x02,0x1F,0x81,0x20,0x47,0x39,0xDD,0x8F,0x5C,0x1B,
+0x3A,0xE8,0x9E,0xE1,0xD2,0xE8,0xFE,0x3E,0xC2,0xF8,0x00,0x21,0x9F,0x04,0xFE,0xF7,
+0xBA,0xCF,0xD7,0x17,0x00,0x52,0x9A,0xE4,0xE7,0xFF,0xFF,0x67,0x04,0x60,0x81,0x1C,
+0x81,0x08,0x50,0xA0,0x18,0xE7,0xFF,0xBE,0x2A,0xE4,0x00,0x5B,0x86,0x0D,0x61,0x26,
+0x0D,0x41,0x2A,0x0D,0x21,0x2E,0x1C,0x21,0x30,0x85,0x29,0x1C,0x21,0xE8,0x0D,0x21,
+0x14,0x0D,0x41,0x10,0x0D,0x61,0x0C,0x0D,0x81,0x08,0x0D,0xA1,0x04,0xD0,0x67,0x03,
+0x32,0xD0,0x67,0x00,0x65,0xD0,0x61,0x08,0x15,0xE4,0x00,0x00,0x19,0xD0,0x69,0x07,
+0xD6,0xE4,0x00,0x01,0x57,0x4C,0x63,0x20,0xC1,0x40,0x10,0x01,0x99,0x60,0xFD,0x4A,
+0x07,0xBC,0x8D,0x43,0x13,0x4A,0x01,0x13,0x2A,0x00,0x13,0x0A,0x03,0x12,0xEA,0x02,
+0x4C,0x9A,0xC0,0x4C,0xB8,0xC0,0x4F,0x5A,0x80,0x4F,0x18,0x80,0x8C,0x9A,0x8C,0xB8,
+0x8C,0x99,0x8C,0xB7,0x4F,0x39,0x40,0x4E,0xF7,0x40,0x88,0x6B,0x8C,0x99,0x8C,0xB7,
+0x9D,0x61,0xE4,0x00,0x5C,0xF2,0x5D,0x6B,0x00,0x9D,0x44,0xD1,0x64,0xFE,0x4E,0xE4,
+0x00,0x01,0x51,0xC1,0xA0,0x10,0x01,0x99,0x40,0xFD,0xAD,0x07,0x64,0x5D,0x8A,0x00,
+0x41,0x6D,0x54,0x98,0x60,0x88,0x8C,0x98,0xA0,0x10,0xCB,0x00,0xE4,0x00,0x5D,0x06,
+0x98,0x60,0x88,0x8C,0x98,0xA1,0x10,0xCB,0x00,0x9D,0x41,0xE4,0x00,0x5C,0xE8,0x21,
+0x4F,0x7A,0x98,0x60,0x98,0x83,0x98,0xA0,0x98,0xC0,0xE4,0x00,0x5C,0xCA,0x0D,0x21,
+0x16,0x0D,0xA1,0x06,0x0D,0x81,0x0A,0x0D,0x61,0x0E,0x0D,0x41,0x12,0x98,0x60,0x98,
+0x83,0x98,0xA1,0x98,0xC0,0x1C,0x21,0x18,0xE4,0x00,0x5C,0x8F,0xC3,0x00,0x10,0x01,
+0x0D,0xA1,0x06,0xFE,0xF8,0x07,0xB0,0xF3,0x38,0x07,0xB0,0x13,0x57,0x01,0x13,0x17,
+0x03,0x4C,0x9A,0xC0,0x12,0xF7,0x02,0x4C,0xB8,0xC0,0x4F,0x5A,0x80,0x4F,0x18,0x80,
+0x8C,0x9A,0x8C,0xB8,0x8C,0x99,0x8C,0xB7,0x4F,0x39,0x40,0x4E,0xF7,0x40,0x0D,0x81,
+0x0A,0x0D,0x61,0x0E,0x0D,0x41,0x12,0x0D,0x21,0x16,0x98,0x60,0x8C,0x99,0x8C,0xB7,
+0x1C,0x21,0x18,0xE4,0x00,0x5B,0x91,0x0D,0xA1,0x06,0x0D,0x81,0x0A,0x0D,0x61,0x0E,
+0x0D,0x41,0x12,0x0D,0x21,0x16,0x1C,0x21,0x18,0x85,0x29,0x1C,0x21,0xE0,0x0D,0xC1,
+0x08,0x0D,0x21,0x1C,0x0D,0x41,0x18,0x0D,0x61,0x14,0x0D,0x81,0x10,0x0D,0xA1,0x0C,
+0x0D,0xE1,0x04,0x89,0xC4,0xD0,0x66,0x00,0xB5,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xBA,
+0x70,0x4C,0x63,0x10,0x8C,0x77,0x0E,0xE3,0x02,0x86,0xE9,0x99,0xE8,0xC9,0x80,0x28,
+0x0A,0xE4,0x00,0x01,0xC9,0xD0,0x81,0x04,0x41,0x1E,0xE4,0xFE,0xD2,0xE1,0x04,0x89,
+0x5C,0x80,0xE1,0xCA,0xE0,0x28,0x0A,0xC9,0x80,0x10,0x06,0x49,0xE1,0x43,0x49,0x8C,
+0xB8,0x99,0xA2,0x99,0x41,0x99,0x60,0x48,0x60,0x1A,0xE4,0x00,0x01,0x87,0xD0,0x81,
+0x04,0x09,0x1E,0xE4,0xFE,0xD2,0xE1,0x04,0x51,0x5C,0x80,0xE1,0xCA,0xE0,0x28,0x0A,
+0xC9,0x80,0x10,0x06,0x99,0xA0,0x49,0xE1,0x43,0x49,0x8C,0xB8,0x89,0x4D,0x99,0x60,
+0x48,0x61,0x1B,0xE4,0x00,0x01,0x35,0x24,0x85,0xE9,0x5C,0x80,0xE1,0xCA,0xE0,0x28,
+0x0A,0xC9,0x80,0x08,0x03,0x49,0xE1,0x43,0x49,0x8C,0xB8,0xE4,0x00,0x00,0xD9,0x24,
+0x85,0xC1,0x5C,0x80,0xE1,0xCA,0xE0,0x28,0x0A,0xC9,0x80,0x10,0x06,0x49,0xE1,0x43,
+0x49,0x8C,0xB8,0xE4,0x00,0x00,0xC5,0x99,0xE1,0xE4,0x00,0x00,0x95,0x99,0xE4,0xC9,
+0x80,0x28,0x0A,0x99,0xA2,0x99,0x41,0x99,0x60,0xE4,0x00,0x00,0x21,0x99,0xE4,0xC9,
+0x80,0x28,0x0A,0x99,0xA2,0x99,0x41,0x99,0x63,0x98,0x60,0xE4,0x00,0x00,0x85,0x99,
+0xA0,0x99,0xE4,0xC9,0x80,0x28,0x0A,0x89,0x4D,0x99,0x60,0xE4,0x00,0x00,0x21,0x99,
+0xA0,0x99,0xE4,0xC9,0x80,0x28,0x0A,0x89,0x4D,0x99,0x63,0x98,0x61,0xE4,0x00,0x00,
+0x41,0x99,0xE4,0xC9,0x80,0x08,0x03,0x99,0xA0,0x89,0x4D,0xE4,0x00,0x00,0x1D,0x99,
+0xE4,0xC9,0x80,0x10,0x06,0x99,0xA2,0x99,0x41,0x99,0x60,0x98,0x63,0xE7,0xFF,0x86,
+0x60,0x88,0x6A,0x88,0x8D,0xE4,0x00,0x73,0x24,0x88,0x6A,0x88,0x8C,0xE4,0x00,0x5A,
+0x44,0x21,0xA0,0x3E,0x88,0x6A,0x88,0x8C,0xE4,0x00,0x6E,0xFE,0xE4,0x00,0x00,0x1F,
+0x21,0xA0,0x2C,0x88,0x6A,0x88,0x8C,0xE4,0x00,0x70,0x5A,0x88,0x6A,0x05,0x80,0xFF,
+0xC9,0x8C,0xFF,0xFF,0x88,0x8C,0xE4,0x00,0x5C,0xCA,0x88,0x8C,0x88,0x6A,0xE4,0x00,
+0x5A,0x52,0x98,0x62,0xE4,0x00,0x57,0xD2,0xC2,0xE0,0x10,0x01,0x98,0x60,0xEC,0x17,
+0x07,0x5C,0xC1,0xA0,0x10,0x01,0xEC,0x0D,0x07,0xB4,0xE4,0x00,0x64,0x0E,0x98,0x60,
+0xE4,0x00,0x5C,0x0E,0x98,0x60,0x88,0x8C,0xE4,0x00,0x5A,0xFE,0x88,0x6F,0xE4,0x00,
+0x57,0x2A,0x98,0x60,0xE4,0x00,0x5D,0x4E,0x21,0x64,0x5E,0xED,0x6D,0x07,0xB4,0x98,
+0x61,0xE4,0x00,0x63,0xC0,0x98,0x63,0xE4,0x00,0x5B,0xC0,0xE4,0x00,0x00,0x2B,0x21,
+0x6C,0x46,0x98,0x61,0x88,0x8C,0xE4,0x00,0x5A,0xA2,0x98,0x61,0xE4,0x00,0x5C,0xFE,
+0xE4,0x00,0x60,0xE2,0x1C,0x63,0x13,0x5C,0x83,0x00,0x88,0x6A,0x5C,0x82,0x93,0x20,
+0x00,0x1B,0x50,0x80,0x14,0xE4,0x00,0x5E,0x00,0x88,0x6A,0x98,0x8C,0xE4,0x00,0x5D,
+0x22,0xC2,0xE0,0x10,0x01,0x88,0x6E,0xED,0xD7,0x07,0xB8,0xE7,0xFF,0xF6,0x80,0x88,
+0x6E,0x0D,0xE1,0x06,0x0D,0xC1,0x0A,0x0D,0xA1,0x0E,0x0D,0x81,0x12,0x0D,0x61,0x16,
+0x0D,0x41,0x1A,0x0D,0x21,0x1E,0x1C,0x21,0x20,0xE7,0xFF,0xF9,0x85,0xC2,0xE0,0x10,
+0x01,0x9C,0x38,0xEC,0x77,0x03,0x24,0x0D,0x41,0x00,0x0D,0x21,0x04,0x89,0x43,0xE7,
+0xFF,0xFB,0xB8,0x25,0x44,0xD3,0x99,0x40,0x88,0x6A,0x98,0x80,0x9D,0x41,0xE4,0x00,
+0x63,0x00,0x5D,0x4A,0x00,0xD1,0x44,0xFF,0x9E,0xE7,0xFF,0xE7,0xB4,0xC2,0xE0,0x10,
+0x01,0xFE,0xF7,0x00,0xD6,0x0C,0x77,0x0B,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x06,0x4B,
+0x53,0x18,0x20,0xEF,0x17,0x06,0x4B,0x0D,0x41,0x02,0x0D,0x21,0x06,0x9C,0x28,0x85,
+0x29,0x1C,0x21,0xD8,0xC2,0xE0,0x10,0x01,0x0D,0x41,0x20,0x0D,0xC1,0x10,0xEE,0xF7,
+0x00,0xD2,0x0D,0x21,0x24,0x0D,0x61,0x1C,0x0D,0x81,0x18,0x0D,0xA1,0x14,0x0D,0xE1,
+0x0C,0x0E,0x01,0x08,0x0E,0x21,0x04,0x0E,0x41,0x00,0x5E,0xE0,0x41,0x89,0x43,0x49,
+0xC1,0x01,0x24,0x64,0x6D,0x1E,0xE3,0xFE,0xD2,0xE1,0x04,0x31,0xD0,0x67,0x04,0x4A,
+0x51,0x60,0x20,0xD0,0x69,0x04,0x46,0x99,0x64,0xE4,0x00,0x00,0x3D,0x51,0x60,0x10,
+0x9A,0xE0,0x20,0x60,0x5C,0x9A,0xE0,0xD1,0x45,0x00,0x92,0x9A,0xE1,0x21,0x44,0x30,
+0x21,0x4C,0x24,0xD1,0x46,0x00,0x32,0x9A,0xE0,0x4E,0xF7,0x28,0xC1,0xE0,0x10,0x01,
+0xC2,0x00,0x10,0x01,0xFD,0xEF,0x0B,0x7C,0xFE,0x10,0x07,0x6C,0x99,0x80,0xC2,0x40,
+0x10,0x01,0x8D,0xF7,0x8E,0x17,0x89,0xAC,0x1E,0x2A,0xFE,0xFE,0x52,0x09,0xAC,0x88,
+0x6D,0x98,0x81,0x88,0xAE,0xE4,0x00,0x6B,0x48,0x42,0xEF,0x64,0x25,0x44,0x41,0x42,
+0xF0,0x64,0x26,0x24,0x29,0xD1,0x47,0x00,0x56,0x42,0xEC,0x94,0x0C,0x77,0x01,0x9D,
+0xA1,0x9D,0x82,0x5D,0xAD,0x00,0xD5,0x6D,0xFE,0xCD,0xE4,0x00,0x00,0x35,0x51,0x60,
+0x10,0xE4,0x00,0x00,0x15,0x99,0x63,0xE7,0xFF,0xFF,0x41,0x9A,0xE0,0x21,0x4A,0x22,
+0xE7,0xFF,0xFF,0x33,0x0E,0x41,0x02,0x0E,0x21,0x06,0x0E,0x01,0x0A,0x0D,0xE1,0x0E,
+0x0D,0xC1,0x12,0x0D,0xA1,0x16,0x0D,0x81,0x1A,0x0D,0x61,0x1E,0x0D,0x41,0x22,0x0D,
+0x21,0x26,0x1C,0x21,0x28,0x85,0x29,0x1C,0x21,0xD0,0x0D,0x41,0x28,0x0D,0x21,0x2C,
+0x0D,0x61,0x24,0x0D,0x81,0x20,0x89,0x44,0xD0,0x67,0x04,0x95,0xC2,0xF8,0x00,0x21,
+0xFE,0xF7,0xBA,0x8C,0x4C,0x63,0x10,0xC1,0x60,0x10,0x01,0x8C,0x77,0xC1,0x80,0x10,
+0x01,0x0E,0xE3,0x02,0xFD,0x6B,0x0A,0x64,0xFD,0x8C,0x0B,0x7C,0x86,0xE9,0xC2,0xE0,
+0x10,0x01,0xEB,0x17,0x06,0x4B,0xC7,0x18,0xFF,0xDF,0xEF,0x17,0x06,0x4B,0xD0,0x88,
+0x02,0xE5,0x9A,0xE1,0x4E,0xF7,0x24,0xC6,0xF7,0x01,0x83,0x22,0xE1,0x3C,0xE4,0x00,
+0x00,0x8D,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x06,0x4B,0xC7,0x18,0xFF,0xDF,0xEF,0x17,
+0x06,0x4B,0xD1,0x47,0x01,0xC5,0x9A,0xE1,0x4E,0xF7,0x54,0x57,0x17,0x8C,0x23,0x00,
+0x9A,0x56,0xF7,0x03,0x22,0xE0,0x98,0x88,0x6A,0xE7,0xFF,0xFD,0x10,0x4C,0x8A,0x28,
+0x4C,0xAA,0x30,0x88,0x61,0x8C,0x8C,0x8C,0xAB,0x50,0xC0,0x10,0xE4,0x00,0x17,0x70,
+0xE4,0x00,0x00,0x15,0x88,0x6A,0xE7,0xFF,0xFC,0xD6,0x0D,0x81,0x22,0x0D,0x61,0x26,
+0x0D,0x41,0x2A,0x0D,0x21,0x2E,0x1C,0x21,0x30,0x85,0x29,0xC3,0x00,0x10,0x01,0x98,
+0x60,0xFF,0x18,0x07,0x6C,0xCB,0x60,0xFF,0xFE,0xE4,0x00,0x00,0x73,0x43,0x38,0xBC,
+0x0B,0x59,0x00,0x4F,0x3A,0xFA,0x47,0x59,0xD6,0x43,0x3A,0xCD,0xCB,0x40,0xFF,0xFE,
+0x8C,0x79,0x5C,0x7A,0x17,0x5F,0x23,0x04,0x9E,0xE2,0x48,0x79,0xD8,0x5E,0xE4,0x09,
+0x23,0xFF,0x75,0xC2,0xE0,0x10,0x01,0x1F,0x18,0x20,0xFE,0xF7,0x07,0xAC,0xD7,0x17,
+0x00,0x52,0x9A,0xE0,0xE7,0xFF,0xFF,0x93,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,0x17,
+0x07,0x68,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x07,0x60,0xC2,0xE0,0x10,0x01,0x9B,0x04,
+0xEC,0x17,0x07,0xAC,0x98,0x64,0xC2,0xE0,0x10,0x01,0x98,0x80,0xEF,0x17,0x03,0x24,
+0xE7,0xFF,0xF6,0xF7,0x20,0x64,0x3E,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x07,0x6A,0xE4,
+0x00,0x00,0x41,0x20,0x68,0x3E,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x07,0x62,0xE4,0x00,
+0x00,0x23,0x9A,0xE0,0x20,0x6C,0x2E,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x07,0xAE,0x88,
+0x77,0x85,0x29,0x20,0x64,0x3E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x07,0x68,0xE4,0x00,
+0x00,0x3D,0x20,0x68,0x3E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x07,0x60,0xE4,0x00,0x00,
+0x1F,0x20,0x6C,0x2E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x07,0xAC,0x85,0x29,0x1C,0x21,
+0xE0,0xC2,0xE0,0x10,0x01,0x0D,0x41,0x18,0x0D,0x61,0x14,0x0D,0x81,0x10,0x0D,0xA1,
+0x0C,0x0D,0xC1,0x08,0x0D,0xE1,0x04,0xEE,0xF7,0x0D,0x56,0x0D,0x21,0x1C,0xC1,0x80,
+0x10,0x01,0xC1,0x60,0x10,0x01,0x5D,0xE3,0x06,0x5D,0xC4,0x06,0x89,0x45,0x89,0xA6,
+0x56,0xF7,0x01,0xFD,0x8C,0x09,0xA0,0xFD,0x6B,0x08,0x6C,0x22,0xE0,0xE0,0x98,0xA2,
+0x25,0x44,0x43,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xBB,0xA0,0x8E,0xEA,0x10,0xB7,0x00,
+0x0E,0xEB,0x02,0x5E,0xE0,0x29,0x88,0x6F,0x88,0x8E,0x48,0xA5,0x12,0xE7,0xFF,0x8F,
+0xCC,0x5C,0x63,0x00,0x20,0x60,0x3C,0x0C,0x0C,0x00,0x0C,0x0D,0x00,0x98,0x61,0xE4,
+0x00,0x00,0xED,0x21,0x45,0x38,0x21,0x40,0x28,0x21,0x4D,0x8E,0xE4,0x00,0x00,0xA7,
+0x0E,0xEB,0x02,0x22,0xE4,0x36,0xE7,0xFF,0x92,0xCE,0x98,0x62,0xE4,0x00,0x00,0x5D,
+0x0E,0xEC,0x02,0x22,0xE4,0x86,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x0D,0x76,0xC2,0xE0,
+0x10,0x01,0xEC,0x97,0x0D,0x56,0xE7,0xFF,0x98,0xEA,0x88,0x6D,0xE7,0xFF,0x99,0x02,
+0xE4,0x00,0x00,0x15,0xE7,0xFF,0x92,0x72,0x98,0x60,0x0C,0x0B,0x00,0xE4,0x00,0x00,
+0x4B,0x88,0x6F,0x88,0x8E,0xE7,0xFF,0x92,0x74,0x98,0x60,0xE4,0x00,0x00,0x2F,0xE7,
+0xFF,0x92,0x3C,0x9A,0xE1,0x0E,0xEB,0x00,0xE4,0x00,0x00,0x11,0xE7,0xFF,0x92,0x22,
+0x98,0x62,0x0D,0x4C,0x00,0x0D,0xE1,0x06,0x0D,0xC1,0x0A,0x0D,0xA1,0x0E,0x0D,0x81,
+0x12,0x0D,0x61,0x16,0x0D,0x41,0x1A,0x0D,0x21,0x1E,0x1C,0x21,0x20,0x85,0x29,0xC3,
+0x80,0x10,0x01,0xC3,0x60,0x10,0x01,0xC3,0x40,0x10,0x01,0xC3,0x20,0x10,0x01,0xC3,
+0x00,0x10,0x01,0xFF,0x9C,0x0D,0x4A,0xFF,0x7B,0x0A,0x5A,0xFF,0x5A,0x0C,0xD8,0xFF,
+0x39,0x0C,0xE4,0xFF,0x18,0x0C,0xDC,0x20,0x69,0x76,0x0A,0xFC,0x04,0x0B,0xD9,0x09,
+0x43,0xD7,0xF5,0x5F,0xDE,0x06,0x4F,0xBE,0xFA,0x47,0xDD,0xF6,0x43,0xBE,0xED,0x5F,
+0xAC,0x99,0x20,0x00,0x79,0x0B,0xBC,0x07,0x0B,0x99,0x0B,0x43,0xBD,0xE5,0x5F,0xBD,
+0x06,0x4F,0x9D,0xFA,0x47,0xBC,0xEE,0x43,0x9D,0xE5,0x5F,0x8D,0xD1,0x20,0x05,0x15,
+0x0E,0xF8,0x01,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x0D,0x51,0x0B,0x99,0x0B,0x0E,0xF8,
+0x03,0x0B,0x39,0x0F,0x12,0xFA,0x00,0x0F,0x9B,0x01,0x0F,0x3B,0x03,0x52,0xF7,0x02,
+0xE4,0x00,0x01,0x55,0xC3,0xA0,0x10,0x01,0xC2,0xE0,0x10,0x01,0xFF,0xBD,0x09,0xB2,
+0xFE,0xF7,0x0C,0x08,0x20,0x6D,0x8E,0x0B,0x79,0x01,0x0B,0xDC,0x01,0x43,0xDE,0xDD,
+0x5F,0xDE,0x06,0x4F,0x7E,0xFA,0x47,0xDB,0xF6,0x43,0x7E,0xDD,0x5F,0x6C,0x99,0x20,
+0x00,0x79,0x0B,0x39,0x03,0x0B,0x7C,0x03,0x43,0x7B,0xCD,0x5F,0x7B,0x06,0x4F,0x3B,
+0xFA,0x47,0x79,0xDE,0x43,0x3B,0xCD,0x5F,0x2D,0xD1,0x20,0x03,0x61,0x0B,0x37,0x17,
+0x0F,0x38,0x01,0x0B,0x37,0x19,0x0F,0x38,0x03,0x0B,0x37,0x47,0x0A,0xF7,0x49,0x0E,
+0xF8,0x07,0x12,0xFA,0x00,0x52,0xF7,0x01,0x0F,0x38,0x05,0x1A,0xFA,0x00,0x9A,0xE2,
+0x1A,0xFD,0x00,0xE4,0x00,0x01,0x5F,0xD0,0x64,0x01,0xD6,0x0B,0x3B,0x00,0x0B,0x7B,
+0x02,0x43,0x79,0xDD,0x9F,0x6E,0x5F,0x63,0x9B,0x20,0x00,0x2F,0xC3,0x20,0x10,0x01,
+0xEB,0x39,0x0C,0xDF,0x0B,0x18,0x01,0x0F,0x17,0x47,0x9B,0x02,0x0F,0x37,0x49,0x1B,
+0x17,0x00,0x12,0xFA,0x00,0x9B,0x1D,0x46,0xF7,0xC4,0x1A,0xFA,0x00,0xE4,0x00,0x00,
+0xEB,0xD0,0x65,0x03,0x8E,0x13,0x7D,0x00,0x23,0x68,0xFE,0x0B,0x98,0x00,0x0B,0x59,
+0x00,0x8F,0x5C,0x43,0x5A,0xD8,0x0B,0x98,0x02,0x0F,0x57,0x17,0x0B,0x59,0x02,0x8F,
+0x5C,0x43,0x5A,0xD8,0x0B,0x98,0x04,0x0F,0x57,0x19,0x0B,0x59,0x08,0x8F,0x5C,0x43,
+0x5A,0xD8,0x0F,0x57,0x47,0x0B,0x58,0x06,0x0B,0x19,0x0A,0x8F,0x1A,0x43,0x78,0xD8,
+0x0F,0x77,0x49,0xE4,0x00,0x00,0x55,0x23,0x64,0x9A,0x0B,0x38,0x01,0x0F,0x37,0x17,
+0x0B,0x38,0x03,0x0F,0x37,0x19,0x0B,0x38,0x05,0x0B,0x18,0x07,0x0F,0x37,0x47,0x0F,
+0x17,0x49,0x9B,0x3E,0x13,0x1A,0x00,0x47,0x18,0xCC,0x1B,0x1A,0x00,0x9B,0x02,0x1B,
+0x17,0x00,0x85,0x29,0xC3,0x00,0x10,0x01,0xFF,0x18,0x0D,0x4A,0xFE,0xE0,0x7F,0xFF,
+0x0E,0xF8,0x01,0x0E,0xF8,0x03,0x0E,0xF8,0x05,0x0E,0xF8,0x07,0x9B,0x01,0xC3,0x20,
+0x10,0x01,0xFF,0x39,0x03,0x36,0x1B,0x19,0x01,0xC3,0x00,0x10,0x01,0xFF,0x18,0x09,
+0xBA,0x0E,0xF8,0x01,0x0E,0xF8,0x03,0x0E,0xF8,0x05,0x0E,0xF8,0x07,0xC3,0x00,0x10,
+0x01,0xF8,0x18,0x09,0xB3,0xC3,0x00,0x10,0x01,0xFF,0x18,0x0C,0xE4,0x0E,0xF8,0x01,
+0x0E,0xF8,0x03,0x0E,0xF8,0x05,0x0E,0xF8,0x07,0x0E,0xF8,0x09,0x0E,0xF8,0x0B,0x0E,
+0xF8,0x0D,0x0E,0xF8,0x0F,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0A,0x5E,0xC2,0xE0,0x10,
+0x01,0x18,0x19,0x00,0xF3,0x17,0x0C,0xD8,0x9B,0x3C,0x47,0x18,0xCC,0xFB,0x17,0x0C,
+0xD8,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x09,0xB2,0x85,0x29,0xC2,0xE0,0x10,0x01,0xC3,
+0x00,0x10,0x01,0x5C,0x63,0x00,0xFE,0xF7,0x0D,0x04,0xFF,0x18,0x0B,0xC0,0x9B,0x20,
+0x20,0x80,0x6C,0xE4,0x00,0x00,0x47,0x4F,0x59,0x10,0x0B,0x97,0x00,0x0B,0x77,0x02,
+0x8F,0x58,0x8F,0x7C,0x9F,0x21,0x0F,0x7A,0x00,0x9E,0xE4,0x5F,0x59,0x00,0xD4,0x7A,
+0xFF,0x4D,0xE4,0x00,0x00,0xF7,0x0B,0x57,0x00,0x0B,0x37,0x02,0x8F,0x3A,0xC3,0x80,
+0x10,0x01,0x0F,0x38,0x00,0xFF,0x9C,0x0A,0xE4,0x13,0x3C,0x04,0x1F,0xB9,0xFF,0x4F,
+0xBD,0x10,0x43,0xD8,0xEC,0x8F,0xB7,0x4F,0x79,0x08,0x09,0x1D,0x00,0x1F,0x5B,0xFF,
+0x4F,0xBA,0x08,0x8F,0xB7,0x0B,0xBD,0x00,0x8F,0xA8,0x0F,0xBE,0x00,0x13,0x9C,0x01,
+0x27,0x84,0xF5,0x4F,0x39,0x10,0x4F,0x5A,0x10,0x43,0x98,0xCC,0x43,0xB7,0xCC,0x9F,
+0x61,0x0B,0xBD,0x00,0x4F,0x7B,0x08,0x8F,0x77,0x0B,0x7B,0x00,0x8F,0x7D,0x0F,0x7C,
+0x00,0x8F,0x1A,0x1F,0x59,0xFE,0x9F,0x3F,0x4F,0x5A,0x08,0x4F,0x39,0x08,0x8F,0x57,
+0x8E,0xF9,0x0B,0x5A,0x00,0x0A,0xF7,0x00,0x8E,0xFA,0x0E,0xF8,0x00,0x85,0x29,0xC3,
+0x00,0x10,0x01,0x5C,0x84,0x00,0xFF,0x18,0x0D,0x04,0x20,0xA0,0x6C,0xE4,0x00,0x00,
+0x4B,0x4F,0x37,0x08,0x9E,0xE1,0x43,0x58,0xCC,0x8F,0x23,0x0B,0x5A,0x00,0x0F,0x59,
+0x01,0xE4,0x00,0x00,0x0D,0x9A,0xE0,0x5F,0x37,0x00,0xD4,0x99,0xFF,0x3D,0xE4,0x00,
+0x00,0x7F,0x20,0xA4,0xEE,0xE4,0x00,0x00,0x31,0x4F,0x37,0x08,0x9E,0xE1,0x43,0x43,
+0xCC,0x8F,0x38,0x0B,0x5A,0x00,0x0F,0x59,0x01,0xE4,0x00,0x00,0x0D,0x9A,0xE0,0x5F,
+0x37,0x00,0xD4,0x99,0xFF,0x3D,0xC2,0xE0,0x10,0x01,0x98,0x80,0xFE,0xF7,0x0A,0xE4,
+0x10,0x77,0x01,0x12,0xF7,0x04,0x40,0x63,0xBB,0xE7,0xFF,0xFD,0xC5,0x85,0x29,0x5C,
+0x84,0x00,0x5C,0x82,0x09,0x4A,0xE1,0x13,0x4F,0x04,0x09,0x9B,0xA2,0x43,0x18,0xBB,
+0x1F,0xC4,0xFE,0x1F,0x58,0xFE,0x1F,0x78,0xFF,0x1F,0x98,0x01,0x9A,0xE0,0x1D,0x04,
+0xFF,0xE4,0x00,0x00,0x73,0x27,0x24,0x6D,0xD6,0xFE,0x00,0xC2,0xD6,0xE8,0x00,0xA2,
+0xD6,0xFA,0x00,0x82,0xD6,0xFB,0x00,0x62,0xD6,0xF8,0x00,0x42,0xD6,0xFC,0x00,0xD6,
+0x20,0xA0,0x36,0x0B,0x23,0x01,0x4F,0x39,0x08,0xE4,0x00,0x00,0x15,0x0B,0x23,0x00,
+0x43,0x39,0xE8,0x0F,0x23,0x01,0x9E,0xE1,0x9C,0x62,0x5F,0x37,0x00,0xD4,0x99,0xFE,
+0x45,0x85,0x29,0x9C,0x38,0x98,0x63,0x0D,0x21,0x04,0xE7,0xFF,0x75,0x66,0x0D,0x21,
+0x06,0x9C,0x28,0xE4,0x00,0x73,0x65,0x9A,0xE8,0x1C,0x21,0xE8,0x0D,0x41,0x10,0x0D,
+0x81,0x08,0xC1,0x80,0x10,0x01,0xFD,0x4C,0x0A,0xE4,0x1A,0xEA,0x04,0x9A,0xE2,0x1A,
+0xEA,0x01,0xFE,0xE0,0x07,0xFF,0x0E,0xEA,0x07,0x0E,0xEA,0x09,0xC2,0xE0,0x10,0x01,
+0x0D,0x61,0x0C,0x99,0x64,0xF9,0x77,0x0A,0x5F,0xFE,0xE0,0x01,0x24,0x0E,0xEA,0x0B,
+0xFE,0xE0,0x04,0x00,0x0D,0x21,0x14,0x0E,0xEA,0x03,0x50,0x60,0x20,0x98,0x80,0xE7,
+0xFF,0x46,0x60,0x50,0x60,0x20,0x98,0x81,0xE7,0xFF,0x46,0x4E,0x52,0xE0,0x23,0xFA,
+0xEC,0x0A,0xE4,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x00,0xC5,0xC2,0xE0,0x10,0x01,0xEC,
+0x17,0x0D,0x7C,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x09,0xA8,0xC2,0xE0,0x10,0x01,0xEC,
+0x17,0x08,0x25,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0D,0x78,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x09,0xB6,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0A,0xF2,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x09,0xC8,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0D,0x58,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x0C,0xF5,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0A,0xF3,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x09,0xC9,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x0B,0xBD,0xC2,0xE0,0x10,0x01,0xEC,
+0x17,0x09,0x9C,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x0D,0x61,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x0A,0x58,0xC2,0xE0,0x10,0x01,0x9B,0x03,0xFB,0x17,0x0A,0x61,0xC2,0xE0,0x10,
+0x01,0xF8,0x17,0x09,0xB3,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x07,0x58,0xC2,0xE0,0x10,
+0x01,0xFF,0x00,0x01,0xF4,0xEF,0x17,0x06,0x49,0xC2,0xE0,0x10,0x01,0x50,0x60,0x14,
+0xF8,0x17,0x07,0xDC,0x50,0x80,0x50,0x19,0x6A,0x0C,0xE7,0xFF,0x84,0xAE,0x52,0xE0,
+0x64,0x50,0x80,0x39,0x0E,0xE1,0x01,0x50,0xA0,0x64,0xFC,0xC0,0x07,0xFF,0xFC,0xE0,
+0x07,0xFF,0x99,0x01,0xC0,0x60,0x10,0x01,0xFC,0x63,0x01,0x80,0xE7,0xFF,0xA1,0xD8,
+0xC0,0x60,0x10,0x01,0x98,0x80,0xFC,0x63,0x0B,0xC0,0x50,0xA0,0x48,0xE7,0xFF,0xA4,
+0xDA,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0C,0x08,0x9E,0xE4,0x18,0x17,0x00,0x18,0x17,
+0x01,0x18,0x17,0x02,0xC3,0x00,0x10,0x01,0x1E,0xF7,0x30,0xFF,0x18,0x0C,0xCC,0xD6,
+0xF8,0xFF,0x66,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0D,0x59,0xC2,0xE0,0x10,0x01,0xF3,
+0x37,0x00,0xB0,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x3D,0xF9,0x1B,0x38,0x00,0xC3,0x00,
+0x10,0x01,0xF3,0x18,0x07,0x57,0xCA,0xF7,0x3D,0xF8,0x1B,0x17,0x00,0xC3,0x00,0x10,
+0x01,0xEC,0x18,0x0B,0x35,0xC3,0x00,0x10,0x01,0xC2,0xE0,0x10,0x01,0xEB,0x58,0x09,
+0xB9,0xEB,0x37,0x07,0xDF,0x53,0x5A,0x04,0xEF,0x58,0x09,0xB9,0x53,0x19,0x05,0xEF,
+0x17,0x07,0xDF,0xC3,0x00,0x10,0x01,0xFE,0xF8,0x0C,0xF6,0xC3,0x60,0x10,0x01,0x18,
+0x17,0x01,0x18,0x17,0x02,0x18,0x17,0x03,0x0C,0x17,0x05,0x0C,0x17,0x07,0x0C,0x17,
+0x0B,0x0C,0x17,0x09,0xC3,0x40,0x10,0x01,0xC3,0x20,0x10,0x01,0xF8,0x18,0x0C,0xF6,
+0x9A,0xE0,0xFF,0x7B,0x0D,0x04,0xFF,0x5A,0x0B,0x36,0xFF,0x39,0x09,0xCC,0x43,0x1B,
+0xBC,0x0C,0x18,0x01,0x43,0x1A,0xBC,0x0C,0x18,0x01,0x4F,0x17,0x08,0x8F,0x19,0x0C,
+0x18,0x00,0x9E,0xE2,0x5E,0xE8,0xC9,0x23,0xFF,0x9D,0x0D,0x81,0x0A,0x0D,0x61,0x0E,
+0x0D,0x41,0x12,0x0D,0x21,0x16,0x1C,0x21,0x18,0x85,0x29,0xE4,0x00,0x6B,0x93,0x1C,
+0x21,0xE8,0x0D,0x21,0x14,0xE7,0xFF,0xD4,0x04,0xE7,0xFF,0xAD,0x5A,0xE7,0xFF,0xD3,
+0x26,0xE7,0xFF,0xF0,0xF2,0x98,0x60,0x98,0x81,0xE7,0xFF,0x6F,0x0C,0x98,0x81,0x98,
+0x60,0x88,0xA4,0xE7,0xFF,0x6F,0x12,0x98,0x81,0x98,0x60,0x88,0xA4,0xE7,0xFF,0x6F,
+0x28,0x98,0x80,0x98,0x61,0x88,0xA4,0xE7,0xFF,0x6F,0x14,0x98,0xA0,0x98,0x62,0x98,
+0x81,0xE7,0xFF,0x6F,0x00,0x98,0x62,0x98,0x80,0xE7,0xFF,0x6F,0x76,0x98,0x60,0x50,
+0x80,0xF6,0xE7,0xFF,0x6F,0x7E,0x98,0x61,0x50,0x80,0xF6,0xE7,0xFF,0x6F,0x6C,0x98,
+0x62,0x50,0x80,0xF3,0xE7,0xFF,0x6F,0x5A,0x98,0x60,0xFC,0x80,0xA0,0x00,0xE7,0xFF,
+0x6F,0xA2,0x98,0x61,0xFC,0x80,0xA0,0x00,0xE7,0xFF,0x6F,0x8E,0x98,0x62,0xFC,0x80,
+0xA0,0x00,0xE7,0xFF,0x6F,0x7A,0xFC,0x80,0x01,0x26,0x98,0x62,0xE7,0xFF,0x6F,0xC2,
+0xFC,0x60,0x01,0x5E,0xE7,0xFF,0x9F,0xBE,0xE7,0xFF,0xFA,0x7E,0x50,0x60,0x1B,0xE7,
+0xFF,0x5C,0x0E,0x50,0x60,0xFA,0xE7,0xFF,0x5C,0x14,0xFC,0x60,0x01,0x08,0xE7,0xFF,
+0x5C,0x18,0x50,0x60,0xCC,0xE7,0xFF,0x5C,0x1E,0x50,0x60,0xCC,0xE7,0xFF,0x5C,0x24,
+0x98,0x6A,0xE7,0xFF,0x5C,0x2C,0x50,0x60,0x1B,0xE7,0xFF,0x73,0x70,0x9A,0xEE,0x0E,
+0xE1,0x00,0x52,0xE0,0x14,0x0E,0xE1,0x04,0xCA,0xE0,0x07,0xD0,0x99,0x0A,0x0E,0xE1,
+0x08,0x98,0xC8,0x98,0xAE,0x88,0xE6,0x98,0x6A,0x98,0x8C,0xE7,0xFF,0x40,0x22,0x98,
+0x81,0x98,0x60,0xE7,0xFF,0xD2,0x00,0x50,0x60,0x10,0xE7,0xFF,0xD2,0x32,0xE4,0x00,
+0x3F,0x84,0xE7,0xFF,0xF9,0x82,0x98,0x80,0x98,0xC0,0x88,0xA4,0x98,0x60,0xE7,0xFF,
+0x3C,0xF2,0xE7,0xFF,0xC0,0x1A,0xE7,0xFF,0xBF,0x06,0xC2,0xE0,0x10,0x01,0xF0,0x77,
+0x03,0x3C,0xE7,0xFF,0xD1,0xC2,0x9B,0x00,0xCA,0xE0,0x48,0x00,0xC3,0x17,0x00,0x0D,
+0xC3,0x17,0x00,0x0F,0x53,0x18,0x04,0xC3,0x17,0x00,0x0D,0xC3,0x17,0x00,0x0F,0x53,
+0x18,0x08,0xC3,0x17,0x00,0x0D,0xC2,0xE0,0x01,0x1F,0x52,0xF7,0x06,0xC2,0xE0,0x01,
+0x1D,0xFC,0x60,0x01,0x40,0xE7,0xFF,0xD1,0x6C,0x50,0x60,0x20,0xE7,0xFF,0xD1,0x76,
+0x98,0x61,0x50,0x80,0x13,0x50,0xA0,0x37,0x98,0xC8,0xFC,0xE0,0x01,0xB0,0xE7,0xFF,
+0xB3,0x46,0xC3,0x00,0x00,0x01,0xC2,0xE0,0x10,0x01,0xFF,0x18,0x3E,0x8B,0x0D,0x21,
+0x16,0xEF,0x17,0x03,0xFC,0x1C,0x21,0x18,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEF,0x17,
+0x00,0xD2,0x23,0x05,0x08,0xEE,0xF7,0x00,0xD2,0x22,0xE8,0xEC,0xC3,0x00,0x10,0x01,
+0xC2,0xE0,0x10,0x01,0xFF,0x18,0x09,0xAC,0xFE,0xF7,0x0D,0x5A,0x0B,0x38,0x01,0xC3,
+0x60,0x10,0x01,0x0F,0x37,0x01,0xC3,0x40,0x10,0x01,0x0B,0x38,0x03,0xFF,0x7B,0x0D,
+0x62,0x0F,0x37,0x03,0x0B,0x18,0x05,0xFF,0x5A,0x09,0x8A,0x0F,0x17,0x05,0x9A,0xE0,
+0xE4,0x00,0x00,0x69,0xC3,0x80,0x10,0x01,0xC3,0x60,0x10,0x01,0x9A,0xE0,0xFF,0x9C,
+0x0B,0x7C,0xFF,0x7B,0x07,0xE0,0x43,0x3C,0xBC,0x43,0x1B,0xBC,0x0B,0x59,0x01,0x0B,
+0x39,0x21,0x0F,0x58,0x01,0x0F,0x38,0x21,0x9E,0xE2,0x5E,0xE4,0x09,0x23,0xFF,0xA5,
+0xE7,0xFF,0xFF,0x39,0x43,0x1B,0xBC,0x43,0x3A,0xBC,0x0B,0x39,0x01,0x0F,0x38,0x01,
+0x9E,0xE2,0x5E,0xE2,0x09,0x23,0xFF,0xBD,0x85,0x29,0xC3,0x80,0x10,0x01,0xC3,0x00,
+0x10,0x01,0x9A,0xE0,0xFF,0x9C,0x07,0xE0,0xFF,0x18,0x0B,0x36,0x43,0x5C,0xBC,0x43,
+0x38,0xBC,0x0B,0x7A,0x01,0x0B,0x5A,0x21,0x0F,0x79,0x01,0x0F,0x59,0x21,0x9E,0xE2,
+0x5E,0xE4,0x09,0x23,0xFF,0xA5,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0D,0x5A,0x0B,0x37,
+0x01,0x0F,0x38,0x41,0x0B,0x37,0x03,0x0A,0xF7,0x05,0x0F,0x38,0x43,0x0E,0xF8,0x45,
+0x85,0x29,0xE4,0x00,0x69,0x89,0xC2,0xE0,0x10,0x01,0xFF,0x20,0xDF,0x9F,0xEB,0x17,
+0x08,0x25,0x47,0x18,0xCC,0x9B,0x3E,0xEF,0x17,0x08,0x25,0xC2,0xE0,0x10,0x01,0xEB,
+0x17,0x0C,0xDB,0x47,0x18,0xCC,0xEF,0x17,0x0C,0xDB,0x85,0x29,0xE4,0x00,0x72,0x39,
+0xE4,0x00,0x71,0xD7,0xE4,0x00,0x72,0x67,0xC2,0xE0,0x10,0x01,0xC3,0x40,0x10,0x01,
+0xF3,0x77,0x0A,0xE4,0xFF,0x5A,0x08,0x24,0xC3,0x00,0x10,0x01,0x88,0xC3,0x1F,0xBB,
+0xFF,0x0A,0xFA,0x01,0xFF,0x18,0x0D,0x04,0x9B,0x20,0xE4,0x00,0x00,0x57,0xD7,0xB9,
+0x00,0xB8,0x0B,0xD8,0x00,0x0B,0x98,0x02,0x8F,0x9E,0xCB,0xD7,0x20,0x00,0xC3,0x80,
+0x1F,0x2C,0x4A,0xFE,0xB8,0x0B,0x98,0x00,0x53,0xD7,0x40,0x5F,0x86,0xD9,0x9F,0x21,
+0x4A,0xFE,0xB8,0x9F,0x02,0x5F,0x99,0x04,0xD7,0x7C,0xFE,0xB5,0x98,0x60,0x0E,0xFA,
+0x01,0x88,0x83,0x98,0xA0,0xE7,0xFF,0xBC,0xBD,0x9C,0x38,0x0D,0x41,0x00,0x0D,0x21,
+0x04,0xC1,0x40,0x10,0x01,0x20,0x64,0x62,0xE7,0xFF,0xBD,0xD8,0x20,0x64,0x56,0xF2,
+0xEA,0x0D,0x58,0x9E,0xE1,0xFA,0xEA,0x0D,0x58,0xE4,0x00,0x00,0x19,0xE7,0xFF,0xBE,
+0x5E,0xF8,0x0A,0x0D,0x58,0xE7,0xFF,0xDC,0x44,0x9A,0xE3,0x20,0x64,0x34,0xE7,0xFF,
+0xDC,0x32,0x5C,0x60,0x49,0x4A,0xE3,0x4B,0xC3,0x00,0x10,0x01,0xF3,0x38,0x0D,0x58,
+0xD6,0xF9,0x02,0x1D,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0C,0xF5,0xC2,0xE0,0x10,0x01,
+0xF8,0x17,0x0A,0xF2,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x09,0xC8,0xC2,0xE0,0x10,0x01,
+0xF8,0x18,0x0D,0x58,0xF8,0x17,0x07,0xDC,0x0D,0x41,0x02,0xC2,0xE0,0x10,0x01,0x0D,
+0x21,0x06,0xEB,0x17,0x08,0x25,0x9C,0x28,0x53,0x18,0x80,0xEF,0x17,0x08,0x25,0xE7,
+0xFF,0x6E,0x19,0x0D,0x41,0x02,0x0D,0x21,0x06,0x9C,0x28,0x85,0x29,0x9C,0x38,0xC3,
+0x14,0x00,0x01,0x0D,0x21,0x04,0xCA,0xF8,0x22,0x00,0x0B,0x37,0x01,0xCB,0x18,0x26,
+0x18,0x9B,0x3F,0x0F,0x37,0x01,0x0B,0x38,0x01,0x53,0x39,0x02,0x0F,0x38,0x01,0x0B,
+0x17,0x01,0xFC,0x60,0x01,0x00,0x0C,0x17,0x01,0xE7,0xFF,0xCC,0xC4,0xC2,0xE0,0x10,
+0x01,0x0D,0x21,0x06,0xEB,0x17,0x00,0xC5,0x9C,0x28,0xC7,0x18,0xFE,0xFF,0xEF,0x17,
+0x00,0xC5,0x85,0x29,0x5C,0xC6,0x00,0x9A,0xE0,0xE4,0x00,0x00,0x45,0x4F,0x17,0x08,
+0x4F,0x57,0x10,0x43,0x23,0xC4,0x8F,0x45,0x8F,0x04,0x0F,0x5A,0x02,0x0B,0x18,0x01,
+0x4F,0x5A,0x42,0x9E,0xE1,0x43,0x18,0xD5,0x0F,0x19,0x01,0x5F,0x17,0x00,0xD4,0xD8,
+0xFE,0xFD,0x85,0x29,0x9C,0x38,0x0D,0x21,0x04,0xE4,0x00,0x38,0xFA,0x0D,0x21,0x06,
+0xFC,0x60,0x01,0x00,0x9C,0x28,0xE7,0xFF,0xCB,0xFB,0x9C,0x38,0x0D,0x21,0x04,0xE4,
+0x00,0x38,0xCE,0x0D,0x21,0x06,0xFC,0x60,0x01,0x00,0x9C,0x28,0xE7,0xFF,0xCB,0xBF,
+0x9C,0x38,0x98,0x80,0x0D,0x21,0x04,0x98,0x61,0xE7,0xFF,0xE4,0x08,0x98,0x60,0xE7,
+0xFF,0x6C,0x50,0x98,0x61,0x98,0x80,0xE7,0xFF,0xE9,0x38,0x98,0x62,0x98,0x80,0xE7,
+0xFF,0xE9,0x28,0x0D,0x21,0x06,0x98,0x63,0x98,0x80,0x9C,0x28,0xE7,0xFF,0xE9,0x0F,
+0x98,0x64,0x98,0x80,0xE7,0xFF,0xE3,0xB3,0x9C,0x38,0x0D,0x21,0x04,0xE7,0xFF,0xD9,
+0xB4,0x24,0x64,0x29,0x20,0x69,0x8A,0xE4,0x00,0x00,0x19,0xE7,0xFF,0xD9,0x98,0xE4,
+0x00,0x00,0x57,0xE7,0xFF,0xCB,0x80,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x00,0xD6,0x0A,
+0xF7,0x09,0x40,0x63,0xBD,0x5E,0xE3,0x04,0xC2,0xE1,0x76,0xEA,0x20,0x00,0x7D,0x98,
+0x62,0xE7,0xFF,0xE8,0x26,0x20,0x60,0x5A,0x98,0x61,0x98,0x80,0xE7,0xFF,0xE3,0x22,
+0x0D,0x21,0x06,0x98,0x60,0x9C,0x28,0xE7,0xFF,0x6B,0x61,0x98,0x62,0x98,0x80,0xE7,
+0xFF,0xE2,0xFC,0xFC,0x60,0x01,0x5E,0xE7,0xFF,0x97,0xCC,0x0D,0x21,0x06,0x98,0x60,
+0x9C,0x28,0xE7,0xFF,0x6A,0xE3,0x0D,0x21,0x06,0x9C,0x28,0x85,0x29,0xD0,0x69,0x05,
+0xDD,0x4F,0x03,0x10,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xBA,0xD0,0x8E,0xF8,0xC3,0x00,
+0x10,0x01,0x0F,0x37,0x02,0xFF,0x18,0x09,0xCC,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x08,
+0x70,0x87,0x29,0xC3,0x00,0x10,0x01,0xFF,0x18,0x09,0x7C,0x0F,0x38,0x02,0xEF,0x37,
+0x00,0x80,0x0F,0x38,0x06,0x0F,0x18,0x0A,0xEF,0x37,0x00,0x84,0xEF,0x17,0x00,0x88,
+0xE4,0x00,0x00,0xF1,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0C,0xCC,0x0F,0x37,0x02,0xEF,
+0x38,0x00,0x80,0x0F,0x37,0x06,0x0E,0xF7,0x0A,0xEF,0x38,0x00,0x84,0xEE,0xF8,0x00,
+0x88,0xE4,0x00,0x00,0xAF,0x4C,0x63,0x30,0xC3,0x60,0x10,0x01,0x9A,0xE0,0xFF,0x7B,
+0x0A,0x64,0x8F,0x63,0x8C,0x78,0x43,0x23,0xBC,0x43,0x5B,0xBC,0x0F,0x5A,0x02,0x0F,
+0x59,0x00,0x9E,0xE4,0x5E,0xE8,0x09,0x23,0xFF,0xBD,0xE4,0x00,0x00,0x5D,0x9C,0x7E,
+0xC3,0x40,0x10,0x01,0x5C,0x63,0x00,0xFF,0x5A,0x08,0xFC,0x4C,0x63,0x30,0x8F,0x43,
+0x8C,0x77,0x9A,0xE0,0x43,0x03,0xBC,0x43,0x3A,0xBC,0x0F,0x39,0x02,0x0F,0x38,0x00,
+0x9E,0xE4,0x5E,0xE8,0x09,0x23,0xFF,0xBD,0x85,0x29,0xD0,0x69,0x06,0x1D,0x4F,0x03,
+0x10,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xBA,0xF8,0x8E,0xF8,0xC3,0x00,0x10,0x01,0x0F,
+0x37,0x02,0xFF,0x18,0x07,0xE0,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0D,0x5A,0x87,0x29,
+0x0B,0x37,0x00,0xC3,0x00,0x10,0x01,0x4F,0x39,0x40,0xFF,0x18,0x09,0x7C,0xE4,0x00,
+0x00,0x25,0x0B,0x37,0x00,0xC3,0x00,0x10,0x01,0x4F,0x39,0x40,0xFF,0x18,0x0C,0xCC,
+0x0F,0x38,0x00,0x0B,0x37,0x02,0x0A,0xF7,0x04,0x4F,0x39,0x40,0x4E,0xF7,0x40,0x0F,
+0x38,0x04,0x0E,0xF8,0x08,0xE4,0x00,0x00,0xD1,0x4E,0xE3,0x28,0x8F,0x17,0x4E,0xE3,
+0x30,0xC3,0x60,0x10,0x01,0xFF,0x7B,0x0A,0x64,0x8F,0x77,0x9A,0xE0,0x4F,0x37,0x08,
+0x43,0x58,0xBC,0x8F,0x3B,0x0B,0x5A,0x00,0x4F,0x5A,0x40,0x0F,0x59,0x00,0x9E,0xE2,
+0x5E,0xE4,0x09,0x23,0xFF,0xA9,0xE4,0x00,0x00,0x6F,0x1E,0xE3,0xFE,0x5E,0xF7,0x00,
+0x4F,0x37,0x28,0x4E,0xF7,0x30,0xC3,0x60,0x10,0x01,0x8F,0x19,0xFF,0x7B,0x08,0xFC,
+0x8F,0x77,0x9A,0xE0,0x4F,0x37,0x08,0x43,0x58,0xBC,0x8F,0x3B,0x0B,0x5A,0x00,0x4F,
+0x5A,0x40,0x0F,0x59,0x00,0x9E,0xE2,0x5E,0xE4,0x09,0x23,0xFF,0xA9,0xE7,0xFF,0xFD,
+0x01,0x9C,0x38,0x98,0x64,0x0D,0x41,0x00,0x0D,0x21,0x04,0x98,0x80,0xE7,0xFF,0xDF,
+0xA0,0xC1,0x40,0x10,0x01,0xEA,0xEA,0x00,0xC5,0xC6,0xF7,0xFE,0xFF,0xEE,0xEA,0x00,
+0xC5,0xE7,0xFF,0xFB,0x06,0xEA,0xEA,0x00,0xC5,0xC6,0xF7,0x01,0x00,0x22,0xE3,0xE0,
+0xFC,0x60,0x01,0x00,0xE7,0xFF,0xC7,0x0E,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xC6,0xDE,
+0xE7,0xFF,0xF5,0xD4,0x98,0x60,0xE7,0xFF,0xFD,0xE8,0x0D,0x21,0x06,0x0D,0x41,0x02,
+0x98,0x61,0x9C,0x28,0xE7,0xFF,0xFD,0xCD,0x9C,0x38,0x0D,0x21,0x04,0x20,0x64,0x54,
+0x98,0x62,0xE7,0xFF,0xFD,0xB0,0x98,0x63,0xE7,0xFF,0xFD,0xA4,0x98,0x69,0xE4,0x00,
+0x00,0x25,0x98,0x60,0xE7,0xFF,0xFD,0x8C,0x98,0x61,0xE7,0xFF,0xFD,0x80,0x98,0x68,
+0x0D,0x21,0x06,0x9C,0x28,0xE7,0xFF,0xFD,0x6B,0x9C,0x38,0x98,0x60,0x0D,0x21,0x04,
+0xE7,0xFF,0xFD,0x54,0x98,0x61,0xE7,0xFF,0xFD,0x48,0x0D,0x21,0x06,0x98,0x68,0x9C,
+0x28,0xE7,0xFF,0xFD,0x33,0x20,0x80,0x64,0xD0,0x84,0x00,0xFA,0x20,0x88,0x90,0x20,
+0x8C,0xA8,0x5C,0x80,0x21,0x4B,0x0A,0x01,0x8A,0xF8,0xE4,0x00,0x00,0x49,0x53,0x00,
+0x19,0x8A,0xF8,0xE4,0x00,0x00,0x37,0x53,0x00,0x19,0x9A,0xE1,0xE4,0x00,0x00,0x25,
+0x53,0x00,0x32,0x8A,0xF8,0xE4,0x00,0x00,0x13,0x53,0x00,0x50,0x8A,0xF8,0xD0,0x69,
+0x0A,0xC5,0x4F,0x43,0x10,0xC3,0x38,0x00,0x21,0xFF,0x39,0xBB,0x20,0x8F,0x3A,0xC3,
+0x40,0x10,0x01,0x0F,0x79,0x02,0xFF,0x5A,0x07,0xE0,0xC3,0x20,0x10,0x01,0xFF,0x39,
+0x0D,0x5A,0x87,0x69,0x4F,0x23,0x30,0x4C,0xA3,0x28,0xC0,0x80,0x10,0x01,0x8C,0xBA,
+0xFC,0x84,0x0A,0x64,0x99,0x02,0x8C,0x99,0xCB,0xA0,0x01,0xF4,0x9B,0x20,0x43,0x65,
+0xCC,0x0B,0x9B,0x00,0x4F,0x79,0x08,0x4F,0x9C,0x40,0x8F,0x64,0x0F,0x5B,0x02,0x5F,
+0x5C,0x1D,0x4B,0xD8,0xB8,0x43,0x9C,0xD5,0x43,0x9E,0xE3,0xCF,0xDA,0x01,0xF4,0x43,
+0x9C,0x40,0x8F,0x9E,0x43,0x9C,0xE8,0x0F,0x9B,0x00,0x9F,0x22,0x5F,0x24,0x09,0x23,
+0xFF,0x3D,0xE4,0x00,0x01,0xC9,0x1F,0x23,0xFE,0x5F,0x39,0x00,0x4C,0xB9,0x28,0x4F,
+0x39,0x30,0xC0,0x80,0x10,0x01,0x8C,0xBA,0xFC,0x84,0x08,0xFC,0x99,0x02,0x8C,0x99,
+0xCB,0xA0,0x01,0xF4,0x9B,0x20,0x43,0x65,0xCC,0x0B,0x9B,0x00,0x4F,0x79,0x08,0x4F,
+0x9C,0x40,0x8F,0x64,0x0F,0x5B,0x02,0x5F,0x5C,0x1D,0x4B,0xD8,0xB8,0x43,0x9C,0xD5,
+0x43,0x9E,0xE3,0xCF,0xDA,0x01,0xF4,0x43,0x9C,0x40,0x8F,0x9E,0x43,0x9C,0xE8,0x0F,
+0x9B,0x00,0x9F,0x22,0x5F,0x24,0x09,0x23,0xFF,0x3D,0xE4,0x00,0x01,0x19,0xC3,0x40,
+0x10,0x01,0x9B,0xC2,0xFF,0x5A,0x0C,0xCC,0xCB,0xA0,0x01,0xF4,0x0F,0x7A,0x02,0x0B,
+0x99,0x00,0x4F,0x9C,0x40,0x5F,0x7C,0x1D,0x43,0x9C,0xDD,0x49,0x18,0xB8,0xCF,0x7B,
+0x01,0xF4,0x43,0x88,0xE3,0x43,0x9C,0xF0,0x8F,0x7C,0x43,0x7B,0xE8,0x0F,0x7A,0x00,
+0x9F,0x22,0xC3,0x60,0x10,0x01,0x9F,0x44,0xFF,0x7B,0x0D,0x60,0xD7,0x3B,0xFE,0x86,
+0xE4,0x00,0x00,0x8D,0xC3,0x40,0x10,0x01,0x9B,0xC2,0xFF,0x5A,0x09,0x7C,0xCB,0xA0,
+0x01,0xF4,0x0F,0x7A,0x02,0x0B,0x99,0x00,0x4F,0x9C,0x40,0x5F,0x7C,0x1D,0x43,0x9C,
+0xDD,0x49,0x18,0xB8,0xCF,0x7B,0x01,0xF4,0x43,0x88,0xE3,0x43,0x9C,0xF0,0x8F,0x7C,
+0x43,0x7B,0xE8,0x0F,0x7A,0x00,0x9F,0x22,0xC3,0x60,0x10,0x01,0x9F,0x44,0xFF,0x7B,
+0x0D,0x60,0xD7,0x3B,0xFE,0x86,0xE7,0xFF,0xF8,0x8F,0x9C,0x38,0x0D,0x21,0x04,0x0D,
+0x41,0x00,0x89,0x43,0x98,0x60,0x88,0x8A,0xE7,0xFF,0xFC,0xBA,0x88,0x8A,0x98,0x61,
+0xE7,0xFF,0xFC,0xAA,0x88,0x8A,0x0D,0x21,0x06,0x0D,0x41,0x02,0x98,0x68,0x9C,0x28,
+0xE7,0xFF,0xFC,0x8B,0x1C,0x21,0xB8,0x0D,0x41,0x40,0x0D,0xA1,0x34,0x0D,0xE1,0x2C,
+0x0E,0x01,0x28,0x0D,0x21,0x44,0xC2,0x00,0x10,0x01,0x0D,0x61,0x3C,0xFE,0x10,0x08,
+0x24,0x0D,0x81,0x38,0x0A,0xF0,0x01,0x0D,0xC1,0x30,0xC7,0x17,0x7F,0xFF,0x0E,0x21,
+0x24,0x0E,0x41,0x20,0x0E,0x61,0x1C,0x0E,0x81,0x18,0x0E,0xA1,0x14,0x0E,0xC1,0x10,
+0x0F,0x10,0x01,0xC1,0xE0,0x10,0x01,0xC1,0xA0,0x10,0x01,0xC1,0x40,0x10,0x01,0x56,
+0xF7,0x08,0xFD,0xEF,0x09,0xB6,0xFD,0xAD,0x0D,0x7C,0xFD,0x4A,0x0C,0x08,0x22,0xE1,
+0x80,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x07,0x5A,0x22,0xE5,0x54,0xC3,0x00,0x10,0x01,
+0x0A,0xEA,0x18,0xFF,0x18,0x01,0x58,0x0B,0x58,0x0E,0xD7,0x57,0x01,0x04,0xCB,0x20,
+0x07,0xFF,0x43,0x59,0xD5,0xD6,0xFA,0x00,0xAC,0x0A,0xEA,0x16,0x0B,0x18,0x0A,0xD7,
+0x17,0x00,0x5C,0x43,0x19,0xC5,0xD6,0xF8,0x01,0x40,0xE7,0xFF,0xE4,0xB4,0x9A,0xE3,
+0x0E,0xED,0x00,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0D,0x78,0xC2,0xE0,0x10,0x01,0x18,
+0x0F,0x00,0xF8,0x17,0x0A,0xF3,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x09,0xC9,0xC2,0xE0,
+0x10,0x01,0xF2,0xF7,0x0D,0x59,0x22,0xE0,0x24,0x98,0x60,0xE7,0xFF,0xC4,0xE6,0x0E,
+0xED,0x02,0x22,0xE0,0x9E,0x0A,0xF0,0x01,0x56,0xF7,0x40,0x22,0xE0,0x60,0xE7,0xFF,
+0x33,0xCA,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0A,0xF3,0x9A,0xE1,0x0E,0xED,0x00,0xE4,
+0x00,0x00,0x15,0x98,0x60,0xE7,0xFF,0xFD,0xCA,0xC2,0x40,0x10,0x01,0x0E,0xED,0x02,
+0xFE,0x52,0x09,0x88,0x22,0xE5,0x56,0x0A,0xF0,0x01,0x57,0x17,0x08,0x23,0x00,0x54,
+0xE7,0xFF,0xE3,0xC8,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0D,0x78,0x9A,0xE2,0xE4,0x00,
+0x00,0xF5,0x57,0x17,0x40,0x23,0x00,0xB4,0xC6,0xF7,0x20,0x00,0x22,0xE0,0x9A,0xC2,
+0xE0,0x10,0x01,0xF3,0x17,0x0A,0xF3,0xC3,0x00,0x19,0x0A,0x20,0x00,0x35,0x98,0x62,
+0xE7,0xFF,0xFD,0x34,0xE4,0x00,0x00,0xAF,0x9F,0x01,0xFB,0x17,0x0A,0xF3,0xE4,0x00,
+0x00,0x9B,0x0C,0x0D,0x00,0xE4,0x00,0x00,0x8D,0x22,0xE9,0x0A,0x0A,0xF0,0x01,0xC1,
+0x60,0x10,0x01,0x56,0xF7,0x08,0x22,0xE0,0xB0,0xF2,0xEB,0x0D,0x78,0x9E,0xE1,0xFA,
+0xEB,0x0D,0x78,0xE7,0xFF,0x32,0xE0,0xF2,0xEB,0x0D,0x78,0x22,0xE0,0x80,0x9A,0xE3,
+0x18,0x12,0x00,0x0E,0xED,0x00,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x0B,0xBD,0xE4,0x00,
+0x00,0x1B,0xF8,0x0B,0x0D,0x78,0x9A,0xE6,0x0E,0xED,0x00,0xC2,0x20,0x10,0x01,0xC1,
+0x80,0x10,0x01,0xC1,0x60,0x10,0x01,0x0E,0xED,0x02,0xFE,0x31,0x0C,0xD8,0xFD,0x8C,
+0x0D,0x4A,0xFD,0x6B,0x0C,0xE4,0xD2,0xE3,0x3E,0x2E,0x12,0xEA,0x00,0x22,0xE4,0x1A,
+0x18,0x12,0x00,0xE7,0xFF,0xCD,0x88,0xC3,0x00,0x10,0x01,0xC2,0xE0,0x10,0x01,0xFF,
+0x20,0x03,0xE8,0x20,0x68,0x1C,0xFF,0x20,0x01,0xF4,0xEF,0x37,0x03,0x3B,0xEF,0x38,
+0x03,0x39,0x0A,0xF0,0x01,0x56,0xF7,0x08,0xD2,0xE0,0x3C,0x5A,0xC2,0x60,0x10,0x01,
+0xC1,0xC0,0x10,0x01,0x13,0x0A,0x00,0xFE,0x73,0x03,0x36,0xFD,0xCE,0x09,0xBA,0xD3,
+0x01,0x11,0x11,0x0A,0xAC,0x04,0x0A,0xEC,0x00,0xC2,0xAF,0xFF,0xE0,0x20,0x06,0x05,
+0x09,0x2A,0x48,0x0B,0x4C,0x06,0x0A,0x8A,0x46,0x43,0x89,0xD5,0x43,0xB4,0xAD,0x0B,
+0x6C,0x02,0x0B,0x0A,0x18,0x08,0xEA,0x16,0x43,0x3B,0xC5,0x43,0xC7,0xBD,0x43,0x3D,
+0xCB,0x41,0x1C,0xF3,0x8F,0x28,0x23,0x21,0x84,0x42,0xD5,0xBD,0x40,0x9B,0xD5,0x40,
+0x7C,0xB3,0x41,0x1D,0x23,0x8C,0x68,0x20,0x60,0x40,0x24,0x60,0x28,0x27,0x20,0x2A,
+0xE4,0x00,0x00,0x8F,0x27,0x3D,0x0E,0x4C,0xB9,0xFA,0x45,0x05,0xCE,0x41,0x08,0x2D,
+0x4C,0xA3,0xFA,0x44,0x65,0x1E,0x40,0xA3,0x2D,0xD4,0xA8,0x01,0x74,0x40,0x78,0xDD,
+0x40,0x9E,0x23,0x42,0xC3,0xB3,0x8E,0xC4,0x22,0xC0,0x40,0x26,0xC0,0x28,0x27,0x20,
+0x2A,0xE4,0x00,0x00,0x2D,0x27,0x3C,0x4A,0x4F,0x36,0xFA,0x46,0xD9,0xB6,0x42,0xD6,
+0xCD,0x9B,0x21,0xD6,0xC8,0x06,0x48,0x41,0x09,0xDD,0x40,0x74,0xBD,0x40,0x87,0xAD,
+0x43,0x3A,0xC5,0x42,0xC8,0x23,0x43,0x23,0xCB,0x8F,0x36,0x23,0x20,0xE8,0x40,0xBA,
+0xDD,0x0C,0xA1,0x0C,0x42,0xB7,0xAD,0x42,0xC3,0x2B,0x40,0xC8,0xAB,0x8C,0xD6,0x20,
+0xC0,0x40,0x24,0xC0,0x28,0x27,0x20,0x2A,0xE4,0x00,0x00,0x3B,0x27,0x3C,0x66,0x4E,
+0xD9,0xFA,0x44,0xB6,0xCE,0x40,0xA5,0xB5,0x4E,0xC6,0xFA,0x44,0xD6,0x36,0x40,0xC6,
+0xB5,0xD4,0xC5,0x01,0xA0,0x43,0x78,0xDD,0x43,0xDE,0xF3,0x43,0x7B,0xDB,0x43,0x58,
+0xD5,0x40,0x84,0x23,0x43,0x5A,0xD3,0x8F,0xDB,0x8C,0x9A,0x9B,0x20,0xD4,0x9E,0x00,
+0x45,0x8B,0xC4,0x9B,0x21,0x40,0x63,0x1B,0x41,0x08,0x43,0x8D,0x03,0xD5,0x1E,0x01,
+0xC9,0xE4,0x00,0x00,0x75,0x42,0xD8,0xD5,0x0C,0xC1,0x0E,0x42,0xB6,0xAB,0x42,0xC4,
+0x33,0x8E,0xB6,0x22,0xA0,0x40,0x26,0xA0,0x28,0x27,0x20,0x2A,0xE7,0xFF,0xFF,0x73,
+0x27,0x3E,0xD6,0x4F,0x35,0xFA,0x46,0xB9,0xAE,0x42,0xB5,0xCD,0x9B,0x20,0xD6,0xA5,
+0x00,0xF0,0xE7,0xFF,0xFF,0x47,0x8B,0xC8,0x53,0x20,0x10,0x43,0xBD,0xEB,0x43,0x9C,
+0xE3,0x53,0x40,0x11,0x8F,0x9D,0x5F,0x9E,0x1F,0x4B,0x39,0xD0,0x4F,0x59,0x21,0x47,
+0x39,0xD6,0x57,0x39,0x0F,0xD3,0x20,0x41,0x32,0x0E,0x8A,0x17,0x0D,0x2A,0x19,0x0C,
+0xEA,0x47,0x0F,0x0A,0x49,0xE4,0x00,0x10,0x2D,0x12,0xF1,0x00,0x9A,0xDE,0x46,0xF7,
+0xB4,0x98,0x63,0x1A,0xF1,0x00,0xE7,0xFF,0xDB,0x92,0xE4,0x00,0x00,0xEB,0xC2,0xEF,
+0xFF,0xE4,0x20,0x01,0xB7,0x13,0x32,0x00,0x09,0x2C,0x02,0x9F,0x21,0x0B,0x6A,0x16,
+0x5F,0x39,0x00,0x41,0x1B,0xBD,0x0B,0x4A,0x18,0x0B,0xAA,0x46,0x43,0xDA,0x4D,0x42,
+0xFD,0xBD,0x0B,0x8A,0x48,0x42,0xF7,0xBB,0x41,0x3C,0x4D,0x1B,0x32,0x00,0x41,0x29,
+0x4B,0x8E,0xE9,0x41,0x08,0x43,0x43,0xDE,0xF3,0x8F,0xC8,0x5E,0xFE,0x1F,0x52,0xE0,
+0x10,0x4A,0xE0,0xB8,0x22,0xE0,0x3C,0x0F,0xAA,0x17,0x0F,0x8A,0x19,0x0F,0x6A,0x47,
+0x0F,0x4A,0x49,0xD3,0x24,0x01,0xBD,0x9F,0x1F,0x12,0xF1,0x00,0x1B,0x0A,0x00,0x9B,
+0x1C,0x46,0xF7,0xC4,0x1A,0xF1,0x00,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x09,0xB2,0x12,
+0xF3,0x00,0x1A,0xEA,0x10,0x12,0xF3,0x01,0x1A,0xEA,0x40,0xE7,0xFF,0x2D,0xB0,0x12,
+0xEA,0x00,0xD2,0xE1,0x3F,0x2E,0xE4,0x00,0x01,0xD7,0x18,0x12,0x00,0xE7,0xFF,0xFF,
+0xC5,0x23,0x07,0x7A,0x18,0x12,0x00,0x0A,0xEC,0x04,0xC2,0xEF,0xFF,0xE0,0x23,0xFF,
+0x45,0x0B,0xCA,0x16,0x0B,0xAA,0x18,0x0B,0x0C,0x00,0x0B,0x2C,0x02,0x43,0x9E,0xC5,
+0x43,0x7D,0xCD,0x43,0xDE,0xBD,0x0B,0x4C,0x06,0x43,0xDE,0xF3,0x43,0xBD,0xD5,0x43,
+0x9C,0xE3,0x43,0xBD,0xEB,0x43,0x7B,0xDB,0x8F,0xBE,0x8F,0x7C,0xD7,0xBB,0x3B,0x01,
+0xE4,0x00,0x0E,0x6D,0x0B,0x8B,0x03,0x43,0x99,0xE5,0x5F,0x9C,0x06,0x4F,0x7C,0xFA,
+0x47,0x9B,0xE6,0x43,0x7C,0xDD,0x5F,0x6D,0xD1,0x20,0x00,0xC1,0xC3,0x60,0x10,0x01,
+0x0B,0xAB,0x03,0xFF,0x9B,0x0A,0x5A,0xEF,0xBB,0x0A,0x5B,0x0B,0x6B,0x07,0x0F,0x7C,
+0x03,0xC3,0x60,0x10,0x01,0xFF,0x9B,0x0C,0xDC,0xEF,0x1B,0x0C,0xDD,0x0F,0x3C,0x03,
+0x13,0x11,0x00,0x53,0x18,0x02,0x1B,0x11,0x00,0x0B,0x0E,0x05,0x0F,0x0E,0x01,0x0B,
+0x0E,0x07,0x0F,0x0E,0x03,0x0B,0x0B,0x09,0x0F,0x0B,0x01,0x0B,0x0B,0x0B,0x0F,0x0B,
+0x03,0x0B,0x0B,0x0D,0x0E,0xEC,0x01,0x0F,0x0B,0x05,0xFE,0xE0,0x7F,0xFF,0x0B,0x0B,
+0x0F,0x0E,0xEC,0x05,0x0E,0xEC,0x07,0x0E,0xEE,0x05,0x0E,0xEE,0x07,0x0E,0xEB,0x09,
+0x0E,0xEB,0x0B,0x0F,0x0B,0x07,0x0E,0xEB,0x0D,0x0E,0xEB,0x0F,0x9B,0x01,0x12,0xF3,
+0x01,0x0F,0x4C,0x03,0x1A,0xF3,0x00,0x42,0xF8,0xBD,0x1A,0xF3,0x01,0xE7,0xFF,0xFE,
+0x05,0x0A,0xEA,0x17,0x0B,0x0C,0x01,0x43,0x18,0xBD,0x5F,0x18,0x06,0x4E,0xF8,0xFA,
+0x47,0x17,0xC6,0x42,0xF8,0xBD,0xC3,0x00,0x10,0x01,0xEB,0x38,0x03,0x38,0xD6,0xF9,
+0x01,0x2C,0x0A,0xEA,0x19,0x0B,0x0C,0x03,0x43,0x18,0xBD,0x5F,0x18,0x06,0x4E,0xF8,
+0xFA,0x47,0x17,0xC6,0x42,0xF8,0xBD,0xC3,0x00,0x10,0x01,0xEB,0x38,0x03,0x3A,0xD6,
+0xF9,0x35,0xC0,0xE7,0xFF,0x2C,0x08,0xD0,0x60,0x35,0x82,0xE7,0xFF,0xDB,0x52,0xC2,
+0xE0,0x10,0x01,0xEF,0x17,0x07,0x5A,0xD3,0x01,0x35,0x06,0xE4,0x00,0x0C,0xFB,0x9B,
+0x1E,0xEF,0x17,0x0B,0xBD,0x1E,0x6A,0x16,0x13,0x4A,0x00,0x8B,0x0C,0x8A,0xF3,0x9B,
+0x20,0xE4,0x00,0x00,0x35,0x0B,0x77,0x01,0x9F,0x21,0x0F,0x78,0x01,0x5F,0x39,0x00,
+0x0B,0x77,0x03,0x1E,0xF7,0x30,0x0F,0x78,0x03,0x9F,0x04,0xD7,0x3A,0xFF,0x56,0xC2,
+0xE0,0x10,0x01,0xEE,0xF7,0x09,0xC6,0x22,0xE4,0x26,0x9A,0x80,0xE4,0x00,0x00,0x5F,
+0xE7,0xFF,0xC5,0xCE,0x20,0x6B,0xD8,0xE7,0xFF,0xC5,0xC0,0x20,0x6C,0xAE,0xE7,0xFF,
+0xFF,0xD9,0xCC,0x94,0x00,0x30,0x88,0xD4,0x1C,0x84,0x10,0x9E,0x81,0x8C,0x8A,0x5E,
+0x94,0x00,0x1C,0x64,0x06,0x9C,0x88,0xE7,0xFF,0x58,0x98,0x10,0xAA,0x00,0xD4,0xB4,
+0xFF,0x25,0xE4,0x00,0x00,0x11,0xE7,0xFF,0x57,0xEA,0xE7,0xFF,0xC5,0x5A,0xC3,0x20,
+0x10,0x01,0xC3,0x00,0x10,0x01,0xC2,0xE0,0x10,0x01,0x20,0x68,0xB6,0x53,0x40,0x5A,
+0xEF,0x58,0x0D,0x53,0xEF,0x59,0x08,0x21,0x53,0x00,0x3C,0xEF,0x17,0x0D,0x73,0xC3,
+0x60,0x10,0x01,0xC2,0xE0,0x10,0x01,0xFE,0xDB,0x09,0xB4,0xEF,0x17,0x08,0x23,0x9A,
+0xA0,0x8A,0x96,0xE4,0x00,0x03,0x4F,0x53,0x40,0x3C,0xEF,0x58,0x0D,0x53,0xEF,0x59,
+0x08,0x21,0x53,0x00,0x28,0xE7,0xFF,0xFF,0xAD,0x4F,0x15,0x10,0x8F,0x0E,0x0B,0x38,
+0x00,0xC3,0x2F,0xFF,0xE4,0x20,0x05,0xA3,0x0B,0xB8,0x02,0xC3,0xAF,0xFF,0xE0,0x20,
+0x05,0x79,0xCF,0x15,0x00,0x30,0x8F,0x0A,0x0B,0x58,0x17,0x43,0x39,0xD5,0x5F,0x39,
+0x06,0x4F,0x59,0xFA,0x47,0x3A,0xCE,0x43,0x39,0xD5,0x0B,0x58,0x19,0x43,0x5D,0xD5,
+0x5F,0x5A,0x06,0x4F,0x1A,0xFA,0xC0,0xA0,0x10,0x01,0x47,0x58,0xD6,0x43,0x96,0xAC,
+0x43,0x5A,0xC5,0x5F,0x39,0x06,0x5F,0x5A,0x06,0xEB,0x05,0x0D,0x53,0x13,0xDC,0x00,
+0xD7,0x58,0x00,0xE4,0xC3,0x80,0x10,0x01,0xEB,0x9C,0x08,0x21,0xD7,0x3C,0x00,0x84,
+0x9B,0x83,0x27,0xC8,0x57,0x1F,0x9E,0x01,0xE4,0x00,0x00,0x19,0x9B,0x80,0x23,0xC0,
+0x24,0x1F,0x9E,0xFF,0x5F,0x9C,0x00,0x43,0xD4,0xAC,0x1B,0x9E,0x00,0x43,0x96,0xAC,
+0x13,0x9C,0x00,0xD3,0x82,0x07,0x51,0xC0,0xC0,0x10,0x01,0xEB,0x86,0x08,0x23,0xD7,
+0x5C,0x00,0x8C,0xCF,0x15,0x00,0x30,0x8F,0x0A,0x0F,0xB8,0x19,0xE4,0x00,0x00,0xB3,
+0xD7,0x58,0x02,0xAC,0x43,0xB8,0xE5,0x40,0x7A,0xE5,0x43,0xBD,0xEB,0x43,0x5C,0xD5,
+0x43,0xD8,0xC3,0x40,0x63,0xD3,0x0F,0x01,0x04,0x8C,0x7D,0x0F,0x21,0x08,0x40,0x63,
+0xF3,0x40,0x63,0xE8,0xE7,0xFF,0x27,0x70,0x4F,0x55,0x10,0x8F,0x4E,0x5C,0x63,0x06,
+0x0F,0x01,0x06,0x0B,0x9A,0x02,0x43,0x18,0x1D,0xCF,0x55,0x00,0x30,0x0F,0x21,0x0A,
+0x8F,0x4A,0x0B,0xBA,0x18,0xD7,0x9D,0x00,0x58,0x43,0x1C,0xC5,0xE4,0x00,0x00,0x0D,
+0x8F,0x1C,0x0F,0x1A,0x19,0xC3,0x00,0x10,0x01,0xEB,0x58,0x0D,0x73,0xD7,0x3A,0x00,
+0xCC,0xCF,0x15,0x00,0x30,0x4F,0x35,0x10,0x8F,0x0A,0x8F,0x2E,0x0B,0x39,0x01,0x0F,
+0x38,0x17,0xE4,0x00,0x00,0xB7,0xC3,0x00,0x10,0x01,0xEB,0x18,0x08,0x21,0xD7,0x38,
+0x02,0x7C,0x43,0x98,0xD5,0x40,0x79,0xD5,0x43,0x9C,0xE3,0x43,0x3A,0xCD,0x43,0xB8,
+0xC3,0x40,0x63,0xCB,0x0F,0x01,0x04,0x8C,0x7C,0x40,0x63,0xEB,0x40,0x63,0xE0,0xE7,
+0xFF,0x26,0x7A,0x4F,0x35,0x10,0x8F,0x2E,0x5C,0x63,0x06,0x0F,0x01,0x06,0x0B,0x59,
+0x00,0x43,0x18,0x1D,0xCF,0x35,0x00,0x30,0x8F,0x2A,0x0B,0x99,0x16,0xD7,0x5C,0x00,
+0x58,0x43,0x1A,0xC5,0xE4,0x00,0x00,0x0D,0x8F,0x1A,0x0F,0x19,0x17,0x4F,0x15,0x10,
+0xCF,0x35,0x00,0x30,0x8F,0x0E,0x8F,0x2A,0x1E,0xF5,0x01,0x0B,0x59,0x17,0x5E,0xB7,
+0x00,0x0B,0x39,0x19,0x0F,0x58,0x01,0x0F,0x38,0x03,0x13,0x0A,0x00,0xD7,0x15,0xF3,
+0x65,0xE7,0xFF,0xC1,0x8C,0x20,0x68,0x36,0x9B,0x08,0xC2,0xE0,0x10,0x01,0xEF,0x17,
+0x03,0x29,0x13,0x2A,0x00,0x1E,0xEB,0x04,0x8B,0x13,0x9B,0x40,0xD7,0x59,0x02,0x0A,
+0x0B,0x77,0x00,0xC3,0x6F,0xFF,0xE0,0x20,0x00,0x41,0x0B,0x77,0xFD,0x0F,0x77,0x01,
+0x0B,0x77,0xFF,0xE4,0x00,0x00,0x1B,0x0B,0x78,0x01,0x0F,0x77,0x01,0x0B,0x78,0x03,
+0x0F,0x77,0x03,0x0B,0x78,0x01,0x9F,0x41,0x0F,0x77,0xFD,0x5F,0x5A,0x00,0x0B,0x78,
+0x03,0x1F,0x18,0x30,0x0F,0x77,0xFF,0x9E,0xE8,0xE7,0xFF,0xFF,0x87,0xC2,0xE0,0x10,
+0x01,0x23,0x24,0x82,0x9B,0x02,0xFB,0x17,0x0A,0x5E,0xC2,0xE0,0x10,0x01,0xEA,0xF7,
+0x03,0x28,0x9B,0x4A,0x9B,0x00,0x43,0x5A,0xBD,0x9B,0x6A,0x8A,0xEB,0xE4,0x00,0x00,
+0x8F,0xF8,0x17,0x0A,0x5E,0xE7,0xFF,0xFF,0xCB,0x0B,0x97,0x04,0x0B,0xB7,0x00,0x0B,
+0xD7,0x06,0x43,0xBD,0xE5,0x9F,0x01,0x43,0xBA,0xEB,0x5F,0x18,0x00,0x43,0xBD,0xD8,
+0x8F,0xBC,0x0B,0x97,0x02,0x0F,0xB3,0x01,0x43,0x9C,0xF5,0x0F,0xB7,0x01,0x43,0x9A,
+0xE3,0x43,0x9C,0xD8,0x8F,0x9E,0x5F,0x9C,0x06,0x0F,0x93,0x03,0x0F,0x97,0x03,0x1E,
+0x73,0x30,0x9E,0xE8,0xD7,0x19,0xFE,0x2E,0x12,0xF1,0x00,0x56,0xF7,0x02,0x22,0xE0,
+0x24,0x98,0x64,0xE7,0xFF,0xD1,0x78,0x12,0xEA,0x00,0xD2,0xE1,0x05,0xCE,0xC3,0x40,
+0x10,0x01,0xC2,0xE0,0x10,0x01,0xF3,0x3A,0x03,0x3D,0xFF,0x17,0x09,0xA4,0xC3,0x20,
+0x1F,0xE4,0x20,0x00,0x61,0x0B,0x2A,0x17,0xF8,0x1A,0x03,0x3D,0xEF,0x37,0x09,0xA5,
+0x0A,0xEA,0x19,0x0E,0xF8,0x03,0xE4,0x00,0x01,0x31,0x23,0x25,0xE2,0x0B,0x4A,0x16,
+0xEB,0x37,0x09,0xA4,0x43,0x7A,0xCD,0x1F,0x7B,0x1D,0x5F,0x67,0x5B,0x20,0x01,0x29,
+0x0B,0x8A,0x18,0x0B,0xB8,0x02,0x43,0x7C,0xED,0x1F,0x7B,0x27,0x5F,0x69,0xDB,0x20,
+0x00,0xE1,0x9B,0x63,0x4F,0x39,0x08,0x8F,0x3A,0x43,0x39,0xD8,0x5F,0x39,0x06,0xEF,
+0x37,0x09,0xA5,0x0F,0x2A,0x17,0x4E,0xFD,0x08,0x0F,0x2E,0x01,0x8E,0xFC,0x0F,0x2B,
+0x01,0x42,0xF7,0xD8,0x5E,0xF7,0x06,0x0E,0xF8,0x03,0x0E,0xEA,0x19,0x0E,0xEE,0x03,
+0x0E,0xEB,0x03,0xE4,0x00,0x00,0x67,0xC2,0xE0,0x10,0x01,0xFF,0x17,0x09,0xA4,0xEF,
+0x57,0x09,0xA5,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x0C,0x21,0x0E,0xF8,0x03,0xE4,0x00,
+0x00,0x31,0x0B,0x2A,0x17,0xEF,0x37,0x09,0xA5,0x0A,0xEA,0x19,0x0E,0xF8,0x03,0xE4,
+0x00,0x00,0x1F,0x22,0xE8,0x2E,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x03,0x3D,0x13,0x0A,
+0x00,0xC2,0xE0,0x10,0x01,0x98,0x61,0xFB,0x17,0x09,0xB3,0xE7,0xFF,0xB3,0xA6,0xE4,
+0x00,0x00,0x19,0x18,0x0F,0x00,0x9A,0xE4,0x0E,0xED,0x00,0x0E,0xED,0x02,0xD2,0xE4,
+0x01,0xBE,0x0A,0xF0,0x01,0x56,0xF7,0x08,0x22,0xE0,0x5C,0x9A,0xE3,0x18,0x12,0x00,
+0x0E,0xED,0x00,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x0B,0xBD,0xE4,0x00,0x00,0x35,0x12,
+0xEF,0x00,0x9E,0xE1,0x5E,0xF7,0x00,0x1A,0xEF,0x00,0x22,0xE0,0x2C,0x9A,0xE5,0x18,
+0x0F,0x00,0x0E,0xED,0x00,0x0E,0xED,0x02,0xD2,0xE5,0x0A,0x0E,0x12,0xEF,0x00,0x9E,
+0xE1,0x1A,0xEF,0x00,0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x09,0xB3,0x22,0xE9,0x36,0x12,
+0xF1,0x00,0x56,0xF7,0x01,0x22,0xE1,0x10,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0A,0x5E,
+0xC1,0x40,0x10,0x01,0xF2,0xEA,0x09,0xB2,0x22,0xE8,0x66,0x98,0x65,0xE7,0xFF,0xCE,
+0xC4,0x98,0x61,0xE7,0xFF,0xB2,0x96,0x9A,0xE1,0xFA,0xEA,0x09,0xB2,0xE4,0x00,0x01,
+0x5D,0xD2,0xE1,0x05,0x2E,0x98,0x65,0xE7,0xFF,0xCE,0x90,0x98,0x61,0xE7,0xFF,0xB2,
+0x62,0xF8,0x0A,0x09,0xB2,0xE4,0x00,0x01,0x2D,0x0B,0x2C,0x00,0x0B,0x4B,0x00,0x43,
+0x19,0xD5,0x5F,0x18,0x06,0x4E,0xF8,0xFA,0x47,0x17,0xC6,0x42,0xF8,0xBD,0x5E,0xEC,
+0x99,0x20,0x00,0x79,0x0A,0xEB,0x03,0x0B,0x0C,0x03,0x43,0x18,0xBD,0x5F,0x18,0x06,
+0x4E,0xF8,0xFA,0x47,0x17,0xC6,0x42,0xF8,0xBD,0x5E,0xED,0xD1,0x20,0x01,0x69,0xC3,
+0x00,0x10,0x01,0xF2,0xF8,0x0A,0x5E,0x22,0xE8,0xB6,0x8F,0x3A,0x43,0x39,0xB8,0x0F,
+0x2A,0x17,0xC3,0x20,0x10,0x01,0xEB,0x59,0x0D,0x4C,0xC3,0x20,0x10,0x01,0xEB,0x39,
+0x0C,0xE6,0x8F,0x3A,0x42,0xF9,0xB8,0x0E,0xEA,0x19,0x9A,0xE1,0xFA,0xF8,0x0A,0x5E,
+0xE4,0x00,0x00,0x33,0x22,0xE4,0x8A,0x0F,0x2A,0x17,0xF8,0x18,0x0A,0x5E,0xC3,0x20,
+0x10,0x01,0xEB,0x39,0x0D,0x4D,0x0F,0x2A,0x19,0x1A,0xEA,0x00,0x98,0x61,0xE7,0xFF,
+0xB1,0x40,0xE4,0x00,0x00,0x13,0x9A,0xE3,0x1A,0xEF,0x00,0x12,0xEF,0x00,0xD2,0xE2,
+0x0B,0x11,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x0B,0xBD,0xE7,0xFF,0x20,0x12,0x9B,0x03,
+0xC2,0xE0,0x10,0x01,0xFB,0x17,0x0D,0x59,0xE7,0xFF,0xD0,0x58,0xE7,0xFF,0x4D,0xFE,
+0xC2,0xE0,0x10,0x01,0xF3,0x17,0x03,0x3D,0xC3,0x00,0x1F,0xE0,0x20,0x00,0x25,0x9B,
+0x01,0xFB,0x17,0x03,0x3D,0x98,0x60,0xE7,0xFF,0xB0,0xAE,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x09,0xC9,0x9A,0xE6,0xE4,0x00,0x01,0x1F,0xD2,0xE6,0x08,0xBE,0x0A,0xF0,0x01,
+0x56,0xF7,0x40,0x22,0xE0,0x26,0x98,0x64,0xE7,0xFF,0xE9,0xA4,0xC3,0x00,0x10,0x01,
+0xF2,0xF8,0x09,0xC9,0x9E,0xE1,0x5E,0xF7,0x00,0xFA,0xF8,0x09,0xC9,0x5E,0xE6,0x53,
+0x0A,0xF0,0x01,0x20,0x01,0x41,0x56,0xF7,0x40,0x22,0xE0,0x50,0x9A,0xE1,0x0E,0xED,
+0x00,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0A,0xF3,0xE4,0x00,0x01,0xAF,0x0C,0x0D,0x00,
+0x0E,0xC1,0x12,0x0E,0xA1,0x16,0x0E,0x81,0x1A,0x0E,0x61,0x1E,0x0E,0x41,0x22,0x0E,
+0x21,0x26,0x0E,0x01,0x2A,0x0D,0xE1,0x2E,0x0D,0xC1,0x32,0x0D,0xA1,0x36,0x0D,0x81,
+0x3A,0x0D,0x61,0x3E,0x0D,0x41,0x42,0x0D,0x21,0x46,0x98,0x60,0x1C,0x21,0x48,0xE7,
+0xFF,0xE8,0xD7,0x56,0xF7,0x08,0xD2,0xE0,0x04,0xD2,0xC2,0xE0,0x10,0x01,0xF8,0x17,
+0x0D,0x78,0x9A,0xE2,0x0E,0xED,0x00,0xE4,0x00,0x01,0x13,0xC2,0xEF,0xFF,0xE4,0x23,
+0xDF,0xA9,0xE7,0xFF,0xF0,0xDB,0x98,0x62,0xE7,0xFF,0xCB,0x6E,0xFE,0xE0,0x7F,0xFF,
+0x0E,0xEC,0x05,0x0E,0xEC,0x07,0x0E,0xEE,0x05,0x0E,0xEE,0x07,0x0E,0xEB,0x09,0x0E,
+0xEB,0x0B,0x0E,0xEB,0x0D,0x0E,0xEB,0x0F,0xE7,0xFF,0xF0,0x8F,0x0B,0x8B,0x01,0x43,
+0x98,0xE5,0x5F,0x9C,0x06,0x4F,0x7C,0xFA,0x47,0x9B,0xE6,0x43,0x7C,0xDD,0x5F,0x6C,
+0x99,0x23,0xE2,0x4F,0xE7,0xFF,0xF1,0x51,0xFE,0xE0,0x7F,0xFF,0x18,0x0F,0x00,0x0E,
+0xEC,0x01,0x0E,0xEC,0x03,0x0E,0xEC,0x05,0x0E,0xEC,0x07,0x18,0x13,0x00,0x1B,0x13,
+0x01,0x9A,0xE5,0xE7,0xFF,0xFB,0x0B,0xC2,0xE0,0x10,0x01,0xCA,0xC0,0xFF,0xFD,0xEB,
+0x17,0x0B,0xBD,0x9F,0x01,0x5F,0x18,0x04,0xD7,0x16,0xCA,0xBD,0xE7,0xFF,0xF2,0xAB,
+0x0E,0xC1,0x12,0x0E,0xA1,0x16,0x0E,0x81,0x1A,0x0E,0x61,0x1E,0x0E,0x41,0x22,0x0E,
+0x21,0x26,0x0E,0x01,0x2A,0x0D,0xE1,0x2E,0x0D,0xC1,0x32,0x0D,0xA1,0x36,0x0D,0x81,
+0x3A,0x0D,0x61,0x3E,0x0D,0x41,0x42,0x0D,0x21,0x46,0x1C,0x21,0x48,0x85,0x29,0x9C,
+0x38,0x0D,0x21,0x04,0x0D,0x41,0x00,0x89,0x43,0x98,0x60,0x88,0x8A,0xE7,0xFF,0xE3,
+0xF0,0x88,0x8A,0x98,0x61,0xE7,0xFF,0xE3,0xE0,0x88,0x8A,0x0D,0x21,0x06,0x0D,0x41,
+0x02,0x98,0x68,0x9C,0x28,0xE7,0xFF,0xE3,0xC1,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x3D,
+0xF9,0x1C,0x21,0xC0,0x0D,0x21,0x3C,0x0D,0x41,0x38,0x0D,0x61,0x34,0x0D,0x81,0x30,
+0x0D,0xA1,0x2C,0x0D,0xC1,0x28,0x0D,0xE1,0x24,0x0E,0x01,0x20,0x0E,0x21,0x1C,0x0E,
+0x41,0x18,0x0E,0x61,0x14,0x13,0x17,0x00,0xC2,0xE0,0x10,0x01,0xFB,0x17,0x00,0xB0,
+0xF3,0x17,0x00,0xB0,0x23,0x00,0x2C,0xF2,0xF7,0x00,0xB0,0xD2,0xE1,0x29,0x4E,0xC1,
+0x80,0x10,0x01,0xFD,0x8C,0x08,0x24,0x0A,0xEC,0x01,0x56,0xF7,0x80,0xD2,0xE0,0x27,
+0x76,0xC1,0xE0,0x10,0x01,0x9B,0x00,0xFD,0xEF,0x0D,0x04,0x89,0xAF,0x8A,0xEF,0x0B,
+0x37,0x00,0x5F,0x2E,0x51,0x20,0x00,0x21,0x9F,0x01,0x5F,0x18,0x00,0xC3,0x20,0x10,
+0x01,0x9E,0xE2,0xFF,0x39,0x0D,0x44,0xD6,0xF9,0xFF,0x46,0x5F,0x02,0xB3,0xC2,0xE0,
+0x10,0x01,0x20,0x00,0x25,0x9B,0x0A,0xFB,0x17,0x0C,0xF4,0xF2,0xF7,0x0C,0xF4,0x22,
+0xE0,0x44,0x9E,0xFF,0xC3,0x00,0x10,0x01,0xFA,0xF8,0x0C,0xF4,0xE4,0x00,0x09,0x91,
+0xC1,0x40,0x10,0x01,0xC1,0xC0,0x10,0x01,0xFD,0x4A,0x01,0x58,0xFD,0xCE,0x03,0x30,
+0x88,0x6A,0x88,0x8E,0xE7,0xFF,0x31,0xFC,0xC1,0x60,0x10,0x01,0x8A,0xED,0xFD,0x6B,
+0x0C,0x08,0x53,0x20,0x14,0x12,0x2B,0x00,0x0B,0x17,0x00,0xCF,0x18,0x00,0x19,0x43,
+0x18,0xC8,0x0F,0x17,0x01,0xC3,0x00,0x10,0x01,0x9E,0xE2,0xFF,0x18,0x0D,0x44,0xD6,
+0xF8,0xFF,0x4E,0x88,0x6A,0x88,0x8E,0xE7,0xFF,0x31,0x96,0xC2,0x00,0x10,0x01,0x9B,
+0x00,0xFE,0x10,0x09,0xB3,0x22,0x20,0x4A,0x12,0xEB,0x00,0x26,0xE4,0x33,0x12,0xF0,
+0x00,0x5E,0xE0,0x01,0x4B,0x01,0x01,0x12,0xEB,0x00,0x22,0xE9,0x3E,0x12,0xF0,0x00,
+0x22,0xE5,0x4A,0x13,0x2B,0x07,0x12,0xEB,0x37,0xD7,0x37,0x02,0x4A,0x0E,0xEB,0x0A,
+0x22,0xE5,0x0A,0x0E,0xEB,0x3A,0x22,0xE4,0xF2,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x0D,
+0x7E,0x22,0xEC,0xC6,0x0A,0xEB,0x16,0xFF,0x37,0xFC,0x01,0xC2,0xE0,0x7F,0xCC,0x20,
+0x00,0x29,0xCB,0x20,0x03,0xFF,0x43,0x39,0xBD,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x0A,
+0xEF,0xD7,0x37,0x00,0xA4,0xE4,0x00,0x00,0x1B,0x22,0xE4,0x26,0x12,0xF0,0x00,0x22,
+0xE0,0x18,0x23,0x00,0xA4,0x53,0x00,0x19,0x0A,0xED,0x00,0xCE,0xF7,0x00,0x14,0x42,
+0xF7,0xC0,0x0E,0xED,0x01,0xC3,0x20,0x10,0x01,0x9D,0xA2,0xFF,0x39,0x0D,0x44,0xD5,
+0xB9,0xFF,0x4E,0x88,0x6A,0x88,0x8E,0xE7,0xFF,0x30,0x56,0x12,0xEB,0x00,0x22,0xE0,
+0x5A,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x09,0xC4,0x13,0x2B,0x00,0xD3,0x20,0x09,0xE6,
+0xE4,0x00,0x02,0xAB,0x98,0x61,0x98,0x81,0x88,0xAA,0xE7,0xFF,0x22,0x26,0x9A,0xE4,
+0x88,0xCE,0x1A,0xE1,0x00,0x98,0x61,0x98,0x81,0x88,0xAA,0x98,0xE0,0x51,0x00,0x14,
+0xE7,0xFF,0x34,0x6A,0x0A,0xEA,0x14,0x0B,0x0A,0x0A,0x0B,0x2A,0x16,0x5D,0xB7,0x04,
+0x41,0xD8,0xBD,0x40,0x98,0xCD,0xCA,0xE0,0x07,0xFF,0x43,0x37,0xCD,0x0B,0x4A,0x06,
+0x0B,0x6A,0x0C,0x40,0x77,0xC5,0x5C,0xD9,0x04,0x13,0xCB,0x00,0x0B,0x2A,0x0E,0x42,
+0x38,0xD5,0x42,0x57,0xCD,0x40,0xBA,0xC5,0x40,0xF9,0xDD,0x42,0x7B,0xCD,0x1E,0xEB,
+0x18,0x9B,0xA0,0xC9,0x00,0x07,0xFF,0xE4,0x00,0x00,0xC5,0x0B,0x97,0xFE,0xD7,0x1C,
+0x00,0x98,0x43,0x9C,0xD5,0x43,0x9C,0x73,0x43,0x9C,0x88,0x8F,0x8D,0xE4,0x00,0x00,
+0x2D,0xD7,0x83,0x00,0xA8,0x43,0x88,0xE5,0x43,0x9C,0xD5,0x43,0x9C,0x23,0x43,0x9C,
+0x28,0x8F,0x86,0x0F,0x97,0xFF,0x0B,0x97,0x00,0xD7,0x3C,0x00,0x88,0x43,0x9C,0xDD,
+0x43,0x9C,0xCB,0x43,0x9C,0x38,0xE4,0x00,0x00,0x31,0xD7,0x92,0x00,0xB8,0x43,0x88,
+0xE5,0x43,0x9C,0xDD,0x43,0x9C,0xCB,0x43,0x9C,0x98,0xFF,0x9C,0x07,0xFF,0x0F,0x97,
+0x01,0x9F,0xA1,0x1E,0xF7,0x30,0x5F,0xBD,0x00,0xD7,0xBE,0xFD,0x16,0x0B,0x0A,0x16,
+0xCA,0xE0,0x07,0xFF,0x0B,0x2A,0x14,0x0B,0x4A,0x10,0x43,0x77,0xCD,0x42,0xF7,0xD5,
+0x43,0x7B,0xC5,0x0B,0x0A,0x12,0x43,0x97,0xC5,0x1E,0xEB,0x16,0x9B,0x00,0xE4,0x00,
+0x00,0x59,0x0B,0xB7,0x00,0x43,0xBD,0xCD,0xCF,0xBD,0x07,0xFF,0x43,0xBD,0xD8,0x9F,
+0x01,0x0F,0xB7,0x01,0x5F,0x18,0x00,0x0B,0xB7,0x02,0x43,0xBD,0xD5,0xCF,0xBD,0x07,
+0xFF,0x43,0xBD,0xE0,0x0F,0xB7,0x03,0x1E,0xF7,0x30,0xD7,0x1E,0xFE,0xC6,0xE7,0xFF,
+0xFD,0xA7,0xCF,0x57,0x00,0x30,0x9E,0xE1,0x8F,0x4B,0x0F,0x5A,0x0E,0xC3,0x40,0x95,
+0xEC,0x4B,0x18,0x0A,0xE4,0x00,0x00,0x11,0x9A,0xE0,0x8B,0x17,0x5F,0x57,0x00,0xD7,
+0x3A,0xFF,0x1D,0xC2,0xE0,0x10,0x01,0xEF,0x17,0x09,0xC4,0x0A,0xEC,0x01,0x52,0xF7,
+0x08,0xE4,0x00,0x00,0x33,0x9B,0x07,0xC2,0xE0,0x10,0x01,0x18,0x10,0x00,0xEF,0x17,
+0x03,0x29,0x0A,0xEC,0x01,0x9B,0x17,0x46,0xF7,0xC4,0x0E,0xEC,0x01,0xC1,0xA0,0x10,
+0x01,0xC2,0xE0,0x10,0x01,0xFD,0x4D,0x0D,0x60,0xEF,0x17,0x00,0xD2,0xD3,0x01,0x0A,
+0x86,0xE7,0xFF,0xE0,0xE6,0xC2,0xE0,0x10,0x01,0x99,0x60,0xEE,0xF7,0x07,0x5A,0x22,
+0xE5,0x6A,0xE4,0x00,0x02,0x2F,0x1C,0x61,0x09,0x88,0x8E,0x98,0xA3,0xE7,0xFF,0x73,
+0x1A,0x1E,0xE1,0x10,0x8E,0xEB,0x12,0xF7,0xF9,0x1F,0x17,0x20,0x4E,0xF7,0x08,0x4F,
+0x18,0x08,0x8E,0xF0,0x8F,0x0F,0x0A,0xF7,0x01,0x0B,0x18,0x00,0xD7,0x17,0x00,0x98,
+0x9A,0xE1,0x0B,0x0A,0x01,0x4E,0xF7,0x5C,0x46,0xF7,0xC5,0xE4,0x00,0x00,0x25,0x9A,
+0xE1,0x0B,0x0A,0x01,0x4E,0xF7,0x5C,0x46,0xF7,0xBF,0x46,0xF7,0xC4,0x9D,0x61,0x0E,
+0xEA,0x01,0x5D,0x6B,0x00,0xE4,0x00,0x00,0x31,0xC1,0xD8,0x00,0x21,0xC2,0x00,0x10,
+0x01,0xC1,0xA0,0x10,0x01,0xFD,0xCE,0xB4,0xBA,0xFE,0x10,0x03,0x2A,0xF2,0xED,0x0A,
+0x61,0xD6,0xEB,0xFC,0xAD,0x0A,0xEA,0x01,0x22,0xE0,0x34,0x0A,0xEC,0x01,0x52,0xF7,
+0x10,0xE4,0x00,0x00,0x3B,0x0A,0xEC,0x01,0x57,0x17,0x10,0x23,0x00,0x34,0x9B,0x21,
+0xC3,0x00,0x10,0x01,0xFB,0x38,0x0D,0x59,0x1F,0x20,0xEF,0x46,0xF7,0xCC,0x0E,0xEC,
+0x01,0xC1,0x40,0x10,0x01,0xC2,0xE0,0x10,0x01,0xFD,0x4A,0x09,0x9C,0xFE,0xF7,0x0A,
+0x58,0x0F,0x0A,0x02,0x23,0x00,0x52,0x18,0x17,0x00,0x0B,0x0C,0x01,0x57,0x18,0x10,
+0x23,0x00,0x20,0x9B,0x01,0x0F,0x0A,0x00,0x0F,0x0A,0x02,0x23,0x04,0x82,0x13,0x17,
+0x00,0x9F,0x01,0x5F,0x18,0x00,0x1B,0x17,0x00,0x0A,0xEC,0x01,0x56,0xF7,0x10,0x22,
+0xE0,0xDC,0x9A,0xE2,0x23,0x00,0x8A,0xE4,0x00,0x00,0x65,0x23,0x08,0x8A,0x18,0x17,
+0x00,0x0A,0xEC,0x01,0x56,0xF7,0x10,0x22,0xE0,0x34,0x98,0x62,0xE7,0xFF,0xA5,0x44,
+0xE4,0x00,0x00,0x33,0x9A,0xE3,0x0E,0xEA,0x00,0xE4,0x00,0x00,0x21,0x23,0x0C,0x32,
+0x98,0x60,0xE7,0xFF,0xA5,0x18,0x0C,0x0A,0x00,0x0B,0x0C,0x00,0xC2,0xE0,0x10,0x01,
+0x27,0x1C,0x56,0xF3,0x17,0x0A,0x60,0xD3,0x09,0x08,0x4D,0x9F,0x01,0xFB,0x17,0x0A,
+0x60,0xE4,0x00,0x01,0xFF,0xF8,0x17,0x0A,0x60,0xE4,0x00,0x01,0xF7,0xEE,0xF7,0x00,
+0xD2,0xD2,0xE2,0x07,0x9E,0x0A,0xEC,0x01,0x56,0xF7,0x40,0x22,0xE0,0x26,0x98,0x63,
+0xE7,0xFF,0xF6,0x9E,0x12,0xEB,0x00,0x22,0xE0,0x36,0x98,0x60,0x98,0x80,0x98,0xA0,
+0xE4,0x00,0x00,0x3B,0x22,0xE4,0x3E,0x08,0x6B,0x17,0x08,0x8B,0x19,0x98,0xA1,0xE4,
+0x00,0x00,0x1D,0xD2,0xE1,0x06,0x09,0x98,0x60,0x98,0x80,0x98,0xA2,0x1C,0xC1,0x0C,
+0xE7,0xFF,0xBE,0x5C,0xD0,0x61,0x05,0x86,0x0E,0xE1,0x0E,0x22,0xE0,0x2A,0x52,0xE0,
+0x58,0xE4,0x00,0x00,0xD9,0x9E,0xFF,0xD2,0xEB,0x03,0x6D,0x4E,0xF7,0x10,0xC3,0x18,
+0x00,0x21,0xFF,0x18,0xBB,0x48,0x8E,0xF8,0x0E,0xF7,0x02,0x86,0xE9,0x52,0xE0,0x60,
+0xE4,0x00,0x00,0x9B,0x52,0xE0,0x61,0xE4,0x00,0x00,0x8D,0x52,0xE0,0x62,0xE4,0x00,
+0x00,0x7F,0x52,0xE0,0x63,0xE4,0x00,0x00,0x71,0x52,0xE0,0x64,0xE4,0x00,0x00,0x63,
+0x52,0xE0,0x65,0xE4,0x00,0x00,0x55,0x52,0xE0,0x66,0xE4,0x00,0x00,0x47,0x52,0xE0,
+0x67,0xE4,0x00,0x00,0x39,0x52,0xE0,0x68,0xE4,0x00,0x00,0x2B,0x52,0xE0,0x69,0xE4,
+0x00,0x00,0x1D,0x52,0xE0,0x6A,0xE4,0x00,0x00,0x0F,0x52,0xE0,0x6B,0x0E,0xEA,0x01,
+0xE4,0x00,0x00,0x69,0x0C,0x0A,0x01,0xE4,0x00,0x00,0x5B,0xC2,0xE0,0x10,0x01,0xEE,
+0xF7,0x00,0xD2,0x22,0xE4,0x86,0x9B,0x05,0xC2,0xE0,0x10,0x01,0xEF,0x17,0x0D,0x7C,
+0x9B,0x03,0xC2,0xE0,0x10,0x01,0x98,0x60,0xFB,0x17,0x0D,0x59,0xE7,0xFF,0xA2,0xE4,
+0xE7,0xFF,0xA1,0xF2,0x0E,0x61,0x16,0x0E,0x41,0x1A,0x0E,0x21,0x1E,0x0E,0x01,0x22,
+0x0D,0xE1,0x26,0x0D,0xC1,0x2A,0x0D,0xA1,0x2E,0x0D,0x81,0x32,0x0D,0x61,0x36,0x0D,
+0x41,0x3A,0x0D,0x21,0x3E,0x1C,0x21,0x40,0x85,0x29,0x9C,0x38,0x0D,0x41,0x00,0x0D,
+0x21,0x04,0x89,0x43,0x20,0x84,0x64,0x98,0x62,0x88,0x8A,0xE7,0xFF,0xD8,0x74,0x98,
+0x62,0x88,0x8A,0xE7,0xFF,0xD8,0x64,0x98,0x69,0xE4,0x00,0x00,0x2D,0x98,0x60,0x88,
+0x8A,0xE7,0xFF,0xD8,0x48,0x98,0x61,0x88,0x8A,0xE7,0xFF,0xD8,0x38,0x98,0x68,0x88,
+0x8A,0x0D,0x21,0x06,0x0D,0x41,0x02,0x9C,0x28,0xE7,0xFF,0xD8,0x19,0x9C,0x38,0x0D,
+0x21,0x04,0x0D,0x41,0x00,0x89,0x43,0x98,0x60,0x88,0x8A,0xE7,0xFF,0xD7,0xF4,0x88,
+0x8A,0x98,0x61,0xE7,0xFF,0xD7,0xE4,0x88,0x8A,0x0D,0x21,0x06,0x0D,0x41,0x02,0x98,
+0x68,0x9C,0x28,0xE7,0xFF,0xD7,0xC5,0xD0,0x69,0x08,0x25,0x4F,0x03,0x10,0xC2,0xF8,
+0x00,0x21,0xFE,0xF7,0xBB,0x78,0x8E,0xF8,0xC3,0x20,0x10,0x01,0x0F,0x77,0x02,0xC3,
+0x40,0x10,0x01,0xC3,0x00,0x10,0x01,0xC2,0xE0,0x10,0x01,0xFF,0x39,0x08,0x70,0xFF,
+0x5A,0x09,0xCC,0xFF,0x18,0x0B,0x36,0xFE,0xF7,0x0D,0x04,0x87,0x69,0x4C,0x63,0x20,
+0x5C,0x63,0x00,0x4F,0x23,0x08,0x4C,0x63,0x10,0x8F,0x19,0x8E,0xF9,0x8F,0x43,0x9B,
+0x20,0x43,0x77,0xCC,0x43,0xB8,0xCC,0x4F,0x99,0x08,0x0B,0xBD,0x01,0x8F,0x9A,0x0F,
+0x9C,0x02,0x4F,0x9C,0x42,0x43,0x9D,0xE5,0x0F,0x9B,0x01,0x9F,0x22,0x5F,0x24,0x09,
+0x23,0xFF,0x85,0xE4,0x00,0x01,0x31,0x9C,0x7E,0x4C,0x63,0x20,0x5C,0x63,0x00,0x4F,
+0x43,0x08,0x4C,0x63,0x10,0x8F,0x1A,0x8C,0x79,0x8E,0xFA,0x9B,0x20,0x43,0x77,0xCC,
+0x43,0xB8,0xCC,0x4F,0x99,0x08,0x0B,0xBD,0x01,0x8F,0x83,0x0F,0x9C,0x02,0x4F,0x9C,
+0x42,0x43,0x9D,0xE5,0x0F,0x9B,0x01,0x9F,0x22,0x5F,0x24,0x09,0x23,0xFF,0x85,0xE4,
+0x00,0x00,0xB9,0x0B,0x78,0x41,0xEF,0x3A,0x00,0x82,0x4F,0x39,0x42,0x43,0x3B,0xCD,
+0x0B,0x78,0x43,0x0F,0x37,0x41,0xEF,0x3A,0x00,0x86,0x4F,0x39,0x42,0x43,0x3B,0xCD,
+0x0F,0x37,0x43,0xEF,0x3A,0x00,0x8A,0xE4,0x00,0x00,0x51,0xEF,0x59,0x00,0x82,0x0B,
+0x78,0x41,0x4F,0x5A,0x42,0x43,0x5B,0xD5,0x0B,0x78,0x43,0x0F,0x57,0x41,0xEF,0x59,
+0x00,0x86,0xEF,0x39,0x00,0x8A,0x4F,0x5A,0x42,0x43,0x5B,0xD5,0x0F,0x57,0x43,0x4F,
+0x39,0x42,0x0B,0x18,0x45,0x43,0x18,0xCD,0x0F,0x17,0x45,0x85,0x29,0x9C,0x38,0x0D,
+0x21,0x04,0x20,0x64,0x54,0x98,0x62,0xE7,0xFF,0xFD,0xE0,0x98,0x63,0xE7,0xFF,0xFD,
+0xD4,0x98,0x69,0xE4,0x00,0x00,0x25,0x98,0x60,0xE7,0xFF,0xFD,0xBC,0x98,0x61,0xE7,
+0xFF,0xFD,0xB0,0x98,0x68,0x0D,0x21,0x06,0x9C,0x28,0xE7,0xFF,0xFD,0x9B,0x9C,0x38,
+0x98,0x60,0x0D,0x21,0x04,0xE7,0xFF,0xFD,0x84,0x98,0x61,0xE7,0xFF,0xFD,0x78,0x0D,
+0x21,0x06,0x98,0x68,0x9C,0x28,0xE7,0xFF,0xFD,0x63,0x9C,0x38,0x0D,0x21,0x04,0xE7,
+0xFF,0xA9,0xA4,0x20,0x60,0x5E,0xE7,0xFF,0xA9,0x82,0x98,0x80,0xE7,0xFF,0xB5,0xF6,
+0xE7,0xFF,0xA9,0x6E,0x98,0x82,0xE4,0x00,0x00,0x37,0xE7,0xFF,0xA9,0x6E,0x20,0x64,
+0x86,0xE7,0xFF,0xA9,0x4C,0x98,0x81,0xE7,0xFF,0xB5,0xC0,0xE7,0xFF,0xA9,0x38,0x98,
+0x83,0xE7,0xFF,0xB3,0x18,0xE7,0xFF,0xCE,0x9E,0x9A,0xE0,0xE4,0x00,0x00,0xA1,0xE7,
+0xFF,0xA9,0x24,0x20,0x68,0x5E,0xE7,0xFF,0xA9,0x02,0x98,0x82,0xE7,0xFF,0xB5,0x76,
+0xE7,0xFF,0xA8,0xEE,0x98,0x81,0xE7,0xFF,0xFF,0xB7,0xE7,0xFF,0xA8,0xEE,0x20,0x6C,
+0x5E,0xE7,0xFF,0xA8,0xCC,0x98,0x83,0xE7,0xFF,0xB5,0x40,0xE7,0xFF,0xA8,0xB8,0x98,
+0x87,0xE7,0xFF,0xFF,0x81,0xE7,0xFF,0xA8,0xB8,0x9A,0xE0,0xD0,0x67,0x00,0x86,0xE7,
+0xFF,0xA8,0x90,0x98,0x87,0xE7,0xFF,0xB5,0x04,0x9A,0xE1,0x88,0x77,0x0D,0x21,0x06,
+0x9C,0x28,0x85,0x29,0x1C,0x21,0xE0,0x0D,0x21,0x1C,0x0D,0x41,0x18,0x0D,0x61,0x14,
+0x0D,0x81,0x10,0x0D,0xA1,0x0C,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0xE7,0xFF,
+0x99,0x9A,0x0C,0x61,0x00,0xE7,0xFF,0x99,0x94,0x0C,0x61,0x04,0x0E,0xE1,0x02,0xD2,
+0xE0,0x15,0x0A,0x0E,0xE1,0x02,0xC1,0x60,0x10,0x01,0xC1,0x40,0x10,0x01,0x57,0x17,
+0x10,0xFD,0x6B,0x00,0xD6,0xFD,0x4A,0x00,0xC4,0xD3,0x00,0x06,0x42,0x50,0x60,0x10,
+0xE7,0xFF,0x99,0x76,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x00,0xB3,0x9F,0x01,0x5F,0x18,
+0x04,0xEF,0x17,0x00,0xB3,0xE7,0xFF,0x99,0x9C,0x0A,0xEB,0x0B,0x40,0x63,0xBD,0x5E,
+0xE3,0x04,0x5E,0xE3,0xBB,0x20,0x02,0x3F,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x06,0x4B,
+0x56,0xF7,0x20,0xD2,0xE0,0x04,0x0A,0x98,0x61,0xE7,0xFF,0xB6,0x36,0x20,0x61,0xDE,
+0xE7,0xFF,0xA7,0x4E,0x20,0x64,0x56,0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x00,0xB8,0x56,
+0xF7,0x01,0x22,0xE1,0x8A,0xE4,0x00,0x00,0x1F,0xE7,0xFF,0xA7,0x1C,0x20,0x63,0xA8,
+0xE4,0x00,0x00,0xA9,0xE7,0xFF,0xCB,0x92,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x06,0x4B,
+0xC7,0x18,0xFF,0xDF,0xEF,0x17,0x06,0x4B,0xE7,0xFF,0xA6,0xDE,0x20,0x60,0x5E,0x98,
+0x81,0x98,0xA0,0xE7,0xFF,0x33,0x92,0x98,0x60,0x88,0x83,0xE7,0xFF,0xB0,0xA4,0xE4,
+0x00,0x00,0x43,0x98,0x80,0x98,0x62,0xE7,0xFF,0xB0,0x8C,0xFC,0x60,0x01,0x5E,0xE7,
+0xFF,0x65,0x5C,0x98,0x60,0xE7,0xFF,0x38,0x7C,0xE7,0xFF,0x98,0x74,0x0C,0x6B,0x09,
+0xE7,0xFF,0xCB,0xE8,0x0A,0xEA,0x01,0x52,0xF7,0x10,0x0E,0xEA,0x01,0xE4,0x00,0x04,
+0x2B,0x57,0x17,0x40,0x23,0x00,0x38,0x50,0x60,0x40,0xE7,0xFF,0x97,0xE2,0xE4,0x00,
+0x04,0x09,0xC6,0xF7,0x01,0x00,0xD2,0xE0,0x0F,0xE2,0xE4,0x00,0x30,0x7C,0x89,0xA3,
+0x98,0x60,0xE7,0xFF,0x97,0x82,0xFC,0x60,0x01,0x00,0xE7,0xFF,0x97,0x82,0xFC,0x60,
+0x01,0x00,0xE7,0xFF,0x97,0x92,0xE7,0xFF,0xA5,0xE2,0xD0,0x67,0x0C,0x05,0x4E,0xE3,
+0x10,0xC3,0x18,0x00,0x21,0xFF,0x18,0xBB,0xA4,0x8E,0xF8,0x0E,0xF7,0x02,0x86,0xE9,
+0xE7,0xFF,0xA5,0xC2,0x20,0x60,0x3E,0x98,0x80,0xE7,0xFF,0xB2,0x1C,0x98,0x60,0xE4,
+0x00,0x02,0xA3,0xE7,0xFF,0xA5,0x9C,0x20,0x64,0x4E,0x98,0x60,0x98,0x81,0xE7,0xFF,
+0xB1,0xF2,0x98,0x60,0x98,0x87,0xE4,0x00,0x02,0x79,0xE7,0xFF,0xA5,0x6E,0xD0,0x67,
+0x09,0xE6,0x98,0x60,0x98,0x87,0xE4,0x00,0x02,0x1D,0xE7,0xFF,0xFB,0xA0,0xD0,0x60,
+0x09,0x62,0xE7,0xFF,0xB3,0x12,0x5D,0x83,0x04,0x98,0x61,0xE7,0xFF,0xB3,0xF2,0xD0,
+0x60,0x07,0xCE,0xC1,0x80,0x1F,0x4A,0x20,0x03,0xC5,0xE7,0xFF,0x37,0x4E,0xE7,0xFF,
+0x37,0x1E,0x5C,0x63,0x00,0x24,0x64,0x33,0x98,0x61,0xC1,0x80,0x3E,0x8A,0x20,0x01,
+0xE9,0x98,0x80,0x98,0x62,0xE7,0xFF,0xAE,0xB0,0xFC,0x60,0x01,0x5E,0xE7,0xFF,0x63,
+0x80,0x98,0x60,0xE7,0xFF,0x36,0xA0,0xE7,0xFF,0x96,0x98,0x0C,0x6B,0x09,0xE4,0x00,
+0x01,0xB1,0xE7,0xFF,0xFA,0xF0,0xD0,0x60,0x06,0xA2,0xE7,0xFF,0xB2,0x62,0xE7,0xFF,
+0x63,0xC0,0xE7,0xFF,0x64,0x50,0xD0,0x61,0x05,0x12,0xE7,0xFF,0x64,0x70,0x20,0x64,
+0xD2,0xE7,0xFF,0x36,0x30,0x5C,0x63,0x00,0xC0,0x60,0x18,0xEE,0x20,0x00,0x1D,0xE7,
+0xFF,0x36,0x3C,0xE7,0xFF,0x36,0x0C,0x98,0x80,0x5D,0x43,0x00,0x98,0x62,0xE7,0xFF,
+0xAD,0xFE,0xCC,0x6A,0x00,0x64,0xFC,0x63,0x01,0x5E,0xE7,0xFF,0x62,0xC6,0xE4,0x00,
+0x01,0x11,0xE7,0xFF,0x64,0x20,0x98,0x62,0x98,0x80,0xE4,0x00,0x00,0xF1,0xE7,0xFF,
+0xA3,0xE6,0x20,0x64,0x48,0xE7,0xFF,0xA3,0xD8,0xE7,0xFF,0xA3,0xD0,0x20,0x61,0xB6,
+0xE4,0x00,0x00,0x21,0xE7,0xFF,0xA3,0xBA,0x88,0x83,0x98,0x64,0xE4,0x00,0x00,0x71,
+0x98,0x64,0x98,0x80,0xE7,0xFF,0xB0,0x06,0x98,0x64,0xE4,0x00,0x00,0x8D,0x98,0x64,
+0x98,0x89,0xE4,0x00,0x00,0x45,0xE7,0xFF,0xA3,0x76,0x20,0x64,0x48,0xE7,0xFF,0xA3,
+0x68,0xE7,0xFF,0xA3,0x60,0x20,0x60,0xD6,0xE4,0x00,0x00,0x3D,0xE7,0xFF,0xA3,0x4A,
+0x88,0x83,0x98,0x67,0xE7,0xFF,0xAF,0xA6,0x0A,0xEA,0x01,0xCA,0xF7,0x01,0x00,0x0E,
+0xEA,0x01,0xE4,0x00,0x00,0x31,0x98,0x67,0x98,0x80,0xE7,0xFF,0xAF,0x7A,0x98,0x67,
+0x98,0x81,0xE7,0xFF,0xAC,0xD6,0xE7,0xFF,0xC8,0x5C,0x88,0x6D,0xE4,0x00,0x00,0xA5,
+0x0E,0xE1,0x06,0x22,0xE1,0x3C,0x0E,0xE1,0x06,0x56,0xF7,0x20,0x22,0xE1,0x18,0xE4,
+0x00,0x2D,0x12,0x89,0x43,0x98,0x60,0xE7,0xFF,0x94,0x18,0x50,0x60,0x20,0xE7,0xFF,
+0x94,0x22,0xE7,0xFF,0x89,0x5A,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x00,0xC9,0xC7,0x18,
+0xFF,0xFE,0x50,0x60,0x20,0xEF,0x17,0x00,0xC9,0xE7,0xFF,0x93,0xFC,0xC2,0xE0,0x10,
+0x01,0x88,0x6A,0xEB,0x17,0x00,0xC7,0x53,0x18,0x20,0xEF,0x17,0x00,0xC7,0xE7,0xFF,
+0x93,0xAA,0x0D,0xA1,0x0E,0x0D,0x81,0x12,0x0D,0x61,0x16,0x0D,0x41,0x1A,0x0D,0x21,
+0x1E,0x1C,0x21,0x20,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x23,0x24,0x0B,0x17,
+0x01,0x53,0x18,0x20,0x0F,0x17,0x01,0x0C,0x63,0x02,0x0B,0x17,0x01,0xC7,0x18,0xFF,
+0xDF,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x23,0x24,0x0B,0x17,
+0x01,0x53,0x18,0x20,0x0F,0x17,0x01,0x0C,0x83,0x00,0x0B,0x17,0x01,0xC7,0x18,0xFF,
+0xDF,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x14,0x0B,0x17,
+0x01,0x53,0x18,0x01,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x23,
+0x24,0x0B,0x17,0x01,0x53,0x18,0x20,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,
+0xCA,0xF7,0x23,0x24,0x0B,0x17,0x01,0xC7,0x18,0xFF,0xDF,0x0F,0x17,0x01,0x85,0x29,
+0x9C,0x30,0x0D,0x21,0x0C,0x0D,0x41,0x08,0x0D,0x61,0x04,0x0D,0x81,0x00,0xC1,0x54,
+0x00,0x01,0xC9,0x8A,0x22,0x28,0x0A,0xEC,0x01,0xC6,0xF7,0xFF,0xFB,0xC9,0x6A,0x22,
+0x04,0x0E,0xEC,0x01,0xFF,0x00,0x80,0x00,0x0A,0xEB,0x01,0x46,0xF7,0xC5,0x5E,0xF7,
+0x04,0xC9,0x4A,0x24,0xA8,0x0E,0xEB,0x01,0x0A,0xEA,0x01,0xCA,0xF7,0x30,0x00,0x50,
+0x60,0x64,0x0E,0xEA,0x01,0xE4,0x00,0x28,0x4A,0x0A,0xEC,0x01,0x52,0xF7,0x04,0x50,
+0x60,0x1E,0x0E,0xEC,0x01,0xE4,0x00,0x28,0x2A,0x0A,0xEB,0x01,0xC6,0xF7,0x7F,0xFF,
+0x0E,0xEB,0x01,0x0A,0xEA,0x01,0xC6,0xF7,0xCF,0xFF,0x0E,0xEA,0x01,0x0D,0x81,0x02,
+0x0D,0x61,0x06,0x0D,0x41,0x0A,0x0D,0x21,0x0E,0x1C,0x21,0x10,0x85,0x29,0xC2,0xF4,
+0x00,0x01,0xCA,0xF7,0x24,0x2C,0x08,0x77,0x01,0x4C,0x63,0x09,0x54,0x63,0x1F,0x9C,
+0x61,0x85,0x29,0x9C,0x7F,0x5C,0x63,0x00,0x5C,0x62,0xFB,0x20,0x00,0x81,0xC2,0xF4,
+0x00,0x01,0x4C,0x63,0x08,0xCA,0xF7,0x24,0x2C,0x54,0x63,0x3E,0x0B,0x17,0x01,0x1F,
+0x20,0xC1,0x47,0x18,0xCC,0x44,0x63,0xC5,0x0C,0x77,0x01,0x85,0x29,0x9B,0x19,0x20,
+0x60,0x62,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x10,0x0B,0x37,0x01,0x47,0x19,0xC4,
+0x53,0x18,0x04,0xE4,0x00,0x00,0x87,0x20,0x64,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,
+0x24,0x10,0x0B,0x17,0x01,0x53,0x18,0x06,0xE4,0x00,0x00,0x5D,0x20,0x68,0x5A,0xC2,
+0xF4,0x00,0x01,0xCA,0xF7,0x24,0x10,0x0B,0x17,0x01,0xC7,0x18,0xFF,0xF9,0xE4,0x00,
+0x00,0x31,0x20,0x6C,0x5E,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x10,0x0B,0x37,0x01,
+0x47,0x19,0xC4,0x53,0x18,0x02,0x0F,0x17,0x01,0x85,0x29,0x5C,0x63,0x00,0x9C,0x30,
+0x0D,0x21,0x0C,0x0D,0x41,0x08,0x0C,0xA1,0x04,0x95,0x50,0xC9,0x4A,0x20,0x80,0x8D,
+0x43,0x4D,0x4A,0x18,0x88,0x6A,0xE7,0xFF,0xFC,0xE0,0x0C,0xA1,0x06,0x1C,0x6A,0x04,
+0x0D,0x21,0x0E,0x0D,0x41,0x0A,0x88,0x85,0x1C,0x21,0x10,0xE7,0xFF,0xFC,0xB7,0x1C,
+0x21,0xE8,0x0D,0x41,0x10,0x5D,0x44,0x00,0x4E,0xEA,0x08,0x0D,0x61,0x0C,0x0D,0x81,
+0x08,0x5D,0x65,0x00,0x5C,0x63,0x00,0x4D,0x83,0x18,0x8D,0x8B,0x8D,0x97,0x06,0xE0,
+0x81,0xCA,0xF7,0x04,0x00,0x0D,0x21,0x14,0x0D,0xA1,0x04,0xC5,0x8C,0x1F,0xFC,0x5D,
+0xA6,0x00,0x8D,0x97,0x88,0x6C,0xE7,0xFF,0xFC,0x00,0x55,0x4A,0x01,0x50,0x80,0xFF,
+0x4D,0x4A,0x08,0x8D,0x6A,0x4D,0x6B,0x18,0x4C,0x84,0x5C,0x4D,0x6D,0x5C,0x44,0x84,
+0x27,0x0D,0xA1,0x06,0x44,0x83,0x24,0x0D,0x41,0x12,0x88,0x6C,0x44,0x84,0x5D,0x0D,
+0x81,0x0A,0x0D,0x61,0x0E,0x0D,0x21,0x16,0x1C,0x21,0x18,0xE7,0xFF,0xFB,0xD7,0x5C,
+0x84,0x04,0x20,0x60,0x28,0x20,0x64,0xC2,0xE4,0x00,0x00,0x33,0x4C,0x84,0x41,0xC2,
+0xF4,0x00,0x01,0x9C,0x9F,0xCA,0xF7,0x24,0x34,0xC4,0x84,0x01,0xFF,0xE4,0x00,0x00,
+0x2B,0x4C,0x84,0x41,0xC2,0xF4,0x00,0x01,0x9C,0x9F,0xCA,0xF7,0x24,0x38,0xC4,0x84,
+0x01,0xFF,0x0C,0x97,0x01,0x85,0x29,0x07,0x00,0xFF,0xCB,0x18,0xFF,0xFF,0x20,0x60,
+0x28,0x20,0x65,0xD2,0xE4,0x00,0x00,0x7D,0xC2,0xF4,0x00,0x01,0x47,0x64,0x27,0xCB,
+0x37,0x24,0x3C,0x0B,0x59,0x01,0x47,0x5A,0xDC,0x0F,0x59,0x01,0xCA,0xF7,0x24,0x40,
+0x47,0x04,0xC4,0x0B,0x37,0x01,0x4F,0x18,0x81,0x44,0x84,0x27,0x4C,0x84,0x81,0x44,
+0x84,0xC4,0x47,0x18,0xC7,0x47,0x19,0xC4,0x47,0x04,0xC5,0x0F,0x17,0x01,0xE4,0x00,
+0x00,0x6F,0x5F,0x44,0x04,0xC2,0xF4,0x00,0x01,0x47,0x9A,0xD7,0xCB,0x37,0x24,0x3C,
+0x0B,0x79,0x01,0x47,0x7B,0xE4,0x47,0x5A,0xDD,0x0F,0x59,0x01,0xCA,0xF7,0x24,0x40,
+0x44,0x84,0xC4,0x0B,0x57,0x01,0x4C,0x84,0x81,0x47,0x24,0x27,0x47,0x1A,0xCC,0x44,
+0x84,0xC5,0x0C,0x97,0x01,0x85,0x29,0x07,0x00,0xFF,0xCB,0x18,0xFF,0xFF,0x20,0x60,
+0x28,0x20,0x65,0xD2,0xE4,0x00,0x00,0x7D,0xC2,0xF4,0x00,0x01,0x47,0x64,0x27,0xCB,
+0x37,0x24,0x1C,0x0B,0x59,0x01,0x47,0x5A,0xDC,0x0F,0x59,0x01,0xCA,0xF7,0x24,0x20,
+0x47,0x04,0xC4,0x0B,0x37,0x01,0x4F,0x18,0x81,0x44,0x84,0x27,0x4C,0x84,0x81,0x44,
+0x84,0xC4,0x47,0x18,0xC7,0x47,0x19,0xC4,0x47,0x04,0xC5,0x0F,0x17,0x01,0xE4,0x00,
+0x00,0x6F,0x5F,0x44,0x04,0xC2,0xF4,0x00,0x01,0x47,0x9A,0xD7,0xCB,0x37,0x24,0x1C,
+0x0B,0x79,0x01,0x47,0x7B,0xE4,0x47,0x5A,0xDD,0x0F,0x59,0x01,0xCA,0xF7,0x24,0x20,
+0x44,0x84,0xC4,0x0B,0x57,0x01,0x4C,0x84,0x81,0x47,0x24,0x27,0x47,0x1A,0xCC,0x44,
+0x84,0xC5,0x0C,0x97,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x24,0x80,0x0B,
+0x38,0x01,0x5F,0x23,0x04,0x0F,0x38,0x01,0x07,0x20,0xFF,0xCB,0x39,0xFF,0xFF,0xCA,
+0xF7,0x24,0x84,0x44,0x63,0xCC,0x0B,0x17,0x01,0x4C,0x63,0x81,0xFF,0x20,0xFF,0x00,
+0x47,0x18,0xCC,0x44,0x63,0xC5,0x0C,0x77,0x01,0x85,0x29,0x07,0x00,0xFF,0xCB,0x18,
+0xFF,0xFF,0x20,0x60,0x28,0x20,0x65,0xD2,0xE4,0x00,0x00,0x7D,0xC2,0xF4,0x00,0x01,
+0x47,0x64,0x27,0xCB,0x37,0x24,0x24,0x0B,0x59,0x01,0x47,0x5A,0xDC,0x0F,0x59,0x01,
+0xCA,0xF7,0x24,0x28,0x47,0x04,0xC4,0x0B,0x37,0x01,0x4F,0x18,0x81,0x44,0x84,0x27,
+0x4C,0x84,0x81,0x44,0x84,0xC4,0x47,0x18,0xC7,0x47,0x19,0xC4,0x47,0x04,0xC5,0x0F,
+0x17,0x01,0xE4,0x00,0x00,0x6F,0x5F,0x44,0x04,0xC2,0xF4,0x00,0x01,0x47,0x9A,0xD7,
+0xCB,0x37,0x24,0x24,0x0B,0x79,0x01,0x47,0x7B,0xE4,0x47,0x5A,0xDD,0x0F,0x59,0x01,
+0xCA,0xF7,0x24,0x28,0x44,0x84,0xC4,0x0B,0x57,0x01,0x4C,0x84,0x81,0x47,0x24,0x27,
+0x47,0x1A,0xCC,0x44,0x84,0xC5,0x0C,0x97,0x01,0x85,0x29,0xC3,0x14,0x00,0x01,0xCA,
+0xF8,0x22,0x08,0x20,0x64,0x3A,0x0B,0x37,0x01,0xCB,0x39,0x10,0x00,0xE4,0x00,0x00,
+0x1D,0x20,0x60,0x36,0x0B,0x37,0x01,0xC7,0x39,0xEF,0xFF,0x0F,0x37,0x01,0xCA,0xF8,
+0x22,0x08,0x0B,0x17,0x01,0xCB,0x18,0x20,0x00,0x0F,0x17,0x01,0x85,0x29,0x5C,0x84,
+0x00,0x1F,0x00,0x80,0x20,0x60,0x28,0x20,0x64,0xAA,0xE4,0x00,0x00,0x21,0xC2,0xF4,
+0x00,0x01,0xCA,0xF7,0x24,0x54,0xE4,0x00,0x00,0x19,0xC2,0xF4,0x00,0x01,0xCA,0xF7,
+0x24,0x64,0x0B,0x37,0x01,0x54,0x84,0x7F,0x47,0x19,0xC4,0x47,0x04,0xC5,0x0F,0x17,
+0x01,0x85,0x29,0x5C,0x84,0x00,0x20,0x60,0x28,0x20,0x64,0xAA,0xE4,0x00,0x00,0x21,
+0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x50,0xE4,0x00,0x00,0x19,0xC2,0xF4,0x00,0x01,
+0xCA,0xF7,0x24,0x61,0x13,0x17,0x00,0x54,0x84,0x1F,0x57,0x18,0xE0,0x44,0x84,0xC5,
+0x18,0x97,0x00,0x85,0x29,0x9C,0x30,0x0D,0x41,0x08,0x0D,0x61,0x04,0x0D,0x21,0x0C,
+0x5D,0x44,0x00,0x89,0x63,0x1C,0x8A,0xF1,0x4C,0x84,0x08,0x5C,0x83,0xF3,0x20,0x00,
+0x19,0x50,0x80,0x1F,0x88,0x6B,0xE7,0xFF,0xFF,0x5A,0x1F,0x00,0x80,0x21,0x60,0x28,
+0x21,0x64,0xAA,0xE4,0x00,0x00,0x21,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x4C,0xE4,
+0x00,0x00,0x19,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x60,0x0B,0x37,0x01,0x55,0x4A,
+0x7F,0x47,0x19,0xC4,0x47,0x0A,0xC5,0x0F,0x17,0x01,0x0D,0x61,0x06,0x0D,0x41,0x0A,
+0x0D,0x21,0x0E,0x1C,0x21,0x10,0x85,0x29,0x20,0x64,0x8E,0xC2,0xF4,0x00,0x01,0xCB,
+0x17,0x22,0x04,0xCA,0xF7,0x22,0x60,0x0B,0x38,0x01,0x53,0x39,0xF0,0x0F,0x38,0x01,
+0x0B,0x17,0x01,0xC7,0x18,0xFF,0xF0,0xE4,0x00,0x00,0x47,0x20,0x60,0x8A,0xC2,0xF4,
+0x00,0x01,0xCB,0x17,0x22,0x04,0xCA,0xF7,0x22,0x60,0x0B,0x38,0x01,0xC7,0x39,0xFF,
+0x0F,0x0F,0x38,0x01,0x0B,0x17,0x01,0x53,0x18,0x0F,0x0F,0x17,0x01,0x85,0x29,0x20,
+0x64,0x8E,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x22,0x04,0xCA,0xF7,0x22,0x60,0x0B,0x38,
+0x01,0x53,0x39,0x08,0x0F,0x38,0x01,0x0B,0x17,0x01,0xC7,0x18,0xFE,0xFF,0xE4,0x00,
+0x00,0x49,0x20,0x60,0x8E,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x22,0x04,0xCA,0xF7,0x22,
+0x60,0x0B,0x38,0x01,0xC7,0x39,0xFF,0xF7,0x0F,0x38,0x01,0x0B,0x17,0x01,0xCB,0x18,
+0x01,0x00,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,
+0x22,0x60,0x0B,0x17,0x01,0xCB,0x18,0x02,0x00,0xE4,0x00,0x00,0x2D,0x20,0x60,0x56,
+0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x22,0x60,0x0B,0x17,0x01,0xC7,0x18,0xFD,0xFF,0x0F,
+0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0x54,0x63,0x7F,0xCA,0xF7,0x24,0xA0,0x1F,
+0x20,0x80,0x0B,0x17,0x01,0x47,0x18,0xCC,0x47,0x03,0xC5,0x0F,0x17,0x01,0x85,0x29,
+0xC2,0xF4,0x00,0x01,0x4C,0x63,0x40,0xCA,0xF7,0x24,0xA0,0xC4,0x63,0x7F,0x00,0x0B,
+0x17,0x01,0xFF,0x20,0x80,0xFF,0x47,0x18,0xCC,0x47,0x03,0xC5,0x0F,0x17,0x01,0x85,
+0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0xA1,0x10,0x77,0x00,0x54,0x63,0x7F,0x85,
+0x29,0x20,0x64,0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0xA0,0x0B,0x17,0x01,0xC7,
+0x18,0xFF,0x7F,0xE4,0x00,0x00,0x2B,0x20,0x60,0x52,0xC2,0xF4,0x00,0x01,0xCA,0xF7,
+0x24,0xA0,0x0B,0x17,0x01,0x53,0x18,0x80,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x5A,
+0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0xA0,0x0B,0x17,0x01,0xC7,0x18,0x7F,0xFF,0xE4,
+0x00,0x00,0x39,0x20,0x60,0x6E,0xC2,0xF4,0x00,0x01,0xFF,0x20,0x80,0x00,0xCA,0xF7,
+0x24,0xA0,0x0B,0x17,0x01,0x47,0x18,0xCD,0x5F,0x18,0x04,0x0F,0x17,0x01,0x85,0x29,
+0xC2,0xF4,0x00,0x01,0x5C,0x63,0x00,0xCA,0xF7,0x22,0x0C,0xFF,0x20,0xFF,0x00,0x0B,
+0x17,0x01,0x47,0x18,0xCC,0x47,0x03,0xC5,0x0F,0x17,0x01,0x85,0x29,0x5C,0x63,0x04,
+0xC2,0xF4,0x00,0x01,0xFF,0x40,0xFF,0x00,0xCA,0xF7,0x22,0xF0,0x47,0x03,0xD4,0x0B,
+0x37,0x01,0x5F,0x39,0x00,0x47,0x18,0xCD,0x0F,0x17,0x01,0x85,0x29,0x5C,0x63,0x04,
+0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x22,0x38,0x0B,0x17,0x01,0x0C,0x77,0x01,0x85,0x29,
+0x20,0x64,0x6A,0xC2,0xF4,0x00,0x01,0x9B,0x3C,0xCA,0xF7,0x25,0xC0,0x0B,0x17,0x01,
+0x47,0x18,0xCC,0x53,0x18,0x01,0xE4,0x00,0x00,0x3F,0x20,0x60,0x7A,0xC2,0xF4,0x00,
+0x01,0xCB,0x17,0x22,0x38,0xCA,0xF7,0x25,0xC0,0x0B,0x38,0x01,0x0C,0x18,0x01,0x0B,
+0x17,0x01,0x53,0x18,0x03,0x0F,0x17,0x01,0x85,0x29,0x5C,0x84,0x00,0x20,0x64,0x62,
+0x4C,0x63,0x24,0xC2,0xF4,0x00,0x01,0x5C,0x63,0x04,0xCA,0xF7,0x22,0xCC,0x0C,0x77,
+0x01,0xE4,0x00,0x00,0x25,0x20,0x60,0x3A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x22,0xCC,
+0x0C,0x17,0x01,0x85,0x29,0x20,0x60,0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x22,0xE8,
+0x0B,0x17,0x01,0xC7,0x18,0xFF,0xFE,0xE4,0x00,0x00,0x2B,0x20,0x64,0x52,0xC2,0xF4,
+0x00,0x01,0xCA,0xF7,0x22,0xE8,0x0B,0x17,0x01,0x53,0x18,0x01,0x0F,0x17,0x01,0x85,
+0x29,0x20,0x60,0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x22,0xE8,0x0B,0x17,0x01,0xC7,
+0x18,0xF0,0xFF,0xE4,0x00,0x00,0x2D,0x20,0x64,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,
+0x22,0xE8,0x0B,0x17,0x01,0xCB,0x18,0x0F,0x00,0x0F,0x17,0x01,0x85,0x29,0x5C,0x63,
+0x00,0xC4,0x84,0x03,0xFF,0x20,0x64,0x70,0x20,0x60,0x34,0x20,0x68,0x88,0x20,0x6C,
+0xDA,0xE4,0x00,0x00,0x51,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x68,0xE4,0x00,0x00,
+0x49,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x6C,0xE4,0x00,0x00,0x31,0xC2,0xF4,0x00,
+0x01,0xCA,0xF7,0x24,0x70,0xE4,0x00,0x00,0x19,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,
+0x74,0x0C,0x97,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x23,0x24,0x0B,0x17,
+0x01,0x53,0x18,0x20,0x0F,0x17,0x01,0x5C,0x63,0x00,0x07,0x00,0x20,0xCB,0x18,0x41,
+0x00,0x44,0x63,0xC5,0x4C,0x63,0x10,0x0C,0x83,0x00,0x0B,0x17,0x01,0xC7,0x18,0xFF,
+0xDF,0x0F,0x17,0x01,0x85,0x29,0xFC,0x21,0xFE,0x88,0x50,0xA0,0x96,0xED,0x21,0x01,
+0x74,0xED,0x41,0x01,0x70,0xED,0x61,0x01,0x6C,0x88,0x61,0xC1,0x78,0x00,0x21,0xFD,
+0x6B,0xB4,0xBE,0x88,0x8B,0xE7,0xFF,0x53,0x0A,0xFD,0x41,0x00,0x96,0xFC,0x8B,0x00,
+0x96,0x88,0x6A,0x50,0xA0,0xD2,0xE7,0xFF,0x52,0xE8,0x8A,0xE1,0xC3,0x54,0x00,0x01,
+0xFF,0x60,0xFF,0x00,0x0B,0x37,0x01,0x47,0x19,0xDC,0x5F,0x39,0x00,0x4F,0x39,0x10,
+0x4F,0x18,0x08,0x8F,0x19,0x0B,0x37,0x03,0x47,0xB9,0xCF,0x8F,0x1A,0x0B,0x98,0x01,
+0x47,0x9C,0xEC,0x0B,0xB7,0x05,0x47,0x39,0xEC,0x47,0x3C,0xCD,0x0F,0x38,0x01,0x9E,
+0xE6,0xD5,0x57,0xFE,0x9E,0xFE,0xE1,0x00,0x96,0xFF,0x81,0x01,0x68,0x0B,0x37,0x01,
+0x47,0x19,0xDC,0x5F,0x39,0x00,0x4F,0x39,0x10,0x4F,0x18,0x08,0x8F,0x19,0x0B,0x37,
+0x03,0x47,0xD9,0xCF,0x8F,0x1A,0x0B,0xB8,0x01,0x47,0xBD,0xF4,0x0B,0xD7,0x05,0x47,
+0x39,0xF4,0x47,0x3D,0xCD,0x0F,0x38,0x01,0x9E,0xE6,0xD7,0x97,0xFE,0x9E,0xED,0x61,
+0x01,0x6E,0xED,0x41,0x01,0x72,0xED,0x21,0x01,0x76,0xFC,0x21,0x01,0x78,0x85,0x29,
+0xC2,0xF4,0x00,0x01,0xCB,0x17,0x22,0x00,0x0C,0x18,0x01,0xCA,0xF7,0x24,0x14,0xFF,
+0x20,0xFF,0x07,0x0B,0x17,0x01,0x47,0x18,0xCC,0x53,0x18,0x30,0x0F,0x17,0x01,0x85,
+0x29,0x1C,0x21,0xD8,0xC0,0x98,0x00,0x21,0x0D,0x21,0x24,0x1C,0x61,0x02,0xFC,0x84,
+0xB4,0xBE,0x50,0xA0,0x1E,0xFC,0x84,0x01,0x68,0xE7,0xFF,0x51,0x62,0xC3,0x54,0x00,
+0x01,0xCA,0xE0,0x11,0x50,0xCB,0x5A,0x22,0x00,0x57,0x37,0xFF,0x4F,0x39,0x10,0x8F,
+0x3A,0x0C,0x19,0x01,0x9E,0xE1,0xC3,0x14,0x00,0x01,0xC2,0xE2,0x2B,0x84,0x23,0xFF,
+0xAD,0xCA,0xF8,0x23,0x70,0x0C,0x17,0x01,0xCA,0xF8,0x23,0x74,0x0C,0x17,0x01,0xCB,
+0x18,0x23,0x78,0x1E,0xE1,0x02,0x0C,0x18,0x01,0x1F,0x41,0x20,0x0B,0x37,0x01,0xFF,
+0x60,0xFF,0x00,0x47,0x19,0xDC,0x5F,0x39,0x00,0x4F,0x39,0x10,0x4F,0x18,0x08,0x8F,
+0x19,0xC3,0x34,0x00,0x01,0x8F,0x19,0x0B,0x37,0x03,0x47,0x99,0xCF,0x0B,0x78,0x01,
+0x47,0x7B,0xE4,0x0B,0x97,0x05,0x47,0x39,0xE4,0x47,0x3B,0xCD,0x0F,0x38,0x01,0x9E,
+0xE6,0xD7,0x57,0xFE,0x5E,0x0D,0x21,0x26,0xFC,0x60,0x01,0xF4,0x1C,0x21,0x28,0xE4,
+0x00,0x16,0xB7,0x5C,0x84,0x00,0x9B,0x10,0x20,0x60,0x28,0x20,0x64,0xAA,0xE4,0x00,
+0x00,0x21,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x22,0x10,0xE4,0x00,0x00,0x19,0xC2,0xF4,
+0x00,0x01,0xCA,0xF7,0x22,0x14,0x0B,0x37,0x01,0x54,0x84,0x0F,0x47,0x19,0xC4,0x47,
+0x04,0xC5,0x0F,0x17,0x01,0x85,0x29,0x1C,0x21,0xE0,0xC0,0x98,0x00,0x21,0x0D,0x21,
+0x1C,0x88,0x61,0xFC,0x84,0xB4,0xBE,0x50,0xA0,0x18,0xFC,0x84,0x01,0x86,0xE7,0xFF,
+0x4F,0xB8,0x8A,0xE1,0x1F,0x41,0x18,0x0B,0x37,0x01,0xFF,0x60,0xFF,0x00,0x47,0x19,
+0xDC,0x5F,0x39,0x00,0x4F,0x39,0x10,0x4F,0x18,0x08,0x8F,0x19,0xC3,0x34,0x00,0x01,
+0x8F,0x19,0x0B,0x37,0x03,0x47,0x99,0xCF,0x0B,0x78,0x01,0x47,0x7B,0xE4,0x0B,0x97,
+0x05,0x47,0x39,0xE4,0x47,0x3B,0xCD,0x0F,0x38,0x01,0x9E,0xE6,0xD7,0x57,0xFE,0x5E,
+0xC3,0x54,0x00,0x01,0xCA,0xE0,0x11,0x50,0xCB,0x5A,0x22,0x00,0x57,0x37,0xFF,0x4F,
+0x39,0x10,0x8F,0x3A,0x0C,0x19,0x01,0x9E,0xE1,0xC3,0x14,0x00,0x01,0xC2,0xE2,0x2B,
+0x84,0x23,0xFF,0xAD,0xCA,0xF8,0x23,0x70,0x0C,0x17,0x01,0xCA,0xF8,0x23,0x74,0x0C,
+0x17,0x01,0xCB,0x18,0x23,0x78,0x0C,0x18,0x01,0x0D,0x21,0x1E,0x1C,0x21,0x20,0x85,
+0x29,0x1C,0x21,0xE0,0xC0,0x98,0x00,0x21,0x0D,0x21,0x1C,0x1C,0x61,0x06,0xFC,0x84,
+0xB4,0xBE,0x50,0xA0,0x12,0xFC,0x84,0x01,0x9E,0xE7,0xFF,0x4E,0x82,0x1E,0xE1,0x06,
+0x1F,0x41,0x18,0x0B,0x37,0x01,0xFF,0x60,0xFF,0x00,0x47,0x19,0xDC,0x5F,0x39,0x00,
+0x4F,0x39,0x10,0x4F,0x18,0x08,0x8F,0x19,0xC3,0x34,0x00,0x01,0x8F,0x19,0x0B,0x37,
+0x03,0x47,0x99,0xCF,0x0B,0x78,0x01,0x47,0x7B,0xE4,0x0B,0x97,0x05,0x47,0x39,0xE4,
+0x47,0x3B,0xCD,0x0F,0x38,0x01,0x9E,0xE6,0xD7,0x57,0xFE,0x5E,0xC3,0x74,0x00,0x01,
+0xCA,0xE0,0x11,0x50,0xCB,0x7B,0x22,0x00,0xFF,0x40,0x11,0x11,0x57,0x37,0xFF,0x4F,
+0x39,0x10,0x8F,0x3B,0x0F,0x59,0x01,0x9E,0xE1,0xC3,0x14,0x00,0x01,0xC2,0xE2,0x2B,
+0x84,0x23,0xFF,0xAD,0xCB,0x38,0x23,0x70,0x9A,0xFF,0x0E,0xF9,0x01,0xCB,0x38,0x23,
+0x74,0x0E,0xF9,0x01,0xCB,0x18,0x23,0x78,0x0E,0xF8,0x01,0x0D,0x21,0x1E,0x1C,0x21,
+0x20,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x74,0xD8,0x18,0x18,0x00,0xCB,0x37,
+0x74,0x10,0x5C,0x63,0x00,0x18,0x79,0x00,0xCB,0x37,0x76,0x30,0x18,0x19,0x00,0x53,
+0x40,0x24,0xCB,0x37,0x74,0x00,0x1B,0x59,0x00,0xCB,0x77,0x74,0x28,0x53,0x20,0x60,
+0x1B,0x3B,0x00,0xCB,0x77,0x74,0x30,0x1B,0x3B,0x00,0xCB,0x77,0x74,0x38,0x53,0x20,
+0x1C,0x1B,0x3B,0x00,0xCB,0x77,0x74,0x40,0x1B,0x3B,0x00,0xCB,0x37,0x74,0xA8,0x13,
+0x39,0x00,0xCB,0x37,0x74,0x78,0x9B,0x69,0x1B,0x79,0x00,0xCB,0x37,0x74,0x70,0x18,
+0x19,0x00,0xCB,0x37,0x74,0x60,0x13,0x79,0x00,0x1B,0x59,0x00,0xCA,0xF7,0x74,0x61,
+0x13,0x37,0x00,0x18,0x17,0x00,0x98,0x61,0x12,0xF8,0x00,0x52,0xF7,0x01,0x1A,0xF8,
+0x00,0x85,0x29,0x5C,0x63,0x00,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0x20,0x18,0x77,
+0x00,0x0B,0x17,0x01,0xC7,0x18,0xFE,0xFF,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,
+0x01,0xCA,0xF7,0x74,0x68,0x10,0x77,0x00,0x4C,0x63,0x21,0x54,0x63,0x01,0x85,0x29,
+0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0xE0,0x10,0x77,0x00,0x4C,0x63,0x09,0x54,0x63,
+0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0x68,0x10,0x77,0x00,0x4C,0x63,
+0x29,0x54,0x63,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0xE0,0x10,0x77,
+0x00,0x4C,0x63,0x19,0x54,0x63,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,
+0x68,0x10,0x77,0x00,0x4C,0x63,0x11,0x54,0x63,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,
+0xCA,0xF7,0x74,0x68,0x08,0x77,0x01,0x4C,0x63,0x49,0x54,0x63,0x01,0x85,0x29,0xC2,
+0xF4,0x00,0x01,0xCA,0xF7,0x74,0x68,0x08,0x77,0x01,0x4C,0x63,0x51,0x54,0x63,0x01,
+0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0x61,0x13,0x17,0x00,0x57,0x18,0xFD,
+0x1B,0x17,0x00,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0x61,0x13,0x17,0x00,
+0x53,0x18,0x02,0x1B,0x17,0x00,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0xC0,
+0x12,0xF7,0x00,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0xA8,0x12,0xF7,0x00,
+0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0xC8,0x12,0xF7,0x00,0x85,0x29,0xC2,
+0xF4,0x00,0x01,0xCA,0xF7,0x74,0xA0,0x12,0xF7,0x00,0x85,0x29,0xC2,0xF4,0x00,0x01,
+0xCA,0xF7,0x74,0x20,0x10,0x77,0x00,0x85,0x29,0x5C,0x63,0x00,0xC3,0x14,0x00,0x01,
+0x4E,0xE3,0x10,0xCB,0x18,0x2A,0x00,0x8E,0xF8,0x08,0x77,0x00,0x9A,0xE8,0xCC,0x63,
+0x00,0x03,0x40,0x63,0xB8,0x85,0x29,0x5C,0x84,0x04,0x5E,0xE4,0x00,0xD2,0xEF,0x05,
+0xAD,0x4E,0xF7,0x10,0xC3,0x18,0x00,0x21,0xFF,0x18,0xBD,0x28,0x8E,0xF8,0xC3,0x34,
+0x00,0x01,0x0F,0x17,0x02,0xCA,0xF9,0x26,0x18,0x0B,0x57,0x01,0xC7,0x5A,0xFF,0xF3,
+0x1F,0x60,0xCF,0x0F,0x57,0x01,0x0B,0x57,0x01,0x47,0x5A,0xDC,0x53,0x5A,0x10,0x4C,
+0x84,0x49,0x0F,0x57,0x01,0x9A,0xE1,0xCB,0x59,0x26,0x20,0xE4,0x00,0x00,0x31,0x4F,
+0x37,0x08,0x9E,0xE1,0x8F,0x38,0x5E,0xF7,0x04,0x0B,0x39,0x01,0xC7,0x39,0x3F,0xFF,
+0x0F,0x3A,0x01,0xC3,0x34,0x00,0x01,0xD6,0xE4,0xFF,0x40,0x20,0x60,0x96,0xCB,0x39,
+0x26,0x38,0x0B,0x18,0x01,0x0A,0xF9,0x01,0x4F,0x18,0x60,0xFF,0x40,0x8F,0xFF,0xC7,
+0x18,0x70,0x00,0x46,0xF7,0xD4,0x46,0xF8,0xBD,0x0E,0xF9,0x01,0xE4,0x00,0x00,0x4B,
+0x20,0x64,0x86,0xCA,0xF9,0x26,0x38,0xFF,0x60,0xF8,0xFF,0x0B,0x38,0x01,0x0B,0x57,
+0x01,0x4F,0x39,0x40,0x47,0x1A,0xDC,0xC7,0x39,0x07,0x00,0x47,0x19,0xC5,0x0F,0x17,
+0x01,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x18,0x0B,0x17,0x01,0x53,0x18,0x30,0x0F,
+0x17,0x01,0x85,0x29,0x5C,0x84,0x00,0xD0,0x8F,0x03,0x9D,0xC2,0xF8,0x00,0x21,0xFE,
+0xF7,0xBC,0x50,0x4C,0x84,0x10,0xC3,0x14,0x00,0x01,0x8C,0x97,0xCB,0x38,0x26,0x34,
+0x0E,0xE4,0x02,0x0B,0x59,0x01,0x0B,0x77,0x03,0xFF,0x80,0xC0,0x00,0xC7,0x7B,0x3F,
+0xFF,0x47,0x5A,0xE4,0x47,0x5B,0xD5,0x0F,0x59,0x01,0x20,0x60,0x7E,0x0B,0x37,0x01,
+0xCB,0x18,0x26,0x38,0x4F,0x39,0x60,0x0B,0x58,0x01,0xFF,0x60,0x8F,0xFF,0xC7,0x39,
+0x70,0x00,0x46,0xFA,0xDC,0xE4,0x00,0x00,0x3F,0x20,0x64,0x86,0x0B,0x37,0x01,0xCB,
+0x18,0x26,0x38,0x4F,0x39,0x40,0x0B,0x58,0x01,0xFF,0x80,0xF8,0xFF,0xC7,0x39,0x07,
+0x00,0x46,0xFA,0xE4,0x46,0xF9,0xBD,0x0E,0xF8,0x01,0x85,0x29,0x5C,0x84,0x00,0xD0,
+0x8C,0x04,0x1D,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xBC,0x50,0x4C,0x84,0x10,0xFF,0x40,
+0xC0,0x00,0x8C,0x97,0x0E,0xE4,0x02,0x20,0x60,0xD6,0xC3,0x14,0x00,0x01,0x0B,0x77,
+0x03,0xCB,0x38,0x26,0xC4,0xC7,0x7B,0x3F,0xFF,0x0B,0x99,0x01,0x47,0x5C,0xD4,0x47,
+0x5B,0xD5,0xCB,0x18,0x26,0x38,0x0F,0x59,0x01,0x1F,0x60,0x8F,0x0B,0x37,0x01,0x0B,
+0x58,0x01,0x4F,0x39,0x20,0x57,0x39,0x70,0xE4,0x00,0x00,0x63,0x20,0x64,0xDA,0xC3,
+0x14,0x00,0x01,0x0B,0x77,0x03,0xCB,0x38,0x26,0xC8,0xC7,0x7B,0x3F,0xFF,0x0B,0x99,
+0x01,0x47,0x5C,0xD4,0x47,0x5B,0xD5,0xCB,0x18,0x26,0x38,0x0F,0x59,0x01,0x9B,0x78,
+0x0B,0x37,0x01,0x0B,0x58,0x01,0x57,0x39,0x07,0x46,0xFA,0xDC,0x46,0xF9,0xBD,0x0E,
+0xF8,0x01,0x85,0x29,0x5C,0x84,0x04,0x20,0x60,0x28,0x20,0x64,0xEE,0xE4,0x00,0x00,
+0x39,0xC2,0xF4,0x00,0x01,0x4C,0x84,0x41,0xCA,0xF7,0x26,0xC0,0x54,0x84,0x3F,0x0B,
+0x17,0x01,0x1F,0x20,0xC0,0xE4,0x00,0x00,0x2F,0xC2,0xF4,0x00,0x01,0xC4,0x84,0x3F,
+0x00,0xCA,0xF7,0x26,0xC0,0xFF,0x20,0xC0,0xFF,0x0B,0x17,0x01,0x47,0x18,0xCC,0x44,
+0x84,0xC5,0x0C,0x97,0x01,0x85,0x29,0x20,0x61,0x52,0x20,0x84,0x84,0x20,0x80,0x2C,
+0xD0,0x82,0x04,0xD6,0xE4,0x00,0x00,0x5D,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x30,
+0x0B,0x17,0x01,0xC7,0x18,0x3F,0xFF,0xE4,0x00,0x01,0x01,0xC2,0xF4,0x00,0x01,0xFF,
+0x20,0x80,0x00,0xCA,0xF7,0x26,0x30,0x0B,0x17,0x01,0xC7,0x18,0x3F,0xFF,0xE4,0x00,
+0x00,0x27,0xC2,0xF4,0x00,0x01,0xFF,0x20,0xC0,0x00,0xCA,0xF7,0x26,0x30,0x0B,0x17,
+0x01,0x47,0x18,0xCD,0x5F,0x18,0x04,0xE4,0x00,0x00,0xA1,0x20,0x65,0x3E,0x20,0x84,
+0x80,0x20,0x80,0x28,0x20,0x89,0x1A,0xE4,0x00,0x00,0x63,0xC2,0xF4,0x00,0x01,0xCA,
+0xF7,0x26,0x30,0x0B,0x17,0x01,0xC7,0x18,0xCF,0xFF,0xE4,0x00,0x00,0x5B,0xC2,0xF4,
+0x00,0x01,0xFF,0x20,0xCF,0xFF,0xCA,0xF7,0x26,0x30,0x0B,0x17,0x01,0x47,0x18,0xCC,
+0xCB,0x18,0x20,0x00,0xE4,0x00,0x00,0x27,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x30,
+0x0B,0x17,0x01,0xCB,0x18,0x30,0x00,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x72,0xC2,
+0xF4,0x00,0x01,0xFF,0x20,0x80,0x00,0xCA,0xF7,0x26,0x24,0x0B,0x17,0x01,0x47,0x18,
+0xCD,0x5F,0x18,0x04,0xE4,0x00,0x00,0x2D,0x20,0x60,0x56,0xC2,0xF4,0x00,0x01,0xCA,
+0xF7,0x26,0x24,0x0B,0x17,0x01,0xC7,0x18,0x7F,0xFF,0x0F,0x17,0x01,0x85,0x29,0x20,
+0x64,0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x24,0x0B,0x17,0x01,0xCB,0x18,0x20,
+0x00,0xE4,0x00,0x00,0x2D,0x20,0x60,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x24,
+0x0B,0x17,0x01,0xC7,0x18,0xDF,0xFF,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x5A,0xC2,
+0xF4,0x00,0x01,0xCA,0xF7,0x26,0x24,0x0B,0x17,0x01,0xCB,0x18,0x40,0x00,0xE4,0x00,
+0x00,0x2D,0x20,0x60,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x24,0x0B,0x17,0x01,
+0xC7,0x18,0xBF,0xFF,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x5A,0xC2,0xF4,0x00,0x01,
+0xCA,0xF7,0x26,0x24,0x0B,0x17,0x01,0xCB,0x18,0x10,0x00,0xE4,0x00,0x00,0x2D,0x20,
+0x60,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x24,0x0B,0x17,0x01,0xC7,0x18,0xEF,
+0xFF,0x0F,0x17,0x01,0x85,0x29,0x9C,0x38,0xC2,0xF4,0x00,0x01,0x0D,0x21,0x04,0xCA,
+0xF7,0x26,0x18,0x0B,0x17,0x01,0xCB,0x18,0x40,0x00,0x98,0x60,0x0F,0x17,0x01,0xE7,
+0xFF,0xFF,0x1A,0x0D,0x21,0x06,0x98,0x60,0x9C,0x28,0xE7,0xFF,0xFF,0x5F,0x20,0x64,
+0x72,0xC2,0xF4,0x00,0x01,0xFF,0x20,0x80,0x00,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,
+0x47,0x18,0xCD,0x5F,0x18,0x04,0xE4,0x00,0x00,0x2D,0x20,0x60,0x56,0xC2,0xF4,0x00,
+0x01,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,0xC7,0x18,0x7F,0xFF,0x0F,0x17,0x01,0x85,
+0x29,0x20,0x64,0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,0xCB,
+0x18,0x20,0x00,0xE4,0x00,0x00,0x2D,0x20,0x60,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,
+0x26,0x00,0x0B,0x17,0x01,0xC7,0x18,0xDF,0xFF,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,
+0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,0xCB,0x18,0x40,0x00,
+0xE4,0x00,0x00,0x2D,0x20,0x60,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x00,0x0B,
+0x17,0x01,0xC7,0x18,0xBF,0xFF,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x5A,0xC2,0xF4,
+0x00,0x01,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,0xCB,0x18,0x10,0x00,0xE4,0x00,0x00,
+0x2D,0x20,0x60,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,0xC7,
+0x18,0xEF,0xFF,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x5A,0xC2,0xF4,0x00,0x01,0xCA,
+0xF7,0x26,0x00,0x0B,0x17,0x01,0xCB,0x18,0x08,0x00,0xE4,0x00,0x00,0x2D,0x20,0x60,
+0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,0xC7,0x18,0xF7,0xFF,
+0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x00,
+0x0B,0x17,0x01,0xCB,0x18,0x04,0x00,0xE4,0x00,0x00,0x2D,0x20,0x60,0x56,0xC2,0xF4,
+0x00,0x01,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,0xC7,0x18,0xFB,0xFF,0x0F,0x17,0x01,
+0x85,0x29,0x5C,0x63,0x00,0xC2,0xF4,0x00,0x01,0x4F,0x23,0x40,0xCA,0xF7,0x26,0x14,
+0x4C,0x63,0x60,0x0B,0x17,0x01,0x44,0x79,0x1D,0x5F,0x18,0x00,0x44,0x63,0xC5,0x5C,
+0x63,0x04,0x0C,0x77,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xFF,0x20,0xF0,0x00,0xCB,
+0x17,0x26,0x0C,0xC4,0x63,0x0F,0xFF,0x0B,0x58,0x01,0x5C,0x63,0x06,0x47,0x5A,0xCC,
+0x47,0x43,0xD5,0x0F,0x58,0x01,0xCA,0xF7,0x26,0x10,0x0B,0x17,0x01,0x47,0x38,0xCC,
+0x44,0x63,0xCD,0x0C,0x77,0x01,0x85,0x29,0x9C,0x38,0xFF,0x00,0xE0,0x00,0x0D,0x21,
+0x04,0x0D,0x41,0x00,0xC1,0x54,0x00,0x01,0xCA,0xEA,0x26,0x04,0x0B,0x37,0x01,0x47,
+0x39,0xC4,0xCB,0x39,0x0F,0xA0,0x0F,0x37,0x01,0xCA,0xEA,0x26,0x08,0x0B,0x37,0x01,
+0x47,0x19,0xC4,0xCB,0x18,0x10,0x60,0x98,0x60,0x0F,0x17,0x01,0xFC,0x80,0x08,0x03,
+0xE7,0xFF,0xF9,0x28,0xCA,0xEA,0x26,0xC0,0xFF,0x20,0xC0,0xFF,0x0B,0x17,0x01,0x47,
+0x18,0xCC,0xCB,0x18,0x08,0x00,0x98,0x60,0x0F,0x17,0x01,0xFC,0x80,0x08,0x03,0xE7,
+0xFF,0xF7,0xDA,0x98,0x61,0xFC,0x80,0x08,0x03,0xE7,0xFF,0xF7,0xC6,0xCA,0xEA,0x26,
+0x00,0x0B,0x17,0x01,0x53,0x18,0x0F,0x0F,0x17,0x01,0x0B,0x17,0x01,0xC7,0x18,0xFF,
+0x7F,0x0F,0x17,0x01,0x0B,0x17,0x01,0xC7,0x18,0xFF,0xBF,0x98,0x68,0x0F,0x17,0x01,
+0xE7,0xFF,0xFE,0x44,0x0D,0x21,0x06,0x0D,0x41,0x02,0xFC,0x60,0x01,0x2C,0x9C,0x28,
+0xE7,0xFF,0xFE,0x6F,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x78,0x00,0x0B,0x17,0x01,0x53,
+0x18,0x02,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x78,0x00,0x0B,
+0x17,0x01,0xC7,0x18,0xFF,0xFD,0x0F,0x17,0x01,0x85,0x29,0x9C,0x7F,0x5C,0x63,0x00,
+0xD0,0x64,0x05,0x15,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xBE,0xE8,0x4C,0x63,0x10,0xFF,
+0x00,0xFC,0xFF,0x8C,0x77,0xC2,0xF4,0x00,0x01,0x0F,0x23,0x02,0x87,0x29,0xCB,0x17,
+0x3D,0x3C,0xCA,0xF7,0x31,0x04,0x0B,0x38,0x01,0x53,0x39,0x01,0x0F,0x38,0x01,0x0B,
+0x17,0x01,0xC7,0x18,0xFC,0xFF,0xE4,0x00,0x00,0xD3,0xCB,0x37,0x3D,0x3C,0xCA,0xF7,
+0x31,0x04,0x0B,0x59,0x01,0x53,0x5A,0x01,0x0F,0x59,0x01,0x0B,0x37,0x01,0x47,0x19,
+0xC4,0xCB,0x18,0x01,0x00,0xE4,0x00,0x00,0x95,0xCB,0x37,0x3D,0x3C,0xCA,0xF7,0x31,
+0x04,0x0B,0x59,0x01,0x53,0x5A,0x01,0x0F,0x59,0x01,0x0B,0x37,0x01,0x47,0x19,0xC4,
+0xCB,0x18,0x02,0x00,0xE4,0x00,0x00,0x57,0xCA,0xF7,0x3D,0x3C,0x0B,0x17,0x01,0xC7,
+0x18,0xFF,0xFE,0xE4,0x00,0x00,0x39,0xCB,0x17,0x3C,0x10,0xCA,0xF7,0x3C,0x14,0x0B,
+0x38,0x01,0x53,0x39,0x01,0x0F,0x38,0x01,0x0B,0x17,0x01,0xC7,0x18,0xFF,0xFD,0x0F,
+0x17,0x01,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x78,0x00,0x0B,0x17,0x01,0xC7,0x18,0xFF,
+0xFB,0x0F,0x17,0x01,0x85,0x29,0x5C,0x63,0x00,0x5C,0x84,0x00,0x9A,0xE0,0x24,0x64,
+0x43,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xBE,0xFC,0x8C,0x77,0x12,0xE3,0x00,0xC3,0x14,
+0x00,0x01,0xCB,0x18,0x78,0x01,0x4E,0xF7,0x10,0x5C,0x80,0x29,0x46,0xF7,0xC5,0x4B,
+0x00,0x1A,0x1B,0x17,0x00,0x85,0x29,0xC2,0xF4,0x00,0x01,0x5C,0x84,0x04,0xCB,0x17,
+0x79,0x04,0xCC,0x84,0x17,0x70,0x4F,0x24,0x81,0x5C,0x84,0x04,0x0F,0x38,0x01,0xCA,
+0xF7,0x79,0x00,0x0C,0x97,0x01,0x98,0x81,0xE7,0xFF,0xFF,0x5D,0xC2,0xF4,0x00,0x01,
+0xCA,0xF7,0x78,0xCC,0x0B,0x17,0x01,0x53,0x18,0x02,0x0F,0x17,0x01,0x85,0x29,0xC2,
+0xF4,0x00,0x01,0xCB,0x17,0x7A,0x30,0xCB,0x37,0x7A,0x34,0xCB,0x57,0x7A,0x10,0xCA,
+0xF7,0x7A,0x14,0x0B,0x18,0x01,0x0B,0x39,0x01,0x0B,0x5A,0x01,0x08,0x77,0x01,0x4E,
+0xF9,0x80,0x4C,0x63,0x80,0x8E,0xF8,0x8C,0x7A,0x44,0x63,0x1F,0x44,0x63,0xBC,0x85,
+0x29,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x7A,0x70,0xCB,0x37,0x7A,0x74,0xCB,0x57,0x7A,
+0x50,0xCA,0xF7,0x7A,0x54,0x0B,0x18,0x01,0x0B,0x39,0x01,0x0B,0x5A,0x01,0x08,0x77,
+0x01,0x4E,0xF9,0x80,0x4C,0x63,0x80,0x8E,0xF8,0x8C,0x7A,0x44,0x63,0x1F,0x44,0x63,
+0xBC,0x85,0x29,0x5C,0x63,0x06,0xC2,0xF4,0x00,0x01,0x47,0x23,0x1F,0xCA,0xF7,0x7A,
+0x10,0x0B,0x17,0x01,0x47,0x19,0xC4,0x44,0x63,0xC5,0x5C,0x63,0x04,0x0C,0x77,0x01,
+0x85,0x29,0x5C,0x63,0x06,0xC2,0xF4,0x00,0x01,0x47,0x23,0x1F,0xCA,0xF7,0x7A,0x50,
+0x0B,0x17,0x01,0x47,0x19,0xC4,0x44,0x63,0xC5,0x5C,0x63,0x04,0x0C,0x77,0x01,0x85,
+0x29,0xC2,0xF4,0x00,0x01,0x44,0x63,0x1F,0xCA,0xF7,0x7A,0x10,0x0B,0x17,0x01,0x47,
+0x18,0x1C,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0x44,0x63,0x1F,0xCA,0xF7,
+0x7A,0x50,0x0B,0x17,0x01,0x47,0x18,0x1C,0x0F,0x17,0x01,0x85,0x29,0x5C,0x63,0x04,
+0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x7A,0x30,0x0C,0x77,0x01,0x85,0x29,0x9B,0x01,0xC2,
+0xF4,0x00,0x01,0xCA,0xF7,0x7A,0x70,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,
+0xFF,0x20,0xAA,0x55,0xCB,0x17,0x78,0xC0,0x0F,0x38,0x01,0x5F,0x03,0x04,0x27,0x08,
+0x17,0x98,0x63,0xCA,0xF7,0x78,0xC4,0x5C,0x63,0x04,0xCB,0x00,0x03,0xE8,0x43,0x04,
+0xC1,0x40,0x63,0xC3,0x4C,0x63,0x81,0x44,0x63,0x1F,0x0C,0x77,0x01,0x06,0xE0,0x5B,
+0xCA,0xF7,0x8D,0x80,0x5C,0x97,0x0D,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x3C,0x44,0x0B,
+0x17,0x01,0x20,0x00,0x2D,0xC7,0x18,0xFF,0xBF,0xE4,0x00,0x00,0x15,0x5F,0x18,0x04,
+0x53,0x18,0x40,0x0F,0x17,0x01,0x85,0x29,0xFF,0x00,0xAA,0x55,0xC2,0xF4,0x00,0x01,
+0xCA,0xF7,0x78,0xC0,0x0F,0x17,0x01,0x85,0x29,0xFF,0x00,0x55,0xAA,0xC2,0xF4,0x00,
+0x01,0xCA,0xF7,0x78,0xC0,0x0F,0x17,0x01,0x85,0x29,0xCA,0xE0,0x03,0x20,0xC3,0x14,
+0x00,0x01,0x5C,0x63,0x04,0xC0,0x60,0x63,0xEA,0x48,0x63,0xB8,0xCA,0xF8,0x79,0x10,
+0x0B,0x37,0x01,0x53,0x39,0x01,0x0F,0x37,0x01,0xCB,0x58,0x79,0x00,0xCB,0x38,0x79,
+0x08,0x9C,0x38,0x0A,0xF9,0x01,0xCB,0x18,0x3C,0x44,0x0B,0x7A,0x01,0x0B,0x39,0x01,
+0x0F,0x21,0x07,0x0B,0x18,0x01,0x57,0x18,0x40,0x5F,0x18,0x04,0x23,0x00,0x40,0x4C,
+0x63,0x29,0x5C,0x60,0x09,0x48,0x63,0x0A,0xE4,0x00,0x00,0x3F,0xCC,0x63,0x00,0x06,
+0x5C,0x63,0x04,0xE4,0x00,0x00,0x29,0x0A,0xF8,0x01,0x52,0xF7,0x01,0x0E,0xF8,0x01,
+0x0A,0xF9,0x01,0xE4,0x00,0x00,0x21,0xC3,0x34,0x00,0x01,0xCB,0x19,0x79,0x10,0xCB,
+0x39,0x79,0x08,0x0B,0x41,0x07,0x43,0x57,0xD5,0xD4,0x7A,0x00,0xB8,0x0B,0x41,0x07,
+0xD7,0x57,0xFE,0xB9,0x0B,0x41,0x07,0x43,0x5B,0xD5,0x8E,0xFA,0xD4,0x77,0xFE,0x5C,
+0x9C,0x28,0x85,0x29,0x5C,0x63,0x04,0xE4,0x00,0x00,0x2D,0x42,0xE4,0x2C,0xC3,0x38,
+0x00,0x01,0x43,0x05,0xCC,0x8F,0x03,0x13,0x18,0x00,0x1B,0x17,0x00,0x9C,0xBF,0x20,
+0xBF,0xB2,0x85,0x29,0xC3,0x14,0x00,0x01,0x5C,0x63,0x00,0xCA,0xF8,0x2C,0x30,0x20,
+0x60,0xBE,0x0B,0x17,0x01,0xCB,0x18,0x02,0x00,0x0F,0x17,0x01,0x80,0x01,0xC2,0xF4,
+0x00,0x01,0xCB,0x17,0x3C,0x44,0xCA,0xF7,0x3C,0xA8,0x0B,0x38,0x01,0xC7,0x39,0xFF,
+0xF3,0x0F,0x38,0x01,0x0B,0x17,0x01,0x53,0x18,0x01,0xE4,0x00,0x00,0xB3,0x0B,0x37,
+0x01,0xCB,0x39,0x02,0x00,0x0F,0x37,0x01,0xCA,0xF8,0x3C,0xA8,0x0B,0x37,0x01,0x53,
+0x39,0x01,0xCB,0x18,0x3C,0x5C,0x0F,0x37,0x01,0x1E,0xE0,0xC0,0x0B,0x38,0x00,0x47,
+0x39,0xBC,0x9A,0xE2,0x24,0x64,0x25,0x54,0x63,0x3F,0x5E,0xE3,0x06,0x46,0xF7,0xCD,
+0x5C,0x77,0x04,0xC2,0xF4,0x00,0x01,0x0C,0x78,0x01,0xCB,0x17,0x3C,0xA8,0xCA,0xF7,
+0x2C,0x30,0x0B,0x38,0x01,0xC7,0x39,0xFF,0xFE,0x0F,0x38,0x01,0x0B,0x17,0x01,0xCB,
+0x18,0x01,0x00,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x3C,0xA8,
+0x0B,0x18,0x01,0x57,0x18,0x01,0x23,0x00,0x46,0xCA,0xF7,0x3C,0x5C,0x08,0x77,0x01,
+0x54,0x63,0x3F,0xE4,0x00,0x00,0x0D,0x98,0x60,0x85,0x29,0x80,0x01,0xC2,0xF4,0x00,
+0x01,0xCA,0xF7,0x1E,0xB0,0x0B,0x17,0x01,0x53,0x18,0x03,0x0F,0x17,0x01,0x80,0x01,
+0x9B,0x1F,0xCA,0xE0,0x48,0x00,0xC3,0x17,0x00,0x0D,0xCA,0xE0,0x48,0x04,0xC3,0x17,
+0x00,0x0D,0x80,0x01,0xCA,0xE0,0x40,0x00,0xC3,0x17,0x00,0x0F,0x53,0x18,0x40,0xC3,
+0x17,0x00,0x0D,0xC3,0x17,0x00,0x0F,0x1F,0x20,0xBF,0x47,0x18,0xCC,0xC3,0x17,0x00,
+0x0D,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x3D,0x80,0x0B,0x38,0x01,0xCB,0x39,
+0x08,0x00,0x0F,0x38,0x01,0xCA,0xF7,0x3D,0x84,0x0B,0x17,0x01,0xCB,0x18,0x08,0x00,
+0x0F,0x17,0x01,0x85,0x29,0xE7,0xFF,0xFF,0xBD,0x56,0xE3,0xFF,0x4E,0xF7,0x08,0x5C,
+0x84,0x04,0xC4,0x63,0xFF,0x00,0x8C,0x77,0xC2,0xF4,0x00,0x01,0x4C,0x63,0x08,0x8C,
+0x77,0x0C,0x83,0x01,0x85,0x29,0x1C,0x21,0xC8,0xC0,0x98,0x00,0x21,0x0D,0x21,0x34,
+0x1C,0x61,0x06,0xFC,0x84,0xB6,0x6E,0x50,0xA0,0x2A,0xE7,0xFF,0x35,0x80,0x1E,0xE1,
+0x06,0x1F,0x41,0x30,0x0B,0x37,0x01,0xFF,0x60,0xFF,0x00,0x47,0x19,0xDC,0x5F,0x39,
+0x00,0x4F,0x39,0x10,0x4F,0x18,0x08,0x8F,0x19,0xC3,0x34,0x00,0x01,0x8F,0x19,0x0B,
+0x37,0x03,0x47,0x99,0xCF,0x0B,0x78,0x01,0x47,0x7B,0xE4,0x0B,0x97,0x05,0x47,0x39,
+0xE4,0x47,0x3B,0xCD,0x0F,0x38,0x01,0x9E,0xE6,0xD7,0x57,0xFE,0x5E,0x0D,0x21,0x36,
+0x1C,0x21,0x38,0x85,0x29,0xFC,0x21,0xFF,0x38,0x50,0xA0,0x3C,0xED,0x21,0x00,0xC4,
+0xED,0x41,0x00,0xC0,0xED,0x61,0x00,0xBC,0xED,0x81,0x00,0xB8,0xED,0xA1,0x00,0xB4,
+0xED,0xC1,0x00,0xB0,0xED,0xE1,0x00,0xAC,0xEE,0x01,0x00,0xA8,0xC1,0x58,0x00,0x21,
+0x1C,0x61,0x6C,0xFD,0x4A,0xB6,0x6E,0x1C,0x8A,0x2A,0xE7,0xFF,0x34,0x80,0x50,0xA0,
+0x24,0x1C,0x8A,0x66,0x1C,0x61,0x48,0xE7,0xFF,0x34,0x66,0x98,0x61,0x98,0x82,0xE7,
+0xFF,0xEE,0x30,0x98,0x61,0xFC,0x80,0x28,0x0A,0xE7,0xFF,0xD5,0x4C,0x98,0x61,0xFC,
+0x80,0x28,0x0A,0xE7,0xFF,0xEB,0x82,0x98,0x61,0x88,0x83,0xE7,0xFF,0xD8,0x00,0x98,
+0x61,0x88,0x83,0xE7,0xFF,0xD5,0x88,0x98,0x60,0x98,0x81,0xE7,0xFF,0xD6,0x78,0x98,
+0x60,0x05,0x4F,0x0F,0xC9,0x4A,0x0F,0x0F,0x88,0x8A,0xE7,0xFF,0xE0,0x38,0x98,0x61,
+0x88,0x8A,0xE7,0xFF,0xE0,0x28,0xC3,0x54,0x00,0x01,0xCA,0xE0,0x11,0x50,0xCB,0x5A,
+0x22,0x00,0x57,0x17,0xFF,0x4F,0x18,0x10,0x8F,0x1A,0x1F,0x61,0x2A,0x0B,0x38,0x01,
+0x4F,0x17,0x08,0x8F,0x1B,0xEF,0x38,0xDD,0x61,0x9E,0xE1,0xC2,0xE2,0x2B,0xE4,0x23,
+0xFF,0x8D,0x1E,0xE1,0x6C,0xFF,0x41,0x00,0xA8,0xC1,0x94,0x00,0x01,0xFD,0xA0,0xFF,
+0x00,0x0B,0x37,0x01,0x47,0x19,0x6C,0x5F,0x39,0x00,0x4F,0x39,0x10,0x4F,0x18,0x08,
+0x8F,0x19,0x0B,0x37,0x03,0x8F,0x0C,0x0F,0x38,0x01,0x9E,0xE4,0xD7,0x57,0xFF,0x2E,
+0x1E,0xE1,0x48,0x1F,0x41,0x6C,0x0B,0x37,0x01,0x47,0x19,0x6C,0x5F,0x39,0x00,0x4F,
+0x39,0x10,0x4F,0x18,0x08,0x8F,0x19,0x0B,0x37,0x03,0x8F,0x0C,0x0F,0x38,0x01,0x9E,
+0xE4,0xD7,0x57,0xFF,0x2E,0xE7,0xFF,0xD1,0x52,0x99,0xE0,0x89,0xC3,0x98,0x61,0xE7,
+0xFF,0xD1,0x68,0xD1,0xE0,0x05,0xBE,0x98,0x60,0x1D,0x61,0x0A,0xE7,0xFF,0xD1,0xA2,
+0x99,0x40,0xE4,0x00,0x01,0x45,0x98,0x61,0x88,0x8A,0x22,0x01,0x0A,0xE7,0xFF,0xDD,
+0x3A,0x98,0x60,0xE7,0xFF,0xDD,0x84,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF7,0x2C,0xE7,
+0xFF,0xCF,0x6E,0xE7,0xFF,0xF5,0xD8,0xC4,0x63,0x01,0x00,0x20,0x63,0xE0,0xFC,0x60,
+0x01,0x00,0xE7,0xFF,0xF6,0x82,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF7,0x46,0x88,0x6A,
+0x98,0x81,0x98,0xA0,0xE7,0xFF,0xE7,0xAA,0xE4,0x00,0x00,0x8B,0xE7,0xFF,0xDC,0xBC,
+0x98,0x61,0xE7,0xFF,0xDD,0x06,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF6,0xAE,0xE7,0xFF,
+0xCE,0xF0,0xE7,0xFF,0xF5,0x5A,0xC4,0x63,0x01,0x00,0x20,0x63,0xE0,0xFC,0x60,0x01,
+0x00,0xE7,0xFF,0xF6,0x04,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF6,0xC8,0x88,0x6A,0x98,
+0x81,0x98,0xA0,0xE7,0xFF,0xE7,0x2C,0x0A,0xEB,0x01,0x40,0x63,0xBD,0x0C,0x6B,0x01,
+0x9E,0x01,0x5E,0x10,0x00,0xD2,0x02,0xFB,0x8E,0x9D,0x41,0x9D,0x62,0x5D,0x4A,0x00,
+0xD1,0x44,0x05,0xEA,0x9A,0x00,0xE7,0xFF,0xFE,0xC1,0x98,0x61,0x1D,0x61,0x12,0xE7,
+0xFF,0xD0,0x3C,0x99,0x40,0xE4,0x00,0x01,0x45,0x98,0x61,0x88,0x8A,0x22,0x01,0x0A,
+0xE7,0xFF,0xDB,0xD4,0x98,0x60,0xE7,0xFF,0xDC,0x1E,0xFC,0x60,0x01,0x00,0xE7,0xFF,
+0xF5,0xC6,0xE7,0xFF,0xCE,0x08,0xE7,0xFF,0xF4,0x72,0xC4,0x63,0x01,0x00,0x20,0x63,
+0xE0,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF5,0x1C,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF5,
+0xE0,0x88,0x6A,0x98,0x81,0x98,0xA0,0xE7,0xFF,0xE6,0x44,0xE4,0x00,0x00,0x8B,0xE7,
+0xFF,0xDB,0x56,0x98,0x61,0xE7,0xFF,0xDB,0xA0,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF5,
+0x48,0xE7,0xFF,0xCD,0x8A,0xE7,0xFF,0xF3,0xF4,0xC4,0x63,0x01,0x00,0x20,0x63,0xE0,
+0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF4,0x9E,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF5,0x62,
+0x88,0x6A,0x98,0x81,0x98,0xA0,0xE7,0xFF,0xE5,0xC6,0x0A,0xEB,0x01,0x40,0x63,0xBD,
+0x0C,0x6B,0x01,0x9E,0x01,0x5E,0x10,0x00,0xD2,0x02,0xFB,0x8E,0x9D,0x41,0x9D,0x62,
+0x5D,0x4A,0x00,0xD1,0x44,0x00,0x52,0x9A,0x00,0xE7,0xFF,0xFE,0xC1,0x9D,0xE1,0x5D,
+0xEF,0x00,0xD1,0xE2,0xF4,0x8E,0x0B,0x21,0x0A,0x0B,0x01,0x12,0x0F,0x21,0x07,0x1E,
+0xE1,0x0C,0x1F,0x81,0x12,0x0B,0x77,0x01,0x8B,0x59,0x5F,0xBB,0x06,0xD7,0x3D,0x00,
+0x30,0x8B,0x5B,0x5F,0x3A,0x06,0x0B,0x77,0x09,0x8B,0x58,0x5F,0xBB,0x06,0xD7,0x1D,
+0x00,0x30,0x8B,0x5B,0x5F,0x1A,0x06,0x9E,0xE2,0xD7,0x97,0xFE,0xE6,0x0F,0x21,0x07,
+0x9A,0xE0,0x0F,0x01,0x09,0x1F,0x21,0x1A,0x8B,0x57,0xFD,0x00,0x3F,0xFF,0xE4,0x00,
+0x00,0x69,0x43,0x7E,0xC4,0x0B,0x9B,0x00,0x43,0x79,0xC4,0x23,0x80,0x32,0x0D,0x1B,
+0x01,0x9B,0x41,0xE4,0x00,0x00,0x23,0x09,0x5D,0x00,0xCD,0x4A,0x1F,0xFF,0x43,0x8A,
+0xE0,0x0F,0x9B,0x01,0x9F,0x02,0xD3,0x08,0xFE,0xE6,0x9F,0x28,0x9E,0xE2,0xD2,0xE4,
+0x00,0xBA,0x1F,0x01,0x0A,0x4F,0xD7,0x10,0x1F,0xA1,0x06,0x8F,0xD8,0x8F,0xB7,0x9B,
+0x00,0xE7,0xFF,0xFF,0x83,0xC3,0x94,0x00,0x01,0x9A,0xE0,0xCB,0x9C,0x24,0x00,0xE4,
+0x00,0x00,0x47,0x43,0xB9,0xC4,0x43,0xDB,0xC4,0x57,0xBD,0xFF,0x0B,0xDE,0x01,0x4F,
+0xBD,0x10,0x8F,0xBC,0x0F,0xDD,0x01,0x9F,0x02,0xD3,0x08,0xFF,0x56,0x9E,0xE1,0x22,
+0xE8,0x54,0x1F,0x21,0x1A,0x4F,0x77,0x18,0x9B,0x00,0x8F,0x79,0xFF,0x37,0x12,0x46,
+0xE7,0xFF,0xFF,0xA7,0x9A,0xE0,0x4F,0x17,0x08,0x1F,0x61,0x6C,0x8F,0x1B,0x0B,0x38,
+0x01,0x47,0x19,0x6C,0x5F,0x39,0x00,0x4F,0x39,0x10,0x4F,0x18,0x08,0x8F,0x19,0x1F,
+0x21,0x2A,0x8F,0x0C,0x8F,0x37,0x0B,0x39,0x01,0x0F,0x38,0x01,0x9E,0xE2,0x5E,0xE3,
+0xC9,0x23,0xFF,0x55,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x25,0x38,0x0B,0x17,0x01,0x23,
+0x40,0x34,0x5F,0x18,0x04,0x53,0x18,0x0F,0xE4,0x00,0x00,0x11,0xC7,0x18,0xFF,0xF0,
+0x0F,0x17,0x01,0x98,0x60,0x98,0x80,0xE7,0xFF,0xD9,0xDE,0x98,0x80,0x98,0x61,0xE7,
+0xFF,0xD9,0xCE,0x98,0x60,0xE7,0xFF,0xD8,0x80,0x98,0x60,0x98,0x80,0xE7,0xFF,0xD8,
+0x1A,0x88,0x6E,0xEE,0x01,0x00,0xAA,0xED,0xE1,0x00,0xAE,0xED,0xC1,0x00,0xB2,0xED,
+0xA1,0x00,0xB6,0xED,0x81,0x00,0xBA,0xED,0x61,0x00,0xBE,0xED,0x41,0x00,0xC2,0xED,
+0x21,0x00,0xC6,0xFC,0x21,0x00,0xC8,0xE7,0xFF,0xCB,0xB9,0xC2,0xF4,0x00,0x01,0x53,
+0x20,0x1F,0xCB,0x17,0x3C,0x30,0x0F,0x38,0x01,0xCC,0x63,0x61,0xA8,0xCB,0x17,0x3C,
+0x90,0xCA,0xF7,0x3C,0x38,0x0B,0x18,0x01,0x43,0x03,0xC1,0x4F,0x18,0x29,0x9F,0x1F,
+0x5F,0x18,0x04,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0x54,0x63,0x62,0xCA,
+0xF7,0x3C,0x94,0x50,0x63,0x02,0x0B,0x17,0x01,0x1F,0x20,0x9D,0x47,0x18,0xCC,0x47,
+0x03,0xC5,0x0F,0x17,0x01,0x85,0x29,0x5C,0x63,0x04,0xC6,0xE3,0x02,0x00,0x5E,0xF7,
+0x04,0x22,0xE0,0x70,0xC2,0xF4,0x00,0x01,0xFF,0x20,0xFC,0xFF,0xCA,0xF7,0x2C,0x54,
+0x0B,0x17,0x01,0x47,0x18,0xCC,0xCB,0x18,0x01,0x00,0x0F,0x17,0x01,0xC6,0xE3,0x04,
+0x00,0x5E,0xF7,0x04,0x22,0xE0,0xB8,0xC2,0xF4,0x00,0x01,0xFF,0x00,0xA5,0x5A,0xCB,
+0x37,0x30,0xCC,0x0F,0x19,0x01,0xCB,0x37,0x30,0xD0,0x0F,0x19,0x01,0xCA,0xF7,0x31,
+0x04,0xFF,0x40,0x8F,0xFF,0x0B,0x17,0x01,0x47,0x18,0xD4,0xCB,0x18,0x30,0x00,0x0F,
+0x17,0x01,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x3C,0x98,0x0B,0x38,0x01,0xFF,0x20,0x01,
+0x01,0x0F,0x38,0x01,0xCB,0x17,0x3C,0xA0,0x0B,0x58,0x01,0x0F,0x38,0x01,0x1F,0x40,
+0x88,0xCB,0x17,0x3C,0xB4,0x0B,0x38,0x01,0x47,0x39,0xD4,0x53,0x39,0x33,0x0F,0x38,
+0x01,0xCB,0x17,0x3C,0xB0,0x0B,0x38,0x01,0x5F,0x39,0x00,0xCB,0x39,0x03,0x00,0x0F,
+0x38,0x01,0xCA,0xF7,0x3C,0x94,0xC4,0x63,0x07,0x00,0x0B,0x17,0x01,0xFF,0x20,0xF8,
+0xFF,0x47,0x18,0xCC,0x44,0x63,0xC5,0x0C,0x77,0x01,0x85,0x29,0x80,0x01,0x80,0x01,
+0x80,0x01,0x80,0x01,0x80,0x01,0xC8,0x80,0xAA,0x55,0xC0,0x74,0x00,0x01,0xC8,0x63,
+0x78,0xC0,0x0C,0x83,0x00,0xC0,0x74,0x00,0x01,0xC8,0x63,0x1F,0xDC,0x50,0x80,0x80,
+0x0C,0x83,0x00,0x04,0x20,0x80,0xC8,0x21,0x17,0xFC,0x1C,0x40,0xFD,0x44,0x21,0x14,
+0x28,0x00,0x74,0xC0,0x40,0x00,0x01,0xC8,0x42,0x36,0x00,0x84,0x49,0x0C,0x41,0x0C,
+0x0C,0x61,0x10,0x0C,0x81,0x14,0x0C,0xA1,0x18,0x0C,0xC1,0x1C,0x0C,0xE1,0x20,0x0D,
+0x01,0x24,0x0D,0x21,0x28,0x0D,0x41,0x2C,0x0D,0x61,0x30,0x0D,0x81,0x34,0x0D,0xA1,
+0x38,0x0D,0xC1,0x3C,0x0D,0xE1,0x40,0x0E,0x01,0x44,0x0E,0x21,0x48,0x0E,0x41,0x4C,
+0x0E,0x61,0x50,0x0E,0x81,0x54,0x0E,0xA1,0x58,0x0E,0xC1,0x5C,0x0E,0xE1,0x60,0x0F,
+0x01,0x64,0x0F,0x21,0x68,0x0F,0x41,0x6C,0x0F,0x61,0x70,0x0F,0x81,0x74,0x0F,0xA1,
+0x78,0x0F,0xC1,0x7C,0x1C,0x61,0x00,0xC1,0x00,0x00,0x01,0xC9,0x08,0xA1,0x18,0x85,
+0x08,0x90,0x23,0x00,0xC0,0x40,0x10,0x01,0xC8,0x42,0x03,0xB0,0xC0,0x60,0x10,0x01,
+0xC8,0x63,0x0D,0x80,0x5C,0x43,0x1F,0x20,0x00,0x2D,0x0C,0x02,0x00,0x1C,0x42,0x04,
+0x93,0xF4,0x85,0x29,0xC0,0x80,0x01,0x1F,0xC0,0x7F,0xFF,0xE1,0xC8,0x63,0xFF,0xF9,
+0x44,0x84,0x1C,0xC0,0x80,0x01,0x1D,0x0C,0x61,0x02,0xC0,0x60,0x02,0x0D,0x0C,0x61,
+0x06,0xC0,0x60,0x04,0x0D,0x0C,0x41,0x0E,0x0C,0x61,0x12,0x0C,0x81,0x16,0x0C,0xA1,
+0x1A,0x0C,0xC1,0x1E,0x0C,0xE1,0x22,0x0D,0x01,0x26,0x0D,0x21,0x2A,0x0D,0x41,0x2E,
+0x0D,0x61,0x32,0x0D,0x81,0x36,0x0D,0xA1,0x3A,0x0D,0xC1,0x3E,0x0D,0xE1,0x42,0x0E,
+0x01,0x46,0x0E,0x21,0x4A,0x0E,0x41,0x4E,0x0E,0x61,0x52,0x0E,0x81,0x56,0x0E,0xA1,
+0x5A,0x0E,0xC1,0x5E,0x0E,0xE1,0x62,0x0F,0x01,0x66,0x0F,0x21,0x6A,0x0F,0x41,0x6E,
+0x0F,0x61,0x72,0x0F,0x81,0x76,0x0F,0xA1,0x7A,0x0F,0xC1,0x7E,0xEF,0xE1,0x00,0x82,
+0x0C,0x21,0x0A,0x84,0x00,0x00,0x00,0x00,0x9C,0x30,0xCA,0xE0,0x48,0x02,0x0D,0x41,
+0x08,0x0D,0x21,0x0C,0x89,0x43,0xC2,0xF7,0x00,0x0F,0x9B,0x1C,0x46,0xF7,0xC4,0x0E,
+0xE1,0x04,0x0E,0xE1,0x06,0x56,0xF7,0x04,0x22,0xE0,0xE0,0xCA,0xE0,0x48,0x00,0xC3,
+0x37,0x00,0x0F,0x9B,0x1B,0x47,0x39,0xC4,0xC3,0x37,0x00,0x0D,0xCA,0xE0,0x48,0x02,
+0xC3,0x37,0x00,0x0F,0x47,0x19,0xC4,0xC3,0x17,0x00,0x0D,0x98,0x82,0xE7,0xFF,0xBE,
+0x0E,0xCA,0xE0,0x48,0x00,0xC3,0x17,0x00,0x0F,0x53,0x18,0x04,0xC3,0x17,0x00,0x0D,
+0x0E,0xE1,0x06,0x56,0xF7,0x08,0x22,0xE0,0xE8,0xCA,0xE0,0x48,0x00,0xC3,0x37,0x00,
+0x0F,0x9B,0x17,0x47,0x39,0xC4,0xC3,0x37,0x00,0x0D,0xCA,0xE0,0x48,0x02,0xC3,0x37,
+0x00,0x0F,0x47,0x19,0xC4,0xC3,0x17,0x00,0x0D,0x98,0x83,0x88,0x6A,0xE7,0xFF,0xBD,
+0x8E,0xCA,0xE0,0x48,0x00,0xC3,0x17,0x00,0x0F,0x53,0x18,0x08,0xC3,0x17,0x00,0x0D,
+0x0D,0x41,0x0A,0x0D,0x21,0x0E,0x1C,0x21,0x10,0x85,0x29,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x01,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x1B,0x00,0x00,0x00,
+0x00,0xA0,0x26,0x01,0x01,0x00,0x00,0x00,0x66,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,0x00,0xA0,0x66,0x00,0xF3,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,
+0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x39,0x00,0x64,0x00,
+0x8F,0x00,0x54,0x00,0x17,0x00,0xB0,0x01,0x28,0x00,0x51,0x00,0x06,0x00,0x0A,0x00,
+0x15,0x00,0x15,0x00,0x01,0x00,0x1B,0x00,0xFA,0x00,0x08,0x01,0x78,0x00,0x78,0x00,
+0x20,0x00,0x32,0x00,0x88,0x01,0x80,0x00,0x8C,0x01,0x80,0x00,0x19,0x00,0x32,0x00,
+0xA0,0xB9,0x00,0xC0,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x14,0x14,0x14,
+0xFD,0xB9,0x00,0xC0,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x14,0x14,0x14,
+0xDF,0xB9,0x00,0xC0,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x14,0x14,0x14,
+0xD5,0xB9,0x00,0xC0,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x14,0x14,0x14,
+0x10,0xBA,0x00,0xC0,0x0B,0x05,0x00,0x00,0x01,0x00,0x00,0x00,0x37,0x14,0x64,0x2C,
+0xA2,0xB9,0x00,0xC0,0x0D,0x06,0x00,0x00,0x01,0x00,0x00,0x00,0x37,0x14,0x5A,0x2C,
+0xAF,0xB9,0x00,0xC0,0x0B,0x07,0x00,0x00,0x01,0x00,0x00,0x00,0x28,0x14,0x28,0x14,
+0xEF,0xB9,0x00,0xC0,0x0E,0x08,0x00,0x00,0x01,0x00,0x00,0x00,0x3C,0x1E,0x37,0x19,
+0xE1,0xB9,0x00,0xC0,0x06,0x09,0x00,0x00,0x01,0x00,0x00,0x00,0x1E,0x14,0x30,0x1E,
+0x1B,0xBA,0x00,0xC0,0x0E,0x0A,0x00,0x00,0x01,0x00,0x00,0x00,0x3C,0x1C,0x3C,0x22,
+0x2F,0xBA,0x00,0xC0,0x0F,0x0B,0x00,0x00,0x01,0x00,0x00,0x00,0x46,0x19,0x28,0x14,
+0x72,0xB9,0x00,0xC0,0x06,0x0C,0x00,0x00,0x01,0x00,0x00,0x00,0x3C,0x1E,0x28,0x14,
+0x8A,0xB9,0x00,0xC0,0x0E,0x0A,0x00,0x00,0x01,0x00,0x00,0x00,0x3C,0x1C,0x3C,0x22,
+0xD7,0xB9,0x00,0xC0,0x08,0x05,0x00,0x00,0x01,0x00,0x00,0x00,0x37,0x14,0x78,0x2C,
+0x05,0xBA,0x00,0xC0,0x0B,0x05,0x00,0x00,0x01,0x00,0x00,0x00,0x37,0x14,0x78,0x2C,
+0xE7,0xB9,0x00,0xC0,0x08,0x06,0x00,0x00,0x01,0x00,0x00,0x00,0x37,0x14,0x5A,0x2C,
+0xBA,0xB9,0x00,0xC0,0x0C,0x08,0x00,0x00,0x01,0x00,0x00,0x00,0x3C,0x1E,0x37,0x19,
+0xFF,0xB9,0x00,0xC0,0x06,0x07,0x00,0x00,0x01,0x00,0x00,0x00,0x28,0x14,0x28,0x14,
+0xCE,0xB9,0x00,0xC0,0x07,0x07,0x00,0x00,0x01,0x00,0x00,0x00,0x28,0x14,0x28,0x14,
+0x98,0xB9,0x00,0xC0,0x08,0x0B,0x00,0x00,0x01,0x00,0x00,0x00,0x46,0x19,0x28,0x14,
+0x29,0xBA,0x00,0xC0,0x06,0x09,0x00,0x00,0x01,0x00,0x00,0x00,0x1E,0x14,0x30,0x1E,
+0xC6,0xB9,0x00,0xC0,0x08,0x0C,0x00,0x00,0x01,0x00,0x00,0x00,0x3C,0x1E,0x28,0x14,
+0x3E,0xBA,0x00,0xC0,0x09,0x09,0x00,0x00,0x01,0x00,0x00,0x00,0x1E,0x14,0x30,0x1E,
+0x78,0xB9,0x00,0xC0,0x0A,0x06,0x00,0x00,0x01,0x00,0x00,0x00,0x37,0x14,0x5A,0x2C,
+0x82,0xB9,0x00,0xC0,0x08,0x06,0x00,0x00,0x01,0x00,0x00,0x00,0x37,0x14,0x5A,0x2C,
+0x8A,0x01,0x80,0x00,0x7E,0x01,0x80,0x00,0x01,0x00,0x00,0x00,0x07,0x00,0xD2,0x00,
+0xD2,0x00,0xD2,0x00,0x06,0x00,0x98,0x08,0x02,0x00,0x00,0x01,0xF4,0x01,0xF4,0x01,
+0x02,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x02,0x00,0x04,0x00,0x06,0x00,
+0x08,0x00,0x0A,0x00,0x0C,0x00,0x10,0x00,0x14,0x00,0x18,0x00,0x20,0x00,0x28,0x00,
+0x32,0x00,0x3E,0x00,0x40,0x00,0x64,0x00,0x80,0x00,0x00,0x01,0x02,0x00,0x00,0x11,
+0xFF,0xFF,0xFF,0xFF,0x01,0x11,0xFF,0xFF,0x18,0x50,0x02,0x11,0xFF,0x7F,0xFF,0x0E,
+0x03,0x11,0xFF,0x00,0xF6,0x00,0x04,0x11,0xFF,0x0F,0x72,0x07,0x05,0x11,0xFF,0x0F,
+0x72,0x07,0x06,0x11,0xFF,0x00,0x00,0x00,0x07,0x11,0x03,0x00,0x00,0x00,0x08,0x11,
+0x73,0x00,0x00,0x00,0x09,0x11,0xFF,0xFF,0x00,0x00,0x09,0x11,0xFF,0x7F,0x00,0x00,
+0x0A,0x11,0xFF,0x7F,0x87,0x10,0x0E,0x11,0xFF,0xFF,0x00,0x00,0x0F,0x11,0xFF,0xFF,
+0x00,0x00,0x17,0x11,0x0F,0xFF,0x00,0x00,0x18,0x11,0xFF,0xFF,0x00,0x02,0x19,0x11,
+0xFF,0x00,0x0E,0x00,0x1E,0x11,0xFF,0xFF,0x00,0x00,0x1F,0x11,0xFF,0x00,0x00,0x00,
+0x33,0x11,0x0F,0x00,0x00,0x00,0x3A,0x11,0x37,0x0F,0x00,0x00,0x3B,0x11,0x77,0x00,
+0x77,0x00,0x3C,0x11,0x00,0xFF,0x00,0xA0,0x3D,0x11,0x77,0x00,0x00,0x00,0x3E,0x11,
+0xFF,0x00,0x00,0x00,0x04,0x12,0x06,0x00,0x00,0x00,0x05,0x12,0xFF,0x00,0x00,0x00,
+0x07,0x12,0xFF,0xFF,0x00,0x00,0x08,0x12,0xFF,0x00,0x00,0x00,0x09,0x12,0xFF,0xFF,
+0x00,0x00,0x0A,0x12,0xFF,0x00,0x00,0x00,0x0B,0x12,0x3F,0x00,0x2E,0x00,0x0D,0x12,
+0x1F,0x00,0x05,0x00,0x0E,0x12,0x1F,0x00,0x05,0x00,0x0F,0x12,0xFF,0xFF,0x00,0x00,
+0x10,0x12,0xFF,0x00,0x00,0x00,0x11,0x12,0xFF,0x0F,0x00,0x00,0x12,0x12,0x87,0x1F,
+0x00,0x00,0x13,0x12,0x7F,0x0F,0x14,0x00,0x14,0x12,0x9F,0xFF,0x0A,0x09,0x15,0x12,
+0x7F,0x0F,0x0C,0x00,0x16,0x12,0xFF,0x0F,0x00,0x07,0x17,0x12,0x1F,0xFF,0x0A,0x5C,
+0x18,0x12,0x7F,0x1F,0x14,0x0A,0x19,0x12,0xFF,0xFF,0x8C,0x21,0x1A,0x12,0xFF,0x03,
+0x00,0x00,0x1B,0x12,0xFF,0x03,0x00,0x00,0x1C,0x12,0xFF,0x03,0x00,0x00,0x1D,0x12,
+0xFF,0x03,0x00,0x00,0x1E,0x12,0x1F,0x1F,0x12,0x07,0x1F,0x12,0x3F,0x3F,0x00,0x00,
+0x20,0x12,0xFF,0xFF,0x00,0x00,0x21,0x12,0xFF,0x00,0x00,0x00,0x23,0x12,0x3F,0x3F,
+0x02,0x00,0x24,0x12,0x3F,0x00,0x00,0x00,0x28,0x12,0xFF,0xFF,0x83,0x81,0x2D,0x12,
+0x01,0x00,0x01,0x00,0x50,0x12,0xFF,0xFF,0x00,0x00,0x51,0x12,0xFF,0x00,0x00,0x00,
+0x70,0x12,0x03,0x00,0x03,0x00,0x01,0x11,0x06,0x00,0x02,0x00,0x02,0x11,0x00,0x08,
+0x00,0x08,0x2A,0x12,0x00,0xFF,0x00,0xBA,0x2B,0x12,0xFF,0x30,0xF0,0x20,0x01,0x11,
+0x06,0x00,0x00,0x00,0x2A,0x12,0x00,0xFF,0x00,0x00,0x2B,0x12,0xFF,0x30,0x00,0x00,
+0x01,0x11,0x00,0x50,0x00,0x50,0x02,0x11,0x3F,0x06,0x2F,0x06,0x01,0x11,0x00,0x50,
+0x00,0x00,0x02,0x11,0x3F,0x06,0x00,0x00,0x2A,0x12,0x00,0x30,0x00,0x20,0x11,0x1E,
+0xFF,0x7F,0x00,0x00,0x12,0x1E,0xFF,0x00,0x00,0x00,0x13,0x1E,0x0F,0x00,0x00,0x00,
+0x15,0x1E,0x73,0x07,0x00,0x00,0x16,0x1E,0x0F,0x00,0x00,0x00,0x18,0x1E,0x3F,0x00,
+0x08,0x00,0x2A,0x1E,0x05,0x00,0x01,0x00,0x50,0x11,0x11,0x11,0x51,0x11,0x11,0x11,
+0x52,0x11,0x11,0x11,0x53,0x11,0x11,0x11,0x54,0x11,0x11,0x11,0x55,0x11,0x11,0x11,
+0x56,0x11,0x11,0x11,0x57,0x11,0x11,0x11,0x58,0x11,0x11,0x11,0x59,0x11,0x11,0x11,
+0x5A,0x11,0x11,0x11,0x5B,0x11,0x11,0x11,0x5C,0x11,0xFF,0xFF,0x5D,0x11,0xFF,0xFF,
+0x5E,0x11,0xFF,0xFF,0x46,0x12,0x00,0x00,0x47,0x12,0x00,0x00,0x48,0x12,0x00,0x00,
+0x49,0x12,0x00,0x00,0x4A,0x12,0x00,0x00,0x4B,0x12,0x00,0x00,0x4C,0x12,0x00,0x00,
+0x4D,0x12,0x00,0x00,0x4E,0x12,0x0F,0x00,0x26,0x08,0x80,0x00,0x04,0x0D,0x80,0x00,
+0x58,0x01,0x80,0x00,0x5C,0x54,0x47,0x37,0x00,0x00,0x31,0x00,0x94,0x00,0xFA,0x00,
+0x66,0x01,0xD9,0x01,0x57,0x02,0xE6,0x02,0x8A,0x03,0x4F,0x04,0x44,0x05,0x84,0x06,
+0x42,0x08,0xEB,0x0A,0x98,0x0F,0x55,0x1A,0xF3,0x07,0xFF,0xFF,0x0F,0x00,0x52,0x00,
+0x69,0x00,0xD9,0x00,0x35,0x38,0x00,0x00,0xB8,0x38,0x00,0x00,0xD7,0x38,0x00,0x00,
+0xAA,0x39,0x00,0x00,0xC1,0x39,0x00,0x00,0xE8,0x00,0xD6,0x00,0xC4,0x00,0xB2,0x00,
+0xA1,0x00,0x8F,0x00,0x7D,0x00,0x6B,0x00,0x59,0x00,0x47,0x00,0x35,0x00,0x23,0x00,
+0x11,0x00,0x00,0x00,0x05,0x04,0x03,0x03,0x04,0x00,0xFF,0x00,0x42,0x06,0x17,0x00,
+0xFE,0x00,0x99,0x0B,0x3B,0x00,0xFC,0x00,0x0D,0x17,0x5F,0x00,0xFB,0x00,0x6E,0x1E,
+0x81,0x00,0xFA,0x00,0xB4,0x22,0xAC,0x00,0xF9,0x00,0xE9,0x28,0xDF,0x00,0xF7,0x00,
+0x6A,0x35,0x0B,0x01,0xF6,0x00,0xD5,0x3A,0x38,0x01,0xFF,0x00,0xE4,0x0A,0x07,0x00,
+0xFE,0x00,0x56,0x0F,0x1E,0x00,0xFD,0x00,0x18,0x16,0x35,0x00,0xFC,0x00,0x6C,0x1A,
+0x4B,0x00,0xFC,0x00,0xD6,0x1D,0x66,0x00,0xFB,0x00,0x8D,0x24,0x81,0x00,0xFA,0x00,
+0xF7,0x2C,0x94,0x00,0xF9,0x00,0x2A,0x30,0xA8,0x00,0xF8,0x00,0x56,0x31,0xC9,0x00,
+0xF7,0x00,0x3E,0x36,0xF6,0x00,0xFE,0x00,0xFE,0x11,0xFD,0xFF,0xFE,0x00,0x06,0x12,
+0x0B,0x00,0xFD,0x00,0xE2,0x14,0x25,0x00,0xFC,0x00,0x5D,0x1B,0x3F,0x00,0xFC,0x00,
+0x27,0x22,0x4F,0x00,0xFB,0x00,0x3D,0x25,0x5C,0x00,0xFA,0x00,0x05,0x28,0x70,0x00,
+0xFA,0x00,0x3C,0x2D,0x88,0x00,0xF8,0x00,0x7C,0x35,0x99,0x00,0xF8,0x00,0xFE,0x37,
+0xAC,0x00,0xF7,0x00,0x51,0x39,0xCC,0x00,0xFE,0x00,0x25,0x14,0xF5,0xFF,0xFD,0x00,
+0xD1,0x16,0x06,0x00,0xFD,0x00,0x39,0x1B,0x16,0x00,0xFC,0x00,0x10,0x1E,0x27,0x00,
+0xFC,0x00,0xF3,0x20,0x3B,0x00,0xFB,0x00,0x82,0x26,0x4C,0x00,0xFA,0x00,0xE5,0x2C,
+0x55,0x00,0xFA,0x00,0xCD,0x2F,0x5F,0x00,0xF9,0x00,0x57,0x31,0x72,0x00,0xF8,0x00,
+0x16,0x36,0x89,0x00,0xF7,0x00,0x61,0x3D,0x9A,0x00,0xF7,0x00,0xC9,0x3F,0xAD,0x00,
+0xFD,0x00,0xED,0x1F,0xDD,0xFF,0xFC,0x00,0xBD,0x21,0xEC,0xFF,0xFC,0x00,0x5D,0x24,
+0xFB,0xFF,0xFC,0x00,0xA0,0x26,0x09,0x00,0xFB,0x00,0x3D,0x29,0x18,0x00,0xFA,0x00,
+0x20,0x2E,0x23,0x00,0xFA,0x00,0x6C,0x33,0x29,0x00,0xF9,0x00,0xC4,0x35,0x2F,0x00,
+0xF9,0x00,0x07,0x37,0x3C,0x00,0xF8,0x00,0xA0,0x3A,0x4B,0x00,0xF8,0x00,0xEE,0x3F,
+0x53,0x00,0xF7,0x00,0x74,0x41,0x5C,0x00,0xF7,0x00,0x0D,0x41,0x70,0x00,0xF6,0x00,
+0xB1,0x43,0x88,0x00,0x17,0x00,0x05,0x0D,0xB7,0xFF,0x0E,0x01,0x0D,0x00,0x25,0x00,
+0xFF,0x03,0x0B,0x00,0x2D,0x00,0x15,0x00,0x65,0x00,0x30,0x03,0x1A,0x00,0x04,0x00,
+0x19,0x00,0x16,0x01,0x2C,0x08,0xCA,0xFE,0x02,0x00,0x19,0x00,0x47,0x01,0x14,0x03,
+0x68,0x00,0x00,0x00,0x1A,0x00,0x1D,0x00,0xD6,0x05,0xD8,0xFF,0x7A,0x00,0x15,0x00,
+0x44,0x00,0x28,0x04,0xF4,0xFF,0x31,0x00,0x19,0x00,0x9A,0x00,0x27,0x04,0xEF,0xFF,
+0x04,0x00,0x20,0x00,0x2C,0x01,0xF4,0x03,0x0A,0x00,0x01,0x00,0x21,0x00,0x24,0x00,
+0xFA,0x04,0xD5,0xFF,0x63,0x00,0x17,0x00,0x6D,0x00,0x78,0x04,0xE3,0xFF,0x25,0x00,
+0x1E,0x00,0xC0,0x00,0x2F,0x04,0xF0,0xFF,0x02,0x00,0x24,0x00,0x2E,0x00,0x35,0x05,
+0xC3,0xFF,0x61,0x00,0x19,0x00,0x98,0x00,0x99,0x04,0xDD,0xFF,0x10,0x00,0x25,0x00,
+0xFA,0x00,0xF8,0x03,0x02,0x00,0x01,0x00,0x28,0x00,0x47,0x00,0x4E,0x06,0x8C,0xFF,
+0x77,0x00,0x1A,0x00,0xB3,0x00,0xEE,0x04,0xD0,0xFF,0x14,0x00,0x2B,0x00,0x04,0x01,
+0x40,0x03,0x37,0x00,0x02,0x00,0x30,0x00,0x7E,0x01,0xDA,0x04,0xA3,0xFF,0x01,0x00,
+0x30,0x00,0x00,0x00,0x13,0x1A,0x05,0x00,0x30,0x34,0x38,0x0C,0x10,0x34,0x30,0x0E,
+0x30,0x0A,0x35,0x02,0x09,0x10,0x35,0x10,0x0A,0x34,0x1E,0x18,0x14,0x0E,0x0B,0x07,
+0x01,0x3C,0x37,0x34,0x30,0x2A,0x26,0x23,0x1C,0x17,0x0E,0x05,0x03,0x10,0x19,0x1B,
+0x2F,0x2F,0x10,0x0E,0x0A,0x05,0x00,0x39,0x33,0x30,0x10,0x0B,0x04,0x35,0x30,0x28,
+0x22,0x1E,0x19,0x13,0x10,0x0B,0x07,0x02,0x3D,0x39,0x00,0x3C,0x38,0x34,0x2E,0x23,
+0x1D,0x16,0x10,0x0B,0x05,0x01,0x3F,0x00,0x0A,0x17,0x1A,0x10,0x02,0x3F,0x21,0x1D,
+0x19,0x14,0x0E,0x04,0x01,0x00,0x00,0x32,0x33,0x05,0x0D,0x3D,0x35,0x09,0x10,0x1F,
+0x1F,0x0D,0x0D,0x0D,0x0D,0x35,0x35,0x0E,0x0D,0x36,0x32,0x09,0x0D,0x37,0x33,0x00,
+0x3C,0x36,0x2A,0x23,0x1E,0x1A,0x15,0x10,0x0B,0x08,0x03,0x3C,0x39,0x0F,0x0F,0x1D,
+0x18,0x12,0x0A,0x04,0x01,0x10,0x10,0x32,0x3E,0x0D,0x10,0x33,0x38,0x01,0x0D,0x10,
+0x30,0x34,0x00,0x0D,0x10,0x32,0x34,0x3A,0x07,0x0D,0x10,0x01,0x05,0x0B,0x0E,0x13,
+0x1A,0x1F,0x25,0x29,0x2E,0x34,0x36,0x3B,0x00,0x10,0x0E,0x07,0x3C,0x33,0x30,0x28,
+0x22,0x1D,0x19,0x14,0x10,0x0A,0x05,0x0B,0x13,0x1A,0x1D,0x22,0x26,0x2B,0x3D,0x02,
+0x10,0x09,0x3D,0x34,0x30,0x0B,0x04,0x00,0xD5,0x54,0x00,0x00,0xD5,0x54,0x00,0x00,
+0xE4,0x54,0x00,0x00,0xE4,0x54,0x00,0x00,0x3D,0x56,0x00,0x00,0x3D,0x56,0x00,0x00,
+0x3D,0x56,0x00,0x00,0x67,0x55,0x00,0x00,0x3D,0x56,0x00,0x00,0xC4,0x55,0x00,0x00,
+0xB5,0x57,0x00,0x00,0xB5,0x57,0x00,0x00,0xDE,0x57,0x00,0x00,0xAB,0x57,0x00,0x00,
+0x07,0x58,0x00,0x00,0x37,0x58,0x00,0x00,0x1F,0x58,0x00,0x00,0x0E,0x5B,0x00,0x00,
+0x32,0x5B,0x00,0x00,0x42,0x5B,0x00,0x00,0x7A,0x5B,0x00,0x00,0x74,0x5B,0x00,0x00,
+0x74,0x5B,0x00,0x00,0x7A,0x5B,0x00,0x00,0x74,0x5B,0x00,0x00,0x01,0x2A,0x2B,0x0A,
+0x09,0x08,0x07,0x06,0x05,0x04,0x02,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x20,0x0B,
+0x0C,0x0D,0x0E,0x0F,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x00,
+0x95,0x68,0x00,0x00,0x95,0x68,0x00,0x00,0xBE,0x68,0x00,0x00,0xBE,0x68,0x00,0x00,
+0xE8,0x68,0x00,0x00,0xE8,0x68,0x00,0x00,0xE8,0x68,0x00,0x00,0xE8,0x68,0x00,0x00,
+0x74,0x68,0x00,0x00,0x53,0x68,0x00,0x00,0x49,0x69,0x00,0x00,0x49,0x69,0x00,0x00,
+0x7A,0x69,0x00,0x00,0x7A,0x69,0x00,0x00,0xAD,0x69,0x00,0x00,0xAD,0x69,0x00,0x00,
+0xAD,0x69,0x00,0x00,0xAD,0x69,0x00,0x00,0x22,0x69,0x00,0x00,0x10,0x69,0x00,0x00,
+0xB4,0x6A,0x00,0x00,0xB4,0x6A,0x00,0x00,0x06,0x6B,0x00,0x00,0x06,0x6B,0x00,0x00,
+0xE6,0x6B,0x00,0x00,0xE6,0x6B,0x00,0x00,0xE6,0x6B,0x00,0x00,0xE6,0x6B,0x00,0x00,
+0x5E,0x6B,0x00,0x00,0xA4,0x6B,0x00,0x00,0x5D,0x7D,0x00,0x00,0x64,0x7D,0x00,0x00,
+0x6B,0x7D,0x00,0x00,0x72,0x7D,0x00,0x00,0x79,0x7D,0x00,0x00,0x80,0x7D,0x00,0x00,
+0x87,0x7D,0x00,0x00,0x8E,0x7D,0x00,0x00,0x95,0x7D,0x00,0x00,0x9C,0x7D,0x00,0x00,
+0xA3,0x7D,0x00,0x00,0xAA,0x7D,0x00,0x00,0xAD,0x7E,0x00,0x00,0xAD,0x7E,0x00,0x00,
+0xE7,0x7E,0x00,0x00,0xE7,0x7E,0x00,0x00,0x7B,0x7F,0x00,0x00,0x7B,0x7F,0x00,0x00,
+0x7B,0x7F,0x00,0x00,0x7B,0x7F,0x00,0x00,0x23,0x7F,0x00,0x00,0x4B,0x7F,0x00,0x00,
+0x00,0x01,0x00,0x00,0xC0,0x81,0x00,0x00,0xFA,0x81,0x00,0x00,0x52,0x82,0x00,0x00,
+0x2A,0x83,0x00,0x00,0xAE,0x82,0x00,0x00,0xDE,0x82,0x00,0x00,0x2A,0x83,0x00,0x00,
+0xE6,0x82,0x00,0x00,0x04,0x00,0x1D,0x00,0x2E,0x00,0x50,0x00,0x82,0x00,0xC7,0x00,
+0x23,0x01,0x9B,0x01,0x32,0x02,0xEE,0x02,0xD0,0x03,0xDE,0x04,0x19,0x06,0x82,0x07,
+0x1A,0x09,0xE0,0x0A,0xD0,0x0C,0xE7,0x0E,0x1F,0x11,0x71,0x13,0xD3,0x15,0x3D,0x18,
+0xA2,0x1A,0xF9,0x1C,0x34,0x1F,0x47,0x21,0x28,0x23,0xCB,0x24,0x27,0x26,0x33,0x27,
+0xEA,0x27,0x46,0x28,0x04,0x00,0x1C,0x00,0x2B,0x00,0x4B,0x00,0x78,0x00,0xB7,0x00,
+0x0A,0x01,0x75,0x01,0xFC,0x01,0xA3,0x02,0x6D,0x03,0x5E,0x04,0x76,0x05,0xB9,0x06,
+0x26,0x08,0xBE,0x09,0x7D,0x0B,0x61,0x0D,0x67,0x0F,0x87,0x11,0xBB,0x13,0xFC,0x15,
+0x3F,0x18,0x7B,0x1A,0xA6,0x1C,0xB6,0x1E,0x9F,0x20,0x57,0x22,0xD7,0x23,0x14,0x25,
+0x08,0x26,0xAF,0x26,0x03,0x27,0x05,0x00,0x08,0x21,0x05,0x00,0x00,0x20,0x00,0x00,
+0x8C,0xBD,0x00,0xC0,0x9C,0xBD,0x00,0xC0,0xAE,0xBD,0x00,0xC0,0xB2,0xBD,0x00,0xC0,
+0x24,0xBD,0x00,0xC0,0x6C,0xBD,0x00,0xC0,0xCC,0xBD,0x00,0xC0,0xEA,0xBD,0x00,0xC0,
+0xEE,0xBD,0x00,0xC0,0x14,0xBE,0x00,0xC0,0xA2,0xBE,0x00,0xC0,0xE4,0xBE,0x00,0xC0,
+0x46,0xBC,0x00,0xC0,0x4A,0xBC,0x00,0xC0,0x20,0xBD,0x00,0xC0,0x68,0xBD,0x00,0xC0,
+0x05,0x00,0x2A,0x00,0x2A,0x00,0x3E,0x00,0x58,0x00,0x79,0x00,0xA1,0x00,0xD3,0x00,
+0x0F,0x01,0x56,0x01,0xAA,0x01,0x0C,0x02,0x7D,0x02,0xFE,0x02,0x91,0x03,0x37,0x04,
+0xF0,0x04,0xBE,0x05,0xA0,0x06,0x99,0x07,0xA7,0x08,0xCC,0x09,0x06,0x0B,0x56,0x0C,
+0xBB,0x0D,0x34,0x0F,0xC0,0x10,0x5D,0x12,0x0A,0x14,0xC5,0x15,0x8A,0x17,0x59,0x19,
+0x2D,0x1B,0x05,0x1D,0xDC,0x1E,0xB0,0x20,0x7D,0x22,0x40,0x24,0xF5,0x25,0x98,0x27,
+0x27,0x29,0x9E,0x2A,0xF9,0x2B,0x37,0x2D,0x53,0x2E,0x4B,0x2F,0x1E,0x30,0xC9,0x30,
+0x4A,0x31,0xA1,0x31,0xCD,0x31,0x04,0x00,0x2D,0x00,0x6D,0x00,0xE7,0x00,0xAD,0x01,
+0xD8,0x02,0x81,0x04,0xBE,0x06,0xA0,0x09,0x30,0x0D,0x6D,0x11,0x47,0x16,0xA3,0x1B,
+0x56,0x21,0x29,0x27,0xDC,0x2C,0x2A,0x32,0xCF,0x36,0x8B,0x3A,0x29,0x3D,0x81,0x3E,
+0x06,0x00,0xF5,0x28,0x03,0x00,0x33,0x33,0x70,0xBD,0x00,0xC0,0x86,0xBD,0x00,0xC0,
+0x18,0xBE,0x00,0xC0,0xA6,0xBE,0x00,0xC0,0x90,0xBD,0x00,0xC0,0xA0,0xBD,0x00,0xC0,
+0x74,0xBD,0x00,0xC0,0xB6,0xBD,0x00,0xC0,0xD0,0xBD,0x00,0xC0,0xF2,0xBD,0x00,0xC0,
+0xF6,0xBC,0x00,0xC0,0xB0,0xBE,0x00,0xC0,0xC4,0xBB,0x00,0xC0,0x04,0xBC,0x00,0xC0,
+0x90,0xBC,0x00,0xC0,0x20,0xBE,0x00,0xC0,0x06,0x00,0x00,0x20,0x03,0x00,0xAA,0x2A,
+0x00,0x00,0x00,0x20,0x02,0x00,0x45,0x00,0x5D,0x01,0x1B,0x04,0x31,0x09,0xA2,0x10,
+0x55,0x19,0x32,0x21,0xE5,0x25,0x01,0x00,0x10,0x10,0xEF,0x2F,0x00,0x00,0x00,0x20,
+0x02,0x00,0x49,0x01,0x6C,0x07,0xB1,0x15,0x60,0x29,0x38,0x38,0x01,0x00,0x00,0x20,
+0x02,0x00,0xAC,0x00,0xCB,0x03,0x95,0x0B,0x6B,0x18,0xE0,0x26,0xA6,0x30,0x02,0x00,
+0xAA,0x2A,0x02,0x00,0x00,0x20,0x03,0x00,0x4D,0x00,0x51,0x01,0xBD,0x03,0x48,0x08,
+0x6B,0x0F,0x0D,0x19,0x47,0x24,0x73,0x2F,0x86,0x38,0x9F,0x3D,0x03,0x00,0x00,0x20,
+0x03,0x00,0x33,0x00,0xC4,0x00,0x08,0x02,0x5B,0x04,0x11,0x08,0x55,0x0D,0x0D,0x14,
+0xCC,0x1B,0xCF,0x23,0x1E,0x2B,0xB5,0x30,0xBD,0x33,0x04,0x00,0x33,0x33,0x04,0x00,
+0xAA,0x2A,0x03,0x00,0x1F,0x00,0x5B,0x00,0xD6,0x00,0xAB,0x01,0xF6,0x02,0xD5,0x04,
+0x59,0x07,0x87,0x0A,0x52,0x0E,0x96,0x12,0x1C,0x17,0x9B,0x1B,0xC0,0x1F,0x37,0x23,
+0xB6,0x25,0x05,0x27,0x04,0x00,0x00,0x20,0x01,0x00,0x65,0x04,0x5D,0x14,0x3D,0x27,
+0x05,0x00,0x26,0x00,0x1D,0x00,0x28,0x00,0x36,0x00,0x47,0x00,0x5A,0x00,0x72,0x00,
+0x8D,0x00,0xAE,0x00,0xD3,0x00,0xFD,0x00,0x2D,0x01,0x64,0x01,0xA2,0x01,0xE6,0x01,
+0x33,0x02,0x87,0x02,0xE5,0x02,0x4B,0x03,0xBA,0x03,0x33,0x04,0xB6,0x04,0x43,0x05,
+0xDB,0x05,0x7C,0x06,0x29,0x07,0xDF,0x07,0xA1,0x08,0x6C,0x09,0x41,0x0A,0x21,0x0B,
+0x09,0x0C,0xFA,0x0C,0xF4,0x0D,0xF5,0x0E,0xFE,0x0F,0x0C,0x11,0x20,0x12,0x38,0x13,
+0x53,0x14,0x71,0x15,0x90,0x16,0xAF,0x17,0xCD,0x18,0xE8,0x19,0x00,0x1B,0x12,0x1C,
+0x1E,0x1D,0x23,0x1E,0x1F,0x1F,0x10,0x20,0xF7,0x20,0xD0,0x21,0x9C,0x22,0x59,0x23,
+0x07,0x24,0xA3,0x24,0x2E,0x25,0xA7,0x25,0x0C,0x26,0x5E,0x26,0x9C,0x26,0xC6,0x26,
+0xDA,0x26,0x05,0x00,0x33,0x33,0x01,0x00,0x7E,0x01,0x41,0x08,0x4A,0x15,0xF4,0x20,
+0x04,0x00,0x23,0x00,0x45,0x00,0x84,0x00,0xE4,0x00,0x6F,0x01,0x2F,0x02,0x2F,0x03,
+0x76,0x04,0x0F,0x06,0xFD,0x07,0x45,0x0A,0xE6,0x0C,0xDA,0x0F,0x19,0x13,0x93,0x16,
+0x37,0x1A,0xEF,0x1D,0xA0,0x21,0x2F,0x25,0x80,0x28,0x77,0x2B,0xFA,0x2D,0xF2,0x2F,
+0x4D,0x31,0xFD,0x31,0x05,0x00,0xF5,0x28,0x0E,0x96,0x00,0x00,0x2A,0x96,0x00,0x00,
+0x49,0x96,0x00,0x00,0x68,0x96,0x00,0x00,0x77,0x96,0x00,0x00,0x44,0x54,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x01,0x01,0x42,
+0x42,0x4D,0x44,0x4C,0x01,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0xD7,0xBE,0x7E,0xFC,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x03,0x00,
+0x00,0x00,0x56,0x30,0x31,0x2E,0x30,0x30,0x37,0x2E,0x30,0x35,0x56,0xDF,0xF5,0x88
+};
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_platform_porting_layer.h
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_platform_porting_layer.h	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_platform_porting_layer.h	(revision 166572)
@@ -0,0 +1,268 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_platform_porting_layer.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_PLATFORM_PORTING_LAYER_H__
+#define __MSTAR_DRV_PLATFORM_PORTING_LAYER_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+
+//#include <mach/board.h>
+//#include <mach/gpio.h>
+#include <soc/sprd/board.h>
+#include <soc/sprd/gpio.h>
+#include <soc/sprd/i2c-sprd.h>
+
+#include <linux/of_gpio.h>
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+//#include <mach/regulator.h>
+#include <soc/sprd/regulator.h>
+#include <linux/regulator/consumer.h>
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+//#include <linux/input/vir_ps.h> 
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+#include <linux/pinctrl/consumer.h>
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+
+#include <linux/of_gpio.h>
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+#include <linux/regulator/consumer.h>
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+#ifdef CONFIG_ENABLE_NOTIFIER_FB
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#endif //CONFIG_ENABLE_NOTIFIER_FB
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+//#include <linux/input/vir_ps.h> 
+#include <linux/sensors.h>
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+#include <linux/pinctrl/consumer.h>
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/rtpm_prio.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+
+#include <linux/namei.h>
+#include <linux/vmalloc.h>
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+#include <linux/hwmsensor.h>
+#include <linux/hwmsen_dev.h>
+#include <linux/sensors_io.h>
+#include <linux/hwmsen_helper.h>
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+/*
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+#include <linux/pinctrl/consumer.h>
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+*/
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/gpio.h>
+
+#ifdef TIMER_DEBUG
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/module.h>
+#endif //TIMER_DEBUG
+
+#ifdef CONFIG_MTK_SENSOR_HUB_SUPPORT
+#include <mach/md32_ipi.h>
+#include <mach/md32_helper.h>
+#endif //CONFIG_MTK_SENSOR_HUB_SUPPORT
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+#include <linux/regulator/consumer.h>
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+#ifdef CONFIG_MTK_BOOT
+#include "mt_boot_common.h"
+#endif //CONFIG_MTK_BOOT
+
+#else
+#include <mach/mt_pm_ldo.h>
+#include <mach/mt_typedefs.h>
+#include <mach/mt_boot.h>
+#include <mach/mt_gpio.h>
+
+#include <cust_eint.h>
+#include <pmic_drv.h>
+
+#include "cust_gpio_usage.h"
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+#include "tpd.h"
+
+#endif
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+/*
+ * Note.
+ * Please change the below GPIO pin setting to follow the platform that you are using(EX. MediaTek, Spreadtrum, Qualcomm).
+ */
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+
+#ifndef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+// TODO : Please FAE colleague to confirm with customer device driver engineer about the value of RST and INT GPIO setting
+#define MS_TS_MSG_IC_GPIO_RST   141//GPIO_TOUCH_RESET //53 //35 
+#define MS_TS_MSG_IC_GPIO_INT   144//GPIO_TOUCH_IRQ   //52 //37
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+#define PINCTRL_STATE_ACTIVE	"pmx_ts_active"
+#define PINCTRL_STATE_SUSPEND	"pmx_ts_suspend"
+#define PINCTRL_STATE_RELEASE	"pmx_ts_release"
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+#define GTP_ADDR_LENGTH       (2)
+#define GTP_IOCTL_MAGIC 			(0x1C)
+#define LTR_IOCTL_GET_PFLAG  	_IOR(GTP_IOCTL_MAGIC, 1, int)
+#define LTR_IOCTL_GET_LFLAG  	_IOR(GTP_IOCTL_MAGIC, 2, int)
+#define LTR_IOCTL_SET_PFLAG  	_IOW(GTP_IOCTL_MAGIC, 3, int)
+#define LTR_IOCTL_SET_LFLAG  	_IOW(GTP_IOCTL_MAGIC, 4, int)
+#define LTR_IOCTL_GET_DATA  	_IOW(GTP_IOCTL_MAGIC, 5, unsigned char)
+#define GTP_IOCTL_PROX_ON 		_IO(GTP_IOCTL_MAGIC, 7)
+#define GTP_IOCTL_PROX_OFF		_IO(GTP_IOCTL_MAGIC, 8)
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_TP_HAVE_KEY
+#define TOUCH_KEY_MENU (139) //229
+#define TOUCH_KEY_HOME (172) //102
+#define TOUCH_KEY_BACK (158)
+#define TOUCH_KEY_SEARCH (217)
+
+#define MAX_KEY_NUM (4)
+#endif //CONFIG_TP_HAVE_KEY
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+
+#ifndef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+// TODO : Please FAE colleague to confirm with customer device driver engineer about the value of RST and INT GPIO setting
+#define MS_TS_MSG_IC_GPIO_RST   0
+#define MS_TS_MSG_IC_GPIO_INT   1
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+#define PINCTRL_STATE_ACTIVE	"pmx_ts_active"
+#define PINCTRL_STATE_SUSPEND	"pmx_ts_suspend"
+#define PINCTRL_STATE_RELEASE	"pmx_ts_release"
+#endif //CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+#ifdef CONFIG_TP_HAVE_KEY
+#define TOUCH_KEY_MENU (139) //229
+#define TOUCH_KEY_HOME (172) //102
+#define TOUCH_KEY_BACK (158)
+#define TOUCH_KEY_SEARCH (217)
+
+#define MAX_KEY_NUM (4)
+#endif //CONFIG_TP_HAVE_KEY
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+
+#ifndef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#define MS_TS_MSG_IC_GPIO_RST   (GPIO_CTP_RST_PIN)
+#define MS_TS_MSG_IC_GPIO_INT   (GPIO_CTP_EINT_PIN)
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+#ifdef CONFIG_TP_HAVE_KEY
+#define TOUCH_KEY_MENU    KEY_MENU 
+#define TOUCH_KEY_HOME    KEY_HOMEPAGE 
+#define TOUCH_KEY_BACK    KEY_BACK
+#define TOUCH_KEY_SEARCH  KEY_SEARCH
+
+#define MAX_KEY_NUM (4)
+#endif //CONFIG_TP_HAVE_KEY
+
+#endif
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+extern void DrvPlatformLyrDisableFingerTouchReport(void);
+extern void DrvPlatformLyrEnableFingerTouchReport(void);
+extern void DrvPlatformLyrFingerTouchPressed(s32 nX, s32 nY, s32 nPressure, s32 nId);
+extern void DrvPlatformLyrFingerTouchReleased(s32 nX, s32 nY, s32 nId);
+extern void DrvPlatformLyrVariableInitialize(void);
+extern s32 DrvPlatformLyrInputDeviceInitialize(struct i2c_client *pClient);
+extern void DrvPlatformLyrSetIicDataRate(struct i2c_client *pClient, u32 nIicDataRate);
+extern void DrvPlatformLyrTouchDevicePowerOff(void);
+extern void DrvPlatformLyrTouchDevicePowerOn(void);
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+extern void DrvPlatformLyrTouchDeviceRegulatorPowerOn(bool nFlag);
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+extern void DrvPlatformLyrTouchDeviceRegisterEarlySuspend(void);
+extern s32 DrvPlatformLyrTouchDeviceRegisterFingerTouchInterruptHandler(void);
+extern s32 DrvPlatformLyrTouchDeviceRemove(struct i2c_client *pClient);
+extern s32 DrvPlatformLyrTouchDeviceRequestGPIO(struct i2c_client *pClient);        
+extern void DrvPlatformLyrTouchDeviceResetHw(void);
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+extern int DrvPlatformLyrGetTpPsData(void);
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+extern void DrvPlatformLyrTpPsEnable(int nEnable);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+extern int DrvPlatformLyrTpPsEnable(struct sensors_classdev* pProximityCdev, unsigned int nEnable);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+extern int DrvPlatformLyrTpPsOperate(void* pSelf, u32 nCommand, void* pBuffIn, int nSizeIn, void* pBuffOut, int nSizeOut, int* pActualOut);
+#endif
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+void DrvPlatformLyrEsdCheck(struct work_struct *pWork);
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+        
+#endif  /* __MSTAR_DRV_PLATFORM_PORTING_LAYER_H__ */
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_utility_adaption.h
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_utility_adaption.h	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_utility_adaption.h	(revision 166572)
@@ -0,0 +1,109 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_utility_adaption.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_UTILITY_ADAPTION_H__
+#define __MSTAR_DRV_UTILITY_ADAPTION_H__ (1)
+
+
+////////////////////////////////////////////////////////////
+/// Included Files
+////////////////////////////////////////////////////////////
+
+#include "mstar_drv_common.h"
+
+////////////////////////////////////////////////////////////
+/// Constant
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Data Types
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Variables
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Macro
+////////////////////////////////////////////////////////////
+#define BK_REG8_WL(addr,val)    ( RegSetLByteValue( addr, val ) )
+#define BK_REG8_WH(addr,val)    ( RegSetHByteValue( addr, val ) )
+#define BK_REG16_W(addr,val)    ( RegSet16BitValue( addr, val ) )
+#define BK_REG8_RL(addr)        ( RegGetLByteValue( addr ) )
+#define BK_REG8_RH(addr)        ( RegGetHByteValue( addr ) )
+#define BK_REG16_R(addr)        ( RegGet16BitValue( addr ) )
+
+#define PRINTF_EMERG(fmt, ...)  printk(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_ALERT(fmt, ...)  printk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_CRIT(fmt, ...)   printk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__) 
+#define PRINTF_ERR(fmt, ...)    printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_WARN(fmt, ...)   printk(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_NOTICE(fmt, ...) printk(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_INFO(fmt, ...)   printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_DEBUG(fmt, ...)  printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__) 
+
+////////////////////////////////////////////////////////////
+/// Function Prototypes
+////////////////////////////////////////////////////////////
+
+#ifdef CONFIG_ENABLE_DMA_IIC
+extern void DmaAlloc(void);
+extern void DmaReset(void);
+extern void DmaFree(void);
+#endif //CONFIG_ENABLE_DMA_IIC
+extern u16  RegGet16BitValue(u16 nAddr);
+extern u8   RegGetLByteValue(u16 nAddr);
+extern u8   RegGetHByteValue(u16 nAddr);
+extern void RegGetXBitValue(u16 nAddr, u8 * pRxData, u16 nLength, u16 nMaxI2cLengthLimit);
+extern void RegSet16BitValue(u16 nAddr, u16 nData);
+extern void RegSetLByteValue(u16 nAddr, u8 nData);
+extern void RegSetHByteValue(u16 nAddr, u8 nData);
+extern void RegSet16BitValueOn(u16 nAddr, u16 nData);
+extern void RegSet16BitValueOff(u16 nAddr, u16 nData);
+extern u16  RegGet16BitValueByAddressMode(u16 nAddr, AddressMode_e eAddressMode);
+extern void RegSet16BitValueByAddressMode(u16 nAddr, u16 nData, AddressMode_e eAddressMode);
+extern void RegMask16BitValue(u16 nAddr, u16 nMask, u16 nData, AddressMode_e eAddressMode);
+extern s32 DbBusEnterSerialDebugMode(void);
+extern void DbBusExitSerialDebugMode(void);
+extern void DbBusIICUseBus(void);
+extern void DbBusIICNotUseBus(void);
+extern void DbBusIICReshape(void);
+extern void DbBusStopMCU(void);
+extern void DbBusNotStopMCU(void);
+extern void DbBusResetSlave(void);
+extern void DbBusWaitMCU(void);
+extern s32 IicWriteData(u8 nSlaveId, u8* pBuf, u16 nSize);
+extern s32 IicReadData(u8 nSlaveId, u8* pBuf, u16 nSize);
+extern s32 IicSegmentReadDataByDbBus(u8 nRegBank, u8 nRegAddr, u8* pBuf, u16 nSize, u16 nMaxI2cLengthLimit);
+extern s32 IicSegmentReadDataBySmBus(u16 nAddr, u8* pBuf, u16 nSize, u16 nMaxI2cLengthLimit);
+extern void mstpMemSet(void *pDst, s8 nVal, u32 nSize);
+extern void mstpMemCopy(void *pDst, void *pSource, u32 nSize);
+extern void mstpDelay(u32 nTime);
+
+#endif // __MSTAR_DRV_UTILITY_ADAPTION_H__
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_common.c
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_common.c	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_common.c	(revision 166572)
@@ -0,0 +1,185 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_common.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_common.h"
+
+/*=============================================================*/
+// MACRO DEFINITION
+/*=============================================================*/
+
+/*=============================================================*/
+// CONSTANT VALUE DEFINITION
+/*=============================================================*/
+
+
+/*=============================================================*/
+// LOCAL VARIABLE DEFINITION
+/*=============================================================*/
+
+static u32 _gCrc32Table[256]; 
+
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+extern struct i2c_client *g_I2cClient;
+
+/*=============================================================*/
+// DATA TYPE DEFINITION
+/*=============================================================*/
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+/// CRC
+u32 DrvCommonCrcDoReflect(u32 nRef, s8 nCh)
+{
+    u32 nValue = 0;
+    u32 i = 0;
+
+    for (i = 1; i < (nCh + 1); i ++)
+    {
+        if (nRef & 1)
+        {
+            nValue |= 1 << (nCh - i);
+        }
+        nRef >>= 1;
+    }
+
+    return nValue;
+}
+
+u32 DrvCommonCrcGetValue(u32 nText, u32 nPrevCRC)
+{
+    u32 nCRC = nPrevCRC;
+
+    nCRC = (nCRC >> 8) ^ _gCrc32Table[(nCRC & 0xFF) ^ nText];
+
+    return nCRC;
+}
+
+void DrvCommonCrcInitTable(void)
+{
+    u32 nMagicNumber = 0x04c11db7;
+    u32 i, j;
+
+    for (i = 0; i <= 0xFF; i ++)
+    {
+        _gCrc32Table[i] = DrvCommonCrcDoReflect(i, 8) << 24;
+        for (j = 0; j < 8; j ++)
+        {
+            _gCrc32Table[i] = (_gCrc32Table[i] << 1) ^ (_gCrc32Table[i] & (0x80000000L) ? nMagicNumber : 0);
+        }
+        _gCrc32Table[i] = DrvCommonCrcDoReflect(_gCrc32Table[i], 32);
+    }
+}
+
+u8 DrvCommonCalculateCheckSum(u8 *pMsg, u32 nLength)
+{
+    s32 nCheckSum = 0;
+    u32 i;
+
+    for (i = 0; i < nLength; i ++)
+    {
+        nCheckSum += pMsg[i];
+    }
+
+    return (u8)((-nCheckSum) & 0xFF);
+}
+
+u32 DrvCommonConvertCharToHexDigit(char *pCh, u32 nLength)
+{
+    u32 nRetVal = 0;
+    u32 i;
+    
+    DBG(&g_I2cClient->dev, "nLength = %d\n", nLength);
+
+    for (i = 0; i < nLength; i ++)
+    {
+        char ch = *pCh++;
+        u32 n = 0;
+        u8  nIsValidDigit = 0;
+        
+        if ((i == 0 && ch == '0') || (i == 1 && ch == 'x'))
+        {
+            continue;		
+        }
+        
+        if ('0' <= ch && ch <= '9')
+        {
+            n = ch-'0';
+            nIsValidDigit = 1;
+        }
+        else if ('a' <= ch && ch <= 'f')
+        {
+            n = 10 + ch-'a';
+            nIsValidDigit = 1;
+        }
+        else if ('A' <= ch && ch <= 'F')
+        {
+            n = 10 + ch-'A';
+            nIsValidDigit = 1;
+        }
+        
+        if (1 == nIsValidDigit)
+        {
+            nRetVal = n + nRetVal*16;
+        }
+    }
+    
+    return nRetVal;
+}
+
+void DrvCommonReadFile(char *pFilePath, u8 *pBuf, u16 nLength)
+{
+    struct file *pFile = NULL;
+    mm_segment_t old_fs;
+    ssize_t nReadBytes = 0;    
+
+    old_fs = get_fs();
+    set_fs(get_ds());
+
+    pFile = filp_open(pFilePath, O_RDONLY, 0);
+    if (IS_ERR(pFile)) {
+        DBG(&g_I2cClient->dev, "Open file failed: %s\n", pFilePath);
+        return;
+    }
+
+    pFile->f_op->llseek(pFile, 0, SEEK_SET);
+    nReadBytes = pFile->f_op->read(pFile, pBuf, nLength, &pFile->f_pos);
+    DBG(&g_I2cClient->dev, "Read %d bytes!\n", (int)nReadBytes);
+
+    set_fs(old_fs);        
+    filp_close(pFile, NULL);    
+}
+
+//------------------------------------------------------------------------------//
\ No newline at end of file
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_main.h
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_main.h	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_main.h	(revision 166572)
@@ -0,0 +1,194 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_main.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_MAIN_H__
+#define __MSTAR_DRV_MAIN_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+#define PROC_NODE_CLASS                       "class"
+#define PROC_NODE_MS_TOUCHSCREEN_MSG20XX      "ms-touchscreen-msg20xx"
+#define PROC_NODE_DEVICE                      "device"
+#define PROC_NODE_CHIP_TYPE                   "chip_type"
+#define PROC_NODE_FIRMWARE_DATA               "data"
+#define PROC_NODE_FIRMWARE_UPDATE             "update"
+#define PROC_NODE_CUSTOMER_FIRMWARE_VERSION   "version"
+#define PROC_NODE_PLATFORM_FIRMWARE_VERSION   "platform_version"
+#define PROC_NODE_DEVICE_DRIVER_VERSION       "driver_version"
+#define PROC_NODE_SD_CARD_FIRMWARE_UPDATE     "sdcard_update"
+#define PROC_NODE_FIRMWARE_DEBUG              "debug"
+#define PROC_NODE_FIRMWARE_SET_DEBUG_VALUE    "set_debug_value"
+#define PROC_NODE_FIRMWARE_SMBUS_DEBUG        "smbus_debug"
+
+#define PROC_NODE_FIRMWARE_SET_DQMEM_VALUE    "set_dqmem_value"
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+#define PROC_NODE_MP_TEST                     "test"
+#define PROC_NODE_MP_TEST_LOG                 "test_log"
+#define PROC_NODE_MP_TEST_FAIL_CHANNEL        "test_fail_channel"
+#define PROC_NODE_MP_TEST_SCOPE               "test_scope"
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+#define PROC_NODE_FIRMWARE_MODE               "mode"
+#define PROC_NODE_FIRMWARE_SENSOR             "sensor"
+#define PROC_NODE_FIRMWARE_PACKET_HEADER      "header"
+
+#define PROC_NODE_QUERY_FEATURE_SUPPORT_STATUS   "query_feature_support_status"
+#define PROC_NODE_CHANGE_FEATURE_SUPPORT_STATUS  "change_feature_support_status"
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#define PROC_NODE_GESTURE_WAKEUP_MODE         "gesture_wakeup_mode"
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+#define PROC_NODE_GESTURE_DEBUG_MODE          "gesture_debug"
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+#define PROC_NODE_GESTURE_INFORMATION_MODE    "gesture_infor"
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+#define PROC_NODE_REPORT_RATE                 "report_rate"
+#endif //CONFIG_ENABLE_COUNT_REPORT_RATE
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+#define PROC_NODE_GLOVE_MODE                  "glove_mode"
+#define PROC_NODE_OPEN_GLOVE_MODE             "open_glove_mode"
+#define PROC_NODE_CLOSE_GLOVE_MODE            "close_glove_mode"
+#endif //CONFIG_ENABLE_GLOVE_MODE
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+#define PROC_NODE_JNI_NODE                    "msgtool"
+#endif //CONFIG_ENABLE_JNI_INTERFACE
+
+#define PROC_NODE_SELINUX_LIMIT_FIRMWARE_UPDATE     "selinux_limit_update"
+#define PROC_NODE_FORCE_FIRMWARE_UPDATE             "force_fw_update"
+
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR MACRO DEFINITION                                            */
+/*--------------------------------------------------------------------------*/
+
+/*--------------------------------------------------------------------------*/
+/* DATA TYPE DEFINITION                                                     */
+/*--------------------------------------------------------------------------*/
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+extern ssize_t DrvMainProcfsChipTypeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsChipTypeWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareDataRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareDataWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareUpdateRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareUpdateWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsCustomerFirmwareVersionRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsCustomerFirmwareVersionWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsPlatformFirmwareVersionRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsPlatformFirmwareVersionWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsDeviceDriverVersionRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsDeviceDriverVersionWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsSdCardFirmwareUpdateRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsSdCardFirmwareUpdateWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareDebugRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareDebugWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareSetDebugValueRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareSetDebugValueWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareSmBusDebugRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareSmBusDebugWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+
+extern ssize_t DrvMainProcfsFirmwareSetDQMemValueRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareSetDQMemValueWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+extern ssize_t DrvMainProcfsMpTestRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsMpTestWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsMpTestLogRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsMpTestLogWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsMpTestFailChannelRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsMpTestFailChannelWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsMpTestScopeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsMpTestScopeWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+extern ssize_t DrvMainProcfsFirmwareModeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareModeWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareSensorRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareSensorWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwarePacketHeaderRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwarePacketHeaderWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainKObjectPacketShow(struct kobject *pKObj, struct kobj_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainKObjectPacketStore(struct kobject *pKObj, struct kobj_attribute *pAttr, const char *pBuf, size_t nCount);
+
+extern ssize_t DrvMainProcfsQueryFeatureSupportStatusRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsQueryFeatureSupportStatusWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsChangeFeatureSupportStatusRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsChangeFeatureSupportStatusWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern ssize_t DrvMainProcfsGestureWakeupModeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsGestureWakeupModeWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+extern ssize_t DrvMainProcfsGestureDebugModeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsGestureDebugModeWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainKObjectGestureDebugShow(struct kobject *pKObj, struct kobj_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainKObjectGestureDebugStore(struct kobject *pKObj, struct kobj_attribute *pAttr, const char *pBuf, size_t nCount);
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+extern ssize_t DrvMainProcfsGestureInforModeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsGestureInforModeWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+extern ssize_t DrvMainProcfsReportRateRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsReportRateWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+#endif //CONFIG_ENABLE_COUNT_REPORT_RATE
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+extern ssize_t DrvMainProcfsGloveModeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsGloveModeWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsOpenGloveModeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsCloseGloveModeRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+#endif //CONFIG_ENABLE_GLOVE_MODE
+
+extern ssize_t DrvMainProcfsSeLinuxLimitFirmwareUpdateRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsForceFirmwareUpdateRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+
+extern s32 DrvMainTouchDeviceInitialize(void);
+extern void DrvMainRemoveProcfsDirEntry(void);
+
+#endif  /* __MSTAR_DRV_MAIN_H__ */
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_ic_fw_porting_layer.h
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_ic_fw_porting_layer.h	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_ic_fw_porting_layer.h	(revision 166572)
@@ -0,0 +1,109 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_ic_fw_porting_layer.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_IC_FW_PORTING_LAYER_H__
+#define __MSTAR_DRV_IC_FW_PORTING_LAYER_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+#include "mstar_drv_fw_control.h"
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+#include "mstar_drv_mp_test.h"
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern void DrvIcFwLyrOpenGestureWakeup(u32 *pWakeupMode);
+extern void DrvIcFwLyrCloseGestureWakeup(void);
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+extern void DrvIcFwLyrOpenGestureDebugMode(u8 nGestureFlag);
+extern void DrvIcFwLyrCloseGestureDebugMode(void);
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+extern u32 DrvIcFwLyrReadDQMemValue(u16 nAddr);
+extern void DrvIcFwLyrWriteDQMemValue(u16 nAddr, u32 nData);
+
+extern u16 DrvIcFwLyrChangeFirmwareMode(u16 nMode);
+extern void DrvIcFwLyrSelfGetFirmwareInfo(SelfFirmwareInfo_t *pInfo);
+extern void DrvIcFwLyrMutualGetFirmwareInfo(MutualFirmwareInfo_t *pInfo);
+extern u16 DrvIcFwLyrGetFirmwareMode(void); // used for MSG26xxM only
+extern void DrvIcFwLyrRestoreFirmwareModeToLogDataMode(void);
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+extern void DrvIcFwLyrCheckFirmwareUpdateBySwId(void);
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+extern void DrvIcFwLyrVariableInitialize(void);
+extern void DrvIcFwLyrOptimizeCurrentConsumption(void);
+extern u8 DrvIcFwLyrGetChipType(void);
+extern void DrvIcFwLyrGetCustomerFirmwareVersion(u16 *pMajor, u16 *pMinor, u8 **ppVersion);
+extern void DrvIcFwLyrGetPlatformFirmwareVersion(u8 **ppVersion);
+extern void DrvIcFwLyrHandleFingerTouch(u8 *pPacket, u16 nLength);
+extern u32 DrvIcFwLyrIsRegisterFingerTouchInterruptHandler(void);
+extern s32 DrvIcFwLyrUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType);
+extern s32 DrvIcFwLyrUpdateFirmwareBySdCard(const char *pFilePath);
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG26XXM) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG28XX)
+extern void DrvIcFwLyrGetMpTestScope(TestScopeInfo_t *pInfo); // for MSG26xxM/MSG28xx
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM || CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+extern void DrvIcFwLyrCreateMpTestWorkQueue(void);
+extern void DrvIcFwLyrScheduleMpTestWork(ItoTestMode_e eItoTestMode);
+extern void DrvIcFwLyrGetMpTestDataLog(ItoTestMode_e eItoTestMode, u8 *pDataLog, u32 *pLength);
+extern void DrvIcFwLyrGetMpTestFailChannel(ItoTestMode_e eItoTestMode, u8 *pFailChannel, u32 *pFailChannelCount);
+extern s32 DrvIcFwLyrGetMpTestResult(void);
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+        
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+extern void DrvIcFwLyrGetTouchPacketAddress(u16 *pDataAddress, u16 *pFlagAddress); // for MSG26xxM/MSG28xx
+#endif //CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+extern s32 DrvIcFwLyrEnableProximity(void);
+extern s32 DrvIcFwLyrDisableProximity(void);
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+extern void DrvIcFwLyrOpenGloveMode(void);
+extern void DrvIcFwLyrCloseGloveMode(void);
+extern void DrvIcFwLyrGetGloveInfo(u8 *pGloveMode);
+#endif //CONFIG_ENABLE_GLOVE_MODE
+
+#endif  /* __MSTAR_DRV_IC_FW_PORTING_LAYER_H__ */
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_hotknot_queue.c
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_hotknot_queue.c	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_hotknot_queue.c	(revision 166572)
@@ -0,0 +1,292 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_hotknot_queue.c
+ *
+ * @brief   This file defines the queue structure for hotknot
+ *
+ *
+ */
+
+////////////////////////////////////////////////////////////
+/// Included Files
+////////////////////////////////////////////////////////////
+#include "mstar_drv_hotknot_queue.h"
+
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+////////////////////////////////////////////////////////////
+/// Data Types
+////////////////////////////////////////////////////////////
+
+
+
+////////////////////////////////////////////////////////////
+/// LOCAL VARIABLE DEFINITION
+////////////////////////////////////////////////////////////
+static u8 * _gQueue = NULL;
+static u16  _gQFront = 0;
+static u16  _gQRear;
+static u16  _gQSize = HOTKNOT_QUEUE_SIZE;
+
+////////////////////////////////////////////////////////////
+/// EXTERN VARIABLE DECLARATION
+////////////////////////////////////////////////////////////
+extern struct i2c_client *g_I2cClient;
+
+////////////////////////////////////////////////////////////
+/// Macro
+////////////////////////////////////////////////////////////
+#define RESULT_OK                     0
+#define RESULT_OVERPUSH              -1
+#define RESULT_OVERPOP               -2
+
+
+////////////////////////////////////////////////////////////
+/// Function Prototypes
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Function Implementation
+////////////////////////////////////////////////////////////
+
+void _DebugShowQueueArray(u8 *pBuf, u16 nLen)
+{
+    int i;
+
+    for(i=0; i < nLen; i++)
+    {
+        DBG(&g_I2cClient->dev, "%02X ", pBuf[i]);       
+
+        if(i%16==15){  
+            DBG(&g_I2cClient->dev, "\n");
+        }
+    }
+    DBG(&g_I2cClient->dev, "\n");    
+}
+
+
+void CreateQueue()
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    _gQueue = (u8*)kmalloc(sizeof(u8)*_gQSize, GFP_KERNEL );
+    _gQFront = _gQRear = 0;
+}
+
+
+void ClearQueue()
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    _gQFront = _gQRear = 0;
+}
+
+
+int PushQueue(u8 * pBuf, u16 nLength)
+{
+    u16 nPushLen = nLength;   
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    //DBG(&g_I2cClient->dev, "*** Show data to PushQueue() ***\n", __func__);
+    //_DebugShowQueueArray(pBuf, nLength);
+    //DBG(&g_I2cClient->dev, "*** Show Queue data before PushQueue() ***\n", __func__);
+    //_DebugShowQueueArray(_gQueue, _gQSize);
+    
+    DBG(&g_I2cClient->dev, "*** Before PushQueue: _gQFront = %d, _gQRear = %d ***\n", _gQFront, _gQRear);
+
+    if(_gQRear >= _gQFront)
+    {
+        if(nPushLen > 0 && _gQFront == 0 && _gQRear == _gQSize-1)    //full
+        {
+            DBG(&g_I2cClient->dev, "*** PushQueue: RESULT_OVERPUSH ***\n");
+            return RESULT_OVERPUSH;
+        }
+    
+        if(nPushLen > _gQSize-1 - (_gQRear - _gQFront))    //over push
+        {
+            DBG(&g_I2cClient->dev, "*** PushQueue: RESULT_OVERPUSH ***\n");        
+            return RESULT_OVERPUSH;
+        }
+    
+        if(_gQRear+nPushLen <= _gQSize-1)
+        {
+            memcpy(&_gQueue[_gQRear+1], pBuf, nPushLen);
+            _gQRear = _gQRear + nPushLen;
+        }
+        else
+        {
+            u16 nQTmp = (_gQSize-1) -_gQRear;
+            memcpy(&_gQueue[_gQRear+1], pBuf, nQTmp);          //push data from rear to end
+            memcpy(_gQueue, &pBuf[nQTmp], nPushLen - nQTmp);    //push data lest
+            _gQRear = nPushLen - nQTmp - 1;        
+        }           
+    }
+    else    //_gQRear < _gQFront
+    {
+        if(nPushLen > 0 && _gQFront == _gQRear+1)    //full
+        {
+            DBG(&g_I2cClient->dev, "*** PushQueue: RESULT_OVERPUSH ***\n");        
+            return RESULT_OVERPUSH;
+        }
+    
+        if(nPushLen > (_gQFront - _gQRear) - 1)    //over push
+        {
+            DBG(&g_I2cClient->dev, "*** PushQueue: RESULT_OVERPUSH ***\n");        
+            return RESULT_OVERPUSH;
+        }
+        
+        memcpy(&_gQueue[_gQRear+1], pBuf, nPushLen);
+        _gQRear = _gQRear + nPushLen;       
+    }
+
+    //DBG(&g_I2cClient->dev, "*** Show Queue data after PushQueue() ***\n", __func__);
+    //_DebugShowQueueArray(_gQueue, _gQSize);
+
+    DBG(&g_I2cClient->dev, "*** After PushQueue: _gQFront = %d, _gQRear = %d ***\n", _gQFront, _gQRear); 
+
+    return nPushLen;     
+}
+
+
+int PopQueue(u8 * pBuf, u16 nLength)
+{
+    u16 nPopLen = nLength; 
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DBG(&g_I2cClient->dev, "*** Before PopQueue: _gQFront = %d, _gQRear = %d ***\n", _gQFront, _gQRear);  
+
+    if(_gQRear >= _gQFront)
+    {
+        if(nPopLen > 0 && _gQRear == _gQFront)    //empty
+        {
+            DBG(&g_I2cClient->dev, "*** PushQueue: RESULT_OVERPOP ***\n");        
+            return RESULT_OVERPOP;
+        }
+    
+        if(nPopLen > _gQRear - _gQFront)    //over pop
+        {
+            DBG(&g_I2cClient->dev, "*** PushQueue: RESULT_OVERPOP ***\n");        
+            return RESULT_OVERPOP;
+        }
+        
+        memcpy(pBuf, &_gQueue[_gQFront+1], nPopLen);
+        _gQFront = _gQFront + nPopLen;
+    }
+    else    //_gQRear < _gQFront 
+    {
+        if(nPopLen > _gQSize - (_gQFront - _gQRear))    //over pop
+        {
+            DBG(&g_I2cClient->dev, "*** PushQueue: RESULT_OVERPOP ***\n");        
+            return RESULT_OVERPOP;
+        }
+    
+        if(_gQFront + nPopLen <= _gQSize-1)
+        {
+            memcpy(pBuf, &_gQueue[_gQFront+1], nPopLen);
+            _gQFront = _gQFront + nPopLen;
+        }
+        else
+        {
+            u16 nQTmp = (_gQSize-1) -_gQFront;
+            memcpy(pBuf, &_gQueue[_gQFront+1], nQTmp);        //pop data from rear to end
+            memcpy(&pBuf[nQTmp], _gQueue, nPopLen - nQTmp);    //pop data lest
+            _gQFront = nPopLen - nQTmp - 1;        
+        }
+    }
+
+    DBG(&g_I2cClient->dev, "*** After PopQueue: _gQFront = %d, _gQRear = %d ***\n", _gQFront, _gQRear);   
+
+    return nPopLen;    
+}
+
+
+int ShowQueue(u8 * pBuf, u16 nLength)    //just show data, not fetch data
+{
+    u16 nShowLen = nLength; 
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if(_gQRear >= _gQFront)
+    {
+        if(nShowLen > 0 && _gQRear == _gQFront)    //empty
+        {
+            return RESULT_OVERPOP;
+        }
+    
+        if(nShowLen > _gQRear - _gQFront)    //over pop
+        {
+            return RESULT_OVERPOP;            
+        }
+        
+        memcpy(pBuf, &_gQueue[_gQFront+1], nShowLen);
+        //_gQFront = _gQFront + nPopLen;
+    }
+    else    //_gQRear < _gQFront 
+    {
+        if(nShowLen > _gQSize - (_gQFront - _gQRear))    //over pop
+        {
+            return RESULT_OVERPOP;            
+        }
+    
+        if(_gQFront + nShowLen <= _gQSize-1)
+        {
+            memcpy(pBuf, &_gQueue[_gQFront+1], nShowLen);
+            //_gQFront = _gQFront + nPopLen;
+        }
+        else
+        {
+            u16 nQTmp = (_gQSize-1) -_gQFront;
+            memcpy(pBuf, &_gQueue[_gQFront+1], nQTmp);        //pop data from rear to end
+            memcpy(&pBuf[nQTmp], _gQueue, nShowLen - nQTmp);    //pop data lest
+            //_gQFront = nPopLen - nQTmp - 1;        
+        }
+    }
+    
+    return nShowLen;
+}
+
+
+void ShowAllQueue(u8 * pBuf, u16 * pFront, u16 * pRear)    //just show data, not fetch data
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    memcpy(pBuf, _gQueue, HOTKNOT_QUEUE_SIZE);        //pop data from rear to end
+    *pFront = _gQFront;
+    *pRear = _gQRear;    
+}
+
+
+void DeleteQueue()
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    _gQFront = _gQRear = 0;   
+    
+    if (_gQueue)
+    {
+        kfree(_gQueue);
+        _gQueue = NULL;
+    }
+}
+
+#endif //CONFIG_ENABLE_HOTKNOT
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_hotknot.h
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_hotknot.h	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_hotknot.h	(revision 166572)
@@ -0,0 +1,332 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_hotknot.h
+ *
+ * @brief   This file defines the hotknot functions
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_HOTKNOT_H__
+#define __MSTAR_DRV_HOTKNOT_H__
+
+
+////////////////////////////////////////////////////////////
+/// Included Files
+////////////////////////////////////////////////////////////
+#include "mstar_drv_common.h"
+#include "mstar_drv_hotknot_queue.h"
+
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+////////////////////////////////////////////////////////////
+/// Data Types
+////////////////////////////////////////////////////////////
+//typedef int bool;
+
+//#define false   0
+//#define true    !false
+
+
+////////////////////////////////////////////////////////////
+/// Function Prototype
+////////////////////////////////////////////////////////////
+extern void CreateHotKnotMem(void);
+extern void DeleteHotKnotMem(void);
+
+
+////////////////////////////////////////////////////////////
+/// Data Types
+////////////////////////////////////////////////////////////
+typedef struct
+{
+    u8          nCmdId;
+    u8         *pSndData;      //send data to fw  
+    u16         nSndLen;
+    u8         *pRcvData;      //receive data from fw
+    u16         nRcvLen;
+    u16        *pFwMode;
+    s32         nTimeOut;
+} DrvCmd_t;
+
+
+//hotknot cmd
+typedef struct
+{
+    u8         nHeader;
+    u8         nInstruction;
+    u8         szReserved[2];     
+} HotKnotCmd_t;
+
+typedef struct
+{
+    u8         nHeader;
+    u8         nInstruction;
+	u8         nResult;
+    u8         szReserved[38];     
+	u8         nIdentify;    	
+	u8         nCheckSum;
+} DemoHotKnotCmdRet_t;
+
+typedef struct
+{
+    u8         nHeader;
+	u8         nPacketLen_H;  
+	u8         nPacketLen_L;
+	u8         nType;    
+    u8         nInstruction;
+	u8         nResult;
+  //u8         szReserved[40];    //unknown size   	
+  //u8         nCheckSum;
+} DebugHotKnotCmdRet_t;
+
+
+//hotknot auth
+typedef struct
+{
+    u8         nHeader;
+    u8         nInstruction;
+    u8         szReserved[2];     
+} HotKnotAuth_t;
+
+
+//hotknot writecipher
+typedef struct
+{
+    u8         nHeader;
+    u8         nInstruction;      
+	u16        nSMBusAdr;
+    u8         szData[16];     
+	u8         nCheckSum;
+} HotKnotWriteCipher_t;
+//return 0 if success, return 1 if fail
+
+
+//hotknot send
+typedef struct
+{
+    u8         nHeader;
+    u8         nInstruction;      
+	u16        nSMBusAdr;
+    u8         szData[129];     
+	u8         nDataLen_H;  
+	u8         nDataLen_L;  	
+	u8         nCheckSum;
+} HotKnotSnd_t;
+
+typedef struct
+{
+    u8         nHeader;
+	u8         nPacketLen_H;  
+	u8         nPacketLen_L;  		
+    u8         nType;      	
+    u8         nInstruction;      
+	u8         nResult;
+    u8         szReserved[143];     
+	u8         nCheckSum;
+} DemoHotKnotSndRet_t;
+
+typedef struct
+{
+    u8         nHeader;
+	u8         nPacketLen_H;  
+	u8         nPacketLen_L;  		
+    u8         nType;      	
+    u8         nInstruction;      
+	u8         nResult;
+    u8         szReserved[143];
+    u8         szDebug[100];    
+	u8         nCheckSum;
+} DebugHotKnotSndRet_t;
+
+
+//hotknot receive
+typedef struct
+{
+    u8         nHeader;
+    u8         nInstruction;
+	u8         nRequireDataLen_H;  
+	u8         nRequireDataLen_L;  	
+} HotKnotRcv_t;
+
+typedef struct
+{
+    u8         nHeader;      	     
+	u8         nActualHotKnotLen_H;  
+	u8         nActualHotKnotLen_L;   
+    u8         szData[146];    
+	u8         nCheckSum;
+} DemoHotKnotLibRcvRet_t;
+
+typedef struct
+{
+    u8         nHeader;
+	u8         nPacketLen_H;  
+	u8         nPacketLen_L;  		
+    u8         nType;      	
+    u8         szData[143];     
+	u8         nActualDataLen_H;  
+	u8         nActualDataLen_L;  		
+	u8         nCheckSum;
+} DemoHotKnotRcvRet_t;
+
+typedef struct
+{
+    u8         nHeader;
+	u8         nPacketLen_H;  
+	u8         nPacketLen_L;  		
+    u8         nType;      	
+    u8         szData[143];     
+	u8         nActualDataLen_H;  
+	u8         nActualDataLen_L;
+    u8         szDebug[100];    
+	u8         nCheckSum;
+} DebugHotKnotRcvRet_t;
+
+
+//hotknot get queue data
+typedef struct
+{
+    u8         nHeader;
+    u8         nInstruction;
+	u8         nRequireDataLen_H;  
+	u8         nRequireDataLen_L;  	
+} HotKnotGetQ_t;
+
+typedef struct
+{
+    u8         nHeader;
+	u16        nFront;  
+	u16        nRear;  		     	
+    u8         szData[HOTKNOT_QUEUE_SIZE];     
+	u8         nCheckSum;
+} DemoHotKnotGetQRet_t;
+
+
+////////////////////////////////////////////////////////////
+/// Variables
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Macro
+////////////////////////////////////////////////////////////
+#define HOTKNOT_IOCTL_BASE               99
+#define HOTKNOT_IOCTL_RUN_CMD            _IOWR(HOTKNOT_IOCTL_BASE, 0, long)
+#define HOTKNOT_IOCTL_QUERY_VENDOR       _IOR('G', 28, char[30])
+
+
+#define HOTKNOT_CMD                      0x60
+#define HOTKNOT_AUTH                     0x61
+#define HOTKNOT_SEND                     0x62
+#define HOTKNOT_RECEIVE                  0x63
+
+
+//HotKnot CMD
+#define ENABLE_HOTKNOT                   0xA0 
+#define DISABLE_HOTKNOT                  0xA1
+#define ENTER_MASTER_MODE                0xA2 
+#define EXIT_MASTER_MODE                 0xA3 
+#define ENTER_SLAVE_MODE                 0xA4 
+#define EXIT_SLAVE_MODE                  0xA5 
+#define READ_PAIR_STATE                  0xA6 
+#define EXIT_READ_PAIR_STATE             0xA7 
+#define ENTER_TRANSFER_MODE              0xA8 
+#define EXIT_TRANSFER_MODE               0xA9 
+#define READ_DEPART_STATE                0xAA 
+
+//HotKnot AUTH
+#define AUTH_INIT                        0xB0 
+#define AUTH_GETKEYINDEX                 0xB1 
+#define AUTH_READSCRAMBLECIPHER          0xB2 
+
+//Hotknot QueryVersion
+#define QUERY_VERSION                    0xB3
+
+//HotKnot Send
+#define AUTH_WRITECIPHER                 0xC0 
+#define SEND_DATA                        0xC1 
+#define ADAPTIVEMOD_BEGIN                0xC3    //notice fw to begin adaptive modulation
+
+//HotKnot Receive
+#define RECEIVE_DATA                     0xD0 
+
+//HotKnot Send Test
+#define SEND_DATA_TEST                   0xC2 
+
+//HotKnot Get Queue
+#define GET_QUEUE                        0xD1    //decide the size to get queue data
+
+//
+#define DEMO_PD_PACKET_ID                0x5A    //only for PD state in demo mode
+#define DEMO_PD_PACKET_IDENTIFY          0xC0    //only for PD state in demo mode
+#define HOTKNOT_PACKET_ID                0xA7
+#define HOTKNOT_PACKET_TYPE              0x41    //for command and send packet
+#define HOTKNOT_RECEIVE_PACKET_TYPE      0x40
+
+//send length
+#define HOTKNOT_CMD_LEN                  4
+#define HOTKNOT_AUTH_LEN                 4
+#define HOTKNOT_WRITECIPHER_LEN          21
+#define HOTKNOT_SEND_LEN                 136
+#define HOTKNOT_RECEIVE_LEN              4      //TBD
+#define HOTKNOT_MAX_DATA_LEN             128 
+#define HOTKNOT_GETQUEUE_LEN             4 
+
+//receive length
+#define KEYINDEX_LEN                     4
+#define QUERYVERSION_LEN                 4 
+#define CIPHER_LEN                       16
+#define DEMO_PD_PACKET_RET_LEN           43
+#define MAX_PD_PACKET_RET_LEN            100    //TBD  
+#define DEMO_HOTKNOT_SEND_RET_LEN        150
+#define DEMO_HOTKNOT_RECEIVE_RET_LEN     150
+#define DEBUG_HOTKNOT_SEND_RET_LEN       250
+#define DEBUG_HOTKNOT_RECEIVE_RET_LEN    250
+
+//result
+#define RESULT_OK                        0
+#define RESULT_FAIL                      1
+#define RESULT_TIMEOUT                   2
+
+//hotknot mode
+#define HOTKNOT_BEFORE_TRANS_STATE       0x91    //read_pair_state success, fw send 43 bytes to driver
+#define HOTKNOT_TRANS_STATE              0x92    //enter_transfer_mode success, fw send 150 bytes to driver
+#define HOTKNOT_AFTER_TRANS_STATE        0x93    //exit_transfer_mode, fw send 43 bytes to driver
+#define HOTKNOT_NOT_TRANS_STATE          0x94    //enter_slave_mode success, fw send 43 bytes to driver
+
+
+
+////////////////////////////////////////////////////////////
+/// COMPILE OPTION DEFINITION                                        
+////////////////////////////////////////////////////////////
+//#define CONFIG_ENABLE_HOTKNOT_RCV_BLOCKING
+
+
+
+////////////////////////////////////////////////////////////
+/// Function Prototypes
+////////////////////////////////////////////////////////////
+extern void ReportHotKnotCmd(u8 *pPacket, u16 nLength);
+extern long HotKnotIoctl( struct file *pFile, unsigned int nCmd, unsigned long nArg );
+
+
+#endif //CONFIG_ENABLE_HOTKNOT
+#endif // __MSTAR_DRV_HOTKNOT_H__
Index: kernel/drivers/input/touchscreen/msg5846/msg22xx_yyyy_update_bin.h
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/msg22xx_yyyy_update_bin.h	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/msg22xx_yyyy_update_bin.h	(revision 166572)
@@ -0,0 +1,3106 @@
+u8 msg22xx_yyyy_update_bin[49664]={
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xF2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x52,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x36,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x1A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x91,0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xFD,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xEF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xE1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xD3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x90,0xC5,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x1C,0x40,0x00,0x1C,
+0x60,0x00,0x1C,0x80,0x00,0x1C,0xA0,0x00,0x1C,0xC0,0x00,0x1C,0xE0,0x00,0x1D,0x00,
+0x00,0x1D,0x20,0x00,0x1D,0x40,0x00,0x1D,0x60,0x00,0x1D,0x80,0x00,0x1D,0xA0,0x00,
+0x1D,0xC0,0x00,0x1D,0xE0,0x00,0x1E,0x00,0x00,0x1E,0x20,0x00,0x1E,0x40,0x00,0x1E,
+0x60,0x00,0x1E,0x80,0x00,0x1E,0xA0,0x00,0x1E,0xC0,0x00,0x1E,0xE0,0x00,0x1F,0x00,
+0x00,0x1F,0x20,0x00,0x1F,0x40,0x00,0x1F,0x60,0x00,0x1F,0x80,0x00,0x1F,0xA0,0x00,
+0x1F,0xC0,0x00,0x1F,0xE0,0x00,0xC0,0x60,0x00,0x01,0xC8,0x63,0x9F,0xCC,0x84,0x69,
+0x80,0x01,0x90,0x00,0x90,0x00,0x90,0x00,0x90,0x00,0x90,0x00,0x90,0x00,0x90,0x00,
+0xFC,0x21,0xFF,0x60,0xEF,0xE1,0x00,0x80,0xFF,0xE1,0x00,0xA0,0x0F,0xE1,0x08,0xC3,
+0xE0,0x02,0x0F,0x0F,0xE1,0x00,0xC3,0xE0,0x04,0x0F,0x0F,0xE1,0x04,0xC3,0xE0,0x03,
+0x0F,0xEF,0xE1,0x00,0x84,0xC3,0xE0,0x05,0x0F,0xEF,0xE1,0x00,0x88,0xC3,0xE0,0x05,
+0x1F,0xEF,0xE1,0x00,0x8C,0xE4,0x01,0x3A,0xD1,0x90,0x00,0x90,0x00,0x90,0x00,0x90,
+0x00,0x90,0x00,0x90,0x00,0x90,0x00,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x30,0x44,0x0B,
+0x17,0x01,0x98,0x60,0x56,0xF8,0x01,0x4F,0x18,0x79,0x22,0xE0,0x14,0x98,0x62,0x23,
+0x00,0x18,0x58,0x77,0x01,0x85,0x29,0x1C,0x21,0xE0,0x0D,0x41,0x18,0x0D,0x81,0x10,
+0xC1,0x40,0x10,0x01,0x99,0x9E,0xFD,0x4A,0x03,0xB0,0x12,0xEA,0x00,0x46,0xEC,0xBC,
+0x0D,0x61,0x14,0x0D,0xA1,0x0C,0x0C,0x81,0x04,0x0C,0xC1,0x00,0x0D,0x21,0x1C,0x5D,
+0x63,0x00,0x89,0xA5,0x1A,0xEA,0x00,0xE7,0xFF,0xFF,0x60,0x0C,0x81,0x06,0x5C,0x63,
+0x00,0x0C,0xC1,0x02,0x20,0x60,0xD6,0x9A,0xE0,0x21,0x60,0x30,0x21,0x64,0x24,0x5D,
+0x60,0x41,0x4A,0xE1,0x01,0x5C,0x80,0x29,0x4A,0xF7,0x0A,0xD1,0xA1,0x05,0x9E,0xD0,
+0xC1,0x07,0xE6,0xC3,0x14,0x00,0x01,0xCB,0x18,0x3D,0x9C,0x0B,0x18,0x01,0xC3,0x00,
+0x5F,0xEE,0x20,0x03,0xA7,0xE4,0x00,0x01,0xB3,0xE7,0xFF,0xFE,0xDC,0x5C,0x63,0x00,
+0x20,0x64,0x62,0x9A,0xE0,0x21,0x60,0x30,0x21,0x64,0x24,0x5D,0x60,0x41,0x4A,0xE1,
+0x01,0x21,0xA5,0xF6,0xE4,0x00,0x01,0x75,0xE7,0xFF,0xFE,0x9E,0x5C,0x63,0x00,0xD0,
+0x62,0x06,0x4E,0x9A,0xE1,0x21,0x60,0x24,0x5D,0x60,0x21,0x4A,0xE1,0x01,0x21,0xA4,
+0x32,0x13,0x0A,0x00,0x53,0x18,0x01,0x1B,0x0A,0x00,0xC3,0x14,0x00,0x01,0xFD,0x8C,
+0x80,0x02,0xCB,0x38,0x23,0x78,0x0B,0x59,0x01,0x47,0x4C,0xD5,0x5F,0x5A,0x04,0x0F,
+0x59,0x01,0xCB,0x38,0x23,0x6C,0x0B,0x59,0x01,0xC7,0x5A,0x8F,0xFF,0x0F,0x59,0x01,
+0xCB,0x38,0x3C,0xD4,0x0B,0x59,0x01,0x47,0x4C,0xD5,0x5F,0x5A,0x04,0x0F,0x59,0x01,
+0xCB,0x38,0x3C,0xE0,0x0B,0x59,0x01,0xC7,0x5A,0x7F,0xFF,0x0F,0x59,0x01,0xCB,0x18,
+0x3C,0xEC,0x0B,0x38,0x01,0x45,0x8C,0xCD,0x5D,0x8C,0x04,0x0D,0x98,0x01,0x22,0xE5,
+0x6A,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x3C,0x68,0x0B,0x38,0x01,0xFF,0x20,0x11,0x11,
+0x0F,0x38,0x01,0xCB,0x17,0x3C,0x6C,0x0B,0x38,0x01,0xFF,0x20,0x22,0x22,0x0F,0x38,
+0x01,0xCB,0x17,0x3C,0x70,0x0B,0x38,0x01,0xFF,0x20,0x33,0x33,0x0F,0x38,0x01,0xCA,
+0xF7,0x78,0xC0,0xFF,0x00,0xAA,0x55,0x0F,0x17,0x01,0xE4,0x00,0x00,0x01,0x13,0x0A,
+0x00,0x53,0x18,0x01,0x1B,0x0A,0x00,0xE7,0xFF,0xFF,0x6F,0x13,0x0A,0x00,0x45,0x8C,
+0xC4,0x19,0x8A,0x00,0xE7,0xFF,0xFF,0x55,0x0D,0xA1,0x0E,0x0D,0x81,0x12,0x0D,0x61,
+0x16,0x0D,0x41,0x1A,0x0D,0x21,0x1E,0x1C,0x21,0x20,0x85,0x29,0xC2,0xE0,0x10,0x01,
+0xEC,0x77,0x03,0xD4,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x03,0xCC,0xC2,0xE0,0x10,0x01,
+0xEC,0xB7,0x03,0xD0,0xC2,0xE0,0x10,0x01,0xEC,0xD7,0x03,0xE8,0xC2,0xE0,0x10,0x01,
+0xEC,0xF7,0x03,0xE0,0xC2,0xE0,0x10,0x01,0x0F,0x01,0x02,0xED,0x17,0x03,0xE4,0xC2,
+0xE0,0x10,0x01,0xEF,0x17,0x03,0xF4,0xC2,0xE0,0x10,0x01,0x0F,0x01,0x06,0xEF,0x17,
+0x03,0xB8,0xC2,0xE0,0x10,0x01,0x0F,0x01,0x0A,0xEF,0x17,0x03,0xD8,0x85,0x29,0x5C,
+0x84,0x00,0xC2,0xE0,0x10,0x01,0x4C,0x84,0x10,0xFE,0xF7,0x03,0xEC,0x8E,0xE4,0x0C,
+0x77,0x00,0x85,0x29,0x5C,0x63,0x00,0x9B,0x00,0x24,0x68,0x25,0x1F,0x03,0xFE,0x5F,
+0x18,0x00,0xC2,0xE0,0x10,0x01,0xF3,0x57,0x0A,0xE8,0x1E,0xE3,0x01,0x1F,0x9A,0xFF,
+0x5F,0x3C,0x00,0xD7,0x97,0x00,0x50,0x1F,0x23,0x02,0x5F,0x39,0x00,0xC2,0xEF,0xFF,
+0xE1,0xCA,0xF7,0xFF,0xFF,0xE4,0x00,0x00,0x2F,0x4F,0x78,0x10,0x9F,0x01,0x8F,0x64,
+0x5F,0x18,0x00,0x0F,0x7B,0x02,0x5E,0xFB,0x15,0x4A,0xF7,0xD8,0xD7,0x19,0xFF,0x69,
+0x4F,0x03,0x10,0xC3,0x20,0x10,0x01,0x8F,0x04,0xEF,0x39,0x03,0xDA,0x0F,0x18,0x02,
+0xD7,0x38,0x01,0x41,0xC3,0x20,0x10,0x01,0xEF,0x79,0x03,0xD6,0xC3,0x20,0x10,0x01,
+0xEF,0xB9,0x03,0xCE,0xC3,0x20,0x10,0x01,0xEF,0xD9,0x03,0xD2,0xC3,0x20,0x10,0x01,
+0xEF,0x39,0x03,0xEA,0xE4,0x00,0x00,0x49,0xC3,0x20,0x10,0x01,0xEF,0x79,0x03,0xE2,
+0xC3,0x20,0x10,0x01,0xEF,0xB9,0x03,0xE6,0xC3,0x20,0x10,0x01,0xEF,0xD9,0x03,0xF6,
+0xC3,0x20,0x10,0x01,0xEF,0x39,0x03,0xBA,0x20,0x60,0xDE,0x0F,0x44,0x02,0x0F,0x84,
+0x06,0xCF,0x5A,0x00,0x32,0x40,0xE7,0xE3,0xD7,0x47,0x05,0xDC,0x42,0xF7,0x2D,0x40,
+0xA5,0xCB,0x43,0x77,0xDB,0x43,0x3B,0x2C,0xCC,0xC6,0x00,0x0A,0x9B,0x4A,0x8C,0xD9,
+0x98,0x61,0x40,0xC6,0xD0,0xD7,0x06,0x04,0xF4,0x98,0x60,0xE4,0x00,0x01,0x31,0x20,
+0x64,0x6A,0x0F,0x44,0x02,0x0F,0x64,0x06,0xCF,0x5A,0x00,0x32,0x40,0xE7,0xDB,0x98,
+0x60,0xD7,0x47,0x04,0x14,0xE4,0x00,0x00,0x55,0x1C,0xFA,0xFE,0xD4,0x67,0x01,0x9E,
+0x4C,0x63,0x10,0x9F,0x5F,0x4F,0x5A,0x10,0x8F,0x44,0x8C,0x83,0x0F,0x5A,0x02,0x0F,
+0x64,0x02,0xCF,0x5A,0x00,0x32,0x41,0x08,0xDB,0x98,0x60,0xD7,0x48,0x02,0xC4,0x42,
+0xF7,0x2D,0x40,0xA5,0xCB,0x43,0xB7,0xEB,0x43,0x3D,0x2C,0xE7,0xFF,0xFF,0x3B,0xD4,
+0x7C,0x01,0x3E,0x9F,0x5F,0x4C,0xE7,0x10,0x4F,0x5A,0x10,0x98,0x60,0x8F,0x44,0x8C,
+0x87,0x0F,0x5A,0x02,0x0F,0x84,0x02,0xCF,0x5A,0x00,0x32,0x41,0x08,0xE3,0xD7,0x48,
+0x01,0x2C,0xE7,0xFF,0xFE,0xD5,0x42,0xF7,0x2D,0xCC,0xC6,0x00,0x0A,0x43,0xD7,0xF3,
+0x40,0xA5,0xCB,0x9B,0x4A,0x43,0x3E,0x2C,0x8C,0xD9,0x40,0xC6,0xD0,0xD7,0x06,0xFB,
+0x60,0x98,0x61,0x85,0x29,0x5C,0xE7,0x00,0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x0A,0xE8,
+0x42,0xE7,0xBB,0x5E,0xF7,0x00,0x9B,0x00,0x8C,0xB7,0x8C,0xD7,0xC3,0x80,0x10,0x01,
+0xC3,0x40,0x10,0x01,0x5C,0xC6,0x00,0x5C,0xA5,0x00,0x8B,0x38,0x9A,0xE0,0xFF,0x9C,
+0x0B,0xC0,0xFF,0x5A,0x0D,0x04,0xE4,0x00,0x00,0x49,0x4F,0x65,0x10,0x43,0xBB,0xE4,
+0x0F,0xBD,0x02,0x9C,0xA1,0x8E,0xFD,0x5C,0xA5,0x00,0x8B,0xBB,0x8F,0x7A,0x8F,0xBA,
+0x0B,0x7B,0x00,0x0B,0xBD,0x02,0x8F,0x1B,0x8F,0x3D,0xD4,0xA6,0xFF,0x01,0x26,0xE0,
+0xE8,0x27,0x20,0xDC,0x27,0x00,0xD0,0xC3,0x40,0x10,0x01,0xFF,0x5A,0x03,0xEC,0x4C,
+0xE7,0x10,0xCF,0x18,0xFF,0xF6,0x8C,0xFA,0x0F,0x47,0x02,0x43,0x3A,0xCB,0x9F,0x56,
+0x8F,0x19,0x43,0x58,0xD0,0xCF,0x5A,0x07,0xFF,0x43,0x5A,0xB8,0x0F,0x43,0x01,0x0E,
+0xE4,0x00,0x98,0x61,0xE4,0x00,0x00,0x0D,0x98,0x60,0x85,0x29,0x9A,0xE3,0x9B,0x01,
+0xE4,0x00,0x00,0x11,0x8F,0x17,0x9E,0xE2,0xD7,0x03,0xFF,0xE1,0x4C,0x77,0x09,0x9C,
+0x7F,0x85,0x29,0xFF,0x00,0x7F,0xFF,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x03,0xBC,0x0F,
+0x17,0x01,0x0F,0x17,0x03,0x0F,0x17,0x05,0x0F,0x17,0x07,0x0F,0x17,0x09,0x0F,0x17,
+0x0B,0x85,0x29,0xC3,0x00,0x10,0x01,0xFE,0xF8,0x03,0xBC,0xC3,0x00,0x10,0x01,0x0B,
+0x37,0x08,0xFF,0x18,0x0C,0x08,0xC3,0x2F,0xFF,0xE0,0x20,0x00,0x41,0x0B,0x37,0x05,
+0x0F,0x37,0x09,0x0B,0x37,0x07,0xE4,0x00,0x00,0x1B,0x0B,0x38,0x17,0x0F,0x37,0x09,
+0x0B,0x38,0x19,0x0F,0x37,0x0B,0x0B,0x37,0x04,0xC3,0x2F,0xFF,0xE0,0x20,0x00,0x41,
+0x0B,0x37,0x01,0x0F,0x37,0x05,0x0B,0x37,0x03,0xE4,0x00,0x00,0x1B,0x0B,0x38,0x17,
+0x0F,0x37,0x05,0x0B,0x38,0x19,0x0F,0x37,0x07,0x0B,0x38,0x17,0x0B,0x18,0x19,0x0F,
+0x37,0x01,0x0F,0x17,0x03,0x85,0x29,0x1C,0x21,0xD8,0xC2,0xE0,0x10,0x01,0x0D,0x21,
+0x24,0x0D,0x41,0x20,0x0D,0x61,0x1C,0xFD,0x57,0x03,0xBC,0x0D,0x81,0x18,0x0D,0xA1,
+0x14,0x0D,0xC1,0x10,0x09,0xAA,0x07,0x0B,0x0A,0x03,0x43,0x18,0x6D,0x5F,0x18,0x06,
+0x0F,0x01,0x0B,0x43,0x18,0xC3,0xE9,0x97,0x03,0xBD,0x09,0xCA,0x05,0x41,0x8C,0x75,
+0x5D,0x8C,0x06,0x40,0x6C,0x63,0x8C,0x78,0xE7,0xFF,0xFE,0x48,0x0A,0xEA,0x09,0x41,
+0xCE,0xBD,0x0A,0xEA,0x0B,0x42,0xED,0xBD,0x5E,0xF7,0x06,0x0E,0xE1,0x0F,0x42,0xF7,
+0xBB,0x5D,0x63,0x06,0x5D,0x4E,0x06,0x40,0x6A,0x53,0x8C,0x77,0xE7,0xFF,0xFE,0x00,
+0x5E,0xE3,0x06,0x98,0x61,0x21,0x60,0xAC,0x22,0xE0,0xA0,0x43,0x0B,0xB8,0xD3,0x05,
+0x01,0x14,0x41,0x4C,0x53,0x0B,0x01,0x0E,0x09,0x81,0x0A,0x41,0x6B,0xBB,0x43,0x0C,
+0xC3,0x8D,0x58,0xCD,0x4A,0x00,0x64,0x42,0xEA,0x58,0x5E,0xE8,0xB1,0x48,0x61,0x01,
+0x0D,0xC1,0x12,0x0D,0xA1,0x16,0x0D,0x81,0x1A,0x0D,0x61,0x1E,0x0D,0x41,0x22,0x0D,
+0x21,0x26,0x1C,0x21,0x28,0x85,0x29,0x1C,0x21,0xE8,0xC2,0xE0,0x10,0x01,0x0D,0x41,
+0x10,0x0D,0x61,0x0C,0x0D,0x81,0x08,0x0D,0xC1,0x00,0xF1,0x97,0x0A,0x5F,0xC1,0x40,
+0x10,0x01,0x1D,0x6C,0xFF,0x0D,0x21,0x14,0x0D,0xA1,0x04,0x5D,0xC3,0x00,0x5D,0x6B,
+0x00,0xFD,0x4A,0x0C,0x08,0x4E,0xEE,0x5D,0x56,0xF7,0x01,0x22,0xE0,0xD4,0x8A,0xEB,
+0xE4,0x00,0x00,0x43,0xCC,0x77,0x00,0x30,0x1D,0xB7,0x01,0x8C,0x6A,0xCC,0x8D,0x00,
+0x30,0x9C,0x64,0x8C,0x8A,0x50,0xA0,0x30,0x9C,0x84,0xE4,0x00,0x59,0xE0,0x5E,0xED,
+0x00,0xD5,0x97,0xFF,0x1D,0x12,0xEA,0x00,0x22,0xE0,0x20,0x9E,0xFF,0x1A,0xEA,0x00,
+0x21,0x60,0x30,0x9D,0x7F,0x5D,0x6B,0x00,0xE7,0xFF,0xFF,0x7B,0x12,0xEA,0x00,0x22,
+0xE0,0x52,0xC2,0xE0,0x10,0x01,0x9B,0x37,0xEB,0x17,0x08,0x25,0x47,0x18,0xCC,0xEF,
+0x17,0x08,0x25,0x0D,0xC1,0x02,0x0D,0xA1,0x06,0x0D,0x81,0x0A,0x0D,0x61,0x0E,0x0D,
+0x41,0x12,0x0D,0x21,0x16,0x1C,0x21,0x18,0x85,0x29,0x5C,0x63,0x00,0x5C,0x84,0x00,
+0xC2,0xE0,0x10,0x01,0x43,0x64,0x1D,0xF2,0xF7,0x0A,0xE8,0x9F,0x61,0x40,0xA5,0xBB,
+0x5F,0x7B,0x00,0x5C,0xA5,0x00,0x20,0xE4,0x3E,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0A,
+0xF4,0xE4,0x00,0x00,0x19,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0D,0x04,0x43,0x23,0x2C,
+0x9B,0x00,0x4F,0x39,0x10,0x9F,0x22,0x8F,0x37,0xC2,0xEF,0xFF,0xE1,0xCA,0xF7,0xFF,
+0xFF,0xE4,0x00,0x00,0x3D,0x0B,0x99,0xFE,0x0B,0x59,0x00,0x9F,0x24,0x8F,0x5C,0x4F,
+0x98,0x10,0x5E,0xFA,0x15,0x8F,0x86,0x4A,0xF7,0xD0,0x0F,0x5C,0x00,0x9F,0x01,0x5F,
+0x58,0x00,0xD7,0x7A,0xFF,0x1D,0x9B,0x00,0xE4,0x00,0x00,0x29,0x0F,0x26,0x02,0x9F,
+0x01,0x43,0x39,0xBD,0x5F,0x18,0x00,0x0F,0x26,0x00,0x9C,0xC4,0xD7,0x78,0xFF,0x85,
+0x85,0x29,0x1C,0x21,0x88,0x0D,0x41,0x70,0x0D,0x61,0x6C,0x5D,0x44,0x00,0x0D,0x81,
+0x68,0x5C,0x85,0x00,0x0D,0xA1,0x64,0x88,0xA6,0x41,0xA4,0x55,0x0D,0x21,0x74,0x89,
+0x83,0x88,0xC1,0x88,0x6A,0xE7,0xFF,0xFE,0xAA,0xC2,0xE0,0x10,0x01,0x9D,0xA1,0xEB,
+0x57,0x01,0x70,0x9B,0x20,0x5D,0xAD,0x00,0x8B,0x19,0x9A,0xE0,0x89,0x61,0xE4,0x00,
+0x00,0x5B,0x4F,0x79,0x10,0x43,0x99,0x54,0x8F,0x6B,0x0F,0x7B,0x02,0x8E,0xFB,0x23,
+0x44,0x54,0x23,0x48,0x36,0xCF,0x9C,0x00,0x06,0x9F,0x9F,0xE4,0x00,0x00,0x13,0x4F,
+0x9C,0x08,0x9F,0x81,0x43,0x7C,0xDB,0x9F,0x21,0x8F,0x1B,0x5F,0x79,0x00,0xD5,0xBB,
+0xFE,0xA5,0x26,0xE1,0x34,0xC3,0x20,0x10,0x01,0xEB,0x39,0x0A,0xEF,0x43,0x18,0xCB,
+0x23,0x44,0x32,0x4F,0x37,0x0A,0x8F,0x19,0xE4,0x00,0x00,0x35,0x23,0x48,0x46,0xCF,
+0x37,0x00,0x03,0xCE,0xF7,0x00,0x06,0x8F,0x19,0xE4,0x00,0x00,0x13,0x8F,0x17,0x4E,
+0xF7,0x08,0x42,0xF8,0xB8,0xC2,0xE0,0xFF,0xE8,0xCB,0x00,0x07,0xFF,0x98,0x61,0x4A,
+0xF7,0xC0,0x5E,0xFF,0xF9,0x4A,0xF7,0x00,0x0E,0xEC,0x01,0xE4,0x00,0x00,0x0D,0x98,
+0x60,0x0D,0xA1,0x66,0x0D,0x81,0x6A,0x0D,0x61,0x6E,0x0D,0x41,0x72,0x0D,0x21,0x76,
+0x1C,0x21,0x78,0x85,0x29,0xFC,0x21,0xFF,0x78,0xED,0x41,0x00,0x80,0x0D,0x81,0x78,
+0x0D,0xA1,0x74,0x0D,0xC1,0x70,0x0D,0xE1,0x6C,0x0E,0x01,0x68,0x0E,0xC1,0x64,0xED,
+0x21,0x00,0x84,0x0D,0x61,0x7C,0xC1,0x40,0x10,0x01,0xFD,0x4A,0x0A,0xE4,0x11,0x6A,
+0x04,0x4E,0xEB,0x08,0x9E,0xE8,0xC6,0xF7,0x03,0xF8,0xFE,0xC1,0x00,0x88,0x5D,0xC4,
+0x00,0x5D,0xA5,0x00,0x8A,0x03,0x5C,0xA6,0x00,0x89,0xE1,0x41,0x65,0x5B,0x40,0x21,
+0xBD,0x88,0x6E,0x88,0x8D,0xFC,0xD6,0xFF,0x78,0xE7,0xFF,0xFC,0xA2,0xC3,0x40,0x10,
+0x01,0x89,0x81,0x5D,0x6B,0x00,0x13,0x2A,0x04,0x9A,0xE0,0xFF,0x5A,0x04,0x00,0xE4,
+0x00,0x00,0x29,0x4F,0x17,0x08,0x9E,0xE1,0x43,0x6C,0xC4,0x8F,0x1A,0x0B,0x18,0x03,
+0x0F,0x1B,0x01,0x5F,0x17,0x00,0xD7,0x38,0xFF,0x6D,0x43,0x4B,0x74,0x8D,0xAB,0x5F,
+0x5A,0x00,0x5D,0xAD,0x00,0x9A,0xE0,0x1F,0x2D,0x01,0x43,0x39,0xD5,0x5F,0x39,0x00,
+0xE4,0x00,0x00,0x33,0x4F,0x77,0x10,0xFF,0x96,0xFF,0x78,0x8F,0x7C,0x0F,0x7B,0x02,
+0x27,0x60,0x4A,0xD5,0xB8,0x03,0x19,0x9E,0xE1,0x5F,0x17,0x00,0xD7,0x38,0xFF,0x45,
+0x8B,0x1A,0x1F,0x36,0xD8,0x1F,0x76,0xD8,0x4E,0xF8,0x10,0x8E,0xF9,0x0F,0x37,0xA2,
+0x1E,0xF8,0x01,0x43,0x39,0xCB,0x4E,0xF7,0x10,0x8E,0xFB,0x0E,0xF7,0xA2,0x42,0xF7,
+0xBB,0x5F,0x37,0x15,0x4B,0x77,0xC8,0x27,0x60,0xBC,0x8F,0x1A,0x0B,0x6A,0x0B,0x41,
+0x78,0x5D,0x13,0x4A,0x0C,0x4D,0x6B,0x08,0x98,0x61,0x8D,0x8B,0x0B,0x0C,0x00,0x43,
+0x18,0xDB,0x43,0x77,0xDB,0x43,0x18,0xD0,0x8E,0xF9,0x42,0xFB,0xB8,0x8E,0xF8,0x0E,
+0xF0,0x01,0xE4,0x00,0x00,0x0D,0x98,0x60,0x88,0x2F,0x0E,0xC1,0x66,0x0E,0x01,0x6A,
+0x0D,0xE1,0x6E,0x0D,0xC1,0x72,0x0D,0xA1,0x76,0x0D,0x81,0x7A,0x0D,0x61,0x7E,0xED,
+0x41,0x00,0x82,0xED,0x21,0x00,0x86,0xFC,0x21,0x00,0x88,0x85,0x29,0x1C,0x21,0xB8,
+0x0D,0x41,0x40,0xC1,0x40,0x10,0x01,0x0D,0x61,0x3C,0x0D,0x81,0x38,0x0D,0xC1,0x30,
+0x0E,0x41,0x20,0x0E,0x61,0x1C,0x0E,0x81,0x18,0x0E,0xA1,0x14,0x0E,0xC1,0x10,0x0D,
+0x21,0x44,0x0D,0xA1,0x34,0x0D,0xE1,0x2C,0x0E,0x01,0x28,0x0E,0x21,0x24,0x5E,0x63,
+0x00,0x5E,0x44,0x00,0xC1,0xC0,0x10,0x01,0xF0,0x8A,0x0A,0xE4,0xFD,0xCE,0x08,0x26,
+0x98,0xA0,0x88,0x6E,0x99,0x80,0x8A,0xCA,0xE4,0x00,0xA9,0x6E,0xC1,0x40,0x10,0x01,
+0x89,0x6C,0xC2,0xA0,0x10,0x01,0x9A,0x81,0xFD,0x4A,0x0C,0x08,0xE4,0x00,0x01,0x19,
+0xCC,0x6B,0x00,0x30,0xEA,0xF5,0x07,0xDF,0x41,0xA3,0x54,0x56,0xF7,0x02,0x12,0x2D,
+0x04,0x12,0x0D,0x05,0x11,0xED,0x07,0x22,0xE1,0x0C,0x1C,0x61,0x04,0x88,0x91,0x88,
+0xB0,0x88,0xCF,0x98,0xE0,0xE7,0xFF,0xFA,0xDA,0x20,0x61,0x14,0x1C,0x61,0x06,0x88,
+0x91,0x88,0xB0,0x88,0xCF,0x98,0xE0,0xE7,0xFF,0xFC,0x5C,0x20,0x60,0xCC,0x0B,0x01,
+0x04,0xCF,0x18,0x00,0x07,0x0A,0xE1,0x06,0xCE,0xF7,0x00,0x03,0x8E,0xF8,0x9B,0x0A,
+0x42,0xF7,0xC0,0x0E,0xED,0x17,0xE4,0x00,0x00,0x43,0x8C,0x6A,0x88,0x91,0x1C,0x63,
+0x16,0x88,0xB0,0x88,0xCF,0x98,0xE0,0xE7,0xFF,0xFA,0x56,0x20,0x60,0x32,0x4E,0xF4,
+0x5C,0x45,0x8C,0xBD,0x5D,0x8C,0x00,0x88,0x6E,0xF0,0x96,0x0A,0xE4,0x98,0xA1,0x9D,
+0x61,0xE4,0x00,0xA8,0x3C,0x5D,0x6B,0x00,0x12,0xEA,0x00,0xD6,0xEB,0xFB,0xAD,0x88,
+0x6C,0xE7,0xFF,0xF7,0xAC,0x12,0xEA,0x00,0x22,0xE0,0x6C,0xC2,0xE0,0x10,0x01,0xEA,
+0xF7,0x09,0xB9,0x56,0xF7,0x40,0x22,0xE0,0x34,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x03,
+0xCA,0x86,0xE8,0xC2,0xE0,0x10,0x01,0x88,0x6E,0xF0,0x97,0x0A,0xE4,0x98,0xA1,0xE4,
+0x00,0xA7,0xC0,0xC2,0xE0,0x10,0x01,0x99,0x80,0xEA,0xF7,0x09,0xB9,0x89,0x6C,0x56,
+0xF7,0x80,0x99,0xA1,0x22,0xE0,0xFC,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x03,0xDE,0x86,
+0xE8,0xE4,0x00,0x00,0x7F,0xCE,0xEB,0x00,0x30,0x40,0x6A,0xBC,0x8A,0xE3,0x88,0x83,
+0x10,0xB7,0x04,0x1C,0x63,0x18,0x9C,0x8C,0x10,0xD7,0x05,0x10,0xF7,0x07,0xE7,0xFF,
+0xF3,0x0E,0x20,0x60,0x32,0x4E,0xED,0x5C,0x45,0x8C,0xBD,0x5D,0x8C,0x00,0x9D,0x61,
+0x5D,0x6B,0x00,0x12,0xEA,0x00,0xD6,0xEB,0xFE,0x7D,0x88,0x6C,0xE7,0xFF,0xF6,0x96,
+0x22,0x61,0x5C,0x22,0x40,0xFE,0xE4,0x00,0x00,0xA3,0xCD,0x6C,0x00,0x30,0x8D,0x6A,
+0x0A,0xEB,0x16,0x0E,0xE1,0x08,0x0A,0xEB,0x18,0x1C,0x61,0x08,0x0E,0xE1,0x0C,0x1C,
+0x81,0x0C,0xEE,0xED,0x03,0xFE,0x0C,0xAB,0x0E,0x88,0xCE,0x86,0xE8,0x0E,0xE1,0x0A,
+0x9D,0x81,0x0E,0xEB,0x17,0x5D,0x8C,0x00,0x0E,0xE1,0x0E,0x0E,0xEB,0x19,0xE4,0x00,
+0x00,0x25,0xC1,0xC0,0x10,0x01,0x99,0x80,0xC1,0xA0,0x10,0x01,0xFD,0xCE,0x01,0x58,
+0x12,0xEA,0x00,0xD6,0xEC,0xFD,0xBD,0xC2,0xE0,0x10,0x01,0x13,0x6A,0x00,0xEB,0x97,
+0x07,0xDF,0x9B,0x20,0xC2,0xE0,0x10,0x01,0x57,0x9C,0x01,0xFE,0xF7,0x0C,0x20,0xCB,
+0xA0,0x07,0xFF,0xE4,0x00,0x00,0x89,0x0B,0x57,0x01,0x13,0xD7,0xEF,0x5F,0x1A,0x06,
+0x47,0x18,0xC7,0x4F,0x18,0xFA,0x47,0x1A,0xC4,0x5F,0x58,0x06,0xC3,0x40,0xFF,0xE8,
+0x20,0x00,0x1D,0xFF,0x00,0x07,0xFF,0x0F,0x17,0x01,0x5F,0x58,0x06,0x23,0x80,0x48,
+0xCF,0x1A,0x03,0xFF,0x4F,0x5E,0x50,0x43,0x18,0xE8,0x8F,0x1A,0x0F,0x17,0x01,0x9F,
+0x21,0x1E,0xF7,0x30,0x5F,0x39,0x00,0xD7,0x3B,0xFE,0x06,0x0E,0xC1,0x12,0x0E,0xA1,
+0x16,0x0E,0x81,0x1A,0x0E,0x61,0x1E,0x0E,0x41,0x22,0x0E,0x21,0x26,0x0E,0x01,0x2A,
+0x0D,0xE1,0x2E,0x0D,0xC1,0x32,0x0D,0xA1,0x36,0x0D,0x81,0x3A,0x0D,0x61,0x3E,0x0D,
+0x41,0x42,0x0D,0x21,0x46,0x1C,0x21,0x48,0x85,0x29,0x1C,0x21,0xB0,0x0D,0x61,0x44,
+0x0D,0xC1,0x38,0x0D,0xE1,0x34,0x0E,0x61,0x24,0x0E,0xC1,0x18,0x0D,0x21,0x4C,0x0D,
+0x41,0x48,0x0D,0x81,0x40,0x0D,0xA1,0x3C,0x0E,0x01,0x30,0x0E,0x21,0x2C,0x0E,0x41,
+0x28,0x0E,0x81,0x20,0x0E,0xA1,0x1C,0x1E,0xC1,0x50,0xC2,0xE0,0x10,0x01,0x5C,0xC6,
+0x00,0x0C,0x36,0xC4,0x0C,0xD6,0xC0,0xF3,0xD7,0x0A,0xE8,0x8B,0x03,0x4F,0xBE,0x10,
+0x5E,0x64,0x00,0x1E,0xFD,0x0A,0x89,0xC5,0xC6,0xF7,0x07,0xF8,0x5D,0xE7,0x00,0x40,
+0x21,0xBD,0x89,0x61,0x20,0xA8,0x3E,0xC2,0xE0,0x10,0x01,0xEA,0xB7,0x04,0x38,0xE4,
+0x00,0x00,0x0F,0x0A,0xA3,0x1C,0xC3,0x40,0x10,0x01,0x8A,0xEB,0xFF,0x5A,0x0B,0xC0,
+0xCB,0x60,0x20,0x00,0x9B,0x80,0xE4,0x00,0x00,0x7D,0x21,0xC8,0x4A,0x41,0x1A,0xEC,
+0x0D,0x5A,0x02,0x0D,0x08,0x02,0x8D,0x0A,0xE4,0x00,0x00,0x29,0x22,0x60,0x2A,0x0D,
+0x1A,0x02,0xE4,0x00,0x00,0x15,0x41,0x1A,0xEC,0x0D,0x08,0x02,0x0D,0x17,0x00,0x9F,
+0x81,0x0D,0xB7,0x02,0x5F,0x9C,0x00,0x5D,0xBB,0x15,0x9E,0xE4,0x4B,0x6D,0xD8,0x9F,
+0x44,0x5F,0x7B,0x06,0xD7,0x9E,0xFE,0x36,0x45,0xBB,0xDF,0x99,0x40,0x4D,0xAD,0xFA,
+0xC2,0xE0,0x10,0x01,0xC2,0x40,0x10,0x01,0xFE,0x97,0x0C,0x08,0x45,0xAD,0xDC,0x8A,
+0x2A,0x99,0x80,0x8A,0x14,0xFE,0x52,0x0A,0xE4,0xE4,0x00,0x06,0x43,0x21,0xC8,0xBA,
+0xC2,0xE0,0x10,0x01,0x13,0xB4,0x00,0xFF,0x77,0x0C,0x0D,0x9B,0x80,0xE4,0x00,0x00,
+0x35,0x13,0xDB,0xFF,0xD7,0xCA,0x00,0x5D,0x13,0xDB,0x00,0xD5,0x5E,0x13,0xA1,0x9F,
+0x81,0x1F,0x7B,0x30,0x5F,0x9C,0x00,0xD7,0x9D,0xFF,0x56,0x21,0x41,0x52,0x0F,0x4B,
+0x02,0xD6,0xBA,0x12,0xF4,0x0F,0x6B,0x06,0xD7,0x5B,0x00,0x7C,0xD7,0x5B,0x12,0x9E,
+0x0F,0x6B,0x0A,0xD7,0x5B,0x12,0x60,0x08,0xF8,0x20,0x09,0x18,0x22,0x98,0x60,0x0F,
+0x16,0xB4,0x88,0x8B,0x88,0xAD,0x88,0xD5,0xE7,0xFF,0xEB,0x98,0x0F,0x16,0xB6,0xD0,
+0x60,0x11,0x82,0x13,0x54,0x00,0x9B,0x62,0x8F,0x4C,0x99,0x41,0xCF,0x5A,0x00,0x30,
+0x8F,0x54,0x18,0x1A,0x04,0x18,0x1A,0x06,0x1B,0x7A,0x05,0xE4,0x00,0x04,0x41,0x21,
+0x45,0x86,0x0F,0x4B,0x06,0xD6,0xBA,0x10,0x54,0x0F,0x6B,0x02,0xD7,0x7A,0x10,0x1C,
+0x0F,0x6B,0x0A,0xD7,0x5B,0x00,0x7C,0xD7,0x5B,0x0F,0xC6,0x0F,0x6B,0x0E,0xD7,0x5B,
+0x0F,0x88,0x08,0xF8,0x20,0x09,0x18,0x22,0x98,0x61,0x0F,0x16,0xB4,0x88,0x8B,0x88,
+0xAD,0x88,0xD5,0xE7,0xFF,0xEA,0xE2,0x0F,0x16,0xB6,0xD0,0x60,0x0E,0xAA,0x9B,0x61,
+0x13,0x54,0x00,0x5D,0xE0,0x21,0x8F,0x4C,0x99,0x42,0xCF,0x5A,0x00,0x30,0x8F,0x54,
+0x1B,0x7A,0x06,0x18,0x1A,0x04,0x4B,0x63,0x13,0x1B,0x7A,0x05,0xE4,0x00,0x03,0x7F,
+0xD1,0x41,0x06,0x41,0x1F,0x7A,0xFE,0xD7,0x6A,0x06,0x08,0x4F,0x4A,0x10,0x8F,0x4B,
+0x0F,0x5A,0x02,0xD6,0xBA,0x0C,0xE4,0x1F,0x6A,0xFF,0x4F,0x7B,0x10,0x8F,0x6B,0x0F,
+0x7B,0x02,0xD7,0x5B,0x01,0x34,0xD7,0x5B,0x0C,0x4E,0x1F,0x8A,0xFE,0x4F,0x9C,0x10,
+0x8F,0x8B,0x0F,0x9C,0x02,0xD7,0x5C,0x0B,0xD0,0x1F,0xAA,0x01,0x4F,0xBD,0x10,0x8F,
+0xAB,0x0F,0xBD,0x02,0xD7,0xBC,0x0B,0x58,0x1F,0x8A,0x01,0x4F,0x9C,0x10,0x8F,0x8B,
+0x0F,0x9C,0x02,0xD7,0x5C,0x00,0xDC,0xD7,0x5C,0x0A,0xC6,0x1F,0x8A,0x02,0x4F,0x9C,
+0x10,0x8F,0x8B,0x0F,0x9C,0x02,0xD7,0x5C,0x0A,0x48,0xD7,0x9B,0x0A,0x2C,0x08,0xF8,
+0x20,0x09,0x18,0x22,0x88,0x6A,0x0F,0x16,0xB4,0x88,0x8B,0x88,0xAD,0x88,0xD5,0xE7,
+0xFF,0xE9,0x8A,0x0F,0x16,0xB6,0xD0,0x60,0x09,0x4A,0x13,0x74,0x00,0x1F,0x8A,0xFF,
+0x8F,0x6C,0x5F,0x9C,0x00,0x21,0xE4,0x26,0x1F,0x8A,0xFE,0x5F,0x9C,0x00,0xCF,0x7B,
+0x00,0x30,0x43,0x5B,0x84,0x1B,0x9A,0x04,0x19,0x5A,0x06,0x1F,0x4A,0x01,0x5F,0x5A,
+0x00,0x21,0xE4,0x26,0x1F,0x4A,0x02,0x5F,0x5A,0x00,0x8F,0x74,0x9D,0x41,0x1B,0x5B,
+0x05,0x5D,0x4A,0x00,0xE4,0x00,0x01,0xEF,0x4F,0x6A,0x10,0x1F,0x9A,0xFE,0x8F,0x6B,
+0xD5,0x5C,0x04,0x06,0x0F,0x7B,0x02,0xD6,0xBB,0x06,0xC4,0x1F,0x9A,0xFF,0x4F,0x9C,
+0x10,0x8F,0x8B,0x0F,0x9C,0x02,0xD7,0x9B,0x06,0x4C,0x1F,0x9A,0xFD,0x4F,0x9C,0x10,
+0x8F,0x8B,0x0F,0x9C,0x02,0xD7,0x7C,0x00,0xB4,0xD7,0x7C,0x05,0xB6,0x9F,0x5C,0x4F,
+0x5A,0x10,0x8F,0x4B,0x0F,0x5A,0x02,0xD7,0x7A,0x05,0x40,0x08,0xF8,0x20,0x09,0x18,
+0x22,0x88,0x6A,0x0F,0x16,0xB4,0x88,0x8B,0x88,0xAD,0x88,0xD5,0xE7,0xFF,0xE8,0x50,
+0x0F,0x16,0xB6,0xD0,0x60,0x04,0x62,0x13,0x54,0x00,0x1F,0x6A,0xFF,0x8F,0x4C,0x5F,
+0x7B,0x00,0x21,0xE4,0x26,0x1F,0x6A,0xFE,0x5F,0x7B,0x00,0xCF,0x5A,0x00,0x30,0x8F,
+0x50,0x19,0x5A,0x06,0x1B,0x7A,0x04,0x9D,0x41,0x5D,0x4A,0x00,0xE4,0x00,0x00,0xB9,
+0x0F,0x5B,0x02,0xD6,0xBA,0x02,0xE4,0x1F,0x6A,0xFF,0x4F,0x7B,0x10,0x8F,0x6B,0x0F,
+0x7B,0x02,0xD7,0x5B,0x00,0xBC,0xD7,0x5B,0x02,0x4E,0x1F,0x6A,0xFE,0x4F,0x7B,0x10,
+0x8F,0x6B,0x0F,0x7B,0x02,0xD7,0x5B,0x01,0xD0,0x08,0xF8,0x20,0x09,0x18,0x22,0x88,
+0x6A,0x0F,0x16,0xB4,0x88,0x8B,0x88,0xAD,0x88,0xD5,0xE7,0xFF,0xE7,0x74,0x0F,0x16,
+0xB6,0x20,0x60,0x78,0x13,0x54,0x00,0x1F,0x6A,0xFE,0x8F,0x4C,0xCF,0x5A,0x00,0x30,
+0x8F,0x54,0x1B,0x7A,0x04,0x19,0x5A,0x06,0x19,0x5A,0x05,0xE4,0x00,0x00,0x21,0x9D,
+0x41,0x5D,0x4A,0x00,0x13,0x52,0x04,0xD7,0x4A,0xEB,0x35,0x13,0x52,0x04,0xD7,0x4A,
+0x03,0xE1,0x13,0x74,0x00,0x43,0x5B,0x64,0xCF,0xBA,0x00,0x30,0x8F,0xB4,0x13,0x9D,
+0x05,0xD5,0x5C,0x00,0x95,0x1D,0x5C,0x01,0x21,0xE0,0x20,0x11,0x5D,0x06,0x9D,0x42,
+0x5D,0x4A,0x00,0xCF,0x5A,0x00,0x30,0x8F,0x50,0x1A,0x7A,0x07,0x0D,0xDA,0x08,0x1F,
+0x4C,0x01,0x5F,0x5A,0x00,0x8A,0x3A,0x21,0xC9,0x06,0x8F,0x7A,0x1F,0x5B,0xFF,0xCF,
+0x7B,0x00,0x30,0xCF,0x5A,0x00,0x30,0x8F,0x50,0x42,0x3B,0x84,0x1C,0x9A,0x04,0x1C,
+0x71,0x04,0x0F,0x16,0xB4,0x0F,0x56,0xBC,0x50,0xA0,0x30,0xE4,0x00,0x47,0x7E,0x0F,
+0x56,0xBE,0x9B,0x61,0x13,0x5A,0x07,0x43,0x5B,0xD5,0x9D,0x82,0x1B,0x51,0x07,0x5F,
+0x4C,0x00,0x0F,0x16,0xB6,0x4E,0x3A,0x09,0x89,0x9A,0x13,0x52,0x04,0xD7,0x4A,0x00,
+0x69,0x0F,0x56,0xC2,0x8F,0x51,0xD3,0x41,0xFB,0x70,0x13,0x14,0x00,0x8D,0x98,0x88,
+0x71,0x19,0x94,0x00,0x0C,0x36,0xC6,0x0E,0xC1,0x1A,0x0E,0xA1,0x1E,0x0E,0x81,0x22,
+0x0E,0x61,0x26,0x0E,0x41,0x2A,0x0E,0x21,0x2E,0x0E,0x01,0x32,0x0D,0xE1,0x36,0x0D,
+0xC1,0x3A,0x0D,0xA1,0x3E,0x0D,0x81,0x42,0x0D,0x61,0x46,0x0D,0x41,0x4A,0x0D,0x21,
+0x4E,0x1C,0x21,0x50,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x04,0x37,0x85,0x29,
+0xC2,0xE0,0x10,0x01,0xEC,0x77,0x04,0x39,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,
+0x04,0x3B,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x04,0x3D,0x85,0x29,0xC2,0xE0,
+0x10,0x01,0xEC,0x77,0x04,0x3F,0x85,0x29,0xC2,0xE0,0x10,0x01,0xF8,0x77,0x04,0x40,
+0x85,0x29,0xC2,0xE0,0x10,0x01,0x1C,0x21,0xD0,0x0D,0x41,0x28,0x0D,0x61,0x24,0x0D,
+0xA1,0x1C,0x0D,0xE1,0x14,0x0E,0x21,0x0C,0x0E,0x41,0x08,0x0E,0x61,0x04,0x0E,0xC1,
+0x00,0x0D,0x21,0x2C,0x0D,0x81,0x20,0x0D,0xC1,0x18,0x0E,0x01,0x10,0xF3,0x37,0x0A,
+0xE5,0x1E,0xF9,0x07,0xC6,0xF7,0x01,0xF8,0x1E,0xC1,0x30,0x8A,0x21,0xC1,0xE0,0x10,
+0x01,0x40,0x21,0xBD,0xFD,0xEF,0x0B,0x34,0xC2,0x60,0x10,0x01,0x0A,0xEF,0x01,0x89,
+0xA3,0x8A,0x44,0x89,0x61,0x56,0xF7,0x10,0xFD,0x53,0x04,0x34,0x22,0xE0,0x20,0x9A,
+0xE1,0x1A,0xEA,0x00,0xC2,0xE0,0x10,0x01,0xC1,0xC0,0x10,0x01,0xF3,0x77,0x0A,0x5F,
+0xFD,0xCE,0x0C,0x08,0xC1,0x80,0x10,0x01,0x18,0x0E,0x00,0xFD,0x8C,0x0C,0x10,0x9B,
+0x00,0x8A,0xEC,0x9B,0x5F,0xE4,0x00,0x00,0x2B,0x0C,0x17,0x00,0x1B,0x57,0xFE,0x1B,
+0x57,0xFF,0x9F,0x01,0x1E,0xF7,0x30,0x5F,0x18,0x00,0xD7,0x1B,0xFF,0x7E,0xC2,0xE0,
+0x10,0x01,0x98,0x80,0xF0,0x77,0x0A,0xE8,0x40,0x79,0x1B,0xE4,0x00,0x99,0x60,0x98,
+0x80,0x98,0xA1,0x98,0xC0,0x10,0xEA,0x00,0x88,0x6D,0xE7,0xFF,0xF5,0x80,0x98,0x81,
+0x18,0x6B,0x00,0x5E,0x03,0x00,0x98,0xA1,0x88,0x6D,0x98,0xC0,0x10,0xEA,0x00,0xE7,
+0xFF,0xF5,0x56,0x18,0x6B,0x01,0x0B,0x0F,0x01,0x5E,0xE3,0x00,0x57,0x18,0x10,0x23,
+0x01,0xC8,0x26,0x04,0x33,0x26,0xE4,0x27,0x43,0x10,0xBC,0x23,0x09,0x9A,0x18,0x0A,
+0x00,0xC3,0x00,0x10,0x01,0xF3,0x18,0x09,0xB3,0x23,0x04,0x32,0x22,0x04,0x26,0x22,
+0xE4,0x1A,0x18,0x6A,0x00,0xC2,0xE0,0x10,0x01,0x18,0x0E,0x00,0xF3,0x37,0x0A,0x5F,
+0x9B,0x1F,0x9A,0xE0,0xE4,0x00,0x00,0x2B,0x0C,0x0C,0x00,0x1B,0x0C,0xFE,0x1B,0x0C,
+0xFF,0x9E,0xE1,0x1D,0x8C,0x30,0x5E,0xF7,0x00,0xD6,0xF9,0xFF,0x7E,0x98,0x80,0x98,
+0xA1,0x98,0xC0,0x10,0xEA,0x00,0x88,0x6D,0xE7,0xFF,0xF4,0x84,0x98,0x81,0x18,0x6B,
+0x00,0x98,0xA1,0x88,0x6D,0x98,0xC0,0x10,0xEA,0x00,0xE7,0xFF,0xF4,0x60,0x18,0x6B,
+0x01,0x0A,0xEF,0x01,0x56,0xF7,0x04,0xD2,0xE0,0x04,0xCA,0x13,0x0E,0x00,0xD3,0x01,
+0x04,0x91,0xC2,0xE0,0x10,0x01,0x98,0x60,0xF1,0xF7,0x0A,0xE8,0x1D,0x98,0xFF,0x8A,
+0xE3,0xC3,0x00,0x10,0x01,0x9A,0x01,0xFF,0x18,0x0B,0xC0,0xE4,0x00,0x00,0xDB,0xCF,
+0x37,0x00,0x30,0x8F,0x2E,0x11,0x19,0x07,0x13,0xB9,0x06,0x43,0x6F,0x43,0x5F,0x7B,
+0x00,0x43,0x9D,0xDC,0x4F,0x3C,0x10,0x8F,0x38,0x0A,0x72,0x00,0x0F,0x59,0x02,0x1F,
+0x37,0x01,0xCF,0xD9,0x00,0x30,0x8F,0xCE,0x10,0x9E,0x07,0xD4,0x88,0x01,0xC6,0x9F,
+0xA2,0x13,0xDE,0x06,0xD7,0xBE,0x01,0x7E,0x8F,0x7D,0x4F,0x7B,0x10,0x8F,0x78,0x0F,
+0x7B,0x02,0xD7,0x7A,0x01,0x0C,0x9F,0x81,0x43,0x5A,0x98,0x4F,0x9C,0x10,0x8F,0x98,
+0x0F,0x9C,0x02,0x43,0x7B,0xE5,0xD7,0x5B,0x00,0x68,0x4F,0x30,0xCC,0x44,0x63,0xCD,
+0x5C,0x63,0x00,0x9E,0xE1,0x5E,0xF7,0x00,0xD5,0x97,0xFC,0xBC,0xE7,0xFF,0xE7,0xD6,
+0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x0A,0xE5,0x26,0xE4,0x89,0x13,0x0B,0x00,0x27,0x04,
+0x73,0x12,0xEB,0x01,0x26,0xE4,0x5B,0x5F,0x17,0x17,0x88,0x6D,0x48,0xD7,0xC0,0x98,
+0x80,0x98,0xA2,0x10,0xEA,0x00,0xE7,0xFF,0xF2,0xC8,0x88,0x31,0x0E,0xC1,0x02,0x0E,
+0x61,0x06,0x0E,0x41,0x0A,0x0E,0x21,0x0E,0x0E,0x01,0x12,0x0D,0xE1,0x16,0x0D,0xC1,
+0x1A,0x0D,0xA1,0x1E,0x0D,0x81,0x22,0x0D,0x61,0x26,0x0D,0x41,0x2A,0x0D,0x21,0x2E,
+0x1C,0x21,0x30,0x85,0x29,0x1C,0x21,0x90,0x5C,0x63,0x00,0x0D,0x41,0x68,0x0D,0x61,
+0x64,0x0D,0x81,0x60,0x0D,0xA1,0x5C,0x0D,0xC1,0x58,0x0D,0xE1,0x54,0x0E,0x81,0x40,
+0x5D,0xE8,0x00,0x5C,0x84,0x00,0x5D,0xE1,0x3B,0xC2,0xE0,0x10,0x01,0xC1,0xA0,0x10,
+0x01,0xC1,0x80,0x10,0x01,0x0D,0x21,0x6C,0x0E,0x01,0x50,0x0E,0x21,0x4C,0x0E,0x41,
+0x48,0x0E,0x61,0x44,0x0E,0xA1,0x3C,0x0E,0xC1,0x38,0x0C,0x61,0x0C,0x0C,0x81,0x10,
+0x0C,0xC1,0x08,0x0C,0xE1,0x14,0x49,0xEF,0x52,0x99,0xC1,0x99,0x40,0x51,0x60,0xFF,
+0xFE,0x97,0x0C,0x08,0xFD,0xAD,0x0A,0xE4,0xFD,0x8C,0x04,0x36,0xE4,0x00,0x0A,0x13,
+0xE4,0x00,0x96,0xBE,0xCF,0x15,0x00,0x30,0x8F,0x14,0x0B,0x38,0x18,0x0B,0x58,0x16,
+0x0F,0x21,0x30,0x0F,0x41,0x28,0x0F,0x38,0x0E,0x0C,0x01,0x2C,0x0F,0x21,0x20,0x0C,
+0x01,0x34,0x0C,0x01,0x24,0x12,0x58,0x04,0x12,0x38,0x05,0x12,0x78,0x07,0x0F,0x38,
+0x0A,0xD3,0x20,0x2D,0x1A,0x23,0x25,0x3E,0x9B,0x0A,0x09,0x0D,0x0B,0x13,0xD4,0x00,
+0x41,0x0F,0x43,0x9A,0x01,0x41,0x08,0xC0,0x8B,0x0E,0xE4,0x00,0x00,0x65,0xCF,0x38,
+0x00,0x30,0x8F,0x34,0x13,0xB9,0x07,0x43,0xB0,0xED,0xD6,0x7D,0x00,0xEE,0x0F,0xB9,
+0x0A,0x23,0xA4,0x5A,0x0B,0xB9,0x16,0x43,0xBA,0xED,0x4F,0x3D,0xFA,0x47,0xB9,0xEE,
+0x43,0x3D,0xCD,0xD5,0x19,0x26,0x5C,0x9F,0x01,0x5F,0x18,0x00,0xD7,0xD8,0xFE,0x95,
+0xE4,0x00,0x0A,0x25,0x9A,0x00,0xD3,0x22,0x0B,0x7E,0x13,0xB4,0x00,0x8B,0x2E,0x9B,
+0xC1,0xE4,0x00,0x00,0x63,0xCF,0x59,0x00,0x30,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0C,
+0x08,0x8F,0x57,0x11,0x1A,0x07,0x41,0x1E,0x45,0xD6,0x68,0x00,0xA6,0x0D,0x1A,0x0A,
+0x21,0x08,0x36,0x11,0x18,0x06,0x13,0x5A,0x06,0xD5,0x1A,0x24,0x5A,0x9F,0x21,0x5F,
+0x39,0x00,0xD7,0xB9,0xFE,0x9D,0xE4,0x00,0x09,0xFB,0xEB,0x18,0x09,0xB9,0x57,0x18,
+0x80,0xD3,0x00,0x05,0x02,0xC3,0x00,0x10,0x01,0x1C,0x61,0x1C,0xEF,0x18,0x03,0xB6,
+0x08,0x81,0x19,0x88,0xB2,0x88,0xD1,0x88,0xF0,0x87,0x08,0xD0,0x60,0x07,0xEA,0xC2,
+0xF8,0x00,0x21,0xFE,0xF7,0xB6,0xFC,0x0C,0x77,0x02,0xC2,0xE0,0x10,0x01,0xFE,0xF7,
+0x01,0x58,0x98,0xA0,0x10,0x97,0x24,0xE4,0x00,0x95,0x90,0x13,0x0D,0x04,0x10,0x6D,
+0x01,0x98,0x81,0x40,0x63,0xC3,0xE4,0x00,0x93,0x2A,0x0E,0xE1,0x16,0x9E,0xC3,0x4E,
+0xD6,0x18,0x8E,0xD7,0x0B,0x16,0x04,0x0C,0x96,0x0A,0x40,0x84,0xC5,0x5C,0x9F,0xF9,
+0x0C,0x61,0x1E,0x48,0x84,0x00,0x88,0xB2,0x88,0xD1,0x88,0xF0,0xC3,0x00,0x10,0x01,
+0xEF,0x18,0x03,0xFA,0x87,0x08,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xB6,0xFC,0x0C,0x77,
+0x02,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x01,0x58,0x98,0xA1,0x10,0x97,0x24,0xE4,0x00,
+0x94,0xE2,0x13,0x0D,0x04,0x10,0x6D,0x01,0x98,0x81,0x40,0x63,0xC3,0xE4,0x00,0x92,
+0x7C,0x1C,0x61,0x1A,0x1C,0x81,0x24,0x88,0xB2,0x88,0xD1,0x88,0xF0,0xE7,0xFF,0xDF,
+0x90,0x20,0x61,0x9C,0x0B,0x01,0x18,0x0F,0x01,0x2C,0x0B,0x01,0x1A,0x0F,0x01,0x34,
+0x0E,0xE1,0x0E,0x22,0xE0,0x9C,0x0E,0xE1,0x12,0x22,0xE0,0x84,0xC2,0xF8,0x00,0x21,
+0xFE,0xF7,0xB7,0x00,0xC3,0x00,0x10,0x01,0x1C,0x61,0x2C,0xEF,0x18,0x03,0xFE,0x1C,
+0x81,0x34,0x0C,0xA1,0x26,0x0C,0xD7,0x02,0x87,0x08,0x0F,0x21,0x36,0x5F,0x3F,0xF9,
+0xCB,0x00,0x07,0xFF,0x4B,0x39,0x00,0xCF,0x53,0xFC,0x00,0xC3,0x20,0xFF,0xE8,0xFF,
+0x5A,0x04,0x00,0x4B,0x39,0xC0,0x9A,0x00,0xCF,0x39,0x03,0xFF,0x43,0x19,0xC0,0x8F,
+0x1A,0x0F,0x01,0x34,0xE4,0x00,0x00,0x23,0x0C,0x01,0x2C,0x0C,0x01,0x34,0x0C,0x01,
+0x24,0xE4,0x00,0x06,0x1F,0xC3,0x00,0x10,0x01,0x0F,0xA1,0x26,0xEA,0x38,0x0B,0x35,
+0x0E,0x41,0x22,0x57,0x11,0x02,0x23,0x00,0xE8,0x0E,0xE1,0x0A,0x0B,0x17,0x02,0xD6,
+0x58,0x00,0x44,0xD7,0xB8,0x01,0x38,0x53,0x00,0x64,0xD7,0xB2,0x00,0x5C,0x43,0x12,
+0xC0,0xE4,0x00,0x00,0x0F,0x43,0x1D,0xC0,0x0E,0xE1,0x0A,0x0B,0x37,0x05,0x43,0x18,
+0xCB,0x0B,0x2C,0x09,0x8F,0x19,0xE4,0x00,0x00,0x0F,0x0B,0x0C,0x09,0x0F,0x0C,0x07,
+0x0F,0x01,0x32,0x0F,0xC1,0x36,0x08,0x6C,0x07,0x42,0xD8,0xF5,0x8B,0x52,0x5E,0xD6,
+0x06,0x8B,0x3D,0x4D,0x16,0xFA,0x4C,0x63,0x08,0x46,0xC8,0xB6,0x41,0x16,0x45,0xD4,
+0x68,0x19,0x10,0xD6,0x5D,0x00,0x90,0x11,0x0C,0x0A,0x41,0x08,0xEB,0xD5,0x12,0x18,
+0xA0,0xE4,0x00,0x05,0xE7,0xD7,0xB2,0x18,0x60,0x11,0x0C,0x0A,0x41,0x08,0x93,0xD5,
+0x1D,0x18,0x10,0xE4,0x00,0x05,0xC3,0x89,0x16,0xD7,0xB2,0x00,0xD0,0x9B,0x21,0x43,
+0x99,0x9D,0x8B,0x38,0x89,0x11,0x8B,0x1E,0x5E,0x7C,0x00,0x8B,0xD9,0x8A,0x36,0x8B,
+0x5D,0x8B,0x32,0x40,0xBA,0xCC,0x40,0x68,0x8D,0x42,0x5A,0xCD,0x5C,0x7F,0xF9,0x4F,
+0xB2,0xFA,0x4A,0xDA,0xC8,0x46,0x5D,0x96,0x48,0x99,0xD0,0x42,0x52,0xED,0x9E,0x41,
+0x42,0x52,0x28,0x4C,0xA3,0xFA,0xCE,0x52,0xFF,0xF6,0x44,0x65,0x1E,0x9E,0x4A,0x40,
+0xA3,0x2D,0x26,0x44,0x17,0x9A,0x42,0x5F,0xB2,0x00,0x52,0x40,0x14,0x43,0xA5,0xE8,
+0x5F,0xBD,0x06,0x5F,0xA2,0x79,0x4B,0xBD,0x90,0x42,0x44,0xB4,0x26,0x41,0x10,0x8E,
+0x28,0x4C,0x71,0xFA,0x46,0x23,0x8E,0x42,0x31,0x1D,0x4E,0x31,0x0A,0x5C,0x71,0x06,
+0x40,0xA3,0xED,0x8C,0x7D,0x40,0x85,0x23,0x42,0xC3,0xB3,0x8E,0xC4,0x42,0x56,0x90,
+0x42,0x32,0x8D,0x5E,0x52,0x06,0x5E,0x31,0x06,0x4E,0xD1,0xFA,0x46,0x36,0x8E,0x42,
+0x31,0xB5,0x41,0x08,0x8B,0x42,0x3D,0x8D,0x42,0x52,0x8B,0x8D,0x12,0x41,0x08,0xE8,
+0xCF,0xB5,0x00,0x30,0x8F,0xB4,0x0D,0x1D,0x17,0xC3,0xA0,0x10,0x01,0xF3,0xBD,0x04,
+0x40,0x41,0x19,0xEB,0xD7,0x48,0x01,0x34,0x4D,0x19,0x08,0xD5,0x1A,0x01,0x0C,0x4D,
+0x1D,0x08,0xCE,0x3A,0xFF,0xFE,0x41,0x08,0xCB,0x9F,0xBE,0x8D,0x11,0x43,0xBD,0xD3,
+0x43,0x28,0xCB,0x43,0x39,0xE8,0xE4,0x00,0x00,0x0D,0x9B,0x20,0x22,0x60,0x26,0x8B,
+0x99,0x8B,0x3A,0x8B,0x5C,0x43,0xB8,0xF4,0x42,0x39,0xD4,0x4F,0x9D,0xFA,0x47,0xBC,
+0xEE,0x43,0xBD,0xE5,0x4F,0xBD,0x0A,0x5D,0x1D,0x06,0x26,0x21,0x54,0x43,0x98,0x45,
+0xFF,0x9C,0x01,0x2B,0xC3,0x80,0x4A,0xCE,0x20,0x01,0x1D,0x43,0xD8,0xF5,0x4F,0x9E,
+0xFA,0x47,0xDC,0xF6,0x43,0x9E,0xE5,0x4F,0x9C,0x0A,0x9F,0x81,0x5F,0x9C,0x06,0x43,
+0xC8,0xE5,0x8D,0x1C,0x43,0x48,0xD3,0x43,0x3E,0xCB,0x8F,0x3A,0x43,0x39,0x88,0x43,
+0xB9,0xED,0x5F,0x39,0x06,0x5F,0xBD,0x06,0x4F,0x5D,0xFA,0x47,0xBA,0xEE,0x43,0xBD,
+0xD5,0x43,0x18,0xEB,0x43,0xBC,0xED,0x43,0x39,0xEB,0x8F,0x19,0x43,0x18,0xE0,0xCF,
+0x35,0x00,0x30,0x8F,0x34,0x0F,0x19,0x19,0xE4,0x00,0x01,0x91,0xD7,0xB2,0x00,0xB0,
+0x9B,0x01,0x8B,0x32,0x43,0x98,0x9D,0x8B,0x5D,0x5E,0x7C,0x00,0x8B,0x1E,0xE4,0x00,
+0x00,0x11,0x8B,0x3D,0x8B,0x52,0xC3,0xC0,0x10,0x01,0xF3,0xDE,0x04,0x40,0x40,0x79,
+0xF3,0xD7,0x43,0x01,0x34,0x4C,0x79,0x08,0xD4,0x7A,0x01,0x0C,0x4C,0x7E,0x08,0xCC,
+0x9A,0xFF,0xFE,0x40,0x63,0xCB,0x9F,0xDE,0x8C,0x64,0x43,0xDE,0xD3,0x43,0x23,0xCB,
+0x43,0x39,0xF0,0xE4,0x00,0x00,0x0D,0x9B,0x20,0x22,0x60,0x26,0x8B,0x99,0x8B,0x3A,
+0x8B,0x5C,0x43,0x99,0xD4,0x27,0x81,0x50,0xC3,0x00,0x7F,0xEC,0x20,0x00,0x49,0xCB,
+0xC0,0x04,0x00,0x43,0xDE,0xC5,0xC3,0xC0,0x25,0x68,0xE4,0x00,0x00,0x11,0xC3,0x00,
+0xA5,0x68,0x4B,0xC1,0x01,0x23,0xC0,0xD0,0xCF,0x5A,0x04,0x50,0x53,0xC0,0x50,0xCF,
+0x39,0x03,0xB0,0x8F,0x3A,0x43,0x39,0xE0,0xFF,0x99,0xFC,0x00,0x5F,0x39,0x06,0x5F,
+0x9C,0x06,0x4F,0x5C,0xFA,0x47,0x9A,0xE6,0x43,0x9C,0xD5,0x43,0x18,0xE3,0x43,0x9E,
+0xE5,0x43,0x39,0xE3,0x8F,0x19,0x43,0x18,0xF0,0xCF,0x35,0x00,0x30,0x42,0x52,0xB3,
+0x8F,0x34,0x42,0x3D,0x8B,0x0F,0x19,0x19,0x8E,0x32,0x41,0x11,0x40,0x0D,0x19,0x17,
+0xCF,0x75,0x00,0x30,0x8F,0x74,0x0F,0x1B,0x0A,0x23,0x04,0x62,0x9B,0x22,0x0F,0x3B,
+0x08,0x22,0x00,0xFC,0xCF,0x2B,0x00,0x30,0x8F,0x34,0x0C,0x19,0x08,0xE4,0x00,0x00,
+0x55,0x23,0x08,0xBE,0xCF,0x0B,0x00,0x30,0x8F,0x14,0x0C,0x18,0x08,0x9B,0x01,0xE4,
+0x00,0x00,0x31,0x0C,0x18,0x08,0xCF,0x0B,0x00,0x30,0x8F,0x14,0x0C,0x18,0x08,0x9B,
+0x01,0x4F,0x78,0xAC,0x45,0x4A,0xDD,0x4F,0x18,0x5C,0x45,0x58,0x55,0x5D,0x4A,0x00,
+0x9D,0xC1,0x5D,0xCE,0x00,0x1F,0x6E,0xFF,0xC2,0xF8,0x00,0x21,0x5E,0xBB,0x00,0xFE,
+0xF7,0xB6,0xF8,0x13,0x14,0x00,0x0C,0x77,0x02,0x10,0x8D,0x00,0x98,0xA1,0xD7,0x15,
+0xD7,0x15,0xE4,0x00,0x8C,0x7A,0x88,0x6A,0xE7,0xFF,0xDB,0xFE,0x13,0x14,0x00,0x5F,
+0x38,0x00,0x27,0x28,0x15,0x9B,0x02,0x1B,0x14,0x00,0xE4,0x00,0x01,0x4D,0x89,0x78,
+0xE4,0x00,0x00,0x0D,0x89,0x79,0xCF,0x0B,0x00,0x30,0x8F,0x14,0x0B,0x38,0x16,0x9A,
+0x01,0x0F,0x21,0x2C,0x0B,0x38,0x18,0x0F,0x18,0x0E,0x0F,0x21,0x34,0x0F,0x01,0x24,
+0xE7,0xFF,0xF9,0x2B,0x41,0x12,0xEC,0xCE,0xD5,0x00,0x30,0x8E,0xD4,0x0D,0x16,0x0C,
+0x54,0x71,0x08,0x0E,0xC1,0x2A,0x0E,0x21,0x2E,0xD0,0x60,0xF3,0x9A,0xE7,0xFF,0xFA,
+0x15,0xCF,0x15,0x00,0x30,0x8F,0x14,0x0F,0x38,0x0A,0xD3,0x22,0xFB,0xB6,0xE7,0xFF,
+0xFE,0xAB,0xC3,0x00,0x10,0x01,0x9A,0xC1,0xE8,0xF8,0x09,0xB9,0x0F,0x01,0x04,0x42,
+0xD6,0x9D,0x54,0xE7,0x40,0x5E,0x16,0x00,0x1C,0x61,0x18,0x88,0x92,0x88,0xB1,0x88,
+0xD0,0x4C,0xE7,0x31,0xE7,0xFF,0xDD,0x3C,0x0F,0x01,0x06,0xD0,0x60,0xD8,0x7E,0xE7,
+0xFF,0xF8,0x53,0xCF,0x15,0x00,0x30,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0C,0x08,0x8F,
+0x17,0x0C,0x18,0x08,0x9B,0x01,0x4F,0x78,0xAC,0x45,0x4A,0xDD,0xE7,0xFF,0xFE,0x43,
+0x0E,0xC1,0x3A,0x0E,0xA1,0x3E,0x0E,0x81,0x42,0x0E,0x61,0x46,0x0E,0x41,0x4A,0x0E,
+0x21,0x4E,0x0E,0x01,0x52,0x0D,0xE1,0x56,0x0D,0xC1,0x5A,0x0D,0xA1,0x5E,0x0D,0x81,
+0x62,0x0D,0x61,0x66,0x0D,0x41,0x6A,0x0D,0x21,0x6E,0x1C,0x21,0x70,0x85,0x29,0x20,
+0x60,0x2E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x01,0x2C,0x85,0x29,0x20,0x60,0x4E,0xC2,
+0xE0,0x10,0x01,0xEC,0x97,0x00,0xF0,0xC2,0xE0,0x10,0x01,0xEC,0xB7,0x01,0x28,0x85,
+0x29,0x20,0x60,0x5E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x04,0x48,0xC2,0xE0,0x10,0x01,
+0xEC,0xB7,0x04,0x4C,0xE4,0x00,0x00,0x5D,0x20,0x64,0x5E,0xC2,0xE0,0x10,0x01,0xEC,
+0x97,0x04,0x7C,0xC2,0xE0,0x10,0x01,0xEC,0xB7,0x04,0x70,0xE4,0x00,0x00,0x2F,0x20,
+0x68,0x4E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x04,0x68,0xC2,0xE0,0x10,0x01,0xEC,0xB7,
+0x04,0x44,0x85,0x29,0x20,0x68,0x2E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x04,0x64,0x85,
+0x29,0x5C,0x84,0x04,0x20,0x60,0x3E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x01,0x33,0xE4,
+0x00,0x00,0x3D,0x20,0x64,0x3E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x01,0x15,0xE4,0x00,
+0x00,0x1F,0x20,0x68,0x2E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x01,0x35,0x85,0x29,0x5C,
+0x84,0x04,0x20,0x60,0x3E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x00,0xF5,0xE4,0x00,0x00,
+0x3D,0x20,0x64,0x3E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x01,0x31,0xE4,0x00,0x00,0x1F,
+0x20,0x68,0x2E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x01,0x0D,0x85,0x29,0x5C,0x84,0x04,
+0x20,0x68,0x2E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x01,0x0F,0x85,0x29,0x1C,0x21,0xC8,
+0x0D,0x21,0x34,0x0D,0x41,0x30,0x0D,0x61,0x2C,0x0D,0x81,0x28,0x0D,0xA1,0x24,0x0D,
+0xC1,0x20,0x0D,0xE1,0x1C,0x0E,0x01,0x18,0x0E,0x21,0x14,0x0E,0x41,0x10,0x0E,0x61,
+0x0C,0x0E,0x81,0x08,0x0E,0xA1,0x04,0x0E,0xC1,0x00,0x20,0x65,0x70,0x20,0x60,0x4C,
+0xD0,0x62,0x04,0x42,0x99,0xC0,0x89,0xEE,0xD0,0x63,0x06,0x66,0xE4,0x00,0x01,0x71,
+0xC2,0xE0,0x10,0x01,0xEE,0xD7,0x00,0xF2,0xC2,0xE0,0x10,0x01,0xEE,0xB7,0x01,0x2A,
+0xC2,0xE0,0x10,0x01,0xEE,0x97,0x04,0x4A,0xC2,0xE0,0x10,0x01,0xEE,0x77,0x04,0x4E,
+0xC2,0xE0,0x10,0x01,0xE9,0xF7,0x01,0x33,0xC2,0xE0,0x10,0x01,0x9A,0x00,0xE9,0xD7,
+0x00,0xF5,0x99,0xA0,0xC2,0xE0,0x10,0x01,0x9A,0x21,0xED,0x77,0x01,0x2E,0x9A,0x45,
+0x89,0x90,0xE4,0x00,0x00,0xD9,0xC2,0xE0,0x10,0x01,0xEE,0x97,0x04,0x7E,0xC2,0xE0,
+0x10,0x01,0xEE,0x77,0x04,0x72,0xC2,0xE0,0x10,0x01,0x99,0xA0,0xE9,0xF7,0x01,0x15,
+0x9A,0x00,0xC2,0xE0,0x10,0x01,0x8A,0x2D,0xE9,0xD7,0x01,0x31,0x9A,0x40,0x99,0x61,
+0x89,0x90,0x9A,0xA0,0xE4,0x00,0x00,0x71,0xC2,0xE0,0x10,0x01,0xEE,0x97,0x04,0x6A,
+0xC2,0xE0,0x10,0x01,0xEE,0x17,0x04,0x66,0xC2,0xE0,0x10,0x01,0xE9,0xF7,0x01,0x35,
+0xC2,0xE0,0x10,0x01,0x99,0x81,0xE9,0xD7,0x01,0x0D,0x9A,0x21,0xC2,0xE0,0x10,0x01,
+0x9A,0x40,0xE9,0xB7,0x01,0x0F,0x99,0x61,0x9A,0x60,0x8A,0xAC,0x9A,0xC1,0x99,0x41,
+0xE4,0x00,0x00,0x55,0xC2,0xE0,0x10,0x01,0xE9,0xF7,0x01,0x33,0xC2,0xE0,0x10,0x01,
+0xE9,0xD7,0x00,0xF5,0x99,0xA0,0x9A,0x40,0x9A,0x00,0x9A,0x80,0x9A,0xA0,0x8A,0x2D,
+0x89,0x72,0x8A,0x70,0x89,0x94,0x8A,0xD5,0x99,0x40,0x88,0x6A,0xE4,0x00,0xD7,0x98,
+0x88,0x6A,0xE4,0x00,0xD8,0x1A,0x88,0x76,0xE4,0x00,0xEB,0xC8,0x88,0x75,0xE4,0x00,
+0xEC,0x22,0x88,0x74,0xE4,0x00,0xD9,0x7A,0x88,0x73,0xE4,0x00,0xD9,0xC6,0x88,0x72,
+0xE4,0x00,0xD8,0xC8,0x88,0x71,0xE4,0x00,0xD8,0xF4,0x88,0x6A,0xE4,0x00,0xED,0x44,
+0x88,0x70,0xE4,0x00,0xED,0x9E,0x98,0x60,0xE4,0x00,0xED,0xEC,0x98,0x60,0xE4,0x00,
+0xEE,0x3A,0x98,0x60,0xE4,0x00,0xEE,0x88,0x98,0x60,0xE4,0x00,0xEE,0xD6,0x88,0x6F,
+0xE4,0x00,0xD9,0xC0,0x88,0x6E,0xE4,0x00,0xD9,0xEE,0x88,0x6D,0xE4,0x00,0xDA,0x22,
+0x88,0x6C,0xE4,0x00,0xDA,0x3C,0x88,0x6B,0x0E,0xC1,0x02,0x0E,0xA1,0x06,0x0E,0x81,
+0x0A,0x0E,0x61,0x0E,0x0E,0x41,0x12,0x0E,0x21,0x16,0x0E,0x01,0x1A,0x0D,0xE1,0x1E,
+0x0D,0xC1,0x22,0x0D,0xA1,0x26,0x0D,0x81,0x2A,0x0D,0x61,0x2E,0x0D,0x41,0x32,0x0D,
+0x21,0x36,0x1C,0x21,0x38,0xE4,0x00,0xD7,0x85,0xC2,0xE0,0x10,0x01,0xF0,0x77,0x04,
+0x60,0x85,0x29,0xC2,0xE0,0x10,0x01,0xF8,0x77,0x04,0x60,0x85,0x29,0xC2,0xE0,0x10,
+0x01,0xF3,0x17,0x04,0x60,0x9F,0x01,0xFB,0x17,0x04,0x60,0x85,0x29,0xC2,0xE0,0x10,
+0x01,0xF0,0x77,0x04,0x80,0x85,0x29,0xC2,0xE0,0x10,0x01,0xF8,0x77,0x04,0x80,0x85,
+0x29,0xC2,0xE0,0x10,0x01,0xF3,0x17,0x04,0x80,0x9F,0x01,0xFB,0x17,0x04,0x80,0x85,
+0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x01,0x08,0x85,0x29,0xC3,0x40,0x10,0x01,0xFF,
+0x5A,0x00,0xF8,0x0C,0x1A,0x00,0x9A,0xE1,0xC3,0x20,0x10,0x01,0xFF,0x39,0x01,0x18,
+0x0E,0xF9,0x00,0xC3,0x00,0x10,0x01,0xFF,0x18,0x04,0x50,0x0C,0x18,0x00,0x0C,0x1A,
+0x04,0x0E,0xF9,0x04,0x0C,0x18,0x04,0x0C,0x1A,0x08,0x0E,0xF9,0x08,0x0C,0x18,0x08,
+0x0C,0x1A,0x0C,0x0E,0xF9,0x0C,0x0C,0x18,0x0C,0xC3,0x00,0x10,0x01,0xEE,0xF8,0x01,
+0x10,0x85,0x29,0x9C,0x38,0x0D,0x41,0x04,0xC2,0xE0,0x10,0x01,0xC3,0x00,0x10,0x01,
+0x5C,0xA5,0x00,0x5C,0xC6,0x00,0xF3,0x37,0x04,0x78,0xFF,0x18,0x01,0x10,0xD7,0x25,
+0x00,0x6A,0xF8,0xB7,0x04,0x78,0x9A,0xE1,0x0E,0xF8,0x00,0xC3,0x80,0x10,0x01,0xC2,
+0xE0,0x10,0x01,0x0F,0x38,0x02,0xFF,0x9C,0x01,0x18,0xFE,0xF7,0x00,0xF8,0x23,0x24,
+0x9A,0x0B,0xA3,0x00,0x4F,0x46,0x18,0x43,0x77,0xD4,0x0F,0xBB,0x00,0x0B,0xA4,0x00,
+0x0F,0xBB,0x04,0x8F,0x5C,0x0F,0x3A,0x00,0x0F,0x3A,0x04,0x40,0xA5,0x35,0x20,0xA4,
+0x1A,0x0C,0x18,0x00,0x4F,0x46,0x18,0x8F,0x57,0x0F,0x3A,0x02,0x0F,0x5A,0x02,0x0B,
+0x03,0x00,0x8B,0x77,0x43,0x39,0xC5,0x27,0x3C,0x2A,0x43,0x58,0xD5,0xE4,0x00,0x00,
+0x0F,0x43,0x5A,0xC5,0x4F,0x26,0x18,0x8F,0x3B,0x0F,0x79,0x02,0x0F,0x39,0x02,0x43,
+0x7B,0xC5,0x27,0x7C,0x2A,0x43,0x18,0xCD,0xE4,0x00,0x00,0x0F,0x43,0x19,0xC5,0x43,
+0x7A,0xC3,0x4F,0x46,0x18,0x8F,0x57,0x0F,0x3A,0x06,0x0F,0x5A,0x06,0x0B,0x04,0x00,
+0x8B,0xB7,0x43,0x39,0xC5,0x27,0x3C,0x2A,0x43,0x58,0xD5,0xE4,0x00,0x00,0x0F,0x43,
+0x5A,0xC5,0x4F,0x26,0x18,0x8F,0x3D,0x0F,0xB9,0x06,0x0F,0x39,0x06,0x43,0xBD,0xC5,
+0x27,0xBC,0x2A,0x43,0x18,0xCD,0xE4,0x00,0x00,0x0F,0x43,0x19,0xC5,0x43,0x1A,0xC3,
+0x9B,0x23,0x8F,0x1B,0x9B,0x41,0xE4,0x00,0x00,0x11,0x8F,0x59,0x9F,0x22,0xD7,0x58,
+0xFF,0xE1,0x4F,0x19,0x09,0xC3,0x20,0x10,0x01,0x9F,0x1F,0x53,0x40,0x1E,0x5F,0x18,
+0x06,0xEF,0x19,0x04,0x74,0xC3,0x20,0x10,0x01,0x43,0x18,0xD1,0xEF,0x39,0x01,0x0A,
+0x43,0x18,0xC3,0x43,0x39,0xC5,0xC3,0x00,0x10,0x01,0x5F,0x23,0x11,0x20,0x00,0x1B,
+0x53,0x20,0x19,0xEF,0x38,0x04,0x6C,0xC3,0xA0,0x10,0x01,0xEC,0xB8,0x04,0x6E,0x4C,
+0xC6,0x08,0x9B,0x00,0xFF,0xBD,0x04,0x50,0xCB,0x40,0x10,0x00,0x43,0x26,0xC4,0x4F,
+0x39,0x10,0x43,0x7C,0xCC,0xC9,0x40,0xA0,0x00,0x0D,0x1B,0x02,0x0F,0xDB,0x02,0x43,
+0x68,0x53,0xCF,0xDE,0x00,0x0A,0x8F,0xC5,0x43,0xDB,0xF0,0x43,0x7D,0xCC,0x0F,0xDB,
+0x00,0x5F,0xD8,0x00,0x23,0xC0,0x92,0x43,0xD7,0xCC,0x0D,0x1E,0x02,0x0F,0x7B,0x02,
+0x0F,0x3E,0x02,0x0B,0xC3,0x00,0x43,0x3E,0xCD,0x43,0x3B,0xCB,0x43,0x39,0xD0,0x8F,
+0x28,0x0F,0x23,0x01,0xE4,0x00,0x00,0x43,0x43,0xD7,0xCC,0x0D,0x1E,0x02,0x0F,0x7B,
+0x02,0x0F,0x3E,0x02,0x0B,0xC4,0x00,0x43,0x3E,0xCD,0x43,0x3B,0xCB,0x43,0x39,0xD0,
+0x8F,0x28,0x0F,0x24,0x01,0x43,0x66,0xC4,0x4F,0x7B,0x10,0x43,0xD7,0xDC,0x0F,0x3E,
+0x00,0x43,0x3C,0xDC,0x8F,0x7D,0x0F,0xD9,0x02,0x0D,0x1B,0x02,0x0F,0x79,0x02,0x43,
+0x68,0xDB,0x43,0x7B,0xD0,0x43,0x7E,0xDD,0x0F,0x79,0x00,0x9F,0x01,0xD3,0x02,0xFB,
+0x7E,0x0D,0x41,0x06,0x9C,0x28,0x85,0x29,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x04,0xAE,
+0x13,0x17,0x20,0x43,0x37,0xC4,0x9F,0x01,0x18,0x79,0x00,0x5F,0x18,0x00,0x1B,0x17,
+0x20,0xC3,0x20,0x10,0x01,0xC2,0xE0,0x10,0x01,0x5F,0x04,0xDB,0xFF,0x39,0x05,0x30,
+0xFE,0xF7,0x05,0x82,0x20,0x00,0x91,0x4F,0x18,0x08,0xC3,0x40,0x10,0x01,0x8F,0x38,
+0xEB,0x5A,0x05,0x25,0x8F,0x17,0x0F,0x59,0x01,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x06,
+0x31,0x0E,0xF8,0x01,0xE4,0x00,0x00,0x1D,0xFF,0x00,0x7F,0xFF,0x0F,0x19,0x4F,0x0F,
+0x17,0x4F,0x85,0x29,0xC3,0x00,0x10,0x01,0x5C,0x84,0x02,0x9A,0xE0,0xFF,0x18,0x04,
+0xAE,0xE4,0x00,0x00,0x51,0x43,0x38,0xBC,0x43,0x63,0xBC,0x13,0x59,0x00,0x9E,0xE1,
+0x8F,0x44,0x5E,0xF7,0x00,0x1F,0x5A,0x40,0x4F,0x3A,0xFA,0x4F,0x39,0xD1,0x8F,0x59,
+0x57,0x5A,0x3F,0x43,0x3A,0xCD,0x1B,0x3B,0x00,0x13,0x38,0x20,0xD7,0x37,0xFE,0xCD,
+0x85,0x29,0xC3,0x18,0x00,0x21,0x5F,0x23,0x00,0xFF,0x18,0xB7,0x08,0x9A,0xE0,0x5C,
+0x77,0x00,0x0B,0x78,0x01,0x9B,0x5F,0x5C,0x62,0x01,0x20,0x00,0x19,0x0B,0x58,0x03,
+0xD7,0x64,0x01,0x7D,0xD7,0x44,0x01,0x59,0x23,0x24,0x36,0x40,0x60,0xBD,0x54,0x63,
+0x3F,0xE4,0x00,0x00,0x57,0x23,0x28,0x2A,0x1C,0x63,0x20,0xE4,0x00,0x00,0x1B,0x23,
+0x2C,0x76,0x52,0xE0,0x20,0x40,0x77,0x1D,0x5C,0x63,0x00,0xE4,0x00,0x00,0x23,0x9E,
+0xE1,0x9F,0x02,0x5E,0xE2,0x29,0x23,0xFE,0xE5,0x50,0x60,0xFF,0x85,0x29,0xC2,0xE0,
+0x10,0x01,0xFE,0xF7,0x04,0x8A,0x0B,0x17,0x07,0x0A,0xF7,0x01,0x40,0x63,0xC3,0x40,
+0x63,0xB8,0x9A,0xEA,0x40,0x63,0xB8,0x85,0x29,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x01,
+0x38,0x0B,0x17,0x06,0x0A,0xF7,0x04,0xD7,0x17,0x00,0x92,0xCC,0x63,0x07,0xD0,0x42,
+0xF8,0xBD,0x40,0x63,0xB8,0xE4,0x00,0x00,0x0D,0x98,0x60,0x85,0x29,0x8B,0x23,0x20,
+0x80,0x96,0xC2,0xE0,0x10,0x01,0x98,0x60,0xFE,0xF7,0x01,0x38,0x0B,0x17,0x02,0x0A,
+0xF7,0x00,0xD7,0x17,0x00,0xDA,0xCC,0x79,0x07,0xD0,0x42,0xF8,0xBD,0x40,0x63,0xB8,
+0xE4,0x00,0x00,0x1B,0x20,0x84,0x1E,0xE7,0xFF,0xFF,0x65,0x98,0x60,0x85,0x29,0x5C,
+0x84,0x00,0x5C,0xA5,0x00,0x4C,0x84,0x30,0x5C,0xC6,0x00,0x8C,0x85,0x4C,0x84,0x08,
+0x8C,0x64,0xD0,0xC8,0x00,0x59,0x0C,0x03,0x01,0xE4,0x00,0x00,0x3F,0x52,0xE0,0x64,
+0x20,0xC0,0x54,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xB7,0x04,0x9C,0xC1,0x4C,0xC6,0x0A,
+0x8C,0xD7,0x12,0xE6,0xFF,0x0E,0xE3,0x01,0x85,0x29,0xFC,0x21,0xFE,0x88,0xEE,0x21,
+0x01,0x54,0xEE,0x41,0x01,0x50,0xED,0x21,0x01,0x74,0xED,0x41,0x01,0x70,0xED,0x61,
+0x01,0x6C,0xED,0x81,0x01,0x68,0xED,0xA1,0x01,0x64,0xED,0xC1,0x01,0x60,0xED,0xE1,
+0x01,0x5C,0xEE,0x01,0x01,0x58,0xEE,0x61,0x01,0x4C,0xEE,0x81,0x01,0x48,0xEE,0xA1,
+0x01,0x44,0x5E,0x23,0x00,0x8A,0x44,0x5C,0xA5,0x00,0x4F,0x11,0x08,0x9A,0xE1,0xD4,
+0xB8,0x00,0x94,0x43,0x18,0x28,0x9A,0xE0,0x23,0x00,0x24,0x1E,0xF8,0x01,0x5E,0xF7,
+0x00,0x43,0x05,0xBB,0x5F,0x08,0x11,0x20,0x00,0x21,0x9E,0xFF,0x5E,0xF7,0x00,0x42,
+0x17,0x2B,0x8B,0x41,0x5E,0x10,0x00,0x9B,0x00,0x41,0xD0,0x8D,0x9D,0xC2,0x5D,0xCE,
+0x00,0xE4,0x00,0x00,0x4D,0x43,0x7A,0xCC,0x13,0xBC,0x00,0x9F,0x21,0x1B,0xBB,0x00,
+0xE4,0x00,0x00,0x13,0x9B,0x20,0x43,0x86,0xC4,0x5F,0x79,0x00,0xD6,0xFB,0xFF,0x4D,
+0x9F,0x01,0x8F,0x57,0x5F,0x18,0x00,0xD7,0x05,0xFF,0x6E,0x99,0x60,0x52,0x80,0x40,
+0xE4,0x00,0x01,0xC9,0x21,0x60,0x56,0x13,0x12,0x00,0x1E,0xE1,0x00,0x1F,0x18,0x40,
+0x8E,0xED,0x12,0xF7,0x00,0xE4,0x00,0x00,0x21,0x13,0x15,0x00,0x42,0xF3,0x6C,0x1F,
+0x18,0x40,0x12,0xF7,0xFF,0x43,0x18,0xBD,0x4E,0xF8,0xFA,0x4E,0xF7,0xD1,0x40,0xD8,
+0xBC,0x54,0xC6,0x3F,0x40,0xC6,0xBD,0x5C,0xC6,0x00,0x5C,0xC4,0x13,0x20,0x00,0x25,
+0x40,0xD4,0x35,0x5C,0xC6,0x00,0x1C,0x61,0x40,0x21,0x60,0x7A,0x98,0x80,0x88,0xAC,
+0xE7,0xFF,0xFD,0x9E,0x21,0x81,0x78,0x0B,0x0A,0x81,0xEA,0xEA,0xFF,0x7F,0x8E,0xF8,
+0x0E,0xEA,0x81,0xE4,0x00,0x00,0x9F,0x98,0x81,0x88,0xAC,0x21,0x64,0x56,0xE7,0xFF,
+0xFD,0x62,0x21,0x81,0x00,0x0B,0x0A,0xFF,0xEA,0xEA,0xFF,0x7F,0xE4,0x00,0x00,0x45,
+0xE7,0xFF,0xFD,0x3E,0x21,0x80,0x52,0xEB,0x01,0x00,0xC1,0x0A,0xE1,0x41,0x8E,0xF8,
+0xEE,0xE1,0x00,0xC1,0xE4,0x00,0x00,0x3D,0x0B,0x0A,0xFF,0x0A,0xEA,0x81,0x5F,0x57,
+0x04,0x5F,0x38,0x04,0xD7,0x3A,0x00,0x31,0x8A,0xF8,0x0B,0x0A,0x01,0x8E,0xF8,0x0E,
+0xEA,0x01,0x9D,0xA1,0x9D,0x42,0x5D,0x8D,0x00,0xD5,0xCC,0xFA,0x5D,0x21,0x60,0x76,
+0x9D,0x61,0x5D,0x6B,0x00,0xE4,0x00,0x00,0x3F,0x0B,0x0F,0x01,0x9E,0xE1,0x0F,0x0F,
+0x81,0x5E,0xF7,0x00,0x9D,0xE2,0xE4,0x00,0x00,0x0D,0x9A,0xE0,0xD6,0xEE,0xFF,0x6E,
+0xE7,0xFF,0xFF,0xC1,0xD5,0x71,0x00,0xC2,0xFD,0xE1,0x00,0xC0,0x1E,0x61,0x00,0x89,
+0x4F,0x99,0xA0,0x42,0xB2,0x5C,0x8E,0x6B,0xE7,0xFF,0xFF,0x7D,0x21,0x64,0x26,0x9D,
+0xDF,0xE4,0x00,0x00,0x0F,0x1D,0xCE,0x3F,0xFE,0xE1,0x01,0x40,0x4D,0xCE,0x08,0x8D,
+0xD7,0xE8,0x6E,0xFF,0x01,0x42,0x03,0x80,0xEE,0xA1,0x01,0x46,0x5C,0x70,0x00,0xEE,
+0x81,0x01,0x4A,0xEE,0x61,0x01,0x4E,0xEE,0x41,0x01,0x52,0xEE,0x21,0x01,0x56,0xEE,
+0x01,0x01,0x5A,0xED,0xE1,0x01,0x5E,0xED,0xC1,0x01,0x62,0xED,0xA1,0x01,0x66,0xED,
+0x81,0x01,0x6A,0xED,0x61,0x01,0x6E,0xED,0x41,0x01,0x72,0xED,0x21,0x01,0x76,0xFC,
+0x21,0x01,0x78,0x85,0x29,0x5C,0x84,0x06,0x5C,0xA5,0x06,0x43,0x24,0x2C,0x9B,0x02,
+0x43,0x19,0xC0,0x53,0x20,0x1E,0x5E,0xE3,0x06,0xC7,0x18,0xFF,0xFF,0x40,0x84,0x2D,
+0x98,0x60,0xCC,0x84,0x00,0x0A,0x40,0x84,0xC8,0xC4,0x84,0xFF,0xFF,0x43,0x38,0x25,
+0xD6,0xF9,0x00,0x60,0x8C,0x98,0x5C,0x97,0x1D,0x48,0x61,0x01,0x85,0x29,0x24,0x80,
+0x68,0x24,0x7C,0x34,0xCE,0xE3,0x03,0xE8,0x98,0x61,0xE4,0x00,0x00,0x49,0xCE,0xE3,
+0xFC,0x18,0x98,0x64,0xE4,0x00,0x00,0x35,0x20,0x80,0x74,0x24,0x7C,0x34,0xCE,0xE3,
+0xFC,0x18,0x98,0x62,0xE4,0x00,0x00,0x15,0xCE,0xE3,0x03,0xE8,0x98,0x63,0x40,0x97,
+0x20,0xE7,0xFF,0xF9,0x23,0x9A,0xE0,0x20,0x60,0x3C,0x5C,0x60,0x11,0x52,0xE0,0x30,
+0x53,0x00,0x10,0x4A,0xF8,0xB8,0x88,0x77,0x85,0x29,0x0A,0xE3,0x00,0x26,0xFC,0x60,
+0xC3,0x00,0x10,0x01,0xEB,0x18,0x04,0x91,0x5F,0x38,0x06,0x5E,0xF8,0x1D,0x4A,0xF9,
+0xB8,0xE4,0x00,0x00,0x0D,0x9A,0xE0,0x0E,0xE3,0x01,0xC3,0x00,0x10,0x01,0x0A,0xE4,
+0x00,0xFF,0x18,0x04,0x8A,0x26,0xFC,0x4C,0x0B,0x38,0x07,0x5F,0x59,0x06,0x5E,0xF9,
+0x1D,0x4A,0xFA,0xB8,0xE4,0x00,0x00,0x0D,0x9A,0xE0,0x0E,0xE4,0x01,0x13,0x38,0x04,
+0x23,0x28,0x64,0x23,0x2C,0x8C,0x23,0x20,0xA6,0x0B,0x23,0x00,0x0E,0xE3,0x01,0x0A,
+0xF8,0x07,0x42,0xF7,0xCD,0xE4,0x00,0x00,0x15,0x0B,0x18,0x09,0x42,0xF8,0xBD,0x0E,
+0xE4,0x01,0xE4,0x00,0x00,0x1B,0x0B,0x03,0x00,0x0E,0xE3,0x01,0x0F,0x04,0x01,0x85,
+0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x04,0x99,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x04,
+0xD1,0x85,0x29,0x1C,0x21,0xD0,0x0D,0x41,0x28,0x0D,0x61,0x24,0x0D,0x81,0x20,0x0D,
+0xA1,0x1C,0x0C,0x61,0x07,0x0C,0x81,0x05,0x0D,0x21,0x2C,0x0D,0xC1,0x18,0x0D,0xE1,
+0x14,0x0E,0x01,0x10,0x0E,0x21,0x0C,0x5D,0xA5,0x00,0x1C,0x61,0x06,0x1C,0x81,0x04,
+0xE7,0xFF,0xFE,0x94,0xC2,0xE0,0x10,0x01,0x09,0x81,0x04,0xFF,0x17,0x04,0x8A,0xEA,
+0xF7,0x04,0x8B,0x0B,0x18,0x03,0x41,0x8C,0xC3,0x41,0x8C,0xB8,0x5D,0x8C,0x06,0x0D,
+0x81,0x05,0xC1,0x40,0x10,0x01,0xC1,0x60,0x10,0x01,0xFD,0x4A,0x04,0xA0,0xFD,0x6B,
+0x04,0xAC,0xD1,0xA1,0x06,0x9E,0xC1,0xC0,0x10,0x01,0xC1,0xA0,0x10,0x01,0x0E,0xEA,
+0x02,0xFD,0xCE,0x04,0x9A,0xFD,0xAD,0x05,0x80,0x22,0xE4,0x68,0x22,0xE0,0x34,0x98,
+0x60,0xD2,0xE3,0x08,0x25,0xE4,0x00,0x00,0xD7,0x0A,0xE1,0x07,0x0E,0xED,0x01,0xE4,
+0x00,0x00,0xAB,0xC2,0xE0,0x10,0x01,0x0A,0x21,0x06,0xEE,0x37,0x04,0x89,0xC2,0xE0,
+0x10,0x01,0x09,0xED,0x00,0xED,0x97,0x05,0x29,0x41,0xEF,0x8D,0x4E,0xEF,0xFA,0x0A,
+0x0E,0x00,0x45,0xF7,0x7E,0x42,0x10,0x65,0x41,0xEF,0xBD,0x4E,0xF0,0xFA,0x46,0x17,
+0x86,0x42,0x10,0xBD,0xC2,0xE0,0x10,0x01,0xE8,0x77,0x04,0xD1,0xE7,0xFF,0xF7,0x04,
+0x42,0x10,0x83,0x41,0xEF,0x7B,0x40,0x63,0x1B,0x8D,0xF0,0x9A,0xE3,0xD5,0xE3,0x05,
+0x18,0x0E,0x2D,0x01,0x0D,0x8E,0x01,0x0C,0x0B,0x01,0x9A,0xE2,0xE4,0x00,0x01,0x29,
+0x0A,0xE1,0x06,0x09,0xAD,0x00,0x41,0xAD,0xBD,0x4E,0xED,0xFA,0x45,0xB7,0x6E,0x41,
+0xAD,0xBD,0x0A,0xEE,0x00,0x41,0x97,0x65,0x4E,0xEC,0xFA,0x45,0x97,0x66,0x41,0x8C,
+0xBD,0xC2,0xE0,0x10,0x01,0x41,0x8C,0x63,0xE8,0x77,0x04,0xD1,0x41,0xAD,0x6B,0xE7,
+0xFF,0xF6,0x5E,0x8D,0x8D,0x40,0x63,0x1B,0xD5,0x83,0x01,0x88,0x9A,0xE4,0x0E,0xEA,
+0x00,0xE4,0x00,0x00,0x51,0x21,0xA1,0x26,0x0E,0xEA,0x02,0x22,0xE8,0x60,0x26,0xE8,
+0x2B,0x22,0xE5,0x0A,0xE4,0x00,0x00,0x2B,0x22,0xEC,0x90,0xD2,0xE4,0x01,0xC6,0xE4,
+0x00,0x00,0x51,0x9A,0xE1,0xE4,0x00,0x00,0x57,0xC2,0xE0,0x10,0x01,0x0B,0x0B,0x01,
+0xEA,0xF7,0x04,0x99,0xD7,0x17,0x00,0xF9,0xE4,0x00,0x00,0x2D,0x9A,0xE4,0x98,0x61,
+0x0E,0xEA,0x00,0xE4,0x00,0x00,0x25,0x0C,0x0A,0x00,0xE4,0x00,0x00,0x13,0x9A,0xE4,
+0x0E,0xEA,0x00,0x98,0x60,0x0A,0xEB,0x01,0x0E,0x21,0x0E,0x9E,0xE1,0x0E,0x01,0x12,
+0x0E,0xEB,0x01,0x0D,0xE1,0x16,0x0D,0xC1,0x1A,0x0D,0xA1,0x1E,0x0D,0x81,0x22,0x0D,
+0x61,0x26,0x0D,0x41,0x2A,0x0D,0x21,0x2E,0x1C,0x21,0x30,0x85,0x29,0xC2,0xE0,0x10,
+0x01,0xEC,0x17,0x04,0xD3,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x05,0x2C,0x85,0x29,0x9B,
+0x01,0xC2,0xE0,0x10,0x01,0x1C,0x21,0xB0,0xFB,0x17,0x05,0xD4,0x0D,0x41,0x48,0x0D,
+0x61,0x44,0x0D,0x81,0x40,0x0E,0x01,0x30,0x0E,0x21,0x2C,0x0E,0x41,0x28,0x0E,0x61,
+0x24,0x0E,0x81,0x20,0x0E,0xA1,0x1C,0x0E,0xC1,0x18,0x0C,0x61,0x17,0x0C,0x81,0x15,
+0x0D,0x21,0x4C,0x0D,0xA1,0x3C,0x0D,0xC1,0x38,0x0D,0xE1,0x34,0x1C,0x61,0x16,0x1C,
+0x81,0x14,0xE7,0xFF,0xFA,0xF0,0xC2,0xE0,0x10,0x01,0x09,0x41,0x16,0xED,0x57,0x05,
+0x25,0xC2,0xE0,0x10,0x01,0xFF,0x17,0x04,0x8A,0xEA,0xF7,0x04,0x8B,0x0B,0x18,0x03,
+0x09,0x61,0x14,0x41,0x6B,0xC3,0x41,0x6B,0xB8,0xC2,0xE0,0x10,0x01,0xC3,0x00,0x10,
+0x01,0x5D,0x6B,0x06,0xED,0x77,0x06,0x31,0xEA,0xF8,0x04,0xD3,0x9E,0xE1,0x5E,0xF7,
+0x04,0xEE,0xF8,0x04,0xD3,0xC3,0x20,0x10,0x01,0xC2,0x60,0x10,0x01,0xC2,0x40,0x10,
+0x01,0xC2,0x80,0x10,0x01,0xC2,0xA0,0x10,0x01,0xC3,0x00,0x10,0x01,0xC2,0xC0,0x10,
+0x01,0xC3,0x40,0x10,0x01,0xFF,0x39,0x06,0x32,0xFE,0x73,0x05,0x26,0xFE,0x52,0x04,
+0x96,0xFE,0x34,0x05,0xD2,0xFE,0x15,0x06,0x26,0xFF,0x18,0x05,0xD6,0xFE,0xD6,0x04,
+0xD4,0xFD,0x9A,0x01,0x38,0xD2,0xE1,0x04,0x3E,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x04,
+0xCE,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x04,0xA4,0xC2,0xE0,0x10,0x01,0xC3,0x60,0x10,
+0x01,0xEC,0x17,0x05,0x2C,0xC3,0x40,0x10,0x01,0x0D,0x4C,0x01,0x0D,0x4C,0x03,0x0D,
+0x6C,0x05,0x0D,0x6C,0x07,0x0D,0x4C,0x09,0x0D,0x6C,0x0B,0x0C,0x0C,0x10,0x0C,0x0C,
+0x14,0x0D,0x53,0x01,0x0D,0x72,0x01,0x0D,0x51,0x01,0x0D,0x70,0x01,0x9A,0xE0,0xFF,
+0x7B,0x05,0x30,0xFF,0x5A,0x05,0x82,0x43,0x98,0xBC,0x0C,0x1C,0x01,0x43,0x96,0xBC,
+0x0C,0x1C,0x01,0x43,0x9B,0xBC,0x0C,0x1C,0x01,0x43,0x9A,0xBC,0x0C,0x1C,0x01,0x9E,
+0xE2,0x5E,0xEA,0x09,0x23,0xFF,0x8D,0x9A,0xE1,0x0D,0x58,0x01,0x0D,0x76,0x01,0x0D,
+0x5B,0x01,0x0D,0x7A,0x01,0x1A,0xF9,0x00,0xE4,0x00,0x03,0x49,0xC2,0xE0,0x10,0x01,
+0xF2,0xF7,0x04,0xCE,0x5E,0xE3,0xBB,0x20,0x04,0xF5,0x09,0xF3,0x00,0x40,0x8A,0x7D,
+0x0F,0x01,0x04,0x0C,0x81,0x0C,0x0F,0x21,0x08,0x50,0x60,0x23,0xE7,0xFF,0xF2,0x44,
+0x09,0xD2,0x00,0x0C,0x81,0x0E,0x41,0xAB,0x75,0x43,0x64,0x23,0x42,0xED,0x6B,0x40,
+0x63,0x1B,0x8E,0xFB,0x0F,0x01,0x06,0x0F,0x21,0x0A,0xD6,0xE3,0x0B,0x10,0x12,0xF9,
+0x00,0x5E,0xE4,0xDB,0x20,0x00,0x51,0x4F,0x77,0x08,0x8F,0x1B,0x8E,0xDB,0x0D,0x58,
+0x01,0x0D,0x76,0x01,0xE4,0x00,0x00,0x1D,0xFF,0x60,0x7F,0xFF,0x0F,0x78,0x4F,0x0F,
+0x76,0x4F,0x1E,0xD7,0x01,0x5E,0xD6,0x00,0x1A,0xD9,0x00,0x0A,0xEC,0x00,0xD6,0xEA,
+0x00,0x38,0x0D,0x4C,0x01,0x0B,0x0C,0x02,0x8A,0xEC,0xD5,0x58,0x00,0x38,0x0D,0x4C,
+0x03,0x0B,0x17,0x04,0xD7,0x0B,0x00,0x38,0x0D,0x77,0x05,0x0A,0xEC,0x06,0xD5,0x77,
+0x00,0x38,0x0D,0x6C,0x07,0x4E,0xE4,0xFA,0x47,0x17,0x26,0x42,0xF8,0xBD,0x0F,0x0C,
+0x12,0x8E,0xF8,0x0E,0xEC,0x10,0x4E,0xED,0xFA,0x47,0x17,0x6E,0x42,0xF8,0xBD,0x0F,
+0x0C,0x16,0x8E,0xF8,0x88,0x6D,0x0E,0xEC,0x14,0xE7,0xFF,0xF6,0xCA,0xC3,0x00,0x10,
+0x01,0xF8,0x78,0x04,0x9C,0xC1,0xA0,0x10,0x01,0x89,0x83,0x5E,0xE3,0x00,0xFD,0xAD,
+0x06,0x28,0x22,0xC9,0x94,0x26,0xC9,0x95,0x13,0x2D,0x00,0x1F,0x39,0x40,0x43,0x39,
+0xBD,0x4F,0x19,0xFA,0x4F,0x18,0xD1,0x42,0xF9,0xC4,0x56,0xF7,0x3F,0x42,0xD7,0xC5,
+0x5E,0xF6,0x00,0x0E,0xE1,0x10,0x26,0xEC,0x31,0x57,0x16,0xFF,0x5F,0x07,0x91,0x20,
+0x01,0x65,0xC3,0x00,0x10,0x01,0xF3,0x18,0x04,0xCE,0x23,0x00,0xC2,0x08,0x91,0x00,
+0x40,0x8F,0x25,0x08,0x70,0x00,0x40,0x6E,0x1D,0xE7,0xFF,0xF6,0x0A,0xE7,0xFF,0xEE,
+0x56,0x0E,0xE1,0x12,0xD2,0xE7,0x00,0x69,0x56,0xF6,0xFF,0x5E,0xE7,0x11,0x20,0x01,
+0x71,0x0D,0xF1,0x01,0x0D,0xD0,0x01,0x19,0x8D,0x00,0x0D,0x53,0x01,0x0D,0x72,0x01,
+0xE4,0x00,0x00,0xB9,0x5E,0xE3,0xC9,0x20,0x01,0x55,0x9B,0x01,0xC2,0xE0,0x10,0x01,
+0xEF,0x17,0x05,0x2C,0xE4,0x00,0x00,0x91,0x0B,0x10,0x00,0x0B,0x31,0x00,0x43,0x18,
+0x75,0x43,0x39,0x7D,0x0F,0x01,0x04,0x0F,0x21,0x08,0x50,0x60,0x23,0xE7,0xFF,0xEF,
+0xA2,0x0F,0x21,0x0A,0x0F,0x01,0x06,0x43,0x39,0xCB,0x43,0x18,0xC3,0x40,0x63,0x1B,
+0x8F,0x19,0xD7,0x03,0xFC,0x5C,0xE7,0xFF,0xFE,0xF9,0xC2,0xE0,0x10,0x01,0xF3,0x17,
+0x04,0xA4,0x9F,0x01,0xFB,0x17,0x04,0xA4,0xE7,0xFF,0xFF,0x33,0x0E,0xC1,0x1A,0x0E,
+0xA1,0x1E,0x0E,0x81,0x22,0x0E,0x61,0x26,0x0E,0x41,0x2A,0x0E,0x21,0x2E,0x0E,0x01,
+0x32,0x0D,0xE1,0x36,0x0D,0xC1,0x3A,0x0D,0xA1,0x3E,0x0D,0x81,0x42,0x0D,0x61,0x46,
+0x0D,0x41,0x4A,0x0D,0x21,0x4E,0x1C,0x21,0x50,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,
+0x97,0x04,0xA8,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x06,0x2C,0x85,0x29,0xFC,0x21,0xFF,
+0x58,0xED,0x61,0x00,0x9C,0x0E,0xC1,0x70,0xED,0x21,0x00,0xA4,0xED,0x41,0x00,0xA0,
+0xED,0x81,0x00,0x98,0xED,0xA1,0x00,0x94,0xED,0xC1,0x00,0x90,0xED,0xE1,0x00,0x8C,
+0xEE,0x01,0x00,0x88,0xEE,0x21,0x00,0x84,0xEE,0x41,0x00,0x80,0x0E,0x61,0x7C,0x0E,
+0x81,0x78,0x0E,0xA1,0x74,0xFE,0xC1,0x00,0xA8,0xC2,0xE0,0x10,0x01,0xC1,0x60,0x10,
+0x01,0xEA,0xF7,0x05,0x26,0xFD,0x6B,0x01,0x38,0xC3,0x00,0x10,0x01,0x0C,0x76,0xA0,
+0xEB,0x18,0x04,0x96,0x0C,0x36,0xA4,0x0E,0xEB,0x0D,0x0F,0x0B,0x0F,0xC3,0x20,0x10,
+0x01,0xF3,0x39,0x04,0xCE,0x5F,0x23,0xDB,0x20,0x00,0x85,0xC3,0x20,0x10,0x01,0xE8,
+0x79,0x06,0x26,0xC3,0x20,0x10,0x01,0xE8,0x99,0x05,0xD2,0x40,0x97,0x25,0x40,0x78,
+0x1D,0xE7,0xFF,0xF3,0x7A,0xE7,0xFF,0xEB,0xC6,0x0C,0x6B,0x12,0x0D,0x4B,0x16,0x98,
+0x80,0x0C,0x6B,0x18,0x0D,0x4B,0x1C,0xE7,0xFF,0xEE,0x0C,0x0C,0x6B,0x10,0x88,0x6A,
+0xE7,0xFF,0xED,0xB2,0x0B,0x0B,0x00,0x0C,0x6B,0x14,0xC2,0xE0,0x10,0x01,0x0B,0x2B,
+0x02,0xEA,0xF7,0x04,0x94,0x43,0x39,0xC5,0xC3,0x00,0x10,0x01,0xFE,0x38,0x04,0x84,
+0xD6,0xF9,0x00,0x88,0x0B,0x4B,0x06,0x0B,0x2B,0x04,0x43,0x3A,0xCD,0xD6,0xF9,0x00,
+0xEC,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x05,0x2E,0x22,0xE4,0x44,0xC2,0xE0,0x10,0x01,
+0xFD,0x57,0x04,0xAE,0x13,0x2A,0x20,0x27,0x24,0x5B,0xC2,0xE0,0x10,0x01,0xEC,0x16,
+0xFF,0x78,0xEC,0x17,0x05,0x2C,0x0C,0x16,0x80,0xE4,0x00,0x10,0x67,0x0C,0x36,0x9C,
+0x0F,0x31,0x02,0xEC,0x16,0xFF,0x78,0x0F,0x39,0x02,0x0C,0x16,0x80,0x0B,0x39,0x01,
+0x0C,0x16,0x90,0x9F,0x27,0x99,0x80,0x4F,0x39,0x19,0x4F,0x39,0x18,0x40,0x21,0xCD,
+0xEC,0x36,0xFF,0x70,0x40,0x21,0xCD,0xEC,0x36,0xFF,0x64,0xE4,0x00,0x0F,0xCB,0x4F,
+0x0C,0x20,0xEF,0x16,0xFF,0x68,0x0E,0xF7,0x06,0x8E,0xF8,0x11,0xB7,0x05,0x5D,0xA3,
+0xFB,0x20,0x00,0x45,0xC3,0x20,0x10,0x01,0xEF,0x19,0x04,0xAA,0x8B,0x2D,0xE4,0x00,
+0x00,0x25,0x1F,0x2D,0xE0,0xC3,0x40,0x10,0x01,0x5F,0x39,0x00,0xEF,0x1A,0x06,0x2E,
+0x9B,0x41,0x4F,0x3A,0xCC,0x47,0x19,0xC4,0xD3,0x00,0x0A,0x12,0x1F,0x0D,0xFF,0x27,
+0x0D,0x13,0x10,0xB7,0x04,0x0C,0xD7,0x02,0x10,0x6A,0x20,0x9A,0xE0,0x20,0xA0,0x30,
+0x88,0x8A,0xE7,0xFF,0xED,0x10,0x5E,0xE3,0x00,0xEF,0x16,0xFF,0x72,0x8F,0x0C,0x1A,
+0xF8,0x00,0x0E,0xF1,0x02,0xEF,0x16,0xFF,0x6A,0x0E,0xF7,0x06,0x8E,0xF8,0x10,0xAA,
+0x20,0x10,0x77,0x04,0x0C,0x97,0x02,0x88,0xCA,0x9A,0xE0,0xD0,0xA0,0x07,0x5E,0xE4,
+0x00,0x01,0xDD,0x99,0xC0,0x99,0xFB,0x8A,0x0E,0xD1,0xAA,0x03,0x66,0x99,0xE0,0x1C,
+0x76,0xA8,0x88,0x8F,0xE7,0xFF,0xEA,0x00,0x0E,0xF1,0x02,0xEF,0x36,0xFF,0x6A,0x0E,
+0xF7,0x06,0x10,0x6A,0x20,0x8E,0xF9,0x10,0xB7,0x04,0x0C,0xD7,0x02,0x20,0xA0,0x54,
+0x1C,0x96,0xA8,0xE7,0xFF,0xEC,0x4E,0x5C,0x63,0x00,0xD4,0x70,0x00,0x41,0x8A,0x03,
+0x89,0xCF,0x9D,0xE4,0x5D,0xEF,0x00,0x5D,0xE8,0x09,0x23,0xFF,0x15,0xEE,0xF6,0xFF,
+0x72,0x8E,0xEC,0x1A,0x17,0x00,0x5E,0x09,0x73,0x20,0x02,0xA9,0x1C,0x76,0xA8,0x88,
+0x8E,0xE7,0xFF,0xE9,0x66,0x0E,0xF1,0x02,0xEF,0x56,0xFF,0x6A,0x0E,0xF7,0x06,0x8E,
+0xFA,0xE4,0x00,0x00,0xC9,0x1C,0x76,0xA8,0x88,0x8F,0xE7,0xFF,0xE9,0x34,0x0E,0xF1,
+0x02,0xEF,0x16,0xFF,0x6A,0x0E,0xF7,0x06,0x10,0x6A,0x20,0x8E,0xF8,0x10,0xB7,0x04,
+0x0C,0xD7,0x02,0x20,0xA0,0x54,0x1C,0x96,0xA8,0xE7,0xFF,0xEB,0x82,0x5C,0x63,0x00,
+0xD4,0x70,0x00,0x41,0x8A,0x03,0x89,0xCF,0x9D,0xE1,0x5D,0xEF,0x02,0xD1,0xE6,0xFE,
+0x46,0xEE,0xF6,0xFF,0x72,0x8E,0xEC,0x1A,0x17,0x00,0x5E,0x09,0x73,0x20,0x01,0x19,
+0x1C,0x76,0xA8,0x88,0x8E,0xE7,0xFF,0xE8,0x9E,0x0E,0xF1,0x02,0xEF,0x36,0xFF,0x6A,
+0x0E,0xF7,0x06,0x8E,0xF9,0x10,0x77,0x04,0x0C,0x97,0x02,0x10,0xAA,0x20,0x9A,0xE0,
+0x20,0xA0,0x34,0x1C,0xD6,0xA8,0xE7,0xFF,0xEA,0xE8,0x5E,0xE3,0x00,0xEF,0x16,0xFF,
+0x66,0x8F,0x0C,0x1A,0xF8,0x00,0xE4,0x00,0x00,0x2D,0xEE,0xF6,0xFF,0x72,0x8E,0xEC,
+0x18,0x17,0x00,0xEE,0xF6,0xFF,0x66,0x8E,0xEC,0x18,0x17,0x00,0xEE,0xF6,0xFF,0x72,
+0x8E,0xEC,0x12,0xF7,0x00,0x0E,0xF6,0x94,0x5E,0xE9,0x53,0x20,0x19,0x01,0xEE,0xF6,
+0xFF,0x66,0x8E,0xEC,0x12,0xF7,0x00,0x0E,0xF6,0x98,0x5E,0xE8,0xB3,0x20,0x18,0xB9,
+0x0B,0x4B,0x08,0x0A,0xEB,0x02,0x0B,0x0B,0x00,0x0B,0x2B,0x06,0xEF,0x56,0xFF,0x58,
+0xEE,0xF6,0xFF,0x60,0xEF,0x16,0xFF,0x74,0xEF,0x36,0xFF,0x5C,0x0A,0x0B,0x0C,0x09,
+0xEB,0x0A,0x09,0xCB,0x0E,0x0A,0x6B,0x04,0xD1,0xA7,0x01,0x36,0xD5,0xEE,0x2F,0xF8,
+0x41,0xCE,0x7D,0x4C,0x6E,0xFA,0x45,0xC3,0x76,0x40,0x6E,0x1D,0xE7,0xFF,0xE8,0xBA,
+0xC0,0x60,0x18,0xE8,0x20,0x17,0x9D,0x12,0xEA,0x20,0xE4,0x00,0x08,0xB3,0xEF,0x56,
+0xFF,0x5A,0x43,0x5A,0x85,0x4E,0xFA,0xFA,0x0F,0x56,0x84,0x46,0x97,0xD6,0xEF,0x36,
+0xFF,0x62,0x42,0x94,0xBD,0xEF,0x56,0xFF,0x76,0x42,0xEF,0x75,0x43,0x39,0xD5,0xEE,
+0xF6,0xFF,0x7C,0xEF,0x36,0xFF,0x6C,0x4E,0xF7,0xFA,0xEF,0x16,0xFF,0x7E,0x46,0xB7,
+0xC6,0x42,0xB5,0xBD,0xEE,0xF6,0xFF,0x5E,0x42,0x57,0x9D,0xD1,0xA8,0x08,0x7E,0x40,
+0x77,0x7D,0xE7,0xFF,0xE8,0x0E,0xC0,0x60,0xCE,0x48,0x20,0x00,0x95,0xEF,0x16,0xFF,
+0x62,0x98,0x80,0x40,0x78,0x85,0xE7,0xFF,0xE8,0x2E,0xC0,0x60,0x19,0x08,0x20,0x00,
+0x45,0x12,0xEA,0x20,0x8E,0xEA,0x12,0xF7,0xFF,0x5E,0xE5,0xFB,0x20,0x15,0xBD,0x42,
+0xB5,0xAB,0x42,0x94,0xA3,0x42,0x52,0x93,0x8E,0x95,0xEF,0x36,0xFF,0x6E,0xCE,0x94,
+0x00,0x64,0x42,0xF9,0xCB,0x8E,0x57,0x4E,0x52,0x18,0xD6,0x54,0x00,0x91,0x40,0x6E,
+0x9D,0xE7,0xFF,0xE7,0x70,0xC0,0x60,0x18,0xE8,0x20,0x15,0x09,0xEF,0x56,0xFF,0x62,
+0xEE,0xF6,0xFF,0x5A,0x98,0x80,0x40,0x7A,0xBD,0xE7,0xFF,0xE7,0x88,0xC0,0x60,0x4A,
+0xE8,0x20,0x14,0xA9,0x11,0xEA,0x00,0x1E,0xEF,0xF0,0x5E,0xE3,0xDB,0x20,0x00,0x45,
+0x12,0xEA,0x01,0x9E,0xF0,0x5E,0xF7,0x00,0x5E,0xE3,0xD3,0x20,0x14,0x41,0xC3,0x20,
+0x10,0x01,0xFF,0x39,0x04,0xAE,0x13,0x19,0x20,0x8F,0x19,0x12,0xF8,0xFF,0x1F,0x37,
+0xEF,0x5F,0x23,0xDB,0x20,0x00,0x49,0x13,0x18,0xFE,0x5F,0x02,0x13,0x20,0x00,0x25,
+0x5F,0x05,0xF3,0x20,0x13,0xA1,0x9E,0xF4,0xD2,0xE6,0x00,0x9D,0xEC,0x76,0xFF,0x7E,
+0xE7,0xFF,0xE6,0x92,0xC0,0x60,0x9C,0x4C,0x20,0x13,0x4D,0x9D,0xF8,0xD1,0xE7,0x21,
+0xD5,0xEF,0x56,0xFF,0x5E,0x41,0xCE,0xD5,0x4C,0x6E,0xFA,0x45,0xC3,0x76,0x40,0x6E,
+0x1D,0xE7,0xFF,0xE6,0x50,0xC0,0x60,0x7C,0xEC,0x20,0x10,0x79,0xEE,0xF6,0xFF,0x62,
+0x98,0x80,0x42,0x10,0xBD,0x4C,0x70,0xFA,0x46,0x03,0x86,0x40,0x70,0x1D,0xE7,0xFF,
+0xE6,0x5E,0xC0,0x60,0x3E,0x68,0xE4,0x00,0x07,0xFD,0xD1,0xAA,0x0E,0xFE,0xEF,0x16,
+0xFF,0x5A,0x43,0x10,0xC5,0x4E,0xF8,0xFA,0x0F,0x16,0x88,0x44,0x77,0xC6,0x98,0x80,
+0x40,0x63,0xBD,0xE7,0xFF,0xE6,0x14,0x0C,0x76,0x8C,0xC0,0x60,0xAF,0x0C,0x20,0x00,
+0x69,0x40,0x6E,0x7D,0x4E,0xE3,0xFA,0x44,0x77,0x1E,0x40,0x63,0xBD,0xE7,0xFF,0xE5,
+0x98,0xC0,0x60,0xAF,0x08,0x20,0x00,0xF5,0xEF,0x36,0xFF,0x5E,0x88,0x6F,0x88,0x99,
+0x88,0xB3,0xE7,0xFF,0xEA,0x86,0x20,0x60,0x52,0xEF,0x56,0xFF,0x5E,0x88,0x6E,0x88,
+0x9A,0x88,0xB3,0xE7,0xFF,0xEA,0x64,0x20,0x60,0x6C,0xEE,0xF6,0xFF,0x5A,0xD6,0x17,
+0x00,0xA0,0x0C,0x76,0x8A,0x98,0x80,0xE7,0xFF,0xE5,0x6C,0xC0,0x60,0x32,0x0C,0x20,
+0x10,0x71,0xEF,0x16,0xFF,0x6E,0x42,0xF8,0xC3,0x42,0xB5,0xAB,0x42,0x94,0xA3,0x42,
+0x52,0x93,0x8E,0x95,0x8E,0x57,0xCE,0x94,0x00,0x64,0x4E,0xF2,0x18,0xD6,0x97,0x01,
+0xA1,0x40,0x6E,0x9D,0xE7,0xFF,0xE4,0xCA,0xC0,0x60,0x18,0xEC,0x20,0x00,0x95,0x12,
+0xEA,0x01,0x9E,0xF0,0x5E,0xF7,0x00,0x5E,0xE3,0xD3,0x20,0x00,0x5D,0xEF,0x36,0xFF,
+0x76,0x98,0x80,0x40,0x70,0xCD,0xE7,0xFF,0xE4,0xCE,0xC0,0x60,0x2B,0xCC,0x20,0x0F,
+0x35,0x12,0xAA,0x00,0x1E,0xF5,0xF8,0x5E,0xE6,0x13,0x20,0x00,0xAD,0xEF,0x56,0xFF,
+0x5E,0x40,0x7A,0x7D,0xE7,0xFF,0xE4,0x4A,0xC0,0x60,0xC7,0xEC,0x20,0x00,0x65,0x40,
+0x6F,0x9D,0xE7,0xFF,0xE4,0x2E,0xC0,0x60,0xC7,0xEC,0x20,0x00,0x2D,0xCE,0xF2,0x00,
+0x06,0xD6,0x97,0x1C,0xD5,0xCE,0x52,0x00,0x0C,0xD6,0x92,0x01,0x39,0x12,0xEA,0x01,
+0xD2,0xEF,0x01,0x05,0x0C,0x76,0x86,0x98,0x80,0xE7,0xFF,0xE4,0x28,0x5C,0x6C,0x91,
+0x20,0x00,0x41,0x40,0x6E,0x7D,0xE7,0xFF,0xE3,0xC6,0x5C,0x6C,0x99,0x20,0x0D,0xB9,
+0x1E,0xB5,0xDB,0x5E,0xA2,0x3B,0x20,0x00,0x85,0x12,0xEA,0x20,0x8E,0xEA,0x12,0xF7,
+0xFF,0x5E,0xE4,0x93,0x20,0x00,0x4D,0x5E,0xE6,0xDB,0x20,0x00,0x35,0x0E,0xF6,0x8E,
+0xC2,0xE0,0x7D,0x0C,0x20,0x0D,0x1D,0xEC,0x76,0xFF,0x7E,0xE7,0xFF,0xE3,0x5C,0xC0,
+0x60,0xBB,0x88,0x20,0x00,0x65,0xEF,0x16,0xFF,0x62,0xEF,0x36,0xFF,0x76,0x88,0x70,
+0x88,0x98,0x88,0xB9,0xE7,0xFF,0xE8,0x42,0xD0,0x60,0x19,0x1E,0x40,0x6E,0x7D,0x4E,
+0xE3,0xFA,0x44,0x77,0x1E,0x40,0x63,0xBD,0xE7,0xFF,0xE3,0x02,0xC0,0x60,0xBB,0x88,
+0x20,0x00,0x5D,0xEF,0x56,0xFF,0x5E,0xD5,0xFA,0x18,0x22,0xD5,0xF3,0x18,0x02,0xD5,
+0xDA,0x17,0xE2,0xD5,0xD3,0x17,0xC2,0x0E,0xF6,0x8E,0xC2,0xE0,0xBB,0x88,0x20,0x00,
+0x7D,0xEF,0x16,0xFF,0x5A,0xEF,0x36,0xFF,0x62,0xD7,0x19,0x17,0x12,0xEF,0x56,0xFF,
+0x76,0xD7,0x1A,0x16,0xD2,0xD6,0x19,0x16,0xB2,0xD6,0x1A,0x16,0x92,0xEE,0xF6,0xFF,
+0x62,0xEF,0x16,0xFF,0x5A,0x98,0x80,0x40,0x77,0xC5,0xE7,0xFF,0xE2,0xA6,0xC0,0x60,
+0xBB,0x8C,0x4A,0xE1,0x01,0xE4,0x00,0x04,0x49,0xC2,0xE0,0x10,0x01,0x1F,0x0D,0xFD,
+0xFE,0xF7,0x04,0x8A,0x27,0x04,0xE7,0x0B,0x17,0x03,0x0B,0x37,0x01,0xCF,0x18,0x01,
+0x2C,0x43,0x18,0xC8,0xD6,0x58,0x14,0xBC,0x0B,0x17,0x07,0xC2,0xE0,0x10,0x01,0xEE,
+0xF7,0x03,0x22,0x12,0xF7,0x00,0x42,0xF8,0xBB,0x53,0x00,0x64,0x42,0xF7,0xC0,0x0F,
+0x0B,0x1A,0xD6,0xF8,0x13,0xCC,0x0E,0xEB,0x12,0xE4,0x00,0x01,0x51,0x1F,0x0D,0xFF,
+0xD3,0x01,0x05,0x65,0x13,0x4A,0x20,0x13,0x2A,0x00,0x23,0x44,0x98,0x13,0x0A,0x01,
+0x43,0x99,0xC5,0x8F,0x38,0x4F,0x7C,0xFA,0x4F,0x39,0x0A,0x47,0x9B,0xE6,0x43,0x7C,
+0xDD,0x5F,0x7B,0x00,0x5F,0x63,0xFB,0x20,0x00,0x1B,0x1F,0x39,0x20,0x57,0x39,0x3F,
+0x9B,0x00,0x1F,0xB9,0x40,0x53,0xC0,0x40,0xE4,0x00,0x00,0x63,0x43,0x2A,0xC4,0x13,
+0x99,0x00,0x43,0x9D,0xE5,0x4F,0x7C,0xFA,0x4F,0x7B,0xD1,0x43,0x3C,0xDC,0x57,0x39,
+0x3F,0x43,0x39,0xDD,0x5F,0x39,0x00,0x5F,0x24,0x13,0x20,0x00,0x25,0x43,0x3E,0xCD,
+0x5F,0x39,0x00,0x9F,0x01,0xD3,0x24,0x10,0x35,0x5F,0x78,0x00,0xD7,0x5B,0xFE,0x85,
+0xE4,0x00,0x04,0x8D,0xC3,0x20,0x10,0x01,0xEF,0x19,0x03,0x1E,0x13,0x38,0x00,0x0B,
+0x17,0x09,0x43,0x39,0xC3,0x53,0x00,0x64,0x43,0x39,0xC1,0x0B,0x17,0x03,0x43,0x39,
+0xC3,0x0B,0x17,0x01,0x42,0xF9,0xC0,0x0F,0x0B,0x1E,0xD6,0xF8,0x0E,0x8C,0x0E,0xEB,
+0x16,0xC2,0xE1,0x06,0x8C,0x20,0x07,0x19,0xE4,0x00,0x02,0x5F,0xD1,0xA9,0x02,0x46,
+0xC3,0x40,0x10,0x01,0xF6,0xFA,0x04,0xA4,0xD2,0xE3,0x0D,0x9C,0xEE,0xF6,0xFF,0x5A,
+0x50,0x60,0x64,0x42,0x10,0xBD,0xE7,0xFF,0xDF,0xF0,0xD4,0x70,0x0D,0x0C,0x12,0xEA,
+0x20,0xD2,0xE5,0x08,0x31,0x13,0x0A,0x01,0x9F,0x10,0x5F,0x18,0x00,0x5F,0x03,0xDB,
+0x20,0x03,0xDD,0x8E,0xEA,0x12,0xF7,0xFE,0x9E,0xF0,0x5E,0xF7,0x00,0x5E,0xE3,0xD3,
+0xE4,0x00,0x01,0x35,0xD1,0xA5,0x01,0x16,0x40,0x6E,0x9D,0xE7,0xFF,0xDF,0xBC,0xC0,
+0x60,0xA2,0x88,0x20,0x03,0x51,0x12,0xEA,0x00,0x9E,0xF8,0x5E,0xF7,0x00,0xD2,0xEE,
+0x0A,0xE9,0xE4,0x00,0x01,0x8B,0xD1,0xA6,0x03,0xDE,0xEF,0x16,0xFF,0x5E,0x40,0x78,
+0x7D,0xE7,0xFF,0xDF,0x70,0xC0,0x60,0x9C,0x48,0x20,0x00,0x79,0x40,0x6E,0x9D,0xE7,
+0xFF,0xDF,0x54,0xC0,0x60,0x3E,0x6C,0x20,0x00,0x41,0x12,0xEA,0x00,0x1E,0xF7,0xD8,
+0x5E,0xF7,0x00,0xD2,0xEE,0x09,0x41,0xEF,0x36,0xFF,0x5E,0x40,0x79,0x75,0xE7,0xFF,
+0xDF,0x16,0xC0,0x60,0x7D,0x08,0x20,0x02,0x05,0x40,0x6F,0x9D,0xE7,0xFF,0xDE,0xFA,
+0xC0,0x60,0xE0,0xEC,0x20,0x01,0xCD,0x12,0xEA,0x20,0x8E,0xEA,0x13,0x17,0xFF,0xD3,
+0x07,0x00,0x7D,0x12,0xF7,0xFE,0xD2,0xE7,0x07,0xAD,0xE4,0x00,0x00,0xBB,0x5F,0x02,
+0xD3,0x20,0x03,0xA9,0x12,0xF7,0xFE,0x5E,0xE2,0xD3,0x20,0x03,0x85,0xE4,0x00,0x00,
+0x95,0x9A,0xE0,0xD1,0xAB,0x02,0x36,0xEF,0x56,0xFF,0x5A,0xD6,0x1A,0x00,0x40,0xD5,
+0xCF,0x06,0x64,0x41,0xCE,0x7D,0x4C,0x6E,0xFA,0x45,0xC3,0x76,0x40,0x6E,0x1D,0xE7,
+0xFF,0xDE,0x54,0xC0,0x60,0x25,0x6C,0x20,0x00,0x81,0xEE,0xF6,0xFF,0x5A,0x98,0x80,
+0x42,0x10,0xBD,0x4C,0x70,0xFA,0x46,0x03,0x86,0x40,0x70,0x1D,0xE7,0xFF,0xDE,0x62,
+0xC0,0x60,0x25,0x68,0x20,0x02,0x5D,0x9A,0xE0,0xEF,0x36,0xFF,0x6A,0x0F,0x11,0x02,
+0x0F,0x18,0x06,0x8F,0x19,0x0F,0x38,0x0A,0x23,0x25,0x92,0x0F,0x4B,0x12,0x23,0x41,
+0x78,0x0F,0x2B,0x16,0x23,0x21,0x60,0x11,0xD8,0x0C,0x13,0xD8,0x0D,0x97,0x63,0x11,
+0x18,0x0E,0xCB,0x7B,0x34,0x50,0x13,0xB8,0x0F,0x41,0xCE,0xDB,0xCF,0x9E,0x07,0xD0,
+0xCF,0x1D,0x07,0xD0,0xD1,0xAA,0x00,0xAE,0x22,0xE0,0x44,0xCF,0x9E,0x46,0x50,0xCF,
+0x1D,0x46,0x50,0x43,0x9C,0x69,0x43,0x18,0x69,0xCE,0xFA,0x07,0xD0,0xD6,0xEE,0x01,
+0xF5,0xCF,0x5A,0x00,0x14,0xD7,0x9A,0x01,0xB5,0xCE,0xF9,0x07,0xD0,0x43,0x68,0xDB,
+0xD6,0xFB,0x01,0x5D,0xCF,0x39,0x00,0x14,0xD7,0x19,0x01,0x1D,0x0E,0xF6,0x96,0x0F,
+0x56,0x9A,0x0F,0x16,0x92,0x8E,0xFA,0x4E,0xF7,0x0A,0xD6,0xF8,0x00,0x88,0x5E,0xF7,
+0x00,0x0D,0x96,0x80,0x0E,0xF6,0x90,0xEE,0xF6,0xFF,0x78,0x9D,0x81,0x5D,0x8C,0x00,
+0x0E,0xF1,0x02,0x0F,0x17,0x02,0x0B,0x18,0x01,0xD7,0x0C,0xC0,0xB5,0xC2,0xE0,0x10,
+0x01,0xEF,0x36,0xFF,0x7A,0x0C,0x36,0x9E,0xFB,0x37,0x04,0xCF,0xE7,0xFF,0xE7,0x22,
+0x98,0x62,0xEF,0x56,0xFF,0x7A,0x23,0x41,0x14,0x0E,0xF1,0x02,0x0F,0x36,0x82,0x0F,
+0x17,0x06,0x0F,0x56,0xA2,0x4E,0xF9,0x20,0x98,0x61,0x8E,0xF8,0x12,0xF7,0x05,0x0E,
+0xFA,0x00,0xE4,0x00,0x00,0x53,0xEF,0x36,0xFF,0x6E,0x4F,0x19,0xFA,0x46,0x78,0xCE,
+0x42,0x73,0xC5,0x4F,0x12,0xFA,0x46,0x58,0x96,0x42,0x52,0xC5,0x4E,0x52,0x12,0xFE,
+0x52,0x01,0x2C,0xD6,0x72,0xFC,0xC4,0xE7,0xFF,0xFB,0x3B,0x0C,0x36,0xA6,0x0E,0xC1,
+0x72,0x0E,0xA1,0x76,0x0E,0x81,0x7A,0x0E,0x61,0x7E,0xEE,0x41,0x00,0x82,0xEE,0x21,
+0x00,0x86,0xEE,0x01,0x00,0x8A,0xED,0xE1,0x00,0x8E,0xED,0xC1,0x00,0x92,0xED,0xA1,
+0x00,0x96,0xED,0x81,0x00,0x9A,0xED,0x61,0x00,0x9E,0xED,0x41,0x00,0xA2,0xED,0x21,
+0x00,0xA6,0xFC,0x21,0x00,0xA8,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x04,0x84,
+0xC2,0xE0,0x10,0x01,0x9C,0x38,0xEC,0x97,0x04,0x8B,0x0D,0x21,0x04,0x0D,0x41,0x00,
+0x08,0x61,0x09,0xFD,0x57,0x04,0x8A,0x0C,0xAA,0x03,0x0C,0xCA,0x07,0x0C,0xEA,0x09,
+0x19,0x0A,0x04,0xE7,0xFF,0xDA,0xF6,0x0D,0x21,0x06,0x0C,0x6A,0x0B,0x0D,0x41,0x02,
+0x9C,0x28,0x85,0x29,0x9C,0x30,0x5C,0x63,0x00,0x0D,0x41,0x08,0x0D,0x61,0x04,0x4C,
+0x63,0x08,0xC2,0xF8,0x00,0x21,0x0D,0x21,0x0C,0xFE,0xF7,0xB7,0x2C,0x99,0x40,0x8E,
+0xE3,0x09,0x77,0x01,0x88,0x6A,0x88,0x8B,0x9D,0x41,0xE4,0x00,0xAF,0x08,0x5D,0x4A,
+0x00,0xD1,0x44,0xFF,0x9E,0x0D,0x61,0x06,0x0D,0x41,0x0A,0x0D,0x21,0x0E,0x1C,0x21,
+0x10,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x06,0x35,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x06,0x3A,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x06,0x33,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x06,0x36,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x06,0x3D,0xC2,0xE0,0x10,0x01,0xEC,
+0x17,0x06,0x39,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x06,0x40,0x85,0x29,0xC2,0xE0,0x10,
+0x01,0xEC,0x77,0x06,0x35,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x06,0x33,0xC2,0xE0,0x10,
+0x01,0xF0,0x77,0x06,0x3A,0xC2,0xE0,0x10,0x01,0xF8,0x77,0x06,0x36,0xC2,0xE0,0x10,
+0x01,0xEC,0x17,0x06,0x3D,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x06,0x39,0xC2,0xE0,0x10,
+0x01,0xEC,0x17,0x06,0x40,0x24,0x6C,0x1F,0xE7,0xFF,0xFE,0x99,0x85,0x29,0xC2,0xE0,
+0x10,0x01,0xC3,0x00,0x10,0x01,0x5C,0x63,0x04,0xEC,0x77,0x06,0x39,0xC2,0xE0,0x10,
+0x01,0xEC,0x17,0x06,0x40,0xF3,0x78,0x06,0x33,0xC3,0x40,0x10,0x01,0xC3,0x20,0x10,
+0x01,0xC3,0x00,0x10,0x01,0xFF,0x5A,0x06,0x3A,0xFF,0x39,0x06,0x36,0x23,0x60,0x2C,
+0xEB,0x78,0x06,0x3D,0xD7,0x63,0x00,0xA1,0x13,0x5A,0x00,0xEC,0x78,0x06,0x3D,0x1B,
+0x59,0x00,0x9B,0x01,0xEF,0x17,0x06,0x40,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEB,0x17,
+0x06,0x39,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x06,0x35,0x5E,0xF8,0x1F,0x48,0x61,0x01,
+0x85,0x29,0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x06,0x33,0x5E,0xE0,0x5B,0x48,0x61,0x01,
+0x85,0x29,0xC2,0xE0,0x10,0x01,0xF3,0x17,0x06,0x33,0x27,0x08,0x7B,0x9F,0x01,0xFB,
+0x17,0x06,0x33,0xC2,0xE0,0x10,0x01,0xF0,0x77,0x06,0x3A,0x9C,0x61,0x54,0x63,0x03,
+0xF8,0x77,0x06,0x3A,0xE7,0xFF,0xFD,0x61,0x85,0x29,0x8B,0x03,0x56,0xE3,0x03,0x22,
+0xE0,0x98,0x9B,0x04,0x42,0xF8,0xBD,0x5F,0x44,0x00,0x5E,0xE5,0x17,0x4B,0x37,0x28,
+0x9A,0xE0,0xE4,0x00,0x00,0x13,0x1B,0x58,0x00,0x9E,0xE1,0x43,0x03,0xBC,0xD6,0xF9,
+0xFF,0xC6,0x40,0xA5,0xBD,0x4E,0xE4,0x80,0x4F,0x64,0xC0,0x47,0x7B,0xBD,0x4E,0xE4,
+0x40,0x47,0x7B,0x25,0x4F,0x45,0x11,0x47,0x7B,0xBD,0x9A,0xE0,0xE4,0x00,0x00,0x17,
+0x8F,0x38,0x9E,0xE1,0x0F,0x79,0x00,0x4F,0x37,0x10,0xD6,0xFA,0xFF,0xB6,0x8F,0x19,
+0x9A,0xE0,0x54,0xA5,0x03,0x5C,0x84,0x00,0xE4,0x00,0x00,0x19,0x43,0x37,0xC4,0x9E,
+0xE1,0x18,0x99,0x00,0xD4,0xB7,0xFF,0xC5,0x85,0x29,0x46,0xE4,0x1D,0x56,0xF7,0x03,
+0x22,0xE0,0x82,0x9A,0xFC,0x47,0x45,0xBC,0x9A,0xE0,0xE4,0x00,0x00,0x51,0x43,0x03,
+0xBC,0x43,0x24,0xBC,0x9E,0xE1,0x13,0x39,0x00,0x1B,0x38,0x00,0xE4,0x00,0x00,0x0D,
+0x9A,0xE0,0xD6,0xE5,0xFF,0x66,0xE4,0x00,0x00,0x63,0x0F,0x39,0x02,0x9E,0xE4,0x0F,
+0x38,0x00,0x43,0x03,0xBC,0x43,0x24,0xBC,0xD6,0xFA,0xFF,0x96,0x9A,0xE0,0x54,0xA5,
+0x03,0xE4,0x00,0x00,0x25,0x43,0x57,0xC4,0x43,0x77,0xCC,0x9E,0xE1,0x13,0x7B,0x00,
+0x1B,0x7A,0x00,0xD4,0xB7,0xFF,0x95,0x85,0x29,0x9C,0x30,0x0D,0x41,0x08,0x0D,0x61,
+0x04,0x0D,0x21,0x0C,0x89,0x63,0x99,0x40,0xE4,0x00,0x20,0xB4,0x20,0x64,0xD2,0xE4,
+0x00,0x22,0xE6,0x20,0x64,0x82,0xE4,0x00,0x22,0xC4,0xC2,0xE0,0x10,0x01,0xFF,0x20,
+0xFF,0x7F,0xEB,0x17,0x08,0x25,0x99,0x41,0x47,0x18,0xCC,0xEF,0x17,0x08,0x25,0xE4,
+0x00,0x00,0x23,0xE4,0x00,0x22,0xDA,0x20,0x67,0x7C,0x88,0x6B,0xE4,0x00,0x22,0x3A,
+0x88,0x6A,0x0D,0x61,0x06,0x0D,0x41,0x0A,0x0D,0x21,0x0E,0x1C,0x21,0x10,0x85,0x29,
+0x1C,0x21,0xD0,0x0D,0x21,0x2C,0x0D,0x41,0x28,0x0D,0x61,0x24,0x0D,0x81,0x20,0x0D,
+0xA1,0x1C,0x0D,0xC1,0x18,0x0D,0xE1,0x14,0x0E,0x01,0x10,0x0E,0x21,0x0C,0x0E,0x41,
+0x08,0x0E,0x61,0x04,0xE4,0x00,0x5F,0x1C,0xC1,0x80,0x10,0x01,0xC0,0x60,0x00,0x21,
+0xFD,0x4C,0x00,0xC4,0xFC,0x63,0xB0,0xE4,0xC0,0x80,0x10,0x01,0xC0,0xA0,0x10,0x01,
+0xFC,0x84,0x00,0x00,0xFC,0xA5,0x03,0x44,0x40,0xA5,0x25,0xE4,0x00,0x5A,0x00,0x0C,
+0x0A,0x01,0x0C,0x0A,0x03,0x0C,0x0A,0x05,0x0C,0x0A,0x08,0xC2,0xE0,0x10,0x01,0xEC,
+0x17,0x00,0xB3,0x0C,0x0A,0x0C,0x9A,0xEA,0xC1,0xC0,0x10,0x01,0x0E,0xEA,0x11,0xEC,
+0x0E,0x06,0x50,0x50,0x60,0x26,0xE4,0x00,0x22,0xD4,0xC8,0x80,0xE1,0x00,0x98,0x60,
+0xE4,0x00,0x2E,0xCE,0x98,0x63,0xE4,0x00,0x2D,0x56,0xE4,0x00,0x06,0xF0,0xC2,0xE0,
+0x10,0x01,0x9B,0x3C,0xF3,0x17,0x0C,0xD8,0x47,0x18,0xCC,0xFC,0x60,0x0B,0xB8,0xFB,
+0x17,0x0C,0xD8,0x05,0x60,0x5B,0xC9,0x6B,0x8D,0x80,0x88,0x8B,0xE4,0x00,0x2D,0x8E,
+0x98,0x61,0xC2,0x58,0x00,0x21,0x8A,0x6B,0xC1,0x80,0x10,0x01,0xC1,0xA0,0x10,0x01,
+0xC1,0x60,0x10,0x01,0xE4,0x00,0x2D,0x66,0xC2,0x00,0x10,0x01,0xC1,0xE0,0x10,0x01,
+0xC2,0x20,0x10,0x01,0xFE,0x52,0xB7,0x34,0xFD,0x8C,0x06,0x4A,0xFD,0xAD,0x08,0x24,
+0xFD,0x6B,0x06,0x44,0xE4,0x00,0x2D,0x16,0x0E,0xEA,0x0E,0x22,0xE5,0xA0,0x22,0xE0,
+0x2C,0xD2,0xE2,0x17,0xB6,0xE4,0x00,0x02,0x5F,0xE4,0x00,0x58,0xAC,0xE4,0x00,0x2D,
+0x2C,0x0C,0x6A,0x13,0xE4,0x00,0x2D,0x1E,0x0C,0x6A,0x17,0xE4,0x00,0x2D,0x10,0x0C,
+0x6A,0x1B,0xE4,0x00,0x2D,0x02,0x0C,0x6A,0x19,0x0A,0xEC,0x01,0xC6,0xF7,0xFF,0xDF,
+0x0E,0xEC,0x01,0x0A,0xEC,0x01,0xC6,0xF7,0xFF,0x7F,0x0E,0xEC,0x01,0x9A,0xE1,0x0E,
+0xEA,0x0C,0x0A,0xED,0x01,0x52,0xF7,0x80,0xEC,0x0E,0x06,0x50,0x0E,0xED,0x01,0x98,
+0x61,0xE4,0x00,0x1D,0x24,0x98,0x60,0xE4,0x00,0x30,0x0E,0xE4,0x00,0x2F,0x1C,0xE4,
+0x00,0x05,0x31,0xEE,0xF0,0x06,0x4E,0x22,0xE4,0x4E,0x9A,0xE2,0x0E,0xEA,0x0C,0x0C,
+0x0B,0x00,0xEC,0x10,0x06,0x4C,0xE4,0x00,0x05,0x03,0xEE,0xEE,0x06,0x52,0x22,0xE0,
+0x2C,0xD2,0xE1,0x13,0xB6,0xE4,0x00,0x00,0x3D,0x98,0x61,0xE7,0xFF,0xFC,0x5C,0xD0,
+0x61,0x13,0x46,0xEC,0x0F,0x0D,0x7C,0xEC,0x6E,0x06,0x50,0xE4,0x00,0x5F,0xEA,0xE4,
+0x00,0x02,0x81,0x0A,0xEA,0x01,0xC6,0xF7,0x01,0x00,0xD2,0xE0,0x12,0x6A,0xE4,0x00,
+0x2B,0xEA,0x0A,0xEA,0x13,0x0B,0x0A,0x11,0x40,0x63,0xBD,0x5E,0xE3,0x04,0xD7,0x17,
+0x11,0xCD,0xE4,0x00,0x2B,0xC2,0x0C,0x6A,0x13,0x0A,0xEA,0x01,0xC6,0xF7,0xFE,0xFF,
+0x0E,0xEA,0x01,0xE4,0x00,0x5A,0x2E,0xE4,0x00,0x5F,0xE2,0xE4,0x00,0x5F,0x12,0xEE,
+0xEF,0x0D,0x7E,0xEE,0xF1,0x09,0xA8,0xE4,0x00,0x5B,0x26,0x98,0x61,0xE4,0x00,0x8F,
+0x40,0xE4,0x00,0x5B,0xAA,0x98,0x61,0xE4,0x00,0x5C,0x02,0xE4,0x00,0x5C,0xBC,0xE4,
+0x00,0x81,0x14,0x0A,0xED,0x01,0x56,0xF7,0x80,0xD2,0xE0,0x0F,0x72,0x0A,0xEA,0x01,
+0xC6,0xF7,0x01,0x00,0x22,0xE3,0xE4,0x0A,0xEA,0x01,0xC6,0xF7,0xFE,0xFF,0x0E,0xEA,
+0x01,0x9A,0xE1,0x0E,0xEA,0x0C,0xEC,0x0E,0x06,0x50,0x98,0x61,0xE4,0x00,0x1B,0x6E,
+0xE4,0x00,0x03,0x8F,0x0E,0xEB,0x02,0xD2,0xE4,0x0E,0x05,0x4E,0xF7,0x10,0x8E,0xF2,
+0x0E,0xF7,0x02,0x86,0xE9,0x0A,0xEC,0x01,0xC6,0xF7,0xFF,0xDF,0x0E,0xEC,0x01,0x0A,
+0xEC,0x01,0xC6,0xF7,0xFF,0x7F,0xFF,0x00,0xFF,0x7F,0x0E,0xEC,0x01,0x0A,0xED,0x01,
+0x46,0xF7,0xC4,0x0E,0xED,0x01,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0D,0x58,0xC2,0xE0,
+0x10,0x01,0xF8,0x17,0x0C,0xF5,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0D,0x59,0xE4,0x00,
+0x5C,0xDE,0x98,0x62,0xE4,0x00,0x29,0xBE,0x50,0x60,0x40,0xE4,0x00,0x29,0xD0,0x50,
+0x60,0x19,0xE4,0x00,0x5A,0xBC,0xE4,0x00,0x04,0x04,0x50,0x60,0xC8,0xE4,0x00,0x2A,
+0x30,0xE4,0x00,0x62,0x40,0x50,0x60,0x40,0xE4,0x00,0x5A,0x88,0xC8,0x80,0x7D,0x00,
+0xFC,0x60,0x0B,0xB8,0xE4,0x00,0x29,0x9E,0xFC,0x60,0x06,0x00,0xE4,0x00,0x5A,0x70,
+0xE4,0x00,0x03,0xC0,0xE4,0x00,0x02,0x5D,0x98,0x60,0xE7,0xFF,0xF9,0xDE,0xD0,0x61,
+0x09,0x4E,0x9A,0xE2,0xEC,0x0F,0x0D,0x7C,0x0E,0xEB,0x00,0xE4,0x00,0x5D,0xCA,0xE4,
+0x00,0x5D,0x0A,0xE4,0x00,0x02,0x29,0x0A,0xEA,0x01,0xC6,0xF7,0x01,0x00,0xD2,0xE0,
+0x05,0x8A,0x0A,0xEA,0x01,0xC6,0xF7,0xFE,0xFF,0x0E,0xEA,0x01,0xE4,0x00,0x03,0x48,
+0x98,0x60,0x98,0x80,0xE4,0x00,0x28,0xA6,0xFC,0x60,0x0B,0xB8,0xC8,0x80,0x7D,0x00,
+0xE4,0x00,0x28,0xE6,0xE4,0x00,0x29,0x0E,0xFC,0x60,0x0B,0xB8,0x88,0x93,0xE4,0x00,
+0x28,0xCA,0x98,0x81,0x98,0x60,0xE4,0x00,0x28,0x62,0xE4,0x00,0x02,0xE4,0x98,0x62,
+0xE4,0x00,0x28,0xDE,0xE4,0x00,0x28,0xDE,0x0C,0x6A,0x13,0x0A,0xEA,0x01,0xC6,0xF7,
+0xFE,0xFF,0x0E,0xEA,0x01,0xE4,0x00,0x57,0x4A,0xE4,0x00,0x58,0x62,0xE4,0x00,0x8C,
+0xE2,0x98,0x80,0x98,0x64,0xE4,0x00,0x40,0x90,0xE4,0x00,0x5C,0x16,0xEE,0xEF,0x0D,
+0x7E,0xEE,0xF1,0x09,0xA8,0xE4,0x00,0x58,0xC2,0x98,0x60,0xE4,0x00,0x59,0x1A,0xE4,
+0x00,0x59,0xD4,0xE4,0x00,0x7E,0x2C,0x0A,0xED,0x01,0x56,0xF7,0x80,0x22,0xE0,0x88,
+0x0A,0xEA,0x01,0xC6,0xF7,0x01,0x00,0x22,0xE3,0xE4,0x0A,0xEA,0x01,0xC6,0xF7,0xFE,
+0xFF,0x0E,0xEA,0x01,0x9A,0xE1,0x98,0x60,0x0E,0xEB,0x00,0xE4,0x00,0x18,0x90,0xC2,
+0xE0,0x10,0x01,0xEA,0xF7,0x0D,0x61,0x5E,0xEB,0x01,0x20,0x00,0x29,0x1E,0xF7,0xA0,
+0xD2,0xEB,0x02,0x3D,0x9A,0xE3,0xE4,0x00,0x00,0x7D,0x98,0x63,0xE4,0x00,0x2B,0x44,
+0xE4,0x00,0x2A,0x52,0xE4,0x00,0x27,0xBE,0x9A,0xE4,0x0C,0x6A,0x17,0xE4,0x00,0x00,
+0x4F,0xE4,0x00,0x27,0xA4,0x0A,0xEA,0x17,0x40,0x63,0xBD,0x5E,0xE3,0x04,0xC2,0xE0,
+0x7C,0xEA,0x20,0x00,0x55,0x98,0x60,0xE4,0x00,0x26,0x9E,0xE4,0x00,0x27,0x70,0x0C,
+0x6A,0x17,0x9A,0xE2,0x0E,0xEB,0x00,0x0E,0xEA,0x0A,0xFC,0x60,0x1E,0x7F,0x9E,0xE1,
+0x0E,0xEA,0x08,0x0C,0x8A,0x0A,0xE4,0x00,0x29,0x12,0xE4,0x00,0x27,0xE2,0xE7,0xFF,
+0xF9,0xCD,0xE4,0x00,0xA3,0x49,0x9C,0x38,0x0D,0x21,0x04,0x0D,0x41,0x00,0xE4,0x00,
+0xA4,0xA4,0x98,0x68,0xE4,0x00,0x95,0x1E,0x98,0x60,0xFC,0x80,0x28,0x0A,0xE4,0x00,
+0x97,0x62,0x98,0x61,0xFC,0x80,0x28,0x0A,0xE4,0x00,0x97,0x4E,0x98,0x60,0x50,0x80,
+0x14,0xE4,0x00,0x9C,0x48,0x98,0x60,0x98,0x8C,0xE4,0x00,0x9B,0x6A,0x98,0x61,0x50,
+0x80,0x14,0xE4,0x00,0x9C,0x26,0x98,0x61,0x98,0x8C,0x99,0x40,0xE4,0x00,0x9B,0x44,
+0x88,0x6A,0x98,0x80,0x9D,0x41,0xE4,0x00,0xA1,0xB0,0x5D,0x4A,0x00,0xD1,0x44,0xFF,
+0x9E,0x98,0x60,0x05,0x40,0xFF,0xC9,0x4A,0xFF,0xFF,0x88,0x8A,0xE4,0x00,0x99,0x9E,
+0x88,0x8A,0x98,0x60,0xE4,0x00,0x97,0x26,0x88,0x8A,0x0D,0x21,0x06,0x0D,0x41,0x02,
+0x98,0x60,0x9C,0x28,0xE4,0x00,0x98,0x07,0xE4,0x00,0xA3,0xF3,0xE4,0x00,0xA5,0x97,
+0xE4,0x00,0xA6,0xC3,0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x06,0x77,0x1C,0x21,0xB0,0x0E,
+0xE1,0x10,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x06,0x54,0x0D,0x41,0x4C,0x0D,0x61,0x48,
+0x0D,0x81,0x44,0x0D,0xE1,0x38,0x0E,0x01,0x34,0x0E,0x21,0x30,0x0E,0x41,0x2C,0x0E,
+0x61,0x28,0x0E,0x81,0x24,0x0D,0xA1,0x40,0x0D,0xC1,0x3C,0x0E,0xA1,0x20,0x0E,0xC1,
+0x1C,0x0E,0xE1,0x0C,0xC2,0x60,0x10,0x01,0xC2,0x40,0x10,0x01,0xFE,0x73,0x06,0x74,
+0xFE,0x52,0x06,0x5C,0xC2,0x20,0x10,0x01,0xC2,0x00,0x10,0x01,0xFE,0x31,0x06,0x60,
+0xFE,0x10,0x06,0x64,0xC1,0xE0,0x10,0x01,0xC1,0x8F,0xFF,0xE1,0xFD,0xEF,0x06,0x70,
+0x9B,0x80,0xC2,0x98,0x00,0x21,0xC0,0xD8,0x00,0x21,0x13,0x53,0x00,0x0E,0xF2,0x02,
+0x0D,0x51,0x02,0x0F,0xB0,0x02,0x0F,0x6F,0x02,0x99,0x60,0xC9,0x8C,0xFF,0xFF,0x88,
+0xFC,0x53,0x20,0xFF,0xFE,0x94,0xB7,0x64,0xFC,0xC6,0xB8,0xB4,0xE4,0x00,0x01,0xC5,
+0x41,0x14,0xC4,0x9F,0x01,0x11,0x08,0x00,0x8D,0xA8,0x5D,0xAD,0x00,0xE4,0x00,0x00,
+0x11,0x9B,0x00,0x89,0xB8,0x5D,0x18,0x00,0xD7,0xC8,0xFF,0x45,0xC3,0x18,0x00,0x21,
+0xFF,0x18,0xB7,0x64,0x8F,0x0B,0x99,0x00,0x12,0xB8,0x00,0xCF,0x0D,0x00,0x0A,0x1E,
+0xD5,0xFF,0x8F,0x06,0x0E,0xC1,0x08,0x0F,0x01,0x14,0xE4,0x00,0x01,0x37,0x0F,0x01,
+0x16,0xCD,0xE8,0x00,0x0A,0x8D,0xF8,0x0A,0xCF,0x00,0x0E,0xC1,0x04,0x0F,0x01,0x0E,
+0x0E,0xC1,0x0A,0xD5,0x16,0x00,0x3A,0x0B,0x0F,0x0A,0x0D,0xE1,0x06,0xD5,0xE4,0x03,
+0xB4,0xD4,0x98,0x03,0x94,0x8D,0xCD,0x5D,0xCE,0x00,0xCF,0x0E,0x00,0x0A,0x8F,0x06,
+0x09,0xF8,0x06,0x0B,0x18,0x08,0x4F,0x18,0x50,0x41,0xEF,0x23,0x8D,0xF8,0xFD,0xEF,
+0x02,0x00,0x4D,0xEF,0x52,0x5D,0xEF,0x06,0x41,0xEF,0x7B,0x43,0x03,0x7D,0x4E,0xD8,
+0xFA,0x47,0x16,0xC6,0x43,0x18,0xB5,0xD7,0x0C,0x01,0x4C,0xC3,0x20,0x1F,0xE4,0x20,
+0x00,0x2D,0x89,0x5D,0x89,0x97,0x8B,0x3A,0x88,0xFC,0x8B,0xAA,0x8A,0xEC,0x8B,0x59,
+0x8B,0x87,0x8B,0x78,0x89,0x4F,0x89,0x98,0x88,0xEE,0x8B,0x3E,0xE4,0x00,0x00,0x2F,
+0xC3,0x40,0x1F,0xE0,0x20,0x00,0x1D,0xD6,0xF8,0x00,0x60,0x8B,0xAF,0x8A,0xF8,0x8B,
+0x5E,0x8B,0x8E,0x9D,0x01,0x5D,0xC8,0x00,0xD6,0xAE,0xFB,0x35,0x9D,0x61,0x5F,0xCB,
+0x00,0x0E,0xC1,0x12,0xD6,0xDE,0xF9,0x6D,0xC3,0x00,0x10,0x01,0x1B,0x53,0x00,0xFF,
+0x18,0x06,0x70,0x0E,0xF2,0x00,0x0D,0x51,0x00,0x0F,0xB0,0x00,0x0F,0x78,0x00,0xC3,
+0x20,0x1F,0xE0,0x20,0x01,0x55,0xCF,0x9C,0x00,0x0A,0xCC,0xE7,0x00,0x0A,0x8C,0xE6,
+0x0B,0x07,0x04,0x4F,0x18,0x50,0x8C,0xDC,0x08,0x67,0x02,0x0B,0x86,0x02,0x40,0x63,
+0x23,0x0B,0x46,0x04,0x8C,0x78,0x43,0x1B,0xBC,0xFC,0x63,0x02,0x00,0x4C,0x63,0x52,
+0x23,0x00,0xA8,0xC2,0xE0,0x1F,0xE0,0x20,0x00,0x8D,0x40,0x63,0xBB,0x40,0x9C,0x23,
+0x4E,0xFA,0x50,0x8E,0xE4,0xFE,0xF7,0x02,0x00,0x4E,0xF7,0x52,0x43,0x77,0xDB,0x8C,
+0x7B,0x40,0x63,0xC0,0xE4,0x00,0x00,0x0D,0x88,0x64,0x0E,0xC1,0x1E,0x0E,0xA1,0x22,
+0x0E,0x81,0x26,0x0E,0x61,0x2A,0x0E,0x41,0x2E,0x0E,0x21,0x32,0x0E,0x01,0x36,0x0D,
+0xE1,0x3A,0x0D,0xC1,0x3E,0x0D,0xA1,0x42,0x0D,0x81,0x46,0x0D,0x61,0x4A,0x0D,0x41,
+0x4E,0x1B,0x25,0x00,0x1C,0x21,0x50,0x85,0x29,0x8B,0x23,0xC2,0xE0,0x10,0x01,0x5C,
+0xA5,0x00,0xF2,0xF7,0x06,0x77,0x98,0x60,0xD6,0xE5,0x0C,0xB9,0xD3,0x3F,0x0C,0x98,
+0xC2,0xE0,0x10,0x01,0xC3,0x00,0x10,0x01,0xC3,0x60,0x10,0x01,0xF2,0xF7,0x06,0x76,
+0xFF,0x18,0x06,0x56,0xFF,0x7B,0x06,0x75,0x22,0xE8,0x42,0x13,0x18,0x00,0x5F,0x08,
+0x9B,0x20,0x00,0x51,0xE4,0x00,0x01,0x3B,0xD2,0xE1,0x04,0xCE,0x13,0x18,0x00,0x5F,
+0x05,0x93,0x20,0x02,0x3D,0x24,0xA4,0x4B,0x9B,0x43,0x43,0x5A,0x2D,0x4F,0x5A,0x08,
+0x5F,0x5A,0x00,0xE4,0x00,0x00,0x37,0x20,0xA8,0x54,0x9B,0x44,0x43,0x5A,0x2D,0x4F,
+0x5A,0x08,0x5F,0x5A,0x00,0x20,0xAC,0xEE,0xE4,0x00,0x00,0x51,0x9B,0x43,0x9A,0xE0,
+0x13,0x9B,0x00,0x8B,0x17,0xE4,0x00,0x00,0x27,0x4F,0xB8,0x08,0x9F,0x01,0x8F,0xBC,
+0x5F,0x18,0x00,0x8E,0xFD,0x5E,0xF7,0x00,0xD7,0x05,0xFF,0x8E,0xE4,0x00,0x00,0x49,
+0x5E,0xE0,0x21,0x53,0x00,0x1D,0x52,0xE0,0x2F,0x4A,0xF8,0xB8,0xE4,0x00,0x00,0x4B,
+0x5E,0xE0,0x29,0x53,0x00,0x41,0x52,0xE0,0x29,0x4A,0xF8,0xB8,0xE4,0x00,0x00,0x2B,
+0x27,0x04,0x33,0x9F,0x9F,0x4F,0x18,0x08,0xE4,0x00,0x00,0x8B,0x9B,0x0A,0x20,0xA9,
+0x10,0x13,0x1B,0x00,0x9C,0xBF,0x9F,0x1F,0x4C,0xA5,0x08,0x8F,0x05,0xE4,0x00,0x00,
+0x65,0x9B,0x43,0x13,0xBB,0x00,0x43,0x5A,0x2D,0x9A,0xE0,0x4F,0x5A,0x08,0x8B,0x77,
+0x5F,0x5A,0x00,0xE4,0x00,0x00,0x21,0x8F,0x9D,0x9F,0x61,0x8E,0xFC,0x5F,0x7B,0x00,
+0x5E,0xF7,0x00,0x4F,0x9B,0x08,0xD7,0x65,0xFF,0x8E,0x1F,0x1D,0xFF,0x8F,0x1C,0x5F,
+0x18,0x00,0x4F,0x5A,0x08,0xC3,0xB8,0x00,0x21,0xFF,0xBD,0xB7,0x48,0x8F,0xBA,0x9B,
+0x40,0xE4,0x00,0x01,0x0B,0x4F,0x7A,0x08,0x8F,0x7D,0x0B,0x9B,0x00,0xD7,0x3C,0x03,
+0xBC,0x0B,0x7B,0x02,0xD7,0x79,0x03,0x84,0x8E,0xFA,0xC3,0xB8,0x00,0x21,0xCF,0x17,
+0x00,0x06,0xFF,0xBD,0xB7,0x6A,0x8F,0x1D,0x1F,0x57,0x01,0x14,0xD8,0x00,0xCF,0x5A,
+0x00,0x06,0x09,0x18,0x02,0x8F,0x5D,0x98,0x60,0x0B,0xB8,0x04,0x14,0xBA,0x00,0x0B,
+0xDA,0x02,0x0B,0x1A,0x04,0xD7,0x9B,0x02,0x52,0x42,0xF9,0xDD,0x40,0x77,0x33,0x43,
+0x3C,0xCD,0x43,0x59,0x2B,0x43,0xD9,0xF3,0x8F,0x43,0x40,0x77,0x43,0x43,0x5A,0x23,
+0x8C,0x7E,0x8C,0x7A,0x42,0xF7,0xEB,0x40,0x83,0x23,0x97,0x41,0x43,0x39,0xC3,0xCB,
+0x5A,0x86,0xA0,0x8F,0x37,0x40,0x64,0xD0,0x43,0x7C,0xDD,0x8C,0x79,0x40,0x63,0xD8,
+0xE4,0x00,0x00,0x1F,0x9F,0x41,0x5F,0x7A,0x00,0xD7,0x1B,0xFB,0xE5,0x98,0x60,0x85,
+0x29,0xC2,0xE0,0x10,0x01,0xF8,0x77,0x06,0x76,0xC2,0xE0,0x10,0x01,0xF8,0x97,0x06,
+0x6C,0xC2,0xE0,0x10,0x01,0xF8,0xB7,0x06,0x56,0xC2,0xE0,0x10,0x01,0xF8,0xD7,0x06,
+0x75,0xC2,0xE0,0x10,0x01,0xEC,0xF7,0x06,0x55,0x85,0x29,0x9A,0xFF,0x1C,0x21,0xD8,
+0x0D,0xE1,0x0C,0x1A,0xE1,0x07,0xC1,0xE0,0x10,0x01,0xFD,0xEF,0x06,0x74,0x1A,0xEF,
+0x00,0x52,0xE0,0xFF,0xC3,0x00,0x10,0x01,0x0D,0x41,0x20,0x0D,0x61,0x1C,0x0D,0xA1,
+0x14,0x0D,0xC1,0x10,0xCB,0x20,0xFF,0xFF,0xC1,0xC0,0x10,0x01,0xEF,0x38,0x06,0x58,
+0xFD,0xCE,0x06,0x70,0xC1,0xA0,0x10,0x01,0x0E,0xEE,0x00,0xFD,0xAD,0x06,0x5C,0x0D,
+0x21,0x24,0x0E,0xED,0x00,0x0D,0x81,0x18,0xC2,0xE0,0x10,0x01,0x0E,0x01,0x08,0x89,
+0x63,0xF3,0x17,0x06,0x76,0x89,0x44,0x88,0x65,0xC2,0xE0,0x10,0x01,0x23,0x08,0x56,
+0xC3,0x00,0x10,0x01,0xF3,0x18,0x06,0x56,0x5F,0x08,0x9B,0x20,0x00,0x61,0xE4,0x00,
+0x00,0x37,0x23,0x04,0x5E,0xC3,0x00,0x10,0x01,0xF3,0x18,0x06,0x56,0x5F,0x05,0x93,
+0x20,0x00,0x25,0x9B,0x05,0xE4,0x00,0x00,0x0D,0x9B,0x04,0xFB,0x17,0x06,0x77,0xC2,
+0x00,0x10,0x01,0x0E,0xEB,0x02,0xEE,0xF0,0x06,0x58,0x0A,0xE6,0x0A,0x0C,0x8B,0x02,
+0xD4,0x97,0x04,0xCC,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x0C,0xDB,0x53,0x18,0x01,0x1C,
+0xA1,0x07,0xEF,0x17,0x0C,0xDB,0xE7,0xFF,0xF6,0x9C,0x0C,0x6B,0x00,0x0C,0x8A,0x02,
+0xED,0x90,0x06,0x5A,0x10,0xAF,0x00,0x88,0x6C,0xE7,0xFF,0xFA,0xC0,0xC2,0xE0,0x10,
+0x01,0x89,0x63,0xEC,0x77,0x06,0x68,0x10,0xA1,0x07,0x0C,0x8A,0x02,0x88,0x6C,0xE7,
+0xFF,0xFA,0x94,0xC3,0x00,0x10,0x01,0xEC,0x78,0x06,0x78,0x0F,0x6E,0x02,0x0F,0x2D,
+0x02,0x0F,0x4A,0x02,0x43,0x1B,0xCC,0x23,0x00,0xEC,0xC3,0x20,0x1F,0xE0,0x20,0x00,
+0xD1,0xC3,0x80,0x10,0x01,0xEF,0xBC,0x06,0x62,0xC3,0x80,0x10,0x01,0xEF,0x9C,0x06,
+0x66,0x43,0xBD,0xE5,0x4F,0x9D,0xFA,0x47,0xBC,0xEE,0x43,0x9D,0xE5,0xD7,0x1C,0x00,
+0xAC,0x41,0x6B,0xDB,0x42,0xE3,0xCB,0x8E,0xEB,0x43,0x17,0xC0,0x8F,0x58,0xE4,0x00,
+0x01,0x55,0x42,0xFA,0x1C,0xE4,0x00,0x01,0x5B,0xC9,0x80,0x07,0xFF,0x42,0xEC,0xBD,
+0xD6,0xE4,0x05,0x2C,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x0C,0xDB,0x53,0x18,0x01,0x40,
+0x8C,0x25,0xEF,0x17,0x0C,0xDB,0x1C,0xA1,0x07,0xE7,0xFF,0xF5,0x56,0x40,0x6C,0x1D,
+0x0C,0x6B,0x00,0xEE,0xF0,0x06,0x5A,0x0C,0x8A,0x02,0x41,0x8C,0xBD,0x10,0xAF,0x00,
+0x88,0x6C,0xE7,0xFF,0xF9,0x6E,0xC2,0xE0,0x10,0x01,0x89,0x63,0xEC,0x77,0x06,0x68,
+0x10,0xA1,0x07,0x0C,0x8A,0x02,0x88,0x6C,0xE7,0xFF,0xF9,0x42,0xC3,0x00,0x10,0x01,
+0xEC,0x78,0x06,0x78,0x0F,0x6E,0x02,0x0F,0x2D,0x02,0x0F,0x4A,0x02,0x43,0x1B,0xCC,
+0x23,0x00,0xFC,0xC3,0x20,0x1F,0xE0,0x20,0x00,0xE1,0xC3,0x80,0x10,0x01,0xEF,0xBC,
+0x06,0x62,0xC3,0x80,0x10,0x01,0xEF,0x9C,0x06,0x66,0x43,0xBD,0xE5,0x4F,0x9D,0xFA,
+0x47,0xBC,0xEE,0x43,0x9D,0xE5,0xD7,0x1C,0x00,0xCC,0x41,0x6B,0xDB,0x42,0xE3,0xCB,
+0x8E,0xEB,0x43,0x17,0xC0,0x43,0x5A,0xC5,0x0F,0x4A,0x00,0xE4,0x00,0x00,0x15,0x42,
+0xFA,0x1D,0x0E,0xEA,0x00,0x0E,0x01,0x0A,0x0D,0xE1,0x0E,0x0D,0xC1,0x12,0x0D,0xA1,
+0x16,0x0D,0x81,0x1A,0x0D,0x61,0x1E,0x0D,0x41,0x22,0x0D,0x21,0x26,0x1C,0x21,0x28,
+0x85,0x29,0x1C,0x21,0xD0,0x0D,0x41,0x28,0x0D,0x61,0x24,0x0D,0x81,0x20,0x0D,0xA1,
+0x1C,0x0D,0xC1,0x18,0x0D,0xE1,0x14,0x0E,0x01,0x10,0x0E,0x21,0x0C,0x0E,0x41,0x08,
+0x5E,0x23,0x00,0x0E,0x61,0x04,0x56,0x11,0x03,0x4E,0xF1,0x11,0x5E,0x00,0x09,0x99,
+0xC0,0x4A,0x41,0x01,0x99,0x80,0x9A,0x64,0x0D,0x21,0x2C,0x8E,0x57,0x89,0x44,0x89,
+0xAE,0x89,0x6C,0x99,0xE0,0x42,0x73,0x25,0xE4,0x00,0x00,0xF3,0x42,0xF3,0x54,0xD6,
+0xF1,0x01,0xD8,0x22,0x04,0x4A,0x51,0xC0,0x10,0x11,0x6A,0x00,0x89,0xAE,0x51,0x80,
+0x10,0xE4,0x00,0x00,0x6B,0x22,0x08,0x4A,0x51,0xC0,0x10,0x11,0x6A,0x00,0x11,0x8A,
+0x01,0x89,0xAE,0xE4,0x00,0x00,0x47,0x22,0x0C,0x7E,0x11,0x6A,0x00,0x11,0x8A,0x01,
+0x11,0xAA,0x02,0x51,0xC0,0x10,0xE4,0x00,0x00,0x21,0x11,0x6A,0x00,0x11,0x8A,0x01,
+0x11,0xAA,0x02,0x11,0xCA,0x03,0x4E,0xEC,0x80,0x4C,0x8C,0xC0,0x8C,0x97,0x4E,0xEE,
+0x80,0x4F,0x0B,0x40,0x4C,0xAE,0xC0,0x8C,0xB7,0x4E,0xED,0x40,0x88,0x6F,0x8C,0x8B,
+0x8C,0xAD,0x8C,0x98,0x8C,0xB7,0x9D,0xE1,0xE4,0x00,0x87,0xC6,0x5D,0xEF,0x00,0x9D,
+0x44,0xD5,0xF2,0xFC,0x5E,0x0E,0x61,0x06,0x0E,0x41,0x0A,0x0E,0x21,0x0E,0x0E,0x01,
+0x12,0x0D,0xE1,0x16,0x0D,0xC1,0x1A,0x0D,0xA1,0x1E,0x0D,0x81,0x22,0x0D,0x61,0x26,
+0x0D,0x41,0x2A,0x0D,0x21,0x2E,0x1C,0x21,0x30,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEE,
+0xF7,0x00,0xD2,0x5E,0xE0,0x41,0x1C,0x21,0xE8,0x0D,0x61,0x0C,0x0D,0x81,0x08,0x0D,
+0xA1,0x04,0x0D,0x21,0x14,0x0D,0x41,0x10,0x89,0x63,0x5D,0x84,0x00,0x49,0xA1,0x01,
+0xE4,0x00,0x4B,0x94,0xC3,0x14,0x00,0x01,0xCB,0x18,0x7A,0x30,0x0A,0xF8,0x01,0xC6,
+0xF7,0x01,0x00,0x5E,0xF7,0x04,0x22,0xE3,0xD8,0xFC,0x60,0x01,0x00,0x99,0x40,0xE4,
+0x00,0x17,0x58,0xE4,0x00,0x00,0x31,0x88,0x6A,0x98,0x81,0x88,0xAD,0x9D,0x41,0xE4,
+0x00,0x9C,0x94,0x5D,0x4A,0x00,0x0C,0x6B,0x01,0x9D,0x62,0xD5,0x4C,0xFF,0x66,0x0D,
+0xA1,0x06,0x0D,0x81,0x0A,0x0D,0x61,0x0E,0x0D,0x41,0x12,0x0D,0x21,0x16,0x1C,0x21,
+0x18,0x85,0x29,0xFC,0x21,0xFD,0xF0,0xED,0x41,0x02,0x08,0xED,0xE1,0x01,0xF4,0xEE,
+0x01,0x01,0xF0,0xED,0x21,0x02,0x0C,0xED,0x61,0x02,0x04,0xED,0x81,0x02,0x00,0xED,
+0xA1,0x01,0xFC,0xED,0xC1,0x01,0xF8,0xEE,0x21,0x01,0xEC,0xEE,0x41,0x01,0xE8,0xEE,
+0x61,0x01,0xE4,0xC2,0x00,0x10,0x01,0xC1,0xE0,0x10,0x01,0x89,0x43,0xFE,0x10,0x07,
+0xBC,0xFD,0xEF,0x07,0x64,0x20,0x60,0x30,0x20,0x68,0x84,0x20,0x64,0x30,0x24,0x64,
+0x5F,0x99,0x80,0xE4,0x00,0x00,0x0D,0x99,0x81,0x4D,0x8C,0x20,0x51,0x60,0x10,0x8D,
+0x90,0xE4,0x00,0x00,0x29,0xD0,0x64,0x00,0x62,0x99,0x80,0x89,0x6C,0xE4,0x00,0x00,
+0x11,0x89,0x8F,0x99,0x63,0x9A,0xE0,0x89,0xC1,0x53,0x20,0x10,0xE4,0x00,0x00,0x19,
+0x43,0x0E,0xBC,0x9E,0xE1,0x1B,0x38,0x00,0x5F,0x17,0x00,0xD5,0x78,0xFF,0xAD,0x88,
+0x6B,0x88,0x81,0x99,0xA3,0xE7,0xFF,0xFC,0x1A,0x89,0xC1,0xFE,0x20,0xFE,0xB0,0xCA,
+0x40,0x01,0x50,0x52,0x60,0x3F,0x1C,0x61,0x60,0x88,0x8B,0xE7,0xFF,0xFD,0xC0,0x1F,
+0x21,0x60,0x8B,0x01,0x9B,0x41,0xE4,0x00,0x00,0x93,0x0A,0xF9,0x00,0xC2,0xFF,0xD5,
+0xEC,0x20,0x00,0x39,0x43,0x71,0xBD,0xC3,0x60,0x2A,0x0C,0xE4,0x00,0x00,0x0F,0x5E,
+0xE0,0x19,0x4B,0x61,0x01,0x23,0x60,0x98,0xFE,0xF7,0x01,0x50,0x13,0x58,0x00,0x42,
+0xF7,0x90,0x8E,0xFA,0x5E,0xF7,0x06,0x26,0xFC,0x34,0x5E,0xE7,0xF1,0x4A,0xF7,0x98,
+0xE4,0x00,0x00,0x0D,0x9A,0xE0,0x1A,0xF8,0x00,0x9B,0x40,0x9F,0x01,0x9F,0x22,0x42,
+0xF8,0x75,0x5E,0xF7,0x00,0xD5,0x77,0xFD,0xAD,0x23,0x40,0x24,0x9A,0xE0,0xE4,0x00,
+0x00,0x51,0x88,0x6B,0x88,0x81,0x9D,0xBF,0xE7,0xFF,0xFB,0x14,0x5D,0xAD,0x00,0x21,
+0xA2,0x1E,0xE7,0xFF,0xFF,0xD5,0x43,0x0C,0xBC,0x1F,0x21,0x00,0x8F,0x37,0x9E,0xE1,
+0x13,0x39,0x00,0x1B,0x38,0x00,0x5F,0x17,0x00,0xD5,0x78,0xFF,0x6D,0x21,0x40,0x64,
+0x21,0x48,0x28,0x21,0x44,0x8C,0xD1,0x44,0x01,0xCA,0x99,0x60,0x99,0x80,0x88,0x8B,
+0x89,0x4C,0xE4,0x00,0x00,0x77,0xC1,0x80,0x10,0x01,0x99,0x60,0x88,0x90,0xFD,0x8C,
+0x0A,0x64,0xE4,0x00,0x00,0x2D,0xC0,0x80,0x10,0x01,0xC1,0x80,0x10,0x01,0x99,0x61,
+0xFC,0x84,0x07,0xCC,0xFD,0x8C,0x0A,0xA4,0x51,0x40,0x10,0xE4,0x00,0x00,0x25,0xC1,
+0x80,0x10,0x01,0x99,0x68,0x88,0x8F,0xFD,0x8C,0x0C,0xCC,0x99,0x43,0x88,0x6A,0xE7,
+0xFF,0xFA,0x26,0xFD,0xA1,0x01,0x20,0x88,0x8A,0x88,0x6D,0xE7,0xFF,0xFB,0xE0,0x9A,
+0xE0,0xE4,0x00,0x00,0x33,0x4F,0x17,0x10,0x4F,0x37,0x08,0x8F,0x0C,0x8F,0x2D,0x9E,
+0xE1,0x0B,0x39,0x00,0x4F,0x39,0x40,0x0F,0x38,0x00,0x5F,0x17,0x00,0xD5,0x58,0xFF,
+0x45,0x88,0x6B,0xE4,0x00,0x48,0xF4,0xED,0x21,0x02,0x0E,0xEE,0x61,0x01,0xE6,0xEE,
+0x41,0x01,0xEA,0xEE,0x21,0x01,0xEE,0xEE,0x01,0x01,0xF2,0xED,0xE1,0x01,0xF6,0xED,
+0xC1,0x01,0xFA,0xED,0xA1,0x01,0xFE,0xED,0x81,0x02,0x02,0xED,0x61,0x02,0x06,0xED,
+0x41,0x02,0x0A,0xFC,0x21,0x02,0x10,0x85,0x29,0x9C,0x38,0xC2,0xE0,0x10,0x01,0x0D,
+0x21,0x04,0xFE,0xF7,0x07,0xBC,0x9B,0x00,0x13,0x37,0x00,0x13,0x57,0x10,0x8F,0x3A,
+0x4F,0x39,0x08,0x9E,0xE1,0x8F,0x19,0xC3,0x20,0x10,0x01,0xFF,0x39,0x07,0xCC,0xD6,
+0xF9,0xFF,0x4E,0xC2,0xE0,0x10,0x01,0xF3,0x57,0x07,0x64,0xFE,0xF7,0x07,0x64,0x13,
+0x37,0x02,0x13,0x77,0x01,0x98,0x60,0x42,0xFB,0xD4,0x98,0x80,0x8E,0xF9,0x53,0x20,
+0x43,0x4E,0xF7,0x08,0x8E,0xF8,0x97,0x03,0x4E,0xF7,0x09,0xCB,0x18,0xD0,0x8F,0xCE,
+0xF7,0x03,0x5B,0x42,0xF7,0xC9,0xCE,0xF7,0x00,0x23,0xD6,0xF8,0x00,0xA1,0x97,0x2F,
+0x98,0x60,0xCB,0x39,0x42,0x3F,0x98,0x82,0xD6,0xF9,0x00,0x31,0x98,0x87,0xE4,0x00,
+0x91,0x8A,0x0D,0x21,0x06,0x98,0x61,0x98,0x80,0x9C,0x28,0xE4,0x00,0x91,0x71,0x9C,
+0x38,0x98,0x80,0x0D,0x21,0x04,0x98,0x66,0xE4,0x00,0x26,0x06,0x98,0x60,0xE7,0xFF,
+0xFA,0xEA,0x98,0x81,0x98,0x66,0xE4,0x00,0x25,0xEA,0x98,0x61,0xE7,0xFF,0xFA,0xCE,
+0x98,0x66,0x98,0x87,0xE4,0x00,0x25,0xCE,0x0D,0x21,0x06,0x98,0x64,0x9C,0x28,0xE7,
+0xFF,0xFA,0xA9,0xC2,0xE0,0x10,0x01,0x5C,0xA0,0x29,0xF3,0x37,0x0A,0xE4,0x53,0x40,
+0x6C,0x52,0xE0,0x36,0xC3,0x60,0x10,0x01,0x4B,0x5A,0xB8,0xFF,0x7B,0x0D,0x04,0x20,
+0x60,0x6C,0xE4,0x00,0x00,0x55,0x4F,0x17,0x08,0x9E,0xE1,0x8F,0x1B,0x0B,0x18,0x00,
+0xD7,0x58,0x00,0x78,0x98,0x61,0xE4,0x00,0x00,0xD9,0x9A,0xE0,0x43,0x40,0xD5,0x5F,
+0x17,0x00,0xD7,0x38,0xFF,0x25,0x98,0x60,0xE4,0x00,0x00,0xB5,0x20,0x67,0xEA,0x9A,
+0xE0,0x20,0x80,0xA6,0x9A,0xE0,0x43,0x80,0xD5,0xE4,0x00,0x00,0x7D,0x4F,0x17,0x08,
+0x8F,0x1B,0x0B,0x18,0x00,0x4F,0x98,0xFA,0x47,0x1C,0xC6,0x43,0x18,0xE5,0x0B,0x84,
+0x00,0xD7,0x1C,0x00,0x38,0x0F,0x04,0x01,0x9E,0xE1,0x5F,0x17,0x00,0xD7,0x38,0xFF,
+0x05,0xE7,0xFF,0xFF,0xA7,0x4F,0x17,0x08,0x8F,0x1B,0x0B,0x18,0x00,0xD7,0x98,0xFD,
+0x3C,0x9E,0xE1,0xD7,0x1A,0xFD,0x0C,0x5F,0x17,0x00,0xD7,0x38,0xFF,0x5D,0xE7,0xFF,
+0xFF,0x51,0x85,0x29,0xC2,0xE0,0x10,0x01,0xC3,0x00,0x10,0x01,0xF3,0xB7,0x0A,0xE4,
+0xC3,0xC0,0x10,0x01,0x9A,0xE0,0xFF,0x18,0x06,0x80,0x8B,0x37,0xFF,0xDE,0x0D,0x04,
+0xE4,0x00,0x00,0x5B,0x4F,0x57,0x08,0x0B,0x98,0x00,0x8F,0x5E,0x0B,0x5A,0x00,0x43,
+0x9A,0xE5,0x4F,0x7C,0xFA,0x47,0x9B,0xE6,0x43,0x7C,0xDD,0x5F,0x6A,0x31,0x20,0x00,
+0x21,0x9F,0x21,0x5F,0x39,0x00,0x0F,0x58,0x01,0x9E,0xE1,0x9F,0x02,0x5F,0x57,0x00,
+0xD7,0xBA,0xFE,0xA5,0x5F,0x21,0x13,0x48,0x61,0x01,0x85,0x29,0xC2,0xE0,0x10,0x01,
+0xC3,0x40,0x10,0x01,0xF3,0x37,0x0A,0xE4,0xC3,0x60,0x10,0x01,0x9A,0xE0,0xFF,0x5A,
+0x06,0x80,0xFF,0x7B,0x0D,0x04,0xE4,0x00,0x00,0x29,0x4F,0x17,0x08,0x9E,0xE1,0x43,
+0x9A,0xC4,0x8F,0x1B,0x0B,0x18,0x01,0x0F,0x1C,0x01,0x5F,0x17,0x00,0xD7,0x38,0xFF,
+0x6D,0x85,0x29,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0A,0xF2,0xC2,0xE0,0x10,0x01,0x9C,
+0x38,0xF8,0x17,0x09,0xC8,0x0D,0x21,0x04,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x07,0xDC,
+0x20,0x64,0x26,0x98,0x60,0xE4,0x00,0x00,0x0D,0x98,0x64,0x98,0x80,0xE4,0x00,0x27,
+0x20,0xC2,0xE0,0x10,0x01,0x0D,0x21,0x06,0xEC,0x17,0x06,0x7C,0x9C,0x28,0xE4,0x00,
+0x42,0x8D,0x1C,0x21,0xE8,0xC2,0xE0,0x10,0x01,0x0D,0x41,0x10,0xEB,0x17,0x00,0xC5,
+0x0D,0x21,0x14,0x0D,0x61,0x0C,0x0C,0x01,0x07,0x89,0x43,0xC7,0x18,0x01,0x00,0x98,
+0x60,0xD3,0x00,0x06,0x52,0xEB,0x17,0x00,0xC5,0xC7,0x18,0xFE,0xFF,0xEF,0x17,0x00,
+0xC5,0xE4,0x00,0x3D,0x32,0xE4,0x00,0x3E,0x4A,0x21,0x44,0x36,0x98,0x61,0xE4,0x00,
+0x72,0x5E,0xE4,0x00,0x00,0x11,0xE4,0x00,0x72,0xB0,0xC2,0xE0,0x10,0x01,0xED,0x77,
+0x06,0x7E,0x5D,0x60,0x01,0x0C,0x01,0x07,0x98,0x61,0x1C,0x81,0x06,0x98,0xA1,0x48,
+0x84,0x00,0x88,0xCA,0xE7,0xFF,0xFC,0x5E,0xC2,0xE0,0x10,0x01,0x20,0x60,0xEE,0xF3,
+0x17,0x0A,0xF2,0x9F,0x01,0xFB,0x17,0x0A,0xF2,0x0A,0xE1,0x06,0x5E,0xE3,0x59,0x20,
+0x00,0x45,0xC2,0xE0,0x10,0x01,0xF3,0x17,0x09,0xC8,0x9F,0x01,0xFB,0x17,0x09,0xC8,
+0x98,0x63,0x21,0x44,0x36,0x98,0x81,0xE4,0x00,0x6E,0xC6,0xE4,0x00,0x00,0x6D,0xE4,
+0x00,0x6F,0x3C,0xE4,0x00,0x00,0x5D,0xF8,0x17,0x0A,0xF2,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x09,0xC8,0x21,0x63,0x76,0x0A,0xE1,0x06,0xC2,0xE0,0x14,0x48,0x23,0xFF,0x4D,
+0x21,0x44,0x36,0x98,0x61,0xE4,0x00,0x46,0x66,0xE4,0x00,0x00,0x11,0xE4,0x00,0x46,
+0xB8,0x9B,0x01,0xC2,0xE0,0x10,0x01,0x98,0x61,0xEF,0x17,0x06,0x7C,0xC2,0xE0,0x10,
+0x01,0xF3,0x17,0x07,0xDC,0x9F,0x01,0xFB,0x17,0x07,0xDC,0x0D,0x61,0x0E,0x0D,0x41,
+0x12,0x0D,0x21,0x16,0x1C,0x21,0x18,0x85,0x29,0x9C,0x38,0x0D,0x21,0x04,0x20,0x64,
+0x26,0x98,0x60,0xE4,0x00,0x00,0x0D,0x98,0x64,0x98,0x80,0xE4,0x00,0x24,0xE4,0x0D,
+0x21,0x06,0x9C,0x28,0xE4,0x00,0x40,0x61,0x98,0x81,0x98,0x60,0x88,0xA4,0xE7,0xFF,
+0xA7,0x9D,0xC2,0xE0,0x10,0x01,0x98,0x61,0xF2,0xF7,0x0A,0xF2,0xD2,0xEA,0x00,0x95,
+0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x09,0xC8,0x5E,0xE0,0xBB,0x48,0x61,0x01,0x85,0x29,
+0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x07,0xDC,0x5E,0xE1,0xDB,0x48,0x61,0x01,0x85,0x29,
+0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x00,0x00,0x0C,0x17,0x00,0x0C,0x17,0x19,0x0C,0x17,
+0x1B,0xEC,0x17,0x00,0xA1,0xEC,0x17,0x00,0xA3,0xEC,0x17,0x00,0xA5,0xEC,0x17,0x00,
+0xA7,0xF8,0x17,0x00,0xA8,0xEC,0x17,0x00,0xAC,0x1F,0x17,0x08,0xEC,0x17,0x00,0xA1,
+0x0F,0x17,0x04,0x1F,0x17,0x20,0x0F,0x17,0x1C,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x00,
+0xC9,0x53,0x18,0x02,0xEF,0x17,0x00,0xC9,0x85,0x29,0xC3,0x20,0x10,0x01,0xFF,0x19,
+0x00,0x00,0x1E,0xF8,0x20,0x5C,0x63,0x04,0x0E,0xF8,0x1C,0x9A,0xE0,0xE4,0x00,0x00,
+0x29,0x0F,0x38,0x1E,0x43,0x44,0xBC,0x8F,0x37,0x13,0x5A,0x00,0x9E,0xE1,0x1B,0x59,
+0x00,0x5F,0x37,0x04,0xD4,0x79,0xFF,0x6D,0x9A,0xE1,0xEE,0xF8,0x00,0xAC,0x85,0x29,
+0x9C,0x38,0x0D,0x21,0x04,0x0D,0x41,0x00,0x5D,0x43,0x00,0xE7,0xFF,0xFE,0xEA,0x88,
+0x6A,0xE4,0x00,0x8D,0x44,0x0D,0x21,0x06,0x0D,0x41,0x02,0x9C,0x28,0x85,0x29,0x1C,
+0x21,0xE8,0x0D,0x41,0x10,0x0D,0x81,0x08,0x0D,0xC1,0x00,0x0D,0x21,0x14,0x0D,0x61,
+0x0C,0x0D,0xA1,0x04,0xC1,0x80,0x10,0x01,0xE4,0x00,0x8E,0xC2,0xC1,0xC0,0x10,0x01,
+0x5C,0x63,0x00,0xFD,0x8C,0x00,0xB8,0xFD,0x4E,0x00,0x00,0xD0,0x60,0x1C,0x12,0xE4,
+0x00,0x8E,0xE0,0x5C,0x63,0x00,0x20,0x60,0xDC,0x0C,0x0A,0x19,0xE4,0x00,0x8F,0x6C,
+0xE4,0x00,0x0A,0xA6,0xEC,0x6A,0x00,0xA5,0xE4,0x00,0x00,0x4B,0x0E,0xEA,0x06,0x09,
+0xAA,0x19,0x8D,0xB7,0xE4,0x00,0x8F,0x70,0x18,0x6D,0x00,0x0A,0xEA,0x19,0xD2,0xEE,
+0x00,0x8D,0x0A,0xEA,0x19,0x9E,0xE1,0x5E,0xF7,0x04,0x0E,0xEA,0x19,0x99,0x60,0xE4,
+0x00,0x8D,0xEE,0x5C,0x63,0x00,0x20,0x63,0x5A,0x0E,0xEA,0x06,0x13,0x17,0x00,0x5F,
+0x0A,0x09,0x20,0x00,0x61,0x0A,0xEA,0x19,0xD2,0xE4,0x03,0x06,0xE4,0x00,0x8E,0x98,
+0x0A,0xEA,0x19,0x22,0xE1,0xA2,0xE4,0x00,0x08,0x87,0x13,0x17,0x00,0x5F,0x0A,0x29,
+0x20,0x01,0x0B,0x13,0x17,0x00,0x5F,0x0A,0x49,0x23,0xFF,0x73,0x13,0x17,0x00,0x5F,
+0x0A,0x69,0x20,0x00,0xC3,0x13,0x17,0x00,0x5F,0x0A,0x89,0x20,0x00,0x9F,0x13,0x17,
+0x00,0x5F,0x0B,0x09,0x20,0x00,0x7B,0x13,0x17,0x00,0x5F,0x0B,0x29,0x23,0xFE,0xE3,
+0x13,0x17,0x00,0x5F,0x04,0x09,0x20,0x00,0x33,0x12,0xF7,0x00,0x5E,0xE4,0x29,0x20,
+0x00,0x25,0x0A,0xEA,0x19,0x22,0xEE,0x9C,0x98,0x61,0xE4,0x00,0x9F,0x20,0x9D,0x61,
+0xC1,0x64,0xE2,0x0E,0x23,0xFD,0xEF,0xE7,0xFF,0xFF,0x2B,0x0E,0xEA,0x06,0x13,0x17,
+0x00,0xD3,0x00,0x1E,0xC2,0x13,0x17,0x00,0x5F,0x0B,0x9B,0x20,0x0F,0x39,0x13,0x17,
+0x00,0x5F,0x0A,0x49,0x07,0x00,0x80,0x20,0x00,0xA5,0x0B,0x2A,0x19,0xD3,0x24,0x14,
+0x36,0x13,0x37,0x01,0x13,0x57,0x02,0x12,0xF7,0x03,0x4F,0x39,0x40,0x47,0x39,0xD5,
+0xC3,0x22,0x7F,0xEE,0x20,0x09,0xBD,0x8F,0x19,0x1A,0xF8,0x00,0xE4,0x00,0x04,0xCF,
+0x13,0x37,0x00,0x5F,0x2A,0x69,0x20,0x02,0xCD,0x0B,0x2A,0x19,0xD3,0x23,0x1C,0x6E,
+0x13,0x57,0x01,0x13,0x37,0x02,0x4E,0xFA,0x40,0x46,0xF7,0xCD,0xCB,0x20,0x14,0x00,
+0xC2,0xE2,0x80,0x0A,0x4A,0xF7,0xC8,0x8E,0xF8,0x0E,0xEA,0x1C,0xFE,0xE0,0x08,0x00,
+0xEE,0xEA,0x00,0xA1,0xE4,0x00,0x00,0x1D,0xE4,0x00,0x07,0xEE,0x98,0x61,0xE4,0x00,
+0x08,0x22,0xE4,0x00,0x8B,0xA2,0x5C,0x63,0x00,0x20,0x63,0xBC,0xEC,0x0A,0x00,0xA3,
+0xE4,0x00,0x8C,0xAA,0xE4,0x00,0x8C,0x3C,0xEB,0x0A,0x00,0xA3,0xEA,0xEA,0x00,0xA1,
+0xD7,0x17,0x01,0x26,0xEA,0xEA,0x00,0xA3,0xEA,0xEA,0x00,0xA1,0xE4,0x00,0x8C,0x32,
+0xE4,0x00,0x8C,0x9E,0xE4,0x00,0x8C,0x62,0xEC,0x0A,0x00,0xA3,0xEC,0x0A,0x00,0xA1,
+0xE4,0x00,0x06,0x33,0xE4,0x00,0x8B,0x90,0x5C,0x63,0x00,0x20,0x63,0x66,0xE4,0x00,
+0x8A,0xE4,0x5C,0x63,0x00,0x20,0x63,0x0C,0xEA,0xEA,0x00,0xA3,0x0F,0x0A,0x1E,0x8E,
+0xF8,0x10,0x77,0x00,0xE4,0x00,0x8A,0x5E,0xEA,0xEA,0x00,0xA3,0x9E,0xE1,0x5E,0xF7,
+0x04,0xEE,0xEA,0x00,0xA3,0xE7,0xFF,0xFF,0x47,0x13,0x17,0x00,0x5F,0x0B,0x01,0x20,
+0x00,0x31,0x13,0x17,0x00,0x5F,0x0B,0x29,0x20,0x04,0xB5,0x0B,0x0A,0x19,0x23,0x0C,
+0xB6,0xC3,0x00,0x10,0x01,0x9B,0x21,0xEF,0x38,0x06,0x4C,0x13,0x17,0x01,0x12,0xF7,
+0x02,0x4F,0x18,0x40,0x47,0x18,0xBD,0xC2,0xE0,0x10,0x01,0xEF,0x17,0x0D,0x54,0xC2,
+0xE0,0x10,0x01,0xEC,0x17,0x0D,0x74,0xE4,0x00,0x02,0xD9,0x0B,0x0A,0x19,0xD3,0x04,
+0x0B,0x2E,0xC3,0x00,0x10,0x01,0xEF,0x18,0x06,0xCA,0x23,0x00,0x68,0xEB,0x2A,0x00,
+0xA5,0xEB,0x0A,0x00,0xA7,0x43,0x19,0xC5,0xD3,0x0A,0x00,0x60,0xF3,0x0A,0x00,0xA8,
+0xF8,0x0A,0x00,0xA8,0x11,0xD7,0x01,0xC1,0xA0,0x10,0x01,0x13,0x57,0x02,0xFD,0x6D,
+0x06,0xCC,0x13,0x17,0x03,0x4E,0xEE,0x08,0x43,0x2B,0xBC,0x9E,0xE1,0x1B,0x59,0x00,
+0x8E,0xEB,0x1B,0x17,0x00,0xC2,0xE0,0x10,0x01,0x99,0x81,0xED,0x97,0x06,0xC8,0xE4,
+0x00,0x06,0x08,0xEC,0x6A,0x00,0xA7,0xF2,0xEA,0x00,0xA8,0x4D,0xCC,0x74,0x45,0xCE,
+0xBD,0x5D,0xCE,0x00,0xF9,0xCA,0x00,0xA8,0xF2,0xEA,0x00,0xA8,0x56,0xF7,0x01,0xD2,
+0xE0,0x07,0xA2,0xF2,0xEA,0x00,0xA8,0x56,0xF7,0x02,0xD2,0xE0,0x07,0x4A,0xF2,0xEA,
+0x00,0xA8,0x56,0xF7,0x04,0xD2,0xE0,0x06,0xF2,0xF2,0xEA,0x00,0xA8,0x56,0xF7,0x08,
+0xD2,0xE0,0x06,0x9A,0xF3,0x4D,0x06,0xCC,0x13,0x0B,0x01,0x12,0xEB,0x02,0x4E,0xF7,
+0x40,0x13,0x2B,0x03,0x4F,0x5A,0xC0,0x4F,0x18,0x80,0x47,0x1A,0xC5,0x47,0x18,0xCD,
+0x47,0x18,0xBD,0xC2,0xE0,0x10,0x01,0xEF,0x17,0x0D,0x74,0x13,0x4B,0x04,0x13,0x0B,
+0x05,0x12,0xEB,0x06,0x4E,0xF7,0x40,0x13,0x2B,0x07,0x4F,0x5A,0xC0,0x4F,0x18,0x80,
+0x47,0x1A,0xC5,0x47,0x18,0xCD,0x47,0x18,0xBD,0xC2,0xE0,0x10,0x01,0xEF,0x17,0x0D,
+0x54,0xF2,0xEA,0x00,0xA8,0xF8,0x0A,0x00,0xA8,0xC2,0xE0,0x10,0x01,0xED,0x97,0x06,
+0x4C,0xE4,0x00,0x00,0xE5,0x13,0x17,0x00,0x5F,0x04,0x09,0x20,0x00,0x99,0x0B,0x0A,
+0x19,0x23,0x0D,0x8A,0x13,0x37,0x01,0x13,0x17,0x02,0x4E,0xF9,0x40,0x46,0xF7,0xC5,
+0xC2,0xEB,0x54,0xA4,0x20,0x01,0x3D,0x12,0xEC,0x00,0x52,0xF7,0x03,0xE4,0x00,0x00,
+0x87,0x13,0x17,0x00,0x5F,0x04,0x29,0x20,0x05,0xC9,0x0B,0x0A,0x19,0x23,0x0C,0xDA,
+0x13,0x37,0x01,0x13,0x17,0x02,0x4E,0xF9,0x40,0x46,0xF7,0xC5,0xC3,0x00,0x10,0x01,
+0xEE,0xF8,0x00,0xBC,0x12,0xEC,0x00,0x57,0x37,0x01,0x23,0x20,0x64,0xEF,0x18,0x00,
+0xBE,0x23,0x00,0x32,0x9B,0x1B,0x46,0xF7,0xC4,0xE4,0x00,0x00,0x0F,0x52,0xF7,0x04,
+0x1A,0xEC,0x00,0x0C,0x0A,0x00,0x0C,0x0A,0x19,0xE4,0x00,0x02,0x61,0xE4,0x00,0x87,
+0x4C,0x5C,0x63,0x00,0xD0,0x60,0x09,0x2A,0xE4,0x00,0x88,0x8E,0xE4,0x00,0x88,0x52,
+0x50,0x60,0x20,0xE4,0x00,0x03,0x38,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x3D,0xF9,0x13,
+0x17,0x00,0xC2,0xE0,0x10,0x01,0xFD,0x77,0x00,0xB0,0x1B,0x0B,0x00,0x13,0x0B,0x00,
+0x23,0x00,0x42,0xC2,0xE0,0x10,0x01,0x99,0xA6,0xEE,0xF7,0x00,0xD2,0x22,0xE8,0xD8,
+0x12,0xEB,0x00,0x22,0xE0,0x4E,0x12,0xEC,0x00,0x56,0xF7,0x01,0x5E,0xE0,0x09,0x49,
+0xA4,0x43,0xE4,0x00,0x00,0x43,0x12,0xEB,0x00,0x22,0xE4,0x2A,0x51,0xA0,0x80,0xE4,
+0x00,0x00,0x29,0x12,0xEB,0x00,0x22,0xEB,0xD8,0x12,0xEB,0x00,0x22,0xEF,0xC0,0xC9,
+0xA0,0xFF,0xFF,0xEE,0xEA,0x00,0xAE,0x22,0xE4,0x2E,0xED,0xAA,0x00,0xA1,0xEC,0x0A,
+0x00,0xAC,0xE4,0x00,0x87,0x66,0xEA,0xEA,0x00,0xA1,0xD5,0xB7,0x03,0xF5,0xC2,0xE0,
+0x10,0x01,0xF3,0x17,0x0D,0x59,0x23,0x00,0x24,0x9F,0x1F,0xFB,0x17,0x0D,0x59,0xEC,
+0x0A,0x00,0xA3,0xE9,0x8A,0x00,0xA1,0xE4,0x00,0x00,0x73,0x12,0xEB,0x00,0x22,0xE0,
+0x92,0xEA,0xEA,0x00,0xA3,0x0F,0x0A,0x1E,0x8E,0xF8,0x10,0x77,0x00,0xE4,0x00,0x85,
+0x4C,0xEA,0xEA,0x00,0xA3,0x9E,0xE1,0x5E,0xF7,0x04,0xEE,0xEA,0x00,0xA3,0xE4,0x00,
+0x00,0x25,0xE4,0x00,0x85,0x56,0x5C,0x63,0x00,0x20,0x63,0xE4,0xE7,0xFF,0xFF,0xAB,
+0xEA,0xEA,0x00,0xA3,0xD6,0xEC,0xFE,0x3E,0xE4,0x00,0x86,0xCE,0xE4,0x00,0x86,0x92,
+0xEC,0x0A,0x00,0xA1,0xEC,0x0A,0x00,0xA3,0xE4,0x00,0x00,0x45,0x98,0x60,0x9D,0x61,
+0xE4,0x00,0x84,0xC6,0xE4,0x00,0x00,0x0D,0x99,0x60,0xD5,0xAB,0xFF,0x95,0xE4,0x00,
+0x86,0x82,0xE4,0x00,0x86,0x46,0xEC,0x0A,0x00,0xA1,0xC2,0xE0,0x10,0x01,0xEB,0x17,
+0x00,0xC9,0x53,0x18,0x02,0xEF,0x17,0x00,0xC9,0x0D,0xC1,0x02,0x0D,0xA1,0x06,0x0D,
+0x81,0x0A,0x0D,0x61,0x0E,0x0D,0x41,0x12,0x0D,0x21,0x16,0x1C,0x21,0x18,0x85,0x29,
+0x9C,0x38,0x0D,0x21,0x04,0xE4,0x00,0x8D,0x42,0x98,0x60,0x88,0x83,0xE4,0x00,0x8A,
+0x74,0x98,0x61,0x98,0x82,0xE4,0x00,0x8A,0x64,0x98,0x60,0xFC,0x80,0x28,0x0A,0xE4,
+0x00,0x86,0x50,0x98,0x61,0xFC,0x80,0x28,0x0A,0xE4,0x00,0x87,0xB6,0x0D,0x21,0x06,
+0x9C,0x28,0xE4,0x00,0x90,0x0D,0x20,0x64,0x1E,0xE4,0x00,0x91,0x37,0xE4,0x00,0x91,
+0x55,0x9C,0x38,0x0D,0x21,0x04,0xE4,0x00,0x91,0x6A,0x0D,0x21,0x06,0x9C,0x28,0xE4,
+0x00,0x91,0x31,0xE4,0x00,0x93,0x29,0xE4,0x00,0x92,0xBF,0xE4,0x00,0x93,0x89,0xE4,
+0x00,0x93,0xE5,0xE4,0x00,0x97,0xC3,0xE4,0x00,0x95,0x2D,0xE4,0x00,0x94,0x31,0xE4,
+0x00,0x94,0x67,0xE4,0x00,0x94,0x9D,0xE4,0x00,0x94,0xC1,0xE4,0x00,0x94,0xE5,0xE4,
+0x00,0x93,0x1B,0xE4,0x00,0x95,0x13,0x20,0x60,0x28,0x20,0x64,0x3E,0xE4,0x00,0x00,
+0x11,0xE4,0x00,0x95,0xAF,0xE4,0x00,0x95,0xC9,0x85,0x29,0xE4,0x00,0x98,0xC1,0xE4,
+0x00,0x95,0xD7,0xC2,0xE0,0x10,0x01,0xE8,0x77,0x00,0xB3,0xEB,0x17,0x00,0xB3,0xD4,
+0x78,0xFF,0xC6,0x85,0x29,0x9C,0x30,0x0D,0x41,0x08,0x0D,0x61,0x04,0x0D,0x21,0x0C,
+0x5D,0x43,0x04,0xE7,0xFF,0xFF,0xC0,0xC2,0xE0,0x10,0x01,0xFF,0x17,0x00,0xD6,0x89,
+0x77,0x0C,0x78,0x03,0xE7,0xFF,0xFF,0x9E,0xFF,0x0B,0x00,0xD6,0x0B,0x18,0x03,0x40,
+0x63,0xC5,0x5F,0x03,0x04,0xD5,0x58,0xFF,0x7D,0x0D,0x61,0x06,0x0D,0x41,0x0A,0x0D,
+0x21,0x0E,0x1C,0x21,0x10,0x85,0x29,0xE4,0x00,0x98,0xDD,0xC3,0x34,0x00,0x01,0xCA,
+0xF9,0x23,0xFC,0x0A,0xF7,0x00,0xD2,0xFF,0x04,0x3C,0xC3,0x00,0x10,0x01,0xF2,0xF8,
+0x06,0xD4,0x9E,0xE1,0x5E,0xF7,0x00,0xFA,0xF8,0x06,0xD4,0x22,0xE1,0xCA,0xC3,0x00,
+0x10,0x01,0xC3,0x60,0x10,0x01,0xFF,0x18,0x03,0x2A,0xCA,0xE0,0x11,0x7D,0xCB,0x39,
+0x22,0x00,0xFF,0x7B,0x0D,0x04,0x1F,0x57,0xFD,0x57,0x5A,0xFF,0x4F,0x5A,0x10,0x8F,
+0x59,0x0B,0x9A,0x01,0x4F,0x97,0x08,0x8F,0x9B,0xEB,0x9C,0xDD,0x47,0x0F,0x9A,0x01,
+0x5F,0x57,0x00,0x5F,0x4F,0xE9,0x57,0x57,0xFF,0x4F,0x5A,0x10,0x8F,0x59,0x0B,0x9A,
+0x01,0x20,0x00,0x6D,0xFF,0xA0,0x80,0x00,0x5F,0x9C,0x04,0x47,0x9C,0xEC,0x0B,0xB8,
+0x01,0xC7,0xBD,0x7F,0xFF,0x47,0x9C,0xED,0xE4,0x00,0x00,0x0F,0x0B,0x98,0x01,0x0F,
+0x9A,0x01,0x9E,0xE1,0x9F,0x02,0xC2,0xE2,0x30,0x04,0x23,0xFE,0xB1,0x85,0x29,0x5C,
+0x63,0x04,0xE4,0x00,0x97,0xAF,0x9A,0xE0,0x8B,0x17,0xE4,0x00,0x00,0x1D,0x43,0x23,
+0xBC,0x9E,0xE1,0x13,0x39,0x00,0x8F,0x19,0xD4,0x97,0xFF,0xB4,0x40,0x60,0xC5,0x85,
+0x29,0x9C,0x38,0x98,0x60,0x0D,0x21,0x04,0xE7,0xFF,0xFC,0xFC,0x98,0x61,0xE7,0xFF,
+0xFC,0xF0,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x00,0xD2,0x22,0xE8,0x3A,0x50,0x60,0xC8,
+0xE7,0xFF,0xFD,0xCA,0xE4,0x00,0x00,0x15,0x98,0x6F,0xE7,0xFF,0xFD,0x8A,0x0D,0x21,
+0x06,0x98,0x60,0x9C,0x28,0xE7,0xFF,0xFC,0xA3,0x9C,0x38,0xC2,0xE0,0x10,0x01,0x0D,
+0x21,0x04,0xEC,0x17,0x0D,0x61,0x0D,0x41,0x00,0xC2,0xE0,0x10,0x01,0xF3,0x17,0x00,
+0xB0,0x23,0x00,0x42,0xC3,0x00,0x10,0x01,0x98,0x66,0xEF,0x18,0x00,0xD2,0x23,0x08,
+0x78,0xF2,0xF7,0x00,0xB0,0x50,0x60,0x80,0x22,0xE0,0x52,0xC2,0xE0,0x10,0x01,0xF2,
+0xF7,0x00,0xB8,0x56,0xF7,0x01,0x5E,0xE0,0x09,0x48,0x64,0x43,0xC1,0x40,0x10,0x01,
+0xEA,0xEA,0x00,0xC9,0x56,0xF7,0x02,0x22,0xE0,0x6C,0xC0,0x80,0x10,0x01,0xFC,0x84,
+0x06,0xD5,0xE7,0xFF,0xF0,0xF0,0xEA,0xEA,0x00,0xC9,0xC6,0xF7,0xFF,0xFD,0xEE,0xEA,
+0x00,0xC9,0x0D,0x41,0x02,0x0D,0x21,0x06,0x9C,0x28,0xE7,0xFF,0xFE,0xAF,0xC2,0xF4,
+0x00,0x01,0xCB,0x17,0x3D,0xF9,0x1C,0x21,0xE0,0xCA,0xF7,0x3D,0xF8,0x0D,0x41,0x18,
+0x0D,0x61,0x14,0x0D,0x81,0x10,0x0D,0xA1,0x0C,0x0D,0xC1,0x08,0x0D,0xE1,0x04,0x0E,
+0x01,0x00,0x0D,0x21,0x1C,0xC1,0x60,0x10,0x01,0xFD,0x6B,0x08,0x24,0x0A,0x0B,0x01,
+0xC6,0x10,0x7F,0xFF,0x0E,0x0B,0x01,0x13,0x38,0x00,0xC3,0x00,0x10,0x01,0xFB,0x38,
+0x00,0xB0,0x13,0x37,0x00,0xC2,0xE0,0x10,0x01,0xFB,0x37,0x07,0x57,0xC1,0xC0,0x10,
+0x01,0xC1,0xA0,0x10,0x01,0xC3,0x40,0x10,0x01,0xC3,0x20,0x10,0x01,0x5D,0x83,0x00,
+0xFD,0xCE,0x0D,0x04,0xFD,0xAD,0x07,0x58,0xFD,0xE0,0x80,0x00,0xFD,0x5A,0x06,0xD5,
+0xFE,0xF9,0x0C,0x08,0xD1,0x81,0x12,0x76,0x0B,0xB7,0x19,0x45,0xF0,0x7D,0xCB,0x00,
+0x07,0xFF,0x0D,0xEB,0x01,0x43,0xB8,0xED,0x5F,0xBD,0x04,0x5F,0x7D,0x06,0x0F,0x77,
+0x19,0x13,0x57,0x00,0xD3,0x41,0x1D,0xB9,0x0B,0x77,0x49,0x43,0x18,0xDD,0x0F,0x17,
+0x49,0x0B,0x17,0x1D,0x43,0x00,0xC5,0x0F,0x17,0x1D,0x0B,0x17,0x46,0x0B,0x77,0x16,
+0x5F,0x1B,0x15,0x4B,0xA1,0x01,0xCF,0x1D,0x00,0x30,0x8F,0x17,0x4B,0x80,0x0A,0x0B,
+0x78,0x16,0x9B,0x00,0x27,0x7C,0x50,0xC3,0x00,0x10,0x01,0x5F,0xDB,0x04,0xEB,0x18,
+0x0A,0xEB,0x5F,0x78,0x15,0x4B,0x1E,0xC0,0x0F,0x17,0x13,0xCF,0xBD,0x00,0x30,0x9B,
+0x00,0x8F,0xB7,0x0B,0x7D,0x18,0x27,0x7C,0x50,0xC3,0x00,0x10,0x01,0x5F,0xBB,0x04,
+0xEB,0x18,0x0A,0xED,0x5F,0x78,0x15,0x4B,0x1D,0xC0,0x0F,0x17,0x15,0xCF,0x1C,0x00,
+0x30,0x8F,0x17,0x0B,0x78,0x16,0x9B,0x00,0x27,0x7C,0x50,0xC3,0x00,0x10,0x01,0x5F,
+0x3B,0x04,0xEB,0x18,0x0A,0xEB,0x5F,0x78,0x15,0x4B,0x19,0xC0,0x0F,0x17,0x43,0xCF,
+0x9C,0x00,0x30,0x9B,0x00,0x8F,0x97,0x0B,0x3C,0x18,0x27,0x3C,0x50,0xC3,0x00,0x10,
+0x01,0x5F,0x79,0x04,0xEB,0x18,0x0A,0xED,0x5F,0x38,0x15,0x4B,0x1B,0xC0,0x0B,0x77,
+0x43,0x0B,0x37,0x13,0x43,0x3B,0xCD,0x0F,0x17,0x45,0x0F,0x37,0x1B,0x0B,0x37,0x15,
+0x43,0x18,0xCD,0x0F,0x17,0x1D,0xE4,0x00,0x00,0x69,0xC3,0x00,0x10,0x01,0x5F,0xDC,
+0x04,0xEB,0x18,0x0A,0xEB,0x5F,0x98,0x15,0x4B,0x1E,0xC0,0x0F,0x17,0x13,0x9B,0x00,
+0x27,0x7C,0x44,0xC3,0x00,0x10,0x01,0xEB,0x18,0x0A,0xED,0x5F,0x78,0x1D,0x4B,0x18,
+0xE8,0x0F,0x17,0x15,0x0C,0x17,0x1B,0x0C,0x17,0x1D,0xC3,0x00,0x10,0x01,0xF3,0x18,
+0x00,0xB0,0x23,0x01,0x9E,0x53,0x00,0x52,0x0B,0x37,0x13,0x1B,0x0A,0x00,0x4F,0x99,
+0x41,0x0B,0x17,0x15,0x4F,0x9C,0x20,0x4F,0x78,0x41,0x1B,0x2A,0x02,0x57,0x7B,0x0F,
+0x1B,0x0A,0x03,0x47,0x7C,0xDD,0x1B,0x6A,0x01,0x27,0x44,0xA1,0x0B,0x17,0x1A,0x0A,
+0xF7,0x1C,0x4F,0x38,0x42,0x4F,0x57,0x42,0x5F,0x39,0x04,0x57,0x5A,0x0F,0x4F,0x39,
+0x20,0x1B,0x0A,0x05,0x47,0x39,0xD5,0x1A,0xEA,0x06,0x1B,0x2A,0x04,0xE4,0x00,0x00,
+0x1B,0x18,0x0A,0x04,0x18,0x0A,0x05,0x18,0x0A,0x06,0x88,0x6A,0x98,0x87,0xE7,0xFF,
+0xFA,0x90,0x18,0x6A,0x07,0xE4,0x00,0x01,0x81,0x8B,0x0A,0x18,0x18,0x00,0xC3,0x20,
+0x10,0x01,0x9F,0x01,0xFF,0x39,0x07,0x57,0xD7,0x19,0xFF,0x9E,0x53,0x00,0x62,0x1B,
+0x0A,0x00,0x0B,0x17,0x13,0x4F,0x38,0x41,0x1B,0x0A,0x02,0x0B,0x17,0x15,0x1B,0x2A,
+0x01,0x1B,0x0A,0x04,0x4F,0x38,0x41,0x57,0x1A,0x01,0x53,0x18,0x20,0x1B,0x0A,0x11,
+0x0B,0x17,0x1A,0x1B,0x2A,0x03,0x0A,0xF7,0x1C,0x4F,0x38,0x42,0x1B,0x0A,0x0E,0x4F,
+0x5A,0x20,0x4F,0x17,0x42,0x53,0x5A,0x02,0x1B,0x0A,0x0F,0x1B,0x4A,0x12,0x1A,0xEA,
+0x10,0x1B,0x2A,0x0D,0x88,0x6A,0x50,0x80,0x1F,0xE7,0xFF,0xF9,0xBA,0xC3,0x00,0x10,
+0x01,0x18,0x6A,0x1F,0xC3,0x60,0x10,0x01,0x1D,0x4A,0x20,0xFF,0x18,0x09,0xCC,0x9A,
+0xE0,0xC3,0x40,0x10,0x01,0xFF,0x7B,0x0B,0x36,0xF3,0x3A,0x07,0x57,0x23,0x24,0x34,
+0x23,0x28,0x68,0x43,0x37,0x74,0xE4,0x00,0x00,0x0F,0x43,0x37,0xDC,0x17,0x99,0x01,
+0x1B,0x8A,0x00,0x0B,0x39,0x01,0xE4,0x00,0x00,0x21,0x0F,0x38,0x02,0x4F,0x99,0x82,
+0x4F,0x39,0x42,0x1B,0x8A,0x00,0x1B,0x2A,0x01,0x9E,0xE2,0x9D,0x42,0x9F,0x04,0x5E,
+0xE8,0xC9,0x23,0xFF,0x1D,0x0A,0xEB,0x00,0xD2,0xFF,0x0D,0x04,0x9A,0xE1,0xE4,0x00,
+0x02,0x99,0x21,0x81,0xFA,0xF2,0xF8,0x00,0xB0,0x22,0xE0,0xB2,0x52,0xE0,0x52,0x1A,
+0xEA,0x00,0x9A,0xFF,0x88,0x6A,0x1A,0xEA,0x01,0x1A,0xEA,0x02,0x1A,0xEA,0x03,0x1A,
+0xEA,0x04,0x1A,0xEA,0x05,0x1A,0xEA,0x06,0x98,0x87,0xE7,0xFF,0xF8,0x98,0x18,0x6A,
+0x07,0xE4,0x00,0x00,0x7F,0x8A,0xEA,0x18,0x17,0x00,0xC3,0x00,0x10,0x01,0x9E,0xE1,
+0xFF,0x18,0x07,0x57,0xD6,0xF8,0xFF,0x9E,0x52,0xE0,0x62,0x9B,0x1F,0x1A,0xEA,0x00,
+0x1E,0xEA,0x01,0x1B,0x17,0x00,0xC3,0x20,0x10,0x01,0x9E,0xE1,0xFF,0x39,0x06,0xF4,
+0xD6,0xF9,0xFF,0x9E,0x88,0x6A,0x50,0x80,0x1F,0xE7,0xFF,0xF8,0x1A,0x18,0x6A,0x1F,
+0x0A,0xEB,0x01,0x0C,0x0D,0x00,0x45,0xEF,0xBD,0x0D,0xEB,0x01,0xE4,0x00,0x02,0x39,
+0xD1,0x82,0x06,0x8E,0xF3,0x18,0x00,0xB0,0x23,0x00,0xD2,0x52,0xE0,0x52,0xC3,0x00,
+0x10,0x01,0x1A,0xEA,0x00,0xEB,0x18,0x0D,0x61,0x9A,0xFF,0x1B,0x0A,0x05,0x1A,0xEA,
+0x01,0x1A,0xEA,0x02,0x1A,0xEA,0x03,0x1A,0xEA,0x04,0x1A,0xEA,0x06,0x88,0x6A,0x98,
+0x87,0xE7,0xFF,0xF7,0x8A,0x18,0x6A,0x07,0xE4,0x00,0x01,0x15,0x8B,0x0A,0x18,0x18,
+0x00,0xC3,0x20,0x10,0x01,0x9F,0x01,0xFF,0x39,0x07,0x57,0xD7,0x19,0xFF,0x9E,0x53,
+0x00,0x62,0x1B,0x0A,0x00,0x0B,0x17,0x13,0x4F,0x38,0x41,0x1B,0x0A,0x02,0x1B,0x2A,
+0x01,0x0B,0x17,0x15,0x4F,0x38,0x41,0x1B,0x0A,0x04,0x1B,0x2A,0x03,0x13,0x17,0x00,
+0x57,0x38,0x01,0x4F,0x18,0x20,0x53,0x18,0x02,0x53,0x39,0x20,0x1B,0x0A,0x12,0x0B,
+0x17,0x1A,0x1B,0x2A,0x11,0x0A,0xF7,0x1C,0x4F,0x38,0x42,0x1B,0x0A,0x0E,0x4F,0x17,
+0x42,0x1A,0xEA,0x10,0x1B,0x2A,0x0D,0x1B,0x0A,0x0F,0x88,0x6A,0x50,0x80,0x1F,0xE7,
+0xFF,0xF6,0xAE,0x9A,0xE0,0x18,0x6A,0x1F,0x43,0x17,0x74,0x0B,0x38,0x00,0x43,0x0A,
+0xBC,0x4F,0x59,0x42,0x1B,0x38,0x21,0x1B,0x58,0x20,0x9E,0xE2,0x5E,0xE8,0xC9,0x23,
+0xFF,0xA5,0x45,0xF0,0x7D,0x9A,0xE2,0x0D,0xEB,0x01,0x0E,0xED,0x00,0xE4,0x00,0x00,
+0x97,0x21,0x8D,0x1E,0x1E,0xE0,0xA7,0x1A,0xEA,0x00,0x9A,0xE6,0x1A,0xEA,0x02,0x52,
+0xE0,0x50,0x1A,0xEA,0x03,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x0D,0x61,0x45,0xF0,0x7D,
+0x18,0x0A,0x01,0x0D,0xEB,0x01,0x1A,0xEA,0x04,0x88,0x6A,0x98,0x85,0xE7,0xFF,0xF5,
+0xF2,0x0D,0x8D,0x00,0x18,0x6A,0x05,0xE4,0x00,0x00,0x23,0x0B,0x97,0x16,0x9B,0x00,
+0xD3,0x9F,0xE8,0xD8,0xE7,0xFF,0xFA,0x0D,0x0E,0x01,0x02,0x0D,0xE1,0x06,0x0D,0xC1,
+0x0A,0x0D,0xA1,0x0E,0x0D,0x81,0x12,0x0D,0x61,0x16,0x0D,0x41,0x1A,0x0D,0x21,0x1E,
+0x1C,0x21,0x20,0x85,0x29,0x1C,0x21,0xD0,0x0D,0x41,0x28,0x0D,0x81,0x20,0x5D,0x43,
+0x00,0x5D,0x84,0x00,0x42,0xEC,0x55,0x9E,0xE1,0x5E,0xF7,0x00,0x57,0x17,0x03,0x4E,
+0xF7,0x11,0x5F,0x00,0x09,0x0D,0x61,0x24,0x0D,0xA1,0x1C,0x0D,0xC1,0x18,0x49,0xA1,
+0x01,0x0D,0x21,0x2C,0x8D,0xB7,0xC1,0xD8,0x00,0x21,0xE4,0x00,0x5F,0xDE,0x99,0x60,
+0xFD,0xCE,0xBA,0xAF,0xE4,0x00,0x00,0xE3,0x88,0x61,0x50,0x80,0x22,0x50,0xA0,0x18,
+0xE7,0xFF,0xC1,0x94,0x9A,0xE4,0x43,0x0E,0x54,0x13,0x58,0x00,0x1F,0x01,0x18,0x4F,
+0x3A,0x09,0x57,0x5A,0x01,0x8F,0x19,0x17,0x18,0xE8,0x5F,0x40,0x01,0x4B,0x50,0x7B,
+0x47,0x5A,0xC4,0x5F,0x17,0x02,0x20,0x00,0x25,0x4F,0x17,0x20,0x5F,0x18,0x02,0x1F,
+0x61,0x18,0x47,0x18,0xD5,0x8F,0x3B,0x1B,0x19,0xE8,0x9D,0x41,0x5D,0x4A,0x00,0xD5,
+0x4C,0x00,0xE1,0x06,0xE0,0x81,0xCC,0x6B,0x00,0x18,0x88,0x81,0x8C,0x77,0x50,0xA0,
+0x18,0x9D,0x61,0xE7,0xFF,0xC1,0xCE,0xE4,0x00,0x00,0x1D,0x9E,0xE1,0xD2,0xE8,0xFD,
+0x4E,0xE7,0xFF,0xFF,0xC5,0x5E,0xEB,0x00,0xD5,0xB7,0xFC,0x85,0xE4,0x00,0x5F,0x00,
+0x0D,0x21,0x2E,0x0D,0xC1,0x1A,0x0D,0xA1,0x1E,0x0D,0x81,0x22,0x0D,0x61,0x26,0x0D,
+0x41,0x2A,0x1C,0x21,0x30,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x03,0x26,0x85,
+0x29,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x07,0xBA,0x85,0x29,0x1C,0x21,0xD0,0x0D,0x21,
+0x2C,0x0D,0x41,0x28,0x0D,0x61,0x24,0xD0,0x69,0x0C,0x35,0x4F,0x03,0x10,0xC2,0xF8,
+0x00,0x21,0xC1,0x58,0x00,0x21,0xFE,0xF7,0xBA,0x48,0xFD,0x4A,0xBA,0xAF,0x8E,0xF8,
+0x0E,0xF7,0x02,0x86,0xE9,0x4C,0x83,0x20,0x88,0x64,0x9C,0x8F,0xE7,0xFF,0xFD,0xD2,
+0xE4,0x00,0x02,0xBB,0x0C,0x61,0x04,0xE4,0x00,0x5E,0x04,0x0C,0x61,0x06,0x1D,0x63,
+0xFE,0x5D,0x6B,0x00,0x4D,0x6B,0x20,0x8D,0x6A,0x05,0x40,0x81,0x1C,0x61,0x08,0x50,
+0x80,0x22,0x50,0xA0,0x18,0xE7,0xFF,0xBF,0xAA,0x9A,0xE4,0x43,0x0B,0xBC,0x13,0x58,
+0xFC,0x1F,0x01,0x20,0x4F,0x3A,0x09,0x57,0x5A,0x01,0x8F,0x19,0x13,0x18,0xE8,0x5F,
+0x40,0x01,0x4B,0x50,0x7B,0x47,0x5A,0xC4,0x5F,0x17,0x02,0x5F,0x5A,0x02,0x20,0x00,
+0x25,0x4F,0x17,0x20,0x5F,0x18,0x02,0x1F,0x61,0x20,0x47,0x18,0xD5,0x8F,0x3B,0x1B,
+0x19,0xE8,0x9E,0xE1,0xD2,0xE8,0xFE,0x3E,0x88,0x6A,0x1C,0x81,0x08,0x50,0xA0,0x18,
+0xE7,0xFF,0xBF,0xF4,0x07,0x80,0x81,0x1D,0x4A,0x18,0x9D,0x64,0x53,0x9C,0x60,0xD5,
+0x5C,0xFC,0xEE,0xE4,0x00,0x01,0xAD,0xE4,0x00,0x5D,0x04,0x1C,0x61,0x08,0x50,0x80,
+0x22,0x50,0xA0,0x18,0xE7,0xFF,0xBE,0xCC,0xC3,0x78,0x00,0x21,0x9A,0xE4,0xFF,0x7B,
+0xBA,0xAC,0xD2,0xE7,0x01,0xC2,0x43,0x1B,0xBC,0x13,0x58,0xFC,0x1F,0x01,0x20,0x4F,
+0x3A,0x09,0x57,0x5A,0x01,0x8F,0x19,0x17,0x18,0xE8,0x5F,0x40,0x01,0x4B,0x50,0x7B,
+0x47,0x5A,0xC4,0x5F,0x17,0x02,0x20,0x00,0x25,0x4F,0x17,0x20,0x5F,0x18,0x02,0x1F,
+0x81,0x20,0x47,0x18,0xD5,0x8F,0x3C,0x1B,0x19,0xE8,0x9E,0xE1,0xD2,0xE8,0xFE,0x36,
+0xE4,0x00,0x00,0xD9,0xE4,0x00,0x5C,0x4A,0x1C,0x61,0x08,0x50,0x80,0x22,0x50,0xA0,
+0x18,0xE7,0xFF,0xBE,0x12,0x8B,0x0A,0xE4,0x00,0x00,0x9F,0x43,0x38,0xBC,0x13,0x79,
+0xFC,0x1F,0x21,0x20,0x4F,0x5B,0x09,0x57,0x7B,0x01,0x8F,0x3A,0x13,0x39,0xE8,0x5F,
+0x60,0x01,0x4B,0x70,0x7B,0x47,0x7B,0xCC,0x5F,0x37,0x02,0x5F,0x7B,0x02,0x20,0x00,
+0x25,0x4F,0x37,0x20,0x5F,0x39,0x02,0x1F,0x81,0x20,0x47,0x39,0xDD,0x8F,0x5C,0x1B,
+0x3A,0xE8,0x9E,0xE1,0xD2,0xE8,0xFE,0x3E,0xC2,0xF8,0x00,0x21,0x9F,0x04,0xFE,0xF7,
+0xBA,0xCF,0xD7,0x17,0x00,0x52,0x9A,0xE4,0xE7,0xFF,0xFF,0x67,0x04,0x60,0x81,0x1C,
+0x81,0x08,0x50,0xA0,0x18,0xE7,0xFF,0xBE,0x2A,0xE4,0x00,0x5B,0x86,0x0D,0x61,0x26,
+0x0D,0x41,0x2A,0x0D,0x21,0x2E,0x1C,0x21,0x30,0x85,0x29,0x1C,0x21,0xE8,0x0D,0x21,
+0x14,0x0D,0x41,0x10,0x0D,0x61,0x0C,0x0D,0x81,0x08,0x0D,0xA1,0x04,0xD0,0x67,0x03,
+0x32,0xD0,0x67,0x00,0x65,0xD0,0x61,0x08,0x15,0xE4,0x00,0x00,0x19,0xD0,0x69,0x07,
+0xD6,0xE4,0x00,0x01,0x57,0x4C,0x63,0x20,0xC1,0x40,0x10,0x01,0x99,0x60,0xFD,0x4A,
+0x07,0xBC,0x8D,0x43,0x13,0x4A,0x01,0x13,0x2A,0x00,0x13,0x0A,0x03,0x12,0xEA,0x02,
+0x4C,0x9A,0xC0,0x4C,0xB8,0xC0,0x4F,0x5A,0x80,0x4F,0x18,0x80,0x8C,0x9A,0x8C,0xB8,
+0x8C,0x99,0x8C,0xB7,0x4F,0x39,0x40,0x4E,0xF7,0x40,0x88,0x6B,0x8C,0x99,0x8C,0xB7,
+0x9D,0x61,0xE4,0x00,0x5C,0xF2,0x5D,0x6B,0x00,0x9D,0x44,0xD1,0x64,0xFE,0x4E,0xE4,
+0x00,0x01,0x51,0xC1,0xA0,0x10,0x01,0x99,0x40,0xFD,0xAD,0x07,0x64,0x5D,0x8A,0x00,
+0x41,0x6D,0x54,0x98,0x60,0x88,0x8C,0x98,0xA0,0x10,0xCB,0x00,0xE4,0x00,0x5D,0x06,
+0x98,0x60,0x88,0x8C,0x98,0xA1,0x10,0xCB,0x00,0x9D,0x41,0xE4,0x00,0x5C,0xE8,0x21,
+0x4F,0x7A,0x98,0x60,0x98,0x83,0x98,0xA0,0x98,0xC0,0xE4,0x00,0x5C,0xCA,0x0D,0x21,
+0x16,0x0D,0xA1,0x06,0x0D,0x81,0x0A,0x0D,0x61,0x0E,0x0D,0x41,0x12,0x98,0x60,0x98,
+0x83,0x98,0xA1,0x98,0xC0,0x1C,0x21,0x18,0xE4,0x00,0x5C,0x8F,0xC3,0x00,0x10,0x01,
+0x0D,0xA1,0x06,0xFE,0xF8,0x07,0xB0,0xF3,0x38,0x07,0xB0,0x13,0x57,0x01,0x13,0x17,
+0x03,0x4C,0x9A,0xC0,0x12,0xF7,0x02,0x4C,0xB8,0xC0,0x4F,0x5A,0x80,0x4F,0x18,0x80,
+0x8C,0x9A,0x8C,0xB8,0x8C,0x99,0x8C,0xB7,0x4F,0x39,0x40,0x4E,0xF7,0x40,0x0D,0x81,
+0x0A,0x0D,0x61,0x0E,0x0D,0x41,0x12,0x0D,0x21,0x16,0x98,0x60,0x8C,0x99,0x8C,0xB7,
+0x1C,0x21,0x18,0xE4,0x00,0x5B,0x91,0x0D,0xA1,0x06,0x0D,0x81,0x0A,0x0D,0x61,0x0E,
+0x0D,0x41,0x12,0x0D,0x21,0x16,0x1C,0x21,0x18,0x85,0x29,0x1C,0x21,0xE0,0x0D,0xC1,
+0x08,0x0D,0x21,0x1C,0x0D,0x41,0x18,0x0D,0x61,0x14,0x0D,0x81,0x10,0x0D,0xA1,0x0C,
+0x0D,0xE1,0x04,0x89,0xC4,0xD0,0x66,0x00,0xB5,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xBA,
+0x70,0x4C,0x63,0x10,0x8C,0x77,0x0E,0xE3,0x02,0x86,0xE9,0x99,0xE8,0xC9,0x80,0x28,
+0x0A,0xE4,0x00,0x01,0xC9,0xD0,0x81,0x04,0x41,0x1E,0xE4,0xFE,0xD2,0xE1,0x04,0x89,
+0x5C,0x80,0xE1,0xCA,0xE0,0x28,0x0A,0xC9,0x80,0x10,0x06,0x49,0xE1,0x43,0x49,0x8C,
+0xB8,0x99,0xA2,0x99,0x41,0x99,0x60,0x48,0x60,0x1A,0xE4,0x00,0x01,0x87,0xD0,0x81,
+0x04,0x09,0x1E,0xE4,0xFE,0xD2,0xE1,0x04,0x51,0x5C,0x80,0xE1,0xCA,0xE0,0x28,0x0A,
+0xC9,0x80,0x10,0x06,0x99,0xA0,0x49,0xE1,0x43,0x49,0x8C,0xB8,0x89,0x4D,0x99,0x60,
+0x48,0x61,0x1B,0xE4,0x00,0x01,0x35,0x24,0x85,0xE9,0x5C,0x80,0xE1,0xCA,0xE0,0x28,
+0x0A,0xC9,0x80,0x08,0x03,0x49,0xE1,0x43,0x49,0x8C,0xB8,0xE4,0x00,0x00,0xD9,0x24,
+0x85,0xC1,0x5C,0x80,0xE1,0xCA,0xE0,0x28,0x0A,0xC9,0x80,0x10,0x06,0x49,0xE1,0x43,
+0x49,0x8C,0xB8,0xE4,0x00,0x00,0xC5,0x99,0xE1,0xE4,0x00,0x00,0x95,0x99,0xE4,0xC9,
+0x80,0x28,0x0A,0x99,0xA2,0x99,0x41,0x99,0x60,0xE4,0x00,0x00,0x21,0x99,0xE4,0xC9,
+0x80,0x28,0x0A,0x99,0xA2,0x99,0x41,0x99,0x63,0x98,0x60,0xE4,0x00,0x00,0x85,0x99,
+0xA0,0x99,0xE4,0xC9,0x80,0x28,0x0A,0x89,0x4D,0x99,0x60,0xE4,0x00,0x00,0x21,0x99,
+0xA0,0x99,0xE4,0xC9,0x80,0x28,0x0A,0x89,0x4D,0x99,0x63,0x98,0x61,0xE4,0x00,0x00,
+0x41,0x99,0xE4,0xC9,0x80,0x08,0x03,0x99,0xA0,0x89,0x4D,0xE4,0x00,0x00,0x1D,0x99,
+0xE4,0xC9,0x80,0x10,0x06,0x99,0xA2,0x99,0x41,0x99,0x60,0x98,0x63,0xE7,0xFF,0x86,
+0x60,0x88,0x6A,0x88,0x8D,0xE4,0x00,0x73,0x24,0x88,0x6A,0x88,0x8C,0xE4,0x00,0x5A,
+0x44,0x21,0xA0,0x3E,0x88,0x6A,0x88,0x8C,0xE4,0x00,0x6E,0xFE,0xE4,0x00,0x00,0x1F,
+0x21,0xA0,0x2C,0x88,0x6A,0x88,0x8C,0xE4,0x00,0x70,0x5A,0x88,0x6A,0x05,0x80,0xFF,
+0xC9,0x8C,0xFF,0xFF,0x88,0x8C,0xE4,0x00,0x5C,0xCA,0x88,0x8C,0x88,0x6A,0xE4,0x00,
+0x5A,0x52,0x98,0x62,0xE4,0x00,0x57,0xD2,0xC2,0xE0,0x10,0x01,0x98,0x60,0xEC,0x17,
+0x07,0x5C,0xC1,0xA0,0x10,0x01,0xEC,0x0D,0x07,0xB4,0xE4,0x00,0x64,0x0E,0x98,0x60,
+0xE4,0x00,0x5C,0x0E,0x98,0x60,0x88,0x8C,0xE4,0x00,0x5A,0xFE,0x88,0x6F,0xE4,0x00,
+0x57,0x2A,0x98,0x60,0xE4,0x00,0x5D,0x4E,0x21,0x64,0x5E,0xED,0x6D,0x07,0xB4,0x98,
+0x61,0xE4,0x00,0x63,0xC0,0x98,0x63,0xE4,0x00,0x5B,0xC0,0xE4,0x00,0x00,0x2B,0x21,
+0x6C,0x46,0x98,0x61,0x88,0x8C,0xE4,0x00,0x5A,0xA2,0x98,0x61,0xE4,0x00,0x5C,0xFE,
+0xE4,0x00,0x60,0xE2,0x1C,0x63,0x13,0x5C,0x83,0x00,0x88,0x6A,0x5C,0x82,0x93,0x20,
+0x00,0x1B,0x50,0x80,0x14,0xE4,0x00,0x5E,0x00,0x88,0x6A,0x98,0x8C,0xE4,0x00,0x5D,
+0x22,0xC2,0xE0,0x10,0x01,0x88,0x6E,0xED,0xD7,0x07,0xB8,0xE7,0xFF,0xF6,0x80,0x88,
+0x6E,0x0D,0xE1,0x06,0x0D,0xC1,0x0A,0x0D,0xA1,0x0E,0x0D,0x81,0x12,0x0D,0x61,0x16,
+0x0D,0x41,0x1A,0x0D,0x21,0x1E,0x1C,0x21,0x20,0xE7,0xFF,0xF9,0x85,0xC2,0xE0,0x10,
+0x01,0x9C,0x38,0xEC,0x77,0x03,0x24,0x0D,0x41,0x00,0x0D,0x21,0x04,0x89,0x43,0xE7,
+0xFF,0xFB,0xB8,0x25,0x44,0xD3,0x99,0x40,0x88,0x6A,0x98,0x80,0x9D,0x41,0xE4,0x00,
+0x63,0x00,0x5D,0x4A,0x00,0xD1,0x44,0xFF,0x9E,0xE7,0xFF,0xE7,0xB4,0xC2,0xE0,0x10,
+0x01,0xFE,0xF7,0x00,0xD6,0x0C,0x77,0x0B,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x06,0x4B,
+0x53,0x18,0x20,0xEF,0x17,0x06,0x4B,0x0D,0x41,0x02,0x0D,0x21,0x06,0x9C,0x28,0x85,
+0x29,0x1C,0x21,0xD8,0xC2,0xE0,0x10,0x01,0x0D,0x41,0x20,0x0D,0xC1,0x10,0xEE,0xF7,
+0x00,0xD2,0x0D,0x21,0x24,0x0D,0x61,0x1C,0x0D,0x81,0x18,0x0D,0xA1,0x14,0x0D,0xE1,
+0x0C,0x0E,0x01,0x08,0x0E,0x21,0x04,0x0E,0x41,0x00,0x5E,0xE0,0x41,0x89,0x43,0x49,
+0xC1,0x01,0x24,0x64,0x6D,0x1E,0xE3,0xFE,0xD2,0xE1,0x04,0x31,0xD0,0x67,0x04,0x4A,
+0x51,0x60,0x20,0xD0,0x69,0x04,0x46,0x99,0x64,0xE4,0x00,0x00,0x3D,0x51,0x60,0x10,
+0x9A,0xE0,0x20,0x60,0x5C,0x9A,0xE0,0xD1,0x45,0x00,0x92,0x9A,0xE1,0x21,0x44,0x30,
+0x21,0x4C,0x24,0xD1,0x46,0x00,0x32,0x9A,0xE0,0x4E,0xF7,0x28,0xC1,0xE0,0x10,0x01,
+0xC2,0x00,0x10,0x01,0xFD,0xEF,0x0B,0x7C,0xFE,0x10,0x07,0x6C,0x99,0x80,0xC2,0x40,
+0x10,0x01,0x8D,0xF7,0x8E,0x17,0x89,0xAC,0x1E,0x2A,0xFE,0xFE,0x52,0x09,0xAC,0x88,
+0x6D,0x98,0x81,0x88,0xAE,0xE4,0x00,0x6B,0x48,0x42,0xEF,0x64,0x25,0x44,0x41,0x42,
+0xF0,0x64,0x26,0x24,0x29,0xD1,0x47,0x00,0x56,0x42,0xEC,0x94,0x0C,0x77,0x01,0x9D,
+0xA1,0x9D,0x82,0x5D,0xAD,0x00,0xD5,0x6D,0xFE,0xCD,0xE4,0x00,0x00,0x35,0x51,0x60,
+0x10,0xE4,0x00,0x00,0x15,0x99,0x63,0xE7,0xFF,0xFF,0x41,0x9A,0xE0,0x21,0x4A,0x22,
+0xE7,0xFF,0xFF,0x33,0x0E,0x41,0x02,0x0E,0x21,0x06,0x0E,0x01,0x0A,0x0D,0xE1,0x0E,
+0x0D,0xC1,0x12,0x0D,0xA1,0x16,0x0D,0x81,0x1A,0x0D,0x61,0x1E,0x0D,0x41,0x22,0x0D,
+0x21,0x26,0x1C,0x21,0x28,0x85,0x29,0x1C,0x21,0xD0,0x0D,0x41,0x28,0x0D,0x21,0x2C,
+0x0D,0x61,0x24,0x0D,0x81,0x20,0x89,0x44,0xD0,0x67,0x04,0x95,0xC2,0xF8,0x00,0x21,
+0xFE,0xF7,0xBA,0x8C,0x4C,0x63,0x10,0xC1,0x60,0x10,0x01,0x8C,0x77,0xC1,0x80,0x10,
+0x01,0x0E,0xE3,0x02,0xFD,0x6B,0x0A,0x64,0xFD,0x8C,0x0B,0x7C,0x86,0xE9,0xC2,0xE0,
+0x10,0x01,0xEB,0x17,0x06,0x4B,0xC7,0x18,0xFF,0xDF,0xEF,0x17,0x06,0x4B,0xD0,0x88,
+0x02,0xE5,0x9A,0xE1,0x4E,0xF7,0x24,0xC6,0xF7,0x01,0x83,0x22,0xE1,0x3C,0xE4,0x00,
+0x00,0x8D,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x06,0x4B,0xC7,0x18,0xFF,0xDF,0xEF,0x17,
+0x06,0x4B,0xD1,0x47,0x01,0xC5,0x9A,0xE1,0x4E,0xF7,0x54,0x57,0x17,0x8C,0x23,0x00,
+0x9A,0x56,0xF7,0x03,0x22,0xE0,0x98,0x88,0x6A,0xE7,0xFF,0xFD,0x10,0x4C,0x8A,0x28,
+0x4C,0xAA,0x30,0x88,0x61,0x8C,0x8C,0x8C,0xAB,0x50,0xC0,0x10,0xE4,0x00,0x17,0x70,
+0xE4,0x00,0x00,0x15,0x88,0x6A,0xE7,0xFF,0xFC,0xD6,0x0D,0x81,0x22,0x0D,0x61,0x26,
+0x0D,0x41,0x2A,0x0D,0x21,0x2E,0x1C,0x21,0x30,0x85,0x29,0xC3,0x00,0x10,0x01,0x98,
+0x60,0xFF,0x18,0x07,0x6C,0xCB,0x60,0xFF,0xFE,0xE4,0x00,0x00,0x73,0x43,0x38,0xBC,
+0x0B,0x59,0x00,0x4F,0x3A,0xFA,0x47,0x59,0xD6,0x43,0x3A,0xCD,0xCB,0x40,0xFF,0xFE,
+0x8C,0x79,0x5C,0x7A,0x17,0x5F,0x23,0x04,0x9E,0xE2,0x48,0x79,0xD8,0x5E,0xE4,0x09,
+0x23,0xFF,0x75,0xC2,0xE0,0x10,0x01,0x1F,0x18,0x20,0xFE,0xF7,0x07,0xAC,0xD7,0x17,
+0x00,0x52,0x9A,0xE0,0xE7,0xFF,0xFF,0x93,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEC,0x17,
+0x07,0x68,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x07,0x60,0xC2,0xE0,0x10,0x01,0x9B,0x04,
+0xEC,0x17,0x07,0xAC,0x98,0x64,0xC2,0xE0,0x10,0x01,0x98,0x80,0xEF,0x17,0x03,0x24,
+0xE7,0xFF,0xF6,0xF7,0x20,0x64,0x3E,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x07,0x6A,0xE4,
+0x00,0x00,0x41,0x20,0x68,0x3E,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x07,0x62,0xE4,0x00,
+0x00,0x23,0x9A,0xE0,0x20,0x6C,0x2E,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x07,0xAE,0x88,
+0x77,0x85,0x29,0x20,0x64,0x3E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x07,0x68,0xE4,0x00,
+0x00,0x3D,0x20,0x68,0x3E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x07,0x60,0xE4,0x00,0x00,
+0x1F,0x20,0x6C,0x2E,0xC2,0xE0,0x10,0x01,0xEC,0x97,0x07,0xAC,0x85,0x29,0x1C,0x21,
+0xE0,0xC2,0xE0,0x10,0x01,0x0D,0x41,0x18,0x0D,0x61,0x14,0x0D,0x81,0x10,0x0D,0xA1,
+0x0C,0x0D,0xC1,0x08,0x0D,0xE1,0x04,0xEE,0xF7,0x0D,0x56,0x0D,0x21,0x1C,0xC1,0x80,
+0x10,0x01,0xC1,0x60,0x10,0x01,0x5D,0xE3,0x06,0x5D,0xC4,0x06,0x89,0x45,0x89,0xA6,
+0x56,0xF7,0x01,0xFD,0x8C,0x09,0xA0,0xFD,0x6B,0x08,0x6C,0x22,0xE0,0xE0,0x98,0xA2,
+0x25,0x44,0x43,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xBB,0xA0,0x8E,0xEA,0x10,0xB7,0x00,
+0x0E,0xEB,0x02,0x5E,0xE0,0x29,0x88,0x6F,0x88,0x8E,0x48,0xA5,0x12,0xE7,0xFF,0x8F,
+0xCC,0x5C,0x63,0x00,0x20,0x60,0x3C,0x0C,0x0C,0x00,0x0C,0x0D,0x00,0x98,0x61,0xE4,
+0x00,0x00,0xED,0x21,0x45,0x38,0x21,0x40,0x28,0x21,0x4D,0x8E,0xE4,0x00,0x00,0xA7,
+0x0E,0xEB,0x02,0x22,0xE4,0x36,0xE7,0xFF,0x92,0xCE,0x98,0x62,0xE4,0x00,0x00,0x5D,
+0x0E,0xEC,0x02,0x22,0xE4,0x86,0xC2,0xE0,0x10,0x01,0xEC,0x77,0x0D,0x76,0xC2,0xE0,
+0x10,0x01,0xEC,0x97,0x0D,0x56,0xE7,0xFF,0x98,0xEA,0x88,0x6D,0xE7,0xFF,0x99,0x02,
+0xE4,0x00,0x00,0x15,0xE7,0xFF,0x92,0x72,0x98,0x60,0x0C,0x0B,0x00,0xE4,0x00,0x00,
+0x4B,0x88,0x6F,0x88,0x8E,0xE7,0xFF,0x92,0x74,0x98,0x60,0xE4,0x00,0x00,0x2F,0xE7,
+0xFF,0x92,0x3C,0x9A,0xE1,0x0E,0xEB,0x00,0xE4,0x00,0x00,0x11,0xE7,0xFF,0x92,0x22,
+0x98,0x62,0x0D,0x4C,0x00,0x0D,0xE1,0x06,0x0D,0xC1,0x0A,0x0D,0xA1,0x0E,0x0D,0x81,
+0x12,0x0D,0x61,0x16,0x0D,0x41,0x1A,0x0D,0x21,0x1E,0x1C,0x21,0x20,0x85,0x29,0xC3,
+0x80,0x10,0x01,0xC3,0x60,0x10,0x01,0xC3,0x40,0x10,0x01,0xC3,0x20,0x10,0x01,0xC3,
+0x00,0x10,0x01,0xFF,0x9C,0x0D,0x4A,0xFF,0x7B,0x0A,0x5A,0xFF,0x5A,0x0C,0xD8,0xFF,
+0x39,0x0C,0xE4,0xFF,0x18,0x0C,0xDC,0x20,0x69,0x76,0x0A,0xFC,0x04,0x0B,0xD9,0x09,
+0x43,0xD7,0xF5,0x5F,0xDE,0x06,0x4F,0xBE,0xFA,0x47,0xDD,0xF6,0x43,0xBE,0xED,0x5F,
+0xAC,0x99,0x20,0x00,0x79,0x0B,0xBC,0x07,0x0B,0x99,0x0B,0x43,0xBD,0xE5,0x5F,0xBD,
+0x06,0x4F,0x9D,0xFA,0x47,0xBC,0xEE,0x43,0x9D,0xE5,0x5F,0x8D,0xD1,0x20,0x05,0x15,
+0x0E,0xF8,0x01,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x0D,0x51,0x0B,0x99,0x0B,0x0E,0xF8,
+0x03,0x0B,0x39,0x0F,0x12,0xFA,0x00,0x0F,0x9B,0x01,0x0F,0x3B,0x03,0x52,0xF7,0x02,
+0xE4,0x00,0x01,0x55,0xC3,0xA0,0x10,0x01,0xC2,0xE0,0x10,0x01,0xFF,0xBD,0x09,0xB2,
+0xFE,0xF7,0x0C,0x08,0x20,0x6D,0x8E,0x0B,0x79,0x01,0x0B,0xDC,0x01,0x43,0xDE,0xDD,
+0x5F,0xDE,0x06,0x4F,0x7E,0xFA,0x47,0xDB,0xF6,0x43,0x7E,0xDD,0x5F,0x6C,0x99,0x20,
+0x00,0x79,0x0B,0x39,0x03,0x0B,0x7C,0x03,0x43,0x7B,0xCD,0x5F,0x7B,0x06,0x4F,0x3B,
+0xFA,0x47,0x79,0xDE,0x43,0x3B,0xCD,0x5F,0x2D,0xD1,0x20,0x03,0x61,0x0B,0x37,0x17,
+0x0F,0x38,0x01,0x0B,0x37,0x19,0x0F,0x38,0x03,0x0B,0x37,0x47,0x0A,0xF7,0x49,0x0E,
+0xF8,0x07,0x12,0xFA,0x00,0x52,0xF7,0x01,0x0F,0x38,0x05,0x1A,0xFA,0x00,0x9A,0xE2,
+0x1A,0xFD,0x00,0xE4,0x00,0x01,0x5F,0xD0,0x64,0x01,0xD6,0x0B,0x3B,0x00,0x0B,0x7B,
+0x02,0x43,0x79,0xDD,0x9F,0x6E,0x5F,0x63,0x9B,0x20,0x00,0x2F,0xC3,0x20,0x10,0x01,
+0xEB,0x39,0x0C,0xDF,0x0B,0x18,0x01,0x0F,0x17,0x47,0x9B,0x02,0x0F,0x37,0x49,0x1B,
+0x17,0x00,0x12,0xFA,0x00,0x9B,0x1D,0x46,0xF7,0xC4,0x1A,0xFA,0x00,0xE4,0x00,0x00,
+0xEB,0xD0,0x65,0x03,0x8E,0x13,0x7D,0x00,0x23,0x68,0xFE,0x0B,0x98,0x00,0x0B,0x59,
+0x00,0x8F,0x5C,0x43,0x5A,0xD8,0x0B,0x98,0x02,0x0F,0x57,0x17,0x0B,0x59,0x02,0x8F,
+0x5C,0x43,0x5A,0xD8,0x0B,0x98,0x04,0x0F,0x57,0x19,0x0B,0x59,0x08,0x8F,0x5C,0x43,
+0x5A,0xD8,0x0F,0x57,0x47,0x0B,0x58,0x06,0x0B,0x19,0x0A,0x8F,0x1A,0x43,0x78,0xD8,
+0x0F,0x77,0x49,0xE4,0x00,0x00,0x55,0x23,0x64,0x9A,0x0B,0x38,0x01,0x0F,0x37,0x17,
+0x0B,0x38,0x03,0x0F,0x37,0x19,0x0B,0x38,0x05,0x0B,0x18,0x07,0x0F,0x37,0x47,0x0F,
+0x17,0x49,0x9B,0x3E,0x13,0x1A,0x00,0x47,0x18,0xCC,0x1B,0x1A,0x00,0x9B,0x02,0x1B,
+0x17,0x00,0x85,0x29,0xC3,0x00,0x10,0x01,0xFF,0x18,0x0D,0x4A,0xFE,0xE0,0x7F,0xFF,
+0x0E,0xF8,0x01,0x0E,0xF8,0x03,0x0E,0xF8,0x05,0x0E,0xF8,0x07,0x9B,0x01,0xC3,0x20,
+0x10,0x01,0xFF,0x39,0x03,0x36,0x1B,0x19,0x01,0xC3,0x00,0x10,0x01,0xFF,0x18,0x09,
+0xBA,0x0E,0xF8,0x01,0x0E,0xF8,0x03,0x0E,0xF8,0x05,0x0E,0xF8,0x07,0xC3,0x00,0x10,
+0x01,0xF8,0x18,0x09,0xB3,0xC3,0x00,0x10,0x01,0xFF,0x18,0x0C,0xE4,0x0E,0xF8,0x01,
+0x0E,0xF8,0x03,0x0E,0xF8,0x05,0x0E,0xF8,0x07,0x0E,0xF8,0x09,0x0E,0xF8,0x0B,0x0E,
+0xF8,0x0D,0x0E,0xF8,0x0F,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0A,0x5E,0xC2,0xE0,0x10,
+0x01,0x18,0x19,0x00,0xF3,0x17,0x0C,0xD8,0x9B,0x3C,0x47,0x18,0xCC,0xFB,0x17,0x0C,
+0xD8,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x09,0xB2,0x85,0x29,0xC2,0xE0,0x10,0x01,0xC3,
+0x00,0x10,0x01,0x5C,0x63,0x00,0xFE,0xF7,0x0D,0x04,0xFF,0x18,0x0B,0xC0,0x9B,0x20,
+0x20,0x80,0x6C,0xE4,0x00,0x00,0x47,0x4F,0x59,0x10,0x0B,0x97,0x00,0x0B,0x77,0x02,
+0x8F,0x58,0x8F,0x7C,0x9F,0x21,0x0F,0x7A,0x00,0x9E,0xE4,0x5F,0x59,0x00,0xD4,0x7A,
+0xFF,0x4D,0xE4,0x00,0x00,0xF7,0x0B,0x57,0x00,0x0B,0x37,0x02,0x8F,0x3A,0xC3,0x80,
+0x10,0x01,0x0F,0x38,0x00,0xFF,0x9C,0x0A,0xE4,0x13,0x3C,0x04,0x1F,0xB9,0xFF,0x4F,
+0xBD,0x10,0x43,0xD8,0xEC,0x8F,0xB7,0x4F,0x79,0x08,0x09,0x1D,0x00,0x1F,0x5B,0xFF,
+0x4F,0xBA,0x08,0x8F,0xB7,0x0B,0xBD,0x00,0x8F,0xA8,0x0F,0xBE,0x00,0x13,0x9C,0x01,
+0x27,0x84,0xF5,0x4F,0x39,0x10,0x4F,0x5A,0x10,0x43,0x98,0xCC,0x43,0xB7,0xCC,0x9F,
+0x61,0x0B,0xBD,0x00,0x4F,0x7B,0x08,0x8F,0x77,0x0B,0x7B,0x00,0x8F,0x7D,0x0F,0x7C,
+0x00,0x8F,0x1A,0x1F,0x59,0xFE,0x9F,0x3F,0x4F,0x5A,0x08,0x4F,0x39,0x08,0x8F,0x57,
+0x8E,0xF9,0x0B,0x5A,0x00,0x0A,0xF7,0x00,0x8E,0xFA,0x0E,0xF8,0x00,0x85,0x29,0xC3,
+0x00,0x10,0x01,0x5C,0x84,0x00,0xFF,0x18,0x0D,0x04,0x20,0xA0,0x6C,0xE4,0x00,0x00,
+0x4B,0x4F,0x37,0x08,0x9E,0xE1,0x43,0x58,0xCC,0x8F,0x23,0x0B,0x5A,0x00,0x0F,0x59,
+0x01,0xE4,0x00,0x00,0x0D,0x9A,0xE0,0x5F,0x37,0x00,0xD4,0x99,0xFF,0x3D,0xE4,0x00,
+0x00,0x7F,0x20,0xA4,0xEE,0xE4,0x00,0x00,0x31,0x4F,0x37,0x08,0x9E,0xE1,0x43,0x43,
+0xCC,0x8F,0x38,0x0B,0x5A,0x00,0x0F,0x59,0x01,0xE4,0x00,0x00,0x0D,0x9A,0xE0,0x5F,
+0x37,0x00,0xD4,0x99,0xFF,0x3D,0xC2,0xE0,0x10,0x01,0x98,0x80,0xFE,0xF7,0x0A,0xE4,
+0x10,0x77,0x01,0x12,0xF7,0x04,0x40,0x63,0xBB,0xE7,0xFF,0xFD,0xC5,0x85,0x29,0x5C,
+0x84,0x00,0x5C,0x82,0x09,0x4A,0xE1,0x13,0x4F,0x04,0x09,0x9B,0xA2,0x43,0x18,0xBB,
+0x1F,0xC4,0xFE,0x1F,0x58,0xFE,0x1F,0x78,0xFF,0x1F,0x98,0x01,0x9A,0xE0,0x1D,0x04,
+0xFF,0xE4,0x00,0x00,0x73,0x27,0x24,0x6D,0xD6,0xFE,0x00,0xC2,0xD6,0xE8,0x00,0xA2,
+0xD6,0xFA,0x00,0x82,0xD6,0xFB,0x00,0x62,0xD6,0xF8,0x00,0x42,0xD6,0xFC,0x00,0xD6,
+0x20,0xA0,0x36,0x0B,0x23,0x01,0x4F,0x39,0x08,0xE4,0x00,0x00,0x15,0x0B,0x23,0x00,
+0x43,0x39,0xE8,0x0F,0x23,0x01,0x9E,0xE1,0x9C,0x62,0x5F,0x37,0x00,0xD4,0x99,0xFE,
+0x45,0x85,0x29,0x9C,0x38,0x98,0x63,0x0D,0x21,0x04,0xE7,0xFF,0x75,0x66,0x0D,0x21,
+0x06,0x9C,0x28,0xE4,0x00,0x73,0x65,0x9A,0xE8,0x1C,0x21,0xE8,0x0D,0x41,0x10,0x0D,
+0x81,0x08,0xC1,0x80,0x10,0x01,0xFD,0x4C,0x0A,0xE4,0x1A,0xEA,0x04,0x9A,0xE2,0x1A,
+0xEA,0x01,0xFE,0xE0,0x07,0xFF,0x0E,0xEA,0x07,0x0E,0xEA,0x09,0xC2,0xE0,0x10,0x01,
+0x0D,0x61,0x0C,0x99,0x64,0xF9,0x77,0x0A,0x5F,0xFE,0xE0,0x01,0x24,0x0E,0xEA,0x0B,
+0xFE,0xE0,0x04,0x00,0x0D,0x21,0x14,0x0E,0xEA,0x03,0x50,0x60,0x20,0x98,0x80,0xE7,
+0xFF,0x46,0x60,0x50,0x60,0x20,0x98,0x81,0xE7,0xFF,0x46,0x4E,0x52,0xE0,0x23,0xFA,
+0xEC,0x0A,0xE4,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x00,0xC5,0xC2,0xE0,0x10,0x01,0xEC,
+0x17,0x0D,0x7C,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x09,0xA8,0xC2,0xE0,0x10,0x01,0xEC,
+0x17,0x08,0x25,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0D,0x78,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x09,0xB6,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0A,0xF2,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x09,0xC8,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0D,0x58,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x0C,0xF5,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0A,0xF3,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x09,0xC9,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x0B,0xBD,0xC2,0xE0,0x10,0x01,0xEC,
+0x17,0x09,0x9C,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x0D,0x61,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x0A,0x58,0xC2,0xE0,0x10,0x01,0x9B,0x03,0xFB,0x17,0x0A,0x61,0xC2,0xE0,0x10,
+0x01,0xF8,0x17,0x09,0xB3,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x07,0x58,0xC2,0xE0,0x10,
+0x01,0xFF,0x00,0x01,0xF4,0xEF,0x17,0x06,0x49,0xC2,0xE0,0x10,0x01,0x50,0x60,0x14,
+0xF8,0x17,0x07,0xDC,0x50,0x80,0x50,0x19,0x6A,0x0C,0xE7,0xFF,0x84,0xAE,0x52,0xE0,
+0x64,0x50,0x80,0x39,0x0E,0xE1,0x01,0x50,0xA0,0x64,0xFC,0xC0,0x07,0xFF,0xFC,0xE0,
+0x07,0xFF,0x99,0x01,0xC0,0x60,0x10,0x01,0xFC,0x63,0x01,0x80,0xE7,0xFF,0xA1,0xD8,
+0xC0,0x60,0x10,0x01,0x98,0x80,0xFC,0x63,0x0B,0xC0,0x50,0xA0,0x48,0xE7,0xFF,0xA4,
+0xDA,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0C,0x08,0x9E,0xE4,0x18,0x17,0x00,0x18,0x17,
+0x01,0x18,0x17,0x02,0xC3,0x00,0x10,0x01,0x1E,0xF7,0x30,0xFF,0x18,0x0C,0xCC,0xD6,
+0xF8,0xFF,0x66,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0D,0x59,0xC2,0xE0,0x10,0x01,0xF3,
+0x37,0x00,0xB0,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x3D,0xF9,0x1B,0x38,0x00,0xC3,0x00,
+0x10,0x01,0xF3,0x18,0x07,0x57,0xCA,0xF7,0x3D,0xF8,0x1B,0x17,0x00,0xC3,0x00,0x10,
+0x01,0xEC,0x18,0x0B,0x35,0xC3,0x00,0x10,0x01,0xC2,0xE0,0x10,0x01,0xEB,0x58,0x09,
+0xB9,0xEB,0x37,0x07,0xDF,0x53,0x5A,0x04,0xEF,0x58,0x09,0xB9,0x53,0x19,0x05,0xEF,
+0x17,0x07,0xDF,0xC3,0x00,0x10,0x01,0xFE,0xF8,0x0C,0xF6,0xC3,0x60,0x10,0x01,0x18,
+0x17,0x01,0x18,0x17,0x02,0x18,0x17,0x03,0x0C,0x17,0x05,0x0C,0x17,0x07,0x0C,0x17,
+0x0B,0x0C,0x17,0x09,0xC3,0x40,0x10,0x01,0xC3,0x20,0x10,0x01,0xF8,0x18,0x0C,0xF6,
+0x9A,0xE0,0xFF,0x7B,0x0D,0x04,0xFF,0x5A,0x0B,0x36,0xFF,0x39,0x09,0xCC,0x43,0x1B,
+0xBC,0x0C,0x18,0x01,0x43,0x1A,0xBC,0x0C,0x18,0x01,0x4F,0x17,0x08,0x8F,0x19,0x0C,
+0x18,0x00,0x9E,0xE2,0x5E,0xE8,0xC9,0x23,0xFF,0x9D,0x0D,0x81,0x0A,0x0D,0x61,0x0E,
+0x0D,0x41,0x12,0x0D,0x21,0x16,0x1C,0x21,0x18,0x85,0x29,0xE4,0x00,0x6B,0x93,0x1C,
+0x21,0xE8,0x0D,0x21,0x14,0xE7,0xFF,0xD4,0x04,0xE7,0xFF,0xAD,0x5A,0xE7,0xFF,0xD3,
+0x26,0xE7,0xFF,0xF0,0xF2,0x98,0x60,0x98,0x81,0xE7,0xFF,0x6F,0x0C,0x98,0x81,0x98,
+0x60,0x88,0xA4,0xE7,0xFF,0x6F,0x12,0x98,0x81,0x98,0x60,0x88,0xA4,0xE7,0xFF,0x6F,
+0x28,0x98,0x80,0x98,0x61,0x88,0xA4,0xE7,0xFF,0x6F,0x14,0x98,0xA0,0x98,0x62,0x98,
+0x81,0xE7,0xFF,0x6F,0x00,0x98,0x62,0x98,0x80,0xE7,0xFF,0x6F,0x76,0x98,0x60,0x50,
+0x80,0xF6,0xE7,0xFF,0x6F,0x7E,0x98,0x61,0x50,0x80,0xF6,0xE7,0xFF,0x6F,0x6C,0x98,
+0x62,0x50,0x80,0xF3,0xE7,0xFF,0x6F,0x5A,0x98,0x60,0xFC,0x80,0xA0,0x00,0xE7,0xFF,
+0x6F,0xA2,0x98,0x61,0xFC,0x80,0xA0,0x00,0xE7,0xFF,0x6F,0x8E,0x98,0x62,0xFC,0x80,
+0xA0,0x00,0xE7,0xFF,0x6F,0x7A,0xFC,0x80,0x01,0x26,0x98,0x62,0xE7,0xFF,0x6F,0xC2,
+0xFC,0x60,0x01,0x5E,0xE7,0xFF,0x9F,0xBE,0xE7,0xFF,0xFA,0x7E,0x50,0x60,0x1B,0xE7,
+0xFF,0x5C,0x0E,0x50,0x60,0xFA,0xE7,0xFF,0x5C,0x14,0xFC,0x60,0x01,0x08,0xE7,0xFF,
+0x5C,0x18,0x50,0x60,0xCC,0xE7,0xFF,0x5C,0x1E,0x50,0x60,0xCC,0xE7,0xFF,0x5C,0x24,
+0x98,0x6A,0xE7,0xFF,0x5C,0x2C,0x50,0x60,0x1B,0xE7,0xFF,0x73,0x70,0x9A,0xEE,0x0E,
+0xE1,0x00,0x52,0xE0,0x14,0x0E,0xE1,0x04,0xCA,0xE0,0x07,0xD0,0x99,0x0A,0x0E,0xE1,
+0x08,0x98,0xC8,0x98,0xAE,0x88,0xE6,0x98,0x6A,0x98,0x8C,0xE7,0xFF,0x40,0x22,0x98,
+0x81,0x98,0x60,0xE7,0xFF,0xD2,0x00,0x50,0x60,0x10,0xE7,0xFF,0xD2,0x32,0xE4,0x00,
+0x3F,0x84,0xE7,0xFF,0xF9,0x82,0x98,0x80,0x98,0xC0,0x88,0xA4,0x98,0x60,0xE7,0xFF,
+0x3C,0xF2,0xE7,0xFF,0xC0,0x1A,0xE7,0xFF,0xBF,0x06,0xC2,0xE0,0x10,0x01,0xF0,0x77,
+0x03,0x3C,0xE7,0xFF,0xD1,0xC2,0x9B,0x00,0xCA,0xE0,0x48,0x00,0xC3,0x17,0x00,0x0D,
+0xC3,0x17,0x00,0x0F,0x53,0x18,0x04,0xC3,0x17,0x00,0x0D,0xC3,0x17,0x00,0x0F,0x53,
+0x18,0x08,0xC3,0x17,0x00,0x0D,0xC2,0xE0,0x01,0x1F,0x52,0xF7,0x06,0xC2,0xE0,0x01,
+0x1D,0xFC,0x60,0x01,0x40,0xE7,0xFF,0xD1,0x6C,0x50,0x60,0x20,0xE7,0xFF,0xD1,0x76,
+0x98,0x61,0x50,0x80,0x13,0x50,0xA0,0x37,0x98,0xC8,0xFC,0xE0,0x01,0xB0,0xE7,0xFF,
+0xB3,0x46,0xC3,0x00,0x00,0x01,0xC2,0xE0,0x10,0x01,0xFF,0x18,0x3E,0x8B,0x0D,0x21,
+0x16,0xEF,0x17,0x03,0xFC,0x1C,0x21,0x18,0x85,0x29,0xC2,0xE0,0x10,0x01,0xEF,0x17,
+0x00,0xD2,0x23,0x05,0x08,0xEE,0xF7,0x00,0xD2,0x22,0xE8,0xEC,0xC3,0x00,0x10,0x01,
+0xC2,0xE0,0x10,0x01,0xFF,0x18,0x09,0xAC,0xFE,0xF7,0x0D,0x5A,0x0B,0x38,0x01,0xC3,
+0x60,0x10,0x01,0x0F,0x37,0x01,0xC3,0x40,0x10,0x01,0x0B,0x38,0x03,0xFF,0x7B,0x0D,
+0x62,0x0F,0x37,0x03,0x0B,0x18,0x05,0xFF,0x5A,0x09,0x8A,0x0F,0x17,0x05,0x9A,0xE0,
+0xE4,0x00,0x00,0x69,0xC3,0x80,0x10,0x01,0xC3,0x60,0x10,0x01,0x9A,0xE0,0xFF,0x9C,
+0x0B,0x7C,0xFF,0x7B,0x07,0xE0,0x43,0x3C,0xBC,0x43,0x1B,0xBC,0x0B,0x59,0x01,0x0B,
+0x39,0x21,0x0F,0x58,0x01,0x0F,0x38,0x21,0x9E,0xE2,0x5E,0xE4,0x09,0x23,0xFF,0xA5,
+0xE7,0xFF,0xFF,0x39,0x43,0x1B,0xBC,0x43,0x3A,0xBC,0x0B,0x39,0x01,0x0F,0x38,0x01,
+0x9E,0xE2,0x5E,0xE2,0x09,0x23,0xFF,0xBD,0x85,0x29,0xC3,0x80,0x10,0x01,0xC3,0x00,
+0x10,0x01,0x9A,0xE0,0xFF,0x9C,0x07,0xE0,0xFF,0x18,0x0B,0x36,0x43,0x5C,0xBC,0x43,
+0x38,0xBC,0x0B,0x7A,0x01,0x0B,0x5A,0x21,0x0F,0x79,0x01,0x0F,0x59,0x21,0x9E,0xE2,
+0x5E,0xE4,0x09,0x23,0xFF,0xA5,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0D,0x5A,0x0B,0x37,
+0x01,0x0F,0x38,0x41,0x0B,0x37,0x03,0x0A,0xF7,0x05,0x0F,0x38,0x43,0x0E,0xF8,0x45,
+0x85,0x29,0xE4,0x00,0x69,0x89,0xC2,0xE0,0x10,0x01,0xFF,0x20,0xDF,0x9F,0xEB,0x17,
+0x08,0x25,0x47,0x18,0xCC,0x9B,0x3E,0xEF,0x17,0x08,0x25,0xC2,0xE0,0x10,0x01,0xEB,
+0x17,0x0C,0xDB,0x47,0x18,0xCC,0xEF,0x17,0x0C,0xDB,0x85,0x29,0xE4,0x00,0x72,0x39,
+0xE4,0x00,0x71,0xD7,0xE4,0x00,0x72,0x67,0xC2,0xE0,0x10,0x01,0xC3,0x40,0x10,0x01,
+0xF3,0x77,0x0A,0xE4,0xFF,0x5A,0x08,0x24,0xC3,0x00,0x10,0x01,0x88,0xC3,0x1F,0xBB,
+0xFF,0x0A,0xFA,0x01,0xFF,0x18,0x0D,0x04,0x9B,0x20,0xE4,0x00,0x00,0x57,0xD7,0xB9,
+0x00,0xB8,0x0B,0xD8,0x00,0x0B,0x98,0x02,0x8F,0x9E,0xCB,0xD7,0x20,0x00,0xC3,0x80,
+0x1F,0x2C,0x4A,0xFE,0xB8,0x0B,0x98,0x00,0x53,0xD7,0x40,0x5F,0x86,0xD9,0x9F,0x21,
+0x4A,0xFE,0xB8,0x9F,0x02,0x5F,0x99,0x04,0xD7,0x7C,0xFE,0xB5,0x98,0x60,0x0E,0xFA,
+0x01,0x88,0x83,0x98,0xA0,0xE7,0xFF,0xBC,0xBD,0x9C,0x38,0x0D,0x41,0x00,0x0D,0x21,
+0x04,0xC1,0x40,0x10,0x01,0x20,0x64,0x62,0xE7,0xFF,0xBD,0xD8,0x20,0x64,0x56,0xF2,
+0xEA,0x0D,0x58,0x9E,0xE1,0xFA,0xEA,0x0D,0x58,0xE4,0x00,0x00,0x19,0xE7,0xFF,0xBE,
+0x5E,0xF8,0x0A,0x0D,0x58,0xE7,0xFF,0xDC,0x44,0x9A,0xE3,0x20,0x64,0x34,0xE7,0xFF,
+0xDC,0x32,0x5C,0x60,0x49,0x4A,0xE3,0x4B,0xC3,0x00,0x10,0x01,0xF3,0x38,0x0D,0x58,
+0xD6,0xF9,0x02,0x1D,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0C,0xF5,0xC2,0xE0,0x10,0x01,
+0xF8,0x17,0x0A,0xF2,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x09,0xC8,0xC2,0xE0,0x10,0x01,
+0xF8,0x18,0x0D,0x58,0xF8,0x17,0x07,0xDC,0x0D,0x41,0x02,0xC2,0xE0,0x10,0x01,0x0D,
+0x21,0x06,0xEB,0x17,0x08,0x25,0x9C,0x28,0x53,0x18,0x80,0xEF,0x17,0x08,0x25,0xE7,
+0xFF,0x6E,0x19,0x0D,0x41,0x02,0x0D,0x21,0x06,0x9C,0x28,0x85,0x29,0x9C,0x38,0xC3,
+0x14,0x00,0x01,0x0D,0x21,0x04,0xCA,0xF8,0x22,0x00,0x0B,0x37,0x01,0xCB,0x18,0x26,
+0x18,0x9B,0x3F,0x0F,0x37,0x01,0x0B,0x38,0x01,0x53,0x39,0x02,0x0F,0x38,0x01,0x0B,
+0x17,0x01,0xFC,0x60,0x01,0x00,0x0C,0x17,0x01,0xE7,0xFF,0xCC,0xC4,0xC2,0xE0,0x10,
+0x01,0x0D,0x21,0x06,0xEB,0x17,0x00,0xC5,0x9C,0x28,0xC7,0x18,0xFE,0xFF,0xEF,0x17,
+0x00,0xC5,0x85,0x29,0x5C,0xC6,0x00,0x9A,0xE0,0xE4,0x00,0x00,0x45,0x4F,0x17,0x08,
+0x4F,0x57,0x10,0x43,0x23,0xC4,0x8F,0x45,0x8F,0x04,0x0F,0x5A,0x02,0x0B,0x18,0x01,
+0x4F,0x5A,0x42,0x9E,0xE1,0x43,0x18,0xD5,0x0F,0x19,0x01,0x5F,0x17,0x00,0xD4,0xD8,
+0xFE,0xFD,0x85,0x29,0x9C,0x38,0x0D,0x21,0x04,0xE4,0x00,0x38,0xFA,0x0D,0x21,0x06,
+0xFC,0x60,0x01,0x00,0x9C,0x28,0xE7,0xFF,0xCB,0xFB,0x9C,0x38,0x0D,0x21,0x04,0xE4,
+0x00,0x38,0xCE,0x0D,0x21,0x06,0xFC,0x60,0x01,0x00,0x9C,0x28,0xE7,0xFF,0xCB,0xBF,
+0x9C,0x38,0x98,0x80,0x0D,0x21,0x04,0x98,0x61,0xE7,0xFF,0xE4,0x08,0x98,0x60,0xE7,
+0xFF,0x6C,0x50,0x98,0x61,0x98,0x80,0xE7,0xFF,0xE9,0x38,0x98,0x62,0x98,0x80,0xE7,
+0xFF,0xE9,0x28,0x0D,0x21,0x06,0x98,0x63,0x98,0x80,0x9C,0x28,0xE7,0xFF,0xE9,0x0F,
+0x98,0x64,0x98,0x80,0xE7,0xFF,0xE3,0xB3,0x9C,0x38,0x0D,0x21,0x04,0xE7,0xFF,0xD9,
+0xB4,0x24,0x64,0x29,0x20,0x69,0x8A,0xE4,0x00,0x00,0x19,0xE7,0xFF,0xD9,0x98,0xE4,
+0x00,0x00,0x57,0xE7,0xFF,0xCB,0x80,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x00,0xD6,0x0A,
+0xF7,0x09,0x40,0x63,0xBD,0x5E,0xE3,0x04,0xC2,0xE1,0x76,0xEA,0x20,0x00,0x7D,0x98,
+0x62,0xE7,0xFF,0xE8,0x26,0x20,0x60,0x5A,0x98,0x61,0x98,0x80,0xE7,0xFF,0xE3,0x22,
+0x0D,0x21,0x06,0x98,0x60,0x9C,0x28,0xE7,0xFF,0x6B,0x61,0x98,0x62,0x98,0x80,0xE7,
+0xFF,0xE2,0xFC,0xFC,0x60,0x01,0x5E,0xE7,0xFF,0x97,0xCC,0x0D,0x21,0x06,0x98,0x60,
+0x9C,0x28,0xE7,0xFF,0x6A,0xE3,0x0D,0x21,0x06,0x9C,0x28,0x85,0x29,0xD0,0x69,0x05,
+0xDD,0x4F,0x03,0x10,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xBA,0xD0,0x8E,0xF8,0xC3,0x00,
+0x10,0x01,0x0F,0x37,0x02,0xFF,0x18,0x09,0xCC,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x08,
+0x70,0x87,0x29,0xC3,0x00,0x10,0x01,0xFF,0x18,0x09,0x7C,0x0F,0x38,0x02,0xEF,0x37,
+0x00,0x80,0x0F,0x38,0x06,0x0F,0x18,0x0A,0xEF,0x37,0x00,0x84,0xEF,0x17,0x00,0x88,
+0xE4,0x00,0x00,0xF1,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0C,0xCC,0x0F,0x37,0x02,0xEF,
+0x38,0x00,0x80,0x0F,0x37,0x06,0x0E,0xF7,0x0A,0xEF,0x38,0x00,0x84,0xEE,0xF8,0x00,
+0x88,0xE4,0x00,0x00,0xAF,0x4C,0x63,0x30,0xC3,0x60,0x10,0x01,0x9A,0xE0,0xFF,0x7B,
+0x0A,0x64,0x8F,0x63,0x8C,0x78,0x43,0x23,0xBC,0x43,0x5B,0xBC,0x0F,0x5A,0x02,0x0F,
+0x59,0x00,0x9E,0xE4,0x5E,0xE8,0x09,0x23,0xFF,0xBD,0xE4,0x00,0x00,0x5D,0x9C,0x7E,
+0xC3,0x40,0x10,0x01,0x5C,0x63,0x00,0xFF,0x5A,0x08,0xFC,0x4C,0x63,0x30,0x8F,0x43,
+0x8C,0x77,0x9A,0xE0,0x43,0x03,0xBC,0x43,0x3A,0xBC,0x0F,0x39,0x02,0x0F,0x38,0x00,
+0x9E,0xE4,0x5E,0xE8,0x09,0x23,0xFF,0xBD,0x85,0x29,0xD0,0x69,0x06,0x1D,0x4F,0x03,
+0x10,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xBA,0xF8,0x8E,0xF8,0xC3,0x00,0x10,0x01,0x0F,
+0x37,0x02,0xFF,0x18,0x07,0xE0,0xC2,0xE0,0x10,0x01,0xFE,0xF7,0x0D,0x5A,0x87,0x29,
+0x0B,0x37,0x00,0xC3,0x00,0x10,0x01,0x4F,0x39,0x40,0xFF,0x18,0x09,0x7C,0xE4,0x00,
+0x00,0x25,0x0B,0x37,0x00,0xC3,0x00,0x10,0x01,0x4F,0x39,0x40,0xFF,0x18,0x0C,0xCC,
+0x0F,0x38,0x00,0x0B,0x37,0x02,0x0A,0xF7,0x04,0x4F,0x39,0x40,0x4E,0xF7,0x40,0x0F,
+0x38,0x04,0x0E,0xF8,0x08,0xE4,0x00,0x00,0xD1,0x4E,0xE3,0x28,0x8F,0x17,0x4E,0xE3,
+0x30,0xC3,0x60,0x10,0x01,0xFF,0x7B,0x0A,0x64,0x8F,0x77,0x9A,0xE0,0x4F,0x37,0x08,
+0x43,0x58,0xBC,0x8F,0x3B,0x0B,0x5A,0x00,0x4F,0x5A,0x40,0x0F,0x59,0x00,0x9E,0xE2,
+0x5E,0xE4,0x09,0x23,0xFF,0xA9,0xE4,0x00,0x00,0x6F,0x1E,0xE3,0xFE,0x5E,0xF7,0x00,
+0x4F,0x37,0x28,0x4E,0xF7,0x30,0xC3,0x60,0x10,0x01,0x8F,0x19,0xFF,0x7B,0x08,0xFC,
+0x8F,0x77,0x9A,0xE0,0x4F,0x37,0x08,0x43,0x58,0xBC,0x8F,0x3B,0x0B,0x5A,0x00,0x4F,
+0x5A,0x40,0x0F,0x59,0x00,0x9E,0xE2,0x5E,0xE4,0x09,0x23,0xFF,0xA9,0xE7,0xFF,0xFD,
+0x01,0x9C,0x38,0x98,0x64,0x0D,0x41,0x00,0x0D,0x21,0x04,0x98,0x80,0xE7,0xFF,0xDF,
+0xA0,0xC1,0x40,0x10,0x01,0xEA,0xEA,0x00,0xC5,0xC6,0xF7,0xFE,0xFF,0xEE,0xEA,0x00,
+0xC5,0xE7,0xFF,0xFB,0x06,0xEA,0xEA,0x00,0xC5,0xC6,0xF7,0x01,0x00,0x22,0xE3,0xE0,
+0xFC,0x60,0x01,0x00,0xE7,0xFF,0xC7,0x0E,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xC6,0xDE,
+0xE7,0xFF,0xF5,0xD4,0x98,0x60,0xE7,0xFF,0xFD,0xE8,0x0D,0x21,0x06,0x0D,0x41,0x02,
+0x98,0x61,0x9C,0x28,0xE7,0xFF,0xFD,0xCD,0x9C,0x38,0x0D,0x21,0x04,0x20,0x64,0x54,
+0x98,0x62,0xE7,0xFF,0xFD,0xB0,0x98,0x63,0xE7,0xFF,0xFD,0xA4,0x98,0x69,0xE4,0x00,
+0x00,0x25,0x98,0x60,0xE7,0xFF,0xFD,0x8C,0x98,0x61,0xE7,0xFF,0xFD,0x80,0x98,0x68,
+0x0D,0x21,0x06,0x9C,0x28,0xE7,0xFF,0xFD,0x6B,0x9C,0x38,0x98,0x60,0x0D,0x21,0x04,
+0xE7,0xFF,0xFD,0x54,0x98,0x61,0xE7,0xFF,0xFD,0x48,0x0D,0x21,0x06,0x98,0x68,0x9C,
+0x28,0xE7,0xFF,0xFD,0x33,0x20,0x80,0x64,0xD0,0x84,0x00,0xFA,0x20,0x88,0x90,0x20,
+0x8C,0xA8,0x5C,0x80,0x21,0x4B,0x0A,0x01,0x8A,0xF8,0xE4,0x00,0x00,0x49,0x53,0x00,
+0x19,0x8A,0xF8,0xE4,0x00,0x00,0x37,0x53,0x00,0x19,0x9A,0xE1,0xE4,0x00,0x00,0x25,
+0x53,0x00,0x32,0x8A,0xF8,0xE4,0x00,0x00,0x13,0x53,0x00,0x50,0x8A,0xF8,0xD0,0x69,
+0x0A,0xC5,0x4F,0x43,0x10,0xC3,0x38,0x00,0x21,0xFF,0x39,0xBB,0x20,0x8F,0x3A,0xC3,
+0x40,0x10,0x01,0x0F,0x79,0x02,0xFF,0x5A,0x07,0xE0,0xC3,0x20,0x10,0x01,0xFF,0x39,
+0x0D,0x5A,0x87,0x69,0x4F,0x23,0x30,0x4C,0xA3,0x28,0xC0,0x80,0x10,0x01,0x8C,0xBA,
+0xFC,0x84,0x0A,0x64,0x99,0x02,0x8C,0x99,0xCB,0xA0,0x01,0xF4,0x9B,0x20,0x43,0x65,
+0xCC,0x0B,0x9B,0x00,0x4F,0x79,0x08,0x4F,0x9C,0x40,0x8F,0x64,0x0F,0x5B,0x02,0x5F,
+0x5C,0x1D,0x4B,0xD8,0xB8,0x43,0x9C,0xD5,0x43,0x9E,0xE3,0xCF,0xDA,0x01,0xF4,0x43,
+0x9C,0x40,0x8F,0x9E,0x43,0x9C,0xE8,0x0F,0x9B,0x00,0x9F,0x22,0x5F,0x24,0x09,0x23,
+0xFF,0x3D,0xE4,0x00,0x01,0xC9,0x1F,0x23,0xFE,0x5F,0x39,0x00,0x4C,0xB9,0x28,0x4F,
+0x39,0x30,0xC0,0x80,0x10,0x01,0x8C,0xBA,0xFC,0x84,0x08,0xFC,0x99,0x02,0x8C,0x99,
+0xCB,0xA0,0x01,0xF4,0x9B,0x20,0x43,0x65,0xCC,0x0B,0x9B,0x00,0x4F,0x79,0x08,0x4F,
+0x9C,0x40,0x8F,0x64,0x0F,0x5B,0x02,0x5F,0x5C,0x1D,0x4B,0xD8,0xB8,0x43,0x9C,0xD5,
+0x43,0x9E,0xE3,0xCF,0xDA,0x01,0xF4,0x43,0x9C,0x40,0x8F,0x9E,0x43,0x9C,0xE8,0x0F,
+0x9B,0x00,0x9F,0x22,0x5F,0x24,0x09,0x23,0xFF,0x3D,0xE4,0x00,0x01,0x19,0xC3,0x40,
+0x10,0x01,0x9B,0xC2,0xFF,0x5A,0x0C,0xCC,0xCB,0xA0,0x01,0xF4,0x0F,0x7A,0x02,0x0B,
+0x99,0x00,0x4F,0x9C,0x40,0x5F,0x7C,0x1D,0x43,0x9C,0xDD,0x49,0x18,0xB8,0xCF,0x7B,
+0x01,0xF4,0x43,0x88,0xE3,0x43,0x9C,0xF0,0x8F,0x7C,0x43,0x7B,0xE8,0x0F,0x7A,0x00,
+0x9F,0x22,0xC3,0x60,0x10,0x01,0x9F,0x44,0xFF,0x7B,0x0D,0x60,0xD7,0x3B,0xFE,0x86,
+0xE4,0x00,0x00,0x8D,0xC3,0x40,0x10,0x01,0x9B,0xC2,0xFF,0x5A,0x09,0x7C,0xCB,0xA0,
+0x01,0xF4,0x0F,0x7A,0x02,0x0B,0x99,0x00,0x4F,0x9C,0x40,0x5F,0x7C,0x1D,0x43,0x9C,
+0xDD,0x49,0x18,0xB8,0xCF,0x7B,0x01,0xF4,0x43,0x88,0xE3,0x43,0x9C,0xF0,0x8F,0x7C,
+0x43,0x7B,0xE8,0x0F,0x7A,0x00,0x9F,0x22,0xC3,0x60,0x10,0x01,0x9F,0x44,0xFF,0x7B,
+0x0D,0x60,0xD7,0x3B,0xFE,0x86,0xE7,0xFF,0xF8,0x8F,0x9C,0x38,0x0D,0x21,0x04,0x0D,
+0x41,0x00,0x89,0x43,0x98,0x60,0x88,0x8A,0xE7,0xFF,0xFC,0xBA,0x88,0x8A,0x98,0x61,
+0xE7,0xFF,0xFC,0xAA,0x88,0x8A,0x0D,0x21,0x06,0x0D,0x41,0x02,0x98,0x68,0x9C,0x28,
+0xE7,0xFF,0xFC,0x8B,0x1C,0x21,0xB8,0x0D,0x41,0x40,0x0D,0xA1,0x34,0x0D,0xE1,0x2C,
+0x0E,0x01,0x28,0x0D,0x21,0x44,0xC2,0x00,0x10,0x01,0x0D,0x61,0x3C,0xFE,0x10,0x08,
+0x24,0x0D,0x81,0x38,0x0A,0xF0,0x01,0x0D,0xC1,0x30,0xC7,0x17,0x7F,0xFF,0x0E,0x21,
+0x24,0x0E,0x41,0x20,0x0E,0x61,0x1C,0x0E,0x81,0x18,0x0E,0xA1,0x14,0x0E,0xC1,0x10,
+0x0F,0x10,0x01,0xC1,0xE0,0x10,0x01,0xC1,0xA0,0x10,0x01,0xC1,0x40,0x10,0x01,0x56,
+0xF7,0x08,0xFD,0xEF,0x09,0xB6,0xFD,0xAD,0x0D,0x7C,0xFD,0x4A,0x0C,0x08,0x22,0xE1,
+0x80,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x07,0x5A,0x22,0xE5,0x54,0xC3,0x00,0x10,0x01,
+0x0A,0xEA,0x18,0xFF,0x18,0x01,0x58,0x0B,0x58,0x0E,0xD7,0x57,0x01,0x04,0xCB,0x20,
+0x07,0xFF,0x43,0x59,0xD5,0xD6,0xFA,0x00,0xAC,0x0A,0xEA,0x16,0x0B,0x18,0x0A,0xD7,
+0x17,0x00,0x5C,0x43,0x19,0xC5,0xD6,0xF8,0x01,0x40,0xE7,0xFF,0xE4,0xB4,0x9A,0xE3,
+0x0E,0xED,0x00,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0D,0x78,0xC2,0xE0,0x10,0x01,0x18,
+0x0F,0x00,0xF8,0x17,0x0A,0xF3,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x09,0xC9,0xC2,0xE0,
+0x10,0x01,0xF2,0xF7,0x0D,0x59,0x22,0xE0,0x24,0x98,0x60,0xE7,0xFF,0xC4,0xE6,0x0E,
+0xED,0x02,0x22,0xE0,0x9E,0x0A,0xF0,0x01,0x56,0xF7,0x40,0x22,0xE0,0x60,0xE7,0xFF,
+0x33,0xCA,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0A,0xF3,0x9A,0xE1,0x0E,0xED,0x00,0xE4,
+0x00,0x00,0x15,0x98,0x60,0xE7,0xFF,0xFD,0xCA,0xC2,0x40,0x10,0x01,0x0E,0xED,0x02,
+0xFE,0x52,0x09,0x88,0x22,0xE5,0x56,0x0A,0xF0,0x01,0x57,0x17,0x08,0x23,0x00,0x54,
+0xE7,0xFF,0xE3,0xC8,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0D,0x78,0x9A,0xE2,0xE4,0x00,
+0x00,0xF5,0x57,0x17,0x40,0x23,0x00,0xB4,0xC6,0xF7,0x20,0x00,0x22,0xE0,0x9A,0xC2,
+0xE0,0x10,0x01,0xF3,0x17,0x0A,0xF3,0xC3,0x00,0x19,0x0A,0x20,0x00,0x35,0x98,0x62,
+0xE7,0xFF,0xFD,0x34,0xE4,0x00,0x00,0xAF,0x9F,0x01,0xFB,0x17,0x0A,0xF3,0xE4,0x00,
+0x00,0x9B,0x0C,0x0D,0x00,0xE4,0x00,0x00,0x8D,0x22,0xE9,0x0A,0x0A,0xF0,0x01,0xC1,
+0x60,0x10,0x01,0x56,0xF7,0x08,0x22,0xE0,0xB0,0xF2,0xEB,0x0D,0x78,0x9E,0xE1,0xFA,
+0xEB,0x0D,0x78,0xE7,0xFF,0x32,0xE0,0xF2,0xEB,0x0D,0x78,0x22,0xE0,0x80,0x9A,0xE3,
+0x18,0x12,0x00,0x0E,0xED,0x00,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x0B,0xBD,0xE4,0x00,
+0x00,0x1B,0xF8,0x0B,0x0D,0x78,0x9A,0xE6,0x0E,0xED,0x00,0xC2,0x20,0x10,0x01,0xC1,
+0x80,0x10,0x01,0xC1,0x60,0x10,0x01,0x0E,0xED,0x02,0xFE,0x31,0x0C,0xD8,0xFD,0x8C,
+0x0D,0x4A,0xFD,0x6B,0x0C,0xE4,0xD2,0xE3,0x3E,0x2E,0x12,0xEA,0x00,0x22,0xE4,0x1A,
+0x18,0x12,0x00,0xE7,0xFF,0xCD,0x88,0xC3,0x00,0x10,0x01,0xC2,0xE0,0x10,0x01,0xFF,
+0x20,0x03,0xE8,0x20,0x68,0x1C,0xFF,0x20,0x01,0xF4,0xEF,0x37,0x03,0x3B,0xEF,0x38,
+0x03,0x39,0x0A,0xF0,0x01,0x56,0xF7,0x08,0xD2,0xE0,0x3C,0x5A,0xC2,0x60,0x10,0x01,
+0xC1,0xC0,0x10,0x01,0x13,0x0A,0x00,0xFE,0x73,0x03,0x36,0xFD,0xCE,0x09,0xBA,0xD3,
+0x01,0x11,0x11,0x0A,0xAC,0x04,0x0A,0xEC,0x00,0xC2,0xAF,0xFF,0xE0,0x20,0x06,0x05,
+0x09,0x2A,0x48,0x0B,0x4C,0x06,0x0A,0x8A,0x46,0x43,0x89,0xD5,0x43,0xB4,0xAD,0x0B,
+0x6C,0x02,0x0B,0x0A,0x18,0x08,0xEA,0x16,0x43,0x3B,0xC5,0x43,0xC7,0xBD,0x43,0x3D,
+0xCB,0x41,0x1C,0xF3,0x8F,0x28,0x23,0x21,0x84,0x42,0xD5,0xBD,0x40,0x9B,0xD5,0x40,
+0x7C,0xB3,0x41,0x1D,0x23,0x8C,0x68,0x20,0x60,0x40,0x24,0x60,0x28,0x27,0x20,0x2A,
+0xE4,0x00,0x00,0x8F,0x27,0x3D,0x0E,0x4C,0xB9,0xFA,0x45,0x05,0xCE,0x41,0x08,0x2D,
+0x4C,0xA3,0xFA,0x44,0x65,0x1E,0x40,0xA3,0x2D,0xD4,0xA8,0x01,0x74,0x40,0x78,0xDD,
+0x40,0x9E,0x23,0x42,0xC3,0xB3,0x8E,0xC4,0x22,0xC0,0x40,0x26,0xC0,0x28,0x27,0x20,
+0x2A,0xE4,0x00,0x00,0x2D,0x27,0x3C,0x4A,0x4F,0x36,0xFA,0x46,0xD9,0xB6,0x42,0xD6,
+0xCD,0x9B,0x21,0xD6,0xC8,0x06,0x48,0x41,0x09,0xDD,0x40,0x74,0xBD,0x40,0x87,0xAD,
+0x43,0x3A,0xC5,0x42,0xC8,0x23,0x43,0x23,0xCB,0x8F,0x36,0x23,0x20,0xE8,0x40,0xBA,
+0xDD,0x0C,0xA1,0x0C,0x42,0xB7,0xAD,0x42,0xC3,0x2B,0x40,0xC8,0xAB,0x8C,0xD6,0x20,
+0xC0,0x40,0x24,0xC0,0x28,0x27,0x20,0x2A,0xE4,0x00,0x00,0x3B,0x27,0x3C,0x66,0x4E,
+0xD9,0xFA,0x44,0xB6,0xCE,0x40,0xA5,0xB5,0x4E,0xC6,0xFA,0x44,0xD6,0x36,0x40,0xC6,
+0xB5,0xD4,0xC5,0x01,0xA0,0x43,0x78,0xDD,0x43,0xDE,0xF3,0x43,0x7B,0xDB,0x43,0x58,
+0xD5,0x40,0x84,0x23,0x43,0x5A,0xD3,0x8F,0xDB,0x8C,0x9A,0x9B,0x20,0xD4,0x9E,0x00,
+0x45,0x8B,0xC4,0x9B,0x21,0x40,0x63,0x1B,0x41,0x08,0x43,0x8D,0x03,0xD5,0x1E,0x01,
+0xC9,0xE4,0x00,0x00,0x75,0x42,0xD8,0xD5,0x0C,0xC1,0x0E,0x42,0xB6,0xAB,0x42,0xC4,
+0x33,0x8E,0xB6,0x22,0xA0,0x40,0x26,0xA0,0x28,0x27,0x20,0x2A,0xE7,0xFF,0xFF,0x73,
+0x27,0x3E,0xD6,0x4F,0x35,0xFA,0x46,0xB9,0xAE,0x42,0xB5,0xCD,0x9B,0x20,0xD6,0xA5,
+0x00,0xF0,0xE7,0xFF,0xFF,0x47,0x8B,0xC8,0x53,0x20,0x10,0x43,0xBD,0xEB,0x43,0x9C,
+0xE3,0x53,0x40,0x11,0x8F,0x9D,0x5F,0x9E,0x1F,0x4B,0x39,0xD0,0x4F,0x59,0x21,0x47,
+0x39,0xD6,0x57,0x39,0x0F,0xD3,0x20,0x41,0x32,0x0E,0x8A,0x17,0x0D,0x2A,0x19,0x0C,
+0xEA,0x47,0x0F,0x0A,0x49,0xE4,0x00,0x10,0x2D,0x12,0xF1,0x00,0x9A,0xDE,0x46,0xF7,
+0xB4,0x98,0x63,0x1A,0xF1,0x00,0xE7,0xFF,0xDB,0x92,0xE4,0x00,0x00,0xEB,0xC2,0xEF,
+0xFF,0xE4,0x20,0x01,0xB7,0x13,0x32,0x00,0x09,0x2C,0x02,0x9F,0x21,0x0B,0x6A,0x16,
+0x5F,0x39,0x00,0x41,0x1B,0xBD,0x0B,0x4A,0x18,0x0B,0xAA,0x46,0x43,0xDA,0x4D,0x42,
+0xFD,0xBD,0x0B,0x8A,0x48,0x42,0xF7,0xBB,0x41,0x3C,0x4D,0x1B,0x32,0x00,0x41,0x29,
+0x4B,0x8E,0xE9,0x41,0x08,0x43,0x43,0xDE,0xF3,0x8F,0xC8,0x5E,0xFE,0x1F,0x52,0xE0,
+0x10,0x4A,0xE0,0xB8,0x22,0xE0,0x3C,0x0F,0xAA,0x17,0x0F,0x8A,0x19,0x0F,0x6A,0x47,
+0x0F,0x4A,0x49,0xD3,0x24,0x01,0xBD,0x9F,0x1F,0x12,0xF1,0x00,0x1B,0x0A,0x00,0x9B,
+0x1C,0x46,0xF7,0xC4,0x1A,0xF1,0x00,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x09,0xB2,0x12,
+0xF3,0x00,0x1A,0xEA,0x10,0x12,0xF3,0x01,0x1A,0xEA,0x40,0xE7,0xFF,0x2D,0xB0,0x12,
+0xEA,0x00,0xD2,0xE1,0x3F,0x2E,0xE4,0x00,0x01,0xD7,0x18,0x12,0x00,0xE7,0xFF,0xFF,
+0xC5,0x23,0x07,0x7A,0x18,0x12,0x00,0x0A,0xEC,0x04,0xC2,0xEF,0xFF,0xE0,0x23,0xFF,
+0x45,0x0B,0xCA,0x16,0x0B,0xAA,0x18,0x0B,0x0C,0x00,0x0B,0x2C,0x02,0x43,0x9E,0xC5,
+0x43,0x7D,0xCD,0x43,0xDE,0xBD,0x0B,0x4C,0x06,0x43,0xDE,0xF3,0x43,0xBD,0xD5,0x43,
+0x9C,0xE3,0x43,0xBD,0xEB,0x43,0x7B,0xDB,0x8F,0xBE,0x8F,0x7C,0xD7,0xBB,0x3B,0x01,
+0xE4,0x00,0x0E,0x6D,0x0B,0x8B,0x03,0x43,0x99,0xE5,0x5F,0x9C,0x06,0x4F,0x7C,0xFA,
+0x47,0x9B,0xE6,0x43,0x7C,0xDD,0x5F,0x6D,0xD1,0x20,0x00,0xC1,0xC3,0x60,0x10,0x01,
+0x0B,0xAB,0x03,0xFF,0x9B,0x0A,0x5A,0xEF,0xBB,0x0A,0x5B,0x0B,0x6B,0x07,0x0F,0x7C,
+0x03,0xC3,0x60,0x10,0x01,0xFF,0x9B,0x0C,0xDC,0xEF,0x1B,0x0C,0xDD,0x0F,0x3C,0x03,
+0x13,0x11,0x00,0x53,0x18,0x02,0x1B,0x11,0x00,0x0B,0x0E,0x05,0x0F,0x0E,0x01,0x0B,
+0x0E,0x07,0x0F,0x0E,0x03,0x0B,0x0B,0x09,0x0F,0x0B,0x01,0x0B,0x0B,0x0B,0x0F,0x0B,
+0x03,0x0B,0x0B,0x0D,0x0E,0xEC,0x01,0x0F,0x0B,0x05,0xFE,0xE0,0x7F,0xFF,0x0B,0x0B,
+0x0F,0x0E,0xEC,0x05,0x0E,0xEC,0x07,0x0E,0xEE,0x05,0x0E,0xEE,0x07,0x0E,0xEB,0x09,
+0x0E,0xEB,0x0B,0x0F,0x0B,0x07,0x0E,0xEB,0x0D,0x0E,0xEB,0x0F,0x9B,0x01,0x12,0xF3,
+0x01,0x0F,0x4C,0x03,0x1A,0xF3,0x00,0x42,0xF8,0xBD,0x1A,0xF3,0x01,0xE7,0xFF,0xFE,
+0x05,0x0A,0xEA,0x17,0x0B,0x0C,0x01,0x43,0x18,0xBD,0x5F,0x18,0x06,0x4E,0xF8,0xFA,
+0x47,0x17,0xC6,0x42,0xF8,0xBD,0xC3,0x00,0x10,0x01,0xEB,0x38,0x03,0x38,0xD6,0xF9,
+0x01,0x2C,0x0A,0xEA,0x19,0x0B,0x0C,0x03,0x43,0x18,0xBD,0x5F,0x18,0x06,0x4E,0xF8,
+0xFA,0x47,0x17,0xC6,0x42,0xF8,0xBD,0xC3,0x00,0x10,0x01,0xEB,0x38,0x03,0x3A,0xD6,
+0xF9,0x35,0xC0,0xE7,0xFF,0x2C,0x08,0xD0,0x60,0x35,0x82,0xE7,0xFF,0xDB,0x52,0xC2,
+0xE0,0x10,0x01,0xEF,0x17,0x07,0x5A,0xD3,0x01,0x35,0x06,0xE4,0x00,0x0C,0xFB,0x9B,
+0x1E,0xEF,0x17,0x0B,0xBD,0x1E,0x6A,0x16,0x13,0x4A,0x00,0x8B,0x0C,0x8A,0xF3,0x9B,
+0x20,0xE4,0x00,0x00,0x35,0x0B,0x77,0x01,0x9F,0x21,0x0F,0x78,0x01,0x5F,0x39,0x00,
+0x0B,0x77,0x03,0x1E,0xF7,0x30,0x0F,0x78,0x03,0x9F,0x04,0xD7,0x3A,0xFF,0x56,0xC2,
+0xE0,0x10,0x01,0xEE,0xF7,0x09,0xC6,0x22,0xE4,0x26,0x9A,0x80,0xE4,0x00,0x00,0x5F,
+0xE7,0xFF,0xC5,0xCE,0x20,0x6B,0xD8,0xE7,0xFF,0xC5,0xC0,0x20,0x6C,0xAE,0xE7,0xFF,
+0xFF,0xD9,0xCC,0x94,0x00,0x30,0x88,0xD4,0x1C,0x84,0x10,0x9E,0x81,0x8C,0x8A,0x5E,
+0x94,0x00,0x1C,0x64,0x06,0x9C,0x88,0xE7,0xFF,0x58,0x98,0x10,0xAA,0x00,0xD4,0xB4,
+0xFF,0x25,0xE4,0x00,0x00,0x11,0xE7,0xFF,0x57,0xEA,0xE7,0xFF,0xC5,0x5A,0xC3,0x20,
+0x10,0x01,0xC3,0x00,0x10,0x01,0xC2,0xE0,0x10,0x01,0x20,0x68,0xB6,0x53,0x40,0x5A,
+0xEF,0x58,0x0D,0x53,0xEF,0x59,0x08,0x21,0x53,0x00,0x3C,0xEF,0x17,0x0D,0x73,0xC3,
+0x60,0x10,0x01,0xC2,0xE0,0x10,0x01,0xFE,0xDB,0x09,0xB4,0xEF,0x17,0x08,0x23,0x9A,
+0xA0,0x8A,0x96,0xE4,0x00,0x03,0x4F,0x53,0x40,0x3C,0xEF,0x58,0x0D,0x53,0xEF,0x59,
+0x08,0x21,0x53,0x00,0x28,0xE7,0xFF,0xFF,0xAD,0x4F,0x15,0x10,0x8F,0x0E,0x0B,0x38,
+0x00,0xC3,0x2F,0xFF,0xE4,0x20,0x05,0xA3,0x0B,0xB8,0x02,0xC3,0xAF,0xFF,0xE0,0x20,
+0x05,0x79,0xCF,0x15,0x00,0x30,0x8F,0x0A,0x0B,0x58,0x17,0x43,0x39,0xD5,0x5F,0x39,
+0x06,0x4F,0x59,0xFA,0x47,0x3A,0xCE,0x43,0x39,0xD5,0x0B,0x58,0x19,0x43,0x5D,0xD5,
+0x5F,0x5A,0x06,0x4F,0x1A,0xFA,0xC0,0xA0,0x10,0x01,0x47,0x58,0xD6,0x43,0x96,0xAC,
+0x43,0x5A,0xC5,0x5F,0x39,0x06,0x5F,0x5A,0x06,0xEB,0x05,0x0D,0x53,0x13,0xDC,0x00,
+0xD7,0x58,0x00,0xE4,0xC3,0x80,0x10,0x01,0xEB,0x9C,0x08,0x21,0xD7,0x3C,0x00,0x84,
+0x9B,0x83,0x27,0xC8,0x57,0x1F,0x9E,0x01,0xE4,0x00,0x00,0x19,0x9B,0x80,0x23,0xC0,
+0x24,0x1F,0x9E,0xFF,0x5F,0x9C,0x00,0x43,0xD4,0xAC,0x1B,0x9E,0x00,0x43,0x96,0xAC,
+0x13,0x9C,0x00,0xD3,0x82,0x07,0x51,0xC0,0xC0,0x10,0x01,0xEB,0x86,0x08,0x23,0xD7,
+0x5C,0x00,0x8C,0xCF,0x15,0x00,0x30,0x8F,0x0A,0x0F,0xB8,0x19,0xE4,0x00,0x00,0xB3,
+0xD7,0x58,0x02,0xAC,0x43,0xB8,0xE5,0x40,0x7A,0xE5,0x43,0xBD,0xEB,0x43,0x5C,0xD5,
+0x43,0xD8,0xC3,0x40,0x63,0xD3,0x0F,0x01,0x04,0x8C,0x7D,0x0F,0x21,0x08,0x40,0x63,
+0xF3,0x40,0x63,0xE8,0xE7,0xFF,0x27,0x70,0x4F,0x55,0x10,0x8F,0x4E,0x5C,0x63,0x06,
+0x0F,0x01,0x06,0x0B,0x9A,0x02,0x43,0x18,0x1D,0xCF,0x55,0x00,0x30,0x0F,0x21,0x0A,
+0x8F,0x4A,0x0B,0xBA,0x18,0xD7,0x9D,0x00,0x58,0x43,0x1C,0xC5,0xE4,0x00,0x00,0x0D,
+0x8F,0x1C,0x0F,0x1A,0x19,0xC3,0x00,0x10,0x01,0xEB,0x58,0x0D,0x73,0xD7,0x3A,0x00,
+0xCC,0xCF,0x15,0x00,0x30,0x4F,0x35,0x10,0x8F,0x0A,0x8F,0x2E,0x0B,0x39,0x01,0x0F,
+0x38,0x17,0xE4,0x00,0x00,0xB7,0xC3,0x00,0x10,0x01,0xEB,0x18,0x08,0x21,0xD7,0x38,
+0x02,0x7C,0x43,0x98,0xD5,0x40,0x79,0xD5,0x43,0x9C,0xE3,0x43,0x3A,0xCD,0x43,0xB8,
+0xC3,0x40,0x63,0xCB,0x0F,0x01,0x04,0x8C,0x7C,0x40,0x63,0xEB,0x40,0x63,0xE0,0xE7,
+0xFF,0x26,0x7A,0x4F,0x35,0x10,0x8F,0x2E,0x5C,0x63,0x06,0x0F,0x01,0x06,0x0B,0x59,
+0x00,0x43,0x18,0x1D,0xCF,0x35,0x00,0x30,0x8F,0x2A,0x0B,0x99,0x16,0xD7,0x5C,0x00,
+0x58,0x43,0x1A,0xC5,0xE4,0x00,0x00,0x0D,0x8F,0x1A,0x0F,0x19,0x17,0x4F,0x15,0x10,
+0xCF,0x35,0x00,0x30,0x8F,0x0E,0x8F,0x2A,0x1E,0xF5,0x01,0x0B,0x59,0x17,0x5E,0xB7,
+0x00,0x0B,0x39,0x19,0x0F,0x58,0x01,0x0F,0x38,0x03,0x13,0x0A,0x00,0xD7,0x15,0xF3,
+0x65,0xE7,0xFF,0xC1,0x8C,0x20,0x68,0x36,0x9B,0x08,0xC2,0xE0,0x10,0x01,0xEF,0x17,
+0x03,0x29,0x13,0x2A,0x00,0x1E,0xEB,0x04,0x8B,0x13,0x9B,0x40,0xD7,0x59,0x02,0x0A,
+0x0B,0x77,0x00,0xC3,0x6F,0xFF,0xE0,0x20,0x00,0x41,0x0B,0x77,0xFD,0x0F,0x77,0x01,
+0x0B,0x77,0xFF,0xE4,0x00,0x00,0x1B,0x0B,0x78,0x01,0x0F,0x77,0x01,0x0B,0x78,0x03,
+0x0F,0x77,0x03,0x0B,0x78,0x01,0x9F,0x41,0x0F,0x77,0xFD,0x5F,0x5A,0x00,0x0B,0x78,
+0x03,0x1F,0x18,0x30,0x0F,0x77,0xFF,0x9E,0xE8,0xE7,0xFF,0xFF,0x87,0xC2,0xE0,0x10,
+0x01,0x23,0x24,0x82,0x9B,0x02,0xFB,0x17,0x0A,0x5E,0xC2,0xE0,0x10,0x01,0xEA,0xF7,
+0x03,0x28,0x9B,0x4A,0x9B,0x00,0x43,0x5A,0xBD,0x9B,0x6A,0x8A,0xEB,0xE4,0x00,0x00,
+0x8F,0xF8,0x17,0x0A,0x5E,0xE7,0xFF,0xFF,0xCB,0x0B,0x97,0x04,0x0B,0xB7,0x00,0x0B,
+0xD7,0x06,0x43,0xBD,0xE5,0x9F,0x01,0x43,0xBA,0xEB,0x5F,0x18,0x00,0x43,0xBD,0xD8,
+0x8F,0xBC,0x0B,0x97,0x02,0x0F,0xB3,0x01,0x43,0x9C,0xF5,0x0F,0xB7,0x01,0x43,0x9A,
+0xE3,0x43,0x9C,0xD8,0x8F,0x9E,0x5F,0x9C,0x06,0x0F,0x93,0x03,0x0F,0x97,0x03,0x1E,
+0x73,0x30,0x9E,0xE8,0xD7,0x19,0xFE,0x2E,0x12,0xF1,0x00,0x56,0xF7,0x02,0x22,0xE0,
+0x24,0x98,0x64,0xE7,0xFF,0xD1,0x78,0x12,0xEA,0x00,0xD2,0xE1,0x05,0xCE,0xC3,0x40,
+0x10,0x01,0xC2,0xE0,0x10,0x01,0xF3,0x3A,0x03,0x3D,0xFF,0x17,0x09,0xA4,0xC3,0x20,
+0x1F,0xE4,0x20,0x00,0x61,0x0B,0x2A,0x17,0xF8,0x1A,0x03,0x3D,0xEF,0x37,0x09,0xA5,
+0x0A,0xEA,0x19,0x0E,0xF8,0x03,0xE4,0x00,0x01,0x31,0x23,0x25,0xE2,0x0B,0x4A,0x16,
+0xEB,0x37,0x09,0xA4,0x43,0x7A,0xCD,0x1F,0x7B,0x1D,0x5F,0x67,0x5B,0x20,0x01,0x29,
+0x0B,0x8A,0x18,0x0B,0xB8,0x02,0x43,0x7C,0xED,0x1F,0x7B,0x27,0x5F,0x69,0xDB,0x20,
+0x00,0xE1,0x9B,0x63,0x4F,0x39,0x08,0x8F,0x3A,0x43,0x39,0xD8,0x5F,0x39,0x06,0xEF,
+0x37,0x09,0xA5,0x0F,0x2A,0x17,0x4E,0xFD,0x08,0x0F,0x2E,0x01,0x8E,0xFC,0x0F,0x2B,
+0x01,0x42,0xF7,0xD8,0x5E,0xF7,0x06,0x0E,0xF8,0x03,0x0E,0xEA,0x19,0x0E,0xEE,0x03,
+0x0E,0xEB,0x03,0xE4,0x00,0x00,0x67,0xC2,0xE0,0x10,0x01,0xFF,0x17,0x09,0xA4,0xEF,
+0x57,0x09,0xA5,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x0C,0x21,0x0E,0xF8,0x03,0xE4,0x00,
+0x00,0x31,0x0B,0x2A,0x17,0xEF,0x37,0x09,0xA5,0x0A,0xEA,0x19,0x0E,0xF8,0x03,0xE4,
+0x00,0x00,0x1F,0x22,0xE8,0x2E,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x03,0x3D,0x13,0x0A,
+0x00,0xC2,0xE0,0x10,0x01,0x98,0x61,0xFB,0x17,0x09,0xB3,0xE7,0xFF,0xB3,0xA6,0xE4,
+0x00,0x00,0x19,0x18,0x0F,0x00,0x9A,0xE4,0x0E,0xED,0x00,0x0E,0xED,0x02,0xD2,0xE4,
+0x01,0xBE,0x0A,0xF0,0x01,0x56,0xF7,0x08,0x22,0xE0,0x5C,0x9A,0xE3,0x18,0x12,0x00,
+0x0E,0xED,0x00,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x0B,0xBD,0xE4,0x00,0x00,0x35,0x12,
+0xEF,0x00,0x9E,0xE1,0x5E,0xF7,0x00,0x1A,0xEF,0x00,0x22,0xE0,0x2C,0x9A,0xE5,0x18,
+0x0F,0x00,0x0E,0xED,0x00,0x0E,0xED,0x02,0xD2,0xE5,0x0A,0x0E,0x12,0xEF,0x00,0x9E,
+0xE1,0x1A,0xEF,0x00,0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x09,0xB3,0x22,0xE9,0x36,0x12,
+0xF1,0x00,0x56,0xF7,0x01,0x22,0xE1,0x10,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0A,0x5E,
+0xC1,0x40,0x10,0x01,0xF2,0xEA,0x09,0xB2,0x22,0xE8,0x66,0x98,0x65,0xE7,0xFF,0xCE,
+0xC4,0x98,0x61,0xE7,0xFF,0xB2,0x96,0x9A,0xE1,0xFA,0xEA,0x09,0xB2,0xE4,0x00,0x01,
+0x5D,0xD2,0xE1,0x05,0x2E,0x98,0x65,0xE7,0xFF,0xCE,0x90,0x98,0x61,0xE7,0xFF,0xB2,
+0x62,0xF8,0x0A,0x09,0xB2,0xE4,0x00,0x01,0x2D,0x0B,0x2C,0x00,0x0B,0x4B,0x00,0x43,
+0x19,0xD5,0x5F,0x18,0x06,0x4E,0xF8,0xFA,0x47,0x17,0xC6,0x42,0xF8,0xBD,0x5E,0xEC,
+0x99,0x20,0x00,0x79,0x0A,0xEB,0x03,0x0B,0x0C,0x03,0x43,0x18,0xBD,0x5F,0x18,0x06,
+0x4E,0xF8,0xFA,0x47,0x17,0xC6,0x42,0xF8,0xBD,0x5E,0xED,0xD1,0x20,0x01,0x69,0xC3,
+0x00,0x10,0x01,0xF2,0xF8,0x0A,0x5E,0x22,0xE8,0xB6,0x8F,0x3A,0x43,0x39,0xB8,0x0F,
+0x2A,0x17,0xC3,0x20,0x10,0x01,0xEB,0x59,0x0D,0x4C,0xC3,0x20,0x10,0x01,0xEB,0x39,
+0x0C,0xE6,0x8F,0x3A,0x42,0xF9,0xB8,0x0E,0xEA,0x19,0x9A,0xE1,0xFA,0xF8,0x0A,0x5E,
+0xE4,0x00,0x00,0x33,0x22,0xE4,0x8A,0x0F,0x2A,0x17,0xF8,0x18,0x0A,0x5E,0xC3,0x20,
+0x10,0x01,0xEB,0x39,0x0D,0x4D,0x0F,0x2A,0x19,0x1A,0xEA,0x00,0x98,0x61,0xE7,0xFF,
+0xB1,0x40,0xE4,0x00,0x00,0x13,0x9A,0xE3,0x1A,0xEF,0x00,0x12,0xEF,0x00,0xD2,0xE2,
+0x0B,0x11,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x0B,0xBD,0xE7,0xFF,0x20,0x12,0x9B,0x03,
+0xC2,0xE0,0x10,0x01,0xFB,0x17,0x0D,0x59,0xE7,0xFF,0xD0,0x58,0xE7,0xFF,0x4D,0xFE,
+0xC2,0xE0,0x10,0x01,0xF3,0x17,0x03,0x3D,0xC3,0x00,0x1F,0xE0,0x20,0x00,0x25,0x9B,
+0x01,0xFB,0x17,0x03,0x3D,0x98,0x60,0xE7,0xFF,0xB0,0xAE,0xC2,0xE0,0x10,0x01,0xF8,
+0x17,0x09,0xC9,0x9A,0xE6,0xE4,0x00,0x01,0x1F,0xD2,0xE6,0x08,0xBE,0x0A,0xF0,0x01,
+0x56,0xF7,0x40,0x22,0xE0,0x26,0x98,0x64,0xE7,0xFF,0xE9,0xA4,0xC3,0x00,0x10,0x01,
+0xF2,0xF8,0x09,0xC9,0x9E,0xE1,0x5E,0xF7,0x00,0xFA,0xF8,0x09,0xC9,0x5E,0xE6,0x53,
+0x0A,0xF0,0x01,0x20,0x01,0x41,0x56,0xF7,0x40,0x22,0xE0,0x50,0x9A,0xE1,0x0E,0xED,
+0x00,0xC2,0xE0,0x10,0x01,0xF8,0x17,0x0A,0xF3,0xE4,0x00,0x01,0xAF,0x0C,0x0D,0x00,
+0x0E,0xC1,0x12,0x0E,0xA1,0x16,0x0E,0x81,0x1A,0x0E,0x61,0x1E,0x0E,0x41,0x22,0x0E,
+0x21,0x26,0x0E,0x01,0x2A,0x0D,0xE1,0x2E,0x0D,0xC1,0x32,0x0D,0xA1,0x36,0x0D,0x81,
+0x3A,0x0D,0x61,0x3E,0x0D,0x41,0x42,0x0D,0x21,0x46,0x98,0x60,0x1C,0x21,0x48,0xE7,
+0xFF,0xE8,0xD7,0x56,0xF7,0x08,0xD2,0xE0,0x04,0xD2,0xC2,0xE0,0x10,0x01,0xF8,0x17,
+0x0D,0x78,0x9A,0xE2,0x0E,0xED,0x00,0xE4,0x00,0x01,0x13,0xC2,0xEF,0xFF,0xE4,0x23,
+0xDF,0xA9,0xE7,0xFF,0xF0,0xDB,0x98,0x62,0xE7,0xFF,0xCB,0x6E,0xFE,0xE0,0x7F,0xFF,
+0x0E,0xEC,0x05,0x0E,0xEC,0x07,0x0E,0xEE,0x05,0x0E,0xEE,0x07,0x0E,0xEB,0x09,0x0E,
+0xEB,0x0B,0x0E,0xEB,0x0D,0x0E,0xEB,0x0F,0xE7,0xFF,0xF0,0x8F,0x0B,0x8B,0x01,0x43,
+0x98,0xE5,0x5F,0x9C,0x06,0x4F,0x7C,0xFA,0x47,0x9B,0xE6,0x43,0x7C,0xDD,0x5F,0x6C,
+0x99,0x23,0xE2,0x4F,0xE7,0xFF,0xF1,0x51,0xFE,0xE0,0x7F,0xFF,0x18,0x0F,0x00,0x0E,
+0xEC,0x01,0x0E,0xEC,0x03,0x0E,0xEC,0x05,0x0E,0xEC,0x07,0x18,0x13,0x00,0x1B,0x13,
+0x01,0x9A,0xE5,0xE7,0xFF,0xFB,0x0B,0xC2,0xE0,0x10,0x01,0xCA,0xC0,0xFF,0xFD,0xEB,
+0x17,0x0B,0xBD,0x9F,0x01,0x5F,0x18,0x04,0xD7,0x16,0xCA,0xBD,0xE7,0xFF,0xF2,0xAB,
+0x0E,0xC1,0x12,0x0E,0xA1,0x16,0x0E,0x81,0x1A,0x0E,0x61,0x1E,0x0E,0x41,0x22,0x0E,
+0x21,0x26,0x0E,0x01,0x2A,0x0D,0xE1,0x2E,0x0D,0xC1,0x32,0x0D,0xA1,0x36,0x0D,0x81,
+0x3A,0x0D,0x61,0x3E,0x0D,0x41,0x42,0x0D,0x21,0x46,0x1C,0x21,0x48,0x85,0x29,0x9C,
+0x38,0x0D,0x21,0x04,0x0D,0x41,0x00,0x89,0x43,0x98,0x60,0x88,0x8A,0xE7,0xFF,0xE3,
+0xF0,0x88,0x8A,0x98,0x61,0xE7,0xFF,0xE3,0xE0,0x88,0x8A,0x0D,0x21,0x06,0x0D,0x41,
+0x02,0x98,0x68,0x9C,0x28,0xE7,0xFF,0xE3,0xC1,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x3D,
+0xF9,0x1C,0x21,0xC0,0x0D,0x21,0x3C,0x0D,0x41,0x38,0x0D,0x61,0x34,0x0D,0x81,0x30,
+0x0D,0xA1,0x2C,0x0D,0xC1,0x28,0x0D,0xE1,0x24,0x0E,0x01,0x20,0x0E,0x21,0x1C,0x0E,
+0x41,0x18,0x0E,0x61,0x14,0x13,0x17,0x00,0xC2,0xE0,0x10,0x01,0xFB,0x17,0x00,0xB0,
+0xF3,0x17,0x00,0xB0,0x23,0x00,0x2C,0xF2,0xF7,0x00,0xB0,0xD2,0xE1,0x29,0x4E,0xC1,
+0x80,0x10,0x01,0xFD,0x8C,0x08,0x24,0x0A,0xEC,0x01,0x56,0xF7,0x80,0xD2,0xE0,0x27,
+0x76,0xC1,0xE0,0x10,0x01,0x9B,0x00,0xFD,0xEF,0x0D,0x04,0x89,0xAF,0x8A,0xEF,0x0B,
+0x37,0x00,0x5F,0x2E,0x51,0x20,0x00,0x21,0x9F,0x01,0x5F,0x18,0x00,0xC3,0x20,0x10,
+0x01,0x9E,0xE2,0xFF,0x39,0x0D,0x44,0xD6,0xF9,0xFF,0x46,0x5F,0x02,0xB3,0xC2,0xE0,
+0x10,0x01,0x20,0x00,0x25,0x9B,0x0A,0xFB,0x17,0x0C,0xF4,0xF2,0xF7,0x0C,0xF4,0x22,
+0xE0,0x44,0x9E,0xFF,0xC3,0x00,0x10,0x01,0xFA,0xF8,0x0C,0xF4,0xE4,0x00,0x09,0x91,
+0xC1,0x40,0x10,0x01,0xC1,0xC0,0x10,0x01,0xFD,0x4A,0x01,0x58,0xFD,0xCE,0x03,0x30,
+0x88,0x6A,0x88,0x8E,0xE7,0xFF,0x31,0xFC,0xC1,0x60,0x10,0x01,0x8A,0xED,0xFD,0x6B,
+0x0C,0x08,0x53,0x20,0x14,0x12,0x2B,0x00,0x0B,0x17,0x00,0xCF,0x18,0x00,0x19,0x43,
+0x18,0xC8,0x0F,0x17,0x01,0xC3,0x00,0x10,0x01,0x9E,0xE2,0xFF,0x18,0x0D,0x44,0xD6,
+0xF8,0xFF,0x4E,0x88,0x6A,0x88,0x8E,0xE7,0xFF,0x31,0x96,0xC2,0x00,0x10,0x01,0x9B,
+0x00,0xFE,0x10,0x09,0xB3,0x22,0x20,0x4A,0x12,0xEB,0x00,0x26,0xE4,0x33,0x12,0xF0,
+0x00,0x5E,0xE0,0x01,0x4B,0x01,0x01,0x12,0xEB,0x00,0x22,0xE9,0x3E,0x12,0xF0,0x00,
+0x22,0xE5,0x4A,0x13,0x2B,0x07,0x12,0xEB,0x37,0xD7,0x37,0x02,0x4A,0x0E,0xEB,0x0A,
+0x22,0xE5,0x0A,0x0E,0xEB,0x3A,0x22,0xE4,0xF2,0xC2,0xE0,0x10,0x01,0xEE,0xF7,0x0D,
+0x7E,0x22,0xEC,0xC6,0x0A,0xEB,0x16,0xFF,0x37,0xFC,0x01,0xC2,0xE0,0x7F,0xCC,0x20,
+0x00,0x29,0xCB,0x20,0x03,0xFF,0x43,0x39,0xBD,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x0A,
+0xEF,0xD7,0x37,0x00,0xA4,0xE4,0x00,0x00,0x1B,0x22,0xE4,0x26,0x12,0xF0,0x00,0x22,
+0xE0,0x18,0x23,0x00,0xA4,0x53,0x00,0x19,0x0A,0xED,0x00,0xCE,0xF7,0x00,0x14,0x42,
+0xF7,0xC0,0x0E,0xED,0x01,0xC3,0x20,0x10,0x01,0x9D,0xA2,0xFF,0x39,0x0D,0x44,0xD5,
+0xB9,0xFF,0x4E,0x88,0x6A,0x88,0x8E,0xE7,0xFF,0x30,0x56,0x12,0xEB,0x00,0x22,0xE0,
+0x5A,0xC2,0xE0,0x10,0x01,0xEC,0x17,0x09,0xC4,0x13,0x2B,0x00,0xD3,0x20,0x09,0xE6,
+0xE4,0x00,0x02,0xAB,0x98,0x61,0x98,0x81,0x88,0xAA,0xE7,0xFF,0x22,0x26,0x9A,0xE4,
+0x88,0xCE,0x1A,0xE1,0x00,0x98,0x61,0x98,0x81,0x88,0xAA,0x98,0xE0,0x51,0x00,0x14,
+0xE7,0xFF,0x34,0x6A,0x0A,0xEA,0x14,0x0B,0x0A,0x0A,0x0B,0x2A,0x16,0x5D,0xB7,0x04,
+0x41,0xD8,0xBD,0x40,0x98,0xCD,0xCA,0xE0,0x07,0xFF,0x43,0x37,0xCD,0x0B,0x4A,0x06,
+0x0B,0x6A,0x0C,0x40,0x77,0xC5,0x5C,0xD9,0x04,0x13,0xCB,0x00,0x0B,0x2A,0x0E,0x42,
+0x38,0xD5,0x42,0x57,0xCD,0x40,0xBA,0xC5,0x40,0xF9,0xDD,0x42,0x7B,0xCD,0x1E,0xEB,
+0x18,0x9B,0xA0,0xC9,0x00,0x07,0xFF,0xE4,0x00,0x00,0xC5,0x0B,0x97,0xFE,0xD7,0x1C,
+0x00,0x98,0x43,0x9C,0xD5,0x43,0x9C,0x73,0x43,0x9C,0x88,0x8F,0x8D,0xE4,0x00,0x00,
+0x2D,0xD7,0x83,0x00,0xA8,0x43,0x88,0xE5,0x43,0x9C,0xD5,0x43,0x9C,0x23,0x43,0x9C,
+0x28,0x8F,0x86,0x0F,0x97,0xFF,0x0B,0x97,0x00,0xD7,0x3C,0x00,0x88,0x43,0x9C,0xDD,
+0x43,0x9C,0xCB,0x43,0x9C,0x38,0xE4,0x00,0x00,0x31,0xD7,0x92,0x00,0xB8,0x43,0x88,
+0xE5,0x43,0x9C,0xDD,0x43,0x9C,0xCB,0x43,0x9C,0x98,0xFF,0x9C,0x07,0xFF,0x0F,0x97,
+0x01,0x9F,0xA1,0x1E,0xF7,0x30,0x5F,0xBD,0x00,0xD7,0xBE,0xFD,0x16,0x0B,0x0A,0x16,
+0xCA,0xE0,0x07,0xFF,0x0B,0x2A,0x14,0x0B,0x4A,0x10,0x43,0x77,0xCD,0x42,0xF7,0xD5,
+0x43,0x7B,0xC5,0x0B,0x0A,0x12,0x43,0x97,0xC5,0x1E,0xEB,0x16,0x9B,0x00,0xE4,0x00,
+0x00,0x59,0x0B,0xB7,0x00,0x43,0xBD,0xCD,0xCF,0xBD,0x07,0xFF,0x43,0xBD,0xD8,0x9F,
+0x01,0x0F,0xB7,0x01,0x5F,0x18,0x00,0x0B,0xB7,0x02,0x43,0xBD,0xD5,0xCF,0xBD,0x07,
+0xFF,0x43,0xBD,0xE0,0x0F,0xB7,0x03,0x1E,0xF7,0x30,0xD7,0x1E,0xFE,0xC6,0xE7,0xFF,
+0xFD,0xA7,0xCF,0x57,0x00,0x30,0x9E,0xE1,0x8F,0x4B,0x0F,0x5A,0x0E,0xC3,0x40,0x95,
+0xEC,0x4B,0x18,0x0A,0xE4,0x00,0x00,0x11,0x9A,0xE0,0x8B,0x17,0x5F,0x57,0x00,0xD7,
+0x3A,0xFF,0x1D,0xC2,0xE0,0x10,0x01,0xEF,0x17,0x09,0xC4,0x0A,0xEC,0x01,0x52,0xF7,
+0x08,0xE4,0x00,0x00,0x33,0x9B,0x07,0xC2,0xE0,0x10,0x01,0x18,0x10,0x00,0xEF,0x17,
+0x03,0x29,0x0A,0xEC,0x01,0x9B,0x17,0x46,0xF7,0xC4,0x0E,0xEC,0x01,0xC1,0xA0,0x10,
+0x01,0xC2,0xE0,0x10,0x01,0xFD,0x4D,0x0D,0x60,0xEF,0x17,0x00,0xD2,0xD3,0x01,0x0A,
+0x86,0xE7,0xFF,0xE0,0xE6,0xC2,0xE0,0x10,0x01,0x99,0x60,0xEE,0xF7,0x07,0x5A,0x22,
+0xE5,0x6A,0xE4,0x00,0x02,0x2F,0x1C,0x61,0x09,0x88,0x8E,0x98,0xA3,0xE7,0xFF,0x73,
+0x1A,0x1E,0xE1,0x10,0x8E,0xEB,0x12,0xF7,0xF9,0x1F,0x17,0x20,0x4E,0xF7,0x08,0x4F,
+0x18,0x08,0x8E,0xF0,0x8F,0x0F,0x0A,0xF7,0x01,0x0B,0x18,0x00,0xD7,0x17,0x00,0x98,
+0x9A,0xE1,0x0B,0x0A,0x01,0x4E,0xF7,0x5C,0x46,0xF7,0xC5,0xE4,0x00,0x00,0x25,0x9A,
+0xE1,0x0B,0x0A,0x01,0x4E,0xF7,0x5C,0x46,0xF7,0xBF,0x46,0xF7,0xC4,0x9D,0x61,0x0E,
+0xEA,0x01,0x5D,0x6B,0x00,0xE4,0x00,0x00,0x31,0xC1,0xD8,0x00,0x21,0xC2,0x00,0x10,
+0x01,0xC1,0xA0,0x10,0x01,0xFD,0xCE,0xB4,0xBA,0xFE,0x10,0x03,0x2A,0xF2,0xED,0x0A,
+0x61,0xD6,0xEB,0xFC,0xAD,0x0A,0xEA,0x01,0x22,0xE0,0x34,0x0A,0xEC,0x01,0x52,0xF7,
+0x10,0xE4,0x00,0x00,0x3B,0x0A,0xEC,0x01,0x57,0x17,0x10,0x23,0x00,0x34,0x9B,0x21,
+0xC3,0x00,0x10,0x01,0xFB,0x38,0x0D,0x59,0x1F,0x20,0xEF,0x46,0xF7,0xCC,0x0E,0xEC,
+0x01,0xC1,0x40,0x10,0x01,0xC2,0xE0,0x10,0x01,0xFD,0x4A,0x09,0x9C,0xFE,0xF7,0x0A,
+0x58,0x0F,0x0A,0x02,0x23,0x00,0x52,0x18,0x17,0x00,0x0B,0x0C,0x01,0x57,0x18,0x10,
+0x23,0x00,0x20,0x9B,0x01,0x0F,0x0A,0x00,0x0F,0x0A,0x02,0x23,0x04,0x82,0x13,0x17,
+0x00,0x9F,0x01,0x5F,0x18,0x00,0x1B,0x17,0x00,0x0A,0xEC,0x01,0x56,0xF7,0x10,0x22,
+0xE0,0xDC,0x9A,0xE2,0x23,0x00,0x8A,0xE4,0x00,0x00,0x65,0x23,0x08,0x8A,0x18,0x17,
+0x00,0x0A,0xEC,0x01,0x56,0xF7,0x10,0x22,0xE0,0x34,0x98,0x62,0xE7,0xFF,0xA5,0x44,
+0xE4,0x00,0x00,0x33,0x9A,0xE3,0x0E,0xEA,0x00,0xE4,0x00,0x00,0x21,0x23,0x0C,0x32,
+0x98,0x60,0xE7,0xFF,0xA5,0x18,0x0C,0x0A,0x00,0x0B,0x0C,0x00,0xC2,0xE0,0x10,0x01,
+0x27,0x1C,0x56,0xF3,0x17,0x0A,0x60,0xD3,0x09,0x08,0x4D,0x9F,0x01,0xFB,0x17,0x0A,
+0x60,0xE4,0x00,0x01,0xFF,0xF8,0x17,0x0A,0x60,0xE4,0x00,0x01,0xF7,0xEE,0xF7,0x00,
+0xD2,0xD2,0xE2,0x07,0x9E,0x0A,0xEC,0x01,0x56,0xF7,0x40,0x22,0xE0,0x26,0x98,0x63,
+0xE7,0xFF,0xF6,0x9E,0x12,0xEB,0x00,0x22,0xE0,0x36,0x98,0x60,0x98,0x80,0x98,0xA0,
+0xE4,0x00,0x00,0x3B,0x22,0xE4,0x3E,0x08,0x6B,0x17,0x08,0x8B,0x19,0x98,0xA1,0xE4,
+0x00,0x00,0x1D,0xD2,0xE1,0x06,0x09,0x98,0x60,0x98,0x80,0x98,0xA2,0x1C,0xC1,0x0C,
+0xE7,0xFF,0xBE,0x5C,0xD0,0x61,0x05,0x86,0x0E,0xE1,0x0E,0x22,0xE0,0x2A,0x52,0xE0,
+0x58,0xE4,0x00,0x00,0xD9,0x9E,0xFF,0xD2,0xEB,0x03,0x6D,0x4E,0xF7,0x10,0xC3,0x18,
+0x00,0x21,0xFF,0x18,0xBB,0x48,0x8E,0xF8,0x0E,0xF7,0x02,0x86,0xE9,0x52,0xE0,0x60,
+0xE4,0x00,0x00,0x9B,0x52,0xE0,0x61,0xE4,0x00,0x00,0x8D,0x52,0xE0,0x62,0xE4,0x00,
+0x00,0x7F,0x52,0xE0,0x63,0xE4,0x00,0x00,0x71,0x52,0xE0,0x64,0xE4,0x00,0x00,0x63,
+0x52,0xE0,0x65,0xE4,0x00,0x00,0x55,0x52,0xE0,0x66,0xE4,0x00,0x00,0x47,0x52,0xE0,
+0x67,0xE4,0x00,0x00,0x39,0x52,0xE0,0x68,0xE4,0x00,0x00,0x2B,0x52,0xE0,0x69,0xE4,
+0x00,0x00,0x1D,0x52,0xE0,0x6A,0xE4,0x00,0x00,0x0F,0x52,0xE0,0x6B,0x0E,0xEA,0x01,
+0xE4,0x00,0x00,0x69,0x0C,0x0A,0x01,0xE4,0x00,0x00,0x5B,0xC2,0xE0,0x10,0x01,0xEE,
+0xF7,0x00,0xD2,0x22,0xE4,0x86,0x9B,0x05,0xC2,0xE0,0x10,0x01,0xEF,0x17,0x0D,0x7C,
+0x9B,0x03,0xC2,0xE0,0x10,0x01,0x98,0x60,0xFB,0x17,0x0D,0x59,0xE7,0xFF,0xA2,0xE4,
+0xE7,0xFF,0xA1,0xF2,0x0E,0x61,0x16,0x0E,0x41,0x1A,0x0E,0x21,0x1E,0x0E,0x01,0x22,
+0x0D,0xE1,0x26,0x0D,0xC1,0x2A,0x0D,0xA1,0x2E,0x0D,0x81,0x32,0x0D,0x61,0x36,0x0D,
+0x41,0x3A,0x0D,0x21,0x3E,0x1C,0x21,0x40,0x85,0x29,0x9C,0x38,0x0D,0x41,0x00,0x0D,
+0x21,0x04,0x89,0x43,0x20,0x84,0x64,0x98,0x62,0x88,0x8A,0xE7,0xFF,0xD8,0x74,0x98,
+0x62,0x88,0x8A,0xE7,0xFF,0xD8,0x64,0x98,0x69,0xE4,0x00,0x00,0x2D,0x98,0x60,0x88,
+0x8A,0xE7,0xFF,0xD8,0x48,0x98,0x61,0x88,0x8A,0xE7,0xFF,0xD8,0x38,0x98,0x68,0x88,
+0x8A,0x0D,0x21,0x06,0x0D,0x41,0x02,0x9C,0x28,0xE7,0xFF,0xD8,0x19,0x9C,0x38,0x0D,
+0x21,0x04,0x0D,0x41,0x00,0x89,0x43,0x98,0x60,0x88,0x8A,0xE7,0xFF,0xD7,0xF4,0x88,
+0x8A,0x98,0x61,0xE7,0xFF,0xD7,0xE4,0x88,0x8A,0x0D,0x21,0x06,0x0D,0x41,0x02,0x98,
+0x68,0x9C,0x28,0xE7,0xFF,0xD7,0xC5,0xD0,0x69,0x08,0x25,0x4F,0x03,0x10,0xC2,0xF8,
+0x00,0x21,0xFE,0xF7,0xBB,0x78,0x8E,0xF8,0xC3,0x20,0x10,0x01,0x0F,0x77,0x02,0xC3,
+0x40,0x10,0x01,0xC3,0x00,0x10,0x01,0xC2,0xE0,0x10,0x01,0xFF,0x39,0x08,0x70,0xFF,
+0x5A,0x09,0xCC,0xFF,0x18,0x0B,0x36,0xFE,0xF7,0x0D,0x04,0x87,0x69,0x4C,0x63,0x20,
+0x5C,0x63,0x00,0x4F,0x23,0x08,0x4C,0x63,0x10,0x8F,0x19,0x8E,0xF9,0x8F,0x43,0x9B,
+0x20,0x43,0x77,0xCC,0x43,0xB8,0xCC,0x4F,0x99,0x08,0x0B,0xBD,0x01,0x8F,0x9A,0x0F,
+0x9C,0x02,0x4F,0x9C,0x42,0x43,0x9D,0xE5,0x0F,0x9B,0x01,0x9F,0x22,0x5F,0x24,0x09,
+0x23,0xFF,0x85,0xE4,0x00,0x01,0x31,0x9C,0x7E,0x4C,0x63,0x20,0x5C,0x63,0x00,0x4F,
+0x43,0x08,0x4C,0x63,0x10,0x8F,0x1A,0x8C,0x79,0x8E,0xFA,0x9B,0x20,0x43,0x77,0xCC,
+0x43,0xB8,0xCC,0x4F,0x99,0x08,0x0B,0xBD,0x01,0x8F,0x83,0x0F,0x9C,0x02,0x4F,0x9C,
+0x42,0x43,0x9D,0xE5,0x0F,0x9B,0x01,0x9F,0x22,0x5F,0x24,0x09,0x23,0xFF,0x85,0xE4,
+0x00,0x00,0xB9,0x0B,0x78,0x41,0xEF,0x3A,0x00,0x82,0x4F,0x39,0x42,0x43,0x3B,0xCD,
+0x0B,0x78,0x43,0x0F,0x37,0x41,0xEF,0x3A,0x00,0x86,0x4F,0x39,0x42,0x43,0x3B,0xCD,
+0x0F,0x37,0x43,0xEF,0x3A,0x00,0x8A,0xE4,0x00,0x00,0x51,0xEF,0x59,0x00,0x82,0x0B,
+0x78,0x41,0x4F,0x5A,0x42,0x43,0x5B,0xD5,0x0B,0x78,0x43,0x0F,0x57,0x41,0xEF,0x59,
+0x00,0x86,0xEF,0x39,0x00,0x8A,0x4F,0x5A,0x42,0x43,0x5B,0xD5,0x0F,0x57,0x43,0x4F,
+0x39,0x42,0x0B,0x18,0x45,0x43,0x18,0xCD,0x0F,0x17,0x45,0x85,0x29,0x9C,0x38,0x0D,
+0x21,0x04,0x20,0x64,0x54,0x98,0x62,0xE7,0xFF,0xFD,0xE0,0x98,0x63,0xE7,0xFF,0xFD,
+0xD4,0x98,0x69,0xE4,0x00,0x00,0x25,0x98,0x60,0xE7,0xFF,0xFD,0xBC,0x98,0x61,0xE7,
+0xFF,0xFD,0xB0,0x98,0x68,0x0D,0x21,0x06,0x9C,0x28,0xE7,0xFF,0xFD,0x9B,0x9C,0x38,
+0x98,0x60,0x0D,0x21,0x04,0xE7,0xFF,0xFD,0x84,0x98,0x61,0xE7,0xFF,0xFD,0x78,0x0D,
+0x21,0x06,0x98,0x68,0x9C,0x28,0xE7,0xFF,0xFD,0x63,0x9C,0x38,0x0D,0x21,0x04,0xE7,
+0xFF,0xA9,0xA4,0x20,0x60,0x5E,0xE7,0xFF,0xA9,0x82,0x98,0x80,0xE7,0xFF,0xB5,0xF6,
+0xE7,0xFF,0xA9,0x6E,0x98,0x82,0xE4,0x00,0x00,0x37,0xE7,0xFF,0xA9,0x6E,0x20,0x64,
+0x86,0xE7,0xFF,0xA9,0x4C,0x98,0x81,0xE7,0xFF,0xB5,0xC0,0xE7,0xFF,0xA9,0x38,0x98,
+0x83,0xE7,0xFF,0xB3,0x18,0xE7,0xFF,0xCE,0x9E,0x9A,0xE0,0xE4,0x00,0x00,0xA1,0xE7,
+0xFF,0xA9,0x24,0x20,0x68,0x5E,0xE7,0xFF,0xA9,0x02,0x98,0x82,0xE7,0xFF,0xB5,0x76,
+0xE7,0xFF,0xA8,0xEE,0x98,0x81,0xE7,0xFF,0xFF,0xB7,0xE7,0xFF,0xA8,0xEE,0x20,0x6C,
+0x5E,0xE7,0xFF,0xA8,0xCC,0x98,0x83,0xE7,0xFF,0xB5,0x40,0xE7,0xFF,0xA8,0xB8,0x98,
+0x87,0xE7,0xFF,0xFF,0x81,0xE7,0xFF,0xA8,0xB8,0x9A,0xE0,0xD0,0x67,0x00,0x86,0xE7,
+0xFF,0xA8,0x90,0x98,0x87,0xE7,0xFF,0xB5,0x04,0x9A,0xE1,0x88,0x77,0x0D,0x21,0x06,
+0x9C,0x28,0x85,0x29,0x1C,0x21,0xE0,0x0D,0x21,0x1C,0x0D,0x41,0x18,0x0D,0x61,0x14,
+0x0D,0x81,0x10,0x0D,0xA1,0x0C,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0xE7,0xFF,
+0x99,0x9A,0x0C,0x61,0x00,0xE7,0xFF,0x99,0x94,0x0C,0x61,0x04,0x0E,0xE1,0x02,0xD2,
+0xE0,0x15,0x0A,0x0E,0xE1,0x02,0xC1,0x60,0x10,0x01,0xC1,0x40,0x10,0x01,0x57,0x17,
+0x10,0xFD,0x6B,0x00,0xD6,0xFD,0x4A,0x00,0xC4,0xD3,0x00,0x06,0x42,0x50,0x60,0x10,
+0xE7,0xFF,0x99,0x76,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x00,0xB3,0x9F,0x01,0x5F,0x18,
+0x04,0xEF,0x17,0x00,0xB3,0xE7,0xFF,0x99,0x9C,0x0A,0xEB,0x0B,0x40,0x63,0xBD,0x5E,
+0xE3,0x04,0x5E,0xE3,0xBB,0x20,0x02,0x3F,0xC2,0xE0,0x10,0x01,0xEA,0xF7,0x06,0x4B,
+0x56,0xF7,0x20,0xD2,0xE0,0x04,0x0A,0x98,0x61,0xE7,0xFF,0xB6,0x36,0x20,0x61,0xDE,
+0xE7,0xFF,0xA7,0x4E,0x20,0x64,0x56,0xC2,0xE0,0x10,0x01,0xF2,0xF7,0x00,0xB8,0x56,
+0xF7,0x01,0x22,0xE1,0x8A,0xE4,0x00,0x00,0x1F,0xE7,0xFF,0xA7,0x1C,0x20,0x63,0xA8,
+0xE4,0x00,0x00,0xA9,0xE7,0xFF,0xCB,0x92,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x06,0x4B,
+0xC7,0x18,0xFF,0xDF,0xEF,0x17,0x06,0x4B,0xE7,0xFF,0xA6,0xDE,0x20,0x60,0x5E,0x98,
+0x81,0x98,0xA0,0xE7,0xFF,0x33,0x92,0x98,0x60,0x88,0x83,0xE7,0xFF,0xB0,0xA4,0xE4,
+0x00,0x00,0x43,0x98,0x80,0x98,0x62,0xE7,0xFF,0xB0,0x8C,0xFC,0x60,0x01,0x5E,0xE7,
+0xFF,0x65,0x5C,0x98,0x60,0xE7,0xFF,0x38,0x7C,0xE7,0xFF,0x98,0x74,0x0C,0x6B,0x09,
+0xE7,0xFF,0xCB,0xE8,0x0A,0xEA,0x01,0x52,0xF7,0x10,0x0E,0xEA,0x01,0xE4,0x00,0x04,
+0x2B,0x57,0x17,0x40,0x23,0x00,0x38,0x50,0x60,0x40,0xE7,0xFF,0x97,0xE2,0xE4,0x00,
+0x04,0x09,0xC6,0xF7,0x01,0x00,0xD2,0xE0,0x0F,0xE2,0xE4,0x00,0x30,0x7C,0x89,0xA3,
+0x98,0x60,0xE7,0xFF,0x97,0x82,0xFC,0x60,0x01,0x00,0xE7,0xFF,0x97,0x82,0xFC,0x60,
+0x01,0x00,0xE7,0xFF,0x97,0x92,0xE7,0xFF,0xA5,0xE2,0xD0,0x67,0x0C,0x05,0x4E,0xE3,
+0x10,0xC3,0x18,0x00,0x21,0xFF,0x18,0xBB,0xA4,0x8E,0xF8,0x0E,0xF7,0x02,0x86,0xE9,
+0xE7,0xFF,0xA5,0xC2,0x20,0x60,0x3E,0x98,0x80,0xE7,0xFF,0xB2,0x1C,0x98,0x60,0xE4,
+0x00,0x02,0xA3,0xE7,0xFF,0xA5,0x9C,0x20,0x64,0x4E,0x98,0x60,0x98,0x81,0xE7,0xFF,
+0xB1,0xF2,0x98,0x60,0x98,0x87,0xE4,0x00,0x02,0x79,0xE7,0xFF,0xA5,0x6E,0xD0,0x67,
+0x09,0xE6,0x98,0x60,0x98,0x87,0xE4,0x00,0x02,0x1D,0xE7,0xFF,0xFB,0xA0,0xD0,0x60,
+0x09,0x62,0xE7,0xFF,0xB3,0x12,0x5D,0x83,0x04,0x98,0x61,0xE7,0xFF,0xB3,0xF2,0xD0,
+0x60,0x07,0xCE,0xC1,0x80,0x1F,0x4A,0x20,0x03,0xC5,0xE7,0xFF,0x37,0x4E,0xE7,0xFF,
+0x37,0x1E,0x5C,0x63,0x00,0x24,0x64,0x33,0x98,0x61,0xC1,0x80,0x3E,0x8A,0x20,0x01,
+0xE9,0x98,0x80,0x98,0x62,0xE7,0xFF,0xAE,0xB0,0xFC,0x60,0x01,0x5E,0xE7,0xFF,0x63,
+0x80,0x98,0x60,0xE7,0xFF,0x36,0xA0,0xE7,0xFF,0x96,0x98,0x0C,0x6B,0x09,0xE4,0x00,
+0x01,0xB1,0xE7,0xFF,0xFA,0xF0,0xD0,0x60,0x06,0xA2,0xE7,0xFF,0xB2,0x62,0xE7,0xFF,
+0x63,0xC0,0xE7,0xFF,0x64,0x50,0xD0,0x61,0x05,0x12,0xE7,0xFF,0x64,0x70,0x20,0x64,
+0xD2,0xE7,0xFF,0x36,0x30,0x5C,0x63,0x00,0xC0,0x60,0x18,0xEE,0x20,0x00,0x1D,0xE7,
+0xFF,0x36,0x3C,0xE7,0xFF,0x36,0x0C,0x98,0x80,0x5D,0x43,0x00,0x98,0x62,0xE7,0xFF,
+0xAD,0xFE,0xCC,0x6A,0x00,0x64,0xFC,0x63,0x01,0x5E,0xE7,0xFF,0x62,0xC6,0xE4,0x00,
+0x01,0x11,0xE7,0xFF,0x64,0x20,0x98,0x62,0x98,0x80,0xE4,0x00,0x00,0xF1,0xE7,0xFF,
+0xA3,0xE6,0x20,0x64,0x48,0xE7,0xFF,0xA3,0xD8,0xE7,0xFF,0xA3,0xD0,0x20,0x61,0xB6,
+0xE4,0x00,0x00,0x21,0xE7,0xFF,0xA3,0xBA,0x88,0x83,0x98,0x64,0xE4,0x00,0x00,0x71,
+0x98,0x64,0x98,0x80,0xE7,0xFF,0xB0,0x06,0x98,0x64,0xE4,0x00,0x00,0x8D,0x98,0x64,
+0x98,0x89,0xE4,0x00,0x00,0x45,0xE7,0xFF,0xA3,0x76,0x20,0x64,0x48,0xE7,0xFF,0xA3,
+0x68,0xE7,0xFF,0xA3,0x60,0x20,0x60,0xD6,0xE4,0x00,0x00,0x3D,0xE7,0xFF,0xA3,0x4A,
+0x88,0x83,0x98,0x67,0xE7,0xFF,0xAF,0xA6,0x0A,0xEA,0x01,0xCA,0xF7,0x01,0x00,0x0E,
+0xEA,0x01,0xE4,0x00,0x00,0x31,0x98,0x67,0x98,0x80,0xE7,0xFF,0xAF,0x7A,0x98,0x67,
+0x98,0x81,0xE7,0xFF,0xAC,0xD6,0xE7,0xFF,0xC8,0x5C,0x88,0x6D,0xE4,0x00,0x00,0xA5,
+0x0E,0xE1,0x06,0x22,0xE1,0x3C,0x0E,0xE1,0x06,0x56,0xF7,0x20,0x22,0xE1,0x18,0xE4,
+0x00,0x2D,0x12,0x89,0x43,0x98,0x60,0xE7,0xFF,0x94,0x18,0x50,0x60,0x20,0xE7,0xFF,
+0x94,0x22,0xE7,0xFF,0x89,0x5A,0xC2,0xE0,0x10,0x01,0xEB,0x17,0x00,0xC9,0xC7,0x18,
+0xFF,0xFE,0x50,0x60,0x20,0xEF,0x17,0x00,0xC9,0xE7,0xFF,0x93,0xFC,0xC2,0xE0,0x10,
+0x01,0x88,0x6A,0xEB,0x17,0x00,0xC7,0x53,0x18,0x20,0xEF,0x17,0x00,0xC7,0xE7,0xFF,
+0x93,0xAA,0x0D,0xA1,0x0E,0x0D,0x81,0x12,0x0D,0x61,0x16,0x0D,0x41,0x1A,0x0D,0x21,
+0x1E,0x1C,0x21,0x20,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x23,0x24,0x0B,0x17,
+0x01,0x53,0x18,0x20,0x0F,0x17,0x01,0x0C,0x63,0x02,0x0B,0x17,0x01,0xC7,0x18,0xFF,
+0xDF,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x23,0x24,0x0B,0x17,
+0x01,0x53,0x18,0x20,0x0F,0x17,0x01,0x0C,0x83,0x00,0x0B,0x17,0x01,0xC7,0x18,0xFF,
+0xDF,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x14,0x0B,0x17,
+0x01,0x53,0x18,0x01,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x23,
+0x24,0x0B,0x17,0x01,0x53,0x18,0x20,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,
+0xCA,0xF7,0x23,0x24,0x0B,0x17,0x01,0xC7,0x18,0xFF,0xDF,0x0F,0x17,0x01,0x85,0x29,
+0x9C,0x30,0x0D,0x21,0x0C,0x0D,0x41,0x08,0x0D,0x61,0x04,0x0D,0x81,0x00,0xC1,0x54,
+0x00,0x01,0xC9,0x8A,0x22,0x28,0x0A,0xEC,0x01,0xC6,0xF7,0xFF,0xFB,0xC9,0x6A,0x22,
+0x04,0x0E,0xEC,0x01,0xFF,0x00,0x80,0x00,0x0A,0xEB,0x01,0x46,0xF7,0xC5,0x5E,0xF7,
+0x04,0xC9,0x4A,0x24,0xA8,0x0E,0xEB,0x01,0x0A,0xEA,0x01,0xCA,0xF7,0x30,0x00,0x50,
+0x60,0x64,0x0E,0xEA,0x01,0xE4,0x00,0x28,0x4A,0x0A,0xEC,0x01,0x52,0xF7,0x04,0x50,
+0x60,0x1E,0x0E,0xEC,0x01,0xE4,0x00,0x28,0x2A,0x0A,0xEB,0x01,0xC6,0xF7,0x7F,0xFF,
+0x0E,0xEB,0x01,0x0A,0xEA,0x01,0xC6,0xF7,0xCF,0xFF,0x0E,0xEA,0x01,0x0D,0x81,0x02,
+0x0D,0x61,0x06,0x0D,0x41,0x0A,0x0D,0x21,0x0E,0x1C,0x21,0x10,0x85,0x29,0xC2,0xF4,
+0x00,0x01,0xCA,0xF7,0x24,0x2C,0x08,0x77,0x01,0x4C,0x63,0x09,0x54,0x63,0x1F,0x9C,
+0x61,0x85,0x29,0x9C,0x7F,0x5C,0x63,0x00,0x5C,0x62,0xFB,0x20,0x00,0x81,0xC2,0xF4,
+0x00,0x01,0x4C,0x63,0x08,0xCA,0xF7,0x24,0x2C,0x54,0x63,0x3E,0x0B,0x17,0x01,0x1F,
+0x20,0xC1,0x47,0x18,0xCC,0x44,0x63,0xC5,0x0C,0x77,0x01,0x85,0x29,0x9B,0x19,0x20,
+0x60,0x62,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x10,0x0B,0x37,0x01,0x47,0x19,0xC4,
+0x53,0x18,0x04,0xE4,0x00,0x00,0x87,0x20,0x64,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,
+0x24,0x10,0x0B,0x17,0x01,0x53,0x18,0x06,0xE4,0x00,0x00,0x5D,0x20,0x68,0x5A,0xC2,
+0xF4,0x00,0x01,0xCA,0xF7,0x24,0x10,0x0B,0x17,0x01,0xC7,0x18,0xFF,0xF9,0xE4,0x00,
+0x00,0x31,0x20,0x6C,0x5E,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x10,0x0B,0x37,0x01,
+0x47,0x19,0xC4,0x53,0x18,0x02,0x0F,0x17,0x01,0x85,0x29,0x5C,0x63,0x00,0x9C,0x30,
+0x0D,0x21,0x0C,0x0D,0x41,0x08,0x0C,0xA1,0x04,0x95,0x50,0xC9,0x4A,0x20,0x80,0x8D,
+0x43,0x4D,0x4A,0x18,0x88,0x6A,0xE7,0xFF,0xFC,0xE0,0x0C,0xA1,0x06,0x1C,0x6A,0x04,
+0x0D,0x21,0x0E,0x0D,0x41,0x0A,0x88,0x85,0x1C,0x21,0x10,0xE7,0xFF,0xFC,0xB7,0x1C,
+0x21,0xE8,0x0D,0x41,0x10,0x5D,0x44,0x00,0x4E,0xEA,0x08,0x0D,0x61,0x0C,0x0D,0x81,
+0x08,0x5D,0x65,0x00,0x5C,0x63,0x00,0x4D,0x83,0x18,0x8D,0x8B,0x8D,0x97,0x06,0xE0,
+0x81,0xCA,0xF7,0x04,0x00,0x0D,0x21,0x14,0x0D,0xA1,0x04,0xC5,0x8C,0x1F,0xFC,0x5D,
+0xA6,0x00,0x8D,0x97,0x88,0x6C,0xE7,0xFF,0xFC,0x00,0x55,0x4A,0x01,0x50,0x80,0xFF,
+0x4D,0x4A,0x08,0x8D,0x6A,0x4D,0x6B,0x18,0x4C,0x84,0x5C,0x4D,0x6D,0x5C,0x44,0x84,
+0x27,0x0D,0xA1,0x06,0x44,0x83,0x24,0x0D,0x41,0x12,0x88,0x6C,0x44,0x84,0x5D,0x0D,
+0x81,0x0A,0x0D,0x61,0x0E,0x0D,0x21,0x16,0x1C,0x21,0x18,0xE7,0xFF,0xFB,0xD7,0x5C,
+0x84,0x04,0x20,0x60,0x28,0x20,0x64,0xC2,0xE4,0x00,0x00,0x33,0x4C,0x84,0x41,0xC2,
+0xF4,0x00,0x01,0x9C,0x9F,0xCA,0xF7,0x24,0x34,0xC4,0x84,0x01,0xFF,0xE4,0x00,0x00,
+0x2B,0x4C,0x84,0x41,0xC2,0xF4,0x00,0x01,0x9C,0x9F,0xCA,0xF7,0x24,0x38,0xC4,0x84,
+0x01,0xFF,0x0C,0x97,0x01,0x85,0x29,0x07,0x00,0xFF,0xCB,0x18,0xFF,0xFF,0x20,0x60,
+0x28,0x20,0x65,0xD2,0xE4,0x00,0x00,0x7D,0xC2,0xF4,0x00,0x01,0x47,0x64,0x27,0xCB,
+0x37,0x24,0x3C,0x0B,0x59,0x01,0x47,0x5A,0xDC,0x0F,0x59,0x01,0xCA,0xF7,0x24,0x40,
+0x47,0x04,0xC4,0x0B,0x37,0x01,0x4F,0x18,0x81,0x44,0x84,0x27,0x4C,0x84,0x81,0x44,
+0x84,0xC4,0x47,0x18,0xC7,0x47,0x19,0xC4,0x47,0x04,0xC5,0x0F,0x17,0x01,0xE4,0x00,
+0x00,0x6F,0x5F,0x44,0x04,0xC2,0xF4,0x00,0x01,0x47,0x9A,0xD7,0xCB,0x37,0x24,0x3C,
+0x0B,0x79,0x01,0x47,0x7B,0xE4,0x47,0x5A,0xDD,0x0F,0x59,0x01,0xCA,0xF7,0x24,0x40,
+0x44,0x84,0xC4,0x0B,0x57,0x01,0x4C,0x84,0x81,0x47,0x24,0x27,0x47,0x1A,0xCC,0x44,
+0x84,0xC5,0x0C,0x97,0x01,0x85,0x29,0x07,0x00,0xFF,0xCB,0x18,0xFF,0xFF,0x20,0x60,
+0x28,0x20,0x65,0xD2,0xE4,0x00,0x00,0x7D,0xC2,0xF4,0x00,0x01,0x47,0x64,0x27,0xCB,
+0x37,0x24,0x1C,0x0B,0x59,0x01,0x47,0x5A,0xDC,0x0F,0x59,0x01,0xCA,0xF7,0x24,0x20,
+0x47,0x04,0xC4,0x0B,0x37,0x01,0x4F,0x18,0x81,0x44,0x84,0x27,0x4C,0x84,0x81,0x44,
+0x84,0xC4,0x47,0x18,0xC7,0x47,0x19,0xC4,0x47,0x04,0xC5,0x0F,0x17,0x01,0xE4,0x00,
+0x00,0x6F,0x5F,0x44,0x04,0xC2,0xF4,0x00,0x01,0x47,0x9A,0xD7,0xCB,0x37,0x24,0x1C,
+0x0B,0x79,0x01,0x47,0x7B,0xE4,0x47,0x5A,0xDD,0x0F,0x59,0x01,0xCA,0xF7,0x24,0x20,
+0x44,0x84,0xC4,0x0B,0x57,0x01,0x4C,0x84,0x81,0x47,0x24,0x27,0x47,0x1A,0xCC,0x44,
+0x84,0xC5,0x0C,0x97,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x24,0x80,0x0B,
+0x38,0x01,0x5F,0x23,0x04,0x0F,0x38,0x01,0x07,0x20,0xFF,0xCB,0x39,0xFF,0xFF,0xCA,
+0xF7,0x24,0x84,0x44,0x63,0xCC,0x0B,0x17,0x01,0x4C,0x63,0x81,0xFF,0x20,0xFF,0x00,
+0x47,0x18,0xCC,0x44,0x63,0xC5,0x0C,0x77,0x01,0x85,0x29,0x07,0x00,0xFF,0xCB,0x18,
+0xFF,0xFF,0x20,0x60,0x28,0x20,0x65,0xD2,0xE4,0x00,0x00,0x7D,0xC2,0xF4,0x00,0x01,
+0x47,0x64,0x27,0xCB,0x37,0x24,0x24,0x0B,0x59,0x01,0x47,0x5A,0xDC,0x0F,0x59,0x01,
+0xCA,0xF7,0x24,0x28,0x47,0x04,0xC4,0x0B,0x37,0x01,0x4F,0x18,0x81,0x44,0x84,0x27,
+0x4C,0x84,0x81,0x44,0x84,0xC4,0x47,0x18,0xC7,0x47,0x19,0xC4,0x47,0x04,0xC5,0x0F,
+0x17,0x01,0xE4,0x00,0x00,0x6F,0x5F,0x44,0x04,0xC2,0xF4,0x00,0x01,0x47,0x9A,0xD7,
+0xCB,0x37,0x24,0x24,0x0B,0x79,0x01,0x47,0x7B,0xE4,0x47,0x5A,0xDD,0x0F,0x59,0x01,
+0xCA,0xF7,0x24,0x28,0x44,0x84,0xC4,0x0B,0x57,0x01,0x4C,0x84,0x81,0x47,0x24,0x27,
+0x47,0x1A,0xCC,0x44,0x84,0xC5,0x0C,0x97,0x01,0x85,0x29,0xC3,0x14,0x00,0x01,0xCA,
+0xF8,0x22,0x08,0x20,0x64,0x3A,0x0B,0x37,0x01,0xCB,0x39,0x10,0x00,0xE4,0x00,0x00,
+0x1D,0x20,0x60,0x36,0x0B,0x37,0x01,0xC7,0x39,0xEF,0xFF,0x0F,0x37,0x01,0xCA,0xF8,
+0x22,0x08,0x0B,0x17,0x01,0xCB,0x18,0x20,0x00,0x0F,0x17,0x01,0x85,0x29,0x5C,0x84,
+0x00,0x1F,0x00,0x80,0x20,0x60,0x28,0x20,0x64,0xAA,0xE4,0x00,0x00,0x21,0xC2,0xF4,
+0x00,0x01,0xCA,0xF7,0x24,0x54,0xE4,0x00,0x00,0x19,0xC2,0xF4,0x00,0x01,0xCA,0xF7,
+0x24,0x64,0x0B,0x37,0x01,0x54,0x84,0x7F,0x47,0x19,0xC4,0x47,0x04,0xC5,0x0F,0x17,
+0x01,0x85,0x29,0x5C,0x84,0x00,0x20,0x60,0x28,0x20,0x64,0xAA,0xE4,0x00,0x00,0x21,
+0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x50,0xE4,0x00,0x00,0x19,0xC2,0xF4,0x00,0x01,
+0xCA,0xF7,0x24,0x61,0x13,0x17,0x00,0x54,0x84,0x1F,0x57,0x18,0xE0,0x44,0x84,0xC5,
+0x18,0x97,0x00,0x85,0x29,0x9C,0x30,0x0D,0x41,0x08,0x0D,0x61,0x04,0x0D,0x21,0x0C,
+0x5D,0x44,0x00,0x89,0x63,0x1C,0x8A,0xF1,0x4C,0x84,0x08,0x5C,0x83,0xF3,0x20,0x00,
+0x19,0x50,0x80,0x1F,0x88,0x6B,0xE7,0xFF,0xFF,0x5A,0x1F,0x00,0x80,0x21,0x60,0x28,
+0x21,0x64,0xAA,0xE4,0x00,0x00,0x21,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x4C,0xE4,
+0x00,0x00,0x19,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x60,0x0B,0x37,0x01,0x55,0x4A,
+0x7F,0x47,0x19,0xC4,0x47,0x0A,0xC5,0x0F,0x17,0x01,0x0D,0x61,0x06,0x0D,0x41,0x0A,
+0x0D,0x21,0x0E,0x1C,0x21,0x10,0x85,0x29,0x20,0x64,0x8E,0xC2,0xF4,0x00,0x01,0xCB,
+0x17,0x22,0x04,0xCA,0xF7,0x22,0x60,0x0B,0x38,0x01,0x53,0x39,0xF0,0x0F,0x38,0x01,
+0x0B,0x17,0x01,0xC7,0x18,0xFF,0xF0,0xE4,0x00,0x00,0x47,0x20,0x60,0x8A,0xC2,0xF4,
+0x00,0x01,0xCB,0x17,0x22,0x04,0xCA,0xF7,0x22,0x60,0x0B,0x38,0x01,0xC7,0x39,0xFF,
+0x0F,0x0F,0x38,0x01,0x0B,0x17,0x01,0x53,0x18,0x0F,0x0F,0x17,0x01,0x85,0x29,0x20,
+0x64,0x8E,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x22,0x04,0xCA,0xF7,0x22,0x60,0x0B,0x38,
+0x01,0x53,0x39,0x08,0x0F,0x38,0x01,0x0B,0x17,0x01,0xC7,0x18,0xFE,0xFF,0xE4,0x00,
+0x00,0x49,0x20,0x60,0x8E,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x22,0x04,0xCA,0xF7,0x22,
+0x60,0x0B,0x38,0x01,0xC7,0x39,0xFF,0xF7,0x0F,0x38,0x01,0x0B,0x17,0x01,0xCB,0x18,
+0x01,0x00,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,
+0x22,0x60,0x0B,0x17,0x01,0xCB,0x18,0x02,0x00,0xE4,0x00,0x00,0x2D,0x20,0x60,0x56,
+0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x22,0x60,0x0B,0x17,0x01,0xC7,0x18,0xFD,0xFF,0x0F,
+0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0x54,0x63,0x7F,0xCA,0xF7,0x24,0xA0,0x1F,
+0x20,0x80,0x0B,0x17,0x01,0x47,0x18,0xCC,0x47,0x03,0xC5,0x0F,0x17,0x01,0x85,0x29,
+0xC2,0xF4,0x00,0x01,0x4C,0x63,0x40,0xCA,0xF7,0x24,0xA0,0xC4,0x63,0x7F,0x00,0x0B,
+0x17,0x01,0xFF,0x20,0x80,0xFF,0x47,0x18,0xCC,0x47,0x03,0xC5,0x0F,0x17,0x01,0x85,
+0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0xA1,0x10,0x77,0x00,0x54,0x63,0x7F,0x85,
+0x29,0x20,0x64,0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0xA0,0x0B,0x17,0x01,0xC7,
+0x18,0xFF,0x7F,0xE4,0x00,0x00,0x2B,0x20,0x60,0x52,0xC2,0xF4,0x00,0x01,0xCA,0xF7,
+0x24,0xA0,0x0B,0x17,0x01,0x53,0x18,0x80,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x5A,
+0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0xA0,0x0B,0x17,0x01,0xC7,0x18,0x7F,0xFF,0xE4,
+0x00,0x00,0x39,0x20,0x60,0x6E,0xC2,0xF4,0x00,0x01,0xFF,0x20,0x80,0x00,0xCA,0xF7,
+0x24,0xA0,0x0B,0x17,0x01,0x47,0x18,0xCD,0x5F,0x18,0x04,0x0F,0x17,0x01,0x85,0x29,
+0xC2,0xF4,0x00,0x01,0x5C,0x63,0x00,0xCA,0xF7,0x22,0x0C,0xFF,0x20,0xFF,0x00,0x0B,
+0x17,0x01,0x47,0x18,0xCC,0x47,0x03,0xC5,0x0F,0x17,0x01,0x85,0x29,0x5C,0x63,0x04,
+0xC2,0xF4,0x00,0x01,0xFF,0x40,0xFF,0x00,0xCA,0xF7,0x22,0xF0,0x47,0x03,0xD4,0x0B,
+0x37,0x01,0x5F,0x39,0x00,0x47,0x18,0xCD,0x0F,0x17,0x01,0x85,0x29,0x5C,0x63,0x04,
+0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x22,0x38,0x0B,0x17,0x01,0x0C,0x77,0x01,0x85,0x29,
+0x20,0x64,0x6A,0xC2,0xF4,0x00,0x01,0x9B,0x3C,0xCA,0xF7,0x25,0xC0,0x0B,0x17,0x01,
+0x47,0x18,0xCC,0x53,0x18,0x01,0xE4,0x00,0x00,0x3F,0x20,0x60,0x7A,0xC2,0xF4,0x00,
+0x01,0xCB,0x17,0x22,0x38,0xCA,0xF7,0x25,0xC0,0x0B,0x38,0x01,0x0C,0x18,0x01,0x0B,
+0x17,0x01,0x53,0x18,0x03,0x0F,0x17,0x01,0x85,0x29,0x5C,0x84,0x00,0x20,0x64,0x62,
+0x4C,0x63,0x24,0xC2,0xF4,0x00,0x01,0x5C,0x63,0x04,0xCA,0xF7,0x22,0xCC,0x0C,0x77,
+0x01,0xE4,0x00,0x00,0x25,0x20,0x60,0x3A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x22,0xCC,
+0x0C,0x17,0x01,0x85,0x29,0x20,0x60,0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x22,0xE8,
+0x0B,0x17,0x01,0xC7,0x18,0xFF,0xFE,0xE4,0x00,0x00,0x2B,0x20,0x64,0x52,0xC2,0xF4,
+0x00,0x01,0xCA,0xF7,0x22,0xE8,0x0B,0x17,0x01,0x53,0x18,0x01,0x0F,0x17,0x01,0x85,
+0x29,0x20,0x60,0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x22,0xE8,0x0B,0x17,0x01,0xC7,
+0x18,0xF0,0xFF,0xE4,0x00,0x00,0x2D,0x20,0x64,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,
+0x22,0xE8,0x0B,0x17,0x01,0xCB,0x18,0x0F,0x00,0x0F,0x17,0x01,0x85,0x29,0x5C,0x63,
+0x00,0xC4,0x84,0x03,0xFF,0x20,0x64,0x70,0x20,0x60,0x34,0x20,0x68,0x88,0x20,0x6C,
+0xDA,0xE4,0x00,0x00,0x51,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x68,0xE4,0x00,0x00,
+0x49,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,0x6C,0xE4,0x00,0x00,0x31,0xC2,0xF4,0x00,
+0x01,0xCA,0xF7,0x24,0x70,0xE4,0x00,0x00,0x19,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x24,
+0x74,0x0C,0x97,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x23,0x24,0x0B,0x17,
+0x01,0x53,0x18,0x20,0x0F,0x17,0x01,0x5C,0x63,0x00,0x07,0x00,0x20,0xCB,0x18,0x41,
+0x00,0x44,0x63,0xC5,0x4C,0x63,0x10,0x0C,0x83,0x00,0x0B,0x17,0x01,0xC7,0x18,0xFF,
+0xDF,0x0F,0x17,0x01,0x85,0x29,0xFC,0x21,0xFE,0x88,0x50,0xA0,0x96,0xED,0x21,0x01,
+0x74,0xED,0x41,0x01,0x70,0xED,0x61,0x01,0x6C,0x88,0x61,0xC1,0x78,0x00,0x21,0xFD,
+0x6B,0xB4,0xBE,0x88,0x8B,0xE7,0xFF,0x53,0x0A,0xFD,0x41,0x00,0x96,0xFC,0x8B,0x00,
+0x96,0x88,0x6A,0x50,0xA0,0xD2,0xE7,0xFF,0x52,0xE8,0x8A,0xE1,0xC3,0x54,0x00,0x01,
+0xFF,0x60,0xFF,0x00,0x0B,0x37,0x01,0x47,0x19,0xDC,0x5F,0x39,0x00,0x4F,0x39,0x10,
+0x4F,0x18,0x08,0x8F,0x19,0x0B,0x37,0x03,0x47,0xB9,0xCF,0x8F,0x1A,0x0B,0x98,0x01,
+0x47,0x9C,0xEC,0x0B,0xB7,0x05,0x47,0x39,0xEC,0x47,0x3C,0xCD,0x0F,0x38,0x01,0x9E,
+0xE6,0xD5,0x57,0xFE,0x9E,0xFE,0xE1,0x00,0x96,0xFF,0x81,0x01,0x68,0x0B,0x37,0x01,
+0x47,0x19,0xDC,0x5F,0x39,0x00,0x4F,0x39,0x10,0x4F,0x18,0x08,0x8F,0x19,0x0B,0x37,
+0x03,0x47,0xD9,0xCF,0x8F,0x1A,0x0B,0xB8,0x01,0x47,0xBD,0xF4,0x0B,0xD7,0x05,0x47,
+0x39,0xF4,0x47,0x3D,0xCD,0x0F,0x38,0x01,0x9E,0xE6,0xD7,0x97,0xFE,0x9E,0xED,0x61,
+0x01,0x6E,0xED,0x41,0x01,0x72,0xED,0x21,0x01,0x76,0xFC,0x21,0x01,0x78,0x85,0x29,
+0xC2,0xF4,0x00,0x01,0xCB,0x17,0x22,0x00,0x0C,0x18,0x01,0xCA,0xF7,0x24,0x14,0xFF,
+0x20,0xFF,0x07,0x0B,0x17,0x01,0x47,0x18,0xCC,0x53,0x18,0x30,0x0F,0x17,0x01,0x85,
+0x29,0x1C,0x21,0xD8,0xC0,0x98,0x00,0x21,0x0D,0x21,0x24,0x1C,0x61,0x02,0xFC,0x84,
+0xB4,0xBE,0x50,0xA0,0x1E,0xFC,0x84,0x01,0x68,0xE7,0xFF,0x51,0x62,0xC3,0x54,0x00,
+0x01,0xCA,0xE0,0x11,0x50,0xCB,0x5A,0x22,0x00,0x57,0x37,0xFF,0x4F,0x39,0x10,0x8F,
+0x3A,0x0C,0x19,0x01,0x9E,0xE1,0xC3,0x14,0x00,0x01,0xC2,0xE2,0x2B,0x84,0x23,0xFF,
+0xAD,0xCA,0xF8,0x23,0x70,0x0C,0x17,0x01,0xCA,0xF8,0x23,0x74,0x0C,0x17,0x01,0xCB,
+0x18,0x23,0x78,0x1E,0xE1,0x02,0x0C,0x18,0x01,0x1F,0x41,0x20,0x0B,0x37,0x01,0xFF,
+0x60,0xFF,0x00,0x47,0x19,0xDC,0x5F,0x39,0x00,0x4F,0x39,0x10,0x4F,0x18,0x08,0x8F,
+0x19,0xC3,0x34,0x00,0x01,0x8F,0x19,0x0B,0x37,0x03,0x47,0x99,0xCF,0x0B,0x78,0x01,
+0x47,0x7B,0xE4,0x0B,0x97,0x05,0x47,0x39,0xE4,0x47,0x3B,0xCD,0x0F,0x38,0x01,0x9E,
+0xE6,0xD7,0x57,0xFE,0x5E,0x0D,0x21,0x26,0xFC,0x60,0x01,0xF4,0x1C,0x21,0x28,0xE4,
+0x00,0x16,0xB7,0x5C,0x84,0x00,0x9B,0x10,0x20,0x60,0x28,0x20,0x64,0xAA,0xE4,0x00,
+0x00,0x21,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x22,0x10,0xE4,0x00,0x00,0x19,0xC2,0xF4,
+0x00,0x01,0xCA,0xF7,0x22,0x14,0x0B,0x37,0x01,0x54,0x84,0x0F,0x47,0x19,0xC4,0x47,
+0x04,0xC5,0x0F,0x17,0x01,0x85,0x29,0x1C,0x21,0xE0,0xC0,0x98,0x00,0x21,0x0D,0x21,
+0x1C,0x88,0x61,0xFC,0x84,0xB4,0xBE,0x50,0xA0,0x18,0xFC,0x84,0x01,0x86,0xE7,0xFF,
+0x4F,0xB8,0x8A,0xE1,0x1F,0x41,0x18,0x0B,0x37,0x01,0xFF,0x60,0xFF,0x00,0x47,0x19,
+0xDC,0x5F,0x39,0x00,0x4F,0x39,0x10,0x4F,0x18,0x08,0x8F,0x19,0xC3,0x34,0x00,0x01,
+0x8F,0x19,0x0B,0x37,0x03,0x47,0x99,0xCF,0x0B,0x78,0x01,0x47,0x7B,0xE4,0x0B,0x97,
+0x05,0x47,0x39,0xE4,0x47,0x3B,0xCD,0x0F,0x38,0x01,0x9E,0xE6,0xD7,0x57,0xFE,0x5E,
+0xC3,0x54,0x00,0x01,0xCA,0xE0,0x11,0x50,0xCB,0x5A,0x22,0x00,0x57,0x37,0xFF,0x4F,
+0x39,0x10,0x8F,0x3A,0x0C,0x19,0x01,0x9E,0xE1,0xC3,0x14,0x00,0x01,0xC2,0xE2,0x2B,
+0x84,0x23,0xFF,0xAD,0xCA,0xF8,0x23,0x70,0x0C,0x17,0x01,0xCA,0xF8,0x23,0x74,0x0C,
+0x17,0x01,0xCB,0x18,0x23,0x78,0x0C,0x18,0x01,0x0D,0x21,0x1E,0x1C,0x21,0x20,0x85,
+0x29,0x1C,0x21,0xE0,0xC0,0x98,0x00,0x21,0x0D,0x21,0x1C,0x1C,0x61,0x06,0xFC,0x84,
+0xB4,0xBE,0x50,0xA0,0x12,0xFC,0x84,0x01,0x9E,0xE7,0xFF,0x4E,0x82,0x1E,0xE1,0x06,
+0x1F,0x41,0x18,0x0B,0x37,0x01,0xFF,0x60,0xFF,0x00,0x47,0x19,0xDC,0x5F,0x39,0x00,
+0x4F,0x39,0x10,0x4F,0x18,0x08,0x8F,0x19,0xC3,0x34,0x00,0x01,0x8F,0x19,0x0B,0x37,
+0x03,0x47,0x99,0xCF,0x0B,0x78,0x01,0x47,0x7B,0xE4,0x0B,0x97,0x05,0x47,0x39,0xE4,
+0x47,0x3B,0xCD,0x0F,0x38,0x01,0x9E,0xE6,0xD7,0x57,0xFE,0x5E,0xC3,0x74,0x00,0x01,
+0xCA,0xE0,0x11,0x50,0xCB,0x7B,0x22,0x00,0xFF,0x40,0x11,0x11,0x57,0x37,0xFF,0x4F,
+0x39,0x10,0x8F,0x3B,0x0F,0x59,0x01,0x9E,0xE1,0xC3,0x14,0x00,0x01,0xC2,0xE2,0x2B,
+0x84,0x23,0xFF,0xAD,0xCB,0x38,0x23,0x70,0x9A,0xFF,0x0E,0xF9,0x01,0xCB,0x38,0x23,
+0x74,0x0E,0xF9,0x01,0xCB,0x18,0x23,0x78,0x0E,0xF8,0x01,0x0D,0x21,0x1E,0x1C,0x21,
+0x20,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x74,0xD8,0x18,0x18,0x00,0xCB,0x37,
+0x74,0x10,0x5C,0x63,0x00,0x18,0x79,0x00,0xCB,0x37,0x76,0x30,0x18,0x19,0x00,0x53,
+0x40,0x24,0xCB,0x37,0x74,0x00,0x1B,0x59,0x00,0xCB,0x77,0x74,0x28,0x53,0x20,0x60,
+0x1B,0x3B,0x00,0xCB,0x77,0x74,0x30,0x1B,0x3B,0x00,0xCB,0x77,0x74,0x38,0x53,0x20,
+0x1C,0x1B,0x3B,0x00,0xCB,0x77,0x74,0x40,0x1B,0x3B,0x00,0xCB,0x37,0x74,0xA8,0x13,
+0x39,0x00,0xCB,0x37,0x74,0x78,0x9B,0x69,0x1B,0x79,0x00,0xCB,0x37,0x74,0x70,0x18,
+0x19,0x00,0xCB,0x37,0x74,0x60,0x13,0x79,0x00,0x1B,0x59,0x00,0xCA,0xF7,0x74,0x61,
+0x13,0x37,0x00,0x18,0x17,0x00,0x98,0x61,0x12,0xF8,0x00,0x52,0xF7,0x01,0x1A,0xF8,
+0x00,0x85,0x29,0x5C,0x63,0x00,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0x20,0x18,0x77,
+0x00,0x0B,0x17,0x01,0xC7,0x18,0xFE,0xFF,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,
+0x01,0xCA,0xF7,0x74,0x68,0x10,0x77,0x00,0x4C,0x63,0x21,0x54,0x63,0x01,0x85,0x29,
+0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0xE0,0x10,0x77,0x00,0x4C,0x63,0x09,0x54,0x63,
+0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0x68,0x10,0x77,0x00,0x4C,0x63,
+0x29,0x54,0x63,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0xE0,0x10,0x77,
+0x00,0x4C,0x63,0x19,0x54,0x63,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,
+0x68,0x10,0x77,0x00,0x4C,0x63,0x11,0x54,0x63,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,
+0xCA,0xF7,0x74,0x68,0x08,0x77,0x01,0x4C,0x63,0x49,0x54,0x63,0x01,0x85,0x29,0xC2,
+0xF4,0x00,0x01,0xCA,0xF7,0x74,0x68,0x08,0x77,0x01,0x4C,0x63,0x51,0x54,0x63,0x01,
+0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0x61,0x13,0x17,0x00,0x57,0x18,0xFD,
+0x1B,0x17,0x00,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0x61,0x13,0x17,0x00,
+0x53,0x18,0x02,0x1B,0x17,0x00,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0xC0,
+0x12,0xF7,0x00,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0xA8,0x12,0xF7,0x00,
+0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x74,0xC8,0x12,0xF7,0x00,0x85,0x29,0xC2,
+0xF4,0x00,0x01,0xCA,0xF7,0x74,0xA0,0x12,0xF7,0x00,0x85,0x29,0xC2,0xF4,0x00,0x01,
+0xCA,0xF7,0x74,0x20,0x10,0x77,0x00,0x85,0x29,0x5C,0x63,0x00,0xC3,0x14,0x00,0x01,
+0x4E,0xE3,0x10,0xCB,0x18,0x2A,0x00,0x8E,0xF8,0x08,0x77,0x00,0x9A,0xE8,0xCC,0x63,
+0x00,0x03,0x40,0x63,0xB8,0x85,0x29,0x5C,0x84,0x04,0x5E,0xE4,0x00,0xD2,0xEF,0x05,
+0xAD,0x4E,0xF7,0x10,0xC3,0x18,0x00,0x21,0xFF,0x18,0xBD,0x28,0x8E,0xF8,0xC3,0x34,
+0x00,0x01,0x0F,0x17,0x02,0xCA,0xF9,0x26,0x18,0x0B,0x57,0x01,0xC7,0x5A,0xFF,0xF3,
+0x1F,0x60,0xCF,0x0F,0x57,0x01,0x0B,0x57,0x01,0x47,0x5A,0xDC,0x53,0x5A,0x10,0x4C,
+0x84,0x49,0x0F,0x57,0x01,0x9A,0xE1,0xCB,0x59,0x26,0x20,0xE4,0x00,0x00,0x31,0x4F,
+0x37,0x08,0x9E,0xE1,0x8F,0x38,0x5E,0xF7,0x04,0x0B,0x39,0x01,0xC7,0x39,0x3F,0xFF,
+0x0F,0x3A,0x01,0xC3,0x34,0x00,0x01,0xD6,0xE4,0xFF,0x40,0x20,0x60,0x96,0xCB,0x39,
+0x26,0x38,0x0B,0x18,0x01,0x0A,0xF9,0x01,0x4F,0x18,0x60,0xFF,0x40,0x8F,0xFF,0xC7,
+0x18,0x70,0x00,0x46,0xF7,0xD4,0x46,0xF8,0xBD,0x0E,0xF9,0x01,0xE4,0x00,0x00,0x4B,
+0x20,0x64,0x86,0xCA,0xF9,0x26,0x38,0xFF,0x60,0xF8,0xFF,0x0B,0x38,0x01,0x0B,0x57,
+0x01,0x4F,0x39,0x40,0x47,0x1A,0xDC,0xC7,0x39,0x07,0x00,0x47,0x19,0xC5,0x0F,0x17,
+0x01,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x18,0x0B,0x17,0x01,0x53,0x18,0x30,0x0F,
+0x17,0x01,0x85,0x29,0x5C,0x84,0x00,0xD0,0x8F,0x03,0x9D,0xC2,0xF8,0x00,0x21,0xFE,
+0xF7,0xBC,0x50,0x4C,0x84,0x10,0xC3,0x14,0x00,0x01,0x8C,0x97,0xCB,0x38,0x26,0x34,
+0x0E,0xE4,0x02,0x0B,0x59,0x01,0x0B,0x77,0x03,0xFF,0x80,0xC0,0x00,0xC7,0x7B,0x3F,
+0xFF,0x47,0x5A,0xE4,0x47,0x5B,0xD5,0x0F,0x59,0x01,0x20,0x60,0x7E,0x0B,0x37,0x01,
+0xCB,0x18,0x26,0x38,0x4F,0x39,0x60,0x0B,0x58,0x01,0xFF,0x60,0x8F,0xFF,0xC7,0x39,
+0x70,0x00,0x46,0xFA,0xDC,0xE4,0x00,0x00,0x3F,0x20,0x64,0x86,0x0B,0x37,0x01,0xCB,
+0x18,0x26,0x38,0x4F,0x39,0x40,0x0B,0x58,0x01,0xFF,0x80,0xF8,0xFF,0xC7,0x39,0x07,
+0x00,0x46,0xFA,0xE4,0x46,0xF9,0xBD,0x0E,0xF8,0x01,0x85,0x29,0x5C,0x84,0x00,0xD0,
+0x8C,0x04,0x1D,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xBC,0x50,0x4C,0x84,0x10,0xFF,0x40,
+0xC0,0x00,0x8C,0x97,0x0E,0xE4,0x02,0x20,0x60,0xD6,0xC3,0x14,0x00,0x01,0x0B,0x77,
+0x03,0xCB,0x38,0x26,0xC4,0xC7,0x7B,0x3F,0xFF,0x0B,0x99,0x01,0x47,0x5C,0xD4,0x47,
+0x5B,0xD5,0xCB,0x18,0x26,0x38,0x0F,0x59,0x01,0x1F,0x60,0x8F,0x0B,0x37,0x01,0x0B,
+0x58,0x01,0x4F,0x39,0x20,0x57,0x39,0x70,0xE4,0x00,0x00,0x63,0x20,0x64,0xDA,0xC3,
+0x14,0x00,0x01,0x0B,0x77,0x03,0xCB,0x38,0x26,0xC8,0xC7,0x7B,0x3F,0xFF,0x0B,0x99,
+0x01,0x47,0x5C,0xD4,0x47,0x5B,0xD5,0xCB,0x18,0x26,0x38,0x0F,0x59,0x01,0x9B,0x78,
+0x0B,0x37,0x01,0x0B,0x58,0x01,0x57,0x39,0x07,0x46,0xFA,0xDC,0x46,0xF9,0xBD,0x0E,
+0xF8,0x01,0x85,0x29,0x5C,0x84,0x04,0x20,0x60,0x28,0x20,0x64,0xEE,0xE4,0x00,0x00,
+0x39,0xC2,0xF4,0x00,0x01,0x4C,0x84,0x41,0xCA,0xF7,0x26,0xC0,0x54,0x84,0x3F,0x0B,
+0x17,0x01,0x1F,0x20,0xC0,0xE4,0x00,0x00,0x2F,0xC2,0xF4,0x00,0x01,0xC4,0x84,0x3F,
+0x00,0xCA,0xF7,0x26,0xC0,0xFF,0x20,0xC0,0xFF,0x0B,0x17,0x01,0x47,0x18,0xCC,0x44,
+0x84,0xC5,0x0C,0x97,0x01,0x85,0x29,0x20,0x61,0x52,0x20,0x84,0x84,0x20,0x80,0x2C,
+0xD0,0x82,0x04,0xD6,0xE4,0x00,0x00,0x5D,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x30,
+0x0B,0x17,0x01,0xC7,0x18,0x3F,0xFF,0xE4,0x00,0x01,0x01,0xC2,0xF4,0x00,0x01,0xFF,
+0x20,0x80,0x00,0xCA,0xF7,0x26,0x30,0x0B,0x17,0x01,0xC7,0x18,0x3F,0xFF,0xE4,0x00,
+0x00,0x27,0xC2,0xF4,0x00,0x01,0xFF,0x20,0xC0,0x00,0xCA,0xF7,0x26,0x30,0x0B,0x17,
+0x01,0x47,0x18,0xCD,0x5F,0x18,0x04,0xE4,0x00,0x00,0xA1,0x20,0x65,0x3E,0x20,0x84,
+0x80,0x20,0x80,0x28,0x20,0x89,0x1A,0xE4,0x00,0x00,0x63,0xC2,0xF4,0x00,0x01,0xCA,
+0xF7,0x26,0x30,0x0B,0x17,0x01,0xC7,0x18,0xCF,0xFF,0xE4,0x00,0x00,0x5B,0xC2,0xF4,
+0x00,0x01,0xFF,0x20,0xCF,0xFF,0xCA,0xF7,0x26,0x30,0x0B,0x17,0x01,0x47,0x18,0xCC,
+0xCB,0x18,0x20,0x00,0xE4,0x00,0x00,0x27,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x30,
+0x0B,0x17,0x01,0xCB,0x18,0x30,0x00,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x72,0xC2,
+0xF4,0x00,0x01,0xFF,0x20,0x80,0x00,0xCA,0xF7,0x26,0x24,0x0B,0x17,0x01,0x47,0x18,
+0xCD,0x5F,0x18,0x04,0xE4,0x00,0x00,0x2D,0x20,0x60,0x56,0xC2,0xF4,0x00,0x01,0xCA,
+0xF7,0x26,0x24,0x0B,0x17,0x01,0xC7,0x18,0x7F,0xFF,0x0F,0x17,0x01,0x85,0x29,0x20,
+0x64,0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x24,0x0B,0x17,0x01,0xCB,0x18,0x20,
+0x00,0xE4,0x00,0x00,0x2D,0x20,0x60,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x24,
+0x0B,0x17,0x01,0xC7,0x18,0xDF,0xFF,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x5A,0xC2,
+0xF4,0x00,0x01,0xCA,0xF7,0x26,0x24,0x0B,0x17,0x01,0xCB,0x18,0x40,0x00,0xE4,0x00,
+0x00,0x2D,0x20,0x60,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x24,0x0B,0x17,0x01,
+0xC7,0x18,0xBF,0xFF,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x5A,0xC2,0xF4,0x00,0x01,
+0xCA,0xF7,0x26,0x24,0x0B,0x17,0x01,0xCB,0x18,0x10,0x00,0xE4,0x00,0x00,0x2D,0x20,
+0x60,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x24,0x0B,0x17,0x01,0xC7,0x18,0xEF,
+0xFF,0x0F,0x17,0x01,0x85,0x29,0x9C,0x38,0xC2,0xF4,0x00,0x01,0x0D,0x21,0x04,0xCA,
+0xF7,0x26,0x18,0x0B,0x17,0x01,0xCB,0x18,0x40,0x00,0x98,0x60,0x0F,0x17,0x01,0xE7,
+0xFF,0xFF,0x1A,0x0D,0x21,0x06,0x98,0x60,0x9C,0x28,0xE7,0xFF,0xFF,0x5F,0x20,0x64,
+0x72,0xC2,0xF4,0x00,0x01,0xFF,0x20,0x80,0x00,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,
+0x47,0x18,0xCD,0x5F,0x18,0x04,0xE4,0x00,0x00,0x2D,0x20,0x60,0x56,0xC2,0xF4,0x00,
+0x01,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,0xC7,0x18,0x7F,0xFF,0x0F,0x17,0x01,0x85,
+0x29,0x20,0x64,0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,0xCB,
+0x18,0x20,0x00,0xE4,0x00,0x00,0x2D,0x20,0x60,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,
+0x26,0x00,0x0B,0x17,0x01,0xC7,0x18,0xDF,0xFF,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,
+0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,0xCB,0x18,0x40,0x00,
+0xE4,0x00,0x00,0x2D,0x20,0x60,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x00,0x0B,
+0x17,0x01,0xC7,0x18,0xBF,0xFF,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x5A,0xC2,0xF4,
+0x00,0x01,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,0xCB,0x18,0x10,0x00,0xE4,0x00,0x00,
+0x2D,0x20,0x60,0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,0xC7,
+0x18,0xEF,0xFF,0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x5A,0xC2,0xF4,0x00,0x01,0xCA,
+0xF7,0x26,0x00,0x0B,0x17,0x01,0xCB,0x18,0x08,0x00,0xE4,0x00,0x00,0x2D,0x20,0x60,
+0x56,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,0xC7,0x18,0xF7,0xFF,
+0x0F,0x17,0x01,0x85,0x29,0x20,0x64,0x5A,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x26,0x00,
+0x0B,0x17,0x01,0xCB,0x18,0x04,0x00,0xE4,0x00,0x00,0x2D,0x20,0x60,0x56,0xC2,0xF4,
+0x00,0x01,0xCA,0xF7,0x26,0x00,0x0B,0x17,0x01,0xC7,0x18,0xFB,0xFF,0x0F,0x17,0x01,
+0x85,0x29,0x5C,0x63,0x00,0xC2,0xF4,0x00,0x01,0x4F,0x23,0x40,0xCA,0xF7,0x26,0x14,
+0x4C,0x63,0x60,0x0B,0x17,0x01,0x44,0x79,0x1D,0x5F,0x18,0x00,0x44,0x63,0xC5,0x5C,
+0x63,0x04,0x0C,0x77,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xFF,0x20,0xF0,0x00,0xCB,
+0x17,0x26,0x0C,0xC4,0x63,0x0F,0xFF,0x0B,0x58,0x01,0x5C,0x63,0x06,0x47,0x5A,0xCC,
+0x47,0x43,0xD5,0x0F,0x58,0x01,0xCA,0xF7,0x26,0x10,0x0B,0x17,0x01,0x47,0x38,0xCC,
+0x44,0x63,0xCD,0x0C,0x77,0x01,0x85,0x29,0x9C,0x38,0xFF,0x00,0xE0,0x00,0x0D,0x21,
+0x04,0x0D,0x41,0x00,0xC1,0x54,0x00,0x01,0xCA,0xEA,0x26,0x04,0x0B,0x37,0x01,0x47,
+0x39,0xC4,0xCB,0x39,0x0F,0xA0,0x0F,0x37,0x01,0xCA,0xEA,0x26,0x08,0x0B,0x37,0x01,
+0x47,0x19,0xC4,0xCB,0x18,0x10,0x60,0x98,0x60,0x0F,0x17,0x01,0xFC,0x80,0x08,0x03,
+0xE7,0xFF,0xF9,0x28,0xCA,0xEA,0x26,0xC0,0xFF,0x20,0xC0,0xFF,0x0B,0x17,0x01,0x47,
+0x18,0xCC,0xCB,0x18,0x08,0x00,0x98,0x60,0x0F,0x17,0x01,0xFC,0x80,0x08,0x03,0xE7,
+0xFF,0xF7,0xDA,0x98,0x61,0xFC,0x80,0x08,0x03,0xE7,0xFF,0xF7,0xC6,0xCA,0xEA,0x26,
+0x00,0x0B,0x17,0x01,0x53,0x18,0x0F,0x0F,0x17,0x01,0x0B,0x17,0x01,0xC7,0x18,0xFF,
+0x7F,0x0F,0x17,0x01,0x0B,0x17,0x01,0xC7,0x18,0xFF,0xBF,0x98,0x68,0x0F,0x17,0x01,
+0xE7,0xFF,0xFE,0x44,0x0D,0x21,0x06,0x0D,0x41,0x02,0xFC,0x60,0x01,0x2C,0x9C,0x28,
+0xE7,0xFF,0xFE,0x6F,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x78,0x00,0x0B,0x17,0x01,0x53,
+0x18,0x02,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x78,0x00,0x0B,
+0x17,0x01,0xC7,0x18,0xFF,0xFD,0x0F,0x17,0x01,0x85,0x29,0x9C,0x7F,0x5C,0x63,0x00,
+0xD0,0x64,0x05,0x15,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xBE,0xE8,0x4C,0x63,0x10,0xFF,
+0x00,0xFC,0xFF,0x8C,0x77,0xC2,0xF4,0x00,0x01,0x0F,0x23,0x02,0x87,0x29,0xCB,0x17,
+0x3D,0x3C,0xCA,0xF7,0x31,0x04,0x0B,0x38,0x01,0x53,0x39,0x01,0x0F,0x38,0x01,0x0B,
+0x17,0x01,0xC7,0x18,0xFC,0xFF,0xE4,0x00,0x00,0xD3,0xCB,0x37,0x3D,0x3C,0xCA,0xF7,
+0x31,0x04,0x0B,0x59,0x01,0x53,0x5A,0x01,0x0F,0x59,0x01,0x0B,0x37,0x01,0x47,0x19,
+0xC4,0xCB,0x18,0x01,0x00,0xE4,0x00,0x00,0x95,0xCB,0x37,0x3D,0x3C,0xCA,0xF7,0x31,
+0x04,0x0B,0x59,0x01,0x53,0x5A,0x01,0x0F,0x59,0x01,0x0B,0x37,0x01,0x47,0x19,0xC4,
+0xCB,0x18,0x02,0x00,0xE4,0x00,0x00,0x57,0xCA,0xF7,0x3D,0x3C,0x0B,0x17,0x01,0xC7,
+0x18,0xFF,0xFE,0xE4,0x00,0x00,0x39,0xCB,0x17,0x3C,0x10,0xCA,0xF7,0x3C,0x14,0x0B,
+0x38,0x01,0x53,0x39,0x01,0x0F,0x38,0x01,0x0B,0x17,0x01,0xC7,0x18,0xFF,0xFD,0x0F,
+0x17,0x01,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x78,0x00,0x0B,0x17,0x01,0xC7,0x18,0xFF,
+0xFB,0x0F,0x17,0x01,0x85,0x29,0x5C,0x63,0x00,0x5C,0x84,0x00,0x9A,0xE0,0x24,0x64,
+0x43,0xC2,0xF8,0x00,0x21,0xFE,0xF7,0xBE,0xFC,0x8C,0x77,0x12,0xE3,0x00,0xC3,0x14,
+0x00,0x01,0xCB,0x18,0x78,0x01,0x4E,0xF7,0x10,0x5C,0x80,0x29,0x46,0xF7,0xC5,0x4B,
+0x00,0x1A,0x1B,0x17,0x00,0x85,0x29,0xC2,0xF4,0x00,0x01,0x5C,0x84,0x04,0xCB,0x17,
+0x79,0x04,0xCC,0x84,0x17,0x70,0x4F,0x24,0x81,0x5C,0x84,0x04,0x0F,0x38,0x01,0xCA,
+0xF7,0x79,0x00,0x0C,0x97,0x01,0x98,0x81,0xE7,0xFF,0xFF,0x5D,0xC2,0xF4,0x00,0x01,
+0xCA,0xF7,0x78,0xCC,0x0B,0x17,0x01,0x53,0x18,0x02,0x0F,0x17,0x01,0x85,0x29,0xC2,
+0xF4,0x00,0x01,0xCB,0x17,0x7A,0x30,0xCB,0x37,0x7A,0x34,0xCB,0x57,0x7A,0x10,0xCA,
+0xF7,0x7A,0x14,0x0B,0x18,0x01,0x0B,0x39,0x01,0x0B,0x5A,0x01,0x08,0x77,0x01,0x4E,
+0xF9,0x80,0x4C,0x63,0x80,0x8E,0xF8,0x8C,0x7A,0x44,0x63,0x1F,0x44,0x63,0xBC,0x85,
+0x29,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x7A,0x70,0xCB,0x37,0x7A,0x74,0xCB,0x57,0x7A,
+0x50,0xCA,0xF7,0x7A,0x54,0x0B,0x18,0x01,0x0B,0x39,0x01,0x0B,0x5A,0x01,0x08,0x77,
+0x01,0x4E,0xF9,0x80,0x4C,0x63,0x80,0x8E,0xF8,0x8C,0x7A,0x44,0x63,0x1F,0x44,0x63,
+0xBC,0x85,0x29,0x5C,0x63,0x06,0xC2,0xF4,0x00,0x01,0x47,0x23,0x1F,0xCA,0xF7,0x7A,
+0x10,0x0B,0x17,0x01,0x47,0x19,0xC4,0x44,0x63,0xC5,0x5C,0x63,0x04,0x0C,0x77,0x01,
+0x85,0x29,0x5C,0x63,0x06,0xC2,0xF4,0x00,0x01,0x47,0x23,0x1F,0xCA,0xF7,0x7A,0x50,
+0x0B,0x17,0x01,0x47,0x19,0xC4,0x44,0x63,0xC5,0x5C,0x63,0x04,0x0C,0x77,0x01,0x85,
+0x29,0xC2,0xF4,0x00,0x01,0x44,0x63,0x1F,0xCA,0xF7,0x7A,0x10,0x0B,0x17,0x01,0x47,
+0x18,0x1C,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0x44,0x63,0x1F,0xCA,0xF7,
+0x7A,0x50,0x0B,0x17,0x01,0x47,0x18,0x1C,0x0F,0x17,0x01,0x85,0x29,0x5C,0x63,0x04,
+0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x7A,0x30,0x0C,0x77,0x01,0x85,0x29,0x9B,0x01,0xC2,
+0xF4,0x00,0x01,0xCA,0xF7,0x7A,0x70,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,
+0xFF,0x20,0xAA,0x55,0xCB,0x17,0x78,0xC0,0x0F,0x38,0x01,0x5F,0x03,0x04,0x27,0x08,
+0x17,0x98,0x63,0xCA,0xF7,0x78,0xC4,0x5C,0x63,0x04,0xCB,0x00,0x03,0xE8,0x43,0x04,
+0xC1,0x40,0x63,0xC3,0x4C,0x63,0x81,0x44,0x63,0x1F,0x0C,0x77,0x01,0x06,0xE0,0x5B,
+0xCA,0xF7,0x8D,0x80,0x5C,0x97,0x0D,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x3C,0x44,0x0B,
+0x17,0x01,0x20,0x00,0x2D,0xC7,0x18,0xFF,0xBF,0xE4,0x00,0x00,0x15,0x5F,0x18,0x04,
+0x53,0x18,0x40,0x0F,0x17,0x01,0x85,0x29,0xFF,0x00,0xAA,0x55,0xC2,0xF4,0x00,0x01,
+0xCA,0xF7,0x78,0xC0,0x0F,0x17,0x01,0x85,0x29,0xFF,0x00,0x55,0xAA,0xC2,0xF4,0x00,
+0x01,0xCA,0xF7,0x78,0xC0,0x0F,0x17,0x01,0x85,0x29,0xCA,0xE0,0x03,0x20,0xC3,0x14,
+0x00,0x01,0x5C,0x63,0x04,0xC0,0x60,0x63,0xEA,0x48,0x63,0xB8,0xCA,0xF8,0x79,0x10,
+0x0B,0x37,0x01,0x53,0x39,0x01,0x0F,0x37,0x01,0xCB,0x58,0x79,0x00,0xCB,0x38,0x79,
+0x08,0x9C,0x38,0x0A,0xF9,0x01,0xCB,0x18,0x3C,0x44,0x0B,0x7A,0x01,0x0B,0x39,0x01,
+0x0F,0x21,0x07,0x0B,0x18,0x01,0x57,0x18,0x40,0x5F,0x18,0x04,0x23,0x00,0x40,0x4C,
+0x63,0x29,0x5C,0x60,0x09,0x48,0x63,0x0A,0xE4,0x00,0x00,0x3F,0xCC,0x63,0x00,0x06,
+0x5C,0x63,0x04,0xE4,0x00,0x00,0x29,0x0A,0xF8,0x01,0x52,0xF7,0x01,0x0E,0xF8,0x01,
+0x0A,0xF9,0x01,0xE4,0x00,0x00,0x21,0xC3,0x34,0x00,0x01,0xCB,0x19,0x79,0x10,0xCB,
+0x39,0x79,0x08,0x0B,0x41,0x07,0x43,0x57,0xD5,0xD4,0x7A,0x00,0xB8,0x0B,0x41,0x07,
+0xD7,0x57,0xFE,0xB9,0x0B,0x41,0x07,0x43,0x5B,0xD5,0x8E,0xFA,0xD4,0x77,0xFE,0x5C,
+0x9C,0x28,0x85,0x29,0x5C,0x63,0x04,0xE4,0x00,0x00,0x2D,0x42,0xE4,0x2C,0xC3,0x38,
+0x00,0x01,0x43,0x05,0xCC,0x8F,0x03,0x13,0x18,0x00,0x1B,0x17,0x00,0x9C,0xBF,0x20,
+0xBF,0xB2,0x85,0x29,0xC3,0x14,0x00,0x01,0x5C,0x63,0x00,0xCA,0xF8,0x2C,0x30,0x20,
+0x60,0xBE,0x0B,0x17,0x01,0xCB,0x18,0x02,0x00,0x0F,0x17,0x01,0x80,0x01,0xC2,0xF4,
+0x00,0x01,0xCB,0x17,0x3C,0x44,0xCA,0xF7,0x3C,0xA8,0x0B,0x38,0x01,0xC7,0x39,0xFF,
+0xF3,0x0F,0x38,0x01,0x0B,0x17,0x01,0x53,0x18,0x01,0xE4,0x00,0x00,0xB3,0x0B,0x37,
+0x01,0xCB,0x39,0x02,0x00,0x0F,0x37,0x01,0xCA,0xF8,0x3C,0xA8,0x0B,0x37,0x01,0x53,
+0x39,0x01,0xCB,0x18,0x3C,0x5C,0x0F,0x37,0x01,0x1E,0xE0,0xC0,0x0B,0x38,0x00,0x47,
+0x39,0xBC,0x9A,0xE2,0x24,0x64,0x25,0x54,0x63,0x3F,0x5E,0xE3,0x06,0x46,0xF7,0xCD,
+0x5C,0x77,0x04,0xC2,0xF4,0x00,0x01,0x0C,0x78,0x01,0xCB,0x17,0x3C,0xA8,0xCA,0xF7,
+0x2C,0x30,0x0B,0x38,0x01,0xC7,0x39,0xFF,0xFE,0x0F,0x38,0x01,0x0B,0x17,0x01,0xCB,
+0x18,0x01,0x00,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x3C,0xA8,
+0x0B,0x18,0x01,0x57,0x18,0x01,0x23,0x00,0x46,0xCA,0xF7,0x3C,0x5C,0x08,0x77,0x01,
+0x54,0x63,0x3F,0xE4,0x00,0x00,0x0D,0x98,0x60,0x85,0x29,0x80,0x01,0xC2,0xF4,0x00,
+0x01,0xCA,0xF7,0x1E,0xB0,0x0B,0x17,0x01,0x53,0x18,0x03,0x0F,0x17,0x01,0x80,0x01,
+0x9B,0x1F,0xCA,0xE0,0x48,0x00,0xC3,0x17,0x00,0x0D,0xCA,0xE0,0x48,0x04,0xC3,0x17,
+0x00,0x0D,0x80,0x01,0xCA,0xE0,0x40,0x00,0xC3,0x17,0x00,0x0F,0x53,0x18,0x40,0xC3,
+0x17,0x00,0x0D,0xC3,0x17,0x00,0x0F,0x1F,0x20,0xBF,0x47,0x18,0xCC,0xC3,0x17,0x00,
+0x0D,0x85,0x29,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x3D,0x80,0x0B,0x38,0x01,0xCB,0x39,
+0x08,0x00,0x0F,0x38,0x01,0xCA,0xF7,0x3D,0x84,0x0B,0x17,0x01,0xCB,0x18,0x08,0x00,
+0x0F,0x17,0x01,0x85,0x29,0xE7,0xFF,0xFF,0xBD,0x56,0xE3,0xFF,0x4E,0xF7,0x08,0x5C,
+0x84,0x04,0xC4,0x63,0xFF,0x00,0x8C,0x77,0xC2,0xF4,0x00,0x01,0x4C,0x63,0x08,0x8C,
+0x77,0x0C,0x83,0x01,0x85,0x29,0x1C,0x21,0xC8,0xC0,0x98,0x00,0x21,0x0D,0x21,0x34,
+0x1C,0x61,0x06,0xFC,0x84,0xB6,0x6E,0x50,0xA0,0x2A,0xE7,0xFF,0x35,0x80,0x1E,0xE1,
+0x06,0x1F,0x41,0x30,0x0B,0x37,0x01,0xFF,0x60,0xFF,0x00,0x47,0x19,0xDC,0x5F,0x39,
+0x00,0x4F,0x39,0x10,0x4F,0x18,0x08,0x8F,0x19,0xC3,0x34,0x00,0x01,0x8F,0x19,0x0B,
+0x37,0x03,0x47,0x99,0xCF,0x0B,0x78,0x01,0x47,0x7B,0xE4,0x0B,0x97,0x05,0x47,0x39,
+0xE4,0x47,0x3B,0xCD,0x0F,0x38,0x01,0x9E,0xE6,0xD7,0x57,0xFE,0x5E,0x0D,0x21,0x36,
+0x1C,0x21,0x38,0x85,0x29,0xFC,0x21,0xFF,0x38,0x50,0xA0,0x3C,0xED,0x21,0x00,0xC4,
+0xED,0x41,0x00,0xC0,0xED,0x61,0x00,0xBC,0xED,0x81,0x00,0xB8,0xED,0xA1,0x00,0xB4,
+0xED,0xC1,0x00,0xB0,0xED,0xE1,0x00,0xAC,0xEE,0x01,0x00,0xA8,0xC1,0x58,0x00,0x21,
+0x1C,0x61,0x6C,0xFD,0x4A,0xB6,0x6E,0x1C,0x8A,0x2A,0xE7,0xFF,0x34,0x80,0x50,0xA0,
+0x24,0x1C,0x8A,0x66,0x1C,0x61,0x48,0xE7,0xFF,0x34,0x66,0x98,0x61,0x98,0x82,0xE7,
+0xFF,0xEE,0x30,0x98,0x61,0xFC,0x80,0x28,0x0A,0xE7,0xFF,0xD5,0x4C,0x98,0x61,0xFC,
+0x80,0x28,0x0A,0xE7,0xFF,0xEB,0x82,0x98,0x61,0x88,0x83,0xE7,0xFF,0xD8,0x00,0x98,
+0x61,0x88,0x83,0xE7,0xFF,0xD5,0x88,0x98,0x60,0x98,0x81,0xE7,0xFF,0xD6,0x78,0x98,
+0x60,0x05,0x4F,0x0F,0xC9,0x4A,0x0F,0x0F,0x88,0x8A,0xE7,0xFF,0xE0,0x38,0x98,0x61,
+0x88,0x8A,0xE7,0xFF,0xE0,0x28,0xC3,0x54,0x00,0x01,0xCA,0xE0,0x11,0x50,0xCB,0x5A,
+0x22,0x00,0x57,0x17,0xFF,0x4F,0x18,0x10,0x8F,0x1A,0x1F,0x61,0x2A,0x0B,0x38,0x01,
+0x4F,0x17,0x08,0x8F,0x1B,0xEF,0x38,0xDD,0x61,0x9E,0xE1,0xC2,0xE2,0x2B,0xE4,0x23,
+0xFF,0x8D,0x1E,0xE1,0x6C,0xFF,0x41,0x00,0xA8,0xC1,0x94,0x00,0x01,0xFD,0xA0,0xFF,
+0x00,0x0B,0x37,0x01,0x47,0x19,0x6C,0x5F,0x39,0x00,0x4F,0x39,0x10,0x4F,0x18,0x08,
+0x8F,0x19,0x0B,0x37,0x03,0x8F,0x0C,0x0F,0x38,0x01,0x9E,0xE4,0xD7,0x57,0xFF,0x2E,
+0x1E,0xE1,0x48,0x1F,0x41,0x6C,0x0B,0x37,0x01,0x47,0x19,0x6C,0x5F,0x39,0x00,0x4F,
+0x39,0x10,0x4F,0x18,0x08,0x8F,0x19,0x0B,0x37,0x03,0x8F,0x0C,0x0F,0x38,0x01,0x9E,
+0xE4,0xD7,0x57,0xFF,0x2E,0xE7,0xFF,0xD1,0x52,0x99,0xE0,0x89,0xC3,0x98,0x61,0xE7,
+0xFF,0xD1,0x68,0xD1,0xE0,0x05,0xBE,0x98,0x60,0x1D,0x61,0x0A,0xE7,0xFF,0xD1,0xA2,
+0x99,0x40,0xE4,0x00,0x01,0x45,0x98,0x61,0x88,0x8A,0x22,0x01,0x0A,0xE7,0xFF,0xDD,
+0x3A,0x98,0x60,0xE7,0xFF,0xDD,0x84,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF7,0x2C,0xE7,
+0xFF,0xCF,0x6E,0xE7,0xFF,0xF5,0xD8,0xC4,0x63,0x01,0x00,0x20,0x63,0xE0,0xFC,0x60,
+0x01,0x00,0xE7,0xFF,0xF6,0x82,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF7,0x46,0x88,0x6A,
+0x98,0x81,0x98,0xA0,0xE7,0xFF,0xE7,0xAA,0xE4,0x00,0x00,0x8B,0xE7,0xFF,0xDC,0xBC,
+0x98,0x61,0xE7,0xFF,0xDD,0x06,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF6,0xAE,0xE7,0xFF,
+0xCE,0xF0,0xE7,0xFF,0xF5,0x5A,0xC4,0x63,0x01,0x00,0x20,0x63,0xE0,0xFC,0x60,0x01,
+0x00,0xE7,0xFF,0xF6,0x04,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF6,0xC8,0x88,0x6A,0x98,
+0x81,0x98,0xA0,0xE7,0xFF,0xE7,0x2C,0x0A,0xEB,0x01,0x40,0x63,0xBD,0x0C,0x6B,0x01,
+0x9E,0x01,0x5E,0x10,0x00,0xD2,0x02,0xFB,0x8E,0x9D,0x41,0x9D,0x62,0x5D,0x4A,0x00,
+0xD1,0x44,0x05,0xEA,0x9A,0x00,0xE7,0xFF,0xFE,0xC1,0x98,0x61,0x1D,0x61,0x12,0xE7,
+0xFF,0xD0,0x3C,0x99,0x40,0xE4,0x00,0x01,0x45,0x98,0x61,0x88,0x8A,0x22,0x01,0x0A,
+0xE7,0xFF,0xDB,0xD4,0x98,0x60,0xE7,0xFF,0xDC,0x1E,0xFC,0x60,0x01,0x00,0xE7,0xFF,
+0xF5,0xC6,0xE7,0xFF,0xCE,0x08,0xE7,0xFF,0xF4,0x72,0xC4,0x63,0x01,0x00,0x20,0x63,
+0xE0,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF5,0x1C,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF5,
+0xE0,0x88,0x6A,0x98,0x81,0x98,0xA0,0xE7,0xFF,0xE6,0x44,0xE4,0x00,0x00,0x8B,0xE7,
+0xFF,0xDB,0x56,0x98,0x61,0xE7,0xFF,0xDB,0xA0,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF5,
+0x48,0xE7,0xFF,0xCD,0x8A,0xE7,0xFF,0xF3,0xF4,0xC4,0x63,0x01,0x00,0x20,0x63,0xE0,
+0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF4,0x9E,0xFC,0x60,0x01,0x00,0xE7,0xFF,0xF5,0x62,
+0x88,0x6A,0x98,0x81,0x98,0xA0,0xE7,0xFF,0xE5,0xC6,0x0A,0xEB,0x01,0x40,0x63,0xBD,
+0x0C,0x6B,0x01,0x9E,0x01,0x5E,0x10,0x00,0xD2,0x02,0xFB,0x8E,0x9D,0x41,0x9D,0x62,
+0x5D,0x4A,0x00,0xD1,0x44,0x00,0x52,0x9A,0x00,0xE7,0xFF,0xFE,0xC1,0x9D,0xE1,0x5D,
+0xEF,0x00,0xD1,0xE2,0xF4,0x8E,0x0B,0x21,0x0A,0x0B,0x01,0x12,0x0F,0x21,0x07,0x1E,
+0xE1,0x0C,0x1F,0x81,0x12,0x0B,0x77,0x01,0x8B,0x59,0x5F,0xBB,0x06,0xD7,0x3D,0x00,
+0x30,0x8B,0x5B,0x5F,0x3A,0x06,0x0B,0x77,0x09,0x8B,0x58,0x5F,0xBB,0x06,0xD7,0x1D,
+0x00,0x30,0x8B,0x5B,0x5F,0x1A,0x06,0x9E,0xE2,0xD7,0x97,0xFE,0xE6,0x0F,0x21,0x07,
+0x9A,0xE0,0x0F,0x01,0x09,0x1F,0x21,0x1A,0x8B,0x57,0xFD,0x00,0x3F,0xFF,0xE4,0x00,
+0x00,0x69,0x43,0x7E,0xC4,0x0B,0x9B,0x00,0x43,0x79,0xC4,0x23,0x80,0x32,0x0D,0x1B,
+0x01,0x9B,0x41,0xE4,0x00,0x00,0x23,0x09,0x5D,0x00,0xCD,0x4A,0x1F,0xFF,0x43,0x8A,
+0xE0,0x0F,0x9B,0x01,0x9F,0x02,0xD3,0x08,0xFE,0xE6,0x9F,0x28,0x9E,0xE2,0xD2,0xE4,
+0x00,0xBA,0x1F,0x01,0x0A,0x4F,0xD7,0x10,0x1F,0xA1,0x06,0x8F,0xD8,0x8F,0xB7,0x9B,
+0x00,0xE7,0xFF,0xFF,0x83,0xC3,0x94,0x00,0x01,0x9A,0xE0,0xCB,0x9C,0x24,0x00,0xE4,
+0x00,0x00,0x47,0x43,0xB9,0xC4,0x43,0xDB,0xC4,0x57,0xBD,0xFF,0x0B,0xDE,0x01,0x4F,
+0xBD,0x10,0x8F,0xBC,0x0F,0xDD,0x01,0x9F,0x02,0xD3,0x08,0xFF,0x56,0x9E,0xE1,0x22,
+0xE8,0x54,0x1F,0x21,0x1A,0x4F,0x77,0x18,0x9B,0x00,0x8F,0x79,0xFF,0x37,0x12,0x46,
+0xE7,0xFF,0xFF,0xA7,0x9A,0xE0,0x4F,0x17,0x08,0x1F,0x61,0x6C,0x8F,0x1B,0x0B,0x38,
+0x01,0x47,0x19,0x6C,0x5F,0x39,0x00,0x4F,0x39,0x10,0x4F,0x18,0x08,0x8F,0x19,0x1F,
+0x21,0x2A,0x8F,0x0C,0x8F,0x37,0x0B,0x39,0x01,0x0F,0x38,0x01,0x9E,0xE2,0x5E,0xE3,
+0xC9,0x23,0xFF,0x55,0xC2,0xF4,0x00,0x01,0xCA,0xF7,0x25,0x38,0x0B,0x17,0x01,0x23,
+0x40,0x34,0x5F,0x18,0x04,0x53,0x18,0x0F,0xE4,0x00,0x00,0x11,0xC7,0x18,0xFF,0xF0,
+0x0F,0x17,0x01,0x98,0x60,0x98,0x80,0xE7,0xFF,0xD9,0xDE,0x98,0x80,0x98,0x61,0xE7,
+0xFF,0xD9,0xCE,0x98,0x60,0xE7,0xFF,0xD8,0x80,0x98,0x60,0x98,0x80,0xE7,0xFF,0xD8,
+0x1A,0x88,0x6E,0xEE,0x01,0x00,0xAA,0xED,0xE1,0x00,0xAE,0xED,0xC1,0x00,0xB2,0xED,
+0xA1,0x00,0xB6,0xED,0x81,0x00,0xBA,0xED,0x61,0x00,0xBE,0xED,0x41,0x00,0xC2,0xED,
+0x21,0x00,0xC6,0xFC,0x21,0x00,0xC8,0xE7,0xFF,0xCB,0xB9,0xC2,0xF4,0x00,0x01,0x53,
+0x20,0x1F,0xCB,0x17,0x3C,0x30,0x0F,0x38,0x01,0xCC,0x63,0x61,0xA8,0xCB,0x17,0x3C,
+0x90,0xCA,0xF7,0x3C,0x38,0x0B,0x18,0x01,0x43,0x03,0xC1,0x4F,0x18,0x29,0x9F,0x1F,
+0x5F,0x18,0x04,0x0F,0x17,0x01,0x85,0x29,0xC2,0xF4,0x00,0x01,0x54,0x63,0x62,0xCA,
+0xF7,0x3C,0x94,0x50,0x63,0x02,0x0B,0x17,0x01,0x1F,0x20,0x9D,0x47,0x18,0xCC,0x47,
+0x03,0xC5,0x0F,0x17,0x01,0x85,0x29,0x5C,0x63,0x04,0xC6,0xE3,0x02,0x00,0x5E,0xF7,
+0x04,0x22,0xE0,0x70,0xC2,0xF4,0x00,0x01,0xFF,0x20,0xFC,0xFF,0xCA,0xF7,0x2C,0x54,
+0x0B,0x17,0x01,0x47,0x18,0xCC,0xCB,0x18,0x01,0x00,0x0F,0x17,0x01,0xC6,0xE3,0x04,
+0x00,0x5E,0xF7,0x04,0x22,0xE0,0xB8,0xC2,0xF4,0x00,0x01,0xFF,0x00,0xA5,0x5A,0xCB,
+0x37,0x30,0xCC,0x0F,0x19,0x01,0xCB,0x37,0x30,0xD0,0x0F,0x19,0x01,0xCA,0xF7,0x31,
+0x04,0xFF,0x40,0x8F,0xFF,0x0B,0x17,0x01,0x47,0x18,0xD4,0xCB,0x18,0x30,0x00,0x0F,
+0x17,0x01,0xC2,0xF4,0x00,0x01,0xCB,0x17,0x3C,0x98,0x0B,0x38,0x01,0xFF,0x20,0x01,
+0x01,0x0F,0x38,0x01,0xCB,0x17,0x3C,0xA0,0x0B,0x58,0x01,0x0F,0x38,0x01,0x1F,0x40,
+0x88,0xCB,0x17,0x3C,0xB4,0x0B,0x38,0x01,0x47,0x39,0xD4,0x53,0x39,0x33,0x0F,0x38,
+0x01,0xCB,0x17,0x3C,0xB0,0x0B,0x38,0x01,0x5F,0x39,0x00,0xCB,0x39,0x03,0x00,0x0F,
+0x38,0x01,0xCA,0xF7,0x3C,0x94,0xC4,0x63,0x07,0x00,0x0B,0x17,0x01,0xFF,0x20,0xF8,
+0xFF,0x47,0x18,0xCC,0x44,0x63,0xC5,0x0C,0x77,0x01,0x85,0x29,0x80,0x01,0x80,0x01,
+0x80,0x01,0x80,0x01,0x80,0x01,0xC8,0x80,0xAA,0x55,0xC0,0x74,0x00,0x01,0xC8,0x63,
+0x78,0xC0,0x0C,0x83,0x00,0xC0,0x74,0x00,0x01,0xC8,0x63,0x1F,0xDC,0x50,0x80,0x80,
+0x0C,0x83,0x00,0x04,0x20,0x80,0xC8,0x21,0x17,0xFC,0x1C,0x40,0xFD,0x44,0x21,0x14,
+0x28,0x00,0x74,0xC0,0x40,0x00,0x01,0xC8,0x42,0x36,0x00,0x84,0x49,0x0C,0x41,0x0C,
+0x0C,0x61,0x10,0x0C,0x81,0x14,0x0C,0xA1,0x18,0x0C,0xC1,0x1C,0x0C,0xE1,0x20,0x0D,
+0x01,0x24,0x0D,0x21,0x28,0x0D,0x41,0x2C,0x0D,0x61,0x30,0x0D,0x81,0x34,0x0D,0xA1,
+0x38,0x0D,0xC1,0x3C,0x0D,0xE1,0x40,0x0E,0x01,0x44,0x0E,0x21,0x48,0x0E,0x41,0x4C,
+0x0E,0x61,0x50,0x0E,0x81,0x54,0x0E,0xA1,0x58,0x0E,0xC1,0x5C,0x0E,0xE1,0x60,0x0F,
+0x01,0x64,0x0F,0x21,0x68,0x0F,0x41,0x6C,0x0F,0x61,0x70,0x0F,0x81,0x74,0x0F,0xA1,
+0x78,0x0F,0xC1,0x7C,0x1C,0x61,0x00,0xC1,0x00,0x00,0x01,0xC9,0x08,0xA1,0x18,0x85,
+0x08,0x90,0x23,0x00,0xC0,0x40,0x10,0x01,0xC8,0x42,0x03,0xB0,0xC0,0x60,0x10,0x01,
+0xC8,0x63,0x0D,0x80,0x5C,0x43,0x1F,0x20,0x00,0x2D,0x0C,0x02,0x00,0x1C,0x42,0x04,
+0x93,0xF4,0x85,0x29,0xC0,0x80,0x01,0x1F,0xC0,0x7F,0xFF,0xE1,0xC8,0x63,0xFF,0xF9,
+0x44,0x84,0x1C,0xC0,0x80,0x01,0x1D,0x0C,0x61,0x02,0xC0,0x60,0x02,0x0D,0x0C,0x61,
+0x06,0xC0,0x60,0x04,0x0D,0x0C,0x41,0x0E,0x0C,0x61,0x12,0x0C,0x81,0x16,0x0C,0xA1,
+0x1A,0x0C,0xC1,0x1E,0x0C,0xE1,0x22,0x0D,0x01,0x26,0x0D,0x21,0x2A,0x0D,0x41,0x2E,
+0x0D,0x61,0x32,0x0D,0x81,0x36,0x0D,0xA1,0x3A,0x0D,0xC1,0x3E,0x0D,0xE1,0x42,0x0E,
+0x01,0x46,0x0E,0x21,0x4A,0x0E,0x41,0x4E,0x0E,0x61,0x52,0x0E,0x81,0x56,0x0E,0xA1,
+0x5A,0x0E,0xC1,0x5E,0x0E,0xE1,0x62,0x0F,0x01,0x66,0x0F,0x21,0x6A,0x0F,0x41,0x6E,
+0x0F,0x61,0x72,0x0F,0x81,0x76,0x0F,0xA1,0x7A,0x0F,0xC1,0x7E,0xEF,0xE1,0x00,0x82,
+0x0C,0x21,0x0A,0x84,0x00,0x00,0x00,0x00,0x9C,0x30,0xCA,0xE0,0x48,0x02,0x0D,0x41,
+0x08,0x0D,0x21,0x0C,0x89,0x43,0xC2,0xF7,0x00,0x0F,0x9B,0x1C,0x46,0xF7,0xC4,0x0E,
+0xE1,0x04,0x0E,0xE1,0x06,0x56,0xF7,0x04,0x22,0xE0,0xE0,0xCA,0xE0,0x48,0x00,0xC3,
+0x37,0x00,0x0F,0x9B,0x1B,0x47,0x39,0xC4,0xC3,0x37,0x00,0x0D,0xCA,0xE0,0x48,0x02,
+0xC3,0x37,0x00,0x0F,0x47,0x19,0xC4,0xC3,0x17,0x00,0x0D,0x98,0x82,0xE7,0xFF,0xBE,
+0x0E,0xCA,0xE0,0x48,0x00,0xC3,0x17,0x00,0x0F,0x53,0x18,0x04,0xC3,0x17,0x00,0x0D,
+0x0E,0xE1,0x06,0x56,0xF7,0x08,0x22,0xE0,0xE8,0xCA,0xE0,0x48,0x00,0xC3,0x37,0x00,
+0x0F,0x9B,0x17,0x47,0x39,0xC4,0xC3,0x37,0x00,0x0D,0xCA,0xE0,0x48,0x02,0xC3,0x37,
+0x00,0x0F,0x47,0x19,0xC4,0xC3,0x17,0x00,0x0D,0x98,0x83,0x88,0x6A,0xE7,0xFF,0xBD,
+0x8E,0xCA,0xE0,0x48,0x00,0xC3,0x17,0x00,0x0F,0x53,0x18,0x08,0xC3,0x17,0x00,0x0D,
+0x0D,0x41,0x0A,0x0D,0x21,0x0E,0x1C,0x21,0x10,0x85,0x29,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x01,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x1B,0x00,0x00,0x00,
+0x00,0xA0,0x26,0x01,0x01,0x00,0x00,0x00,0x66,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,0x00,0xA0,0x66,0x00,0xF3,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,
+0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x39,0x00,0x64,0x00,
+0x8F,0x00,0x54,0x00,0x17,0x00,0xB0,0x01,0x28,0x00,0x51,0x00,0x06,0x00,0x0A,0x00,
+0x15,0x00,0x15,0x00,0x01,0x00,0x1B,0x00,0xFA,0x00,0x08,0x01,0x78,0x00,0x78,0x00,
+0x20,0x00,0x32,0x00,0x88,0x01,0x80,0x00,0x8C,0x01,0x80,0x00,0x19,0x00,0x32,0x00,
+0xA0,0xB9,0x00,0xC0,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x14,0x14,0x14,
+0xFD,0xB9,0x00,0xC0,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x14,0x14,0x14,
+0xDF,0xB9,0x00,0xC0,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x14,0x14,0x14,
+0xD5,0xB9,0x00,0xC0,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x14,0x14,0x14,
+0x10,0xBA,0x00,0xC0,0x0B,0x05,0x00,0x00,0x01,0x00,0x00,0x00,0x37,0x14,0x64,0x2C,
+0xA2,0xB9,0x00,0xC0,0x0D,0x06,0x00,0x00,0x01,0x00,0x00,0x00,0x37,0x14,0x5A,0x2C,
+0xAF,0xB9,0x00,0xC0,0x0B,0x07,0x00,0x00,0x01,0x00,0x00,0x00,0x28,0x14,0x28,0x14,
+0xEF,0xB9,0x00,0xC0,0x0E,0x08,0x00,0x00,0x01,0x00,0x00,0x00,0x3C,0x1E,0x37,0x19,
+0xE1,0xB9,0x00,0xC0,0x06,0x09,0x00,0x00,0x01,0x00,0x00,0x00,0x1E,0x14,0x30,0x1E,
+0x1B,0xBA,0x00,0xC0,0x0E,0x0A,0x00,0x00,0x01,0x00,0x00,0x00,0x3C,0x1C,0x3C,0x22,
+0x2F,0xBA,0x00,0xC0,0x0F,0x0B,0x00,0x00,0x01,0x00,0x00,0x00,0x46,0x19,0x28,0x14,
+0x72,0xB9,0x00,0xC0,0x06,0x0C,0x00,0x00,0x01,0x00,0x00,0x00,0x3C,0x1E,0x28,0x14,
+0x8A,0xB9,0x00,0xC0,0x0E,0x0A,0x00,0x00,0x01,0x00,0x00,0x00,0x3C,0x1C,0x3C,0x22,
+0xD7,0xB9,0x00,0xC0,0x08,0x05,0x00,0x00,0x01,0x00,0x00,0x00,0x37,0x14,0x78,0x2C,
+0x05,0xBA,0x00,0xC0,0x0B,0x05,0x00,0x00,0x01,0x00,0x00,0x00,0x37,0x14,0x78,0x2C,
+0xE7,0xB9,0x00,0xC0,0x08,0x06,0x00,0x00,0x01,0x00,0x00,0x00,0x37,0x14,0x5A,0x2C,
+0xBA,0xB9,0x00,0xC0,0x0C,0x08,0x00,0x00,0x01,0x00,0x00,0x00,0x3C,0x1E,0x37,0x19,
+0xFF,0xB9,0x00,0xC0,0x06,0x07,0x00,0x00,0x01,0x00,0x00,0x00,0x28,0x14,0x28,0x14,
+0xCE,0xB9,0x00,0xC0,0x07,0x07,0x00,0x00,0x01,0x00,0x00,0x00,0x28,0x14,0x28,0x14,
+0x98,0xB9,0x00,0xC0,0x08,0x0B,0x00,0x00,0x01,0x00,0x00,0x00,0x46,0x19,0x28,0x14,
+0x29,0xBA,0x00,0xC0,0x06,0x09,0x00,0x00,0x01,0x00,0x00,0x00,0x1E,0x14,0x30,0x1E,
+0xC6,0xB9,0x00,0xC0,0x08,0x0C,0x00,0x00,0x01,0x00,0x00,0x00,0x3C,0x1E,0x28,0x14,
+0x3E,0xBA,0x00,0xC0,0x09,0x09,0x00,0x00,0x01,0x00,0x00,0x00,0x1E,0x14,0x30,0x1E,
+0x78,0xB9,0x00,0xC0,0x0A,0x06,0x00,0x00,0x01,0x00,0x00,0x00,0x37,0x14,0x5A,0x2C,
+0x82,0xB9,0x00,0xC0,0x08,0x06,0x00,0x00,0x01,0x00,0x00,0x00,0x37,0x14,0x5A,0x2C,
+0x8A,0x01,0x80,0x00,0x7E,0x01,0x80,0x00,0x01,0x00,0x00,0x00,0x07,0x00,0xD2,0x00,
+0xD2,0x00,0xD2,0x00,0x06,0x00,0x98,0x08,0x02,0x00,0x00,0x01,0xF4,0x01,0xF4,0x01,
+0x02,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x02,0x00,0x04,0x00,0x06,0x00,
+0x08,0x00,0x0A,0x00,0x0C,0x00,0x10,0x00,0x14,0x00,0x18,0x00,0x20,0x00,0x28,0x00,
+0x32,0x00,0x3E,0x00,0x40,0x00,0x64,0x00,0x80,0x00,0x00,0x01,0x02,0x00,0x00,0x11,
+0xFF,0xFF,0xFF,0xFF,0x01,0x11,0xFF,0xFF,0x18,0x50,0x02,0x11,0xFF,0x7F,0xFF,0x0E,
+0x03,0x11,0xFF,0x00,0xF6,0x00,0x04,0x11,0xFF,0x0F,0x72,0x07,0x05,0x11,0xFF,0x0F,
+0x72,0x07,0x06,0x11,0xFF,0x00,0x00,0x00,0x07,0x11,0x03,0x00,0x00,0x00,0x08,0x11,
+0x73,0x00,0x00,0x00,0x09,0x11,0xFF,0xFF,0x00,0x00,0x09,0x11,0xFF,0x7F,0x00,0x00,
+0x0A,0x11,0xFF,0x7F,0x87,0x10,0x0E,0x11,0xFF,0xFF,0x00,0x00,0x0F,0x11,0xFF,0xFF,
+0x00,0x00,0x17,0x11,0x0F,0xFF,0x00,0x00,0x18,0x11,0xFF,0xFF,0x00,0x02,0x19,0x11,
+0xFF,0x00,0x0E,0x00,0x1E,0x11,0xFF,0xFF,0x00,0x00,0x1F,0x11,0xFF,0x00,0x00,0x00,
+0x33,0x11,0x0F,0x00,0x00,0x00,0x3A,0x11,0x37,0x0F,0x00,0x00,0x3B,0x11,0x77,0x00,
+0x77,0x00,0x3C,0x11,0x00,0xFF,0x00,0xA0,0x3D,0x11,0x77,0x00,0x00,0x00,0x3E,0x11,
+0xFF,0x00,0x00,0x00,0x04,0x12,0x06,0x00,0x00,0x00,0x05,0x12,0xFF,0x00,0x00,0x00,
+0x07,0x12,0xFF,0xFF,0x00,0x00,0x08,0x12,0xFF,0x00,0x00,0x00,0x09,0x12,0xFF,0xFF,
+0x00,0x00,0x0A,0x12,0xFF,0x00,0x00,0x00,0x0B,0x12,0x3F,0x00,0x2E,0x00,0x0D,0x12,
+0x1F,0x00,0x05,0x00,0x0E,0x12,0x1F,0x00,0x05,0x00,0x0F,0x12,0xFF,0xFF,0x00,0x00,
+0x10,0x12,0xFF,0x00,0x00,0x00,0x11,0x12,0xFF,0x0F,0x00,0x00,0x12,0x12,0x87,0x1F,
+0x00,0x00,0x13,0x12,0x7F,0x0F,0x14,0x00,0x14,0x12,0x9F,0xFF,0x0A,0x09,0x15,0x12,
+0x7F,0x0F,0x0C,0x00,0x16,0x12,0xFF,0x0F,0x00,0x07,0x17,0x12,0x1F,0xFF,0x0A,0x5C,
+0x18,0x12,0x7F,0x1F,0x14,0x0A,0x19,0x12,0xFF,0xFF,0x8C,0x21,0x1A,0x12,0xFF,0x03,
+0x00,0x00,0x1B,0x12,0xFF,0x03,0x00,0x00,0x1C,0x12,0xFF,0x03,0x00,0x00,0x1D,0x12,
+0xFF,0x03,0x00,0x00,0x1E,0x12,0x1F,0x1F,0x12,0x07,0x1F,0x12,0x3F,0x3F,0x00,0x00,
+0x20,0x12,0xFF,0xFF,0x00,0x00,0x21,0x12,0xFF,0x00,0x00,0x00,0x23,0x12,0x3F,0x3F,
+0x02,0x00,0x24,0x12,0x3F,0x00,0x00,0x00,0x28,0x12,0xFF,0xFF,0x83,0x81,0x2D,0x12,
+0x01,0x00,0x01,0x00,0x50,0x12,0xFF,0xFF,0x00,0x00,0x51,0x12,0xFF,0x00,0x00,0x00,
+0x70,0x12,0x03,0x00,0x03,0x00,0x01,0x11,0x06,0x00,0x02,0x00,0x02,0x11,0x00,0x08,
+0x00,0x08,0x2A,0x12,0x00,0xFF,0x00,0xBA,0x2B,0x12,0xFF,0x30,0xF0,0x20,0x01,0x11,
+0x06,0x00,0x00,0x00,0x2A,0x12,0x00,0xFF,0x00,0x00,0x2B,0x12,0xFF,0x30,0x00,0x00,
+0x01,0x11,0x00,0x50,0x00,0x50,0x02,0x11,0x3F,0x06,0x2F,0x06,0x01,0x11,0x00,0x50,
+0x00,0x00,0x02,0x11,0x3F,0x06,0x00,0x00,0x2A,0x12,0x00,0x30,0x00,0x20,0x11,0x1E,
+0xFF,0x7F,0x00,0x00,0x12,0x1E,0xFF,0x00,0x00,0x00,0x13,0x1E,0x0F,0x00,0x00,0x00,
+0x15,0x1E,0x73,0x07,0x00,0x00,0x16,0x1E,0x0F,0x00,0x00,0x00,0x18,0x1E,0x3F,0x00,
+0x08,0x00,0x2A,0x1E,0x05,0x00,0x01,0x00,0x50,0x11,0x11,0x11,0x51,0x11,0x11,0x11,
+0x52,0x11,0x11,0x11,0x53,0x11,0x11,0x11,0x54,0x11,0x11,0x11,0x55,0x11,0x11,0x11,
+0x56,0x11,0x11,0x11,0x57,0x11,0x11,0x11,0x58,0x11,0x11,0x11,0x59,0x11,0x11,0x11,
+0x5A,0x11,0x11,0x11,0x5B,0x11,0x11,0x11,0x5C,0x11,0xFF,0xFF,0x5D,0x11,0xFF,0xFF,
+0x5E,0x11,0xFF,0xFF,0x46,0x12,0x00,0x00,0x47,0x12,0x00,0x00,0x48,0x12,0x00,0x00,
+0x49,0x12,0x00,0x00,0x4A,0x12,0x00,0x00,0x4B,0x12,0x00,0x00,0x4C,0x12,0x00,0x00,
+0x4D,0x12,0x00,0x00,0x4E,0x12,0x0F,0x00,0x26,0x08,0x80,0x00,0x04,0x0D,0x80,0x00,
+0x58,0x01,0x80,0x00,0x5C,0x54,0x47,0x37,0x00,0x00,0x31,0x00,0x94,0x00,0xFA,0x00,
+0x66,0x01,0xD9,0x01,0x57,0x02,0xE6,0x02,0x8A,0x03,0x4F,0x04,0x44,0x05,0x84,0x06,
+0x42,0x08,0xEB,0x0A,0x98,0x0F,0x55,0x1A,0xF3,0x07,0xFF,0xFF,0x0F,0x00,0x52,0x00,
+0x69,0x00,0xD9,0x00,0x35,0x38,0x00,0x00,0xB8,0x38,0x00,0x00,0xD7,0x38,0x00,0x00,
+0xAA,0x39,0x00,0x00,0xC1,0x39,0x00,0x00,0xE8,0x00,0xD6,0x00,0xC4,0x00,0xB2,0x00,
+0xA1,0x00,0x8F,0x00,0x7D,0x00,0x6B,0x00,0x59,0x00,0x47,0x00,0x35,0x00,0x23,0x00,
+0x11,0x00,0x00,0x00,0x05,0x04,0x03,0x03,0x04,0x00,0xFF,0x00,0x42,0x06,0x17,0x00,
+0xFE,0x00,0x99,0x0B,0x3B,0x00,0xFC,0x00,0x0D,0x17,0x5F,0x00,0xFB,0x00,0x6E,0x1E,
+0x81,0x00,0xFA,0x00,0xB4,0x22,0xAC,0x00,0xF9,0x00,0xE9,0x28,0xDF,0x00,0xF7,0x00,
+0x6A,0x35,0x0B,0x01,0xF6,0x00,0xD5,0x3A,0x38,0x01,0xFF,0x00,0xE4,0x0A,0x07,0x00,
+0xFE,0x00,0x56,0x0F,0x1E,0x00,0xFD,0x00,0x18,0x16,0x35,0x00,0xFC,0x00,0x6C,0x1A,
+0x4B,0x00,0xFC,0x00,0xD6,0x1D,0x66,0x00,0xFB,0x00,0x8D,0x24,0x81,0x00,0xFA,0x00,
+0xF7,0x2C,0x94,0x00,0xF9,0x00,0x2A,0x30,0xA8,0x00,0xF8,0x00,0x56,0x31,0xC9,0x00,
+0xF7,0x00,0x3E,0x36,0xF6,0x00,0xFE,0x00,0xFE,0x11,0xFD,0xFF,0xFE,0x00,0x06,0x12,
+0x0B,0x00,0xFD,0x00,0xE2,0x14,0x25,0x00,0xFC,0x00,0x5D,0x1B,0x3F,0x00,0xFC,0x00,
+0x27,0x22,0x4F,0x00,0xFB,0x00,0x3D,0x25,0x5C,0x00,0xFA,0x00,0x05,0x28,0x70,0x00,
+0xFA,0x00,0x3C,0x2D,0x88,0x00,0xF8,0x00,0x7C,0x35,0x99,0x00,0xF8,0x00,0xFE,0x37,
+0xAC,0x00,0xF7,0x00,0x51,0x39,0xCC,0x00,0xFE,0x00,0x25,0x14,0xF5,0xFF,0xFD,0x00,
+0xD1,0x16,0x06,0x00,0xFD,0x00,0x39,0x1B,0x16,0x00,0xFC,0x00,0x10,0x1E,0x27,0x00,
+0xFC,0x00,0xF3,0x20,0x3B,0x00,0xFB,0x00,0x82,0x26,0x4C,0x00,0xFA,0x00,0xE5,0x2C,
+0x55,0x00,0xFA,0x00,0xCD,0x2F,0x5F,0x00,0xF9,0x00,0x57,0x31,0x72,0x00,0xF8,0x00,
+0x16,0x36,0x89,0x00,0xF7,0x00,0x61,0x3D,0x9A,0x00,0xF7,0x00,0xC9,0x3F,0xAD,0x00,
+0xFD,0x00,0xED,0x1F,0xDD,0xFF,0xFC,0x00,0xBD,0x21,0xEC,0xFF,0xFC,0x00,0x5D,0x24,
+0xFB,0xFF,0xFC,0x00,0xA0,0x26,0x09,0x00,0xFB,0x00,0x3D,0x29,0x18,0x00,0xFA,0x00,
+0x20,0x2E,0x23,0x00,0xFA,0x00,0x6C,0x33,0x29,0x00,0xF9,0x00,0xC4,0x35,0x2F,0x00,
+0xF9,0x00,0x07,0x37,0x3C,0x00,0xF8,0x00,0xA0,0x3A,0x4B,0x00,0xF8,0x00,0xEE,0x3F,
+0x53,0x00,0xF7,0x00,0x74,0x41,0x5C,0x00,0xF7,0x00,0x0D,0x41,0x70,0x00,0xF6,0x00,
+0xB1,0x43,0x88,0x00,0x17,0x00,0x05,0x0D,0xB7,0xFF,0x0E,0x01,0x0D,0x00,0x25,0x00,
+0xFF,0x03,0x0B,0x00,0x2D,0x00,0x15,0x00,0x65,0x00,0x30,0x03,0x1A,0x00,0x04,0x00,
+0x19,0x00,0x16,0x01,0x2C,0x08,0xCA,0xFE,0x02,0x00,0x19,0x00,0x47,0x01,0x14,0x03,
+0x68,0x00,0x00,0x00,0x1A,0x00,0x1D,0x00,0xD6,0x05,0xD8,0xFF,0x7A,0x00,0x15,0x00,
+0x44,0x00,0x28,0x04,0xF4,0xFF,0x31,0x00,0x19,0x00,0x9A,0x00,0x27,0x04,0xEF,0xFF,
+0x04,0x00,0x20,0x00,0x2C,0x01,0xF4,0x03,0x0A,0x00,0x01,0x00,0x21,0x00,0x24,0x00,
+0xFA,0x04,0xD5,0xFF,0x63,0x00,0x17,0x00,0x6D,0x00,0x78,0x04,0xE3,0xFF,0x25,0x00,
+0x1E,0x00,0xC0,0x00,0x2F,0x04,0xF0,0xFF,0x02,0x00,0x24,0x00,0x2E,0x00,0x35,0x05,
+0xC3,0xFF,0x61,0x00,0x19,0x00,0x98,0x00,0x99,0x04,0xDD,0xFF,0x10,0x00,0x25,0x00,
+0xFA,0x00,0xF8,0x03,0x02,0x00,0x01,0x00,0x28,0x00,0x47,0x00,0x4E,0x06,0x8C,0xFF,
+0x77,0x00,0x1A,0x00,0xB3,0x00,0xEE,0x04,0xD0,0xFF,0x14,0x00,0x2B,0x00,0x04,0x01,
+0x40,0x03,0x37,0x00,0x02,0x00,0x30,0x00,0x7E,0x01,0xDA,0x04,0xA3,0xFF,0x01,0x00,
+0x30,0x00,0x00,0x00,0x13,0x1A,0x05,0x00,0x30,0x34,0x38,0x0C,0x10,0x34,0x30,0x0E,
+0x30,0x0A,0x35,0x02,0x09,0x10,0x35,0x10,0x0A,0x34,0x1E,0x18,0x14,0x0E,0x0B,0x07,
+0x01,0x3C,0x37,0x34,0x30,0x2A,0x26,0x23,0x1C,0x17,0x0E,0x05,0x03,0x10,0x19,0x1B,
+0x2F,0x2F,0x10,0x0E,0x0A,0x05,0x00,0x39,0x33,0x30,0x10,0x0B,0x04,0x35,0x30,0x28,
+0x22,0x1E,0x19,0x13,0x10,0x0B,0x07,0x02,0x3D,0x39,0x00,0x3C,0x38,0x34,0x2E,0x23,
+0x1D,0x16,0x10,0x0B,0x05,0x01,0x3F,0x00,0x0A,0x17,0x1A,0x10,0x02,0x3F,0x21,0x1D,
+0x19,0x14,0x0E,0x04,0x01,0x00,0x00,0x32,0x33,0x05,0x0D,0x3D,0x35,0x09,0x10,0x1F,
+0x1F,0x0D,0x0D,0x0D,0x0D,0x35,0x35,0x0E,0x0D,0x36,0x32,0x09,0x0D,0x37,0x33,0x00,
+0x3C,0x36,0x2A,0x23,0x1E,0x1A,0x15,0x10,0x0B,0x08,0x03,0x3C,0x39,0x0F,0x0F,0x1D,
+0x18,0x12,0x0A,0x04,0x01,0x10,0x10,0x32,0x3E,0x0D,0x10,0x33,0x38,0x01,0x0D,0x10,
+0x30,0x34,0x00,0x0D,0x10,0x32,0x34,0x3A,0x07,0x0D,0x10,0x01,0x05,0x0B,0x0E,0x13,
+0x1A,0x1F,0x25,0x29,0x2E,0x34,0x36,0x3B,0x00,0x10,0x0E,0x07,0x3C,0x33,0x30,0x28,
+0x22,0x1D,0x19,0x14,0x10,0x0A,0x05,0x0B,0x13,0x1A,0x1D,0x22,0x26,0x2B,0x3D,0x02,
+0x10,0x09,0x3D,0x34,0x30,0x0B,0x04,0x00,0xD5,0x54,0x00,0x00,0xD5,0x54,0x00,0x00,
+0xE4,0x54,0x00,0x00,0xE4,0x54,0x00,0x00,0x3D,0x56,0x00,0x00,0x3D,0x56,0x00,0x00,
+0x3D,0x56,0x00,0x00,0x67,0x55,0x00,0x00,0x3D,0x56,0x00,0x00,0xC4,0x55,0x00,0x00,
+0xB5,0x57,0x00,0x00,0xB5,0x57,0x00,0x00,0xDE,0x57,0x00,0x00,0xAB,0x57,0x00,0x00,
+0x07,0x58,0x00,0x00,0x37,0x58,0x00,0x00,0x1F,0x58,0x00,0x00,0x0E,0x5B,0x00,0x00,
+0x32,0x5B,0x00,0x00,0x42,0x5B,0x00,0x00,0x7A,0x5B,0x00,0x00,0x74,0x5B,0x00,0x00,
+0x74,0x5B,0x00,0x00,0x7A,0x5B,0x00,0x00,0x74,0x5B,0x00,0x00,0x01,0x2A,0x2B,0x0A,
+0x09,0x08,0x07,0x06,0x05,0x04,0x02,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x20,0x0B,
+0x0C,0x0D,0x0E,0x0F,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x00,
+0x95,0x68,0x00,0x00,0x95,0x68,0x00,0x00,0xBE,0x68,0x00,0x00,0xBE,0x68,0x00,0x00,
+0xE8,0x68,0x00,0x00,0xE8,0x68,0x00,0x00,0xE8,0x68,0x00,0x00,0xE8,0x68,0x00,0x00,
+0x74,0x68,0x00,0x00,0x53,0x68,0x00,0x00,0x49,0x69,0x00,0x00,0x49,0x69,0x00,0x00,
+0x7A,0x69,0x00,0x00,0x7A,0x69,0x00,0x00,0xAD,0x69,0x00,0x00,0xAD,0x69,0x00,0x00,
+0xAD,0x69,0x00,0x00,0xAD,0x69,0x00,0x00,0x22,0x69,0x00,0x00,0x10,0x69,0x00,0x00,
+0xB4,0x6A,0x00,0x00,0xB4,0x6A,0x00,0x00,0x06,0x6B,0x00,0x00,0x06,0x6B,0x00,0x00,
+0xE6,0x6B,0x00,0x00,0xE6,0x6B,0x00,0x00,0xE6,0x6B,0x00,0x00,0xE6,0x6B,0x00,0x00,
+0x5E,0x6B,0x00,0x00,0xA4,0x6B,0x00,0x00,0x5D,0x7D,0x00,0x00,0x64,0x7D,0x00,0x00,
+0x6B,0x7D,0x00,0x00,0x72,0x7D,0x00,0x00,0x79,0x7D,0x00,0x00,0x80,0x7D,0x00,0x00,
+0x87,0x7D,0x00,0x00,0x8E,0x7D,0x00,0x00,0x95,0x7D,0x00,0x00,0x9C,0x7D,0x00,0x00,
+0xA3,0x7D,0x00,0x00,0xAA,0x7D,0x00,0x00,0xAD,0x7E,0x00,0x00,0xAD,0x7E,0x00,0x00,
+0xE7,0x7E,0x00,0x00,0xE7,0x7E,0x00,0x00,0x7B,0x7F,0x00,0x00,0x7B,0x7F,0x00,0x00,
+0x7B,0x7F,0x00,0x00,0x7B,0x7F,0x00,0x00,0x23,0x7F,0x00,0x00,0x4B,0x7F,0x00,0x00,
+0x00,0x01,0x00,0x00,0xC0,0x81,0x00,0x00,0xFA,0x81,0x00,0x00,0x52,0x82,0x00,0x00,
+0x2A,0x83,0x00,0x00,0xAE,0x82,0x00,0x00,0xDE,0x82,0x00,0x00,0x2A,0x83,0x00,0x00,
+0xE6,0x82,0x00,0x00,0x04,0x00,0x1D,0x00,0x2E,0x00,0x50,0x00,0x82,0x00,0xC7,0x00,
+0x23,0x01,0x9B,0x01,0x32,0x02,0xEE,0x02,0xD0,0x03,0xDE,0x04,0x19,0x06,0x82,0x07,
+0x1A,0x09,0xE0,0x0A,0xD0,0x0C,0xE7,0x0E,0x1F,0x11,0x71,0x13,0xD3,0x15,0x3D,0x18,
+0xA2,0x1A,0xF9,0x1C,0x34,0x1F,0x47,0x21,0x28,0x23,0xCB,0x24,0x27,0x26,0x33,0x27,
+0xEA,0x27,0x46,0x28,0x04,0x00,0x1C,0x00,0x2B,0x00,0x4B,0x00,0x78,0x00,0xB7,0x00,
+0x0A,0x01,0x75,0x01,0xFC,0x01,0xA3,0x02,0x6D,0x03,0x5E,0x04,0x76,0x05,0xB9,0x06,
+0x26,0x08,0xBE,0x09,0x7D,0x0B,0x61,0x0D,0x67,0x0F,0x87,0x11,0xBB,0x13,0xFC,0x15,
+0x3F,0x18,0x7B,0x1A,0xA6,0x1C,0xB6,0x1E,0x9F,0x20,0x57,0x22,0xD7,0x23,0x14,0x25,
+0x08,0x26,0xAF,0x26,0x03,0x27,0x05,0x00,0x08,0x21,0x05,0x00,0x00,0x20,0x00,0x00,
+0x8C,0xBD,0x00,0xC0,0x9C,0xBD,0x00,0xC0,0xAE,0xBD,0x00,0xC0,0xB2,0xBD,0x00,0xC0,
+0x24,0xBD,0x00,0xC0,0x6C,0xBD,0x00,0xC0,0xCC,0xBD,0x00,0xC0,0xEA,0xBD,0x00,0xC0,
+0xEE,0xBD,0x00,0xC0,0x14,0xBE,0x00,0xC0,0xA2,0xBE,0x00,0xC0,0xE4,0xBE,0x00,0xC0,
+0x46,0xBC,0x00,0xC0,0x4A,0xBC,0x00,0xC0,0x20,0xBD,0x00,0xC0,0x68,0xBD,0x00,0xC0,
+0x05,0x00,0x2A,0x00,0x2A,0x00,0x3E,0x00,0x58,0x00,0x79,0x00,0xA1,0x00,0xD3,0x00,
+0x0F,0x01,0x56,0x01,0xAA,0x01,0x0C,0x02,0x7D,0x02,0xFE,0x02,0x91,0x03,0x37,0x04,
+0xF0,0x04,0xBE,0x05,0xA0,0x06,0x99,0x07,0xA7,0x08,0xCC,0x09,0x06,0x0B,0x56,0x0C,
+0xBB,0x0D,0x34,0x0F,0xC0,0x10,0x5D,0x12,0x0A,0x14,0xC5,0x15,0x8A,0x17,0x59,0x19,
+0x2D,0x1B,0x05,0x1D,0xDC,0x1E,0xB0,0x20,0x7D,0x22,0x40,0x24,0xF5,0x25,0x98,0x27,
+0x27,0x29,0x9E,0x2A,0xF9,0x2B,0x37,0x2D,0x53,0x2E,0x4B,0x2F,0x1E,0x30,0xC9,0x30,
+0x4A,0x31,0xA1,0x31,0xCD,0x31,0x04,0x00,0x2D,0x00,0x6D,0x00,0xE7,0x00,0xAD,0x01,
+0xD8,0x02,0x81,0x04,0xBE,0x06,0xA0,0x09,0x30,0x0D,0x6D,0x11,0x47,0x16,0xA3,0x1B,
+0x56,0x21,0x29,0x27,0xDC,0x2C,0x2A,0x32,0xCF,0x36,0x8B,0x3A,0x29,0x3D,0x81,0x3E,
+0x06,0x00,0xF5,0x28,0x03,0x00,0x33,0x33,0x70,0xBD,0x00,0xC0,0x86,0xBD,0x00,0xC0,
+0x18,0xBE,0x00,0xC0,0xA6,0xBE,0x00,0xC0,0x90,0xBD,0x00,0xC0,0xA0,0xBD,0x00,0xC0,
+0x74,0xBD,0x00,0xC0,0xB6,0xBD,0x00,0xC0,0xD0,0xBD,0x00,0xC0,0xF2,0xBD,0x00,0xC0,
+0xF6,0xBC,0x00,0xC0,0xB0,0xBE,0x00,0xC0,0xC4,0xBB,0x00,0xC0,0x04,0xBC,0x00,0xC0,
+0x90,0xBC,0x00,0xC0,0x20,0xBE,0x00,0xC0,0x06,0x00,0x00,0x20,0x03,0x00,0xAA,0x2A,
+0x00,0x00,0x00,0x20,0x02,0x00,0x45,0x00,0x5D,0x01,0x1B,0x04,0x31,0x09,0xA2,0x10,
+0x55,0x19,0x32,0x21,0xE5,0x25,0x01,0x00,0x10,0x10,0xEF,0x2F,0x00,0x00,0x00,0x20,
+0x02,0x00,0x49,0x01,0x6C,0x07,0xB1,0x15,0x60,0x29,0x38,0x38,0x01,0x00,0x00,0x20,
+0x02,0x00,0xAC,0x00,0xCB,0x03,0x95,0x0B,0x6B,0x18,0xE0,0x26,0xA6,0x30,0x02,0x00,
+0xAA,0x2A,0x02,0x00,0x00,0x20,0x03,0x00,0x4D,0x00,0x51,0x01,0xBD,0x03,0x48,0x08,
+0x6B,0x0F,0x0D,0x19,0x47,0x24,0x73,0x2F,0x86,0x38,0x9F,0x3D,0x03,0x00,0x00,0x20,
+0x03,0x00,0x33,0x00,0xC4,0x00,0x08,0x02,0x5B,0x04,0x11,0x08,0x55,0x0D,0x0D,0x14,
+0xCC,0x1B,0xCF,0x23,0x1E,0x2B,0xB5,0x30,0xBD,0x33,0x04,0x00,0x33,0x33,0x04,0x00,
+0xAA,0x2A,0x03,0x00,0x1F,0x00,0x5B,0x00,0xD6,0x00,0xAB,0x01,0xF6,0x02,0xD5,0x04,
+0x59,0x07,0x87,0x0A,0x52,0x0E,0x96,0x12,0x1C,0x17,0x9B,0x1B,0xC0,0x1F,0x37,0x23,
+0xB6,0x25,0x05,0x27,0x04,0x00,0x00,0x20,0x01,0x00,0x65,0x04,0x5D,0x14,0x3D,0x27,
+0x05,0x00,0x26,0x00,0x1D,0x00,0x28,0x00,0x36,0x00,0x47,0x00,0x5A,0x00,0x72,0x00,
+0x8D,0x00,0xAE,0x00,0xD3,0x00,0xFD,0x00,0x2D,0x01,0x64,0x01,0xA2,0x01,0xE6,0x01,
+0x33,0x02,0x87,0x02,0xE5,0x02,0x4B,0x03,0xBA,0x03,0x33,0x04,0xB6,0x04,0x43,0x05,
+0xDB,0x05,0x7C,0x06,0x29,0x07,0xDF,0x07,0xA1,0x08,0x6C,0x09,0x41,0x0A,0x21,0x0B,
+0x09,0x0C,0xFA,0x0C,0xF4,0x0D,0xF5,0x0E,0xFE,0x0F,0x0C,0x11,0x20,0x12,0x38,0x13,
+0x53,0x14,0x71,0x15,0x90,0x16,0xAF,0x17,0xCD,0x18,0xE8,0x19,0x00,0x1B,0x12,0x1C,
+0x1E,0x1D,0x23,0x1E,0x1F,0x1F,0x10,0x20,0xF7,0x20,0xD0,0x21,0x9C,0x22,0x59,0x23,
+0x07,0x24,0xA3,0x24,0x2E,0x25,0xA7,0x25,0x0C,0x26,0x5E,0x26,0x9C,0x26,0xC6,0x26,
+0xDA,0x26,0x05,0x00,0x33,0x33,0x01,0x00,0x7E,0x01,0x41,0x08,0x4A,0x15,0xF4,0x20,
+0x04,0x00,0x23,0x00,0x45,0x00,0x84,0x00,0xE4,0x00,0x6F,0x01,0x2F,0x02,0x2F,0x03,
+0x76,0x04,0x0F,0x06,0xFD,0x07,0x45,0x0A,0xE6,0x0C,0xDA,0x0F,0x19,0x13,0x93,0x16,
+0x37,0x1A,0xEF,0x1D,0xA0,0x21,0x2F,0x25,0x80,0x28,0x77,0x2B,0xFA,0x2D,0xF2,0x2F,
+0x4D,0x31,0xFD,0x31,0x05,0x00,0xF5,0x28,0x0E,0x96,0x00,0x00,0x2A,0x96,0x00,0x00,
+0x49,0x96,0x00,0x00,0x68,0x96,0x00,0x00,0x77,0x96,0x00,0x00,0x44,0x54,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x01,0x01,0x42,
+0x42,0x4D,0x44,0x4C,0x01,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0xD7,0xBE,0x7E,0xFC,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x03,0x00,
+0x00,0x00,0x56,0x30,0x31,0x2E,0x30,0x30,0x37,0x2E,0x30,0x35,0x56,0xDF,0xF5,0x88
+};
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_mtk.c
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_mtk.c	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_mtk.c	(revision 166572)
@@ -0,0 +1,452 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_mtk.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/rtpm_prio.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/namei.h>
+#include <linux/vmalloc.h>
+
+#include "tpd.h"
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/dma-mapping.h>
+#include <linux/gpio.h>
+
+#ifdef TIMER_DEBUG
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/module.h>
+#endif //TIMER_DEBUG
+
+#ifdef CONFIG_MTK_SENSOR_HUB_SUPPORT
+#include <mach/md32_ipi.h>
+#include <mach/md32_helper.h>
+#endif //CONFIG_MTK_SENSOR_HUB_SUPPORT
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+#include <linux/regulator/consumer.h>
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+#include "mstar_drv_platform_interface.h"
+
+/*=============================================================*/
+// CONSTANT VALUE DEFINITION
+/*=============================================================*/
+
+#define MSG_TP_IC_NAME "msg2xxx" //"msg21xxA" or "msg22xx" or "msg26xxM" or "msg28xx" /* Please define the mstar touch ic name based on the mutual-capacitive ic or self capacitive ic that you are using */
+#define I2C_BUS_ID   (1)       // i2c bus id : 0 or 1
+
+#define TPD_OK (0)
+
+#define TP_READ_VER
+#ifdef TP_READ_VER
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+#define TP_VER_PROC_FILE  "tp_ver"
+static struct proc_dir_entry *tp_ver_proc = NULL;
+#endif
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_TP_HAVE_KEY
+extern int g_TpVirtualKey[];
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+extern int g_TpVirtualKeyDimLocal[][4];
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_TP_HAVE_KEY
+
+extern struct tpd_device *tpd;
+
+/*=============================================================*/
+// LOCAL VARIABLE DEFINITION
+/*=============================================================*/
+
+struct i2c_client *g_I2cClient = NULL;
+
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+struct regulator *g_ReguVdd = NULL;
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+/*=============================================================*/
+// FUNCTION DECLARATION
+/*=============================================================*/
+
+/*=============================================================*/
+// FUNCTION DEFINITION
+/*=============================================================*/
+
+#ifdef TP_READ_VER
+extern struct mutex g_Mutex;
+extern void DrvPlatformLyrTouchDeviceResetHw(void);
+extern s32 IicWriteData(u8 nSlaveId, u8* pBuf, u16 nSize);
+extern s32 IicReadData(u8 nSlaveId, u8* pBuf, u16 nSize);
+
+int data_buf[1];
+static ssize_t get_tp_ver_func(struct file *f, char __user *buf, size_t count, loff_t *pos)
+{
+	u16 nMajor,nMinor;
+	u8 szDbBusTxData[3] = {0};
+	u8 szDbBusRxData[4] = {0};
+
+	szDbBusTxData[0] = 0x03;
+
+	mutex_lock(&g_Mutex);
+
+	DrvPlatformLyrTouchDeviceResetHw();
+
+	IicWriteData((0x4C>>1), &szDbBusTxData[0], 1);
+	IicReadData((0x4C>>1), &szDbBusRxData[0], 4);
+
+	mutex_unlock(&g_Mutex);
+
+	nMajor = (szDbBusRxData[1]<<8) + szDbBusRxData[0];
+	nMinor = (szDbBusRxData[3]<<8) + szDbBusRxData[2];
+
+	//printk("nRegData1=%x,nRegData2=%x\n", nMajor,nMinor);
+	data_buf[0] = nMajor << 12 | nMinor;
+
+	printk("*** data_buf[0] = %x ***\n", data_buf[0]);
+
+	if(copy_to_user(buf, (char *)data_buf, sizeof(data_buf)))
+	{
+		return -EFAULT;
+	}	
+	 return count;
+}
+static const struct file_operations gt_tp_ver_proc_fops = { 
+    .read = get_tp_ver_func
+};
+#endif
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION//adair
+static struct hrtimer chargerTimer;
+static u8 bCancelTimer = 0;
+static struct workqueue_struct *chargerWq;
+static struct work_struct chargerWork;
+extern u8 g_ForceUpdate;
+extern void DrvFwCtrlChargerDetection(u8 nChargerStatus);
+
+ static void charger_work_func(struct work_struct *work)
+{
+	u8 szChargerStatus[20] = {0};
+        DrvCommonReadFile("/sys/class/power_supply/battery/status", szChargerStatus, 20);
+        
+        //DBG(&g_I2cClient->dev, "*** Battery Status : %s ***\n", szChargerStatus);
+        
+        g_ForceUpdate = 0; // Set flag to force update charger status
+
+        if (strstr(szChargerStatus, "Charging") != NULL || strstr(szChargerStatus, "Full") != NULL || strstr(szChargerStatus, "Fully charged") != NULL) // Charging
+        {
+            DrvFwCtrlChargerDetection(1); // charger plug-in
+        }
+        else // Not charging
+        {
+            DrvFwCtrlChargerDetection(0); // charger plug-out
+        }
+
+        g_ForceUpdate = 0; // Clear flag after force update charger status
+        hrtimer_start(&chargerTimer, ktime_set(0, 125000000), HRTIMER_MODE_REL);
+
+}
+
+static enum hrtimer_restart charger_timer_func(struct hrtimer *timer)
+{   
+       queue_work(chargerWq, &chargerWork);
+	return HRTIMER_NORESTART;
+}
+#endif
+
+/* probe function is used for matching and initializing input device */
+static int /*__devinit*/ tpd_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    int ret = 0;
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+    const char *vdd_name = "vtouch";
+//    const char *vcc_i2c_name = "vcc_i2c";
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+    TPD_DMESG("TPD probe\n");   
+    
+    if (client == NULL)
+    {
+        TPD_DMESG("i2c client is NULL\n");
+        return -1;
+    }
+    g_I2cClient = client;
+    
+    MsDrvInterfaceTouchDeviceSetIicDataRate(g_I2cClient, 100000); // 100 KHz
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+    g_ReguVdd = regulator_get(tpd->tpd_dev, vdd_name);
+    tpd->reg = g_ReguVdd;
+
+    ret = regulator_set_voltage(g_ReguVdd, 2800000, 2800000); 
+    if (ret)
+    {
+        TPD_DMESG("Could not set to 2800mv.\n");
+    }
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+    ret = MsDrvInterfaceTouchDeviceProbe(g_I2cClient, id);
+    if (ret == 0) // If probe is success, then enable the below flag.
+    {
+        tpd_load_status = 1;
+		
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION//adair
+			chargerWq = create_singlethread_workqueue("charger detection");
+		INIT_WORK(&chargerWork, charger_work_func);
+		
+		hrtimer_init(&chargerTimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		chargerTimer.function = charger_timer_func;
+		hrtimer_start(&chargerTimer, ktime_set(1, 0), HRTIMER_MODE_REL);
+   #endif
+    }    
+#ifdef TP_READ_VER 
+	tp_ver_proc = proc_create(TP_VER_PROC_FILE, 0444, NULL, &gt_tp_ver_proc_fops);
+	if (tp_ver_proc == NULL)
+	{
+		printk("create_proc_entry %s failed\n", TP_VER_PROC_FILE);
+	}
+#endif
+
+    TPD_DMESG("TPD probe done\n");
+    
+    return TPD_OK;   
+}
+
+static int tpd_detect(struct i2c_client *client, struct i2c_board_info *info) 
+{
+    strcpy(info->type, TPD_DEVICE);    
+    
+    return TPD_OK;
+}
+
+static int /*__devexit*/ tpd_remove(struct i2c_client *client)
+{   
+    TPD_DEBUG("TPD removed\n");
+    
+    MsDrvInterfaceTouchDeviceRemove(client);
+    
+    return TPD_OK;
+}
+
+
+/* The I2C device list is used for matching I2C device and I2C device driver. */
+static const struct i2c_device_id tpd_device_id[] =
+{
+    {MSG_TP_IC_NAME, 0},
+    {}, /* should not omitted */ 
+};
+
+MODULE_DEVICE_TABLE(i2c, tpd_device_id);
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+const struct of_device_id touch_dt_match_table[] = {
+    { .compatible = "mediatek,cap_touch1",},
+    {},
+};
+
+MODULE_DEVICE_TABLE(of, touch_dt_match_table);
+
+static struct device_attribute *msg2xxx_attrs[] = {
+#ifdef CONFIG_MTK_SENSOR_HUB_SUPPORT
+	&dev_attr_tpd_scp_ctrl,
+#endif //CONFIG_MTK_SENSOR_HUB_SUPPORT
+};
+
+#else
+static struct i2c_board_info __initdata i2c_tpd = {I2C_BOARD_INFO(MSG_TP_IC_NAME, (0x4C>>1))};
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+static struct i2c_driver tpd_i2c_driver = {
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+    .driver = {
+        .name = MSG_TP_IC_NAME,
+        .of_match_table = of_match_ptr(touch_dt_match_table),
+    },
+#else
+    .driver = {
+        .name = MSG_TP_IC_NAME,
+    },
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+    .probe = tpd_probe,
+    .remove = tpd_remove,
+    .id_table = tpd_device_id,
+    .detect = tpd_detect,
+};
+
+static int tpd_local_init(void)
+{  
+    TPD_DMESG("TPD init device driver\n");
+
+    if (i2c_add_driver(&tpd_i2c_driver) != 0)
+    {
+        TPD_DMESG("Unable to add i2c driver.\n");
+         
+        return -1;
+    }
+    
+    if (tpd_load_status == 0) 
+    {
+        TPD_DMESG("Add error touch panel driver.\n");
+
+        i2c_del_driver(&tpd_i2c_driver);
+        return -1;
+    }
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+    if (tpd_dts_data.use_tpd_button)
+    {
+        tpd_button_setting(tpd_dts_data.tpd_key_num, tpd_dts_data.tpd_key_local,
+        tpd_dts_data.tpd_key_dim_local);
+    }
+#else
+#ifdef CONFIG_TP_HAVE_KEY
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE     
+    tpd_button_setting(4, g_TpVirtualKey, g_TpVirtualKeyDimLocal); //MAX_KEY_NUM
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE  
+#endif //CONFIG_TP_HAVE_KEY  
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+    TPD_DMESG("TPD init done %s, %d\n", __func__, __LINE__);  
+        
+    return TPD_OK; 
+}
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+static void tpd_resume(struct device *h)
+#else
+static void tpd_resume(struct early_suspend *h)
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+{
+    TPD_DMESG("TPD wake up\n");
+    
+    MsDrvInterfaceTouchDeviceResume(h);
+    
+    #ifdef CONFIG_ENABLE_CHARGER_DETECTION//adair
+     if(bCancelTimer)
+    {
+         bCancelTimer = 0;
+	  hrtimer_start(&chargerTimer, ktime_set(1, 0), HRTIMER_MODE_REL);
+    }
+#endif
+    TPD_DMESG("TPD wake up done\n");
+}
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+static void tpd_suspend(struct device *h)
+#else
+static void tpd_suspend(struct early_suspend *h)
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+{
+    TPD_DMESG("TPD enter sleep\n");
+	#ifdef CONFIG_ENABLE_CHARGER_DETECTION//adair
+       cancel_work_sync(&chargerWork);
+	hrtimer_cancel(&chargerTimer);
+       bCancelTimer = 1;
+#endif
+
+    MsDrvInterfaceTouchDeviceSuspend(h);
+
+    TPD_DMESG("TPD enter sleep done\n");
+} 
+
+static struct tpd_driver_t tpd_device_driver = {
+    .tpd_device_name = MSG_TP_IC_NAME,
+    .tpd_local_init = tpd_local_init,
+    .suspend = tpd_suspend,
+    .resume = tpd_resume,
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+    .attrs = {
+        .attr = msg2xxx_attrs,
+        .num  = ARRAY_SIZE(msg2xxx_attrs),
+    },
+#else
+#ifdef CONFIG_TP_HAVE_KEY
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+     .tpd_have_button = 1,
+#else
+     .tpd_have_button = 0,
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE        
+#endif //CONFIG_TP_HAVE_KEY        
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+};
+
+static int __init tpd_driver_init(void) 
+{
+    TPD_DMESG("MStar touch panel driver init\n");
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+    tpd_get_dts_info();
+#else
+    i2c_register_board_info(I2C_BUS_ID, &i2c_tpd, 1);
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+    if (tpd_driver_add(&tpd_device_driver) < 0)
+    {
+        TPD_DMESG("TPD add MStar TP driver failed\n");
+    }
+     
+    return 0;
+}
+ 
+static void __exit tpd_driver_exit(void) 
+{
+    TPD_DMESG("MStar touch panel driver exit\n");
+    
+    tpd_driver_remove(&tpd_device_driver);
+}
+
+module_init(tpd_driver_init);
+module_exit(tpd_driver_exit);
+MODULE_LICENSE("GPL");
\ No newline at end of file
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_common.h
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_common.h	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_common.h	(revision 166572)
@@ -0,0 +1,692 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_common.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_COMMON_H__
+#define __MSTAR_DRV_COMMON_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif //CONFIG_HAS_EARLYSUSPEND
+#include <linux/i2c.h>
+#include <linux/proc_fs.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/miscdevice.h>
+#include <linux/time.h>
+#include <linux/input/mt.h>
+#include <asm/unistd.h>
+#include <asm/uaccess.h>
+//#include <linux/uaccess.h> // TODO : For use Android 6.0 on MTK platform
+#include <asm/irq.h>
+#include <asm/io.h>
+
+/*--------------------------------------------------------------------------*/
+/* TOUCH DEVICE DRIVER RELEASE VERSION                                      */
+/*--------------------------------------------------------------------------*/
+
+#define DEVICE_DRIVER_RELEASE_VERSION   ("3.12.0.0")
+
+#if 1
+struct msg2138_ts_platform_data{
+	int irq_gpio_number;
+	int reset_gpio_number;
+	const char *vdd_name;
+	int virtualkeys[12];
+	int TP_MAX_X;
+	int TP_MAX_Y;
+};
+
+extern int MS_TS_MSG_IC_GPIO_RST;
+extern int MS_TS_MSG_IC_GPIO_INT;
+#endif
+/*--------------------------------------------------------------------------*/
+/* COMPILE OPTION DEFINITION                                                */
+/*--------------------------------------------------------------------------*/
+
+/*
+ * Note.
+ * The below compile option is used to enable the specific device driver code handling for distinct smart phone developer platform.
+ * For running on Spreadtrum platform, please define the compile option CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM.
+ * For running on Qualcomm platform, please define the compile option CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM.
+ * For running on MediaTek platform, please define the compile option CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM.
+ */
+#define CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM
+//#define CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM
+//#define CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+
+/*
+ * Note.
+ * The below compile option is used to enable code handling for specific MTK platform which use Android 6.0 upward.
+ * This compile option is used for MTK platform only.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+
+/*
+ * Note.
+ * The below compile option is used to enable the specific device driver code handling to make sure main board can supply power to touch ic for some specific BB chip of MTK(EX. MT6582)/SPRD(EX. SC7715)/QCOM(EX. MSM8610).
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_REGULATOR_POWER_ON
+
+/*
+ * Note.
+ * The below compile option is used to enable touch pin control for specific SPRD/QCOM platform.
+ * This compile option is used for specific SPRD/QCOM platform only.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+/*
+ * Note.
+ * The below compile option is used to distinguish different workqueue scheduling mechanism when firmware report finger touch to device driver by IRQ interrupt.
+ * For MTK platform, there are two type of workqueue scheduling mechanism available.
+ * Please refer to the related code which is enclosed by compile option CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM in mstar_drv_platform_porting_layer.c for more detail.
+ * This compile option is used for MTK platform only.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+
+/*
+ * Note.
+ * The below compile option is used to apply DMA mode for read/write data between device driver and firmware by I2C.
+ * The DMA mode is used to reslove I2C read/write 8 bytes limitation for specific MTK BB chip(EX. MT6589/MT6572/...)
+ * This compile option is used for MTK platform only.
+ * By default, this compile option is disabled.
+ */
+#define CONFIG_ENABLE_DMA_IIC
+
+
+/*
+ * Note.
+ * The below compile option is used to enable the specific device driver code handling when touch panel support virtual key(EX. Menu, Home, Back, Search).
+ * If this compile option is not defined, the function for virtual key handling will be disabled.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_TP_HAVE_KEY
+
+/*
+ * Note.
+ * Since specific MTK BB chip report virtual key touch by using coordinate instead of key code, the below compile option is used to enable the code handling for reporting key with coordinate.
+ * By default, this compile option is disabled.
+ */
+#define CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+
+/*
+ * Note.
+ * The below flag is used to enable debug mode data log for firmware.
+ * Please make sure firmware support debug mode data log firstly, then you can enable this flag.
+ * By default, this flag is enabled.
+ */
+#define CONFIG_ENABLE_FIRMWARE_DATA_LOG (0)   // 1 : Enable, 0 : Disable
+
+/*
+ * Note.
+ * The below compile option is used to enable segment read debug mode finger touch data for MSG26XXM/MSG28XX only.
+ * Since I2C transaction length limitation for some specific MTK BB chip(EX. MT6589/MT6572/...) or QCOM BB chip, the debug mode finger touch data of MSG26XXM/MSG28XX can not be retrieved by one time I2C read operation.  
+ * So we need to retrieve the complete finger touch data by segment read.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+
+/*
+ * Note.
+ * The below compile option is used to enable gesture wakeup.
+ * By default, this compile option is disabled.
+ */
+#define CONFIG_ENABLE_GESTURE_WAKEUP
+
+// ------------------- #ifdef CONFIG_ENABLE_GESTURE_WAKEUP ------------------- //
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*
+ * Note.
+ * The below compile option is used to enable device driver to support at most 64 types of gesture wakeup mode.
+ * If the below compile option is not enabled, device driver can only support at most 16 types of gesture wakeup mode.
+ * By the way, 64 types of gesture wakeup mode is ready for MSG22XX/MSG28XX only.
+ * But, 64 types of gesture wakeup mode for MSG21XXA/MSG26XXM is not supported.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+
+/*
+ * Note.
+ * The below compile option is used to enable gesture debug mode.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+/*
+ * Note.
+ * The below compile option is used to enable gesture information mode.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+// ------------------- #endif CONFIG_ENABLE_GESTURE_WAKEUP ------------------- //
+
+
+/*
+ * Note.
+ * The below compile option shall be used when compile option CONFIG_ENABLE_ITO_MP_TEST or CONFIG_UPDATE_FIRMWARE_BY_SW_ID is enabled.
+ * One or more than one the below compile option can be enabled based on the touch ic that customer project are used.
+ * By default, the below compile option are all disabled.
+ */
+//#define CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+#define CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+//#define CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+//#define CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+
+/*
+ * Note.
+ * The below compile option is used to enable phone level MP test handling.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_ITO_MP_TEST
+
+// ------------------- #ifdef CONFIG_ENABLE_ITO_MP_TEST ------------------- //
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+
+/*
+ * Note.
+ * The below compile option is used to enable the specific short test item of 2R triangle pattern for self-capacitive touch ic.
+ * This compile option is used for MSG21XXA/MSG22XX only.
+ * Please enable the compile option if the ITO pattern is 2R triangle pattern for MSG21XXA/MSG22XX.
+ * Please disable the compile option if the ITO pattern is H(horizontal) triangle pattern for MSG21XXA/MSG22XX.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+// ------------------- #endif CONFIG_ENABLE_ITO_MP_TEST ------------------- //
+
+
+/*
+ * Note.
+ * If this compile option is not defined, the SW ID mechanism for updating firmware will be disabled.
+ * By default, this compile option is disabled.
+ */
+#define CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+// ------------------- #ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID ------------------- //
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+/*
+ * Note.
+ * If this compile option is defined, the update firmware bin file shall be stored in a two dimensional array format.
+ * Else, the update firmware bin file shall be stored in an one dimensional array format.
+ * Be careful, MSG22XX only support storing update firmware bin file in an one dimensional array format, it does not support two dimensional array format.
+ * By default, this compile option is enabled.
+ */
+//#define CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY 
+
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+// ------------------- #endif CONFIG_UPDATE_FIRMWARE_BY_SW_ID ------------------- //
+
+
+/*
+ * Note.
+ * The below compile option is used to enable hotknot and only supports MSG28XX.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_HOTKNOT
+
+
+/*
+ * Note.
+ * The below compile option is used to enable proximity detection.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_PROXIMITY_DETECTION
+
+/*
+ * Note.
+ * The below compile option is used to enable notifier feedback handling for SPRD/QCOM platform.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_NOTIFIER_FB
+
+
+/*
+ * Note.
+ * The below compile option is used to enable report rate calculation.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_ENABLE_COUNT_REPORT_RATE
+
+
+/*
+ * Note.
+ * The below compile option is used to enable glove mode and only supports MSG28XX.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_GLOVE_MODE
+
+
+/*
+ * Note.
+ * The below compile option is used to enable jni interface.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_ENABLE_JNI_INTERFACE
+
+
+/*
+ * Note.
+ * The below compile option is used to enable charger detection for notifying the charger plug in/plug out status to touch firmware.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_CHARGER_DETECTION
+
+
+/*
+ * Note.
+ * The below compile option is used to enable ESD protection.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_ESD_PROTECTION
+
+// ------------------- #ifdef CONFIG_ENABLE_ESD_PROTECTION ------------------- //
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+
+/*
+ * Note.
+ * There are two ESD protection check method.
+ * Method 1. Require the new ESD check command(CmdId:0x55) support from firmware which is currently implemented for MSG22XX only. So default is not supported.
+ * Method 2. Use read finger touch data for checking whether I2C connection is still available under ESD testing.
+ * By default, this compile option is disabled. It means use Method 2 as default ESD check method.
+ */
+//#define CONFIG_ENABLE_ESD_CHECK_COMMAND_BY_FIRMWARE
+
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+// ------------------- #endif CONFIG_ENABLE_ESD_PROTECTION ------------------- //
+
+
+/*
+ * Note.
+ * The below compile option is used to enable the debug code for clarifying some issues. For example, to debug the delay time issue for IC hardware reset.
+ * By the way, this feature is supported for MSG28XX only.
+ * By default, this compile option is disabled.
+ */
+#define CONFIG_ENABLE_CODE_FOR_DEBUG
+
+
+/*
+ * Note.
+ * The below compile option is used to enable/disable Type A/Type B multi-touch protocol for reporting touch point/key to Linux input sub-system.
+ * If this compile option is defined, Type B protocol is enabled.
+ * Else, Type A protocol is enabled.
+ * By default, this compile option is disabled.
+ */
+#define CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+
+/*
+ * Note.
+ * The below compile option is used to enable force touch for reporting touch point to Linux input sub-system.
+ * By the way, force touch is supported for MSG28XX only, but is not supported for MSG26XXM/MSG21XXA/MSG22XX yet.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_FORCE_TOUCH
+
+
+/*
+ * Note. 
+ * The below two compile option is used to enable update firmware with 8 byte or 32 byte each time for MSG28XX.
+ * If the below two compile option is disabled, then update firmware with 128 byte each time for MSG28XX.
+ * By default, the below two compile option is disabled.
+ */
+//#define CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_8_BYTE_EACH_TIME 
+//#define CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_32_BYTE_EACH_TIME
+
+
+/*
+ * Note. 
+ * The below compile option is used to enable high speed isp mode for update firmware of MSG28XX.
+ * By default, the below compile option is disabled.
+ */
+//#define CONFIG_ENABLE_HIGH_SPEED_ISP_MODE
+
+
+/*
+ * Note. 
+ * The below compile option is used to enable update firmware with I2C data rate 400KHz for MSG22XX.
+ * If this compile option is disabled, then update firmware with I2C data rate less than 400KHz for MSG22XX.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K 
+
+// ------------------- #ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K ------------------- //
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+/*
+ * Note.
+ * There are three methods to update firmware for MSG22XX(with chip revision >= 0x04) when I2C data rate is 400KHz.
+ * Method A. Enable I2C 400KHz burst write mode, let e-flash discard the last 2 dummy byte.
+ * Method B. Enable I2C 400KHz burst write mode, let e-flash discard the last 3 dummy byte.
+ * Method C. Enable I2C 400KHz non-burst write mode, only one byte can be written each time.
+ * By default, the compile option CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A is enabled.
+ */
+#define CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A
+//#define CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_B
+//#define CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_C
+
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+// ------------------- #endif CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K ------------------- //
+
+#define CONFIG_ENABLE_APK_PRINT_FW_LOG
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+#define u8   unsigned char
+#define u16  unsigned short
+#define u32  unsigned int
+#define s8   signed char
+#define s16  signed short
+#define s32  signed int
+#define s64  int64_t
+#define u64  uint64_t
+
+// Chip Id
+#define CHIP_TYPE_MSG21XX   (0x01) // EX. MSG2133
+#define CHIP_TYPE_MSG21XXA  (0x02) // EX. MSG2133A/MSG2138A(Besides, use version to distinguish MSG2133A/MSG2138A, you may refer to _DrvFwCtrlUpdateFirmwareCash()) 
+#define CHIP_TYPE_MSG26XXM  (0x03) // EX. MSG2633M
+#define CHIP_TYPE_MSG22XX   (0x7A) // EX. MSG2238/MSG2256
+#define CHIP_TYPE_MSG28XX   (0x85) // EX. MSG2856
+
+// Chip Revision
+#define CHIP_TYPE_MSG22XX_REVISION_U05   (0x04) // U05
+
+
+#define PACKET_TYPE_TOOTH_PATTERN   (0x20)
+#define PACKET_TYPE_GESTURE_WAKEUP  (0x50)
+#define PACKET_TYPE_GESTURE_DEBUG  		(0x51)
+#define PACKET_TYPE_GESTURE_INFORMATION	(0x52)
+#define PACKET_TYPE_ESD_CHECK_HW_RESET	(0x60)
+
+#define TOUCH_SCREEN_X_MIN   (0)
+#define TOUCH_SCREEN_Y_MIN   (0)
+/*
+ * Note.
+ * Please change the below touch screen resolution according to the touch panel that you are using.
+ */
+#define TOUCH_SCREEN_X_MAX   (480)  //LCD_WIDTH
+#define TOUCH_SCREEN_Y_MAX   (854) //LCD_HEIGHT
+/*
+ * Note.
+ * Please do not change the below setting.
+ */
+#define TPD_WIDTH   (2048)
+#define TPD_HEIGHT  (2048)
+
+
+#define BIT0  (1<<0)  // 0x0001
+#define BIT1  (1<<1)  // 0x0002
+#define BIT2  (1<<2)  // 0x0004
+#define BIT3  (1<<3)  // 0x0008
+#define BIT4  (1<<4)  // 0x0010
+#define BIT5  (1<<5)  // 0x0020
+#define BIT6  (1<<6)  // 0x0040
+#define BIT7  (1<<7)  // 0x0080
+#define BIT8  (1<<8)  // 0x0100
+#define BIT9  (1<<9)  // 0x0200
+#define BIT10 (1<<10) // 0x0400
+#define BIT11 (1<<11) // 0x0800
+#define BIT12 (1<<12) // 0x1000
+#define BIT13 (1<<13) // 0x2000
+#define BIT14 (1<<14) // 0x4000
+#define BIT15 (1<<15) // 0x8000
+
+
+#define MAX_DEBUG_REGISTER_NUM     (10)
+#define MAX_DEBUG_COMMAND_ARGUMENT_NUM      (4)
+
+#define MAX_UPDATE_FIRMWARE_BUFFER_SIZE    (130) // 130KB. The size shall be large enough for stored any kind firmware size of MSG21XXA(33KB)/MSG22XX(48.5KB)/MSG26XXM(40KB)/MSG28XX(130KB).
+
+#define MAX_I2C_TRANSACTION_LENGTH_LIMIT      (250) // Please change the value depends on the I2C transaction limitation for the platform that you are using.
+#define MAX_TOUCH_IC_REGISTER_BANK_SIZE       (256) // It is a fixed value and shall not be modified.
+
+
+#define PROCFS_AUTHORITY (0666)
+
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#define GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG     0x00000001    //0000 0000 0000 0000   0000 0000 0000 0001
+#define GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG        0x00000002    //0000 0000 0000 0000   0000 0000 0000 0010
+#define GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG      0x00000004    //0000 0000 0000 0000   0000 0000 0000 0100
+#define GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG      0x00000008    //0000 0000 0000 0000   0000 0000 0000 1000
+#define GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG     0x00000010    //0000 0000 0000 0000   0000 0000 0001 0000
+#define GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG      0x00000020    //0000 0000 0000 0000   0000 0000 0010 0000
+#define GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG      0x00000040    //0000 0000 0000 0000   0000 0000 0100 0000
+#define GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG      0x00000080    //0000 0000 0000 0000   0000 0000 1000 0000
+#define GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG      0x00000100    //0000 0000 0000 0000   0000 0001 0000 0000
+#define GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG      0x00000200    //0000 0000 0000 0000   0000 0010 0000 0000
+#define GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG      0x00000400    //0000 0000 0000 0000   0000 0100 0000 0000
+#define GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG      0x00000800    //0000 0000 0000 0000   0000 1000 0000 0000
+#define GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG      0x00001000    //0000 0000 0000 0000   0001 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE1_FLAG         0x00002000    //0000 0000 0000 0000   0010 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE2_FLAG         0x00004000    //0000 0000 0000 0000   0100 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE3_FLAG         0x00008000    //0000 0000 0000 0000   1000 0000 0000 0000
+
+#ifdef CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+#define GESTURE_WAKEUP_MODE_RESERVE4_FLAG         0x00010000    //0000 0000 0000 0001   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE5_FLAG         0x00020000    //0000 0000 0000 0010   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE6_FLAG         0x00040000    //0000 0000 0000 0100   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE7_FLAG         0x00080000    //0000 0000 0000 1000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE8_FLAG         0x00100000    //0000 0000 0001 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE9_FLAG         0x00200000    //0000 0000 0010 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE10_FLAG        0x00400000    //0000 0000 0100 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE11_FLAG        0x00800000    //0000 0000 1000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE12_FLAG        0x01000000    //0000 0001 0000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE13_FLAG        0x02000000    //0000 0010 0000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE14_FLAG        0x04000000    //0000 0100 0000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE15_FLAG        0x08000000    //0000 1000 0000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE16_FLAG        0x10000000    //0001 0000 0000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE17_FLAG        0x20000000    //0010 0000 0000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE18_FLAG        0x40000000    //0100 0000 0000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE19_FLAG        0x80000000    //1000 0000 0000 0000   0000 0000 0000 0000
+
+#define GESTURE_WAKEUP_MODE_RESERVE20_FLAG        0x00000001    //0000 0000 0000 0000   0000 0000 0000 0001
+#define GESTURE_WAKEUP_MODE_RESERVE21_FLAG        0x00000002    //0000 0000 0000 0000   0000 0000 0000 0010
+#define GESTURE_WAKEUP_MODE_RESERVE22_FLAG        0x00000004    //0000 0000 0000 0000   0000 0000 0000 0100
+#define GESTURE_WAKEUP_MODE_RESERVE23_FLAG        0x00000008    //0000 0000 0000 0000   0000 0000 0000 1000
+#define GESTURE_WAKEUP_MODE_RESERVE24_FLAG        0x00000010    //0000 0000 0000 0000   0000 0000 0001 0000
+#define GESTURE_WAKEUP_MODE_RESERVE25_FLAG        0x00000020    //0000 0000 0000 0000   0000 0000 0010 0000
+#define GESTURE_WAKEUP_MODE_RESERVE26_FLAG        0x00000040    //0000 0000 0000 0000   0000 0000 0100 0000
+#define GESTURE_WAKEUP_MODE_RESERVE27_FLAG        0x00000080    //0000 0000 0000 0000   0000 0000 1000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE28_FLAG        0x00000100    //0000 0000 0000 0000   0000 0001 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE29_FLAG        0x00000200    //0000 0000 0000 0000   0000 0010 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE30_FLAG        0x00000400    //0000 0000 0000 0000   0000 0100 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE31_FLAG        0x00000800    //0000 0000 0000 0000   0000 1000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE32_FLAG        0x00001000    //0000 0000 0000 0000   0001 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE33_FLAG        0x00002000    //0000 0000 0000 0000   0010 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE34_FLAG        0x00004000    //0000 0000 0000 0000   0100 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE35_FLAG        0x00008000    //0000 0000 0000 0000   1000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE36_FLAG        0x00010000    //0000 0000 0000 0001   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE37_FLAG        0x00020000    //0000 0000 0000 0010   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE38_FLAG        0x00040000    //0000 0000 0000 0100   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE39_FLAG        0x00080000    //0000 0000 0000 1000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE40_FLAG        0x00100000    //0000 0000 0001 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE41_FLAG        0x00200000    //0000 0000 0010 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE42_FLAG        0x00400000    //0000 0000 0100 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE43_FLAG        0x00800000    //0000 0000 1000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE44_FLAG        0x01000000    //0000 0001 0000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE45_FLAG        0x02000000    //0000 0010 0000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE46_FLAG        0x04000000    //0000 0100 0000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE47_FLAG        0x08000000    //0000 1000 0000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE48_FLAG        0x10000000    //0001 0000 0000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE49_FLAG        0x20000000    //0010 0000 0000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE50_FLAG        0x40000000    //0100 0000 0000 0000   0000 0000 0000 0000
+#define GESTURE_WAKEUP_MODE_RESERVE51_FLAG        0x80000000    //1000 0000 0000 0000   0000 0000 0000 0000
+#endif //CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+
+#define GESTURE_WAKEUP_PACKET_LENGTH    (6)
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+#define GESTURE_DEBUG_MODE_PACKET_LENGTH	(128)
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+#define GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH	(128)
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#define FEATURE_GESTURE_WAKEUP_MODE         0x0001   
+#define FEATURE_GESTURE_DEBUG_MODE          0x0002
+#define FEATURE_GESTURE_INFORMATION_MODE    0x0003
+
+#define FEATURE_TOUCH_DRIVER_DEBUG_LOG      0x0010
+#define FEATURE_FIRMWARE_DATA_LOG           0x0011
+#define FEATURE_FORCE_TO_UPDATE_FIRMWARE    0x0012
+
+
+#define I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE   (20) // delay 20ms
+
+#define I2C_SMBUS_WRITE_COMMAND_DELAY_FOR_QCOM_PLATFORM   (5) // delay 5ms
+
+#define I2C_SMBUS_READ_COMMAND_DELAY_FOR_SPRD_PLATFORM   (5) // delay 5ms
+
+#define FIRMWARE_FILE_PATH_ON_SD_CARD      "/mnt/sdcard/msctp_update.bin"
+
+#define POWER_SUPPLY_BATTERY_STATUS_PATCH  "/sys/class/power_supply/battery/status"
+
+#define ESD_PROTECT_CHECK_PERIOD   (300) // delay 3s
+#define ESD_CHECK_HW_RESET_PACKET_LENGTH    (8)
+
+/*
+ * Note.
+ * The below flag is used to enable the output log mechanism while touch device driver is running.
+ * If the debug log level is set as 0, the function for output log will be disabled.
+ * By default, the debug log level is set as 1.
+ */
+#define CONFIG_TOUCH_DRIVER_DEBUG_LOG_LEVEL (0)   // 1 : Default, 0 : No log. The bigger value, the more detailed log is output.
+#define ESD_RESET_FLAG      (2)
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+extern u8 TOUCH_DRIVER_DEBUG_LOG_LEVEL;
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR MACRO DEFINITION                                            */
+/*--------------------------------------------------------------------------*/
+
+
+#define DEBUG_LEVEL(level, dev, fmt, arg...) do {\
+	                                           if (level <= TOUCH_DRIVER_DEBUG_LOG_LEVEL)\
+	                                               printk(fmt, ##arg);\
+                                        } while (0)
+
+#define DBG(dev, fmt, arg...) DEBUG_LEVEL(1, dev, fmt, ##arg) 
+/*
+#define DEBUG_LEVEL(level, dev, fmt, arg...) do {\
+	                                           if (level <= TOUCH_DRIVER_DEBUG_LOG_LEVEL)\
+	                                               dev_info(dev, fmt, ##arg);\
+                                        } while (0)
+
+#define DBG(dev, fmt, arg...) DEBUG_LEVEL(1, dev, fmt, ##arg)
+*/
+
+/*--------------------------------------------------------------------------*/
+/* DATA TYPE DEFINITION                                                     */
+/*--------------------------------------------------------------------------*/
+
+typedef enum
+{
+    EMEM_ALL = 0,
+    EMEM_MAIN,
+    EMEM_INFO
+} EmemType_e;
+
+typedef enum
+{
+    ITO_TEST_MODE_OPEN_TEST = 1,
+    ITO_TEST_MODE_SHORT_TEST = 2,
+    ITO_TEST_MODE_WATERPROOF_TEST = 3
+} ItoTestMode_e;
+
+typedef enum
+{
+    ITO_TEST_OK = 0,
+    ITO_TEST_FAIL,
+    ITO_TEST_GET_TP_TYPE_ERROR,
+    ITO_TEST_UNDEFINED_ERROR,
+    ITO_TEST_UNDER_TESTING
+
+} ItoTestResult_e;
+
+typedef enum
+{
+    ADDRESS_MODE_8BIT = 0,
+    ADDRESS_MODE_16BIT = 1
+} AddressMode_e;
+
+typedef enum
+{
+    MUTUAL = 0,
+    SELF,
+    WATERPROOF,
+    MUTUAL_SINGLE_DRIVE
+} ItoTestFwMode_e;
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL VARIABLE DEFINITION                                               */
+/*--------------------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+extern u8 DrvCommonCalculateCheckSum(u8 *pMsg, u32 nLength);
+extern u32 DrvCommonConvertCharToHexDigit(char *pCh, u32 nLength);
+extern u32 DrvCommonCrcDoReflect(u32 nRef, s8 nCh);
+extern u32 DrvCommonCrcGetValue(u32 nText, u32 nPrevCRC);
+extern void DrvCommonCrcInitTable(void);
+extern void DrvCommonReadFile(char *pFilePath, u8 *pBuf, u16 nLength);
+
+#endif  /* __MSTAR_DRV_COMMON_H__ */
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_hotknot_queue.h
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_hotknot_queue.h	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_hotknot_queue.h	(revision 166572)
@@ -0,0 +1,63 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_hotknot_queue.h
+ *
+ * @brief   This file defines the queue structure for hotknot
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_HOTKNOT_QUEUE_H__
+#define __MSTAR_DRV_HOTKNOT_QUEUE_H__
+
+
+////////////////////////////////////////////////////////////
+/// Included Files
+////////////////////////////////////////////////////////////
+
+#include "mstar_drv_common.h"
+
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+////////////////////////////////////////////////////////////
+/// Constant
+////////////////////////////////////////////////////////////
+#define HOTKNOT_QUEUE_SIZE               1024
+
+
+////////////////////////////////////////////////////////////
+/// Variables
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Function Prototype
+////////////////////////////////////////////////////////////
+extern void CreateQueue(void);
+extern void ClearQueue(void);
+extern int PushQueue(u8 * pBuf, u16 nLength);
+extern int PopQueue(u8 * pBuf, u16 nLength);
+extern int ShowQueue(u8 * pBuf, u16 nLength);    //just show data, not fetch data
+extern void ShowAllQueue(u8 * pBuf, u16 * pFront, u16 * pRear);    //just show data, not fetch data
+extern void DeleteQueue(void);
+
+
+#endif //CONFIG_ENABLE_HOTKNOT
+#endif // __MSTAR_DRV_HOTKNOT_QUEUE_H__
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_qcom.c
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_qcom.c	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_qcom.c	(revision 166572)
@@ -0,0 +1,172 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_qcom.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+ 
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/kobject.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include "mstar_drv_platform_interface.h"
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+#include <linux/regulator/consumer.h>
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+/*=============================================================*/
+// CONSTANT VALUE DEFINITION
+/*=============================================================*/
+
+#define MSG_TP_IC_NAME "msg2xxx" //"msg21xxA" or "msg22xx" or "msg26xxM" or "msg28xx" /* Please define the mstar touch ic name based on the mutual-capacitive ic or self capacitive ic that you are using */
+
+/*=============================================================*/
+// VARIABLE DEFINITION
+/*=============================================================*/
+
+struct i2c_client *g_I2cClient = NULL;
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+struct regulator *g_ReguVdd = NULL;
+struct regulator *g_ReguVcc_i2c = NULL;
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+/*=============================================================*/
+// FUNCTION DEFINITION
+/*=============================================================*/
+
+/* probe function is used for matching and initializing input device */
+static int /*__devinit*/ touch_driver_probe(struct i2c_client *client,
+        const struct i2c_device_id *id)
+{
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+    int ret = 0;
+    const char *vdd_name = "vdd";
+    const char *vcc_i2c_name = "vcc_i2c";
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+    printk("*** %s ***\n", __func__);
+    
+    if (client == NULL)
+    {
+        printk("i2c client is NULL\n");
+        return -1;
+    }
+    g_I2cClient = client;
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+    g_ReguVdd = regulator_get(&g_I2cClient->dev, vdd_name);
+
+    ret = regulator_set_voltage(g_ReguVdd, 2800000, 2800000); 
+    if (ret)
+    {
+        printk("Could not set to 2800mv.\n");
+    }
+
+    g_ReguVcc_i2c = regulator_get(&g_I2cClient->dev, vcc_i2c_name);
+
+    ret = regulator_set_voltage(g_ReguVcc_i2c, 1800000, 1800000);  
+    if (ret)
+    {
+        printk("Could not set to 1800mv.\n");
+    }
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+    return MsDrvInterfaceTouchDeviceProbe(g_I2cClient, id);
+}
+
+/* remove function is triggered when the input device is removed from input sub-system */
+static int touch_driver_remove(struct i2c_client *client)
+{
+    printk("*** %s ***\n", __func__);
+
+    return MsDrvInterfaceTouchDeviceRemove(client);
+}
+
+/* The I2C device list is used for matching I2C device and I2C device driver. */
+static const struct i2c_device_id touch_device_id[] =
+{
+    {MSG_TP_IC_NAME, 0},
+    {}, /* should not omitted */ 
+};
+
+MODULE_DEVICE_TABLE(i2c, touch_device_id);
+
+static struct of_device_id touch_match_table[] = {
+    { .compatible = "mstar,msg2xxx",},
+    {},
+};
+
+static struct i2c_driver touch_device_driver =
+{
+    .driver = {
+        .name = MSG_TP_IC_NAME,
+        .owner = THIS_MODULE,
+        .of_match_table = touch_match_table,
+    },
+    .probe = touch_driver_probe,
+    .remove = touch_driver_remove,
+    .id_table = touch_device_id,
+};
+
+static int __init touch_driver_init(void)
+{
+    int ret;
+
+    /* register driver */
+    ret = i2c_add_driver(&touch_device_driver);
+    if (ret < 0)
+    {
+        printk("add MStar touch device driver i2c driver failed.\n");
+        return -ENODEV;
+    }
+    printk("add MStar touch device driver i2c driver.\n");
+
+    return ret;
+}
+
+static void __exit touch_driver_exit(void)
+{
+    printk("remove MStar touch device driver i2c driver.\n");
+
+    i2c_del_driver(&touch_device_driver);
+}
+
+module_init(touch_driver_init);
+module_exit(touch_driver_exit);
+MODULE_LICENSE("GPL");
\ No newline at end of file
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_jni_interface.c
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_jni_interface.c	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_jni_interface.c	(revision 166572)
@@ -0,0 +1,304 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_jni_interface.c
+ *
+ * @brief   This file defines the jni interface functions
+ *
+ *
+ */
+
+////////////////////////////////////////////////////////////
+/// Included Files
+////////////////////////////////////////////////////////////
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kthread.h>
+#include <asm/uaccess.h>
+#include "mstar_drv_jni_interface.h"
+#include "mstar_drv_utility_adaption.h"
+#include "mstar_drv_platform_porting_layer.h"
+
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+////////////////////////////////////////////////////////////
+/// EXTERN VARIABLE DECLARATION
+////////////////////////////////////////////////////////////
+extern u32 SLAVE_I2C_ID_DBBUS;
+extern u32 SLAVE_I2C_ID_DWI2C;
+extern u8 g_IsHotknotEnabled;
+extern u8 g_IsBypassHotknot;
+extern struct i2c_client *g_I2cClient;
+
+
+////////////////////////////////////////////////////////////
+/// LOCAL VARIABLE DEFINITION
+////////////////////////////////////////////////////////////
+static MsgToolDrvCmd_t * _gMsgToolCmdIn = NULL;
+static u8 * _gSndCmdData = NULL;
+static u8 * _gRtnCmdData = NULL;
+
+
+
+void _DebugJniShowArray(u8 *pBuf, u16 nLen)
+{
+    int i;
+
+    for(i=0; i < nLen; i++)
+    {
+        DBG(&g_I2cClient->dev, "%02X ", pBuf[i]);       
+
+        if(i%16==15){  
+            DBG(&g_I2cClient->dev, "\n");
+        }
+    }
+    DBG(&g_I2cClient->dev, "\n");    
+}
+
+
+u64 PtrToU64(u8 * pValue)
+{
+	uintptr_t nValue = (uintptr_t)pValue;
+    return (u64)(0xFFFFFFFFFFFFFFFF&nValue);
+}
+
+u8 * U64ToPtr(u64 nValue)
+{
+	uintptr_t pValue = (uintptr_t)nValue;
+	return (u8 *)pValue;
+}
+
+
+ssize_t MsgToolRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+    long nRet = 0;
+    u8 nBusType = 0;
+    u16 nReadLen = 0;
+    u8 szCmdData[20] = {0};
+
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    //DBG(&g_I2cClient->dev, "*** nCount = %d ***\n", (int)nCount);       
+    nBusType = nCount&0xFF;
+    nReadLen = (nCount >> 8)&0xFFFF;
+    if(nBusType == SLAVE_I2C_ID_DBBUS || nBusType == SLAVE_I2C_ID_DWI2C)
+    {    
+        IicReadData(nBusType, &szCmdData[0], nReadLen);
+    }
+    
+	nRet = copy_to_user(pBuffer, &szCmdData[0], nReadLen); 
+
+    return nRet;
+}			  
+
+
+ssize_t MsgToolWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos)  
+{
+    long nRet = 0;	                       
+    u8 nBusType = 0;  
+    u16 nWriteLen = 0;    
+    u8 szCmdData[20] = {0};    
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    //DBG(&g_I2cClient->dev, "*** nCount = %d ***\n", (int)nCount);        
+    nBusType = nCount&0xFF;
+    nWriteLen = (nCount >> 8)&0xFFFF;    
+    nRet = copy_from_user(szCmdData, &pBuffer[0], nWriteLen);         
+    if(nBusType == SLAVE_I2C_ID_DBBUS || nBusType == SLAVE_I2C_ID_DWI2C)
+    {
+        IicWriteData(nBusType, &szCmdData[0], nWriteLen);    
+    }
+
+    return nRet;
+}
+
+
+void _RegGetXByteData(MsgToolDrvCmd_t * pCmd)
+{    
+    u16 nAddr = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);    
+    nAddr = (_gSndCmdData[1]<<8)|_gSndCmdData[0];    
+    RegGetXBitValue(nAddr, _gRtnCmdData, pCmd->nRtnCmdLen, MAX_I2C_TRANSACTION_LENGTH_LIMIT);
+    //_DebugJniShowArray(_gRtnCmdData, pCmd->nRtnCmdLen);
+}
+
+
+void _ClearMsgToolMem(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+  
+    memset(_gMsgToolCmdIn, 0, sizeof( MsgToolDrvCmd_t ));
+    memset(_gSndCmdData, 0, 1024);
+    memset(_gRtnCmdData, 0, 1024);
+}
+
+
+static MsgToolDrvCmd_t* _TransJniCmdFromUser( unsigned long nArg )
+{
+    long nRet; 
+    MsgToolDrvCmd_t tCmdIn;    
+    MsgToolDrvCmd_t *pTransCmd;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);  
+    _ClearMsgToolMem();
+    pTransCmd = (MsgToolDrvCmd_t *)_gMsgToolCmdIn;    
+    nRet = copy_from_user( &tCmdIn, (void*)nArg, sizeof( MsgToolDrvCmd_t ) );
+    pTransCmd->nCmdId = tCmdIn.nCmdId;
+
+    //_DebugJniShowArray(&tCmdIn, sizeof( MsgToolDrvCmd_t));
+    if(tCmdIn.nSndCmdLen > 0)
+    {
+        pTransCmd->nSndCmdLen = tCmdIn.nSndCmdLen;
+        nRet = copy_from_user( _gSndCmdData, U64ToPtr(tCmdIn.nSndCmdDataPtr), pTransCmd->nSndCmdLen );    	
+    }
+
+    if(tCmdIn.nRtnCmdLen > 0)
+    {
+	    pTransCmd->nRtnCmdLen = tCmdIn.nRtnCmdLen;
+        nRet = copy_from_user( _gRtnCmdData, U64ToPtr(tCmdIn.nRtnCmdDataPtr), pTransCmd->nRtnCmdLen );    	        
+    }
+  
+    return pTransCmd;
+}
+
+
+static void _TransJniCmdToUser( MsgToolDrvCmd_t *pTransCmd, unsigned long nArg )
+{
+    MsgToolDrvCmd_t tCmdOut;
+    long nRet;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);      
+    nRet = copy_from_user( &tCmdOut, (void*)nArg, sizeof( MsgToolDrvCmd_t ) );   
+
+    //_DebugJniShowArray(&tCmdOut, sizeof( MsgToolDrvCmd_t));    
+    nRet = copy_to_user( U64ToPtr(tCmdOut.nRtnCmdDataPtr), _gRtnCmdData, tCmdOut.nRtnCmdLen);
+}
+
+
+long MsgToolIoctl( struct file *pFile, unsigned int nCmd, unsigned long nArg )
+{
+    long nRet = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);    
+    switch ( nCmd )
+    {
+        case MSGTOOL_IOCTL_RUN_CMD:
+            {      
+                MsgToolDrvCmd_t *pTransCmd;			
+                pTransCmd = _TransJniCmdFromUser( nArg );  
+                switch (pTransCmd->nCmdId)
+                {
+                    case MSGTOOL_RESETHW:
+                        DrvPlatformLyrTouchDeviceResetHw();
+                        break;
+                    case MSGTOOL_REGGETXBYTEVALUE:
+                        _RegGetXByteData(pTransCmd);                       
+	                    _TransJniCmdToUser(pTransCmd, nArg);                                                 
+                        break;
+                    case MSGTOOL_HOTKNOTSTATUS:
+                        _gRtnCmdData[0] = g_IsHotknotEnabled;                       
+                        _TransJniCmdToUser(pTransCmd, nArg);                                                 
+                        break;
+                    case MSGTOOL_FINGERTOUCH:
+                        if(pTransCmd->nSndCmdLen == 1)
+                        {
+                            DBG(&g_I2cClient->dev, "*** JNI enable touch ***\n");                        
+                            DrvPlatformLyrEnableFingerTouchReport();
+                        }
+                        else if(pTransCmd->nSndCmdLen == 0)
+                        {
+                            DBG(&g_I2cClient->dev, "*** JNI disable touch ***\n");                                                
+                            DrvPlatformLyrDisableFingerTouchReport();
+                        }
+                        break;
+                    case MSGTOOL_BYPASSHOTKNOT:
+                        if(pTransCmd->nSndCmdLen == 1)
+                        {
+                            DBG(&g_I2cClient->dev, "*** JNI enable bypass hotknot ***\n");                                                
+                            g_IsBypassHotknot = 1;                                                      
+                        }
+                        else if(pTransCmd->nSndCmdLen == 0)
+                        {
+                            DBG(&g_I2cClient->dev, "*** JNI disable bypass hotknot ***\n");                                                
+                            g_IsBypassHotknot = 0;
+                        }
+                        break;
+                    case MSGTOOL_DEVICEPOWEROFF:
+                        DrvPlatformLyrTouchDevicePowerOff();
+                        break;                        
+                    case MSGTOOL_GETSMDBBUS:
+                        DBG(&g_I2cClient->dev, "*** MSGTOOL_GETSMDBBUS ***\n");
+                        _gRtnCmdData[0] = SLAVE_I2C_ID_DBBUS&0xFF;                       
+                        _gRtnCmdData[1] = SLAVE_I2C_ID_DWI2C&0xFF;                                               
+                        _TransJniCmdToUser(pTransCmd, nArg);                                                 
+                        break;
+                    case MSGTOOL_SETIICDATARATE:
+                        DBG(&g_I2cClient->dev, "*** MSGTOOL_SETIICDATARATE ***\n");                        
+                        DrvPlatformLyrSetIicDataRate(g_I2cClient, ((_gSndCmdData[1]<<8)|_gSndCmdData[0])*1000);
+                        break;                        
+                    default:  
+                        break;
+                }		            
+            }   
+		    break;
+		
+        default:
+            nRet = -EINVAL;
+            break;
+    }
+
+    return nRet;
+}
+
+
+void CreateMsgToolMem(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    _gMsgToolCmdIn = (MsgToolDrvCmd_t*)kmalloc( sizeof( MsgToolDrvCmd_t ), GFP_KERNEL );
+    _gSndCmdData = (u8*)kmalloc(1024, GFP_KERNEL );	
+    _gRtnCmdData = (u8*)kmalloc(1024, GFP_KERNEL );           
+}
+
+
+void DeleteMsgToolMem(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+ 
+    if (_gMsgToolCmdIn)
+    {
+        kfree(_gMsgToolCmdIn);
+        _gMsgToolCmdIn = NULL;
+    }
+    
+    if (_gSndCmdData)
+    {
+        kfree(_gSndCmdData);
+        _gSndCmdData = NULL;
+    }
+    
+    if (_gRtnCmdData)
+    {
+        kfree(_gRtnCmdData);
+        _gRtnCmdData = NULL;
+    }
+}
+
+#endif //CONFIG_ENABLE_JNI_INTERFACE
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_platform_interface.c
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_platform_interface.c	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_platform_interface.c	(revision 166572)
@@ -0,0 +1,737 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_platform_interface.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_platform_interface.h"
+#include "mstar_drv_main.h"
+#include "mstar_drv_ic_fw_porting_layer.h"
+#include "mstar_drv_platform_porting_layer.h"
+#include "mstar_drv_utility_adaption.h"
+#include <linux/irq.h>
+#include <linux/of_gpio.h>
+
+int gpio_isr = 0;
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+#include "mstar_drv_hotknot.h"
+#endif //CONFIG_ENABLE_HOTKNOT
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern u32 g_GestureWakeupMode[2];
+extern u8 g_GestureWakeupFlag;
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+extern u8 g_GestureDebugFlag;
+extern u8 g_GestureDebugMode;
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+extern u8 g_EnableTpProximity;
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+extern u8 g_IsEnableGloveMode;
+#endif //CONFIG_ENABLE_GLOVE_MODE
+
+extern u8 g_IsUpdateFirmware;
+
+extern struct input_dev *g_InputDevice;
+extern struct i2c_client *g_I2cClient;
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+extern u8 g_HotKnotState;
+extern u32 SLAVE_I2C_ID_DWI2C;
+#endif //CONFIG_ENABLE_HOTKNOT
+
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION
+extern u8 g_ForceUpdate;
+#endif //CONFIG_ENABLE_CHARGER_DETECTION
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+extern int g_IsEnableEsdCheck;
+extern struct delayed_work g_EsdCheckWork;
+extern struct workqueue_struct *g_EsdCheckWorkqueue;
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+
+extern u8 IS_FIRMWARE_DATA_LOG_ENABLED;
+
+#define TP_READ_VER
+
+#ifdef TP_READ_VER
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/proc_fs.h>
+
+#define TP_VER_PROC_FILE	    "tp_ver"
+static struct proc_dir_entry *tp_ver_proc = NULL;
+
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+bool TP_gesture_Switch = false;
+static unsigned long TP_gesture_value = 0x0;
+
+#endif
+
+/*=============================================================*/
+// GLOBAL VARIABLE DEFINITION
+/*=============================================================*/
+
+
+/*=============================================================*/
+// LOCAL VARIABLE DEFINITION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+static u8 _gAMStartCmd[4] = {HOTKNOT_SEND, ADAPTIVEMOD_BEGIN, 0, 0};
+#endif //CONFIG_ENABLE_HOTKNOT
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+#ifdef TP_READ_VER
+static int get_tp_ver_proc(struct file *file, char *buffer, size_t count, loff_t *ppos)
+{
+	u16 data_buf[3];
+	u8 *firmwareVersion= NULL;
+	printk("tpd_info_read  \n");
+
+	
+
+	 DrvIcFwLyrGetCustomerFirmwareVersion(&data_buf[1],&data_buf[0],&firmwareVersion);
+	if(copy_to_user(buffer, (char*)data_buf, sizeof(data_buf)))
+	{
+		
+		printk("tpd_info_read   version \n");
+		return -EFAULT;
+	}
+	return count;
+
+}
+
+static const struct file_operations gt_tp_ver_proc_fops = { 
+    .read = get_tp_ver_proc
+};
+#endif
+
+#ifdef CONFIG_ENABLE_NOTIFIER_FB
+int MsDrvInterfaceTouchDeviceFbNotifierCallback(struct notifier_block *pSelf, unsigned long nEvent, void *pData)
+{
+    struct fb_event *pEventData = pData;
+    int *pBlank;
+
+    if (pEventData && pEventData->data && nEvent == FB_EVENT_BLANK)
+    {
+        pBlank = pEventData->data;
+
+        if (*pBlank == FB_BLANK_UNBLANK)
+        {
+            DBG(&g_I2cClient->dev, "*** %s() TP Resume ***\n", __func__);
+
+            if (g_IsUpdateFirmware != 0) // Check whether update frimware is finished
+            {
+                DBG(&g_I2cClient->dev, "Not allow to power on/off touch ic while update firmware.\n");
+                return 0;
+            }
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+            if (g_EnableTpProximity == 1)
+            {
+                DBG(&g_I2cClient->dev, "g_EnableTpProximity = %d\n", g_EnableTpProximity);
+                return 0;
+            }
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+            
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_HOTKNOT
+            if (g_HotKnotState != HOTKNOT_BEFORE_TRANS_STATE && g_HotKnotState != HOTKNOT_TRANS_STATE && g_HotKnotState != HOTKNOT_AFTER_TRANS_STATE)
+#endif //CONFIG_ENABLE_HOTKNOT
+            {
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+                if (g_GestureDebugMode == 1)
+                {
+                    DrvIcFwLyrCloseGestureDebugMode();
+                }
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+                if (g_GestureWakeupFlag == 1)
+                {
+                    DrvIcFwLyrCloseGestureWakeup();
+                }
+                else
+                {
+                    DrvPlatformLyrEnableFingerTouchReport(); 
+                }
+            }
+#ifdef CONFIG_ENABLE_HOTKNOT
+            else    // Enable touch in hotknot transfer mode
+            {
+                DrvPlatformLyrEnableFingerTouchReport();     
+            }
+#endif //CONFIG_ENABLE_HOTKNOT
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+    
+#ifdef CONFIG_ENABLE_HOTKNOT
+            if (g_HotKnotState != HOTKNOT_BEFORE_TRANS_STATE && g_HotKnotState != HOTKNOT_TRANS_STATE && g_HotKnotState != HOTKNOT_AFTER_TRANS_STATE)
+#endif //CONFIG_ENABLE_HOTKNOT        
+            {
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+                DrvPlatformLyrTouchDeviceRegulatorPowerOn(true);
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON               
+                DrvPlatformLyrTouchDevicePowerOn(); 
+            }   
+    
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION 
+            {
+                u8 szChargerStatus[20] = {0};
+     
+                DrvCommonReadFile("/sys/class/power_supply/battery/status", szChargerStatus, 20);
+            
+                DBG(&g_I2cClient->dev, "*** Battery Status : %s ***\n", szChargerStatus);
+            
+                g_ForceUpdate = 1; // Set flag to force update charger status
+                
+                if (strstr(szChargerStatus, "Charging") != NULL || strstr(szChargerStatus, "Full") != NULL || strstr(szChargerStatus, "Fully charged") != NULL) // Charging
+                {
+                    DrvFwCtrlChargerDetection(1); // charger plug-in
+                }
+                else // Not charging
+                {
+                    DrvFwCtrlChargerDetection(0); // charger plug-out
+                }
+
+                g_ForceUpdate = 0; // Clear flag after force update charger status
+            }           
+#endif //CONFIG_ENABLE_CHARGER_DETECTION
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+            if (g_IsEnableGloveMode == 1)
+            {
+                DrvIcFwLyrOpenGloveMode();
+            }
+#endif //CONFIG_ENABLE_GLOVE_MODE
+
+            if (IS_FIRMWARE_DATA_LOG_ENABLED)    
+            {
+                DrvIcFwLyrRestoreFirmwareModeToLogDataMode(); // Mark this function call for avoiding device driver may spend longer time to resume from suspend state.
+            } //IS_FIRMWARE_DATA_LOG_ENABLED
+
+#ifndef CONFIG_ENABLE_GESTURE_WAKEUP
+            DrvPlatformLyrEnableFingerTouchReport(); 
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+            g_IsEnableEsdCheck = 1;
+            queue_delayed_work(g_EsdCheckWorkqueue, &g_EsdCheckWork, ESD_PROTECT_CHECK_PERIOD);
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+        }
+        else if (*pBlank == FB_BLANK_POWERDOWN)
+        {
+            DBG(&g_I2cClient->dev, "*** %s() TP Suspend ***\n", __func__);
+            
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+            g_IsEnableEsdCheck = 0;
+            cancel_delayed_work_sync(&g_EsdCheckWork);
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+
+            if (g_IsUpdateFirmware != 0) // Check whether update frimware is finished
+            {
+                DBG(&g_I2cClient->dev, "Not allow to power on/off touch ic while update firmware.\n");
+                return 0;
+            }
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+            if (g_EnableTpProximity == 1)
+            {
+                DBG(&g_I2cClient->dev, "g_EnableTpProximity = %d\n", g_EnableTpProximity);
+                return 0;
+            }
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_HOTKNOT
+            if (g_HotKnotState != HOTKNOT_BEFORE_TRANS_STATE && g_HotKnotState != HOTKNOT_TRANS_STATE && g_HotKnotState != HOTKNOT_AFTER_TRANS_STATE)
+#endif //CONFIG_ENABLE_HOTKNOT
+            {
+                if (g_GestureWakeupMode[0] != 0x00000000 || g_GestureWakeupMode[1] != 0x00000000)
+                {
+                    DrvIcFwLyrOpenGestureWakeup(&g_GestureWakeupMode[0]);
+                    return 0;
+                }
+            }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+            if (g_HotKnotState == HOTKNOT_BEFORE_TRANS_STATE || g_HotKnotState == HOTKNOT_TRANS_STATE || g_HotKnotState == HOTKNOT_AFTER_TRANS_STATE)
+            {
+                IicWriteData(SLAVE_I2C_ID_DWI2C, &_gAMStartCmd[0], 4); 
+            }
+#endif //CONFIG_ENABLE_HOTKNOT 
+
+            DrvPlatformLyrFingerTouchReleased(0, 0, 0); // Send touch end for clearing point touch
+            input_sync(g_InputDevice);
+
+            DrvPlatformLyrDisableFingerTouchReport();
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+            if (g_HotKnotState != HOTKNOT_BEFORE_TRANS_STATE && g_HotKnotState != HOTKNOT_TRANS_STATE && g_HotKnotState != HOTKNOT_AFTER_TRANS_STATE)
+#endif //CONFIG_ENABLE_HOTKNOT        
+            {
+                DrvPlatformLyrTouchDevicePowerOff(); 
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+                DrvPlatformLyrTouchDeviceRegulatorPowerOn(false);
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+            }    
+        }
+    }
+
+    return 0;
+}
+
+#else
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+void MsDrvInterfaceTouchDeviceSuspend(struct device *pDevice)
+#else
+void MsDrvInterfaceTouchDeviceSuspend(struct early_suspend *pSuspend)
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+    g_IsEnableEsdCheck = 0;
+    cancel_delayed_work_sync(&g_EsdCheckWork);
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+
+    if (g_IsUpdateFirmware != 0) // Check whether update frimware is finished
+    {
+        DBG(&g_I2cClient->dev, "Not allow to power on/off touch ic while update firmware.\n");
+        return;
+    }
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+    if (g_EnableTpProximity == 1)
+    {
+        DBG(&g_I2cClient->dev, "g_EnableTpProximity = %d\n", g_EnableTpProximity);
+        return;
+    }
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_HOTKNOT
+    if (g_HotKnotState != HOTKNOT_BEFORE_TRANS_STATE && g_HotKnotState != HOTKNOT_TRANS_STATE && g_HotKnotState != HOTKNOT_AFTER_TRANS_STATE)
+#endif //CONFIG_ENABLE_HOTKNOT
+    {
+        if (TP_gesture_Switch) //(g_GestureWakeupMode[0] != 0x00000000 || g_GestureWakeupMode[1] != 0x00000000)
+        {
+            DBG(&g_I2cClient->dev, "###*** %s()g_GestureWakeupMode[0]:0x%x,g_GestureWakeupMode[1]:0x%x ***\n", __func__,g_GestureWakeupMode[0],g_GestureWakeupMode[1]);
+            DrvIcFwLyrOpenGestureWakeup(&g_GestureWakeupMode[0]);
+			irq_set_irq_type(gpio_isr, IRQF_TRIGGER_HIGH);		
+            return;
+        }
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+    if (g_HotKnotState == HOTKNOT_BEFORE_TRANS_STATE || g_HotKnotState == HOTKNOT_TRANS_STATE || g_HotKnotState == HOTKNOT_AFTER_TRANS_STATE)
+    {
+        IicWriteData(SLAVE_I2C_ID_DWI2C, &_gAMStartCmd[0], 4); 
+    }
+#endif //CONFIG_ENABLE_HOTKNOT  
+
+    DrvPlatformLyrFingerTouchReleased(0, 0, 0); // Send touch end for clearing point touch
+    input_sync(g_InputDevice);
+
+    DrvPlatformLyrDisableFingerTouchReport();
+
+#ifdef CONFIG_ENABLE_HOTKNOT
+    if (g_HotKnotState != HOTKNOT_BEFORE_TRANS_STATE && g_HotKnotState != HOTKNOT_TRANS_STATE && g_HotKnotState != HOTKNOT_AFTER_TRANS_STATE)
+#endif //CONFIG_ENABLE_HOTKNOT        
+    {
+        DrvPlatformLyrTouchDevicePowerOff(); 
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+        DrvPlatformLyrTouchDeviceRegulatorPowerOn(false);
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON               
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+    }    
+}
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+void MsDrvInterfaceTouchDeviceResume(struct device *pDevice)
+#else
+void MsDrvInterfaceTouchDeviceResume(struct early_suspend *pSuspend)
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***,g_GestureWakeupFlag:%d\n", __func__,g_GestureWakeupFlag);
+
+    if (g_IsUpdateFirmware != 0) // Check whether update frimware is finished
+    {
+        DBG(&g_I2cClient->dev, "Not allow to power on/off touch ic while update firmware.\n");
+        return;
+    }
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+    if (g_EnableTpProximity == 1)
+    {
+        DBG(&g_I2cClient->dev, "g_EnableTpProximity = %d\n", g_EnableTpProximity);
+        return;
+    }
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_HOTKNOT
+    if (g_HotKnotState != HOTKNOT_BEFORE_TRANS_STATE && g_HotKnotState != HOTKNOT_TRANS_STATE && g_HotKnotState != HOTKNOT_AFTER_TRANS_STATE)
+#endif //CONFIG_ENABLE_HOTKNOT
+    {
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+        if (g_GestureDebugMode == 1)
+        {
+            DrvIcFwLyrCloseGestureDebugMode();
+        }
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+        if (g_GestureWakeupFlag == 1)
+        {
+            DrvIcFwLyrCloseGestureWakeup();
+			irq_set_irq_type(gpio_isr, IRQF_TRIGGER_RISING);
+        }
+        else
+        {
+            DrvPlatformLyrEnableFingerTouchReport(); 
+        }
+    }
+#ifdef CONFIG_ENABLE_HOTKNOT
+    else    // Enable touch in hotknot transfer mode
+    {
+        DrvPlatformLyrEnableFingerTouchReport();     
+    }
+#endif //CONFIG_ENABLE_HOTKNOT
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+    
+#ifdef CONFIG_ENABLE_HOTKNOT
+    if (g_HotKnotState != HOTKNOT_BEFORE_TRANS_STATE && g_HotKnotState != HOTKNOT_TRANS_STATE && g_HotKnotState != HOTKNOT_AFTER_TRANS_STATE)
+#endif //CONFIG_ENABLE_HOTKNOT        
+    {
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+        DrvPlatformLyrTouchDeviceRegulatorPowerOn(true);
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON               
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+        DrvPlatformLyrTouchDevicePowerOn(); 
+    }   
+    
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION 
+    {
+        u8 szChargerStatus[20] = {0};
+ 
+        DrvCommonReadFile("/sys/class/power_supply/battery/status", szChargerStatus, 20);
+        
+        DBG(&g_I2cClient->dev, "*** Battery Status : %s ***\n", szChargerStatus);
+        
+        g_ForceUpdate = 1; // Set flag to force update charger status
+
+        if (strstr(szChargerStatus, "Charging") != NULL || strstr(szChargerStatus, "Full") != NULL || strstr(szChargerStatus, "Fully charged") != NULL) // Charging
+        {
+            DrvFwCtrlChargerDetection(1); // charger plug-in
+        }
+        else // Not charging
+        {
+            DrvFwCtrlChargerDetection(0); // charger plug-out
+        }
+
+        g_ForceUpdate = 0; // Clear flag after force update charger status
+    }           
+#endif //CONFIG_ENABLE_CHARGER_DETECTION
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+    if (g_IsEnableGloveMode == 1)
+    {
+        DrvIcFwLyrOpenGloveMode();
+    }
+#endif //CONFIG_ENABLE_GLOVE_MODE
+
+    if (IS_FIRMWARE_DATA_LOG_ENABLED)    
+    {
+        DrvIcFwLyrRestoreFirmwareModeToLogDataMode(); // Mark this function call for avoiding device driver may spend longer time to resume from suspend state.
+    } //IS_FIRMWARE_DATA_LOG_ENABLED
+
+#ifndef CONFIG_ENABLE_GESTURE_WAKEUP
+    DrvPlatformLyrEnableFingerTouchReport(); 
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+    g_IsEnableEsdCheck = 1;
+    queue_delayed_work(g_EsdCheckWorkqueue, &g_EsdCheckWork, ESD_PROTECT_CHECK_PERIOD);
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+}
+
+#endif //CONFIG_ENABLE_NOTIFIER_FB
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+static ssize_t fts_gestrue_write(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
+{
+	char temp[8] = {0};
+	int gesture_value = 0;
+	if(copy_from_user(temp, buffer, sizeof(temp)))
+	{
+		printk("ft_gesture_write: call copy_from_user() fail!!\r\n");
+		return -EFAULT;
+	}
+	TP_gesture_value = simple_strtoul(temp, NULL, 10);
+	TP_gesture_Switch = ((TP_gesture_value & 0x1) ? true:false);	
+	
+	DBG(&g_I2cClient->dev, "atoi TP_gesture_value = %d,TP_gesture_Switch=%d,buffer:%s\n", TP_gesture_value,TP_gesture_Switch, buffer);
+	if(!TP_gesture_Switch)
+		return count;
+
+	/*
+	bit7  O
+	bit6  V
+	bit5  double click
+	bit4  right
+	bit3  left
+	bit2  down
+	bit1  up
+	bit0  total switch
+	*/
+
+	if ((TP_gesture_value & 0x80) == 0x80)
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG;
+	}
+	else
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG);
+	}
+	
+
+	if ((TP_gesture_value & 0x40) == 0x40)
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG;
+	}
+	else
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG);
+	}
+	
+	if ((TP_gesture_value & 0x20) == 0x20)
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG;
+	}
+	else
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG);
+	}
+
+	if ((TP_gesture_value & 0x10) == 0x10)
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG;
+	}
+	else
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG);
+	}
+
+	if ((TP_gesture_value & 0x8) == 0x8)
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG;
+	}
+	else
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG);
+	}
+
+	if ((TP_gesture_value & 0x4) == 0x4)
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG;
+	}
+	else
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG);
+	}
+
+	if ((TP_gesture_value & 0x2) == 0x2)
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG;
+	}
+	else
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG);
+	}
+#if 0		//TP_gesture_Switch
+	if ((TP_gesture_value & 0x1) == 0x1)
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] | GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG;
+	}
+	else
+	{
+		g_GestureWakeupMode[0] = g_GestureWakeupMode[0] & (~GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG);
+	}
+#endif
+	DBG(&g_I2cClient->dev, "gtp_read_gusture_file g_GestureWakeupMode = 0x%x \n", g_GestureWakeupMode[0]);
+
+	return count;
+}
+
+static ssize_t fts_gestrue_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
+{
+	unsigned int gesture_value;
+	char buff[8] = {0};
+
+	sprintf(buff, "%d\n", TP_gesture_value);
+	if(copy_to_user(buffer, (void *)&buff, count))
+	{
+		printk("%s copy_to_user fial!!\r\n", __func__);
+		return -EFAULT;
+	}
+	printk("TP_gesture_value = %d\n", TP_gesture_value);
+	return count;
+}
+
+static int fts_gestrue_open(struct inode *inode, struct file *f)
+{
+	return 0;
+}
+
+static int fts_gestrue_release(struct inode *inode, struct file *f)
+{
+	return 0;
+}
+
+static const struct file_operations fts_gestrue_fops =
+{
+	.owner = THIS_MODULE,
+	.open = fts_gestrue_open,
+	.write = fts_gestrue_write,
+	.read = fts_gestrue_read,
+	.release = fts_gestrue_release
+};
+
+static struct miscdevice fts_gestrue_struct = {
+	.name = "tp_gesture_switch",
+	.fops = &fts_gestrue_fops,
+	.minor = MISC_DYNAMIC_MINOR,
+};
+#endif
+
+
+/* probe function is used for matching and initializing input device */
+s32 /*__devinit*/ MsDrvInterfaceTouchDeviceProbe(struct i2c_client *pClient, const struct i2c_device_id *pDeviceId)
+{
+    s32 nRetVal = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+  
+    DrvPlatformLyrVariableInitialize(); 
+
+    DrvPlatformLyrTouchDeviceRequestGPIO(pClient);
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+    DrvPlatformLyrTouchDeviceRegulatorPowerOn(true);
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+    DrvPlatformLyrTouchDevicePowerOn();
+
+    nRetVal = DrvMainTouchDeviceInitialize();
+    if (nRetVal == -ENODEV)
+    {
+        DrvPlatformLyrTouchDeviceRemove(pClient);
+        return nRetVal;
+    }
+
+    DrvPlatformLyrInputDeviceInitialize(pClient); 
+    
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaAlloc(); // DmaAlloc() shall be called after DrvPlatformLyrInputDeviceInitialize()
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    DrvPlatformLyrTouchDeviceRegisterFingerTouchInterruptHandler();
+
+    DrvPlatformLyrTouchDeviceRegisterEarlySuspend();
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+    DrvIcFwLyrCheckFirmwareUpdateBySwId();
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+    INIT_DELAYED_WORK(&g_EsdCheckWork, DrvPlatformLyrEsdCheck);
+    g_EsdCheckWorkqueue = create_workqueue("esd_check");
+    queue_delayed_work(g_EsdCheckWorkqueue, &g_EsdCheckWork, ESD_PROTECT_CHECK_PERIOD);
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+
+#ifdef TP_READ_VER
+	DBG(&g_I2cClient->dev, "create TP_VER_PROC_FILE \n");
+		//Get firmware version
+		tp_ver_proc = proc_create(TP_VER_PROC_FILE, 0664, NULL, &gt_tp_ver_proc_fops);
+		if (tp_ver_proc == NULL)
+		{
+			DBG(&g_I2cClient->dev, "create_proc_entry %s failed\n", TP_VER_PROC_FILE);
+		}
+	
+#endif
+    //mstart_read_gusture_file();
+	
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+		if (misc_register(&fts_gestrue_struct) < 0)
+		{
+			printk("%s: Creat fts_gestrue_struct device file error!!\n", __func__);
+		}
+
+#endif
+
+
+    DBG(&g_I2cClient->dev, "*** MStar touch driver registered ***\n");
+    
+    return nRetVal;
+}
+
+/* remove function is triggered when the input device is removed from input sub-system */
+s32 /*__devexit*/ MsDrvInterfaceTouchDeviceRemove(struct i2c_client *pClient)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return DrvPlatformLyrTouchDeviceRemove(pClient);
+}
+
+void MsDrvInterfaceTouchDeviceSetIicDataRate(struct i2c_client *pClient, u32 nIicDataRate)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvPlatformLyrSetIicDataRate(pClient, nIicDataRate);
+}    
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_jni_interface.h
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_jni_interface.h	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_jni_interface.h	(revision 166572)
@@ -0,0 +1,93 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_jni_interface.h
+ *
+ * @brief   This file defines the jni interface functions
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_JNI_INTERFACE_H__
+#define __MSTAR_DRV_JNI_INTERFACE_H__
+
+
+////////////////////////////////////////////////////////////
+/// Included Files
+////////////////////////////////////////////////////////////
+#include "mstar_drv_common.h"
+
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+////////////////////////////////////////////////////////////
+/// Data Types
+////////////////////////////////////////////////////////////
+/*
+typedef struct
+{
+    u64          nCmdId;
+    u8         *pSndCmdData;      //send data to fw  
+    u64         nSndCmdLen;
+    u8         *pRtnCmdData;      //receive data from fw
+    u64         nRtnCmdLen;
+} MsgToolDrvCmd_t;
+*/
+
+typedef struct
+{
+    u64         nCmdId;
+    u64         nSndCmdDataPtr;      //send data to fw  
+    u64         nSndCmdLen;
+    u64         nRtnCmdDataPtr;      //receive data from fw
+    u64         nRtnCmdLen;
+} MsgToolDrvCmd_t;
+
+
+
+////////////////////////////////////////////////////////////
+/// Macro
+////////////////////////////////////////////////////////////
+#define MSGTOOL_MAGIC_NUMBER               96
+#define MSGTOOL_IOCTL_RUN_CMD              _IO(MSGTOOL_MAGIC_NUMBER, 1)
+
+
+#define MSGTOOL_RESETHW           0x01 
+#define MSGTOOL_REGGETXBYTEVALUE  0x02 
+#define MSGTOOL_HOTKNOTSTATUS     0x03 
+#define MSGTOOL_FINGERTOUCH       0x04
+#define MSGTOOL_BYPASSHOTKNOT     0x05
+#define MSGTOOL_DEVICEPOWEROFF    0x06
+#define MSGTOOL_GETSMDBBUS        0x07
+#define MSGTOOL_SETIICDATARATE    0x08
+
+
+
+////////////////////////////////////////////////////////////
+/// Function Prototypes
+////////////////////////////////////////////////////////////
+
+extern ssize_t MsgToolRead(struct file *pFile, char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t MsgToolWrite(struct file *pFile, const char __user *pBuffer, size_t nCount, loff_t *pPos);  
+extern long MsgToolIoctl( struct file *pFile, unsigned int nCmd, unsigned long nArg );
+extern void CreateMsgToolMem(void);
+extern void DeleteMsgToolMem(void);
+
+
+#endif //CONFIG_ENABLE_JNI_INTERFACE
+#endif // __MSTAR_DRV_JNI_INTERFACE_H__
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_sprd.c
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_sprd.c	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_sprd.c	(revision 166572)
@@ -0,0 +1,258 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_sprd.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif //CONFIG_HAS_EARLYSUSPEND
+#include <linux/i2c.h>
+#include <linux/kobject.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include "mstar_drv_platform_interface.h"
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+//#include <mach/regulator.h>
+#include <soc/sprd/regulator.h>
+#include <linux/regulator/consumer.h>
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+/*=============================================================*/
+// CONSTANT VALUE DEFINITION
+/*=============================================================*/
+
+#define MSG_TP_IC_NAME "msg2xxx" //"msg21xxA" or "msg22xx" or "msg26xxM" or "msg28xx" /* Please define the mstar touch ic name based on the mutual-capacitive ic or self capacitive ic that you are using */
+
+/*=============================================================*/
+// VARIABLE DEFINITION
+/*=============================================================*/
+
+struct i2c_client *g_I2cClient = NULL;
+int MS_TS_MSG_IC_GPIO_RST = 0;
+int MS_TS_MSG_IC_GPIO_INT = 0;
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+struct regulator *g_ReguVdd = NULL;
+struct regulator *g_ReguVcc_i2c = NULL;
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+#ifdef CONFIG_OF
+static struct msg2138_ts_platform_data *pixcir_ts_parse_dt(struct device *dev)
+{
+	struct msg2138_ts_platform_data *pdata = NULL;
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (!pdata) {
+		dev_err(dev, "Could not allocate struct msg5846_ts_platform_data");
+		return NULL;
+	}
+	pdata->reset_gpio_number = of_get_gpio(np, 0);
+	if(pdata->reset_gpio_number < 0){
+		dev_err(dev, "fail to get reset_gpio_number\n");
+		goto fail;
+	}
+	pdata->irq_gpio_number = of_get_gpio(np, 1);
+	if(pdata->irq_gpio_number < 0){
+		dev_err(dev, "fail to get irq_gpio_number\n");
+		goto fail;
+	}
+	ret = of_property_read_string(np, "vdd_name", &pdata->vdd_name);
+	if(ret){
+		dev_err(dev, "fail to get vdd_name\n");
+		goto fail;
+	}
+	ret = of_property_read_u32_array(np, "virtualkeys", &pdata->virtualkeys,12);
+	if(ret){
+		dev_err(dev, "fail to get virtualkeys\n");
+		goto fail;
+	}
+	ret = of_property_read_u32(np, "TP_MAX_X", &pdata->TP_MAX_X);
+	if(ret){
+		dev_err(dev, "fail to get TP_MAX_X\n");
+		goto fail;
+	}
+	ret = of_property_read_u32(np, "TP_MAX_Y", &pdata->TP_MAX_Y);
+	if(ret){
+		dev_err(dev, "fail to get TP_MAX_Y\n");
+		goto fail;
+	}
+
+	return pdata;
+fail:
+	kfree(pdata);
+	return NULL;
+}
+#endif
+/*=============================================================*/
+// FUNCTION DEFINITION
+/*=============================================================*/
+
+/* probe function is used for matching and initializing input device */
+static int /*__devinit*/ touch_driver_probe(struct i2c_client *client,
+        const struct i2c_device_id *id)
+{
+ struct msg2138_ts_platform_data *pdata;
+  int err =0;
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+   int ret = 0;
+//    const char *vdd_name = "vdd";
+//    const char *vcc_i2c_name = "vcc_i2c";
+//struct regulator *reg_vdd,*reg_vdd1v8,*reg_vdd2v8;
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+    printk("*** %s ***\n", __FUNCTION__);
+    
+    if (client == NULL)
+    {
+        printk("i2c client is NULL\n");
+        return -1;
+    }
+#if 1
+    pdata = client->dev.platform_data;
+
+#ifdef CONFIG_OF
+    struct device_node *np = client->dev.of_node;
+    if (np && !pdata){
+        pdata = pixcir_ts_parse_dt(&client->dev);
+        if(pdata){
+		client->dev.platform_data = pdata;
+        } else {
+		err = -ENOMEM;
+		goto exit_alloc_platform_data_failed;
+        }
+    }
+#endif
+    g_I2cClient = client;
+    MS_TS_MSG_IC_GPIO_RST = 141;//pdata->reset_gpio_number;
+    MS_TS_MSG_IC_GPIO_INT = 144;//pdata->irq_gpio_number;
+#endif
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+    g_ReguVdd = regulator_get(&g_I2cClient->dev, "vdd28");
+
+    ret = regulator_set_voltage(g_ReguVdd, 2800000, 2800000); 
+    if (ret)
+    {
+        printk("Could not set to 2800mv.\n");
+    }
+
+    g_ReguVcc_i2c = regulator_get(&g_I2cClient->dev, "vdd18");
+
+    ret = regulator_set_voltage(g_ReguVcc_i2c, 1800000, 1800000);  
+    if (ret)
+    {
+        printk("Could not set to 1800mv.\n");
+    }
+
+		
+
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+    return MsDrvInterfaceTouchDeviceProbe(g_I2cClient, id);
+exit_alloc_platform_data_failed:
+    return err;
+}
+
+/* remove function is triggered when the input device is removed from input sub-system */
+static int /*__devexit*/ touch_driver_remove(struct i2c_client *client)
+{
+    printk("*** %s ***\n", __FUNCTION__);
+
+    return MsDrvInterfaceTouchDeviceRemove(client);
+}
+
+/* The I2C device list is used for matching I2C device and I2C device driver. */
+static const struct i2c_device_id touch_device_id[] =
+{
+    {MSG_TP_IC_NAME, 0},
+    {}, /* should not omitted */ 
+};
+
+MODULE_DEVICE_TABLE(i2c, touch_device_id);
+
+static const struct of_device_id touch_dt_match_table[] = {
+    { .compatible = "mstar,msg2xxx",},
+    {},
+};
+
+MODULE_DEVICE_TABLE(of, touch_dt_match_table);
+
+static struct i2c_driver touch_device_driver =
+{
+    .driver = {
+        .name = MSG_TP_IC_NAME,
+        .owner = THIS_MODULE,
+        .of_match_table = touch_dt_match_table,
+    },
+    .probe = touch_driver_probe,
+    .remove = touch_driver_remove,
+    .id_table = touch_device_id,
+};
+
+static int /*__init*/ touch_driver_init(void)
+{
+    int ret;
+
+    /* register driver */
+    ret = i2c_add_driver(&touch_device_driver);
+    if (ret < 0)
+    {
+        printk("add MStar touch device driver i2c driver failed.\n");
+        return -ENODEV;
+    }
+    printk("add MStar touch device driver i2c driver.\n");
+
+    return ret;
+}
+
+static void /*__exit*/ touch_driver_exit(void)
+{
+    printk("remove MStar touch device driver i2c driver.\n");
+
+    i2c_del_driver(&touch_device_driver);
+}
+
+module_init(touch_driver_init);
+module_exit(touch_driver_exit);
+MODULE_LICENSE("GPL");
\ No newline at end of file
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_platform_interface.h
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_platform_interface.h	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_platform_interface.h	(revision 166572)
@@ -0,0 +1,55 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_platform_interface.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_PLATFORM_INTERFACE_H__
+#define __MSTAR_DRV_PLATFORM_INTERFACE_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+extern s32 /*__devinit*/ MsDrvInterfaceTouchDeviceProbe(struct i2c_client *pClient, const struct i2c_device_id *pDeviceId);
+extern s32 /*__devexit*/ MsDrvInterfaceTouchDeviceRemove(struct i2c_client *pClient);
+#ifdef CONFIG_ENABLE_NOTIFIER_FB
+extern int MsDrvInterfaceTouchDeviceFbNotifierCallback(struct notifier_block *pSelf, unsigned long nEvent, void *pData);
+#else
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+extern void MsDrvInterfaceTouchDeviceResume(struct device *pDevice);
+extern void MsDrvInterfaceTouchDeviceSuspend(struct device *pDevice);
+#else
+extern void MsDrvInterfaceTouchDeviceResume(struct early_suspend *pSuspend);        
+extern void MsDrvInterfaceTouchDeviceSuspend(struct early_suspend *pSuspend);
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#endif //CONFIG_ENABLE_NOTIFIER_FB
+extern void MsDrvInterfaceTouchDeviceSetIicDataRate(struct i2c_client *pClient, u32 nIicDataRate);
+        
+#endif  /* __MSTAR_DRV_PLATFORM_INTERFACE_H__ */
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_extern.h
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_extern.h	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_extern.h	(revision 166572)
@@ -0,0 +1,46 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_extern.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_EXTERN_H__
+#define __MSTAR_DRV_EXTERN_H__
+
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+//#include "mstar_drv_common.h"
+
+/*=============================================================*/
+// EXTERN FUNCTION DECLARATION
+/*=============================================================*/
+
+//#ifdef CONFIG_ENABLE_CHARGER_DETECTION
+extern void DrvFwCtrlChargerDetection(u8 nChargerStatus);
+//#endif //CONFIG_ENABLE_CHARGER_DETECTION
+
+
+#endif  /* __MSTAR_DRV_EXTERN_H__ */
Index: kernel/drivers/input/touchscreen/msg5846/Makefile
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/Makefile	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/Makefile	(revision 166572)
@@ -0,0 +1,8 @@
+#
+# Makefile for the input core drivers.
+#
+
+# Each configuration option enables a list of files.
+obj-$(CONFIG_TOUCHSCREEN_MSG5846)  += msg5846_ts.o
+
+msg5846_ts-objs += mstar_drv_sprd.o mstar_drv_common.o  mstar_drv_ic_fw_porting_layer.o  mstar_drv_main.o mstar_drv_platform_interface.o mstar_drv_platform_porting_layer.o mstar_drv_fw_control.o mstar_drv_utility_adaption.o mstar_drv_jni_interface.o  mstar_drv_mp_test.o
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_mp_test.c
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_mp_test.c	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_mp_test.c	(revision 166572)
@@ -0,0 +1,6561 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_mp_test.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_mp_test.h"
+#include "mstar_drv_utility_adaption.h"
+#include "mstar_drv_fw_control.h"
+#include "mstar_drv_platform_porting_layer.h"
+#include "mstar_drv_ic_fw_porting_layer.h"
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+/* The below .h file are included for MSG21xxA */
+// Modify.
+#include "msg21xxa_open_test_ANA1_X.h"
+#include "msg21xxa_open_test_ANA2_X.h"
+#include "msg21xxa_open_test_ANA1_B_X.h"
+#include "msg21xxa_open_test_ANA2_B_X.h"
+#include "msg21xxa_open_test_ANA3_X.h"
+
+#include "msg21xxa_open_test_ANA1_Y.h"
+#include "msg21xxa_open_test_ANA2_Y.h"
+#include "msg21xxa_open_test_ANA1_B_Y.h"
+#include "msg21xxa_open_test_ANA2_B_Y.h"
+#include "msg21xxa_open_test_ANA3_Y.h"
+
+// Modify.
+#include "msg21xxa_short_test_ANA1_X.h"
+#include "msg21xxa_short_test_ANA2_X.h"
+#include "msg21xxa_short_test_ANA3_X.h"
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE  
+#include "msg21xxa_short_test_ANA4_X.h"
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+
+#include "msg21xxa_short_test_ANA1_Y.h"
+#include "msg21xxa_short_test_ANA2_Y.h"
+#include "msg21xxa_short_test_ANA3_Y.h"
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE  
+#include "msg21xxa_short_test_ANA4_Y.h"
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+/* The below .h file are included for MSG22xx */
+// Modify.
+#include "msg22xx_open_test_RIU1_X.h"
+#include "msg22xx_open_test_RIU2_X.h"
+#include "msg22xx_open_test_RIU3_X.h"
+
+#include "msg22xx_open_test_RIU1_Y.h"
+#include "msg22xx_open_test_RIU2_Y.h"
+#include "msg22xx_open_test_RIU3_Y.h"
+
+// Modify.
+#include "msg22xx_short_test_RIU1_X.h"
+#include "msg22xx_short_test_RIU2_X.h"
+#include "msg22xx_short_test_RIU3_X.h"
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE  
+#include "msg22xx_short_test_RIU4_X.h"
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+
+#include "msg22xx_short_test_RIU1_Y.h"
+#include "msg22xx_short_test_RIU2_Y.h"
+#include "msg22xx_short_test_RIU3_Y.h"
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE  
+#include "msg22xx_short_test_RIU4_Y.h"
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+/* The below .h file are included for MSG26xxM */
+#include "msg26xxm_open_test_X.h"
+#include "msg26xxm_short_test_X.h"
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+/* The below .h file are included for MSG28xx */
+#include "msg28xx_mp_test_X.h"
+#include "msg28xx_mp_test_Y.h"
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+/*=============================================================*/
+// PREPROCESSOR CONSTANT DEFINITION
+/*=============================================================*/
+
+// Modify.
+#define TP_TYPE_X    (1) //(2)
+#define TP_TYPE_Y    (4)
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+extern u32 SLAVE_I2C_ID_DBBUS;
+extern u32 SLAVE_I2C_ID_DWI2C;
+
+extern u8 g_ChipType;
+
+extern struct i2c_client *g_I2cClient;
+extern struct mutex g_Mutex;
+
+/*=============================================================*/
+// GLOBAL VARIABLE DEFINITION
+/*=============================================================*/
+
+u32 g_IsInMpTest = 0;
+
+/*=============================================================*/
+// LOCAL VARIABLE DEFINITION
+/*=============================================================*/
+
+static u32 _gTestRetryCount = CTP_MP_TEST_RETRY_COUNT;
+static ItoTestMode_e _gItoTestMode = 0;
+
+static s32 _gCtpMpTestStatus = ITO_TEST_UNDER_TESTING;
+
+static u32 _gTestFailChannelCount = 0;
+
+static struct work_struct _gCtpItoTestWork;
+static struct workqueue_struct *_gCtpMpTestWorkQueue = NULL;
+
+ItoTestResult_e _gItoTestResult = ITO_TEST_OK;
+
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG22XX)
+/* The below variable are defined for MSG21xxA/MSG22xx */
+static u8 _gSelfICTestFailChannel[SELF_IC_MAX_CHANNEL_NUM] = {0};
+
+static s16 _gSelfICRawData1[SELF_IC_MAX_CHANNEL_NUM] = {0};
+static s16 _gSelfICRawData2[SELF_IC_MAX_CHANNEL_NUM] = {0};
+static s16 _gSelfICRawData3[SELF_IC_MAX_CHANNEL_NUM] = {0};
+static s16 _gSelfICRawData4[SELF_IC_MAX_CHANNEL_NUM] = {0};
+static s8 _gSelfICDataFlag1[SELF_IC_MAX_CHANNEL_NUM] = {0};
+static s8 _gSelfICDataFlag2[SELF_IC_MAX_CHANNEL_NUM] = {0};
+static s8 _gSelfICDataFlag3[SELF_IC_MAX_CHANNEL_NUM] = {0};
+static s8 _gSelfICDataFlag4[SELF_IC_MAX_CHANNEL_NUM] = {0};
+
+static u8 _gSelfICItoTestKeyNum = 0;
+static u8 _gSelfICItoTestDummyNum = 0;
+static u8 _gSelfICItoTestTriangleNum = 0;
+static u8 _gSelfICIsEnable2R = 0;
+
+static u8 *_gSelfIC_MAP1 = NULL;
+static u8 *_gSelfIC_MAP2 = NULL;
+static u8 *_gSelfIC_MAP3 = NULL;
+static u8 *_gSelfIC_MAP40_1 = NULL;
+static u8 *_gSelfIC_MAP40_2 = NULL;
+static u8 *_gSelfIC_MAP41_1 = NULL;
+static u8 *_gSelfIC_MAP41_2 = NULL;
+
+static u8 *_gSelfIC_SHORT_MAP1 = NULL;
+static u8 *_gSelfIC_SHORT_MAP2 = NULL;
+static u8 *_gSelfIC_SHORT_MAP3 = NULL;
+
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+static u8 *_gSelfIC_MAP40_3 = NULL;
+static u8 *_gSelfIC_MAP40_4 = NULL;
+static u8 *_gSelfIC_MAP41_3 = NULL;
+static u8 *_gSelfIC_MAP41_4 = NULL;
+
+static u8 *_gSelfIC_SHORT_MAP4 = NULL;
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA || CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+static u8 _gMsg21xxaLTP = 1;	
+
+// _gMsg21xxaOpen1~_gMsg21xxaOpen3 are for MSG21XXA
+static u16 *_gMsg21xxaOpen1 = NULL;
+static u16 *_gMsg21xxaOpen1B = NULL;
+static u16 *_gMsg21xxaOpen2 = NULL;
+static u16 *_gMsg21xxaOpen2B = NULL;
+static u16 *_gMsg21xxaOpen3 = NULL;
+
+// _gMsg21xxaShort_1~_gMsg21xxaShort_4 are for MSG21XXA
+static u16 *_gMsg21xxaShort_1 = NULL;
+static u16 *_gMsg21xxaShort_2 = NULL;
+static u16 *_gMsg21xxaShort_3 = NULL;
+
+// _gMsg21xxaShort_1_GPO~_gMsg21xxaShort_4_GPO are for MSG21XXA
+static u16 *_gMsg21xxaShort_1_GPO = NULL;
+static u16 *_gMsg21xxaShort_2_GPO = NULL;
+static u16 *_gMsg21xxaShort_3_GPO = NULL;
+
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+static u16 *_gMsg21xxaShort_4 = NULL;
+static u16 *_gMsg21xxaShort_4_GPO = NULL;
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+static u8 _gIsOldFirmwareVersion = 0;
+
+// _gMsg22xxOpenRIU1~_gMsg22xxOpenRIU3 are for MSG22XX
+static u32 *_gMsg22xxOpenRIU1 = NULL;
+static u32 *_gMsg22xxOpenRIU2 = NULL;
+static u32 *_gMsg22xxOpenRIU3 = NULL;
+
+// _gMsg22xxShort_RIU1~_gMsg22xxShort_RIU4 are for MSG22XX
+static u32 *_gMsg22xxShort_RIU1 = NULL;
+static u32 *_gMsg22xxShort_RIU2 = NULL;
+static u32 *_gMsg22xxShort_RIU3 = NULL;
+
+// _gMsg22xxOpenSubFrameNum1~_gMsg22xxShortSubFrameNum4 are for MSG22XX
+static u8 _gMsg22xxOpenSubFrameNum1 = 0;
+static u8 _gMsg22xxOpenSubFrameNum2 = 0;
+static u8 _gMsg22xxOpenSubFrameNum3 = 0;
+static u8 _gMsg22xxShortSubFrameNum1 = 0;
+static u8 _gMsg22xxShortSubFrameNum2 = 0;
+static u8 _gMsg22xxShortSubFrameNum3 = 0;
+
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+static u32 *_gMsg22xxShort_RIU4 = NULL;
+static u8 _gMsg22xxShortSubFrameNum4 = 0;
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG26XXM) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG28XX)
+/* The below variable are defined for MSG26xxM/MSG28xx */
+TestScopeInfo_t g_TestScopeInfo = {0}; // Used for MSG26xxM/MSG28xx
+
+static u16 _gMutualICSenseLineNum = 0;
+static u16 _gMutualICDriveLineNum = 0;
+static u16 _gMutualICWaterProofNum = 0;
+
+static u8 _gMutualICTestFailChannel[MUTUAL_IC_MAX_MUTUAL_NUM] = {0};
+
+static s32 _gMutualICDeltaC[MUTUAL_IC_MAX_MUTUAL_NUM] = {0};
+static s32 _gMutualICResult[MUTUAL_IC_MAX_MUTUAL_NUM] = {0};
+static s32 _gMutualICResultWater[12] = {0};
+//static u8 _gMutualICMode[MUTUAL_IC_MAX_MUTUAL_NUM] = {0};
+static s32 _gMutualICSenseR[MUTUAL_IC_MAX_CHANNEL_NUM] = {0};
+static s32 _gMutualICDriveR[MUTUAL_IC_MAX_CHANNEL_NUM] = {0};
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM || CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+static u8 _gMutualICTestAutoSwitchFlag = 1;
+static u8 _gMutualICTestSwitchMode = 0;
+
+static s32 _gMutualICTempDeltaC[MUTUAL_IC_MAX_MUTUAL_NUM] = {0};
+
+static u8 _gMsg26xxmShortTestChannel[MUTUAL_IC_MAX_CHANNEL_NUM] = {0};
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+u16 _gMsg28xxMuxMem_20_3E_0_Settings[16] = {0};
+u16 _gMsg28xxMuxMem_20_3E_1_Settings[16] = {0};
+u16 _gMsg28xxMuxMem_20_3E_2_Settings[16] = {0};
+u16 _gMsg28xxMuxMem_20_3E_3_Settings[16] = {0};
+u16 _gMsg28xxMuxMem_20_3E_4_Settings[16] = {0};
+u16 _gMsg28xxMuxMem_20_3E_5_Settings[16] = {0};
+u16 _gMsg28xxMuxMem_20_3E_6_Settings[16] = {0};
+
+static s32 _gMutualICDeltaCWater[12] = {0};
+static s32 _gMutualICGRR[MUTUAL_IC_MAX_CHANNEL_NUM] = {0};
+
+// Used for MSG28xx TP type definition
+static u16 _gMsg28xx_SENSE_NUM = 0;
+static u16 _gMsg28xx_DRIVE_NUM = 0;
+static u16 _gMsg28xx_KEY_NUM = 0;
+static u16 _gMsg28xx_KEY_LINE = 0;
+static u16 _gMsg28xx_GR_NUM = 0;
+static u16 _gMsg28xx_CSUB_REF = 0;
+static u16 _gMsg28xx_SENSE_MUTUAL_SCAN_NUM = 0;
+static u16 _gMsg28xx_MUTUAL_KEY = 0;
+static u16 _gMsg28xx_PATTERN_TYPE = 0;
+
+static u16 _gMsg28xx_SHORT_N1_TEST_NUMBER = 0;
+static u16 _gMsg28xx_SHORT_N2_TEST_NUMBER = 0;
+static u16 _gMsg28xx_SHORT_S1_TEST_NUMBER = 0;
+static u16 _gMsg28xx_SHORT_S2_TEST_NUMBER = 0;
+static u16 _gMsg28xx_SHORT_TEST_5_TYPE = 0;
+static u16 _gMsg28xx_SHORT_X_TEST_NUMBER = 0;
+                                                                                                                                    
+static u16 * _gMsg28xx_SHORT_N1_TEST_PIN = NULL;
+static u16 * _gMsg28xx_SHORT_N1_MUX_MEM_20_3E = NULL;
+static u16 * _gMsg28xx_SHORT_N2_TEST_PIN = NULL;
+static u16 * _gMsg28xx_SHORT_N2_MUX_MEM_20_3E = NULL;
+static u16 * _gMsg28xx_SHORT_S1_TEST_PIN = NULL;
+static u16 * _gMsg28xx_SHORT_S1_MUX_MEM_20_3E = NULL;
+static u16 * _gMsg28xx_SHORT_S2_TEST_PIN = NULL;
+static u16 * _gMsg28xx_SHORT_S2_MUX_MEM_20_3E = NULL;
+static u16 * _gMsg28xx_SHORT_X_TEST_PIN = NULL;
+static u16 * _gMsg28xx_SHORT_X_MUX_MEM_20_3E = NULL;                                                           
+                               
+static u16 * _gMsg28xx_PAD_TABLE_DRIVE = NULL;
+static u16 * _gMsg28xx_PAD_TABLE_SENSE = NULL;
+static u16 * _gMsg28xx_PAD_TABLE_GR = NULL;
+                               
+static u8 * _gMsg28xx_KEYSEN = NULL;
+static u8 * _gMsg28xx_KEYDRV = NULL;
+                                                            
+//static u8 ** g_Msg28xxMapVaMutual;
+static u16 _gMsg28xxTpType = 0;
+static s8 _gMsg28xxDeepStandBy = 0;
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+ 
+/*=============================================================*/
+// EXTERN FUNCTION DECLARATION
+/*=============================================================*/
+
+
+/*=============================================================*/
+// LOCAL FUNCTION DECLARATION
+/*=============================================================*/
+
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG22XX)
+static u16 _DrvMpTestItoTestSelfICGetTpType(void);
+static u16 _DrvMpTestItoTestSelfICChooseTpType(void);
+static void _DrvMpTestItoTestSelfICAnaSwReset(void);
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA || CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG26XXM) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG28XX)
+static u8 _DrvMpTestMutualICCheckValueInRange(s32 nValue, s32 nMax, s32 nMin);
+static void _DrvMpTestMutualICDebugShowArray(void *pBuf, u16 nLen, int nDataType, int nCarry, int nChangeLine);
+//static void _DrvMpTestMutualICDebugShowS32Array(s32 *pBuf, u16 nRow, u16 nCol);
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM || CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+/*=============================================================*/
+// LOCAL FUNCTION DEFINITION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+static u16 _DrvMpTestItoTestMsg21xxaGetNum(void)
+{
+    u32 i;
+    u16 nSensorNum = 0;
+    u16 nRegVal1, nRegVal2;
+ 
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nRegVal1 = RegGet16BitValue(0x114A); //bank:ana, addr:h0025  
+    DBG(&g_I2cClient->dev, "nRegValue1 = %d\n", nRegVal1);
+    
+    if ((nRegVal1 & BIT1) == BIT1)
+    {
+        nRegVal1 = RegGet16BitValue(0x120A); //bank:ana2, addr:h0005  			
+        nRegVal1 = nRegVal1 & 0x0F;
+    	
+        nRegVal2 = RegGet16BitValue(0x1216); //bank:ana2, addr:h000b    		
+        nRegVal2 = ((nRegVal2 >> 1) & 0x0F) + 1;
+    	
+        nSensorNum = nRegVal1 * nRegVal2;
+    }
+    else
+    {
+        for (i = 0; i < 4; i ++)
+        {
+            nSensorNum += (RegGet16BitValue(0x120A)>>(4*i))&0x0F; //bank:ana2, addr:h0005  
+        }
+    }
+    DBG(&g_I2cClient->dev, "nSensorNum = %d\n", nSensorNum);
+
+    return nSensorNum;        
+}
+
+static void _DrvMpTestItoTestMsg21xxaDisableFilterNoiseDetect(void)
+{
+    u16 nRegValue;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+     
+    // Disable DIG/ANA drop
+    nRegValue = RegGet16BitValue(0x1302); 
+      
+    RegSet16BitValue(0x1302, nRegValue & (~(BIT2 | BIT1 | BIT0)));      
+}
+
+static void _DrvMpTestItoTestMsg21xxaPolling(void)
+{
+    u16 nRegInt = 0x0000;
+    u16 nRegVal;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    RegSet16BitValue(0x130C, BIT15); //bank:fir, addr:h0006         
+    RegSet16BitValue(0x1214, (RegGet16BitValue(0x1214) | BIT0)); //bank:ana2, addr:h000a        
+            
+    DBG(&g_I2cClient->dev, "polling start\n");
+
+    do
+    {
+        nRegInt = RegGet16BitValue(0x3D18); //bank:intr_ctrl, addr:h000c
+    } while((nRegInt & SELF_IC_FIQ_E_FRAME_READY_MASK) == 0x0000);
+
+    DBG(&g_I2cClient->dev, "polling end\n");
+    
+    nRegVal = RegGet16BitValue(0x3D18); 
+    RegSet16BitValue(0x3D18, nRegVal & (~SELF_IC_FIQ_E_FRAME_READY_MASK));      
+}
+
+static void _DrvMpTestItoOpenTestMsg21xxaSetV(u8 nEnable, u8 nPrs)	
+{
+    u16 nRegVal;        
+    
+    DBG(&g_I2cClient->dev, "*** %s() nEnable = %d, nPrs = %d ***\n", __func__, nEnable, nPrs);
+    
+    nRegVal = RegGet16BitValue(0x1208); //bank:ana2, addr:h0004
+    nRegVal = nRegVal & 0xF1; 							
+    
+    if (nPrs == 0)
+    {
+        RegSet16BitValue(0x1208, nRegVal|0x0C); 		
+    }
+    else if (nPrs == 1)
+    {
+        RegSet16BitValue(0x1208, nRegVal|0x0E); 		     	
+    }
+    else
+    {
+        RegSet16BitValue(0x1208, nRegVal|0x02); 			
+    }    
+    
+    if (nEnable)
+    {
+        nRegVal = RegGet16BitValue(0x1106); //bank:ana, addr:h0003  
+        RegSet16BitValue(0x1106, nRegVal|0x03);   	
+    }
+    else
+    {
+        nRegVal = RegGet16BitValue(0x1106);    
+        nRegVal = nRegVal & 0xFC;					
+        RegSet16BitValue(0x1106, nRegVal);         
+    }
+}
+
+static u16 _DrvMpTestItoTestMsg21xxaGetDataOut(s16 *pRawData)
+{
+    u32 i;
+    u16 szRawData[SELF_IC_MAX_CHANNEL_NUM] = {0};
+    u16 nSensorNum;
+    u16 nRegInt;
+    u8  szDbBusTxData[8] = {0};
+    u8  szDbBusRxData[SELF_IC_MAX_CHANNEL_NUM*2] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nSensorNum = _DrvMpTestItoTestMsg21xxaGetNum();
+    
+    if ((nSensorNum*2) > (SELF_IC_MAX_CHANNEL_NUM*2))
+    {
+        DBG(&g_I2cClient->dev, "Danger. nSensorNum = %d\n", nSensorNum);
+        return nSensorNum;
+    }
+
+    nRegInt = RegGet16BitValue((0x3d<<8) | (MSG21XXA_REG_INTR_FIQ_MASK<<1)); 
+    RegSet16BitValue((0x3d<<8) | (MSG21XXA_REG_INTR_FIQ_MASK<<1), (nRegInt & (u16)(~SELF_IC_FIQ_E_FRAME_READY_MASK))); 
+    
+    _DrvMpTestItoTestMsg21xxaPolling();
+    
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x13; //bank:fir, addr:h0020 
+    szDbBusTxData[2] = 0x40;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);
+    mdelay(20);
+    IicReadData(SLAVE_I2C_ID_DBBUS, &szDbBusRxData[0], (nSensorNum * 2));
+    mdelay(100);
+    
+    for (i = 0; i < nSensorNum * 2; i ++)
+    {
+        DBG(&g_I2cClient->dev, "szDbBusRxData[%d] = %d\n", i, szDbBusRxData[i]); // add for debug
+    }
+ 
+    nRegInt = RegGet16BitValue((0x3d<<8) | (MSG21XXA_REG_INTR_FIQ_MASK<<1)); 
+    RegSet16BitValue((0x3d<<8) | (MSG21XXA_REG_INTR_FIQ_MASK<<1), (nRegInt | (u16)SELF_IC_FIQ_E_FRAME_READY_MASK)); 
+
+    for (i = 0; i < nSensorNum; i ++)
+    {
+        szRawData[i] = (szDbBusRxData[2 * i + 1] << 8 ) | (szDbBusRxData[2 * i]);
+        pRawData[i] = (s16)szRawData[i];
+    }
+    
+    return nSensorNum;
+}
+
+static void _DrvMpTestItoTestMsg21xxaSendDataIn(u8 nStep)
+{
+    u32	i;
+    u16 *pType = NULL;        
+    u8 	szDbBusTxData[512] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() nStep = %d ***\n", __func__, nStep);
+
+    if (nStep == 1) //39-1
+    {
+        pType = &_gMsg21xxaShort_1[0];      	
+    }
+    else if (nStep == 2) //39-2
+    {
+        pType = &_gMsg21xxaShort_2[0];      	
+    }
+    else if (nStep == 3) //39-3
+    {
+        pType = &_gMsg21xxaShort_3[0];        
+    }
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+    else if (nStep == 0) //39-4 (2R)
+    {
+        pType = &_gMsg21xxaShort_4[0];
+    }
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+    else if (nStep == 4)
+    {
+        pType = &_gMsg21xxaOpen1[0];        
+    }
+    else if (nStep == 5)
+    {
+        pType = &_gMsg21xxaOpen2[0];      	
+    }
+    else if (nStep == 6)
+    {
+        pType = &_gMsg21xxaOpen3[0];      	
+    }
+    else if (nStep == 9)
+    {
+        pType = &_gMsg21xxaOpen1B[0];        
+    }
+    else if (nStep == 10)
+    {
+        pType = &_gMsg21xxaOpen2B[0];      	
+    } 
+     
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x11; //bank:ana, addr:h0000
+    szDbBusTxData[2] = 0x00;    
+    for (i = 0; i <= 0x3E ; i ++)
+    {
+        szDbBusTxData[3+2*i] = pType[i] & 0xFF;
+        szDbBusTxData[4+2*i] = (pType[i] >> 8) & 0xFF;    	
+    }
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+0x3F*2);
+
+    szDbBusTxData[2] = 0x7A * 2; //bank:ana, addr:h007a
+    for (i = 0x7A; i <= 0x7D ; i ++)
+    {
+        szDbBusTxData[3+2*(i-0x7A)] = 0;
+        szDbBusTxData[4+2*(i-0x7A)] = 0;    	    	
+    }
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+8);
+    
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x12; //bank:ana2, addr:h0005
+      
+    szDbBusTxData[2] = 0x05 * 2; 
+    szDbBusTxData[3] = pType[128+0x05] & 0xFF;
+    szDbBusTxData[4] = (pType[128+0x05] >> 8) & 0xFF;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 5);
+    
+    szDbBusTxData[2] = 0x0B * 2; //bank:ana2, addr:h000b
+    szDbBusTxData[3] = pType[128+0x0B] & 0xFF;
+    szDbBusTxData[4] = (pType[128+0x0B] >> 8) & 0xFF;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 5);
+    
+    szDbBusTxData[2] = 0x12 * 2; //bank:ana2, addr:h0012
+    szDbBusTxData[3] = pType[128+0x12] & 0xFF;
+    szDbBusTxData[4] = (pType[128+0x12] >> 8) & 0xFF;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 5);
+    
+    szDbBusTxData[2] = 0x15 * 2; //bank:ana2, addr:h0015
+    szDbBusTxData[3] = pType[128+0x15] & 0xFF;
+    szDbBusTxData[4] = (pType[128+0x15] >> 8) & 0xFF;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 5);
+
+    if (_gItoTestMode == ITO_TEST_MODE_OPEN_TEST)
+    {    	
+//#if 1 //for AC mod
+        szDbBusTxData[1] = 0x13;
+        szDbBusTxData[2] = 0x12 * 2;
+        szDbBusTxData[3] = 0x30;
+        szDbBusTxData[4] = 0x30;
+        IicWriteData(SLAVE_I2C_ID_DBBUS, szDbBusTxData, 5);        
+        
+        szDbBusTxData[2] = 0x14 * 2;
+        szDbBusTxData[3] = 0X30;
+        szDbBusTxData[4] = 0X30;
+        IicWriteData(SLAVE_I2C_ID_DBBUS, szDbBusTxData, 5);     
+        
+        szDbBusTxData[1] = 0x12;
+        for (i = 0x0D; i <= 0x10; i ++) //for AC noise(++)
+        {
+            szDbBusTxData[2] = i * 2;
+            szDbBusTxData[3] = pType[128+i] & 0xFF;
+            szDbBusTxData[4] = (pType[128+i] >> 8) & 0xFF;
+            IicWriteData(SLAVE_I2C_ID_DBBUS, szDbBusTxData, 5);  
+        }
+
+        for (i = 0x16; i <= 0x18; i ++) //for AC noise
+        {
+	          szDbBusTxData[2] = i * 2;
+	          szDbBusTxData[3] = pType[128+i] & 0xFF;
+	          szDbBusTxData[4] = (pType[128+i] >> 8) & 0xFF;
+	          IicWriteData(SLAVE_I2C_ID_DBBUS, szDbBusTxData, 5);  
+        }
+//#endif
+    }
+}
+
+static void _DrvMpTestItoOpenTestMsg21xxaSetC(u8 nCSubStep)
+{
+    u32 i;
+    u8 szDbBusTxData[SELF_IC_MAX_CHANNEL_NUM+3];
+    u8 nHighLevelCSub = 0;
+    u8 nCSubNew;
+     
+    DBG(&g_I2cClient->dev, "*** %s() nCSubStep = %d ***\n", __func__, nCSubStep);
+
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x11; //bank:ana, addr:h0042       
+    szDbBusTxData[2] = 0x84;        
+    
+    for (i = 0; i < SELF_IC_MAX_CHANNEL_NUM; i ++)
+    {
+        nCSubNew = nCSubStep;        
+        nHighLevelCSub = 0;   
+        
+        if (nCSubNew > 0x1F)
+        {
+            nCSubNew = nCSubNew - 0x14;
+            nHighLevelCSub = 1;
+        }
+           
+        szDbBusTxData[3+i] = nCSubNew & 0x1F;        
+        if (nHighLevelCSub == 1)
+        {
+            szDbBusTxData[3+i] |= BIT5;
+        }
+    }
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], SELF_IC_MAX_CHANNEL_NUM+3);
+
+    szDbBusTxData[2] = 0xB4; //bank:ana, addr:h005a        
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], SELF_IC_MAX_CHANNEL_NUM+3);
+}
+
+static void _DrvMpTestItoOpenTestMsg21xxaFirst(u8 nItemId, s16 *pRawData, s8 *pDataFlag)		
+{
+    u32 i, j;
+    s16 szTmpRawData[SELF_IC_MAX_CHANNEL_NUM] = {0};
+    u16	nRegVal;
+    u8  nLoop;
+    u8  nSensorNum1 = 0, nSensorNum2 = 0, nTotalSensor = 0;
+    u8 	*pMapping = NULL;
+    
+    DBG(&g_I2cClient->dev, "*** %s() nItemId = %d ***\n", __func__, nItemId);
+	
+    // Stop cpu
+    RegSet16BitValue(0x0FE6, 0x0001); //bank:mheg5, addr:h0073
+
+    RegSet16BitValue(0x1E24, 0x0500); //bank:chip, addr:h0012
+    RegSet16BitValue(0x1E2A, 0x0000); //bank:chip, addr:h0015
+    RegSet16BitValue(0x1EE6, 0x6E00); //bank:chip, addr:h0073
+    RegSet16BitValue(0x1EE8, 0x0071); //bank:chip, addr:h0074
+	    
+    if (nItemId == 40)    			
+    {
+        pMapping = &_gSelfIC_MAP1[0];
+        if (_gSelfICIsEnable2R)
+        {
+            nTotalSensor = _gSelfICItoTestTriangleNum/2; 
+        }
+        else
+        {
+            nTotalSensor = _gSelfICItoTestTriangleNum/2 + _gSelfICItoTestKeyNum + _gSelfICItoTestDummyNum;
+        }
+    }
+    else if (nItemId == 41)    		
+    {
+        pMapping = &_gSelfIC_MAP2[0];
+        if (_gSelfICIsEnable2R)
+        {
+            nTotalSensor = _gSelfICItoTestTriangleNum/2; 
+        }
+        else
+        {
+            nTotalSensor = _gSelfICItoTestTriangleNum/2 + _gSelfICItoTestKeyNum + _gSelfICItoTestDummyNum;
+        }
+    }
+    else if (nItemId == 42)    		
+    {
+        pMapping = &_gSelfIC_MAP3[0];      
+        nTotalSensor = _gSelfICItoTestTriangleNum + _gSelfICItoTestKeyNum + _gSelfICItoTestDummyNum; 
+    }
+        	    
+    nLoop = 1;
+    if (nItemId != 42)
+    {
+        if (nTotalSensor > 11)
+        {
+            nLoop = 2;
+        }
+    }	
+    
+    DBG(&g_I2cClient->dev, "nLoop = %d\n", nLoop);
+	
+    for (i = 0; i < nLoop; i ++)
+    {
+        if (i == 0)
+        {
+            _DrvMpTestItoTestMsg21xxaSendDataIn(nItemId - 36);
+        }
+        else
+        { 
+            if (nItemId == 40)
+            { 
+                _DrvMpTestItoTestMsg21xxaSendDataIn(9);
+            }
+            else
+            { 		
+                _DrvMpTestItoTestMsg21xxaSendDataIn(10);
+            }
+        }
+	
+        _DrvMpTestItoTestMsg21xxaDisableFilterNoiseDetect();
+	
+        _DrvMpTestItoOpenTestMsg21xxaSetV(1, 0);    
+        nRegVal = RegGet16BitValue(0x110E); //bank:ana, addr:h0007   			
+        RegSet16BitValue(0x110E, nRegVal | BIT11);				 		
+	
+        if (_gMsg21xxaLTP == 1)
+        {
+            _DrvMpTestItoOpenTestMsg21xxaSetC(32);
+        }	    	
+        else
+        {	    	
+	    	    _DrvMpTestItoOpenTestMsg21xxaSetC(0);
+        }
+        
+        _DrvMpTestItoTestSelfICAnaSwReset();
+		
+        if (i == 0)	 
+        {      
+            nSensorNum1 = _DrvMpTestItoTestMsg21xxaGetDataOut(szTmpRawData);
+            DBG(&g_I2cClient->dev, "nSensorNum1 = %d\n", nSensorNum1);
+        }
+        else	
+        {      
+            nSensorNum2 = _DrvMpTestItoTestMsg21xxaGetDataOut(&szTmpRawData[nSensorNum1]);
+            DBG(&g_I2cClient->dev, "nSensorNum1 = %d, nSensorNum2 = %d\n", nSensorNum1, nSensorNum2);
+        }
+    }
+    
+    for (j = 0; j < nTotalSensor; j ++)
+    {
+        if (_gMsg21xxaLTP == 1)
+        {
+            pRawData[pMapping[j]] = szTmpRawData[j] + 4096;
+            pDataFlag[pMapping[j]] = 1;
+        }
+        else
+        {
+            pRawData[pMapping[j]] = szTmpRawData[j];	
+            pDataFlag[pMapping[j]] = 1;
+        }
+    }	
+}
+
+static void _DrvMpTestItoShortTestMsg21xxaChangeGPOSetting(u8 nItemId)
+{
+    u8 szDbBusTxData[3+MSG21XXA_GPO_SETTING_SIZE*2] = {0};
+    u16 szGPOSetting[3] = {0};
+    u32 i;
+    
+    DBG(&g_I2cClient->dev, "*** %s() nItemId = %d ***\n", __func__, nItemId);
+    
+    if (nItemId == 1) // 39-1
+    {
+        szGPOSetting[0] = _gMsg21xxaShort_1_GPO[0];		
+        szGPOSetting[1] = _gMsg21xxaShort_1_GPO[1];		
+        szGPOSetting[2] = _gMsg21xxaShort_1_GPO[2];		
+        szGPOSetting[2] |= (1 << (int)(MSG21XXA_PIN_GUARD_RING % 16));
+    }
+    else if (nItemId == 2) // 39-2
+    {
+        szGPOSetting[0] = _gMsg21xxaShort_2_GPO[0];		
+        szGPOSetting[1] = _gMsg21xxaShort_2_GPO[1];		
+        szGPOSetting[2] = _gMsg21xxaShort_2_GPO[2];		
+        szGPOSetting[2] |= (1 << (int)(MSG21XXA_PIN_GUARD_RING % 16));
+    }
+    else if (nItemId == 3) // 39-3
+    {
+        szGPOSetting[0] = _gMsg21xxaShort_3_GPO[0];		
+        szGPOSetting[1] = _gMsg21xxaShort_3_GPO[1];		
+        szGPOSetting[2] = _gMsg21xxaShort_3_GPO[2];		
+        szGPOSetting[2] |= (1 << (int)(MSG21XXA_PIN_GUARD_RING % 16));
+    }
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+    else if (nItemId == 0) // 39-4 (2R)
+    {
+        szGPOSetting[0] = _gMsg21xxaShort_4_GPO[0];		
+        szGPOSetting[1] = _gMsg21xxaShort_4_GPO[1];		
+        szGPOSetting[2] = _gMsg21xxaShort_4_GPO[2];		
+        szGPOSetting[2] |= (1 << (int)(MSG21XXA_PIN_GUARD_RING % 16));
+    }
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+    else
+    {
+        DBG(&g_I2cClient->dev, "Invalid item id for changing GPIO setting of short test.\n");
+
+        return;
+    }
+
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x12;
+    szDbBusTxData[2] = 0x48;
+
+    for (i = 0; i < MSG21XXA_GPO_SETTING_SIZE; i ++)
+    {
+        szDbBusTxData[3+2*i] = szGPOSetting[i] & 0xFF;
+        szDbBusTxData[4+2*i] = (szGPOSetting[i] >> 8) & 0xFF;    	
+    }
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+MSG21XXA_GPO_SETTING_SIZE*2);    
+}
+
+static void _DrvMpTestItoShortTestMsg21xxaChangeRmodeSetting(u8 nMode)
+{
+    u8 szDbBusTxData[6] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() nMode = %d ***\n", __func__, nMode);
+
+    // AFE R-mode enable(Bit-12)
+    RegSetLByteValue(0x1103, 0x10);
+
+    // drv_mux_OV (Bit-8 1:enable)
+    RegSetLByteValue(0x1107, 0x55);
+    
+    if (nMode == 1) // P_CODE: 0V
+    {
+        RegSet16BitValue(0x110E, 0x073A);
+    }
+    else if (nMode == 0) // N_CODE: 2.4V
+    {
+        RegSet16BitValue(0x110E, 0x073B);
+    }
+
+    // SW2 rising & SW3 rising return to 0
+    RegSetLByteValue(0x1227, 0x01);
+    // turn off the chopping
+    RegSetLByteValue(0x1208, 0x0C);
+    // idle driver ov
+    RegSetLByteValue(0x1241, 0xC0);
+	  
+	  // AFE ov
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x12;
+    szDbBusTxData[2] = 0x44;
+    szDbBusTxData[3] = 0xFF;
+    szDbBusTxData[4] = 0xFF;
+    szDbBusTxData[5] = 0xFF;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 6);        
+}	
+
+static void _DrvMpTestItoShortTestMsg21xxaFirst(u8 nItemId, s16 *pRawData, s8 *pDataFlag)		
+{
+    u32 i;
+    s16 szTmpRawData[SELF_IC_MAX_CHANNEL_NUM] = {0};
+    s16 szTmpRawData2[SELF_IC_MAX_CHANNEL_NUM] = {0};
+    u8  nSensorNum, nSensorNum2, nNumOfSensorMapping1, nNumOfSensorMapping2, nSensorCount = 0;
+    u8 	*pMapping = NULL;
+    
+    DBG(&g_I2cClient->dev, "*** %s() nItemId = %d ***\n", __func__, nItemId);
+
+    // Stop cpu
+    RegSet16BitValue(0x0FE6, 0x0001); //bank:mheg5, addr:h0073
+    // chip top op0
+    RegSet16BitValue(0x1E24, 0x0500); //bank:chip, addr:h0012
+    RegSet16BitValue(0x1E2A, 0x0000); //bank:chip, addr:h0015
+    RegSet16BitValue(0x1EE6, 0x6E00); //bank:chip, addr:h0073
+    RegSet16BitValue(0x1EE8, 0x0071); //bank:chip, addr:h0074
+	    
+    if ((_gSelfICItoTestTriangleNum + _gSelfICItoTestKeyNum + _gSelfICItoTestDummyNum) % 2 != 0)
+    {
+        nNumOfSensorMapping1 = (_gSelfICItoTestTriangleNum + _gSelfICItoTestKeyNum + _gSelfICItoTestDummyNum) / 2 + 1;
+        nNumOfSensorMapping2 = nNumOfSensorMapping1;
+    }
+    else
+    {
+        nNumOfSensorMapping1 = (_gSelfICItoTestTriangleNum + _gSelfICItoTestKeyNum + _gSelfICItoTestDummyNum) / 2;
+        nNumOfSensorMapping2 = nNumOfSensorMapping1;
+        if (nNumOfSensorMapping2 % 2 != 0)
+        {	
+            nNumOfSensorMapping2 ++;
+        }
+    }        
+
+    if (nItemId == 1) // 39-1    			    		
+    {
+        pMapping = &_gSelfIC_SHORT_MAP1[0];
+        nSensorCount = nNumOfSensorMapping1; 
+    }
+    else if (nItemId == 2) // 39-2   		
+    {
+        pMapping = &_gSelfIC_SHORT_MAP2[0];      
+        nSensorCount = nNumOfSensorMapping2; 
+    }
+    else if (nItemId == 3) // 39-3    		
+    {
+        pMapping = &_gSelfIC_SHORT_MAP3[0];      
+        nSensorCount = _gSelfICItoTestTriangleNum; 
+    }
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+    else if (nItemId == 0) // 39-4 (2R)    			
+    {
+        pMapping = &_gSelfIC_SHORT_MAP4[0];
+        nSensorCount = _gSelfICItoTestTriangleNum/2; 
+    }
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+
+    DBG(&g_I2cClient->dev, "nSensorCount = %d\n", nSensorCount);
+        	    
+    _DrvMpTestItoTestMsg21xxaSendDataIn(nItemId);
+    
+    _DrvMpTestItoTestMsg21xxaDisableFilterNoiseDetect();
+
+    _DrvMpTestItoShortTestMsg21xxaChangeRmodeSetting(1);
+    _DrvMpTestItoShortTestMsg21xxaChangeGPOSetting(nItemId);
+    _DrvMpTestItoTestSelfICAnaSwReset();
+    nSensorNum = _DrvMpTestItoTestMsg21xxaGetDataOut(szTmpRawData);
+    DBG(&g_I2cClient->dev, "nSensorNum = %d\n", nSensorNum);
+
+    _DrvMpTestItoShortTestMsg21xxaChangeRmodeSetting(0);
+    _DrvMpTestItoShortTestMsg21xxaChangeGPOSetting(nItemId);
+    _DrvMpTestItoTestSelfICAnaSwReset();
+    nSensorNum2 = _DrvMpTestItoTestMsg21xxaGetDataOut(szTmpRawData2);
+    DBG(&g_I2cClient->dev, "nSensorNum2 = %d\n", nSensorNum2);
+    
+    for (i = 0; i < nSensorCount; i ++)
+    {
+        pRawData[pMapping[i]] = szTmpRawData[i] - szTmpRawData2[i];	
+        pDataFlag[pMapping[i]] = 1;
+    }	
+}
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+static u16 _DrvMpTestItoTestMsg22xxGetDataOut(s16 *pRawData, u16 nSubFrameNum)
+{
+    u32 i;
+    u16 szRawData[SELF_IC_MAX_CHANNEL_NUM*2] = {0};
+    u16 nRegInt = 0x0000;
+    u16 nSize = nSubFrameNum * 4;  // 1SF 4AFE
+    u8  szDbBusTxData[8] = {0};
+    u8  szDbBusRxData[SELF_IC_MAX_CHANNEL_NUM*4] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    RegSet16BitValueOff(0x120A, BIT1); //one-shot mode
+    RegSet16BitValueOff(0x3D08, BIT8); //SELF_IC_FIQ_E_FRAME_READY_MASK
+    //RegSet16BitValue(0x130C, BIT15); //MCU read done
+    RegSet16BitValueOn(0x120A, BIT0); //trigger one-shot 
+
+    DBG(&g_I2cClient->dev, "polling start\n");
+
+    //Polling frame-ready interrupt status
+    do 
+    {
+        nRegInt = RegGet16BitValue(0x3D18); //bank:intr_ctrl, addr:h000c
+    } while((nRegInt & SELF_IC_FIQ_E_FRAME_READY_MASK) == 0x0000);
+
+    DBG(&g_I2cClient->dev, "polling end\n");
+
+    RegSet16BitValueOff(0x3D18, BIT8); //Clear frame-ready interrupt status
+
+    //ReadRegBurst start   
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x15; //bank:fout, addr:h0000 
+    szDbBusTxData[2] = 0x00;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);
+    mdelay(20);
+    IicReadData(SLAVE_I2C_ID_DBBUS, &szDbBusRxData[0], (nSubFrameNum * 4 * 2));
+    mdelay(100);
+
+    for (i = 0; i < (nSubFrameNum * 4 * 2); i ++)
+    {
+        DBG(&g_I2cClient->dev, "szDbBusRxData[%d] = %d\n", i, szDbBusRxData[i]); // add for debug
+    }
+    //ReadRegBurst stop
+ 
+    RegSet16BitValueOn(0x3D08, BIT8); //SELF_IC_FIQ_E_FRAME_READY_MASK
+
+    for (i = 0; i < nSize; i ++)
+    {
+        szRawData[i] = (szDbBusRxData[2 * i + 1] << 8 ) | (szDbBusRxData[2 * i]);
+        pRawData[i] = (s16)szRawData[i];
+    }
+    
+    return nSize;
+}
+
+static void _DrvMpTestItoTestMsg22xxSendDataIn(u8 nStep, u16 nRiuWriteLength)
+{
+    u32	i;
+    u32 *pType = NULL;
+
+    DBG(&g_I2cClient->dev, "*** %s() nStep = %d, nRiuWriteLength = %d ***\n", __func__, nStep, nRiuWriteLength);
+
+    if (nStep == 1) //39-1
+    {
+        pType = &_gMsg22xxShort_RIU1[0];      	
+    }
+    else if (nStep == 2) //39-2
+    {
+        pType = &_gMsg22xxShort_RIU2[0];      	
+    }
+    else if (nStep == 3) //39-3
+    {
+        pType = &_gMsg22xxShort_RIU3[0];        
+    }
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+    else if (nStep == 0) //39-4 (2R)
+    {
+        pType = &_gMsg22xxShort_RIU4[0];
+    }
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+    else if (nStep == 4)
+    {
+        pType = &_gMsg22xxOpenRIU1[0];        
+    }
+    else if (nStep == 5)
+    {
+        pType = &_gMsg22xxOpenRIU2[0];      	
+    }
+    else if (nStep == 6)
+    {
+        pType = &_gMsg22xxOpenRIU3[0];      	
+    }
+
+    RegSet16BitValueOn(0x1192, BIT4); // force on enable sensor mux and csub sel sram clock
+    RegSet16BitValueOff(0x1192, BIT5); // mem clk sel 
+    RegSet16BitValueOff(0x1100, BIT3); // tgen soft rst
+    RegSet16BitValue(0x1180, MSG22XX_RIU_BASE_ADDR); // sensor mux sram read/write base address
+    RegSet16BitValue(0x1182, nRiuWriteLength); // sensor mux sram write length
+    RegSet16BitValueOn(0x1188, BIT0); // reg_mem0_w_start
+
+    for (i = MSG22XX_RIU_BASE_ADDR; i < (MSG22XX_RIU_BASE_ADDR + nRiuWriteLength); i ++)
+    {
+        RegSet16BitValue(0x118A, (u16)(pType[i]));
+        RegSet16BitValue(0x118C, (u16)(pType[i] >> 16));
+    }
+}
+
+static void _DrvMpTestItoTestMsg22xxSetC(u8 nCSubStep)
+{
+    u32 i;
+    u16 nRegVal;
+    u32 nCSubNew; 
+     
+    DBG(&g_I2cClient->dev, "*** %s() nCSubStep = %d ***\n", __func__, nCSubStep);
+    
+    nCSubNew = (nCSubStep > MSG22XX_CSUB_REF_MAX) ? MSG22XX_CSUB_REF_MAX : nCSubStep; // 6 bits
+    nCSubNew = (nCSubNew | (nCSubNew << 8) | (nCSubNew << 16) | (nCSubNew << 24));
+
+    nRegVal = RegGet16BitValue(0x11C8); // csub sel overwrite enable, will referance value of 11C0
+
+    if (nRegVal == 0x000F)
+    {
+        RegSet16BitValue(0x11C0, nCSubNew);         // prs 0
+        RegSet16BitValue(0x11C2, (nCSubNew >> 16)); // prs 0
+        RegSet16BitValue(0x11C4, nCSubNew);         // prs 1
+        RegSet16BitValue(0x11C6, (nCSubNew >> 16)); // prs 1
+    }
+    else
+    {
+        RegSet16BitValueOn(0x1192, BIT4);   // force on enable sensor mux  and csub sel sram clock
+        RegSet16BitValueOff(0x1192, BIT5);   // mem clk sel 
+        RegSet16BitValueOff(0x1100, BIT3);   // tgen soft rst
+        RegSet16BitValue(0x1184, 0);          // nAddr
+        RegSet16BitValue(0x1186, SELF_IC_MAX_CHANNEL_NUM);         // nLen
+        RegSet16BitValueOn(0x1188, BIT2);   // reg_mem0_w_start
+
+        for (i = 0; i < SELF_IC_MAX_CHANNEL_NUM; i ++)
+        {
+            RegSet16BitValue(0x118E, nCSubNew);
+            RegSet16BitValue(0x1190, (nCSubNew >> 16));
+        }
+    }
+}
+
+static void _DrvMpTestItoTestMsg22xxRegisterReset(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    RegSet16BitValueOn(0x1102, (BIT3 | BIT4 | BIT5 | BIT6 | BIT7));
+    RegSet16BitValueOff(0x1130, (BIT0 | BIT1 | BIT2 | BIT3 | BIT8));
+
+    RegSet16BitValueOn(0x1312, BIT15);
+    RegSet16BitValueOff(0x1312, BIT13);
+
+    RegMask16BitValue(0x1250, 0x007F, ((5 << 0) & 0x007F), ADDRESS_MODE_8BIT); 
+
+    RegMask16BitValue(0x1250, 0x7F00, ((1 << 8) & 0x7F00), ADDRESS_MODE_8BIT); 
+
+    RegSet16BitValueOff(0x1250, 0x8080);
+
+    RegSet16BitValueOff(0x1312, (BIT12 | BIT14));
+
+    RegSet16BitValueOn(0x1300, BIT15);
+    RegSet16BitValueOff(0x1300, (BIT10 | BIT11 | BIT12 | BIT13 | BIT14));
+
+    RegSet16BitValueOn(0x1130, BIT9);
+
+    RegSet16BitValueOn(0x1318, (BIT12 | BIT13));
+
+    RegSet16BitValue(0x121A, ((8 - 1) & 0x01FF));       // sampling number group A
+    RegSet16BitValue(0x121C, ((8 - 1) & 0x01FF));       // sampling number group B
+    
+    RegMask16BitValue(0x131A, 0x3FFF, 0x2000, ADDRESS_MODE_8BIT); 
+    
+    RegMask16BitValue(0x131C, (BIT8 | BIT9 | BIT10), (2 << 8), ADDRESS_MODE_8BIT); 
+
+    RegSet16BitValueOff(0x1174, 0x0F00);
+
+    RegSet16BitValueOff(0x1240, 0xFFFF);       // mutual cap mode selection for total 24 subframes, 0: normal sense, 1: mutual cap sense
+    RegSet16BitValueOff(0x1242, 0x00FF);       // mutual cap mode selection for total 24 subframes, 0: normal sense, 1: mutual cap sense
+
+    RegSet16BitValueOn(0x1212, 0xFFFF);       // timing group A/B selection for total 24 subframes, 0: group A, 1: group B
+    RegSet16BitValueOn(0x1214, 0x00FF);       // timing group A/B selection for total 24 subframes, 0: group A, 1: group B
+
+    RegSet16BitValueOn(0x121E, 0xFFFF);   //sample number group A/B selection for total 24 subframes, 0: group A, 1: group B       
+    RegSet16BitValueOn(0x1220, 0x00FF);   //sample number group A/B selection for total 24 subframes, 0: group A, 1: group B    
+
+    RegSet16BitValueOff(0x120E, 0xFFFF);  // noise sense mode selection for total 24 subframes
+    RegSet16BitValueOff(0x1210, 0x00FF);  // noise sense mode selection for total 24 subframes
+
+    RegSet16BitValue(0x128C, 0x0F);  // ADC afe gain correction bypass
+    RegSet16BitValueOff(0x1104, BIT12); 
+}
+
+static void _DrvMpTestItoTestMsg22xxRegisterResetPatch(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() *** _gIsOldFirmwareVersion = %d\n", __func__, _gIsOldFirmwareVersion);
+    
+    if (_gIsOldFirmwareVersion == 0) // Only need to patch register reset for MSG22XX firmware older than V01.005.02;
+    {
+        return;		
+    }
+
+    RegMask16BitValue(0x1101, 0xFFFF, 0x501E, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1102, 0x7FFF, 0x06FF, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1104, 0x0FFF, 0x0772, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1105, 0x0FFF, 0x0770, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1106, 0x00FF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1107, 0x0003, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1108, 0x0073, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1109, 0xFFFF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x110A, 0x7FFF, 0x1087, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x110E, 0xFFFF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x110F, 0xFFFF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1117, 0xFF0F, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1118, 0xFFFF, 0x0200, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1119, 0x00FF, 0x000E, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x111E, 0xFFFF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x111F, 0x00FF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1133, 0x000F, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x113A, 0x0F37, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x113B, 0x0077, 0x0077, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x113C, 0xFF00, 0xA000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x113D, 0x0077, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x113E, 0x00FF, 0x0000, ADDRESS_MODE_16BIT); 
+
+    RegMask16BitValue(0x1204, 0x0006, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1205, 0x00FF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1207, 0xFFFF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1208, 0x00FF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1209, 0xFFFF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x120A, 0x00FF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x120B, 0x003F, 0x002E, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x120D, 0x001F, 0x0005, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x120E, 0x001F, 0x0005, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x120F, 0xFFFF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1210, 0x00FF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1211, 0x0FFF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1212, 0x1F87, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1213, 0x0F7F, 0x0014, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1214, 0xFF9F, 0x090A, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1215, 0x0F7F, 0x0F0C, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1216, 0x0FFF, 0x0700, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1217, 0xFF1F, 0x5C0A, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1218, 0x1F7F, 0x0A14, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1219, 0xFFFF, 0x218C, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x121E, 0x1F1F, 0x0712, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x121F, 0x3F3F, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1220, 0xFFFF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1221, 0x00FF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1223, 0x3F3F, 0x0002, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1224, 0x003F, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1228, 0xFFFF, 0x8183, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x122D, 0x0001, 0x0001, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1250, 0xFFFF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1251, 0x00FF, 0x0000, ADDRESS_MODE_16BIT); 
+    RegMask16BitValue(0x1270, 0x0003, 0x0003, ADDRESS_MODE_16BIT); 
+
+    RegSet16BitValueByAddressMode(0x115C, 0x0000, ADDRESS_MODE_16BIT); //sensor ov enable
+    RegSet16BitValueByAddressMode(0x115D, 0x0000, ADDRESS_MODE_16BIT); //sensor ov enable
+    RegSet16BitValueByAddressMode(0x115E, 0x0000, ADDRESS_MODE_16BIT); //sensor and gr ov enable
+
+    RegSet16BitValueByAddressMode(0x124E, 0x000F, ADDRESS_MODE_16BIT); //bypass mode
+}
+
+static void _DrvMpTestItoTestMsg22xxGetChargeDumpTime(u16 nMode, u16 *pChargeTime, u16 *pDumpTime)
+{
+    u16 nChargeTime = 0, nDumpTime = 0;
+    u16 nMinChargeTime = 0xFFFF, nMinDumpTime = 0xFFFF, nMaxChargeTime = 0x0000, nMaxDumpTime = 0x0000;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nChargeTime = RegGet16BitValue(0x1226);
+    nDumpTime = RegGet16BitValue(0x122A);
+
+    if (nMinChargeTime > nChargeTime)
+    {
+        nMinChargeTime = nChargeTime;
+    }
+
+    if (nMaxChargeTime < nChargeTime)
+    {
+        nMaxChargeTime = nChargeTime;
+    }
+
+    if (nMinDumpTime > nDumpTime)
+    {
+        nMinDumpTime = nDumpTime;
+    }
+
+    if (nMaxDumpTime < nDumpTime)
+    {
+        nMaxDumpTime = nDumpTime;
+    }
+
+    DBG(&g_I2cClient->dev, "nChargeTime = %d, nDumpTime = %d\n", nChargeTime, nDumpTime);
+    
+    if (nMode == 1)
+    {
+        *pChargeTime = nMaxChargeTime;
+        *pDumpTime = nMaxDumpTime;
+    }
+    else
+    {
+        *pChargeTime = nMinChargeTime;
+        *pDumpTime = nMinDumpTime;
+    }
+}
+
+static void _DrvMpTestItoOpenTestMsg22xxFirst(u8 nItemId, s16 *pRawData, s8 *pDataFlag)		
+{
+    u32 i;
+    s16 szTmpRawData[SELF_IC_MAX_CHANNEL_NUM*2] = {0};
+    u16 nSubFrameNum = 0;
+    u16 nChargeTime, nDumpTime;
+    u8 	*pMapping = NULL;
+    
+    DBG(&g_I2cClient->dev, "*** %s() nItemId = %d ***\n", __func__, nItemId);
+	
+    if (nItemId == 40)
+    {
+        // Stop cpu
+        RegSet16BitValue(0x0FE6, 0x0001); //bank:mheg5, addr:h0073
+
+        _DrvMpTestItoTestMsg22xxRegisterResetPatch();
+        _DrvMpTestItoTestMsg22xxRegisterReset();
+    }
+
+    switch (nItemId)
+    {
+        case 40:
+            pMapping = &_gSelfIC_MAP1[0];
+            nSubFrameNum = _gMsg22xxOpenSubFrameNum1;
+            break;
+        case 41:
+            pMapping = &_gSelfIC_MAP2[0];
+            nSubFrameNum = _gMsg22xxOpenSubFrameNum2;
+            break;
+        case 42:
+            pMapping = &_gSelfIC_MAP3[0];
+            nSubFrameNum = _gMsg22xxOpenSubFrameNum3;
+            break;
+    }
+
+    if (nSubFrameNum > 24) // SELF_IC_MAX_CHANNEL_NUM/2
+    {
+        nSubFrameNum = 24;
+    }
+
+    _DrvMpTestItoTestMsg22xxSendDataIn(nItemId - 36, nSubFrameNum * 6);
+    RegSet16BitValue(0x1216, (nSubFrameNum - 1) << 1); // subframe numbers, 0:1subframe, 1:2subframe  
+
+    if (nItemId == 40)
+    {
+        if (1)
+        {
+            RegSet16BitValue(0x1110, 0x0060); //2.4V -> 1.2V    
+        }
+        else
+        {
+            RegSet16BitValue(0x1110, 0x0020); //3.0V -> 0.6V
+        }
+    
+        RegSet16BitValue(0x11C8, 0x000F); //csub sel overwrite enable, will referance value of 11C0
+        RegSet16BitValue(0x1174, 0x0F06); // 1 : sel idel driver for sensor pad that connected to AFE
+        RegSet16BitValue(0x1208, 0x0006); //PRS1
+        RegSet16BitValue(0x1240, 0xFFFF); //mutual cap mode selection for total 24 subframes, 0: normal sense, 1: mutual cap sense
+        RegSet16BitValue(0x1242, 0x00FF); //mutual cap mode selection for total 24 subframes, 0: normal sense, 1: mutual cap sense
+
+        _DrvMpTestItoTestMsg22xxGetChargeDumpTime(1, &nChargeTime, &nDumpTime);
+
+        RegSet16BitValue(0x1226, nChargeTime);
+        RegSet16BitValue(0x122A, nDumpTime);
+
+        _DrvMpTestItoTestMsg22xxSetC(MSG22XX_CSUB_REF);
+        _DrvMpTestItoTestSelfICAnaSwReset();
+    }
+
+    _DrvMpTestItoTestMsg22xxGetDataOut(szTmpRawData, nSubFrameNum);
+
+    for (i = 0; i < nSubFrameNum; i ++)
+    {
+//        DBG(&g_I2cClient->dev, "szTmpRawData[%d * 4] >> 3 = %d\n", i, szTmpRawData[i * 4] >> 3); // add for debug
+//        DBG(&g_I2cClient->dev, "pMapping[%d] = %d\n", i, pMapping[i]); // add for debug
+
+        pRawData[pMapping[i]] = (szTmpRawData[i * 4] >> 3);  // Filter to ADC 
+        pDataFlag[pMapping[i]] = 1;
+    }
+}
+
+static void _DrvMpTestItoShortTestMsg22xxFirst(u8 nItemId, s16 *pRawData, s8 *pDataFlag)		
+{
+    u32 i, j;
+    s16 szIIR1[MSG22XX_MAX_SUBFRAME_NUM*MSG22XX_MAX_AFE_NUM] = {32767};
+    s16 szIIR2[MSG22XX_MAX_SUBFRAME_NUM*MSG22XX_MAX_AFE_NUM] = {32767};
+    s16 szIIRTmp[MSG22XX_MAX_SUBFRAME_NUM*MSG22XX_MAX_AFE_NUM] = {32767};
+    u16 nSensorNum = 0, nSubFrameNum = 0;
+    u8 	*pMapping = NULL;
+    
+    DBG(&g_I2cClient->dev, "*** %s() nItemId = %d ***\n", __func__, nItemId);
+
+    if ((nItemId == 0 && _gSelfICIsEnable2R == 1) || (nItemId == 1 && _gSelfICIsEnable2R == 0))
+    {
+        // Stop cpu
+        RegSet16BitValue(0x0FE6, 0x0001); //bank:mheg5, addr:h0073
+        
+        _DrvMpTestItoTestMsg22xxRegisterResetPatch();
+        _DrvMpTestItoTestMsg22xxRegisterReset();
+    }
+
+    switch(nItemId)
+    {
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+        case 0: // 39-4 (2R)
+            pMapping = &_gSelfIC_SHORT_MAP4[0];
+            nSensorNum = _gMsg22xxShortSubFrameNum4;
+            break;
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+        case 1: // 39-1
+            pMapping = &_gSelfIC_SHORT_MAP1[0];
+            nSensorNum = _gMsg22xxShortSubFrameNum1;
+            break;
+        case 2: // 39-2
+            pMapping = &_gSelfIC_SHORT_MAP2[0];
+            nSensorNum = _gMsg22xxShortSubFrameNum2;
+            break;
+        case 3: // 39-3
+            pMapping = &_gSelfIC_SHORT_MAP3[0];
+            nSensorNum = _gMsg22xxShortSubFrameNum3;
+            break;            
+    }
+    
+    if (nSensorNum > 24) // SELF_IC_MAX_CHANNEL_NUM/2
+    {
+        nSubFrameNum = 24;
+    }
+    else
+    {
+        nSubFrameNum = nSensorNum;
+    }
+
+    _DrvMpTestItoTestMsg22xxSendDataIn(nItemId, nSubFrameNum * 6);
+    RegSet16BitValue(0x1216, (nSubFrameNum - 1) << 1); // subframe numbers, 0:1subframe, 1:2subframe
+
+    if ((nItemId == 0 && _gSelfICIsEnable2R == 1) || (nItemId == 1 && _gSelfICIsEnable2R == 0))
+    {
+        RegSet16BitValue(0x1110, 0x0030); // [6:4}  011 : 2.1V -> 1.5V
+//        RegSet16BitValue(0x1110, 0x0060); // 2.4V -> 1.2V
+        RegSet16BitValue(0x11C8, 0x000F); // csub sel overwrite enable, will referance value of 11C0
+        RegSet16BitValue(0x1174, 0x0000); // [11:8] 000 : sel active driver for sensor pad that connected to AFE
+        RegSet16BitValue(0x1208, 0x0006); // PRS 1
+        RegSet16BitValueOn(0x1104, BIT14); // R mode 
+        RegSet16BitValue(0x1176, 0x0000); // CFB 10p
+        
+        _DrvMpTestItoTestMsg22xxSetC(MSG22XX_CSUB_REF);
+
+        RegMask16BitValue(0x1213, 0x007F, 0x003B, ADDRESS_MODE_16BIT); // Charge 20ns (group A)
+        RegMask16BitValue(0x1218, 0x007F, 0x003B, ADDRESS_MODE_16BIT); // Charge 20ns (group B)
+    }    
+
+    RegMask16BitValue(0x1215, 0x007F, 0x000B, ADDRESS_MODE_16BIT); // Dump 4ns (group A)
+    RegMask16BitValue(0x1219, 0x007F, 0x000B, ADDRESS_MODE_16BIT); // Dump 4ns (group B)
+
+    _DrvMpTestItoTestSelfICAnaSwReset();
+    _DrvMpTestItoTestMsg22xxGetDataOut(szIIRTmp, nSubFrameNum);
+    
+    if (nSensorNum > MSG22XX_MAX_SUBFRAME_NUM)
+    {
+        j = 0;
+
+        for (i = 0; i < MSG22XX_MAX_SUBFRAME_NUM; i ++)
+        {
+            szIIR1[j] = (szIIRTmp[i * 4] >> 3);
+            j ++;
+            
+            if ((nSensorNum - MSG22XX_MAX_SUBFRAME_NUM) > i)
+            {
+                szIIR1[j] = (szIIRTmp[i * 4 + 1] >> 3);
+                j ++;
+            }    
+        }
+    }
+    else
+    {
+        for (i = 0; i < nSensorNum; i ++)
+        {
+            szIIR1[i] = (szIIRTmp[i * 4 + 1] >> 3);
+        }
+    }
+
+    RegMask16BitValue(0x1215, 0x007F, 0x0017, ADDRESS_MODE_16BIT); // Dump 8ns (group A)
+    RegMask16BitValue(0x1219, 0x007F, 0x0017, ADDRESS_MODE_16BIT); // Dump 8ns (group B)
+
+    _DrvMpTestItoTestSelfICAnaSwReset();
+    _DrvMpTestItoTestMsg22xxGetDataOut(szIIRTmp, nSubFrameNum);
+
+    if (nSensorNum > MSG22XX_MAX_SUBFRAME_NUM)
+    {
+        j = 0;
+
+        for (i = 0; i < MSG22XX_MAX_SUBFRAME_NUM; i ++)
+        {
+            szIIR2[j] = (szIIRTmp[i * 4] >> 3);
+            j ++;
+            
+            if ((nSensorNum - MSG22XX_MAX_SUBFRAME_NUM) > i)
+            {
+                szIIR2[j] = (szIIRTmp[i * 4 + 1] >> 3);
+                j ++;
+            }    
+        }
+    }
+    else
+    {
+        for (i = 0; i < nSensorNum; i ++)
+        {
+            szIIR2[i] = (szIIRTmp[i * 4 + 1] >> 3);
+        }
+    }
+
+    for (i = 0; i < nSensorNum; i ++)
+    {
+        if ((abs(szIIR1[i]) > 4000) || (abs(szIIR2[i]) > 4000))
+        {
+            pRawData[pMapping[i]] = 8192;
+        }
+        else
+        {
+            pRawData[pMapping[i]] = ((szIIR2[i] - szIIR1[i]) * 4);
+        }
+        pDataFlag[pMapping[i]] = 1;
+
+//        DBG(&g_I2cClient->dev, "szIIR1[%d] = %d, szIIR2[%d] = %d\n", i, szIIR1[i], i, szIIR2[i]); // add for debug
+//        DBG(&g_I2cClient->dev, "pRawData[%d] = %d\n", pMapping[i], pRawData[pMapping[i]]); // add for debug
+//        DBG(&g_I2cClient->dev, "pMapping[%d] = %d\n", i, pMapping[i]); // add for debug
+    }
+}
+
+static u8 _DrvMpTestMsg22xxCheckFirmwareVersion(void) // Only MSG22XX support platform firmware version
+{
+    u32 i;
+    s32 nDiff;
+    u16 nRegData1, nRegData2;
+    u8 szDbBusRxData[12] = {0};
+    u8 szCompareFwVersion[10] = {0x56, 0x30, 0x31, 0x2E, 0x30, 0x30, 0x35, 0x2E, 0x30, 0x32}; //{'V', '0', '1', '.', '0', '0', '5', '.', '0', '2'}
+    u8 nIsOldFirmwareVersion = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    mutex_lock(&g_Mutex);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); 
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55);
+
+    // RIU password
+    RegSet16BitValue(0x161A, 0xABBA); 
+
+
+    RegSet16BitValue(0x1600, 0xC1F2); // Set start address for platform firmware version on info block(Actually, start reading from 0xC1F0)
+
+    // Enable burst mode
+    RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+    for (i = 0; i < 3; i ++)
+    {
+        RegSetLByteValue(0x160E, 0x01); 
+
+        nRegData1 = RegGet16BitValue(0x1604);
+        nRegData2 = RegGet16BitValue(0x1606);
+
+        szDbBusRxData[i*4+0] = (nRegData1 & 0xFF);
+        szDbBusRxData[i*4+1] = ((nRegData1 >> 8 ) & 0xFF);
+        
+        DBG(&g_I2cClient->dev, "szDbBusRxData[%d] = 0x%x , %c \n", i*4+0, szDbBusRxData[i*4+0], szDbBusRxData[i*4+0]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[%d] = 0x%x , %c \n", i*4+1, szDbBusRxData[i*4+1], szDbBusRxData[i*4+1]); // add for debug
+        
+        szDbBusRxData[i*4+2] = (nRegData2 & 0xFF);
+        szDbBusRxData[i*4+3] = ((nRegData2 >> 8 ) & 0xFF);
+
+        DBG(&g_I2cClient->dev, "szDbBusRxData[%d] = 0x%x , %c \n", i*4+2, szDbBusRxData[i*4+2], szDbBusRxData[i*4+2]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[%d] = 0x%x , %c \n", i*4+3, szDbBusRxData[i*4+3], szDbBusRxData[i*4+3]); // add for debug
+    }
+
+    // Clear burst mode
+    RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+    RegSet16BitValue(0x1600, 0x0000); 
+
+    // Clear RIU password
+    RegSet16BitValue(0x161A, 0x0000); 
+    
+    for (i = 0; i < 10; i ++)
+    {
+        nDiff = szDbBusRxData[2+i] - szCompareFwVersion[i];
+        
+        DBG(&g_I2cClient->dev, "i = %d, nDiff = %d\n", i, nDiff);
+        
+        if (nDiff < 0)
+        {
+            nIsOldFirmwareVersion = 1;
+            break;
+        }
+        else if (nDiff > 0)
+        {
+            nIsOldFirmwareVersion = 0;
+            break;
+        }
+    }
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    mutex_unlock(&g_Mutex);
+
+    return nIsOldFirmwareVersion;
+}
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG22XX)
+static u16 _DrvMpTestItoTestSelfICGetTpType(void)
+{
+    u16 nMajor = 0, nMinor = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+        
+    if (g_ChipType == CHIP_TYPE_MSG21XXA)
+    {
+        u8 szDbBusTxData[3] = {0};
+        u8 szDbBusRxData[4] = {0};
+
+        szDbBusTxData[0] = 0x53;
+        szDbBusTxData[1] = 0x00;
+        szDbBusTxData[2] = 0x2A;
+
+        IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+        IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+        nMajor = (szDbBusRxData[1]<<8) + szDbBusRxData[0];
+        nMinor = (szDbBusRxData[3]<<8) + szDbBusRxData[2];
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        u16 nRegData1, nRegData2;
+
+        DrvPlatformLyrTouchDeviceResetHw();
+    
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+        
+        // Stop mcu
+        RegSetLByteValue(0x0FE6, 0x01); 
+
+        // Stop watchdog
+        RegSet16BitValue(0x3C60, 0xAA55);
+
+        // RIU password
+        RegSet16BitValue(0x161A, 0xABBA); 
+
+        RegSet16BitValue(0x1600, 0xBFF4); // Set start address for customer firmware version on main block
+    
+        // Enable burst mode
+//        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+    
+        RegSetLByteValue(0x160E, 0x01); 
+
+        nRegData1 = RegGet16BitValue(0x1604);
+        nRegData2 = RegGet16BitValue(0x1606);
+
+        nMajor = (((nRegData1 >> 8) & 0xFF) << 8) + (nRegData1 & 0xFF);
+        nMinor = (((nRegData2 >> 8) & 0xFF) << 8) + (nRegData2 & 0xFF);
+
+        // Clear burst mode
+//        RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+        RegSet16BitValue(0x1600, 0x0000); 
+
+        // Clear RIU password
+        RegSet16BitValue(0x161A, 0x0000); 
+
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+
+        DrvPlatformLyrTouchDeviceResetHw();
+        mdelay(100);
+    }
+
+    DBG(&g_I2cClient->dev, "*** major = %d ***\n", nMajor);
+    DBG(&g_I2cClient->dev, "*** minor = %d ***\n", nMinor);
+    
+    return nMajor;
+}
+
+static u16 _DrvMpTestItoTestSelfICChooseTpType(void)
+{
+    u16 nTpType = 0;
+    u32 i = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+    if (g_ChipType == CHIP_TYPE_MSG21XXA)   
+    {
+        // _gMsg21xxaOpen1~_gMsg21xxaOpen3 are for MSG21XXA
+        _gMsg21xxaOpen1 = NULL;
+        _gMsg21xxaOpen1B = NULL;
+        _gMsg21xxaOpen2 = NULL;
+        _gMsg21xxaOpen2B = NULL;
+        _gMsg21xxaOpen3 = NULL;
+
+        // _gMsg21xxaShort_1~_gMsg21xxaShort_4 are for MSG21XXA
+        _gMsg21xxaShort_1 = NULL;
+        _gMsg21xxaShort_2 = NULL;
+        _gMsg21xxaShort_3 = NULL;
+
+        _gMsg21xxaShort_1_GPO = NULL;
+        _gMsg21xxaShort_2_GPO = NULL;
+        _gMsg21xxaShort_3_GPO = NULL;
+
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+        _gMsg21xxaShort_4 = NULL;
+        _gMsg21xxaShort_4_GPO = NULL;
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+    }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+    
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+    if (g_ChipType == CHIP_TYPE_MSG22XX)   
+    {
+        // _gMsg22xxOpenRIU1~_gMsg22xxOpenRIU3 are for MSG22XX
+        _gMsg22xxOpenRIU1 = NULL;
+        _gMsg22xxOpenRIU2 = NULL;
+        _gMsg22xxOpenRIU3 = NULL;
+
+        // _gMsg22xxShort_RIU1~_gMsg22xxShort_RIU4 are for MSG22XX
+        _gMsg22xxShort_RIU1 = NULL;
+        _gMsg22xxShort_RIU2 = NULL;
+        _gMsg22xxShort_RIU3 = NULL;
+
+        _gMsg22xxOpenSubFrameNum1 = 0;
+        _gMsg22xxOpenSubFrameNum2 = 0;
+        _gMsg22xxOpenSubFrameNum3 = 0;
+        _gMsg22xxShortSubFrameNum1 = 0;
+        _gMsg22xxShortSubFrameNum2 = 0;
+        _gMsg22xxShortSubFrameNum3 = 0;
+
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+        _gMsg22xxShort_RIU4 = NULL;
+        _gMsg22xxShortSubFrameNum4 = 0;
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+    }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+    _gSelfIC_MAP1 = NULL;
+    _gSelfIC_MAP2 = NULL;
+    _gSelfIC_MAP3 = NULL;
+    _gSelfIC_MAP40_1 = NULL;
+    _gSelfIC_MAP40_2 = NULL;
+    _gSelfIC_MAP41_1 = NULL;
+    _gSelfIC_MAP41_2 = NULL;
+    
+    _gSelfIC_SHORT_MAP1 = NULL;
+    _gSelfIC_SHORT_MAP2 = NULL;
+    _gSelfIC_SHORT_MAP3 = NULL;
+
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+    _gSelfIC_MAP40_3 = NULL;
+    _gSelfIC_MAP40_4 = NULL;
+    _gSelfIC_MAP41_3 = NULL;
+    _gSelfIC_MAP41_4 = NULL;
+
+    _gSelfIC_SHORT_MAP4 = NULL;
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+    
+    _gSelfICItoTestKeyNum = 0;
+    _gSelfICItoTestDummyNum = 0;
+    _gSelfICItoTestTriangleNum = 0;
+    _gSelfICIsEnable2R = 0;
+
+    for (i = 0; i < 10; i ++)
+    {
+        nTpType = _DrvMpTestItoTestSelfICGetTpType();
+        DBG(&g_I2cClient->dev, "nTpType = %d, i = %d\n", nTpType, i);
+
+        if (TP_TYPE_X == nTpType || TP_TYPE_Y == nTpType) // Modify.
+        {
+            break;
+        }
+        else if (i < 5)
+        {
+            mdelay(100);  
+        }
+        else
+        {
+            DrvPlatformLyrTouchDeviceResetHw();
+        }
+    }
+    
+    if (TP_TYPE_X == nTpType) // Modify. 
+    {
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+        if (g_ChipType == CHIP_TYPE_MSG21XXA)   
+        {
+            _gMsg21xxaOpen1 = MSG21XXA_open_1_X;
+            _gMsg21xxaOpen1B = MSG21XXA_open_1B_X;
+            _gMsg21xxaOpen2 = MSG21XXA_open_2_X;
+            _gMsg21xxaOpen2B = MSG21XXA_open_2B_X;
+            _gMsg21xxaOpen3 = MSG21XXA_open_3_X;
+
+            _gMsg21xxaShort_1 = MSG21XXA_short_1_X;
+            _gMsg21xxaShort_2 = MSG21XXA_short_2_X;
+            _gMsg21xxaShort_3 = MSG21XXA_short_3_X;
+
+            _gMsg21xxaShort_1_GPO = MSG21XXA_short_1_X_GPO;
+            _gMsg21xxaShort_2_GPO = MSG21XXA_short_2_X_GPO;
+            _gMsg21xxaShort_3_GPO = MSG21XXA_short_3_X_GPO;
+
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+            _gMsg21xxaShort_4 = MSG21XXA_short_4_X;
+            _gMsg21xxaShort_4_GPO = MSG21XXA_short_4_X_GPO;
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+
+            _gSelfIC_MAP1 = MSG21XXA_MAP1_X;
+            _gSelfIC_MAP2 = MSG21XXA_MAP2_X;
+            _gSelfIC_MAP3 = MSG21XXA_MAP3_X;
+            _gSelfIC_MAP40_1 = MSG21XXA_MAP40_1_X;
+            _gSelfIC_MAP40_2 = MSG21XXA_MAP40_2_X;
+            _gSelfIC_MAP41_1 = MSG21XXA_MAP41_1_X;
+            _gSelfIC_MAP41_2 = MSG21XXA_MAP41_2_X;
+
+            _gSelfIC_SHORT_MAP1 = MSG21XXA_SHORT_MAP1_X;
+            _gSelfIC_SHORT_MAP2 = MSG21XXA_SHORT_MAP2_X;
+            _gSelfIC_SHORT_MAP3 = MSG21XXA_SHORT_MAP3_X;
+
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE       
+            _gSelfIC_MAP40_3 = MSG21XXA_MAP40_3_X;
+            _gSelfIC_MAP40_4 = MSG21XXA_MAP40_4_X;
+            _gSelfIC_MAP41_3 = MSG21XXA_MAP41_3_X;
+            _gSelfIC_MAP41_4 = MSG21XXA_MAP41_4_X;
+
+            _gSelfIC_SHORT_MAP4 = MSG21XXA_SHORT_MAP4_X;
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+ 
+            _gSelfICItoTestKeyNum = MSG21XXA_NUM_KEY_X;
+            _gSelfICItoTestDummyNum = MSG21XXA_NUM_DUMMY_X;
+            _gSelfICItoTestTriangleNum = MSG21XXA_NUM_SENSOR_X;
+            _gSelfICIsEnable2R = MSG21XXA_ENABLE_2R_X;
+        }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+        if (g_ChipType == CHIP_TYPE_MSG22XX)   
+        {
+            _gMsg22xxOpenRIU1 = MSG22XX_open_1_X;
+            _gMsg22xxOpenRIU2 = MSG22XX_open_2_X;
+            _gMsg22xxOpenRIU3 = MSG22XX_open_3_X;
+
+            _gMsg22xxShort_RIU1 = MSG22XX_short_1_X;
+            _gMsg22xxShort_RIU2 = MSG22XX_short_2_X;
+            _gMsg22xxShort_RIU3 = MSG22XX_short_3_X;
+
+            _gMsg22xxOpenSubFrameNum1 = MSG22XX_NUM_OPEN_1_SENSOR_X;
+            _gMsg22xxOpenSubFrameNum2 = MSG22XX_NUM_OPEN_2_SENSOR_X;
+            _gMsg22xxOpenSubFrameNum3 = MSG22XX_NUM_OPEN_3_SENSOR_X;
+            _gMsg22xxShortSubFrameNum1 = MSG22XX_NUM_SHORT_1_SENSOR_X;
+            _gMsg22xxShortSubFrameNum2 = MSG22XX_NUM_SHORT_2_SENSOR_X;
+            _gMsg22xxShortSubFrameNum3 = MSG22XX_NUM_SHORT_3_SENSOR_X;
+
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+            _gMsg22xxShort_RIU4 = MSG22XX_short_4_X;
+            _gMsg22xxShortSubFrameNum4 = MSG22XX_NUM_SHORT_4_SENSOR_X;
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+
+            _gSelfIC_MAP1 = MSG22XX_MAP1_X;
+            _gSelfIC_MAP2 = MSG22XX_MAP2_X;
+            _gSelfIC_MAP3 = MSG22XX_MAP3_X;
+            _gSelfIC_MAP40_1 = MSG22XX_MAP40_1_X;
+            _gSelfIC_MAP40_2 = MSG22XX_MAP40_2_X;
+            _gSelfIC_MAP41_1 = MSG22XX_MAP41_1_X;
+            _gSelfIC_MAP41_2 = MSG22XX_MAP41_2_X;
+
+            _gSelfIC_SHORT_MAP1 = MSG22XX_SHORT_MAP1_X;
+            _gSelfIC_SHORT_MAP2 = MSG22XX_SHORT_MAP2_X;
+            _gSelfIC_SHORT_MAP3 = MSG22XX_SHORT_MAP3_X;
+
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE       
+            _gSelfIC_MAP40_3 = MSG22XX_MAP40_3_X;
+            _gSelfIC_MAP40_4 = MSG22XX_MAP40_4_X;
+            _gSelfIC_MAP41_3 = MSG22XX_MAP41_3_X;
+            _gSelfIC_MAP41_4 = MSG22XX_MAP41_4_X;
+
+            _gSelfIC_SHORT_MAP4 = MSG22XX_SHORT_MAP4_X;
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+ 
+            _gSelfICItoTestKeyNum = MSG22XX_NUM_KEY_X;
+            _gSelfICItoTestDummyNum = MSG22XX_NUM_DUMMY_X;
+            _gSelfICItoTestTriangleNum = MSG22XX_NUM_SENSOR_X;
+            _gSelfICIsEnable2R = MSG22XX_ENABLE_2R_X;
+        }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+    }
+    else if (TP_TYPE_Y == nTpType) // Modify. 
+    {
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+        if (g_ChipType == CHIP_TYPE_MSG21XXA)   
+        {
+            _gMsg21xxaOpen1 = MSG21XXA_open_1_Y;
+            _gMsg21xxaOpen1B = MSG21XXA_open_1B_Y;
+            _gMsg21xxaOpen2 = MSG21XXA_open_2_Y;
+            _gMsg21xxaOpen2B = MSG21XXA_open_2B_Y;
+            _gMsg21xxaOpen3 = MSG21XXA_open_3_Y;
+
+            _gMsg21xxaShort_1 = MSG21XXA_short_1_Y;
+            _gMsg21xxaShort_2 = MSG21XXA_short_2_Y;
+            _gMsg21xxaShort_3 = MSG21XXA_short_3_Y;
+
+            _gMsg21xxaShort_1_GPO = MSG21XXA_short_1_Y_GPO;
+            _gMsg21xxaShort_2_GPO = MSG21XXA_short_2_Y_GPO;
+            _gMsg21xxaShort_3_GPO = MSG21XXA_short_3_Y_GPO;
+
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE       
+            _gMsg21xxaShort_4 = MSG21XXA_short_4_Y;
+            _gMsg21xxaShort_4_GPO = MSG21XXA_short_4_Y_GPO;
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+
+             _gSelfIC_MAP1 = MSG21XXA_MAP1_Y;
+             _gSelfIC_MAP2 = MSG21XXA_MAP2_Y;
+             _gSelfIC_MAP3 = MSG21XXA_MAP3_Y;
+             _gSelfIC_MAP40_1 = MSG21XXA_MAP40_1_Y;
+             _gSelfIC_MAP40_2 = MSG21XXA_MAP40_2_Y;
+             _gSelfIC_MAP41_1 = MSG21XXA_MAP41_1_Y;
+             _gSelfIC_MAP41_2 = MSG21XXA_MAP41_2_Y;
+
+             _gSelfIC_SHORT_MAP1 = MSG21XXA_SHORT_MAP1_Y;
+             _gSelfIC_SHORT_MAP2 = MSG21XXA_SHORT_MAP2_Y;
+             _gSelfIC_SHORT_MAP3 = MSG21XXA_SHORT_MAP3_Y;
+
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE       
+             _gSelfIC_MAP40_3 = MSG21XXA_MAP40_3_Y;
+             _gSelfIC_MAP40_4 = MSG21XXA_MAP40_4_Y;
+             _gSelfIC_MAP41_3 = MSG21XXA_MAP41_3_Y;
+             _gSelfIC_MAP41_4 = MSG21XXA_MAP41_4_Y;
+        
+             _gSelfIC_SHORT_MAP4 = MSG21XXA_SHORT_MAP4_Y;
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+
+             _gSelfICItoTestKeyNum = MSG21XXA_NUM_KEY_Y;
+             _gSelfICItoTestDummyNum = MSG21XXA_NUM_DUMMY_Y;
+             _gSelfICItoTestTriangleNum = MSG21XXA_NUM_SENSOR_Y;
+             _gSelfICIsEnable2R = MSG21XXA_ENABLE_2R_Y;
+        }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+        if (g_ChipType == CHIP_TYPE_MSG22XX)   
+        {
+             _gMsg22xxOpenRIU1 = MSG22XX_open_1_Y;
+             _gMsg22xxOpenRIU2 = MSG22XX_open_2_Y;
+             _gMsg22xxOpenRIU3 = MSG22XX_open_3_Y;
+
+             _gMsg22xxShort_RIU1 = MSG22XX_short_1_Y;
+             _gMsg22xxShort_RIU2 = MSG22XX_short_2_Y;
+             _gMsg22xxShort_RIU3 = MSG22XX_short_3_Y;
+
+             _gMsg22xxOpenSubFrameNum1 = MSG22XX_NUM_OPEN_1_SENSOR_Y;
+             _gMsg22xxOpenSubFrameNum2 = MSG22XX_NUM_OPEN_2_SENSOR_Y;
+             _gMsg22xxOpenSubFrameNum3 = MSG22XX_NUM_OPEN_3_SENSOR_Y;
+             _gMsg22xxShortSubFrameNum1 = MSG22XX_NUM_SHORT_1_SENSOR_Y;
+             _gMsg22xxShortSubFrameNum2 = MSG22XX_NUM_SHORT_2_SENSOR_Y;
+             _gMsg22xxShortSubFrameNum3 = MSG22XX_NUM_SHORT_3_SENSOR_Y;
+
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE       
+             _gMsg22xxShort_RIU4 = MSG22XX_short_4_Y;
+             _gMsg22xxShortSubFrameNum4 = MSG22XX_NUM_SHORT_4_SENSOR_Y;
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+
+             _gSelfIC_MAP1 = MSG22XX_MAP1_Y;
+             _gSelfIC_MAP2 = MSG22XX_MAP2_Y;
+             _gSelfIC_MAP3 = MSG22XX_MAP3_Y;
+             _gSelfIC_MAP40_1 = MSG22XX_MAP40_1_Y;
+             _gSelfIC_MAP40_2 = MSG22XX_MAP40_2_Y;
+             _gSelfIC_MAP41_1 = MSG22XX_MAP41_1_Y;
+             _gSelfIC_MAP41_2 = MSG22XX_MAP41_2_Y;
+
+             _gSelfIC_SHORT_MAP1 = MSG22XX_SHORT_MAP1_Y;
+             _gSelfIC_SHORT_MAP2 = MSG22XX_SHORT_MAP2_Y;
+             _gSelfIC_SHORT_MAP3 = MSG22XX_SHORT_MAP3_Y;
+
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE       
+             _gSelfIC_MAP40_3 = MSG22XX_MAP40_3_Y;
+             _gSelfIC_MAP40_4 = MSG22XX_MAP40_4_Y;
+             _gSelfIC_MAP41_3 = MSG22XX_MAP41_3_Y;
+             _gSelfIC_MAP41_4 = MSG22XX_MAP41_4_Y;
+        
+             _gSelfIC_SHORT_MAP4 = MSG22XX_SHORT_MAP4_Y;
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+
+             _gSelfICItoTestKeyNum = MSG22XX_NUM_KEY_Y;
+             _gSelfICItoTestDummyNum = MSG22XX_NUM_DUMMY_Y;
+             _gSelfICItoTestTriangleNum = MSG22XX_NUM_SENSOR_Y;
+             _gSelfICIsEnable2R = MSG22XX_ENABLE_2R_Y;
+        }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+    }
+    else
+    {
+        nTpType = 0;
+    }
+    
+    return nTpType;
+}
+
+static void _DrvMpTestItoTestSelfICAnaSwReset(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    RegSet16BitValue(0x1100, 0xFFFF); // reset ANA - analog
+
+    if (g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        RegSet16BitValueOn(0x130C, BIT1); // reset Filter - digital 
+    }
+    
+    RegSet16BitValue(0x1100, 0x0000);
+    mdelay(15);
+}
+
+static ItoTestResult_e _DrvMpTestItoOpenTestSelfICSecond(u8 nItemId)
+{
+    ItoTestResult_e nRetVal = ITO_TEST_OK;
+    u32 i;
+    s32 nTmpRawDataJg1 = 0;
+    s32 nTmpRawDataJg2 = 0;
+    s32 nTmpJgAvgThMax1 = 0;
+    s32 nTmpJgAvgThMin1 = 0;
+    s32 nTmpJgAvgThMax2 = 0;
+    s32 nTmpJgAvgThMin2 = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() nItemId = %d ***\n", __func__, nItemId);
+
+    if (nItemId == 40)    			
+    {
+        for (i = 0; i < (_gSelfICItoTestTriangleNum/2)-2; i ++)
+        {
+            nTmpRawDataJg1 += _gSelfICRawData1[_gSelfIC_MAP40_1[i]];
+        }
+
+        for (i = 0; i < 2; i ++)
+        {
+            nTmpRawDataJg2 += _gSelfICRawData1[_gSelfIC_MAP40_2[i]];
+        }
+    }
+    else if (nItemId == 41)    		
+    {
+        for (i = 0; i < (_gSelfICItoTestTriangleNum/2)-2; i ++)
+        {
+            nTmpRawDataJg1 += _gSelfICRawData2[_gSelfIC_MAP41_1[i]];
+        }
+		
+        for (i = 0; i < 2; i ++)
+        {
+            nTmpRawDataJg2 += _gSelfICRawData2[_gSelfIC_MAP41_2[i]];
+        }
+    }
+
+    nTmpJgAvgThMax1 = (nTmpRawDataJg1 / ((_gSelfICItoTestTriangleNum/2)-2)) * ( 100 + SELF_IC_OPEN_TEST_NON_BORDER_AREA_THRESHOLD) / 100;
+    nTmpJgAvgThMin1 = (nTmpRawDataJg1 / ((_gSelfICItoTestTriangleNum/2)-2)) * ( 100 - SELF_IC_OPEN_TEST_NON_BORDER_AREA_THRESHOLD) / 100;
+    nTmpJgAvgThMax2 = (nTmpRawDataJg2 / 2) * ( 100 + SELF_IC_OPEN_TEST_BORDER_AREA_THRESHOLD) / 100;
+    nTmpJgAvgThMin2 = (nTmpRawDataJg2 / 2 ) * ( 100 - SELF_IC_OPEN_TEST_BORDER_AREA_THRESHOLD) / 100;
+	
+    DBG(&g_I2cClient->dev, "nItemId = %d, nTmpRawDataJg1 = %d, nTmpJgAvgThMax1 = %d, nTmpJgAvgThMin1 = %d, nTmpRawDataJg2 = %d, nTmpJgAvgThMax2 = %d, nTmpJgAvgThMin2 = %d\n", nItemId, nTmpRawDataJg1, nTmpJgAvgThMax1, nTmpJgAvgThMin1, nTmpRawDataJg2, nTmpJgAvgThMax2, nTmpJgAvgThMin2);
+
+    if (nItemId == 40) 
+    {
+        for (i = 0; i < (_gSelfICItoTestTriangleNum/2)-2; i ++)
+        {
+            if (_gSelfICRawData1[_gSelfIC_MAP40_1[i]] > nTmpJgAvgThMax1 || _gSelfICRawData1[_gSelfIC_MAP40_1[i]] < nTmpJgAvgThMin1)
+            { 
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_MAP40_1[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        }
+		
+        for (i = 0; i < 2; i ++)
+        {
+            if (_gSelfICRawData1[_gSelfIC_MAP40_2[i]] > nTmpJgAvgThMax2 || _gSelfICRawData1[_gSelfIC_MAP40_2[i]] < nTmpJgAvgThMin2)
+            { 
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_MAP40_2[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        } 
+    }
+    else if (nItemId == 41) 
+    {
+        for (i = 0; i < (_gSelfICItoTestTriangleNum/2)-2; i ++)
+        {
+            if (_gSelfICRawData2[_gSelfIC_MAP41_1[i]] > nTmpJgAvgThMax1 || _gSelfICRawData2[_gSelfIC_MAP41_1[i]] < nTmpJgAvgThMin1) 
+            { 
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_MAP41_1[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        }
+        
+        for (i = 0; i < 2; i ++)
+        {
+            if (_gSelfICRawData2[_gSelfIC_MAP41_2[i]] > nTmpJgAvgThMax2 || _gSelfICRawData2[_gSelfIC_MAP41_2[i]] < nTmpJgAvgThMin2) 
+            { 
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_MAP41_2[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        }
+    }
+
+    return nRetVal;
+}
+
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+static ItoTestResult_e _DrvMpTestItoOpenTestSelfICSecond2r(u8 nItemId)
+{
+    ItoTestResult_e nRetVal = ITO_TEST_OK;
+    u32 i;
+    s32 nTmpRawDataJg1 = 0;
+    s32 nTmpRawDataJg2 = 0;
+    s32 nTmpRawDataJg3 = 0;
+    s32 nTmpRawDataJg4 = 0;
+    s32 nTmpJgAvgThMax1 = 0;
+    s32 nTmpJgAvgThMin1 = 0;
+    s32 nTmpJgAvgThMax2 = 0;
+    s32 nTmpJgAvgThMin2 = 0;
+    s32 nTmpJgAvgThMax3 = 0;
+    s32 nTmpJgAvgThMin3 = 0;
+    s32 nTmpJgAvgThMax4 = 0;
+    s32 nTmpJgAvgThMin4 = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() nItemId = %d ***\n", __func__, nItemId);
+
+    if (nItemId == 40)    			
+    {
+        for (i = 0; i < (_gSelfICItoTestTriangleNum/4)-2; i ++)
+        {
+            nTmpRawDataJg1 += _gSelfICRawData1[_gSelfIC_MAP40_1[i]];  //first region: non-border 
+        }
+		
+        for (i = 0; i < 2; i ++)
+        {
+            nTmpRawDataJg2 += _gSelfICRawData1[_gSelfIC_MAP40_2[i]];  //first region: border
+        }
+
+        for (i = 0; i < (_gSelfICItoTestTriangleNum/4)-2; i ++)
+        {
+            nTmpRawDataJg3 += _gSelfICRawData1[_gSelfIC_MAP40_3[i]];  //second region: non-border
+        }
+		
+        for (i = 0; i < 2; i ++)
+        {
+            nTmpRawDataJg4 += _gSelfICRawData1[_gSelfIC_MAP40_4[i]];  //second region: border
+        }
+    }
+    else if (nItemId == 41)    		
+    {
+        for (i = 0; i < (_gSelfICItoTestTriangleNum/4)-2; i ++)
+        {
+            nTmpRawDataJg1 += _gSelfICRawData2[_gSelfIC_MAP41_1[i]];  //first region: non-border
+        }
+		
+        for (i = 0; i < 2; i ++)
+        {
+            nTmpRawDataJg2 += _gSelfICRawData2[_gSelfIC_MAP41_2[i]];  //first region: border
+        }
+		
+        for (i = 0; i < (_gSelfICItoTestTriangleNum/4)-2; i ++)
+        {
+            nTmpRawDataJg3 += _gSelfICRawData2[_gSelfIC_MAP41_3[i]];  //second region: non-border
+        }
+		
+        for (i = 0; i < 2; i ++)
+        {
+            nTmpRawDataJg4 += _gSelfICRawData2[_gSelfIC_MAP41_4[i]];  //second region: border
+        }
+    }
+
+    nTmpJgAvgThMax1 = (nTmpRawDataJg1 / ((_gSelfICItoTestTriangleNum/4)-2)) * ( 100 + SELF_IC_OPEN_TEST_NON_BORDER_AREA_THRESHOLD) / 100;
+    nTmpJgAvgThMin1 = (nTmpRawDataJg1 / ((_gSelfICItoTestTriangleNum/4)-2)) * ( 100 - SELF_IC_OPEN_TEST_NON_BORDER_AREA_THRESHOLD) / 100;
+    nTmpJgAvgThMax2 = (nTmpRawDataJg2 / 2) * ( 100 + SELF_IC_OPEN_TEST_BORDER_AREA_THRESHOLD) / 100;
+    nTmpJgAvgThMin2 = (nTmpRawDataJg2 / 2) * ( 100 - SELF_IC_OPEN_TEST_BORDER_AREA_THRESHOLD) / 100;
+    nTmpJgAvgThMax3 = (nTmpRawDataJg3 / ((_gSelfICItoTestTriangleNum/4)-2)) * ( 100 + SELF_IC_OPEN_TEST_NON_BORDER_AREA_THRESHOLD) / 100;
+    nTmpJgAvgThMin3 = (nTmpRawDataJg3 / ((_gSelfICItoTestTriangleNum/4)-2)) * ( 100 - SELF_IC_OPEN_TEST_NON_BORDER_AREA_THRESHOLD) / 100;
+    nTmpJgAvgThMax4 = (nTmpRawDataJg4 / 2) * ( 100 + SELF_IC_OPEN_TEST_BORDER_AREA_THRESHOLD) / 100;
+    nTmpJgAvgThMin4 = (nTmpRawDataJg4 / 2) * ( 100 - SELF_IC_OPEN_TEST_BORDER_AREA_THRESHOLD) / 100;
+		
+    DBG(&g_I2cClient->dev, "nItemId = %d, nTmpRawDataJg1 = %d, nTmpJgAvgThMax1 = %d, nTmpJgAvgThMin1 = %d, nTmpRawDataJg2 = %d, nTmpJgAvgThMax2 = %d, nTmpJgAvgThMin2 = %d\n", nItemId, nTmpRawDataJg1, nTmpJgAvgThMax1, nTmpJgAvgThMin1, nTmpRawDataJg2, nTmpJgAvgThMax2, nTmpJgAvgThMin2);
+    DBG(&g_I2cClient->dev, "nTmpRawDataJg3 = %d, nTmpJgAvgThMax3 = %d, nTmpJgAvgThMin3 = %d, nTmpRawDataJg4 = %d, nTmpJgAvgThMax4 = %d, nTmpJgAvgThMin4 = %d\n", nTmpRawDataJg3, nTmpJgAvgThMax3, nTmpJgAvgThMin3, nTmpRawDataJg4, nTmpJgAvgThMax4, nTmpJgAvgThMin4);
+
+    if (nItemId == 40) 
+    {
+        for (i = 0; i < (_gSelfICItoTestTriangleNum/4)-2; i ++)
+        {
+            if (_gSelfICRawData1[_gSelfIC_MAP40_1[i]] > nTmpJgAvgThMax1 || _gSelfICRawData1[_gSelfIC_MAP40_1[i]] < nTmpJgAvgThMin1) 
+            {
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_MAP40_1[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        }
+		
+        for (i = 0; i < 2; i ++)
+        {
+            if (_gSelfICRawData1[_gSelfIC_MAP40_2[i]] > nTmpJgAvgThMax2 || _gSelfICRawData1[_gSelfIC_MAP40_2[i]] < nTmpJgAvgThMin2) 
+            {
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_MAP40_2[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        } 
+		
+        for (i = 0; i < (_gSelfICItoTestTriangleNum/4)-2; i ++)
+        {
+            if (_gSelfICRawData1[_gSelfIC_MAP40_3[i]] > nTmpJgAvgThMax3 || _gSelfICRawData1[_gSelfIC_MAP40_3[i]] < nTmpJgAvgThMin3) 
+            {
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_MAP40_3[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        }
+		
+        for (i = 0; i < 2; i ++)
+        {
+            if (_gSelfICRawData1[_gSelfIC_MAP40_4[i]] > nTmpJgAvgThMax4 || _gSelfICRawData1[_gSelfIC_MAP40_4[i]] < nTmpJgAvgThMin4) 
+            {
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_MAP40_4[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        } 
+    }
+    else if (nItemId == 41) 
+    {
+        for (i = 0; i < (_gSelfICItoTestTriangleNum/4)-2; i ++)
+        {
+            if (_gSelfICRawData2[_gSelfIC_MAP41_1[i]] > nTmpJgAvgThMax1 || _gSelfICRawData2[_gSelfIC_MAP41_1[i]] < nTmpJgAvgThMin1) 
+            {
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_MAP41_1[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        }
+		
+        for (i = 0; i < 2; i ++)
+        {
+            if (_gSelfICRawData2[_gSelfIC_MAP41_2[i]] > nTmpJgAvgThMax2 || _gSelfICRawData2[_gSelfIC_MAP41_2[i]] < nTmpJgAvgThMin2) 
+            {
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_MAP41_2[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        }
+		
+        for (i = 0; i < (_gSelfICItoTestTriangleNum/4)-2; i ++)
+        {
+            if (_gSelfICRawData2[_gSelfIC_MAP41_3[i]] > nTmpJgAvgThMax3 || _gSelfICRawData2[_gSelfIC_MAP41_3[i]] < nTmpJgAvgThMin3) 
+            {
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_MAP41_3[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        }
+		
+        for (i = 0; i < 2; i ++)
+        {
+            if (_gSelfICRawData2[_gSelfIC_MAP41_4[i]] > nTmpJgAvgThMax4 || _gSelfICRawData2[_gSelfIC_MAP41_4[i]] < nTmpJgAvgThMin4) 
+            {
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_MAP41_4[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        } 
+    }
+
+    return nRetVal;
+}
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+
+static ItoTestResult_e _DrvMpTestItoShortTestSelfICSecond(u8 nItemId)
+{
+    ItoTestResult_e nRetVal = ITO_TEST_OK;
+    u32 i;
+    u8 nSensorCount = 0;
+    u8 nNumOfSensorMapping1 = 0, nNumOfSensorMapping2 = 0;
+	
+    DBG(&g_I2cClient->dev, "*** %s() nItemId = %d ***\n", __func__, nItemId);
+
+    if (g_ChipType == CHIP_TYPE_MSG21XXA)
+    {
+        if ((_gSelfICItoTestTriangleNum + _gSelfICItoTestKeyNum + _gSelfICItoTestDummyNum) % 2 != 0)
+        {
+            nNumOfSensorMapping1 = (_gSelfICItoTestTriangleNum + _gSelfICItoTestKeyNum + _gSelfICItoTestDummyNum) / 2 + 1;
+            nNumOfSensorMapping2 = nNumOfSensorMapping1;
+        }
+        else
+        {
+            nNumOfSensorMapping1 = (_gSelfICItoTestTriangleNum + _gSelfICItoTestKeyNum + _gSelfICItoTestDummyNum) / 2;
+            nNumOfSensorMapping2 = nNumOfSensorMapping1;
+            if (nNumOfSensorMapping2 % 2 != 0)
+            {	
+                nNumOfSensorMapping2 ++;
+            }
+        }        
+    }
+
+    if (nItemId == 1) // 39-1
+    {
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+        if (g_ChipType == CHIP_TYPE_MSG21XXA)
+        {
+            nSensorCount = nNumOfSensorMapping1;
+        }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+        if (g_ChipType == CHIP_TYPE_MSG22XX)
+        {
+            nSensorCount = _gMsg22xxShortSubFrameNum1;
+        }        
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+        
+        for (i = 0; i < nSensorCount; i ++)
+        {
+            if (_gSelfICRawData1[_gSelfIC_SHORT_MAP1[i]] > SELF_IC_SHORT_TEST_THRESHOLD)
+            {
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_SHORT_MAP1[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        }
+    }
+    else if (nItemId == 2) // 39-2
+    {
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+        if (g_ChipType == CHIP_TYPE_MSG21XXA)
+        {
+            nSensorCount = nNumOfSensorMapping2;
+        }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+        if (g_ChipType == CHIP_TYPE_MSG22XX)
+        {
+            nSensorCount = _gMsg22xxShortSubFrameNum2;
+        }        
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+        
+        for (i = 0; i < nSensorCount; i ++)
+        {
+            if (_gSelfICRawData2[_gSelfIC_SHORT_MAP2[i]] > SELF_IC_SHORT_TEST_THRESHOLD)
+            {
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_SHORT_MAP2[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        }
+    }
+    else if (nItemId == 3) // 39-3
+    {
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+        if (g_ChipType == CHIP_TYPE_MSG21XXA)
+        {
+            nSensorCount = _gSelfICItoTestTriangleNum;
+        }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+        if (g_ChipType == CHIP_TYPE_MSG22XX)
+        {
+            nSensorCount = _gMsg22xxShortSubFrameNum3;
+        }      
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+      
+        for (i = 0; i < nSensorCount; i ++)
+        {
+            if (_gSelfICRawData3[_gSelfIC_SHORT_MAP3[i]] > SELF_IC_SHORT_TEST_THRESHOLD)
+            {
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_SHORT_MAP3[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        }
+    }
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+    else if (nItemId == 0) // 39-4 (2R)   
+    {
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+        if (g_ChipType == CHIP_TYPE_MSG21XXA)
+        {
+            nSensorCount = _gSelfICItoTestTriangleNum/2;
+        }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+        if (g_ChipType == CHIP_TYPE_MSG22XX)
+        {
+            nSensorCount = _gMsg22xxShortSubFrameNum4;
+        }        
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+        
+        for (i = 0; i < nSensorCount; i ++)
+        {
+            if (_gSelfICRawData4[_gSelfIC_SHORT_MAP4[i]] > SELF_IC_SHORT_TEST_THRESHOLD)
+            {
+                _gSelfICTestFailChannel[_gTestFailChannelCount] = _gSelfIC_SHORT_MAP4[i];
+                _gTestFailChannelCount ++; 
+                nRetVal = ITO_TEST_FAIL;
+            }
+        }
+    }
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+ 
+    DBG(&g_I2cClient->dev, "nSensorCount = %d\n", nSensorCount);
+
+    return nRetVal;
+}
+
+static ItoTestResult_e _DrvMpTestSelfICItoOpenTestEntry(void) 
+{
+    ItoTestResult_e nRetVal1 = ITO_TEST_OK, nRetVal2 = ITO_TEST_OK, nRetVal3 = ITO_TEST_OK;
+    u32 i;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    DBG(&g_I2cClient->dev, "open test start\n");
+
+    DrvPlatformLyrSetIicDataRate(g_I2cClient, 50000); //50 KHz
+  
+    DrvPlatformLyrDisableFingerTouchReport();
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+    if (!_DrvMpTestItoTestSelfICChooseTpType())
+    {
+        DBG(&g_I2cClient->dev, "Choose Tp Type failed\n");
+        nRetVal1 = ITO_TEST_GET_TP_TYPE_ERROR;
+        goto ITO_TEST_END;
+    }
+    
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop cpu
+    RegSet16BitValue(0x0FE6, 0x0001); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    mdelay(50);
+    
+    for (i = 0; i < SELF_IC_MAX_CHANNEL_NUM; i ++)
+    {
+        _gSelfICRawData1[i] = 0;
+        _gSelfICRawData2[i] = 0;
+        _gSelfICRawData3[i] = 0;
+        _gSelfICDataFlag1[i] = 0;
+        _gSelfICDataFlag2[i] = 0;
+        _gSelfICDataFlag3[i] = 0;
+        _gSelfICTestFailChannel[i] = 0;
+    }	
+	
+    _gTestFailChannelCount = 0; // Reset _gTestFailChannelCount to 0 before test start
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+    if (g_ChipType == CHIP_TYPE_MSG21XXA)
+    {
+        _DrvMpTestItoOpenTestMsg21xxaFirst(40, _gSelfICRawData1, _gSelfICDataFlag1);
+
+        if (_gSelfICIsEnable2R)
+        {
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+            nRetVal2 = _DrvMpTestItoOpenTestSelfICSecond2r(40);
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+        }
+        else
+        {
+            nRetVal2 = _DrvMpTestItoOpenTestSelfICSecond(40);
+        }
+    
+        _DrvMpTestItoOpenTestMsg21xxaFirst(41, _gSelfICRawData2, _gSelfICDataFlag2);
+
+        if (_gSelfICIsEnable2R)
+        {
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+            nRetVal3 = _DrvMpTestItoOpenTestSelfICSecond2r(41);
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+        }
+        else
+        {
+            nRetVal3 = _DrvMpTestItoOpenTestSelfICSecond(41);
+        }
+    }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+    if (g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        _DrvMpTestItoOpenTestMsg22xxFirst(40, _gSelfICRawData1, _gSelfICDataFlag1);
+
+        if (_gSelfICIsEnable2R)
+        {
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+            nRetVal2 = _DrvMpTestItoOpenTestSelfICSecond2r(40);
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+        }
+        else
+        {
+            nRetVal2 = _DrvMpTestItoOpenTestSelfICSecond(40);
+        }
+    
+        _DrvMpTestItoOpenTestMsg22xxFirst(41, _gSelfICRawData2, _gSelfICDataFlag2);
+
+        if (_gSelfICIsEnable2R)
+        {
+#ifdef CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+            nRetVal3 = _DrvMpTestItoOpenTestSelfICSecond2r(41);
+#endif //CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+        }
+        else
+        {
+            nRetVal3 = _DrvMpTestItoOpenTestSelfICSecond(41);
+        }
+    }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+ITO_TEST_END:
+
+    DrvPlatformLyrSetIicDataRate(g_I2cClient, 100000); //100 KHz
+    
+    DrvPlatformLyrTouchDeviceResetHw();
+    DrvPlatformLyrEnableFingerTouchReport();
+
+    DBG(&g_I2cClient->dev, "open test end\n");
+
+    if ((nRetVal1 != ITO_TEST_OK) && (nRetVal2 == ITO_TEST_OK) && (nRetVal3 == ITO_TEST_OK))
+    {
+        return ITO_TEST_GET_TP_TYPE_ERROR;		
+    }
+    else if ((nRetVal1 == ITO_TEST_OK) && ((nRetVal2 != ITO_TEST_OK) || (nRetVal3 != ITO_TEST_OK)))
+    {
+        return ITO_TEST_FAIL;	
+    }
+    else
+    {
+        return ITO_TEST_OK;	
+    }
+}
+
+static ItoTestResult_e _DrvMpTestSelfICItoShortTestEntry(void)
+{
+    ItoTestResult_e nRetVal1 = ITO_TEST_OK, nRetVal2 = ITO_TEST_OK, nRetVal3 = ITO_TEST_OK, nRetVal4 = ITO_TEST_OK, nRetVal5 = ITO_TEST_OK;
+    u32 i = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    DBG(&g_I2cClient->dev, "short test start\n");
+
+    DrvPlatformLyrSetIicDataRate(g_I2cClient, 50000); //50 KHz
+  
+    DrvPlatformLyrDisableFingerTouchReport();
+    DrvPlatformLyrTouchDeviceResetHw(); 
+    
+    if (!_DrvMpTestItoTestSelfICChooseTpType())
+    {
+        DBG(&g_I2cClient->dev, "Choose Tp Type failed\n");
+        nRetVal1 = ITO_TEST_GET_TP_TYPE_ERROR;
+        goto ITO_TEST_END;
+    }
+    
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop cpu
+    RegSet16BitValue(0x0FE6, 0x0001); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    mdelay(50);
+    
+    for (i = 0; i < SELF_IC_MAX_CHANNEL_NUM; i ++)
+    {
+        _gSelfICRawData1[i] = 0;
+        _gSelfICRawData2[i] = 0;
+        _gSelfICRawData3[i] = 0;
+        _gSelfICRawData4[i] = 0;
+        _gSelfICDataFlag1[i] = 0;
+        _gSelfICDataFlag2[i] = 0;
+        _gSelfICDataFlag3[i] = 0;
+        _gSelfICDataFlag4[i] = 0;
+        _gSelfICTestFailChannel[i] = 0;
+    }	
+	
+    _gTestFailChannelCount = 0; // Reset _gTestFailChannelCount to 0 before test start
+	
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+    if (g_ChipType == CHIP_TYPE_MSG21XXA)
+    {
+        if (_gSelfICIsEnable2R)
+        {
+            _DrvMpTestItoShortTestMsg21xxaFirst(0, _gSelfICRawData4, _gSelfICDataFlag4);
+            nRetVal2 = _DrvMpTestItoShortTestSelfICSecond(0);
+        }
+
+        _DrvMpTestItoShortTestMsg21xxaFirst(1, _gSelfICRawData1, _gSelfICDataFlag1);
+        nRetVal3 = _DrvMpTestItoShortTestSelfICSecond(1);
+
+        _DrvMpTestItoShortTestMsg21xxaFirst(2, _gSelfICRawData2, _gSelfICDataFlag2);
+        nRetVal4 = _DrvMpTestItoShortTestSelfICSecond(2);
+
+        _DrvMpTestItoShortTestMsg21xxaFirst(3, _gSelfICRawData3, _gSelfICDataFlag3);
+        nRetVal5 = _DrvMpTestItoShortTestSelfICSecond(3);
+    }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+    if (g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        if (_gSelfICIsEnable2R)
+        {
+            _DrvMpTestItoShortTestMsg22xxFirst(0, _gSelfICRawData4, _gSelfICDataFlag4);
+            nRetVal2 = _DrvMpTestItoShortTestSelfICSecond(0);
+        }
+
+        _DrvMpTestItoShortTestMsg22xxFirst(1, _gSelfICRawData1, _gSelfICDataFlag1);
+        nRetVal3 = _DrvMpTestItoShortTestSelfICSecond(1);
+
+        _DrvMpTestItoShortTestMsg22xxFirst(2, _gSelfICRawData2, _gSelfICDataFlag2);
+        nRetVal4 = _DrvMpTestItoShortTestSelfICSecond(2);
+
+        _DrvMpTestItoShortTestMsg22xxFirst(3, _gSelfICRawData3, _gSelfICDataFlag3);
+        nRetVal5 = _DrvMpTestItoShortTestSelfICSecond(3);
+    }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+ITO_TEST_END:
+
+    DrvPlatformLyrSetIicDataRate(g_I2cClient, 100000); //100 KHz
+    
+    DrvPlatformLyrTouchDeviceResetHw();
+    DrvPlatformLyrEnableFingerTouchReport();
+
+    DBG(&g_I2cClient->dev, "short test end\n");
+    
+    if ((nRetVal1 != ITO_TEST_OK) && (nRetVal2 == ITO_TEST_OK) && (nRetVal3 == ITO_TEST_OK) && (nRetVal4 == ITO_TEST_OK) && (nRetVal5 == ITO_TEST_OK))
+    {
+        return ITO_TEST_GET_TP_TYPE_ERROR;		
+    }
+    else if ((nRetVal1 == ITO_TEST_OK) && ((nRetVal2 != ITO_TEST_OK) || (nRetVal3 != ITO_TEST_OK) || (nRetVal4 != ITO_TEST_OK) || (nRetVal5 != ITO_TEST_OK)))
+    {
+        return ITO_TEST_FAIL;
+    }
+    else
+    {
+        return ITO_TEST_OK;	
+    }
+}
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA || CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+static void _DrvMpTestItoTestMsg26xxmSetToNormalMode(void)
+{
+    u16 nRegData = 0;
+    u16 nTmpAddr = 0, nAddr = 0;
+    u16 nDriveNumGeg = 0, nSenseNumGeg = 0;
+    u16 i = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    RegSet16BitValue(0x0FE6, 0x0001); 
+
+    nRegData = RegGet16BitValue(0x110E); 
+    
+    if (nRegData == 0x1D08)
+    {
+        DBG(&g_I2cClient->dev, "Wrong mode 0\n");
+    }
+    
+    nRegData &= 0x0800;
+    
+    if (nRegData > 1)
+    {
+        DBG(&g_I2cClient->dev, "Wrong mode\n");
+    }
+    
+    RegSet16BitValueOff(0x110E, 0x0800); 
+    RegSet16BitValueOn(0x1116, 0x0005); 
+    RegSet16BitValueOn(0x114A, 0x0001); 
+
+    for (i = 0; i < 7; i ++)
+    {
+        nTmpAddr = 0x3C + i;	
+        nTmpAddr = nTmpAddr * 2;
+        nAddr = (0x11 << 8) | nTmpAddr;
+        RegSet16BitValue(nAddr, MSG26XXM_open_ANA1_N_X[i]); 
+    }
+    
+    RegSet16BitValue(0x1E66, 0x0000); 
+    RegSet16BitValue(0x1E67, 0x0000); 
+    RegSet16BitValue(0x1E68, 0x0000); 
+    RegSet16BitValue(0x1E69, 0x0000); 
+    RegSet16BitValue(0x1E6A, 0x0000); 
+    RegSet16BitValue(0x1E6B, 0x0000); 
+    
+    for (i = 0; i < 21; i ++)
+    {
+        nTmpAddr = 3 + i;	
+        nTmpAddr = nTmpAddr * 2;
+        nAddr = (0x10 << 8) | nTmpAddr;
+        RegSet16BitValue(nAddr, MSG26XXM_open_ANA3_N_X[i]); 
+    }
+    
+    nDriveNumGeg = ((MSG26XXM_DRIVE_NUM - 1) << 8 & 0xFF00);
+    nSenseNumGeg = (MSG26XXM_SENSE_NUM & 0x00FF);
+    
+    RegSet16BitValue(0x1216, nDriveNumGeg); 
+    RegSet16BitValue(0x102E, nSenseNumGeg); 
+
+    RegSet16BitValue(0x0FE6, 0x0001); 
+
+    DBG(&g_I2cClient->dev, "Wrong mode correction\n");
+}
+
+/*
+static void _DrvMpTestItoTestMsg26xxmSetToWaterProofMode(void)
+{
+    u16 nTmpAddr = 0, nAddr = 0;
+    u16 i = 0;
+    u16 nCsubWPdata = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nCsubWPdata = (WATERPROOF_CSUB_REF << 8) | WATERPROOF_CSUB_REF;
+
+    for (i = 0; i < 7; i ++)
+    {
+        nTmpAddr = 0x3C + i;
+        nTmpAddr = nTmpAddr * 2;
+        nAddr = (0x11 << 8) | nTmpAddr;
+        RegSet16BitValue(nAddr, MSG26XXM_WATERPROOF_ANA1_N_X[i]);
+    }
+
+    for (i = 0; i < 21; i ++)
+    {
+        nTmpAddr = 3 + i;
+        nTmpAddr = nTmpAddr * 2;
+        nAddr = (0x10 << 8) | nTmpAddr;
+        RegSet16BitValue(nAddr, MSG26XXM_WATERPROOF_ANA3_N_X[i]);
+    }
+
+    // ana2 write
+    RegSet16BitValue(0x1216, 0x0000);
+
+    for (i = 0; i < 6; i ++)
+    {
+        nTmpAddr = 0x20 + i;
+        nTmpAddr = nTmpAddr * 2;
+        nAddr = (0x10 << 8) | nTmpAddr;
+        RegSet16BitValue(nAddr, nCsubWPdata);
+    }
+
+    RegSet16BitValueOn(0x1116, 0x0005);
+    RegSet16BitValueOn(0x114A, 0x0001);
+    RegSet16BitValue(0x1208, 0x0002);
+
+    DBG(&g_I2cClient->dev, "WaterProof : Wrong mode correction\n");
+}
+*/
+
+static void _DrvMpTestItoTestMsg26xxmMcuStop(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    RegSet16BitValue(0x0FE6, 0x0001); //bank:mheg5, addr:h0073
+}
+
+static void _DrvMpTestItoTestMsg26xxmAnaSwitchToMutual(void)
+{
+    u16 nTemp = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nTemp = RegGet16BitValue(0x114A); //bank:ana, addr:h0025
+    nTemp |= BIT0;
+    RegSet16BitValue(0x114A, nTemp);
+    nTemp = RegGet16BitValue(0x1116); //bank:ana, addr:h000b
+    nTemp |= (BIT2 | BIT0);
+    RegSet16BitValue(0x1116, nTemp);
+}
+
+static u16 _DrvMpTestItoTestMsg26xxmAnaGetMutualChannelNum(void)
+{
+    u16 nSenseLineNum = 0;
+    u16 nRegData = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nRegData = RegGet16BitValue(0x102E); //bank:ana3, addr:h0017
+    nSenseLineNum = nRegData & 0x000F;
+
+    DBG(&g_I2cClient->dev, "nSenseLineNum = %d\n", nSenseLineNum);
+
+    return nSenseLineNum;
+}
+
+static u16 _DrvMpTestItoTestMsg26xxmAnaGetMutualSubFrameNum(void)
+{
+    u16 nDriveLineNum = 0;
+    u16 nRegData = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nRegData = RegGet16BitValue(0x1216); //bank:ana2, addr:h000b
+    nDriveLineNum = ((nRegData & 0xFF00) >> 8) + 1; //Since we only retrieve 8th~12th bit of reg_m_sf_num, 0xFF00 shall be changed to 0x1F00. 
+
+    DBG(&g_I2cClient->dev, "nDriveLineNum = %d\n", nDriveLineNum);
+
+    return nDriveLineNum;
+}
+
+/*
+static void _DrvMpTestItoOpenTestMsg26xxmAnaGetMutualCSub(u8 *pMode)
+{
+    u16 i, j;
+    u16 nSenseLineNum;
+    u16 nDriveLineNum;
+    u16 nTotalNum;
+    u8 szDataAna4[3];    
+    u8 szDataAna3[3];    
+    u8 szDataAna41[MSG26XXM_ANA4_MUTUAL_CSUB_NUMBER]; //200 = 392 - 192  
+    u8 szDataAna31[MSG26XXM_ANA3_MUTUAL_CSUB_NUMBER]; //192 = 14 * 13 + 10   
+    u8 szModeTemp[MUTUAL_IC_MAX_MUTUAL_NUM];
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nTotalNum = MUTUAL_IC_MAX_MUTUAL_NUM;
+
+    nSenseLineNum = _DrvMpTestItoTestMsg26xxmAnaGetMutualChannelNum();
+    nDriveLineNum = _DrvMpTestItoTestMsg26xxmAnaGetMutualSubFrameNum();
+
+    if (MSG26XXM_ANA4_MUTUAL_CSUB_NUMBER > 0)
+    {
+        mdelay(100);
+        for (i = 0; i < MSG26XXM_ANA4_MUTUAL_CSUB_NUMBER; i ++)
+        {	
+            szDataAna41[i] = 0;
+        }
+
+        szDataAna4[0] = 0x10;
+        szDataAna4[1] = 0x15; //bank:ana4, addr:h0000
+        szDataAna4[2] = 0x00;
+        
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDataAna4[0], 3);
+        IicReadData(SLAVE_I2C_ID_DBBUS, &szDataAna41[0], MSG26XXM_ANA4_MUTUAL_CSUB_NUMBER); //200
+
+        nTotalNum -= (u16)MSG26XXM_ANA4_MUTUAL_CSUB_NUMBER;
+    }
+
+    for (i = 0; i < nTotalNum; i ++)
+    {
+        szDataAna31[i] = 0;
+    }
+
+    mdelay(100);
+
+    szDataAna3[0] = 0x10;
+    szDataAna3[1] = 0x10; //bank:ana3, addr:h0020
+    szDataAna3[2] = 0x40;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDataAna3[0], 3);
+    IicReadData(SLAVE_I2C_ID_DBBUS, &szDataAna31[0], MSG26XXM_ANA3_MUTUAL_CSUB_NUMBER); //192
+
+    for (i = 0; i < MSG26XXM_ANA3_MUTUAL_CSUB_NUMBER; i ++)
+    {
+        szModeTemp[i] = szDataAna31[i];
+    }
+
+    for (i = MSG26XXM_ANA3_MUTUAL_CSUB_NUMBER; i < (MSG26XXM_ANA3_MUTUAL_CSUB_NUMBER + MSG26XXM_ANA4_MUTUAL_CSUB_NUMBER); i ++)
+    {
+        szModeTemp[i] = szDataAna41[i - MSG26XXM_ANA3_MUTUAL_CSUB_NUMBER];
+    }
+    
+    for (i = 0; i < nDriveLineNum; i ++)
+    {
+        for (j = 0; j < nSenseLineNum; j ++)
+        {
+            _gMutualICMode[j * nDriveLineNum + i] = szModeTemp[i * MUTUAL_IC_MAX_CHANNEL_SEN + j];
+
+//            DBG(&g_I2cClient->dev, "_gMutualICMode[%d] = %d\n", j * nDriveLineNum + i, _gMutualICMode[j * nDriveLineNum + i]);
+        }
+    }
+}
+*/
+
+static void _DrvMpTestItoOpenTestMsg26xxmAnaSetMutualCSub(u16 nCSub)
+{
+    u16 i = 0;
+    u8 szDbBusTxData[256] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x15; //bank:ana4, addr:h0000
+    szDbBusTxData[2] = 0x00;
+
+    for (i = 3; i < (3+MSG26XXM_ANA4_MUTUAL_CSUB_NUMBER); i ++)
+    {
+        szDbBusTxData[i] = (u8)nCSub;             
+    }
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+MSG26XXM_ANA4_MUTUAL_CSUB_NUMBER);
+
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x10; //bank:ana3, addr:h0020
+    szDbBusTxData[2] = 0x40;
+
+    for (i = 3; i < (3+MSG26XXM_ANA3_MUTUAL_CSUB_NUMBER); i ++)
+    {
+        szDbBusTxData[i] = (u8)nCSub;             
+    }
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+MSG26XXM_ANA3_MUTUAL_CSUB_NUMBER);	
+}
+
+static void _DrvMpTestItoTestMsg26xxmDisableFilterNoiseDetect(void)
+{
+    u16 nTemp = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nTemp = RegGet16BitValue(0x1302); //bank:fir, addr:h0001
+    nTemp &= (~(BIT2 | BIT1 | BIT0));
+    RegSet16BitValue(0x1302, nTemp);
+}
+
+static void _DrvMpTestItoTestMsg26xxmAnaSwReset(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    RegSet16BitValue(0x1100, 0xFFFF); //bank:ana, addr:h0000
+    RegSet16BitValue(0x1100, 0x0000);
+    mdelay(100);
+}
+
+static void _DrvMpTestItoTestMsg26xxmEnableAdcOneShot(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    RegSet16BitValue(0x130C, BIT15); //bank:fir, addr:h0006
+    RegSet16BitValue(0x1214, 0x0031);
+}
+
+static void _DrvMpTestItoTestMsg26xxmGetMutualOneShotRawIir(u16 wszResultData[][MUTUAL_IC_MAX_CHANNEL_DRV], u16 nDriveLineNum, u16 nSenseLineNum)
+{
+    u16 nRegData;
+    u16 i, j;
+    u16 nTemp;
+    u16 nReadSize;
+    u8 szDbBusTxData[3];
+    u8 szShotData1[MSG26XXM_FILTER1_MUTUAL_DELTA_C_NUMBER]; //190 = (6 * 14 + 11) * 2
+    u8 szShotData2[MSG26XXM_FILTER2_MUTUAL_DELTA_C_NUMBER]; //594 = (MUTUAL_IC_MAX_MUTUAL_NUM - (6 * 14 + 11)) * 2
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nTemp = RegGet16BitValue(0x3D08); //bank:intr_ctrl, addr:h0004
+    nTemp &= (~(BIT8 | BIT4));
+    RegSet16BitValue(0x3D08, nTemp);
+
+    _DrvMpTestItoTestMsg26xxmEnableAdcOneShot();
+    
+    nRegData = 0;
+    while (0x0000 == (nRegData & BIT8))
+    {
+        nRegData = RegGet16BitValue(0x3D18); //bank:intr_ctrl, addr:h000c
+    }
+
+    for (i = 0; i < MSG26XXM_FILTER1_MUTUAL_DELTA_C_NUMBER; i ++)
+    {
+        szShotData1[i] = 0;
+    }
+    
+    for (i = 0; i < MSG26XXM_FILTER2_MUTUAL_DELTA_C_NUMBER; i ++)
+    {
+        szShotData2[i] = 0;
+    }
+
+    mdelay(100);
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x13; //bank:fir, addr:h0021
+    szDbBusTxData[2] = 0x42;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);
+    IicReadData(SLAVE_I2C_ID_DBBUS, &szShotData1[0], MSG26XXM_FILTER1_MUTUAL_DELTA_C_NUMBER); //190
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    mdelay(100);
+    nReadSize = IicSegmentReadDataByDbBus(0x20, 0x00, &szShotData2[0], MSG26XXM_FILTER2_MUTUAL_DELTA_C_NUMBER, MAX_I2C_TRANSACTION_LENGTH_LIMIT); //594
+    DBG(&g_I2cClient->dev, "*** nReadSize = %d ***\n", nReadSize); // add for debug
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+    mdelay(100);
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x20; //bank:fir2, addr:h0000
+    szDbBusTxData[2] = 0x00;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);
+    IicReadData(SLAVE_I2C_ID_DBBUS, &szShotData2[0], MSG26XXM_FILTER2_MUTUAL_DELTA_C_NUMBER); //594
+#endif
+
+    for (j = 0; j < nDriveLineNum; j ++)
+    {
+        for (i = 0; i < nSenseLineNum; i ++)
+        {
+            // FILTER1 : SF0~SF5, AFE0~AFE13; SF6, AFE0~AFE10
+            if ((j <= 5) || ((j == 6) && (i <= 10)))
+            {
+                nRegData = (u16)(szShotData1[(j * 14 + i) * 2] | szShotData1[(j * 14 + i) * 2 + 1] << 8);
+                wszResultData[i][ j] = (short)nRegData;
+            }
+            else
+            {
+                // FILTER2 : SF6, AFE11~AFE13
+                if ((j == 6) && (i > 10))
+                {
+                    nRegData = (u16)(szShotData2[((j - 6) * 14 + (i - 11)) * 2] | szShotData2[((j - 6) * 14 + (i - 11)) * 2 + 1] << 8);
+                    wszResultData[i][j] = (short)nRegData;
+                }
+                else
+                {
+                    nRegData = (u16)(szShotData2[6 + ((j - 7) * 14 + i) * 2] | szShotData2[6 + ((j - 7) * 14 + i) * 2 + 1] << 8);
+                    wszResultData[i][j] = (short)nRegData;
+                }
+            }
+        }
+    }
+
+    nTemp = RegGet16BitValue(0x3D08); //bank:intr_ctrl, addr:h0004
+    nTemp |= (BIT8 | BIT4);
+    RegSet16BitValue(0x3D08, nTemp);
+}
+
+static void _DrvMpTestItoTestMsg26xxmGetDeltaC(s32 *pTarget)
+{
+    s16 nTemp;
+    u16 wszRawData[MUTUAL_IC_MAX_CHANNEL_SEN][MUTUAL_IC_MAX_CHANNEL_DRV];
+    u16 i, j;
+    u16 nDriveLineNum = 0, nSenseLineNum = 0, nShift = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nSenseLineNum = _DrvMpTestItoTestMsg26xxmAnaGetMutualChannelNum();
+    nDriveLineNum = _DrvMpTestItoTestMsg26xxmAnaGetMutualSubFrameNum();
+
+    _DrvMpTestItoTestMsg26xxmGetMutualOneShotRawIir(wszRawData, nDriveLineNum, nSenseLineNum);
+
+    for (i = 0; i < nSenseLineNum; i ++)
+    {
+        for (j = 0; j < nDriveLineNum; j ++)
+        {
+            nShift = (u16)(i * nDriveLineNum + j);
+            nTemp = (s16)wszRawData[i][j];
+            pTarget[nShift] = nTemp;
+
+//            DBG(&g_I2cClient->dev, "wszRawData[%d][%d] = %d\n", i, j, nTemp);
+        }
+    }
+}
+
+static s32 _DrvMpTestItoTestMsg26xxmReadTrunkFwVersion(u32* pVersion)
+{
+    u16 nMajor = 0;
+    u16 nMinor = 0;
+    u8 szDbBusTxData[3] = {0};
+    u8 szDbBusRxData[4] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    szDbBusTxData[0] = 0x53;
+    szDbBusTxData[1] = 0x00;
+    szDbBusTxData[2] = 0x24;
+
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+    IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+    DBG(&g_I2cClient->dev, "szDbBusRxData[0] = 0x%x\n", szDbBusRxData[0]); // add for debug
+    DBG(&g_I2cClient->dev, "szDbBusRxData[1] = 0x%x\n", szDbBusRxData[1]); // add for debug
+    DBG(&g_I2cClient->dev, "szDbBusRxData[2] = 0x%x\n", szDbBusRxData[2]); // add for debug
+    DBG(&g_I2cClient->dev, "szDbBusRxData[3] = 0x%x\n", szDbBusRxData[3]); // add for debug
+
+    nMajor = (szDbBusRxData[1]<<8) + szDbBusRxData[0];
+    nMinor = (szDbBusRxData[3]<<8) + szDbBusRxData[2];
+
+    DBG(&g_I2cClient->dev, "*** major = %x ***\n", nMajor);
+    DBG(&g_I2cClient->dev, "*** minor = %x ***\n", nMinor);
+
+    *pVersion = (nMajor << 16) + nMinor;
+
+    return 0;
+}
+
+static s32 _DrvMpTestItoTestMsg26xxmGetSwitchFlag(void)
+{
+    u32 nFwVersion = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (_DrvMpTestItoTestMsg26xxmReadTrunkFwVersion(&nFwVersion) < 0)
+    {
+        _gMutualICTestSwitchMode = 0;
+        return 0;
+    }
+
+    if (nFwVersion >= 0x10030000)
+    {
+        _gMutualICTestSwitchMode = 1;
+    }
+    else
+    {
+        _gMutualICTestSwitchMode = 0;
+    }
+
+    return 0;
+}
+
+static s32 _DrvMpTestItoTestMsg26xxmCheckSwitchStatus(void)
+{
+    u32 nRegData = 0;
+    int nTimeOut = 100;
+    int nCount = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+        mdelay(20);
+        nCount ++;
+        if (nCount > nTimeOut)
+        {
+            return -1;
+        }
+        DBG(&g_I2cClient->dev, "*** %s() nRegData:%x***\n", __func__ , nRegData);
+
+    } while (nRegData != 0x7447);
+
+    return 0;
+}
+
+static s32 _DrvMpTestItoTestMsg26xxmSwitchFwMode(u8 nFWMode)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    RegSet16BitValue(0x0FE6, 0x0001);    //MCU_stop
+    mdelay(150);
+
+    RegSet16BitValue(0X3C60, 0xAA55);    // disable watch dog
+
+    RegSet16BitValue(0X3D08, 0xFFFF);
+    RegSet16BitValue(0X3D18, 0xFFFF);
+
+    RegSet16BitValue(0x3CE4, 0x7474);
+
+    //RegSet16BitValue(0x1E04, 0x7D60);
+    RegSet16BitValue(0x1E04, 0x829F);
+    RegSet16BitValue(0x0FE6, 0x0000);
+    mdelay(150);
+
+    if (_DrvMpTestItoTestMsg26xxmCheckSwitchStatus() < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg26xx MP Test# CheckSwitchStatus failed! ***\n");
+        return -1;
+    }
+
+    switch (nFWMode)
+    {
+        case MUTUAL:
+            RegSet16BitValue(0x3CE4, 0x5705);
+            break;
+
+        case SELF:
+            RegSet16BitValue(0x3CE4, 0x6278);
+            break;
+
+        case WATERPROOF:
+            RegSet16BitValue(0x3CE4, 0x7992);
+            DBG(&g_I2cClient->dev, "*** Msg26xx MP Test# WATERPROOF mode***\n");
+            break;
+
+        default:
+            return -1;
+    }
+    if (_DrvMpTestItoTestMsg26xxmCheckSwitchStatus() < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg26xx MP Test# CheckSwitchStatus failed! ***\n");
+        return -1;
+    }
+
+    RegSet16BitValue(0x0FE6, 0x0001);// stop mcu
+    RegSet16BitValue(0x3D08, 0xFEFF);//open timer
+
+    return 0;
+}
+
+static s32 _DrvMpTestItoTestMsg26xxmSwitchMode(u8 nSwitchMode, u8 nFMode)
+{
+    if (_gMutualICTestSwitchMode != 0)
+    {
+        if (_DrvMpTestItoTestMsg26xxmSwitchFwMode(nFMode) < 0)
+        {
+            if (nFMode == MUTUAL)
+            {
+                _DrvMpTestItoTestMsg26xxmSetToNormalMode();
+            }
+            else
+            {
+                //_DrvMpTestItoTestMsg26xxmSetToWaterProofMode();
+                DBG(&g_I2cClient->dev, "*** Msg26xx MP Test# _DrvMpTestItoTestMsg26xxmSwitchMode failed! ***\n");
+                return -1;
+            }
+        }
+    }
+    else
+    {
+        if (nFMode == MUTUAL)
+        {
+            _DrvMpTestItoTestMsg26xxmSetToNormalMode();
+        }
+        else
+        {
+            //_DrvMpTestItoTestMsg26xxmSetToWaterProofMode();
+            DBG(&g_I2cClient->dev, "*** Msg26xx MP Test# _DrvMpTestItoTestMsg26xxmSwitchMode failed! ***\n");
+            return -1;
+        }
+    }
+    
+    return 0;
+}
+
+static s32 _DrvMpTestMsg26xxmItoOpenTestEntry(void)
+{
+    s32 nRetVal = 0;
+    s32 nPrev = 0, nDelta = 0;
+    u16 i = 0, j = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    DrvPlatformLyrDisableFingerTouchReport();
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    //auto detetc fw version to decide switch fw mode
+    if (_gMutualICTestAutoSwitchFlag != 0)
+    {
+        _DrvMpTestItoTestMsg26xxmGetSwitchFlag();
+    }
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    _DrvMpTestItoTestMsg26xxmSwitchMode(_gMutualICTestSwitchMode, MUTUAL);
+
+    _DrvMpTestItoTestMsg26xxmMcuStop();
+    mdelay(10);
+
+    for (i = 0; i < MUTUAL_IC_MAX_MUTUAL_NUM; i ++)
+    {
+        _gMutualICTestFailChannel[i] = 0;
+    }	
+
+    _gTestFailChannelCount = 0; // Reset _gTestFailChannelCount to 0 before test start
+
+    _gMutualICSenseLineNum = _DrvMpTestItoTestMsg26xxmAnaGetMutualChannelNum();
+    _gMutualICDriveLineNum = _DrvMpTestItoTestMsg26xxmAnaGetMutualSubFrameNum();
+
+    _DrvMpTestItoOpenTestMsg26xxmAnaSetMutualCSub(MSG26XXM_OPEN_CSUB_REF_X);
+
+    _DrvMpTestItoTestMsg26xxmDisableFilterNoiseDetect();
+    
+    // Set charge&dump time 
+    RegSet16BitValue(0x1224, 0xFFC0);
+    RegSet16BitValue(0x122A, 0x0C0A);
+
+    _DrvMpTestItoTestMsg26xxmAnaSwReset();
+    _DrvMpTestItoTestMsg26xxmGetDeltaC(_gMutualICDeltaC); 
+    
+    for (i = 0; i < _gMutualICSenseLineNum; i ++)
+    {
+        DBG(&g_I2cClient->dev, "\nSense[%02d]\t", i);
+        
+        for (j = 0; j < _gMutualICDriveLineNum; j ++)
+        {
+            _gMutualICResult[i * _gMutualICDriveLineNum + j] = (4464*MSG26XXM_OPEN_CSUB_REF_X - _gMutualICDeltaC[i * _gMutualICDriveLineNum + j]);
+            DBG(&g_I2cClient->dev, "%d  %d  %d\t", _gMutualICResult[i * _gMutualICDriveLineNum + j], 4464*MSG26XXM_OPEN_CSUB_REF_X, _gMutualICDeltaC[i * _gMutualICDriveLineNum + j]);
+        }
+    }
+    
+    DBG(&g_I2cClient->dev, "\n\n\n");
+
+//    for (j = 0; j < _gMutualICDriveLineNum; j ++)
+    for (j = 0; j < (_gMutualICDriveLineNum-1); j ++)
+    {
+        for (i = 0; i < _gMutualICSenseLineNum; i ++)
+        {
+            if (_gMutualICResult[i * _gMutualICDriveLineNum + j] < MSG26XXM_FIR_THRESHOLD)
+            {
+                _gMutualICTestFailChannel[i * _gMutualICDriveLineNum + j] = 1;
+                _gTestFailChannelCount ++; 
+                nRetVal = -1;
+                DBG(&g_I2cClient->dev, "\nSense%d, Drive%d, MIN_Threshold = %d\t", i, j, _gMutualICResult[i * _gMutualICDriveLineNum + j]);
+            }
+
+            if (i > 0)
+            {
+                nDelta = _gMutualICResult[i * _gMutualICDriveLineNum + j] > nPrev ? (_gMutualICResult[i * _gMutualICDriveLineNum + j] - nPrev) : (nPrev - _gMutualICResult[i * _gMutualICDriveLineNum + j]);
+                if (nDelta > nPrev*MUTUAL_IC_FIR_RATIO/100)
+                {
+                    if (0 == _gMutualICTestFailChannel[i * _gMutualICDriveLineNum + j]) // for avoid _gTestFailChannelCount to be added twice
+                    {
+                        _gMutualICTestFailChannel[i * _gMutualICDriveLineNum + j] = 1;
+                        _gTestFailChannelCount ++; 
+                    }
+                    nRetVal = -1;
+                    DBG(&g_I2cClient->dev, "\nSense%d, Drive%d, MAX_Ratio = %d,%d\t", i, j, nDelta, nPrev);
+                }
+            }
+            nPrev = _gMutualICResult[i * _gMutualICDriveLineNum + j];
+        }
+    }
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+    
+    DrvPlatformLyrTouchDeviceResetHw();
+    mdelay(300);
+
+    DrvPlatformLyrEnableFingerTouchReport();
+
+    return nRetVal;
+}
+
+static void _DrvMpTestItoTestMsg26xxmSendDataIn(u16 nAddr, u16 nLength, u16 *data)
+{
+    u8 szDbBusTxData[256] = {0};
+    int i = 0;
+
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = (nAddr >> 8) & 0xFF;
+    szDbBusTxData[2] = (nAddr & 0xFF);
+
+    for (i = 0; i <= nLength ; i ++)
+    {
+        szDbBusTxData[3+2*i] = (data[i] & 0xFF);
+        szDbBusTxData[4+2*i] = (data[i] >> 8) & 0xFF;
+    }
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+nLength*2);
+}
+
+static void _DrvMpTestItoShortTestMsg26xxmSetPAD2GPO(u8 nItemID)
+{
+    u16 gpioSetting[MUTUAL_IC_MAX_CHANNEL_NUM] = {0};
+    u16 gpioEnabling[MUTUAL_IC_MAX_CHANNEL_NUM] = {0};
+    u16 gpioZero[MUTUAL_IC_MAX_CHANNEL_NUM] = {0};
+    u8 	gpioNum = 0;
+    u16 *gpioPIN = NULL;
+    int i = 0;
+    int j = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (nItemID == 1)
+    {
+        gpioNum = SHORT_N1_GPO_NUMBER_X;
+        gpioPIN = kzalloc(sizeof(u16) * gpioNum, GFP_KERNEL);
+
+        for (i = 0; i <	gpioNum; i++)
+        {
+            gpioPIN[i] = SHORT_N1_GPO_PIN_X[i];
+        }
+    }
+    else if (nItemID == 2)
+    {
+        gpioNum = SHORT_N2_GPO_NUMBER_X;
+        gpioPIN = kzalloc(sizeof(u16) * gpioNum, GFP_KERNEL);
+    
+        for (i = 0; i <	gpioNum; i++)
+        {
+            gpioPIN[i] = SHORT_N2_GPO_PIN_X[i];
+        }
+    }
+    else if (nItemID == 3)
+    {
+        gpioNum = SHORT_S1_GPO_NUMBER_X;
+        gpioPIN = kzalloc(sizeof(u16) * gpioNum, GFP_KERNEL);
+		
+        for (i = 0; i <	gpioNum; i++)
+        {
+            gpioPIN[i] = SHORT_S1_GPO_PIN_X[i];
+        }
+    }
+    else if (nItemID == 4)
+    {
+        gpioNum = SHORT_S2_GPO_NUMBER_X;
+        gpioPIN = kzalloc(sizeof(u16) * gpioNum, GFP_KERNEL);
+		
+        for (i = 0; i <	gpioNum; i++)
+        {
+            gpioPIN[i] = SHORT_S2_GPO_PIN_X[i];
+        }
+    }
+    DBG(&g_I2cClient->dev, "ItemID %d, gpioNum %d",nItemID, gpioNum);
+
+    for (i = 0; i < MUTUAL_IC_MAX_CHANNEL_NUM; i++)
+    {
+        gpioEnabling[i] = 0xFFFF;
+    }
+
+    for (i = 0; i < gpioNum; i++)
+    {
+        gpioSetting[gpioPIN[i] / 16] |= (u16)(1 << (gpioPIN[i] % 16));
+        gpioEnabling[gpioPIN[i] / 16] &= (u16)(~(1 << (gpioPIN[i] % 16)));
+    }
+
+    ///cts sw overwrite
+    {
+        _DrvMpTestItoTestMsg26xxmSendDataIn(0x1E66, gpioNum, &gpioSetting[0]);   ///who -> will be controlled
+        _DrvMpTestItoTestMsg26xxmSendDataIn(0x1E6C, gpioNum, &gpioEnabling[0]);   ///who -> enable sw overwrite
+        _DrvMpTestItoTestMsg26xxmSendDataIn(0x1E72, gpioNum, &gpioZero[0]);       ///who -> set2GPO
+        _DrvMpTestItoTestMsg26xxmSendDataIn(0x1E78, gpioNum, &gpioZero[0]);       ///who -> GPO2GND
+    }
+
+    for (j = 0; j < gpioNum; j++)
+    {
+        if (MSG26XXM_PIN_GUARD_RING == gpioPIN[j])
+        {
+            u16 u16RegData;
+            u16RegData = RegGet16BitValue(0x1E12);
+            u16RegData = ((u16RegData & 0xFFF9) | BIT0);
+            RegSet16BitValue(0x1E12, u16RegData);
+        }
+    }
+
+    kfree(gpioPIN);
+}
+
+static void _DrvMpTestItoShortTestMsg26xxmChangeANASetting(u8 nItemID)
+{
+    u16 SHORT_MAP_ANA1[7] = {0};
+    u16 SHORT_MAP_ANA2[1] = {0};
+    u16 SHORT_MAP_ANA3[21] = {0};
+    int i = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (nItemID == 1)
+    {
+        for (i = 0; i <	7; i++)
+        {
+            SHORT_MAP_ANA1[i] = short_ANA1_N1_X[i];
+        }
+        
+        for (i = 0; i < 21; i++)
+        {
+            SHORT_MAP_ANA3[i] = short_ANA3_N1_X[i];
+        }
+
+        SHORT_MAP_ANA2[0] = short_ANA2_N1_X[0];
+    }
+    else if (nItemID == 2)
+    {
+        for (i = 0; i <	7; i++)
+        {
+            SHORT_MAP_ANA1[i] = short_ANA1_N2_X[i];
+        }
+		
+        for (i = 0; i < 21; i++)
+        {
+            SHORT_MAP_ANA3[i] = short_ANA3_N2_X[i];
+        }
+
+        SHORT_MAP_ANA2[0] = short_ANA2_N2_X[0];
+    }
+    else if (nItemID == 3)
+    {
+        for (i = 0; i <	7; i++)
+        {
+            SHORT_MAP_ANA1[i] = short_ANA1_S1_X[i];
+        }
+        
+        for (i = 0; i < 21; i++)
+        {
+            SHORT_MAP_ANA3[i] = short_ANA3_S1_X[i];
+        }
+
+        SHORT_MAP_ANA2[0] = short_ANA2_S1_X[0];
+    }
+    else if (nItemID == 4)
+    {
+        for (i = 0; i <	7; i++)
+        {
+            SHORT_MAP_ANA1[i] = short_ANA1_S2_X[i];
+        }
+        
+        for (i = 0; i < 21; i++)
+        {
+            SHORT_MAP_ANA3[i] = short_ANA3_S2_X[i];
+        }
+
+        SHORT_MAP_ANA2[0] = short_ANA2_S2_X[0];
+    }
+
+    ///change ANA setting
+    {
+        _DrvMpTestItoTestMsg26xxmSendDataIn(0x1178, 7, &SHORT_MAP_ANA1[0]);		///ANA1_3C_42
+        _DrvMpTestItoTestMsg26xxmSendDataIn(0x1216, 1, &SHORT_MAP_ANA2[0]);   	///ANA2_0B
+        _DrvMpTestItoTestMsg26xxmSendDataIn(0x1006, 21, &SHORT_MAP_ANA3[0]);    ///ANA3_03_17
+    }
+}
+
+static void _DrvMpTestItoShortTestMsg26xxmAnaFixPrs(u16 nOption)
+{
+    u16 nTemp = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nTemp = RegGet16BitValue(0x1208); //bank:ana2, addr:h000a
+    nTemp &= 0x00F1;
+    nTemp |= (u16)((nOption << 1) & 0x000E);
+    RegSet16BitValue(0x1208, nTemp);
+}
+
+static void _DrvMpTestItoShortTestMsg26xxmSetNoiseSensorMode(u8 nEnable)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (nEnable)
+    {
+        RegSet16BitValueOn(0x110E, BIT11);
+        RegSet16BitValueOff(0x1116, BIT2);
+    }
+    else
+    {
+        RegSet16BitValueOff(0x110E, BIT11);
+    }
+}
+
+static void _DrvMpTestItoShortTestMsg26xxmAndChangeCDtime(u16 nTime1, u16 nTime2)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    RegSet16BitValue(0x1224, nTime1);
+    RegSet16BitValue(0x122A, nTime2);
+}
+
+static void _DrvMpTestMsg26xxmItoShortTest(u8 nItemID)
+{
+    int i;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    _DrvMpTestItoTestMsg26xxmMcuStop();
+    _DrvMpTestItoShortTestMsg26xxmSetPAD2GPO(nItemID);
+    _DrvMpTestItoShortTestMsg26xxmChangeANASetting(nItemID);
+    _DrvMpTestItoTestMsg26xxmAnaSwitchToMutual();
+    _DrvMpTestItoShortTestMsg26xxmAnaFixPrs(7);
+    _DrvMpTestItoTestMsg26xxmDisableFilterNoiseDetect();
+    _DrvMpTestItoShortTestMsg26xxmSetNoiseSensorMode(1);
+    _DrvMpTestItoShortTestMsg26xxmAndChangeCDtime(SHORT_Charge_X, SHORT_Dump1_X);
+    _DrvMpTestItoTestMsg26xxmAnaSwReset();
+    _DrvMpTestItoTestMsg26xxmGetDeltaC(_gMutualICTempDeltaC);
+
+    _DrvMpTestItoTestMsg26xxmMcuStop();
+    _DrvMpTestItoShortTestMsg26xxmSetPAD2GPO(nItemID);
+    _DrvMpTestItoShortTestMsg26xxmChangeANASetting(nItemID);
+    _DrvMpTestItoTestMsg26xxmAnaSwitchToMutual();
+    _DrvMpTestItoShortTestMsg26xxmAnaFixPrs(7);
+    _DrvMpTestItoTestMsg26xxmDisableFilterNoiseDetect();
+    _DrvMpTestItoShortTestMsg26xxmSetNoiseSensorMode(1);
+    _DrvMpTestItoShortTestMsg26xxmAndChangeCDtime(SHORT_Charge_X, SHORT_Dump2_X);
+    _DrvMpTestItoTestMsg26xxmAnaSwReset();
+    _DrvMpTestItoTestMsg26xxmGetDeltaC(_gMutualICDeltaC);
+
+    for (i = 0; i < MUTUAL_IC_MAX_MUTUAL_NUM; i ++)
+    {
+        if ((_gMutualICDeltaC[i] <= -(MUTUAL_IC_IIR_MAX)) || (_gMutualICTempDeltaC[i] <= -(MUTUAL_IC_IIR_MAX)) || (_gMutualICDeltaC[i] >= (MUTUAL_IC_IIR_MAX)) || (_gMutualICTempDeltaC[i] >= (MUTUAL_IC_IIR_MAX)))
+        {
+            _gMutualICDeltaC[i] = 0x7FFF;
+        }
+        else
+        {
+            _gMutualICDeltaC[i] = abs(_gMutualICDeltaC[i] - _gMutualICTempDeltaC[i]);
+        }
+        //DBG(&g_I2cClient->dev, "ItemID%d, MUTUAL_NUM %d, _gMutualICDeltaC = %d\t", nItemID, i, _gMutualICDeltaC[i]);
+    }
+    DBG(&g_I2cClient->dev, "\n");
+}
+
+static s32 _DrvMpTestItoShortTestMsg26xxmCovertRValue(s32 nValue)
+{
+   	if (nValue == 0)
+   	{
+   	   	nValue = 1;
+   	}   	   	   	
+
+   	if (nValue >= MUTUAL_IC_IIR_MAX)
+   	{
+   	   	return 0;
+   	}
+
+   	return ((500*11398) / (nValue));
+}
+
+static ItoTestResult_e _DrvMpTestItoShortTestMsg26xxmJudge(u8 nItemID)
+{
+   	ItoTestResult_e nRetVal = ITO_TEST_OK;
+   	u8 nTestPinLength = 0;
+   	u16 i = 0;
+   	u8 nGpioNum = 0;
+   	u8* pTestGpio = NULL;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+   	if (nItemID == 1)
+   	{
+   	   	nGpioNum = SHORT_N1_TEST_NUMBER_X;
+   	   	pTestGpio = kzalloc(sizeof(u8) * nGpioNum, GFP_KERNEL);
+   	   	
+   	   	for (i = 0; i <	nGpioNum; i++)
+   	   	{
+   	   	   	pTestGpio[i] = SHORT_N1_TEST_PIN_X[i];
+   	   	}
+   	}
+   	else if (nItemID == 2)
+   	{
+   	   	nGpioNum = SHORT_N2_TEST_NUMBER_X;
+   	   	pTestGpio = kzalloc(sizeof(u8) * nGpioNum, GFP_KERNEL);
+   	   	
+   	   	for (i = 0; i <	nGpioNum; i++)
+   	   	{
+   	   	   	pTestGpio[i] = SHORT_N2_TEST_PIN_X[i];
+   	   	}
+   	}
+   	else if (nItemID == 3)
+   	{
+   	   	nGpioNum = SHORT_S1_TEST_NUMBER_X;
+   	   	pTestGpio = kzalloc(sizeof(u8) * nGpioNum, GFP_KERNEL);
+   	   	
+   	   	for (i = 0; i <	nGpioNum; i++)
+   	   	{
+   	   	   	pTestGpio[i] = SHORT_S1_TEST_PIN_X[i];
+   	   	}
+   	}
+   	else if (nItemID == 4)
+   	{
+   	   	nGpioNum = SHORT_S2_TEST_NUMBER_X;
+   	   	pTestGpio = kzalloc(sizeof(u8) * nGpioNum, GFP_KERNEL);
+   	   	
+   	   	for (i = 0; i <	nGpioNum; i++)
+   	   	{
+   	   	   	pTestGpio[i] = SHORT_S2_TEST_PIN_X[i];
+   	   	}
+   	}
+
+   	nTestPinLength = nGpioNum;
+
+   	for (i = 0;i < nTestPinLength; i++)
+   	{
+   	   	_gMsg26xxmShortTestChannel[i] = pTestGpio[i];
+
+   	   	if (0 == _DrvMpTestMutualICCheckValueInRange(_gMutualICDeltaC[i], MSG26XXM_SHORT_VALUE, -MSG26XXM_SHORT_VALUE))
+   	   	{
+   	   	   	nRetVal = ITO_TEST_FAIL;
+   	   	   	_gTestFailChannelCount++;
+   	   	   	DBG(&g_I2cClient->dev, "_gMsg26xxmShortTestChannel i = %d, _gMutualICDeltaC = %d\t", i, _gMutualICDeltaC[i]);
+   	   	}
+   	}
+   	
+   	kfree(pTestGpio);
+
+   	return nRetVal;
+}
+
+static ItoTestResult_e _DrvMpTestMsg26xxmItoShortTestEntry(void)
+{
+    ItoTestResult_e nRetVal1 = ITO_TEST_OK, nRetVal2 = ITO_TEST_OK, nRetVal3 = ITO_TEST_OK, nRetVal4 = ITO_TEST_OK, nRetVal5 = ITO_TEST_OK;
+    u32 i = 0;
+    u32 j = 0;
+    u16 nTestPinCount = 0;
+    s32 nShortThreshold = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    DrvPlatformLyrDisableFingerTouchReport();
+    
+    DrvPlatformLyrTouchDeviceResetHw();
+
+	  //auto detetc fw version to decide switch fw mode
+    if (_gMutualICTestAutoSwitchFlag != 0)
+    {
+        _DrvMpTestItoTestMsg26xxmGetSwitchFlag();
+    }
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+  	_DrvMpTestItoTestMsg26xxmSwitchMode(_gMutualICTestSwitchMode, MUTUAL);
+
+    for (i = 0; i < MUTUAL_IC_MAX_CHANNEL_NUM; i ++)
+    {
+        _gMsg26xxmShortTestChannel[i] = 0;
+    }
+
+    for (i = 0; i < MUTUAL_IC_MAX_MUTUAL_NUM; i ++)
+    {
+        _gMutualICDeltaC[i] = 0;
+    }
+
+    _gMutualICSenseLineNum = _DrvMpTestItoTestMsg26xxmAnaGetMutualChannelNum();
+    _gMutualICDriveLineNum = _DrvMpTestItoTestMsg26xxmAnaGetMutualSubFrameNum();
+
+    for (i = 0; i < MUTUAL_IC_MAX_CHANNEL_NUM; i ++)
+    {
+        _gMsg26xxmShortTestChannel[i] = 0xff;
+    }
+
+    _gTestFailChannelCount = 0;
+
+    nTestPinCount = 0; // Reset nTestPinCount to 0 before test start
+
+    //N1_ShortTest
+
+    if (g_ChipType == CHIP_TYPE_MSG26XXM)
+    {
+        _DrvMpTestMsg26xxmItoShortTest(1); 
+    }
+
+    nRetVal2 = _DrvMpTestItoShortTestMsg26xxmJudge(1);
+
+    for (i = 0; i < MUTUAL_IC_MAX_CHANNEL_NUM; i++)
+    {
+        if (_gMsg26xxmShortTestChannel[i] != 0)
+        {
+            nTestPinCount++;
+        }
+    }
+
+    for (i = 0; i < nTestPinCount; i++)
+    {
+        for (j = 0; j < _gMutualICSenseLineNum; j++)
+        {
+            if (_gMsg26xxmShortTestChannel[i] == SENSE_X[j])
+            {
+                _gMutualICSenseR[j] = _DrvMpTestItoShortTestMsg26xxmCovertRValue(_gMutualICDeltaC[i]);
+
+                DBG(&g_I2cClient->dev, "_gMutualICSenseR[%d] = %d\t", j , _gMutualICSenseR[j]);
+            }
+        }
+    }
+    DBG(&g_I2cClient->dev, "\n");
+
+    //clear
+    for (i = 0; i < MUTUAL_IC_MAX_CHANNEL_NUM; i ++)
+    {
+        _gMsg26xxmShortTestChannel[i] = 0xff;
+    }
+
+    nTestPinCount = 0;
+
+    //N2_ShortTest
+
+    if (g_ChipType == CHIP_TYPE_MSG26XXM)
+    {
+        _DrvMpTestMsg26xxmItoShortTest(2);
+    }
+
+    nRetVal3 = _DrvMpTestItoShortTestMsg26xxmJudge(2);
+
+    for (i = 0; i < MUTUAL_IC_MAX_CHANNEL_NUM; i++)
+    {
+        if (_gMsg26xxmShortTestChannel[i] != 0)
+        {
+            nTestPinCount++;
+        }            
+    }
+
+    for (i = 0; i < nTestPinCount; i++)
+    {
+        for (j = 0; j < _gMutualICSenseLineNum; j++)
+        {
+            if (_gMsg26xxmShortTestChannel[i] == SENSE_X[j])
+            {
+                _gMutualICSenseR[j] = _DrvMpTestItoShortTestMsg26xxmCovertRValue(_gMutualICDeltaC[i]);
+
+                DBG(&g_I2cClient->dev, "_gMutualICSenseR[%d] = %d\t", j , _gMutualICSenseR[j]);
+            }
+        }
+    }
+    DBG(&g_I2cClient->dev, "\n");
+
+    for (i = 0; i < MUTUAL_IC_MAX_CHANNEL_NUM; i ++)
+    {
+        _gMsg26xxmShortTestChannel[i] = 0xff;
+    }
+    
+    nTestPinCount = 0;
+
+    if (g_ChipType == CHIP_TYPE_MSG26XXM)
+    {
+        _DrvMpTestMsg26xxmItoShortTest(3);
+    }
+    
+    nRetVal4 = _DrvMpTestItoShortTestMsg26xxmJudge(3);
+
+    for (i = 0; i < MUTUAL_IC_MAX_CHANNEL_NUM; i++)
+    {
+        if (_gMsg26xxmShortTestChannel[i] != 0)
+        {
+            nTestPinCount++;
+        }
+    }
+
+    for (i = 0; i < nTestPinCount; i++)
+    {
+        for (j = 0; j < _gMutualICDriveLineNum; j++)
+        {
+            if (_gMsg26xxmShortTestChannel[i] == DRIVE_X[j])
+            {
+                _gMutualICDriveR[j] = _DrvMpTestItoShortTestMsg26xxmCovertRValue(_gMutualICDeltaC[i]);
+                DBG(&g_I2cClient->dev, "_gMutualICDriveR[%d] = %d\t", j , _gMutualICDriveR[j]);
+            }
+        }
+    }
+    DBG(&g_I2cClient->dev, "\n");
+    
+    for (i = 0; i < MUTUAL_IC_MAX_CHANNEL_NUM; i ++)
+    {
+        _gMsg26xxmShortTestChannel[i] = 0xff;
+    }
+    
+    nTestPinCount = 0;
+
+    if (g_ChipType == CHIP_TYPE_MSG26XXM)
+    {
+        _DrvMpTestMsg26xxmItoShortTest(4);
+    }
+    
+    nRetVal4 = _DrvMpTestItoShortTestMsg26xxmJudge(4);
+
+    for (i = 0; i < MUTUAL_IC_MAX_CHANNEL_NUM; i++)
+    {
+        if (_gMsg26xxmShortTestChannel[i] != 0)
+        {
+            nTestPinCount++;
+        }
+    }
+
+    for (i = 0; i < nTestPinCount; i++)
+    {
+        for (j = 0; j < _gMutualICDriveLineNum ; j++)
+        {
+            if (_gMsg26xxmShortTestChannel[i] == DRIVE_X[j])
+            {
+                _gMutualICDriveR[j] = _DrvMpTestItoShortTestMsg26xxmCovertRValue(_gMutualICDeltaC[i]);
+                DBG(&g_I2cClient->dev, "_gMutualICDriveR[%d] = %d\t", j , _gMutualICDriveR[j]);
+            }
+        }
+    }
+    DBG(&g_I2cClient->dev, "\n");
+    
+    for (i = 0; i < MUTUAL_IC_MAX_CHANNEL_NUM; i ++)
+    {
+        _gMsg26xxmShortTestChannel[i] = 0xff;
+    }
+    
+    nTestPinCount = 0;
+    nShortThreshold = _DrvMpTestItoShortTestMsg26xxmCovertRValue(MSG26XXM_SHORT_VALUE);
+
+    for (i = 0; i < _gMutualICSenseLineNum; i++)
+    {
+        _gMutualICResult[i] = _gMutualICSenseR[i];
+    }
+
+    for (i = 0; i < _gMutualICDriveLineNum; i++)
+    {
+        _gMutualICResult[i + _gMutualICSenseLineNum] = _gMutualICDriveR[i];
+    }
+
+    for (i = 0; i < (_gMutualICSenseLineNum + _gMutualICDriveLineNum); i++)
+    {
+        if (_gMutualICResult[i] < nShortThreshold)
+        {
+            _gMutualICTestFailChannel[i] = 1;
+        }
+        else
+        {
+            _gMutualICTestFailChannel[i] = 0;
+        }
+    }
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    mdelay(300);
+
+    DrvPlatformLyrEnableFingerTouchReport();
+
+    DBG(&g_I2cClient->dev, "short test end\n");
+
+    DBG(&g_I2cClient->dev, "nRetVal1 = %d, nRetVal2 = %d, nRetVal3 = %d, nRetVal4 = %d, nRetVal5 = %d\n",nRetVal1,nRetVal2,nRetVal3,nRetVal4,nRetVal5);
+
+    if ((nRetVal1 != ITO_TEST_OK) && (nRetVal2 == ITO_TEST_OK) && (nRetVal3 == ITO_TEST_OK) && (nRetVal4 == ITO_TEST_OK) && (nRetVal5 == ITO_TEST_OK))
+    {
+        return ITO_TEST_GET_TP_TYPE_ERROR;
+    }
+    else if ((nRetVal1 == ITO_TEST_OK) && ((nRetVal2 != ITO_TEST_OK) || (nRetVal3 != ITO_TEST_OK) || (nRetVal4 != ITO_TEST_OK) || (nRetVal5 != ITO_TEST_OK)))
+    {
+        return -1;
+    }
+    else
+    {
+        return ITO_TEST_OK;
+    }
+}
+
+static s32 _DrvMpTestItoTestMsg26xxmGetWaterProofOneShotRawIir(u16 wszResultData[])
+{
+    u16 nRegData;
+    u16 i;
+    u16 nTemp;
+    u8 szDbBusTxData[3];
+    u32 nGetdataNum = 12;
+    u8 szShotData[24] = {0}; //Get 12 FIR data
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nTemp = RegGet16BitValue(0x3D08); //bank:intr_ctrl, addr:h0004
+    nTemp &= (~(BIT8));
+    RegSet16BitValue(0x3D08, nTemp);
+    //RegSet16BitValueOff(0x3D08, BIT8);      ///FIQ_E_FRAME_READY_MASK
+
+    _DrvMpTestItoTestMsg26xxmEnableAdcOneShot();
+
+    nRegData = 0;
+    while (0x0000 == (nRegData & BIT8))
+    {
+        nRegData = RegGet16BitValue(0x3D18); //bank:intr_ctrl, addr:h000c
+    }
+
+    for (i = 0; i < nGetdataNum * 2; i ++)
+    {
+        szShotData[i] = 0;
+    }
+
+    mdelay(200);
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x13; //bank:fir, addr:h0021
+    szDbBusTxData[2] = 0x42;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);
+    IicReadData(SLAVE_I2C_ID_DBBUS, &szShotData[0], 24); //12
+
+    for (i = 0; i < nGetdataNum; i ++)
+    {
+        nRegData = (u16)(szShotData[i * 2] | szShotData[i * 2 + 1] << 8);
+        wszResultData[i] = (short)nRegData;
+
+		//DBG(&g_I2cClient->dev, "wszResultData[%d] = %x\t", i  , wszResultData[i]);
+    }
+
+    nTemp = RegGet16BitValue(0x3D08); //bank:intr_ctrl, addr:h0004
+    nTemp |= (BIT8 | BIT4);
+    RegSet16BitValue(0x3D08, nTemp);
+
+    return 0;
+}
+
+static s32 _DrvMpTestItoTestMsg26xxmGetWaterProofDeltaC(s32 *pTarget)
+{
+    u16 wszRawData[12];
+    u16 i;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (_DrvMpTestItoTestMsg26xxmGetWaterProofOneShotRawIir(wszRawData) < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg26xxm WaterProof Test# GetMutualOneShotRawIIR failed! ***\n");
+        return -1;
+    }
+
+    for (i = 0; i < 12; i ++)
+    {
+        pTarget[i] = (s16)wszRawData[i];
+    }
+
+    return 0;
+}
+
+static s32 _DrvMpTestMsg26xxmItoWaterProofTest(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // Stop mcu
+    //RegSet16BitValue(0x0FE6, 0x0001);
+
+    _DrvMpTestItoTestMsg26xxmAnaSwReset();
+
+    _DrvMpTestItoShortTestMsg26xxmAndChangeCDtime(WATERPROOF_Charge_X, WATERPROOF_Dump_X);
+
+    if(_DrvMpTestItoTestMsg26xxmGetWaterProofDeltaC(_gMutualICDeltaC) < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg26xxm WaterProof Test# GetWaterDeltaC failed! ***\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+static s32 _DrvMpTestMsg26xxmItoWaterProofTestJudge(void)
+{
+    u16 i;
+    u32 nGetdataNum = 12;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    for (i = 0; i < nGetdataNum; i ++)
+    {
+        _gMutualICResultWater[i] = 0;
+    }
+
+    for (i = 0; i < nGetdataNum; i++)
+    {
+   		_gMutualICResultWater[i] = _gMutualICDeltaC[i];
+    }
+
+    return 0;
+}
+
+s32 _DrvMpTestMsg26xxmItoWaterProofTestEntry(void)
+{
+    s32 nRetVal = 0;
+    u32 nRegData = 0;
+    u16 i = 0;
+    s32 nResultTemp[12] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    _gMutualICWaterProofNum = 12;
+
+    DrvPlatformLyrDisableFingerTouchReport();
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+	  //auto detetc fw version to decide switch fw mode
+    if (_gMutualICTestAutoSwitchFlag != 0)
+    {
+        _DrvMpTestItoTestMsg26xxmGetSwitchFlag();
+    }
+
+    DbBusResetSlave();
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    if (_DrvMpTestItoTestMsg26xxmSwitchMode(_gMutualICTestSwitchMode, WATERPROOF) < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg26xxm WaterProof Test# Switch FW mode failed! ***\n");
+        return -1;
+    }
+
+    _DrvMpTestItoTestMsg26xxmMcuStop();
+
+    nRegData = RegGet16BitValue(0x3CE4);
+
+    if (nRegData == 0x8bbd)//// if polling 0X8BBD, means the FW is NOT supporting WP.
+    {
+        DBG(&g_I2cClient->dev, "*** Msg26xxm WaterProof Test# No supporting this function! ***\n");
+        return -1;
+    }
+
+    mdelay(10);
+
+    for (i = 0; i < MUTUAL_IC_MAX_MUTUAL_NUM; i ++)
+    {
+        _gMutualICTestFailChannel[i] = 0;
+    }
+
+    _gTestFailChannelCount = 0; // Reset _gTestFailChannelCount to 0 before test start
+
+  	if(_DrvMpTestMsg26xxmItoWaterProofTest() < 0)
+  	{
+        DBG(&g_I2cClient->dev, "*** Msg26xxm WaterProof Test# Get DeltaC failed! ***\n");
+        return -1;
+  	}
+
+    _DrvMpTestMsg26xxmItoWaterProofTestJudge();
+
+    for (i = 0; i < 12; i++)
+    {
+        nResultTemp[i] = _gMutualICResultWater[i];
+    }
+
+    _DrvMpTestMutualICDebugShowArray(_gMutualICResultWater, 12, -32, 10, 8);
+    for (i = 0; i < 12; i++)
+    {
+        if (nResultTemp[i] < WATERPROOFVALUE)    //change comparison way because float computing in driver is prohibited
+        {
+            _gMutualICTestFailChannel[i] = 1;
+            _gTestFailChannelCount++;
+            nRetVal = -1;
+        }
+        else
+        {
+            _gMutualICTestFailChannel[i] = 0;
+        }
+    }
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    mdelay(300);
+
+    DrvPlatformLyrEnableFingerTouchReport();
+
+    return nRetVal;
+}
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+static void _DrvMpTestItoOpenTestMsg28xxSetMutualCsubViaDBbus(s16 nCSub)
+{   
+    u8 nBaseLen = 6;
+    u16 nFilter = 0x3F;
+    u16 nLastFilter = 0xFFF;
+    u8 nBasePattern = nCSub & nFilter; 
+    u8 nPattern;
+    u16 n16BitsPattern;
+    u16 nCSub16Bits[5] = {0};
+    int i;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    for(i=0; i<5; i++)
+    {
+        if(i == 0)
+        {
+            nPattern = nBasePattern;    //Patn => Pattern
+        }
+         
+        n16BitsPattern = ((nPattern & 0xF) << nBaseLen*2) | (nPattern << nBaseLen) | nPattern;
+
+        if(i == 4)
+        {
+            nCSub16Bits[i] = n16BitsPattern & nLastFilter;
+        }
+        else
+        {
+            nCSub16Bits[i] = n16BitsPattern;
+        }
+        nPattern = (u8)((n16BitsPattern >> 4) & nFilter);
+    }    
+        
+    RegSet16BitValue(0x215C, 0x1FFF);
+
+    for (i = 0; i < 5; i++)
+    {
+        RegSet16BitValue(0x2148 + 2 * i, nCSub16Bits[i]);
+        RegSet16BitValue(0x2152 + 2 * i, nCSub16Bits[i]);
+    }     
+}
+
+/*
+static void _DrvMpTestItoOpenTestMsg28xxAFEGainOne(void)
+{
+    u8 nRegData = 0;
+    u16 nAFECoef = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // AFE gain = 1X
+    RegSet16BitValue(0x1318, 0x4440);
+    RegSet16BitValue(0x131A, 0x4444);
+    RegSet16BitValue(0x13D6, 0x2000);
+    
+    RegSet16BitValue(0x2160, 0x0040);
+    RegSet16BitValue(0x2162, 0x0040);
+    RegSet16BitValue(0x2164, 0x0040);
+    RegSet16BitValue(0x2166, 0x0040);
+    RegSet16BitValue(0x2168, 0x0040);
+    RegSet16BitValue(0x216A, 0x0040);
+    RegSet16BitValue(0x216C, 0x0040);
+    RegSet16BitValue(0x216E, 0x0040);
+    RegSet16BitValue(0x2170, 0x0040);
+    RegSet16BitValue(0x2172, 0x0040);
+    RegSet16BitValue(0x2174, 0x0040);
+    RegSet16BitValue(0x2176, 0x0040);
+    RegSet16BitValue(0x2178, 0x0040);
+    RegSet16BitValue(0x217A, 0x1FFF);
+    RegSet16BitValue(0x217C, 0x1FFF);
+    
+    /// reg_hvbuf_sel_gain
+    RegSet16BitValue(0x1564, 0x0077);
+    
+    /// all AFE Cfb use defalt (50p)
+    RegSet16BitValue(0x1508, 0x1FFF);// all AFE Cfb: SW control
+    RegSet16BitValue(0x1550, 0x0000);// all AFE Cfb use defalt (50p)
+    
+    ///ADC: AFE Gain bypass
+    RegSet16BitValue(0x1260, 0x1FFF);
+
+    //AFE coef
+    nRegData = RegGetLByteValue(0x101A);
+    nAFECoef = (u16)(0x10000/nRegData);
+    RegSet16BitValue(0x13D6, nAFECoef);        
+}
+*/
+
+static void _DrvMpTestItoOpenTestMsg28xxAFEGainOne(void)
+{
+    // AFE gain = 1X
+    u16 nAfeGain = 0;
+    u16 nDriOpening = 0;
+    u8 nRegData = 0;
+    u16 nAfeCoef = 0;
+    u16 i = 0;
+
+    //proto.MstarReadReg(loopDevice, (uint)0x1312, ref regdata); //get dri num
+    nRegData = RegGetLByteValue(0x1312);    
+    nDriOpening = nRegData;
+
+    ///filter unit gain
+    if (nDriOpening == 11 || nDriOpening == 15)
+    {
+        RegSet16BitValue(0x1318, 0x4470);
+    }
+    else if (nDriOpening == 7)
+    {
+        RegSet16BitValue(0x1318, 0x4460);
+    }
+
+    //proto.MstarWriteReg_16(loopDevice, 0x131A, 0x4444);
+    RegSet16BitValue(0x131A, 0x4444);
+
+    ///AFE coef
+    //proto.MstarReadReg(loopDevice, (uint)0x101A, ref regdata);
+    nRegData = RegGetLByteValue(0x101A); 
+    nAfeCoef = 0x10000 / nRegData;
+    //proto.MstarWriteReg_16(loopDevice, (uint)0x13D6, AFE_coef);
+    RegSet16BitValue(0x13D6, nAfeCoef);
+
+    ///AFE gain
+    if (nDriOpening == 7 || nDriOpening == 15)
+    {
+        nAfeGain = 0x0040;
+    }    
+    else if (nDriOpening == 11)
+    {
+        nAfeGain = 0x0055;
+    }
+    
+    for (i = 0; i < 13; i++)
+    {
+        RegSet16BitValue(0x2160 + 2 * i, nAfeGain);
+    }
+
+    ///AFE gain: over write enable
+    RegSet16BitValue(0x217A, 0x1FFF);
+    RegSet16BitValue(0x217C, 0x1FFF);
+
+    /// all AFE Cfb use defalt (50p)
+    RegSet16BitValue(0x1508, 0x1FFF);// all AFE Cfb: SW control
+    RegSet16BitValue(0x1550, 0x0000);// all AFE Cfb use defalt (50p)
+
+    /// reg_hvbuf_sel_gain
+    RegSet16BitValue(0x1564, 0x0077);
+
+    ///ADC: AFE Gain bypass
+    RegSet16BitValue(0x1260, 0x1FFF);
+}
+
+static void _DrvMpTestItoOpenTestMsg28xxCalibrateMutualCsub(s16 nCSub)
+{   
+    u8 nChipVer;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nChipVer = RegGetLByteValue(0x1ECE);
+    DBG(&g_I2cClient->dev, "*** Msg28xx Open Test# Chip ID = %d ***\n", nChipVer);    
+    
+    if (nChipVer != 0)
+        RegSet16BitValue(0x10F0, 0x0004);//bit2
+    
+    _DrvMpTestItoOpenTestMsg28xxSetMutualCsubViaDBbus(nCSub);
+    _DrvMpTestItoOpenTestMsg28xxAFEGainOne();    
+}
+
+static void _DrvMpTestItoTestDBBusReadDQMemStart(void)
+{
+    u8 nParCmdSelUseCfg = 0x7F;
+    u8 nParCmdAdByteEn0 = 0x50;
+    u8 nParCmdAdByteEn1 = 0x51;
+    u8 nParCmdDaByteEn0 = 0x54;
+    u8 nParCmdUSetSelB0 = 0x80;
+    u8 nParCmdUSetSelB1 = 0x82;
+    u8 nParCmdSetSelB2  = 0x85;
+    u8 nParCmdIicUse    = 0x35;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdSelUseCfg, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdAdByteEn0, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdAdByteEn1, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdDaByteEn0, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdUSetSelB0, 1);        
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdUSetSelB1, 1); 
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdSetSelB2,  1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdIicUse,    1);        
+}
+
+/*
+static void _DrvMpTestItoTestDBBusReadDQMemStartAddr24(void)
+{
+    u8 nParCmdSelUseCfg = 0x7F;
+//    u8 nParCmdAdByteEn0 = 0x50;
+//    u8 nParCmdAdByteEn1 = 0x51;
+    u8 nParCmdAdByteEn2 = 0x52;    
+//    u8 nParCmdDaByteEn0 = 0x54;
+    u8 nParCmdUSetSelB0 = 0x80;
+    u8 nParCmdUSetSelB1 = 0x82;
+    u8 nParCmdSetSelB2  = 0x85;
+    u8 nParCmdIicUse    = 0x35;
+    //u8 nParCmdWr        = 0x10;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdSelUseCfg, 1);
+    //IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdAdByteEn0, 1);
+    //IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdAdByteEn1, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdAdByteEn2, 1);    
+    //IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdDaByteEn0, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdUSetSelB0, 1);        
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdUSetSelB1, 1); 
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdSetSelB2,  1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdIicUse,    1);        
+}
+*/
+
+static void _DrvMpTestItoTestDBBusReadDQMemEnd(void)
+{
+    u8 nParCmdNSelUseCfg = 0x7E;    
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdNSelUseCfg, 1);
+}
+
+/*
+static void _DrvMpTestItoTestDBBusReadDQMemEndAddr24(void)
+{
+    u8 nParCmdSelUseCfg  = 0x7F;
+    u8 nParCmdAdByteEn1  = 0x51;
+    u8 nParCmdSetSelB0   = 0x81;
+    u8 nParCmdSetSelB1   = 0x83;    
+    u8 nParCmdNSetSelB2  = 0x84;
+    u8 nParCmdIicUse     = 0x35;
+    u8 nParCmdNSelUseCfg = 0x7E;
+    u8 nParCmdNIicUse    = 0x34;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    RegSetLByteValue(0, 0);       
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdSelUseCfg, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdAdByteEn1, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdSetSelB0, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdSetSelB1, 1);    
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdNSetSelB2, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdIicUse, 1);        
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdNSelUseCfg, 1); 
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdNIicUse,  1);
+}
+*/
+
+static void _DrvMpTestItoTestMsg28xxEnableAdcOneShot(void)
+{
+    RegSet16BitValueOn(0x100a, BIT0);
+
+    return;
+}
+
+static s32 _DrvMpTestItoTestMsg28xxTriggerMutualOneShot(s16 * pResultData, u16 * pSenNum, u16 * pDrvNum)
+{    
+    u16 nAddr = 0x5000, nAddrNextSF = 0x1A4;
+    u16 nSF = 0, nAfeOpening = 0, nDriOpening = 0;
+    u16 nMaxDataNumOfOneSF = 0;
+    u16 nDriMode = 0;
+    int nDataShift = -1;
+    u16 i, j, k;    
+    u8 nRegData = 0;
+    u8 nShotData[392] = {0};//13*15*2
+    u16 nRegDataU16 = 0;
+    s16 * pShotDataAll = NULL;
+    u8 nParCmdIicUse    = 0x35;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+        
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdIicUse, 1);        
+    nRegData = RegGetLByteValue(0x130A);
+    nSF = nRegData>>4;
+    nAfeOpening = nRegData & 0x0f;
+    
+    if (nSF == 0)
+    {
+        return -1;
+    }
+    
+    nRegData = RegGetLByteValue(0x100B);
+    nDriMode = nRegData;
+    
+    nRegData = RegGetLByteValue(0x1312);
+    nDriOpening = nRegData;
+
+    DBG(&g_I2cClient->dev, "*** Msg28xx MP Test# TriggerMutualOneShot nSF=%d, nAfeOpening=%d, nDriMode=%d, nDriOpening=%d. ***\n", nSF, nAfeOpening, nDriMode, nDriOpening);
+    
+    nMaxDataNumOfOneSF = nAfeOpening * nDriOpening;
+    
+    pShotDataAll = kzalloc(sizeof(s16) * nSF * nMaxDataNumOfOneSF, GFP_KERNEL);
+
+    RegSet16BitValueOff(0x3D08, BIT8);      ///FIQ_E_FRAME_READY_MASK
+    
+    ///polling frame-ready interrupt status
+    _DrvMpTestItoTestMsg28xxEnableAdcOneShot();
+    
+    while (0x0000 == (nRegDataU16 & BIT8))
+    {
+        nRegDataU16 = RegGet16BitValue(0x3D18);
+    }
+    
+    if (nDriMode == 2) // for short test
+    {
+        if (nAfeOpening % 2 == 0)
+            nDataShift = -1;
+        else
+            nDataShift = 0;    //special case    
+        //s16 nShortResultData[nSF][nAfeOpening];
+        
+        /// get ALL raw data
+        for (i = 0; i < nSF; i++)
+        {
+            _DrvMpTestItoTestDBBusReadDQMemStart();
+            RegGetXBitValue(nAddr + i * nAddrNextSF, nShotData, 28, MAX_I2C_TRANSACTION_LENGTH_LIMIT);
+            _DrvMpTestItoTestDBBusReadDQMemEnd();
+
+            //_DrvMpTestMutualICDebugShowArray(nShotData, 26, 8, 16, 16);   
+            for (j = 0; j < nAfeOpening; j++)
+            {
+                pResultData[i*MUTUAL_IC_MAX_CHANNEL_DRV+j] = (s16)(nShotData[2 * j] | nShotData[2 * j + 1] << 8);
+
+                if (nDataShift == 0 && (j == nAfeOpening-1))
+                {
+                    pResultData[i*MUTUAL_IC_MAX_CHANNEL_DRV+j] = (s16)(nShotData[2 * (j + 1)] | nShotData[2 * (j + 1) + 1] << 8);                
+                }
+            }
+        }
+
+        *pSenNum = nSF;
+        *pDrvNum = nAfeOpening;         
+    }
+    else // for open test
+    {
+        //s16 nOpenResultData[nSF * nAfeOpening][nDriOpening];
+    
+        if (nAfeOpening % 2 == 0 || nDriOpening % 2 == 0)
+            nDataShift = -1;
+        else
+            nDataShift = 0;    //special case
+
+        /// get ALL raw data, combine and handle datashift.
+        for (i = 0; i < nSF; i++)
+        {        
+            _DrvMpTestItoTestDBBusReadDQMemStart();
+            RegGetXBitValue(nAddr + i * nAddrNextSF, nShotData, 392, MAX_I2C_TRANSACTION_LENGTH_LIMIT);
+            _DrvMpTestItoTestDBBusReadDQMemEnd();
+          
+            //_DrvMpTestMutualICDebugShowArray(nShotData, 390, 8, 10, 16);  
+            for (j = 0; j < nMaxDataNumOfOneSF; j++)
+            {
+                pShotDataAll[i*nMaxDataNumOfOneSF+j] = (s16)(nShotData[2 * j] | nShotData[2 * j + 1] << 8);
+    
+                if (nDataShift == 0 && j == (nMaxDataNumOfOneSF - 1))
+                    pShotDataAll[i*nMaxDataNumOfOneSF+j] = (s16)(nShotData[2 * (j + 1)] | nShotData[2 * (j + 1) + 1] << 8);
+            }
+        }
+        
+        //problem here
+        for (k = 0; k < nSF; k++)
+        {
+            for (i = k * nAfeOpening; i < nAfeOpening * (k + 1); i++) //Sen
+            {
+                for (j = 0; j < nDriOpening; j++) //Dri
+                {
+                    pResultData[i*MUTUAL_IC_MAX_CHANNEL_DRV+j] = pShotDataAll[k*nMaxDataNumOfOneSF + (j + (i - nAfeOpening * k) * nDriOpening)]; //resultData[Sen, Dri]
+                }
+            }
+        }
+
+        *pSenNum = nSF * nAfeOpening;
+        *pDrvNum = nDriOpening;        
+    }
+    RegSet16BitValueOn(0x3D08, BIT8);      ///FIQ_E_FRAME_READY_MASK
+    RegSet16BitValueOn(0x3D08, BIT4);      ///FIQ_E_TIMER0_MASK
+
+    kfree(pShotDataAll);
+
+    return 0;
+}
+
+static s32 _DrvMpTestItoTestMsg28xxGetMutualOneShotRawIIR(s16 * nResultData, u16 * pSenNum, u16 * pDrvNum)
+{
+    return _DrvMpTestItoTestMsg28xxTriggerMutualOneShot(nResultData, pSenNum, pDrvNum); 
+}
+
+static s32 _DrvMpTestItoTestMsg28xxGetDeltaC(s32 *pDeltaC)
+{        
+    s16 * pRawData = NULL;
+    s16 nRawDataOverlapDone[_gMsg28xx_SENSE_NUM][_gMsg28xx_DRIVE_NUM];
+    //s16 nDeltaC[MUTUAL_IC_MAX_MUTUAL_NUM] = {0};
+    u16 nDrvPos = 0, nSenPos = 0, nShift = 0;    
+    u16 nSenNumBak = 0;
+    u16 nDrvNumBak = 0;    
+    s16 i, j;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    pRawData = kzalloc(sizeof(s16) * MUTUAL_IC_MAX_CHANNEL_SEN*2 * MUTUAL_IC_MAX_CHANNEL_DRV, GFP_KERNEL);
+
+    if(_DrvMpTestItoTestMsg28xxGetMutualOneShotRawIIR(pRawData, &nSenNumBak, &nDrvNumBak) < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg28xx Open Test# GetMutualOneShotRawIIR failed! ***\n");      
+        return -1;
+    }
+
+    DBG(&g_I2cClient->dev, "*** Msg28xx Open Test# nSenNumBak=%d nDrvNumBak=%d ***\n", nSenNumBak, nDrvNumBak); 
+
+    for (i = 0; i < nSenNumBak; i++)
+    {
+        for (j = 0; j < nDrvNumBak; j++)
+        {
+            nShift = (u16)(i * nDrvNumBak + j);
+            
+            if (_gMsg28xxTpType == TP_TYPE_X)
+            {
+                nDrvPos = g_MapVaMutual_X[nShift][1];            
+                nSenPos = g_MapVaMutual_X[nShift][0];            
+            }
+            else if (_gMsg28xxTpType == TP_TYPE_Y)
+            {
+                nDrvPos = g_MapVaMutual_Y[nShift][1];            
+                nSenPos = g_MapVaMutual_Y[nShift][0];            
+            }
+            
+            if (nDrvPos != 0xFF && nSenPos != 0xFF)
+            {
+                nRawDataOverlapDone[nSenPos][nDrvPos] = pRawData[i*MUTUAL_IC_MAX_CHANNEL_DRV+j];
+            }
+        }
+    }
+  
+    for (i = 0; i < _gMutualICSenseLineNum; i++)
+    {
+        for (j = 0; j < _gMutualICDriveLineNum; j++)
+        {
+            nShift = (u16)(i * _gMutualICDriveLineNum + j);
+            pDeltaC[nShift] = (s32)nRawDataOverlapDone[i][j];
+        }
+    }
+  
+    DBG(&g_I2cClient->dev, "*** Msg28xx Open Test# gDeltaC ***\n");
+    _DrvMpTestMutualICDebugShowArray(pDeltaC, _gMutualICSenseLineNum * _gMutualICDriveLineNum, -32, 10, _gMutualICSenseLineNum);  
+
+    kfree(pRawData);
+
+    return 0;
+}
+
+static void _DrvMpTestItoTestMsg28xxAnaSwReset(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    /// reset ANA
+    RegSet16BitValueOn(0x1002, (BIT0 | BIT1 | BIT2 | BIT3));     ///reg_tgen_soft_rst: 1 to reset
+    RegSet16BitValueOff(0x1002, (BIT0 | BIT1 | BIT2 | BIT3));
+    
+    /// delay
+    mdelay(20);
+}
+
+static s32 _DrvMpTestMsg28xxItoOpenTest(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // Stop mcu
+    RegSet16BitValue(0x0FE6, 0x0001);
+
+    _DrvMpTestItoOpenTestMsg28xxCalibrateMutualCsub(_gMsg28xx_CSUB_REF);
+    RegSet16BitValue(0x156A, 0x000A); ///DAC com voltage
+    _DrvMpTestItoTestMsg28xxAnaSwReset();
+
+    if(_DrvMpTestItoTestMsg28xxGetDeltaC(_gMutualICDeltaC) < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg28xx Open Test# GetDeltaC failed! ***\n");    
+        return -1;
+    } 
+    
+    return 0;
+}
+
+static s32 _DrvMpTestItoOpenTestMsg28xxOpenJudge(u16 nItemID, s8 pNormalTestResult[][2], u16 pNormalTestResultCheck[][13]/*, u16 nDriOpening*/)
+{
+    s32 nRetVal = 0;
+    u16 nCSub = _gMsg28xx_CSUB_REF;
+    u16 nRowNum = 0, nColumnNum = 0;
+    u32 nSum=0, nAvg=0, nDelta=0, nPrev=0;
+    u16 i, j, k;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    for (i = 0; i < _gMutualICSenseLineNum * _gMutualICDriveLineNum; i++)
+    {
+        //deltaC_result[i] = deltaC[i];
+        //_gMutualICResult[i] = 1673 * nCSub - _gMutualICDeltaC[i] * 2 / (nDriOpening + 1);
+        if (_gMutualICDeltaC[i] > 31000)
+        {
+            return -1; 
+        }
+        
+        _gMutualICResult[i] = 1673 * nCSub - _gMutualICDeltaC[i];
+    
+        // For mutual key, last column if not be used, show number "one".
+        if ((_gMsg28xx_MUTUAL_KEY == 1 || _gMsg28xx_MUTUAL_KEY == 2) && (_gMsg28xx_KEY_NUM != 0))
+        {
+            if ((_gMutualICSenseLineNum < _gMutualICDriveLineNum) && ((i + 1) % _gMutualICDriveLineNum == 0))
+            {
+                _gMutualICResult[i] = -32000;    
+                for (k = 0; k < _gMsg28xx_KEY_NUM; k++)
+                {
+                    if ((i + 1) / _gMutualICDriveLineNum == _gMsg28xx_KEYSEN[k])
+                    {
+                        //_gMutualICResult[i] = 1673 * nCSub - _gMutualICDeltaC[i] * 2 / (nDriOpening + 1);
+                        _gMutualICResult[i] = 1673 * nCSub - _gMutualICDeltaC[i];
+                    }    
+                }
+            }
+    
+            if ((_gMutualICSenseLineNum > _gMutualICDriveLineNum) && (i > (_gMutualICSenseLineNum - 1) * _gMutualICDriveLineNum - 1))
+            {
+                _gMutualICResult[i] = -32000;        
+                for (k = 0; k < _gMsg28xx_KEY_NUM; k++)
+                {
+                    if (((i + 1) - (_gMutualICSenseLineNum - 1) * _gMutualICDriveLineNum) == _gMsg28xx_KEYSEN[k])
+                    {
+                        //_gMutualICResult[i] = 1673 * nCSub - _gMutualICDeltaC[i] * 2 / (nDriOpening + 1);
+                        _gMutualICResult[i] = 1673 * nCSub - _gMutualICDeltaC[i];
+                    }    
+                }
+            }
+        }
+    }
+
+    if(_gMsg28xx_KEY_NUM > 0)
+    {
+        if(_gMutualICDriveLineNum >= _gMutualICSenseLineNum)
+        {
+            nRowNum = _gMutualICDriveLineNum-1;
+            nColumnNum = _gMutualICSenseLineNum;
+        }
+        else
+        {
+            nRowNum = _gMutualICDriveLineNum;
+            nColumnNum = _gMutualICSenseLineNum-1;
+        }
+    }
+    else
+    {
+        nRowNum = _gMutualICDriveLineNum;
+        nColumnNum = _gMutualICSenseLineNum;
+    }
+
+    DBG(&g_I2cClient->dev, "*** Msg28xx Open Test# Show _gMutualICResult ***\n"); 
+    //_DrvMpTestMutualICDebugShowArray(_gMutualICResult, nRowNum*nColumnNum, -32, 10, nColumnNum);
+    for (j = 0; j < _gMutualICDriveLineNum; j ++)
+    {
+        for (i = 0; i < _gMutualICSenseLineNum; i ++)
+        {
+            DBG(&g_I2cClient->dev, "%d  ", _gMutualICResult[i * _gMutualICDriveLineNum + j]);
+        }
+        DBG(&g_I2cClient->dev, "\n");                
+    } 
+
+    for (j = 0; j < nRowNum; j ++)
+    {
+        nSum = 0;
+        for (i = 0; i < nColumnNum; i++)
+        {
+             nSum = nSum + _gMutualICResult[i * _gMutualICDriveLineNum + j];                               
+        } 
+        
+        nAvg = nSum / nColumnNum;             
+        DBG(&g_I2cClient->dev, "*** Msg28xx Open Test# OpenJudge average=%d ***\n", nAvg);        
+        for (i = 0; i < nColumnNum; i ++)
+        {
+   	   	    if (0 == _DrvMpTestMutualICCheckValueInRange(_gMutualICResult[i * _gMutualICDriveLineNum + j], (s32)(nAvg + nAvg * MSG28XX_DC_RANGE/100), (s32)(nAvg - nAvg * MSG28XX_DC_RANGE/100)))
+   	   	    {
+                _gMutualICTestFailChannel[i * _gMutualICDriveLineNum + j] = 1;
+                _gTestFailChannelCount ++; 
+                nRetVal = -1;
+            }
+    
+            if (i > 0)
+            {
+                nDelta = _gMutualICResult[i * _gMutualICDriveLineNum + j] > nPrev ? (_gMutualICResult[i * _gMutualICDriveLineNum + j] - nPrev) : (nPrev - _gMutualICResult[i * _gMutualICDriveLineNum + j]);
+                if (nDelta > nPrev*MUTUAL_IC_FIR_RATIO/100)
+                {
+                    if (0 == _gMutualICTestFailChannel[i * _gMutualICDriveLineNum + j]) // for avoid _gTestFailChannelCount to be added twice
+                    {
+                        _gMutualICTestFailChannel[i * _gMutualICDriveLineNum + j] = 1;
+                        _gTestFailChannelCount ++; 
+                    }
+                    nRetVal = -1;
+                    DBG(&g_I2cClient->dev, "\nSense%d, Drive%d, MAX_Ratio = %d,%d\t", i, j, nDelta, nPrev);
+                }
+            }
+            nPrev = _gMutualICResult[i * _gMutualICDriveLineNum + j];
+        }
+    }  
+
+    //DBG(&g_I2cClient->dev, "*** Msg28xx Open Test# OpenJudge _gTestFailChannelCount=%d ***\n", _gTestFailChannelCount);    
+    return nRetVal;
+}
+
+static s32 _DrvMpTestItoTestMsg28xxCheckSwitchStatus(void)
+{
+    u32 nRegData = 0;
+    int nTimeOut = 280;
+    int nT = 0;
+
+    do
+    {
+        nRegData = RegGet16BitValue(0x1402);
+        mdelay(20);
+        nT++;
+        if (nT > nTimeOut)
+        {
+            return -1;
+        }
+
+    } while (nRegData != 0x7447);
+
+    return 0;
+}
+
+static s32 _DrvMpTestMsg28xxItoTestSwitchFwMode(u8 nFMode)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+   
+    RegSet16BitValue(0x0FE6, 0x0001);    //MCU_stop
+    mdelay(100);    
+    RegSet16BitValue(0X3C60, 0xAA55);    // disable watch dog
+
+    RegSet16BitValue(0X3D08, 0xFFFF);
+    RegSet16BitValue(0X3D18, 0xFFFF);
+            
+    RegSet16BitValue(0x1402, 0x7474);
+
+    RegSet16BitValue(0x1E06, 0x0000);
+    RegSet16BitValue(0x1E06, 0x0001);
+    //RegSet16BitValue((uint)0x1E04, (uint)0x7D60);
+    //RegSet16BitValue(0x1E04, 0x829F);
+    RegSet16BitValue(0x0FE6, 0x0000);
+    mdelay(150);
+
+    if (_DrvMpTestItoTestMsg28xxCheckSwitchStatus()<0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg28xx MP Test# CheckSwitchStatus failed! Enter MP mode failed ***\n");    
+        return -1;
+    }
+
+    if (_gMsg28xxDeepStandBy == 0)
+    {
+        //deep satndby mode
+        RegSet16BitValue(0x1402, 0x6179);
+        mdelay(600);
+
+        DbBusEnterSerialDebugMode();
+        DbBusWaitMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+
+        if (_DrvMpTestItoTestMsg28xxCheckSwitchStatus()<0)
+        {
+            _gMsg28xxDeepStandBy = -1;
+            DBG(&g_I2cClient->dev, "*** Msg28xx MP Test# Deep standby fail, fw not support DEEP STANDBY ***\n");    
+            return -1;
+        }
+    }
+
+    switch (nFMode)
+    {
+        case MUTUAL:
+            RegSet16BitValue(0x1402, 0x5705);
+            break;
+
+        case SELF:
+            RegSet16BitValue(0x1402, 0x6278);
+            break;
+
+        case WATERPROOF:
+            RegSet16BitValue(0x1402, 0x7992);
+            break;
+
+        case MUTUAL_SINGLE_DRIVE:
+            RegSet16BitValue(0x1402, 0x0158);
+            break;
+
+        default:
+            return -1;
+    }
+    if (_DrvMpTestItoTestMsg28xxCheckSwitchStatus()<0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg28xx MP Test# CheckSwitchStatus failed! Enter FW mode failed  ***\n");     
+        return -1;
+    }
+
+    RegSet16BitValue(0x0FE6, 0x0001);// stop mcu
+    RegSet16BitValue(0x3D08, 0xFEFF);//open timer
+
+    return 0;
+}
+
+u16 _DrvMpTestMsg28xxItoTestGetTpType(void)
+{
+    u16 nMajor = 0, nMinor = 0;
+    u8 szDbBusTxData[3] = {0};
+    u8 szDbBusRxData[4] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    szDbBusTxData[0] = 0x03;
+    
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 1);
+    IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+    
+    nMajor = (szDbBusRxData[1]<<8) + szDbBusRxData[0];
+    nMinor = (szDbBusRxData[3]<<8) + szDbBusRxData[2];
+
+    DBG(&g_I2cClient->dev, "*** major = %d ***\n", nMajor);
+    DBG(&g_I2cClient->dev, "*** minor = %d ***\n", nMinor);
+
+    return nMajor;
+}
+
+static u16 _DrvMpTestMsg28xxItoTestChooseTpType(void)
+{
+    u32 i = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    _gMsg28xx_SENSE_NUM = 0;
+    _gMsg28xx_DRIVE_NUM = 0;
+    _gMsg28xx_KEY_NUM = 0;
+    _gMsg28xx_KEY_LINE = 0;
+    _gMsg28xx_GR_NUM = 0;
+    _gMsg28xx_CSUB_REF = 0;
+    _gMsg28xx_SENSE_MUTUAL_SCAN_NUM = 0;
+    _gMsg28xx_MUTUAL_KEY = 0;
+    _gMsg28xx_PATTERN_TYPE = 0;
+    
+    _gMsg28xx_SHORT_N1_TEST_NUMBER = 0;
+    _gMsg28xx_SHORT_N2_TEST_NUMBER = 0;
+    _gMsg28xx_SHORT_S1_TEST_NUMBER = 0;
+    _gMsg28xx_SHORT_S2_TEST_NUMBER = 0;
+    _gMsg28xx_SHORT_TEST_5_TYPE = 0;
+    _gMsg28xx_SHORT_X_TEST_NUMBER = 0;
+                                                                                                                                        
+    _gMsg28xx_SHORT_N1_TEST_PIN = NULL;
+    _gMsg28xx_SHORT_N1_MUX_MEM_20_3E = NULL;
+    _gMsg28xx_SHORT_N2_TEST_PIN = NULL;
+    _gMsg28xx_SHORT_N2_MUX_MEM_20_3E = NULL;
+    _gMsg28xx_SHORT_S1_TEST_PIN = NULL;
+    _gMsg28xx_SHORT_S1_MUX_MEM_20_3E = NULL;
+    _gMsg28xx_SHORT_S2_TEST_PIN = NULL;
+    _gMsg28xx_SHORT_S2_MUX_MEM_20_3E = NULL;
+    _gMsg28xx_SHORT_X_TEST_PIN = NULL;
+    _gMsg28xx_SHORT_X_MUX_MEM_20_3E = NULL;                                                           
+                                   
+    _gMsg28xx_PAD_TABLE_DRIVE = NULL;
+    _gMsg28xx_PAD_TABLE_SENSE = NULL;
+    _gMsg28xx_PAD_TABLE_GR = NULL;
+                                   
+    _gMsg28xx_KEYSEN = NULL;
+    _gMsg28xx_KEYDRV = NULL;
+                                                                
+    //g_Msg28xxMapVaMutual = NULL;
+
+    for (i = 0; i < 10; i ++)
+    {
+        _gMsg28xxTpType = _DrvMpTestMsg28xxItoTestGetTpType();
+        DBG(&g_I2cClient->dev, "TP Type = %d, i = %d\n", _gMsg28xxTpType, i);
+
+        if (TP_TYPE_X == _gMsg28xxTpType || TP_TYPE_Y == _gMsg28xxTpType) // Modify.
+        {
+            break;
+        }
+        else if (i < 5)
+        {
+            mdelay(100);  
+        }
+        else
+        {
+            DrvPlatformLyrTouchDeviceResetHw();
+        }
+    }
+    
+    if (TP_TYPE_X == _gMsg28xxTpType) // Modify. 
+    {
+        DBG(&g_I2cClient->dev, "*** Choose Tp Type X ***\n");        
+        
+        _gMsg28xx_SENSE_NUM = SENSE_NUM_X;
+        _gMsg28xx_DRIVE_NUM = DRIVE_NUM_X;
+        _gMsg28xx_KEY_NUM = KEY_NUM_X;
+        _gMsg28xx_KEY_LINE = KEY_LINE_X;
+        _gMsg28xx_GR_NUM = GR_NUM_X;
+        _gMsg28xx_CSUB_REF = CSUB_REF_X;
+        _gMsg28xx_SENSE_MUTUAL_SCAN_NUM = SENSE_MUTUAL_SCAN_NUM_X;
+        _gMsg28xx_MUTUAL_KEY = MUTUAL_KEY_X;
+        _gMsg28xx_PATTERN_TYPE = PATTERN_TYPE_X;
+    
+        _gMsg28xx_SHORT_N1_TEST_NUMBER = SHORT_N1_TEST_NUMBER_X;
+        _gMsg28xx_SHORT_N2_TEST_NUMBER = SHORT_N2_TEST_NUMBER_X;
+        _gMsg28xx_SHORT_S1_TEST_NUMBER = SHORT_S1_TEST_NUMBER_X;
+        _gMsg28xx_SHORT_S2_TEST_NUMBER = SHORT_S2_TEST_NUMBER_X;
+        _gMsg28xx_SHORT_TEST_5_TYPE = SHORT_TEST_5_TYPE_X;
+        _gMsg28xx_SHORT_X_TEST_NUMBER = SHORT_X_TEST_NUMBER_X;
+                                                                                                                                            
+        _gMsg28xx_SHORT_N1_TEST_PIN = MSG28XX_SHORT_N1_TEST_PIN_X;
+        _gMsg28xx_SHORT_N1_MUX_MEM_20_3E = SHORT_N1_MUX_MEM_20_3E_X;
+        _gMsg28xx_SHORT_N2_TEST_PIN = MSG28XX_SHORT_N2_TEST_PIN_X;
+        _gMsg28xx_SHORT_N2_MUX_MEM_20_3E = SHORT_N2_MUX_MEM_20_3E_X;
+        _gMsg28xx_SHORT_S1_TEST_PIN = MSG28XX_SHORT_S1_TEST_PIN_X;
+        _gMsg28xx_SHORT_S1_MUX_MEM_20_3E = SHORT_S1_MUX_MEM_20_3E_X;
+        _gMsg28xx_SHORT_S2_TEST_PIN = MSG28XX_SHORT_S2_TEST_PIN_X;
+        _gMsg28xx_SHORT_S2_MUX_MEM_20_3E = SHORT_S2_MUX_MEM_20_3E_X;
+        _gMsg28xx_SHORT_X_TEST_PIN = MSG28XX_SHORT_X_TEST_PIN_X;
+        _gMsg28xx_SHORT_X_MUX_MEM_20_3E = SHORT_X_MUX_MEM_20_3E_X;                                                           
+                                       
+        _gMsg28xx_PAD_TABLE_DRIVE = PAD_TABLE_DRIVE_X;
+        _gMsg28xx_PAD_TABLE_SENSE = PAD_TABLE_SENSE_X;
+        _gMsg28xx_PAD_TABLE_GR = PAD_TABLE_GR_X;
+                                       
+        _gMsg28xx_KEYSEN = KEYSEN_X;
+        _gMsg28xx_KEYDRV = KEYDRV_X;
+                                                                    
+        //g_Msg28xxMapVaMutual = g_MapVaMutual_X;
+    }
+    else if (TP_TYPE_Y == _gMsg28xxTpType) // Modify. 
+    {
+        DBG(&g_I2cClient->dev, "*** Choose Tp Type Y ***\n");        
+        
+        _gMsg28xx_SENSE_NUM = SENSE_NUM_Y;
+        _gMsg28xx_DRIVE_NUM = DRIVE_NUM_Y;
+        _gMsg28xx_KEY_NUM = KEY_NUM_Y;
+        _gMsg28xx_KEY_LINE = KEY_LINE_Y;
+        _gMsg28xx_GR_NUM = GR_NUM_Y;
+        _gMsg28xx_CSUB_REF = CSUB_REF_Y;
+        _gMsg28xx_SENSE_MUTUAL_SCAN_NUM = SENSE_MUTUAL_SCAN_NUM_Y;
+        _gMsg28xx_MUTUAL_KEY = MUTUAL_KEY_Y;
+        _gMsg28xx_PATTERN_TYPE = PATTERN_TYPE_Y;
+    
+        _gMsg28xx_SHORT_N1_TEST_NUMBER = SHORT_N1_TEST_NUMBER_Y;
+        _gMsg28xx_SHORT_N2_TEST_NUMBER = SHORT_N2_TEST_NUMBER_Y;
+        _gMsg28xx_SHORT_S1_TEST_NUMBER = SHORT_S1_TEST_NUMBER_Y;
+        _gMsg28xx_SHORT_S2_TEST_NUMBER = SHORT_S2_TEST_NUMBER_Y;
+        _gMsg28xx_SHORT_TEST_5_TYPE = SHORT_TEST_5_TYPE_Y;
+        _gMsg28xx_SHORT_X_TEST_NUMBER = SHORT_X_TEST_NUMBER_Y;
+                                                                                                                                            
+        _gMsg28xx_SHORT_N1_TEST_PIN = MSG28XX_SHORT_N1_TEST_PIN_Y;
+        _gMsg28xx_SHORT_N1_MUX_MEM_20_3E = SHORT_N1_MUX_MEM_20_3E_Y;
+        _gMsg28xx_SHORT_N2_TEST_PIN = MSG28XX_SHORT_N2_TEST_PIN_Y;
+        _gMsg28xx_SHORT_N2_MUX_MEM_20_3E = SHORT_N2_MUX_MEM_20_3E_Y;
+        _gMsg28xx_SHORT_S1_TEST_PIN = MSG28XX_SHORT_S1_TEST_PIN_Y;
+        _gMsg28xx_SHORT_S1_MUX_MEM_20_3E = SHORT_S1_MUX_MEM_20_3E_Y;
+        _gMsg28xx_SHORT_S2_TEST_PIN = MSG28XX_SHORT_S2_TEST_PIN_Y;
+        _gMsg28xx_SHORT_S2_MUX_MEM_20_3E = SHORT_S2_MUX_MEM_20_3E_Y;
+        _gMsg28xx_SHORT_X_TEST_PIN = MSG28XX_SHORT_X_TEST_PIN_Y;
+        _gMsg28xx_SHORT_X_MUX_MEM_20_3E = SHORT_X_MUX_MEM_20_3E_Y;                                                           
+                                       
+        _gMsg28xx_PAD_TABLE_DRIVE = PAD_TABLE_DRIVE_Y;
+        _gMsg28xx_PAD_TABLE_SENSE = PAD_TABLE_SENSE_Y;
+        _gMsg28xx_PAD_TABLE_GR = PAD_TABLE_GR_Y;
+                                       
+        _gMsg28xx_KEYSEN = KEYSEN_Y;
+        _gMsg28xx_KEYDRV = KEYDRV_Y;
+                                                                    
+        //g_Msg28xxMapVaMutual = g_MapVaMutual_Y;
+    }
+    else
+    {
+        _gMsg28xxTpType = 0;
+    }
+    
+    return _gMsg28xxTpType;
+}
+
+s32 _DrvMpTestMsg28xxItoOpenTestEntry(void)
+{
+    s32 nRetVal = 0;
+//    u8 nDrvOpening = 0;
+    //u16 nCheckState = 0;
+    u16 nTime = 0;    
+    s8 nNormalTestResult[8][2] = {{0}};    //0:golden    1:ratio
+    u16 nNormalTestResultCheck[6][13] = {{0}};        //6:max subframe    13:max afe
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    _gMsg28xxDeepStandBy = 0;
+    DrvPlatformLyrDisableFingerTouchReport();
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    if (!_DrvMpTestMsg28xxItoTestChooseTpType())
+    {
+        DBG(&g_I2cClient->dev, "Choose Tp Type failed\n");
+        nRetVal = -2;
+        goto ITO_TEST_END;
+    }
+
+    _gMutualICSenseLineNum = _gMsg28xx_SENSE_NUM;        
+    _gMutualICDriveLineNum = _gMsg28xx_DRIVE_NUM;
+
+_RETRY_OPEN:
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    //reset only
+    DbBusResetSlave();
+    DbBusEnterSerialDebugMode();
+    //DbBusWaitMCU();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);    
+
+    // Stop mcu
+    RegSet16BitValue(0x0FE6, 0x0001);
+
+    if(_DrvMpTestMsg28xxItoTestSwitchFwMode(MUTUAL) < 0)
+    {
+        nTime++;
+        if(nTime < 5)
+        {
+            goto _RETRY_OPEN;
+        }    
+        DBG(&g_I2cClient->dev, "*** Msg28xx Open Test# Switch Fw Mode failed! ***\n");
+        nRetVal = -1;
+        goto ITO_TEST_END;
+    }
+
+    //nDrvOpening = RegGetLByteValue(0x1312);
+
+    if(_DrvMpTestMsg28xxItoOpenTest() < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg28xx Open Test# OpenTest failed! ***\n");
+        nRetVal = -1;
+        goto ITO_TEST_END;
+    }
+    
+    mdelay(10);
+
+    nRetVal = _DrvMpTestItoOpenTestMsg28xxOpenJudge(0, nNormalTestResult, nNormalTestResultCheck/*, nDrvOpening*/);
+    DBG(&g_I2cClient->dev, "*** Msg28xx Open Test# OpenTestOpenJudge return value = %d ***\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+    
+ITO_TEST_END:    
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    mdelay(300);
+    
+    DrvPlatformLyrEnableFingerTouchReport();
+
+    return nRetVal;
+}
+
+static void _DrvMpTestItoShortTestMsg28xxSetNoiseSensorMode(u8 nEnable)
+{
+    s16 j;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);    
+
+    if (nEnable)
+    {
+        RegSet16BitValueOn(0x1546, BIT4);
+        for (j = 0; j < 10; j++)
+        {
+            RegSet16BitValue(0x2148 + 2 * j, 0x0000);
+        }
+        RegSet16BitValue(0x215C, 0x1FFF);
+    }
+}
+
+static void _DrvMpTestItoShortTestMsg28xxAnaFixPrs(u16 nOption)
+{
+    u16 nRegData = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    RegSet16BitValue(0x0FE6, 0x0001);
+
+    nRegData = RegGet16BitValue(0x1008);
+    nRegData &= 0x00F1;
+    nRegData |= (u16)((nOption << 1) & 0x000E);
+    RegSet16BitValue(0x1008, nRegData);
+}
+
+static void _DrvMpTestItoShortTestMsg28xxAndChangeCDtime(u16 nTime1, u16 nTime2)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    RegSet16BitValue(0x1026, nTime1);
+    RegSet16BitValue(0x1030, nTime2);
+}
+
+static void _DrvMpTestItoShortTestMsg28xxChangeANASetting(void)
+{
+    int i, nMappingItem; 
+    u8 nChipVer;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // Stop mcu
+    RegSet16BitValue(0x0FE6, 0x0001); //bank:mheg5, addr:h0073
+    
+    nChipVer = RegGetLByteValue(0x1ECE);
+    //uint chip_ver = Convert.ToUInt16((uint)regdata[0]); //for U01 (SF shift).
+    
+    if (nChipVer != 0)
+        RegSetLByteValue(0x131E, 0x01);
+    
+    for (nMappingItem = 0; nMappingItem < 6; nMappingItem++)
+    {
+        /// sensor mux sram read/write base address / write length
+        RegSetLByteValue(0x2192, 0x00);
+        RegSetLByteValue(0x2102, 0x01);
+        RegSetLByteValue(0x2102, 0x00);
+        RegSetLByteValue(0x2182, 0x08);
+        RegSetLByteValue(0x2180, 0x08 * nMappingItem);
+        RegSetLByteValue(0x2188, 0x01);
+    
+        for (i = 0; i < 8; i++)
+        {
+            if (nMappingItem == 0 && nChipVer == 0x0)
+            {
+                RegSet16BitValue(0x218A, _gMsg28xxMuxMem_20_3E_0_Settings[2 * i]);
+                RegSet16BitValue(0x218C, _gMsg28xxMuxMem_20_3E_0_Settings[2 * i + 1]);
+            }
+            if ((nMappingItem == 1 && nChipVer == 0x0) || (nMappingItem == 0 && nChipVer != 0x0))
+            {
+                RegSet16BitValue(0x218A, _gMsg28xxMuxMem_20_3E_1_Settings[2 * i]);
+                RegSet16BitValue(0x218C, _gMsg28xxMuxMem_20_3E_1_Settings[2 * i + 1]);
+            }
+            if ((nMappingItem == 2 && nChipVer == 0x0) || (nMappingItem == 1 && nChipVer != 0x0))
+            {
+                RegSet16BitValue(0x218A, _gMsg28xxMuxMem_20_3E_2_Settings[2 * i]);
+                RegSet16BitValue(0x218C, _gMsg28xxMuxMem_20_3E_2_Settings[2 * i + 1]);
+            }
+            if ((nMappingItem == 3 && nChipVer == 0x0) || (nMappingItem == 2 && nChipVer != 0x0))
+            {
+                RegSet16BitValue(0x218A, _gMsg28xxMuxMem_20_3E_3_Settings[2 * i]);
+                RegSet16BitValue(0x218C, _gMsg28xxMuxMem_20_3E_3_Settings[2 * i + 1]);
+            }
+            if ((nMappingItem == 4 && nChipVer == 0x0) || (nMappingItem == 3 && nChipVer != 0x0))
+            {
+                RegSet16BitValue(0x218A, _gMsg28xxMuxMem_20_3E_4_Settings[2 * i]);
+                RegSet16BitValue(0x218C, _gMsg28xxMuxMem_20_3E_4_Settings[2 * i + 1]);
+            }
+            if ((nMappingItem == 5 && nChipVer == 0x0) || (nMappingItem == 4 && nChipVer != 0x0))
+            {
+                RegSet16BitValue(0x218A, _gMsg28xxMuxMem_20_3E_5_Settings[2 * i]);
+                RegSet16BitValue(0x218C, _gMsg28xxMuxMem_20_3E_5_Settings[2 * i + 1]);
+            }
+            if (nMappingItem == 5 && nChipVer != 0x0)
+            {
+                RegSet16BitValue(0x218A, _gMsg28xxMuxMem_20_3E_6_Settings[2 * i]);
+                RegSet16BitValue(0x218C, _gMsg28xxMuxMem_20_3E_6_Settings[2 * i + 1]);
+            }
+        }
+    }
+}
+
+static void _DrvMpTestMsg28xxItoReadSetting(u16 * pPad2Sense, u16 * pPad2Drive, u16 * pPad2GR)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    memcpy(_gMsg28xxMuxMem_20_3E_1_Settings, _gMsg28xx_SHORT_N1_MUX_MEM_20_3E, sizeof(u16) * 16);
+    memcpy(_gMsg28xxMuxMem_20_3E_2_Settings, _gMsg28xx_SHORT_N2_MUX_MEM_20_3E, sizeof(u16) * 16);
+    memcpy(_gMsg28xxMuxMem_20_3E_3_Settings, _gMsg28xx_SHORT_S1_MUX_MEM_20_3E, sizeof(u16) * 16);
+    memcpy(_gMsg28xxMuxMem_20_3E_4_Settings, _gMsg28xx_SHORT_S2_MUX_MEM_20_3E, sizeof(u16) * 16);
+
+    if(_gMsg28xx_SHORT_TEST_5_TYPE != 0)
+    {
+        memcpy(_gMsg28xxMuxMem_20_3E_5_Settings, _gMsg28xx_SHORT_X_MUX_MEM_20_3E, sizeof(u16) * 16);
+    }
+
+    memcpy(pPad2Sense, _gMsg28xx_PAD_TABLE_SENSE, sizeof(u16) * _gMutualICSenseLineNum);
+    memcpy(pPad2Drive, _gMsg28xx_PAD_TABLE_DRIVE, sizeof(u16) * _gMutualICDriveLineNum);
+
+    if (_gMsg28xx_GR_NUM != 0)
+    {
+        memcpy(pPad2GR, _gMsg28xx_PAD_TABLE_GR, sizeof(u16) * _gMsg28xx_GR_NUM);
+    }
+}
+
+static s32 _DrvMpTestItoShortTestMsg28xxGetValueR(s32 * pTarget)
+{    
+    s16 * pRawData = NULL;
+    u16 nSenNumBak = 0;
+    u16 nDrvNumBak = 0;     
+    u16 nShift = 0;
+    s16 i, j;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    pRawData = kzalloc(sizeof(s16) * MUTUAL_IC_MAX_CHANNEL_SEN*2 * MUTUAL_IC_MAX_CHANNEL_DRV, GFP_KERNEL);
+
+    if (_DrvMpTestItoTestMsg28xxGetMutualOneShotRawIIR(pRawData, &nSenNumBak, &nDrvNumBak) < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg28xx Short Test# GetMutualOneShotRawIIR failed! ***\n");                    
+        return -1;
+    }
+    
+    for (i = 0; i < 5; i++)
+    {
+        for (j = 0; j < 13; j++)
+        {
+            nShift = (u16)(j + 13 * i);
+            pTarget[nShift] = pRawData[i*MUTUAL_IC_MAX_CHANNEL_DRV+j];
+        }
+    }
+
+    kfree(pRawData);
+
+    return 0;
+}
+
+static s32 _DrvMpTestMsg28xxItoShortTest(u8 nItemID)
+{
+    s16 i;
+    u8 nRegData = 0;
+    u16 nAfeCoef = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);    
+
+    // Stop mcu
+    RegSet16BitValue(0x0FE6, 0x0001); //bank:mheg5, addr:h0073
+
+    ///set Subframe = 6 ; Sensor = 13
+    RegSetLByteValue(0x130A, 0x6D);
+    RegSetLByteValue(0x1103, 0x06);
+    RegSetLByteValue(0x1016, 0x0C);
+
+    RegSetLByteValue(0x1104, 0x0C);
+    RegSetLByteValue(0x100C, 0x0C);
+    RegSetLByteValue(0x1B10, 0x0C);
+
+    /// adc analog+digital pipe delay, 60= 13 AFE.
+    RegSetLByteValue(0x102F, 0x60);
+
+    ///trim: Fout 52M &  1.2V
+    RegSet16BitValue(0x1420, 0xA55A);//password
+    RegSet16BitValue(0x1428, 0xA55A);//password
+    RegSet16BitValue(0x1422, 0xFC4C);//go
+
+    _DrvMpTestItoShortTestMsg28xxSetNoiseSensorMode(1);    
+    _DrvMpTestItoShortTestMsg28xxAnaFixPrs(3);    
+    _DrvMpTestItoShortTestMsg28xxAndChangeCDtime(0x007E, 0x001F);    
+
+    ///DAC overwrite
+    RegSet16BitValue(0x150C, 0x80A2); //bit15 //AE:3.5v for test
+    RegSet16BitValue(0x1520, 0xFFFF);//After DAC overwrite, output DC
+    RegSet16BitValue(0x1522, 0xFFFF);
+    RegSet16BitValue(0x1524, 0xFFFF);
+    RegSet16BitValue(0x1526, 0xFFFF);
+
+    /// all AFE Cfb use defalt (50p)
+    RegSet16BitValue(0x1508, 0x1FFF);// all AFE Cfb: SW control
+    RegSet16BitValue(0x1550, 0x0000);// all AFE Cfb use defalt (50p)
+
+    /// reg_afe_icmp disenable
+    RegSet16BitValue(0x1552, 0x0000);
+
+    /// reg_hvbuf_sel_gain
+    RegSet16BitValue(0x1564, 0x0077);
+
+    ///ADC: AFE Gain bypass
+    RegSet16BitValue(0x1260, 0x1FFF);
+
+    ///reg_sel_ros disenable
+    RegSet16BitValue(0x156A, 0x0000);
+
+    ///reg_adc_desp_invert disenable
+    RegSetLByteValue(0x1221, 0x00);
+
+
+    ///AFE coef
+    //protoHandle.MstarReadReg(mdkDevice, (uint)0x101A, ref regdata);
+    nRegData = RegGetLByteValue(0x101A);
+    nAfeCoef = 0x10000 / nRegData;
+    //protoHandle.MstarWriteReg_16(mdkDevice, (uint)0x13D6, AFE_coef);
+    RegSet16BitValue(0x13D6, nAfeCoef);
+    
+    /// AFE gain = 1X
+    //RegSet16BitValue(0x1318, 0x4440);
+    //RegSet16BitValue(0x131A, 0x4444);
+    //RegSet16BitValue(0x13D6, 0x2000);
+
+    _DrvMpTestItoShortTestMsg28xxChangeANASetting();
+    _DrvMpTestItoTestMsg28xxAnaSwReset();
+
+    if (_DrvMpTestItoShortTestMsg28xxGetValueR(_gMutualICDeltaC)<0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg28xx Short Test# GetValueR failed! ***\n");      
+        return -1;
+    }
+    _DrvMpTestMutualICDebugShowArray(_gMutualICDeltaC, 128, -32, 10, 8);
+
+    for (i = 0; i < 65; i++) // 13 AFE * 5 subframe
+    {
+        if (_gMutualICDeltaC[i] <= -1000 || _gMutualICDeltaC[i] >= (MUTUAL_IC_IIR_MAX))
+            _gMutualICDeltaC[i] = 0x7FFF;
+        else
+            _gMutualICDeltaC[i] = abs(_gMutualICDeltaC[i]);
+    }
+    return 0;
+}
+
+static s32 _DrvMpTestItoShortTestMsg28xxReadTestPins(u8 nItemID, u16 * pTestPins)
+{    
+    u16 nCount = 0;
+    s16 i;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    switch (nItemID)
+    {
+        case 1:
+        case 11:
+            nCount = _gMsg28xx_SHORT_N1_TEST_NUMBER;            
+            memcpy(pTestPins, _gMsg28xx_SHORT_N1_TEST_PIN, sizeof(u16) * nCount);
+            break;
+        case 2:
+        case 12:
+            nCount = _gMsg28xx_SHORT_N2_TEST_NUMBER;            
+            memcpy(pTestPins, _gMsg28xx_SHORT_N2_TEST_PIN, sizeof(u16) * nCount);
+            break;
+        case 3:
+        case 13:
+            nCount = _gMsg28xx_SHORT_S1_TEST_NUMBER;            
+            memcpy(pTestPins, _gMsg28xx_SHORT_S1_TEST_PIN, sizeof(u16) * nCount);
+            break;
+        case 4:
+        case 14:
+            nCount = _gMsg28xx_SHORT_S2_TEST_NUMBER;            
+            memcpy(pTestPins, _gMsg28xx_SHORT_S2_TEST_PIN, sizeof(u16) * nCount);
+            break;
+    
+        case 5:
+        case 15:
+            if(_gMsg28xx_SHORT_TEST_5_TYPE != 0)
+            {
+                nCount = _gMsg28xx_SHORT_X_TEST_NUMBER;            
+                memcpy(pTestPins, _gMsg28xx_SHORT_X_TEST_PIN, sizeof(u16) * nCount);
+            }    
+            break;
+
+        case 0:
+        default:
+            return 0;
+    }
+
+    for (i = nCount; i < MUTUAL_IC_MAX_CHANNEL_NUM; i++)
+    {
+        pTestPins[i] = 0xFFFF;    //PIN_NO_ERROR
+    }
+    
+    return nCount;
+}
+
+static s32 _DrvMpTestItoShortTestMsg28xxJudge(u8 nItemID, /*s8 pNormalTestResult[][2],*/ u16 pTestPinMap[][13], u16 * pTestPinCount)
+{
+    s32 nRetVal = 0;
+    u16 nTestPins[MUTUAL_IC_MAX_CHANNEL_NUM];
+    s16 i; 
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    *pTestPinCount = _DrvMpTestItoShortTestMsg28xxReadTestPins(nItemID, nTestPins);
+    //_DrvMpTestMutualICDebugShowArray(nTestPins, *pTestPinCount, 16, 10, 8);    
+    if (*pTestPinCount == 0)
+    {
+        if (nItemID == 5 && _gMsg28xx_SHORT_TEST_5_TYPE == 0)
+        {
+
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "*** Msg28xx Short Test# TestPinCount = 0 ***\n");       
+            return -1;
+        }
+    }
+
+  /*  
+    u16 nCountTestPin = 0;    
+    for (i = 0; i < testPins.Length; i++)
+    {
+        if (pTestPins[i] != 0xFFFF)
+            nCountTestPin++;
+    }
+   */ 
+    
+    for (i = (nItemID - 1) * 13; i < (13 * nItemID); i++)
+    {
+        _gMutualICResult[i] = _gMutualICDeltaC[i];
+    }
+    
+    for (i = 0; i < *pTestPinCount; i++)
+    {
+        pTestPinMap[nItemID][i] = nTestPins[i];    
+   	   	if (0 == _DrvMpTestMutualICCheckValueInRange(_gMutualICResult[i + (nItemID - 1) * 13], MSG28XX_SHORT_VALUE, -1000))    //0: false   1: true
+        {
+            //pNormalTestResult[nItemID][0] = -1;    //-1: failed   0: success 
+            //                         //0: golden   1: ratio
+            DBG(&g_I2cClient->dev, "*** Msg28xx Short Test# ShortTestMsg28xxJudge failed! ***\n");             
+            nRetVal = -1;
+        }
+    }
+
+    DBG(&g_I2cClient->dev, "*** Msg28xx Short Test# nItemID = %d ***\n", nItemID);        
+    //_DrvMpTestMutualICDebugShowArray(pTestPinMap[nItemID], *pTestPinCount, 16, 10, 8);
+    
+    return nRetVal;
+}
+
+static s32 _DrvMpTestItoShortTestMsg28xxCovertRValue(s32 nValue)
+{
+   	if (nValue >= MUTUAL_IC_IIR_MAX)
+   	{
+   	   	return 0;
+   	}
+
+    //return ((3.53 - 1.3) * 10 / (50 * (((float)nValue - 0 ) / 32768 * 1.1)));
+    return 223 * 32768 / (nValue * 550);
+}
+
+static s32 _DrvMpTestMsg28xxItoShortTestEntry(void)
+{
+    //ItoTestResult_e nRetVal1 = ITO_TEST_OK, nRetVal2 = ITO_TEST_OK, nRetVal3 = ITO_TEST_OK, nRetVal4 = ITO_TEST_OK, nRetVal5 = ITO_TEST_OK;
+    s16 i = 0, j = 0;
+    //u16 nTestPinCount = 0;
+    //s32 nShortThreshold = 0;
+    u16 *pPad2Drive = NULL;
+    u16 *pPad2Sense = NULL;
+    u16 nTime = 0;    
+    u16 nPad2GR[MUTUAL_IC_MAX_CHANNEL_NUM] = {0};
+    s32 nResultTemp[(MUTUAL_IC_MAX_CHANNEL_SEN+MUTUAL_IC_MAX_CHANNEL_DRV)*2] = {0};
+
+    ///short test1 to 5.
+    //u16 nTestPinCount = 0;
+    u16 nTestItemLoop = 6;
+    u16 nTestItem = 0; 
+    //s8 nNormalTestResult[8][2] = {0};    //0:golden    1:ratio
+    u16 nTestPinMap[6][13] = {{0}};        //6:max subframe    13:max afe
+    u16 nTestPinNum = 0;
+//    s32 nThrs = 0;
+    u32 nRetVal = 0;
+        
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    _gMsg28xxDeepStandBy = 0;
+    DrvPlatformLyrDisableFingerTouchReport();
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    if (!_DrvMpTestMsg28xxItoTestChooseTpType())
+    {
+        DBG(&g_I2cClient->dev, "Choose Tp Type failed\n");
+        DrvPlatformLyrTouchDeviceResetHw();    
+        DrvPlatformLyrEnableFingerTouchReport();         
+        return -2;
+    }
+
+    pPad2Drive = kzalloc(sizeof(s16) * _gMsg28xx_DRIVE_NUM, GFP_KERNEL);
+    pPad2Sense = kzalloc(sizeof(s16) * _gMsg28xx_SENSE_NUM, GFP_KERNEL);
+    _gMutualICSenseLineNum = _gMsg28xx_SENSE_NUM;
+    _gMutualICDriveLineNum = _gMsg28xx_DRIVE_NUM;
+
+_RETRY_SHORT:
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    //reset only
+    DbBusResetSlave();
+    DbBusEnterSerialDebugMode();
+    DbBusWaitMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    if(_DrvMpTestMsg28xxItoTestSwitchFwMode(MUTUAL_SINGLE_DRIVE) < 0)
+    {
+        nTime++;
+        if(nTime < 5)
+        {
+            goto _RETRY_SHORT;
+        }    
+        DBG(&g_I2cClient->dev, "*** Msg28xx Short Test# Switch Fw Mode failed! ***\n");
+        nRetVal = -1;
+
+        goto ITO_TEST_END;
+    }
+
+    _DrvMpTestMsg28xxItoReadSetting(pPad2Sense, pPad2Drive, nPad2GR);
+
+
+	//N1_ShortTest    
+    if(_DrvMpTestMsg28xxItoShortTest(1) < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg28xx Short Test# Get DeltaC failed! ***\n");
+        nRetVal = -1;
+        goto ITO_TEST_END;      
+    }
+
+    for (nTestItem = 1; nTestItem < nTestItemLoop; nTestItem++)
+    {
+        DBG(&g_I2cClient->dev, "*** Short test item %d ***\n", nTestItem);
+        if (_DrvMpTestItoShortTestMsg28xxJudge(nTestItem, /*nNormalTestResult,*/ nTestPinMap, &nTestPinNum) < 0)
+        {
+            DBG(&g_I2cClient->dev, "*** Msg28xx Short Test# Item %d is failed! ***\n", nTestItem);
+            nRetVal = -1;
+            goto ITO_TEST_END;  
+        }
+
+        if (nTestItem == 1 || nTestItem == 2 || (nTestItem == 5 && _gMsg28xx_SHORT_TEST_5_TYPE == 1))
+        {
+            for (i = 0; i < nTestPinNum; i++)
+            {
+                for (j = 0; j < _gMutualICSenseLineNum; j++)
+                {
+                    if (nTestPinMap[nTestItem][i] == pPad2Sense[j])
+                    {
+                        //_gMutualICSenseR[j] = _DrvMpTestItoShortTestMsg28xxCovertRValue(_gMutualICResult[i + (nTestItem - 1) * 13]);
+                        _gMutualICSenseR[j] = _gMutualICResult[i + (nTestItem - 1) * 13];    //change comparison way because float computing in driver is prohibited
+                    }
+                }
+            }
+        }
+
+        if (nTestItem == 3 || nTestItem == 4 || (nTestItem == 5 && _gMsg28xx_SHORT_TEST_5_TYPE == 2))
+        {
+            for (i = 0; i < nTestPinNum; i++)
+            {
+                for (j = 0; j < _gMutualICDriveLineNum; j++)
+                {
+                    if (nTestPinMap[nTestItem][i] == pPad2Drive[j])
+                    {
+                        //_gMutualICDriveR[j] = _DrvMpTestItoShortTestMsg28xxCovertRValue(_gMutualICResult[i + (nTestItem - 1) * 13]);
+                        _gMutualICDriveR[j] = _gMutualICResult[i + (nTestItem - 1) * 13];    //change comparison way because float computing in driver is prohibited
+                    }
+                }
+            }
+        }
+
+        if (nTestItem == 5 && _gMsg28xx_SHORT_TEST_5_TYPE == 3)
+        {
+            for (i = 0; i < nTestPinNum; i++)
+            {
+                for (j = 0; j < _gMsg28xx_GR_NUM; j++)
+                {
+                    if (nTestPinMap[nTestItem][i] == nPad2GR[j])
+                    {
+                        //_gMutualICGRR[j] = _DrvMpTestItoShortTestMsg28xxCovertRValue(_gMutualICResult[i + (nTestItem - 1) * 13]);
+                        _gMutualICGRR[j] = _gMutualICResult[i + (nTestItem - 1) * 13];    //change comparison way because float computing in driver is prohibited
+                    }
+                }
+            }
+        }
+    }
+
+    for (i = 0; i < _gMutualICSenseLineNum; i++)
+    {
+        nResultTemp[i] = _gMutualICSenseR[i];
+    }
+
+    //for (i = 0; i < _gMutualICDriveLineNum - 1; i++)
+    for (i = 0; i < _gMutualICDriveLineNum; i++)
+    {
+        nResultTemp[i + _gMutualICSenseLineNum] = _gMutualICDriveR[i];
+    }
+
+    //nThrs = _DrvMpTestItoShortTestMsg28xxCovertRValue(MSG28XX_SHORT_VALUE);     
+    for (i = 0; i < _gMutualICSenseLineNum + _gMutualICDriveLineNum; i++)
+    {
+        if(nResultTemp[i] == 0)
+        {        
+            _gMutualICResult[i] = _DrvMpTestItoShortTestMsg28xxCovertRValue(1);
+        }
+        else
+        {
+            _gMutualICResult[i] = _DrvMpTestItoShortTestMsg28xxCovertRValue(nResultTemp[i]);
+        }
+    }
+
+    _DrvMpTestMutualICDebugShowArray(_gMutualICResult, _gMutualICSenseLineNum + _gMutualICDriveLineNum, -32, 10, 8);
+    //for (i = 0; i < (_gMutualICSenseLineNum + _gMutualICDriveLineNum - 1); i++)
+    for (i = 0; i < (_gMutualICSenseLineNum + _gMutualICDriveLineNum); i++)        
+    {
+        if (nResultTemp[i] > MSG28XX_SHORT_VALUE)    //change comparison way because float computing in driver is prohibited
+        {
+            _gMutualICTestFailChannel[i] = 1;
+            _gTestFailChannelCount++;
+            nRetVal = -1;
+        }
+        else
+        {
+            _gMutualICTestFailChannel[i] = 0;
+        }
+    }
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+ITO_TEST_END:
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    mdelay(300);
+
+    DrvPlatformLyrEnableFingerTouchReport();
+    kfree(pPad2Sense);
+    kfree(pPad2Drive);    
+
+    return nRetVal;
+}
+
+static s32 _DrvMpTestItoWaterProofTestMsg28xxTriggerWaterProofOneShot(s16 * pResultData, u32 nDelay)
+{
+    u16 nAddr = 0x5000, nAddrNextSF = 0x1A4;
+    u16 nSF = 0, nAfeOpening = 0, nDriOpening = 0;
+    u16 nMaxDataNumOfOneSF = 0;
+    u16 nDriMode = 0;
+    u16 i;
+    u8 nRegData = 0;
+    u8 nShotData[390] = {0};//13*15*2
+    u16 nRegDataU16 = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nRegData = RegGetLByteValue(0x130A);
+    nSF = nRegData>>4;
+    nAfeOpening = nRegData & 0x0f;
+
+    if(nSF == 0)
+    {
+        return -1;
+    }
+
+    nRegData = RegGetLByteValue(0x100B);
+    nDriMode = nRegData;
+
+    nRegData = RegGetLByteValue(0x1312);
+    nDriOpening = nRegData;
+
+    DBG(&g_I2cClient->dev, "*** Msg28xx WaterProof Test# TriggerWaterProofOneShot nSF=%d, nAfeOpening=%d, nDriMode=%d, nDriOpening=%d. ***\n", nSF, nAfeOpening, nDriMode, nDriOpening);
+
+    nMaxDataNumOfOneSF = nAfeOpening * nDriOpening;
+
+    RegSet16BitValueOff(0x3D08, BIT8);      ///FIQ_E_FRAME_READY_MASK
+
+    ///polling frame-ready interrupt status
+    _DrvMpTestItoTestMsg28xxEnableAdcOneShot();
+
+    while (0x0000 == (nRegDataU16 & BIT8))
+    {
+        nRegDataU16 = RegGet16BitValue(0x3D18);
+    }
+
+    RegSet16BitValueOn(0x3D08, BIT8);      ///FIQ_E_FRAME_READY_MASK
+    RegSet16BitValueOn(0x3D08, BIT4);      ///FIQ_E_TIMER0_MASK
+
+    if (_gMsg28xx_PATTERN_TYPE == 1) // for short test
+    {
+        //s16 nShortResultData[nSF][nAfeOpening];
+
+        /// get ALL raw data
+        _DrvMpTestItoTestDBBusReadDQMemStart();
+        RegGetXBitValue(nAddr, nShotData, 16, MAX_I2C_TRANSACTION_LENGTH_LIMIT);
+        _DrvMpTestItoTestDBBusReadDQMemEnd();
+
+        //_DrvMpTestMutualICDebugShowArray(nShotData, 26, 8, 16, 16);
+        for (i = 0; i < 8; i++)
+        {
+            pResultData[i] = (s16)(nShotData[2 * i] | nShotData[2 * i + 1] << 8);
+        }
+    }
+    else if(_gMsg28xx_PATTERN_TYPE == 3 || _gMsg28xx_PATTERN_TYPE == 4)// for open test
+    {
+        //s16 nOpenResultData[nSF * nAfeOpening][nDriOpening];
+
+        if(nSF >4)
+            nSF = 4;
+
+        /// get ALL raw data, combine and handle datashift.
+        for (i = 0; i < nSF; i++)
+        {
+            _DrvMpTestItoTestDBBusReadDQMemStart();
+            RegGetXBitValue(nAddr + i * nAddrNextSF, nShotData, 16, MAX_I2C_TRANSACTION_LENGTH_LIMIT);
+            _DrvMpTestItoTestDBBusReadDQMemEnd();
+
+            //_DrvMpTestMutualICDebugShowArray(nShotData, 390, 8, 10, 16);
+            pResultData[2 * i] = (s16)(nShotData[4 * i] | nShotData[4 * i + 1] << 8);
+            pResultData[2 * i + 1] = (s16)(nShotData[4 * i + 2] | nShotData[4 * i + 3] << 8);
+        }
+    }
+    else
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+static s32 _DrvMpTestItoWaterProofTesMsg28xxtGetWaterProofOneShotRawIIR(s16 * pRawDataWP, u32 nDelay)
+{
+    return _DrvMpTestItoWaterProofTestMsg28xxTriggerWaterProofOneShot(pRawDataWP, nDelay);
+}
+
+static s32 _DrvMpTestItoWaterProofTestMsg28xxGetDeltaCWP(s32 *pTarget, s8 nSwap, u32 nDelay)
+{
+    s16 nRawDataWP[12] = {0};
+    s16 i;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if(_DrvMpTestItoWaterProofTesMsg28xxtGetWaterProofOneShotRawIIR(nRawDataWP, nDelay) < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg28xx Open Test# GetMutualOneShotRawIIR failed! ***\n");
+        return -1;
+    }
+
+    for (i = 0; i < _gMutualICWaterProofNum; i++)
+    {
+        pTarget[i] = nRawDataWP[i];
+    }
+
+    return 0;
+}
+
+static s32 _DrvMpTestMsg28xxItoWaterProofTest(u32 nDelay)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // Stop mcu
+    RegSet16BitValue(0x0FE6, 0x0001); //bank:mheg5, addr:h0073
+    _DrvMpTestItoTestMsg28xxAnaSwReset();
+
+    if (_DrvMpTestItoWaterProofTestMsg28xxGetDeltaCWP(_gMutualICDeltaCWater, -1, nDelay)<0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg28xx WaterProof Test# GetDeltaCWP failed! ***\n");
+        return -1;
+    }
+
+    _DrvMpTestMutualICDebugShowArray(_gMutualICDeltaCWater, 12, -32, 10, 16);
+
+    return 0;
+}
+
+static void _DrvMpTestMsg28xxItoWaterProofTestMsgJudge(void)
+{
+    int i;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    for (i = 0; i < _gMutualICWaterProofNum; i++)
+    {
+        _gMutualICResultWater[i] =  abs(_gMutualICDeltaCWater[i]);
+    }
+}
+
+static s32 _DrvMpTestMsg28xxItoWaterProofTestEntry(void)
+{
+    s16 i = 0;
+    u32 nRetVal = 0;
+    u16 nRegDataWP = 0;
+    u32 nDelay = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    _gMutualICWaterProofNum = 12;
+
+    DrvPlatformLyrDisableFingerTouchReport();
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    //reset only
+    DbBusResetSlave();
+    DbBusEnterSerialDebugMode();
+    DbBusWaitMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    if(_DrvMpTestMsg28xxItoTestSwitchFwMode(WATERPROOF) < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg28xx WaterProof Test# Switch FW mode failed! ***\n");
+        nRetVal =  -1;
+        goto ITO_TEST_END;
+    }
+
+    nRegDataWP = RegGet16BitValue(0x1402);
+    if(nRegDataWP == 0x8BBD)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg28xx WaterProof Test# FW don't support waterproof! ***\n");
+        nRetVal = -1;
+        goto ITO_TEST_END;         
+    }
+
+    if(_DrvMpTestMsg28xxItoWaterProofTest(nDelay) < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** Msg28xx WaterProof Test# Get DeltaC failed! ***\n");
+        nRetVal = -1;
+        goto ITO_TEST_END;        
+    }
+
+    _DrvMpTestMsg28xxItoWaterProofTestMsgJudge();
+
+    for (i = 0; i < _gMutualICWaterProofNum; i++)
+    {
+        if (_gMutualICResultWater[i] > MSG28XX_WATER_VALUE)    //change comparison way because float computing in driver is prohibited
+        {
+            _gMutualICTestFailChannel[i] = 1;
+            _gTestFailChannelCount++;
+            nRetVal = -1;
+        }
+        else
+        {
+            _gMutualICTestFailChannel[i] = 0;
+        }
+    }
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+ITO_TEST_END:
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    mdelay(300);
+
+    DrvPlatformLyrEnableFingerTouchReport();
+
+    return nRetVal;
+}
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+//------------------------------------------------------------------------------//
+
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG26XXM) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG28XX)
+static u8 _DrvMpTestMutualICCheckValueInRange(s32 nValue, s32 nMax, s32 nMin)
+{
+   	if (nValue <= nMax && nValue >= nMin)
+   	{
+   	   	return 1;
+   	}
+   	else
+   	{
+   	   	return 0;
+   	}
+}
+
+static void _DrvMpTestMutualICDebugShowArray(void *pBuf, u16 nLen, int nDataType, int nCarry, int nChangeLine)
+{
+    u8 * pU8Buf = NULL;
+    s8 * pS8Buf = NULL;
+    u16 * pU16Buf = NULL;
+    s16 * pS16Buf = NULL;
+    u32 * pU32Buf = NULL;
+    s32 * pS32Buf = NULL;
+    int i;
+
+    if(nDataType == 8)
+        pU8Buf = (u8 *)pBuf;    
+    else if(nDataType == -8)
+        pS8Buf = (s8 *)pBuf;    
+    else if(nDataType == 16)
+        pU16Buf = (u16 *)pBuf;    
+    else if(nDataType == -16)
+        pS16Buf = (s16 *)pBuf;    
+    else if(nDataType == 32)
+        pU32Buf = (u32 *)pBuf;    
+    else if(nDataType == -32)
+        pS32Buf = (s32 *)pBuf;    
+
+    for(i=0; i < nLen; i++)
+    {
+        if(nCarry == 16)    
+        {
+            if(nDataType == 8)        
+                DBG(&g_I2cClient->dev, "%02X ", pU8Buf[i]);
+            else if(nDataType == -8)        
+                DBG(&g_I2cClient->dev, "%02X ", pS8Buf[i]);
+            else if(nDataType == 16)        
+                DBG(&g_I2cClient->dev, "%04X ", pU16Buf[i]);
+            else if(nDataType == -16)        
+                DBG(&g_I2cClient->dev, "%04X ", pS16Buf[i]);
+            else if(nDataType == 32)        
+                DBG(&g_I2cClient->dev, "%08X ", pU32Buf[i]);            
+            else if(nDataType == -32)        
+                DBG(&g_I2cClient->dev, "%08X ", pS32Buf[i]);            
+        }    
+        else if(nCarry == 10)
+        {
+            if(nDataType == 8)
+                DBG(&g_I2cClient->dev, "%6d ", pU8Buf[i]);
+            else if(nDataType == -8)
+                DBG(&g_I2cClient->dev, "%6d ", pS8Buf[i]);
+            else if(nDataType == 16)
+                DBG(&g_I2cClient->dev, "%6d ", pU16Buf[i]);
+            else if(nDataType == -16)
+                DBG(&g_I2cClient->dev, "%6d ", pS16Buf[i]);
+            else if(nDataType == 32)
+                DBG(&g_I2cClient->dev, "%6d ", pU32Buf[i]);
+            else if(nDataType == -32)
+                DBG(&g_I2cClient->dev, "%6d ", pS32Buf[i]);
+        }
+ 
+        if(i%nChangeLine == nChangeLine-1)
+        {  
+            DBG(&g_I2cClient->dev, "\n");
+        }
+    }
+    DBG(&g_I2cClient->dev, "\n");    
+}
+
+/*
+static void _DrvMpTestMutualICDebugShowS32Array(s32 *pBuf, u16 nRow, u16 nCol)
+{
+    int i, j;
+
+    for(j=0; j < nRow; j++)
+    {
+        for(i=0; i < nCol; i++)    
+        {
+            DBG(&g_I2cClient->dev, "%4d ", pBuf[i * nRow + j]);       
+        }
+        DBG(&g_I2cClient->dev, "\n");
+    }
+    DBG(&g_I2cClient->dev, "\n");    
+}
+*/
+
+static s32 _DrvMpTestItoWaterProofTest(void)
+{
+    s32 nRetVal = -1;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+    if (g_ChipType == CHIP_TYPE_MSG26XXM)
+    {
+        return _DrvMpTestMsg26xxmItoWaterProofTestEntry();
+    }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+    if (g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        return _DrvMpTestMsg28xxItoWaterProofTestEntry();
+    }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+    return nRetVal;
+}
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM || CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+//------------------------------------------------------------------------------//
+
+static s32 _DrvMpTestItoOpenTest(void)
+{
+    s32 nRetVal = -1;    
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG22XX)
+    if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        nRetVal = _DrvMpTestSelfICItoOpenTestEntry();
+    }    
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA || CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+    if (g_ChipType == CHIP_TYPE_MSG26XXM)
+    {
+        nRetVal = _DrvMpTestMsg26xxmItoOpenTestEntry();
+    }    
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+    if (g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        nRetVal = _DrvMpTestMsg28xxItoOpenTestEntry();
+    }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+    return nRetVal;
+}
+
+static s32 _DrvMpTestItoShortTest(void)
+{
+    s32 nRetVal = -1;    
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG22XX)
+    if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        nRetVal = _DrvMpTestSelfICItoShortTestEntry();
+    }    
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA || CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+    if (g_ChipType == CHIP_TYPE_MSG26XXM)
+    {
+        nRetVal = _DrvMpTestMsg26xxmItoShortTestEntry();
+    }    
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+    if(g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        nRetVal = _DrvMpTestMsg28xxItoShortTestEntry();
+    }    
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+    return nRetVal; 
+}
+
+static void _DrvMpTestItoTestDoWork(struct work_struct *pWork)
+{
+    s32 nRetVal = ITO_TEST_OK;
+    
+    DBG(&g_I2cClient->dev, "*** %s() g_IsInMpTest = %d, _gTestRetryCount = %d ***\n", __func__, g_IsInMpTest, _gTestRetryCount);
+
+    if (_gItoTestMode == ITO_TEST_MODE_OPEN_TEST)
+    {
+        nRetVal = _DrvMpTestItoOpenTest();
+    }
+    else if (_gItoTestMode == ITO_TEST_MODE_SHORT_TEST)
+    {
+        nRetVal = _DrvMpTestItoShortTest();
+    }
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG26XXM) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG28XX)
+    else if (_gItoTestMode == ITO_TEST_MODE_WATERPROOF_TEST)
+    {
+        nRetVal = _DrvMpTestItoWaterProofTest();
+    }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM || CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+    else
+    {
+        DBG(&g_I2cClient->dev, "*** Undefined Mp Test Mode = %d ***\n", _gItoTestMode);
+        return;
+    }
+
+    DBG(&g_I2cClient->dev, "*** ctp mp test result = %d ***\n", nRetVal);
+    
+    if (nRetVal == ITO_TEST_OK) //nRetVal == 0
+    {
+        _gCtpMpTestStatus = ITO_TEST_OK; //PASS
+        g_IsInMpTest = 0;
+        DBG(&g_I2cClient->dev, "mp test success\n");
+    }
+    else
+    {
+        _gTestRetryCount --;
+        if (_gTestRetryCount > 0)
+        {
+            DBG(&g_I2cClient->dev, "_gTestRetryCount = %d\n", _gTestRetryCount);
+            queue_work(_gCtpMpTestWorkQueue, &_gCtpItoTestWork);
+        }
+        else
+        {
+            if (((g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX) && (nRetVal == ITO_TEST_FAIL)) 
+            	|| ((g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX) && (nRetVal == -1)))
+            {
+                _gCtpMpTestStatus = ITO_TEST_FAIL;
+            }
+            else if (((g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX) && (nRetVal == ITO_TEST_GET_TP_TYPE_ERROR)) 
+            	|| ((g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX) && (nRetVal == -2)))
+            {
+                _gCtpMpTestStatus = ITO_TEST_GET_TP_TYPE_ERROR;
+            }
+            else
+            {
+                _gCtpMpTestStatus = ITO_TEST_UNDEFINED_ERROR;
+            }
+              
+            g_IsInMpTest = 0;
+            DBG(&g_I2cClient->dev, "mp test failed\n");
+        }
+    }
+}
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG26XXM) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG28XX)
+void DrvMpTestGetTestScope(TestScopeInfo_t *pInfo)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX) 
+    {
+        pInfo->nMy = _gMutualICDriveLineNum;
+        pInfo->nMx = _gMutualICSenseLineNum;
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+        pInfo->nKeyNum = _gMsg28xx_KEY_NUM;
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+        DBG(&g_I2cClient->dev, "*** My = %d ***\n", pInfo->nMy);
+        DBG(&g_I2cClient->dev, "*** Mx = %d ***\n", pInfo->nMx);
+        DBG(&g_I2cClient->dev, "*** KeyNum = %d ***\n", pInfo->nKeyNum);    
+    }
+}
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM || CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+s32 DrvMpTestGetTestResult(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    DBG(&g_I2cClient->dev, "_gCtpMpTestStatus = %d\n", _gCtpMpTestStatus);
+
+    return _gCtpMpTestStatus;
+}
+
+void DrvMpTestGetTestFailChannel(ItoTestMode_e eItoTestMode, u8 *pFailChannel, u32 *pFailChannelCount)
+{
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG22XX) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG26XXM) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG28XX)
+    u32 i;
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA || CONFIG_ENABLE_CHIP_TYPE_MSG22XX || CONFIG_ENABLE_CHIP_TYPE_MSG26XXM || CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    DBG(&g_I2cClient->dev, "_gTestFailChannelCount = %d\n", _gTestFailChannelCount);
+    
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG22XX)
+    if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX) 
+    {
+        for (i = 0; i < _gTestFailChannelCount; i ++)
+        {
+    	      pFailChannel[i] = _gSelfICTestFailChannel[i];
+        }
+
+        *pFailChannelCount = _gTestFailChannelCount;
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "g_ChipType = 0x%x is an undefined chip type.\n", g_ChipType);
+        *pFailChannelCount = 0;
+    }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA || CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG26XXM) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG28XX)
+    if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX) 
+    {
+        for (i = 0; i < MUTUAL_IC_MAX_MUTUAL_NUM; i ++)
+        {
+    	      pFailChannel[i] = _gMutualICTestFailChannel[i];
+        }
+    
+        *pFailChannelCount = MUTUAL_IC_MAX_MUTUAL_NUM; // Return the test result of all channels, APK will filter out the fail channels.
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "g_ChipType = 0x%x is an undefined chip type.\n", g_ChipType);
+        *pFailChannelCount = 0;
+    }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM || CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+}
+
+void DrvMpTestGetTestDataLog(ItoTestMode_e eItoTestMode, u8 *pDataLog, u32 *pLength)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG22XX)
+    if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX) 
+    {
+        u32 i;
+        u8 nHighByte, nLowByte;
+    
+        if (eItoTestMode == ITO_TEST_MODE_OPEN_TEST)
+        {
+            for (i = 0; i < SELF_IC_MAX_CHANNEL_NUM; i ++)
+            {
+                nHighByte = (_gSelfICRawData1[i] >> 8) & 0xFF;
+                nLowByte = (_gSelfICRawData1[i]) & 0xFF;
+    	  
+                if (_gSelfICDataFlag1[i] == 1)
+                {
+                    pDataLog[i*4] = 1; // indicate it is a on-use channel number
+                }
+                else
+                {
+                    pDataLog[i*4] = 0; // indicate it is a non-use channel number
+                }
+            
+                if (_gSelfICRawData1[i] >= 0)
+                {
+                    pDataLog[i*4+1] = 0; // + : a positive number
+                }
+                else
+                {
+                    pDataLog[i*4+1] = 1; // - : a negative number
+                }
+
+                pDataLog[i*4+2] = nHighByte;
+                pDataLog[i*4+3] = nLowByte;
+            }
+
+            for (i = 0; i < SELF_IC_MAX_CHANNEL_NUM; i ++)
+            {
+                nHighByte = (_gSelfICRawData2[i] >> 8) & 0xFF;
+                nLowByte = (_gSelfICRawData2[i]) & 0xFF;
+        
+                if (_gSelfICDataFlag2[i] == 1)
+                {
+                    pDataLog[i*4+SELF_IC_MAX_CHANNEL_NUM*4] = 1; // indicate it is a on-use channel number
+                }
+                else
+                {
+                    pDataLog[i*4+SELF_IC_MAX_CHANNEL_NUM*4] = 0; // indicate it is a non-use channel number
+                }
+
+                if (_gSelfICRawData2[i] >= 0)
+                {
+                    pDataLog[(i*4+1)+SELF_IC_MAX_CHANNEL_NUM*4] = 0; // + : a positive number
+                }
+                else
+                {
+                    pDataLog[(i*4+1)+SELF_IC_MAX_CHANNEL_NUM*4] = 1; // - : a negative number
+                }
+
+                pDataLog[(i*4+2)+SELF_IC_MAX_CHANNEL_NUM*4] = nHighByte;
+                pDataLog[(i*4+3)+SELF_IC_MAX_CHANNEL_NUM*4] = nLowByte;
+            }
+
+            *pLength = SELF_IC_MAX_CHANNEL_NUM*8;
+        }
+        else if (eItoTestMode == ITO_TEST_MODE_SHORT_TEST)
+        {
+            for (i = 0; i < SELF_IC_MAX_CHANNEL_NUM; i ++)
+            {
+                nHighByte = (_gSelfICRawData1[i] >> 8) & 0xFF;
+                nLowByte = (_gSelfICRawData1[i]) & 0xFF;
+
+                if (_gSelfICDataFlag1[i] == 1)
+                {
+                    pDataLog[i*4] = 1; // indicate it is a on-use channel number
+                }
+                else
+                {
+                    pDataLog[i*4] = 0; // indicate it is a non-use channel number
+                }
+
+                if (_gSelfICRawData1[i] >= 0)
+                {
+                    pDataLog[i*4+1] = 0; // + : a positive number
+                }
+                else
+                {
+                    pDataLog[i*4+1] = 1; // - : a negative number
+                }
+
+                pDataLog[i*4+2] = nHighByte;
+                pDataLog[i*4+3] = nLowByte;
+            }
+
+            for (i = 0; i < SELF_IC_MAX_CHANNEL_NUM; i ++)
+            {
+                nHighByte = (_gSelfICRawData2[i] >> 8) & 0xFF;
+                nLowByte = (_gSelfICRawData2[i]) & 0xFF;
+        
+                if (_gSelfICDataFlag2[i] == 1)
+                {
+                    pDataLog[i*4+SELF_IC_MAX_CHANNEL_NUM*4] = 1; // indicate it is a on-use channel number
+                }
+                else
+                {
+                    pDataLog[i*4+SELF_IC_MAX_CHANNEL_NUM*4] = 0; // indicate it is a non-use channel number
+                }
+
+                if (_gSelfICRawData2[i] >= 0)
+                {
+                    pDataLog[(i*4+1)+SELF_IC_MAX_CHANNEL_NUM*4] = 0; // + : a positive number
+                }
+                else
+                {
+                    pDataLog[(i*4+1)+SELF_IC_MAX_CHANNEL_NUM*4] = 1; // - : a negative number
+                }
+
+                pDataLog[i*4+2+SELF_IC_MAX_CHANNEL_NUM*4] = nHighByte;
+                pDataLog[i*4+3+SELF_IC_MAX_CHANNEL_NUM*4] = nLowByte;
+            }
+
+            for (i = 0; i < SELF_IC_MAX_CHANNEL_NUM; i ++)
+            {
+                nHighByte = (_gSelfICRawData3[i] >> 8) & 0xFF;
+                nLowByte = (_gSelfICRawData3[i]) & 0xFF;
+        
+                if (_gSelfICDataFlag3[i] == 1)
+                {
+                    pDataLog[i*4+SELF_IC_MAX_CHANNEL_NUM*8] = 1; // indicate it is a on-use channel number
+                }
+                else
+                {
+                    pDataLog[i*4+SELF_IC_MAX_CHANNEL_NUM*8] = 0; // indicate it is a non-use channel number
+                }
+
+                if (_gSelfICRawData3[i] >= 0)
+                {
+                    pDataLog[(i*4+1)+SELF_IC_MAX_CHANNEL_NUM*8] = 0; // + : a positive number
+                }
+                else
+                {
+                    pDataLog[(i*4+1)+SELF_IC_MAX_CHANNEL_NUM*8] = 1; // - : a negative number
+                }
+
+                pDataLog[(i*4+2)+SELF_IC_MAX_CHANNEL_NUM*8] = nHighByte;
+                pDataLog[(i*4+3)+SELF_IC_MAX_CHANNEL_NUM*8] = nLowByte;
+            }
+
+            if (_gSelfICIsEnable2R)
+            {
+                for (i = 0; i < SELF_IC_MAX_CHANNEL_NUM; i ++)
+                {
+                    nHighByte = (_gSelfICRawData4[i] >> 8) & 0xFF;
+                    nLowByte = (_gSelfICRawData4[i]) & 0xFF;
+        
+                    if (_gSelfICDataFlag4[i] == 1)
+                    {
+                        pDataLog[i*4+SELF_IC_MAX_CHANNEL_NUM*12] = 1; // indicate it is a on-use channel number
+                    }
+                    else
+                    {
+                        pDataLog[i*4+SELF_IC_MAX_CHANNEL_NUM*12] = 0; // indicate it is a non-use channel number
+                    }
+
+                    if (_gSelfICRawData4[i] >= 0)
+                    {
+                        pDataLog[(i*4+1)+SELF_IC_MAX_CHANNEL_NUM*12] = 0; // + : a positive number
+                    }
+                    else
+                    {
+                        pDataLog[(i*4+1)+SELF_IC_MAX_CHANNEL_NUM*12] = 1; // - : a negative number
+                    }
+
+                    pDataLog[(i*4+2)+SELF_IC_MAX_CHANNEL_NUM*12] = nHighByte;
+                    pDataLog[(i*4+3)+SELF_IC_MAX_CHANNEL_NUM*12] = nLowByte;
+                }
+            }
+        
+            *pLength = SELF_IC_MAX_CHANNEL_NUM*16;
+        }
+        else 
+        {
+            DBG(&g_I2cClient->dev, "*** Undefined MP Test Mode ***\n");
+        }
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "g_ChipType = 0x%x is an undefined chip type.\n", g_ChipType);
+    }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA || CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+#if defined(CONFIG_ENABLE_CHIP_TYPE_MSG26XXM) || defined(CONFIG_ENABLE_CHIP_TYPE_MSG28XX)
+    if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX) 
+    {
+        u32 i, j, k;
+    
+        if (eItoTestMode == ITO_TEST_MODE_OPEN_TEST)
+        {
+            k = 0;
+        
+            for (j = 0; j < _gMutualICDriveLineNum; j ++)
+//            for (j = 0; j < (_gMutualICDriveLineNum-1); j ++)
+            {
+                for (i = 0; i < _gMutualICSenseLineNum; i ++)
+                {
+//                    DBG(&g_I2cClient->dev, "\nDrive%d, Sense%d, Value = %d\t", j, i, _gMutualICResult[i * _gMutualICDriveLineNum + j]); // add for debug
+
+                    if (_gMutualICResult[i * _gMutualICDriveLineNum + j] >= 0)
+                    {
+                        pDataLog[k*5] = 0; // + : a positive number
+                    }
+                    else
+                    {
+                        pDataLog[k*5] = 1; // - : a negative number
+                    }
+
+                    pDataLog[k*5+1] = (_gMutualICResult[i * _gMutualICDriveLineNum + j] >> 24) & 0xFF;
+                    pDataLog[k*5+2] = (_gMutualICResult[i * _gMutualICDriveLineNum + j] >> 16) & 0xFF;
+                    pDataLog[k*5+3] = (_gMutualICResult[i * _gMutualICDriveLineNum + j] >> 8) & 0xFF;
+                    pDataLog[k*5+4] = (_gMutualICResult[i * _gMutualICDriveLineNum + j]) & 0xFF;
+                
+                    k ++;
+                }
+            }
+
+            DBG(&g_I2cClient->dev, "\nk = %d\n", k);
+
+            *pLength = k*5;
+        }
+        else if (eItoTestMode == ITO_TEST_MODE_SHORT_TEST)
+        {
+            k = 0;
+        
+            for (i = 0; i < (_gMutualICDriveLineNum-1 + _gMutualICSenseLineNum); i++)
+            {
+                if (_gMutualICResult[i] >= 0)
+                {
+                    pDataLog[k*5] = 0; // + : a positive number
+                }
+                else
+                {
+                    pDataLog[k*5] = 1; // - : a negative number
+                }
+
+                pDataLog[k*5+1] = (_gMutualICResult[i] >> 24) & 0xFF;
+                pDataLog[k*5+2] = (_gMutualICResult[i] >> 16) & 0xFF;
+                pDataLog[k*5+3] = (_gMutualICResult[i] >> 8) & 0xFF;
+                pDataLog[k*5+4] = (_gMutualICResult[i]) & 0xFF;
+                k ++;
+            }
+
+            DBG(&g_I2cClient->dev, "\nk = %d\n", k);
+
+            *pLength = k*5;
+        }
+        else if (eItoTestMode == ITO_TEST_MODE_WATERPROOF_TEST)
+        {
+            k = 0;
+
+            for (i = 0; i < _gMutualICWaterProofNum; i++)
+            {
+                if (_gMutualICResultWater[i] >= 0)
+                {
+                    pDataLog[k*5] = 0; // + : a positive number
+                }
+                else
+                {
+                    pDataLog[k*5] = 1; // - : a negative number
+                }
+
+                pDataLog[k*5+1] = (_gMutualICResultWater[i] >> 24) & 0xFF;
+                pDataLog[k*5+2] = (_gMutualICResultWater[i] >> 16) & 0xFF;
+                pDataLog[k*5+3] = (_gMutualICResultWater[i] >> 8) & 0xFF;
+                pDataLog[k*5+4] = (_gMutualICResultWater[i]) & 0xFF;
+                k ++;
+            }
+
+            DBG(&g_I2cClient->dev, "\nk = %d\n", k);
+
+            *pLength = k*5;
+        }
+        else 
+        {
+            DBG(&g_I2cClient->dev, "*** Undefined MP Test Mode ***\n");
+        }
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "g_ChipType = 0x%x is an undefined chip type.\n", g_ChipType);
+    }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM || CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+}
+
+void DrvMpTestScheduleMpTestWork(ItoTestMode_e eItoTestMode)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (g_IsInMpTest == 0)
+    {
+        DBG(&g_I2cClient->dev, "ctp mp test start\n");
+        
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+        if (g_ChipType == CHIP_TYPE_MSG22XX)
+        {
+            _gIsOldFirmwareVersion = _DrvMpTestMsg22xxCheckFirmwareVersion();
+        }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+        _gItoTestMode = eItoTestMode;
+        g_IsInMpTest = 1;
+        _gTestRetryCount = CTP_MP_TEST_RETRY_COUNT;
+        _gCtpMpTestStatus = ITO_TEST_UNDER_TESTING;
+
+        queue_work(_gCtpMpTestWorkQueue, &_gCtpItoTestWork);
+    }
+}
+
+void DrvMpTestCreateMpTestWorkQueue(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    _gCtpMpTestWorkQueue = create_singlethread_workqueue("ctp_mp_test");
+    INIT_WORK(&_gCtpItoTestWork, _DrvMpTestItoTestDoWork);
+}
+
+#endif //CONFIG_ENABLE_ITO_MP_TEST
\ No newline at end of file
Index: kernel/drivers/input/touchscreen/msg5846/mstar_drv_fw_control.c
===================================================================
--- kernel/drivers/input/touchscreen/msg5846/mstar_drv_fw_control.c	(revision 0)
+++ kernel/drivers/input/touchscreen/msg5846/mstar_drv_fw_control.c	(revision 166572)
@@ -0,0 +1,13249 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2014 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_fw_control.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_fw_control.h"
+#include "mstar_drv_utility_adaption.h"
+#include "mstar_drv_platform_porting_layer.h"
+
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+extern u32 SLAVE_I2C_ID_DBBUS;
+extern u32 SLAVE_I2C_ID_DWI2C;
+
+#ifdef CONFIG_TP_HAVE_KEY
+extern int g_TpVirtualKey[];
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+extern int g_TpVirtualKeyDimLocal[][4];
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#endif //CONFIG_TP_HAVE_KEY
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+extern struct input_dev *g_ProximityInputDevice;
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM || CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM
+
+extern struct input_dev *g_InputDevice;
+extern struct i2c_client *g_I2cClient;
+
+extern u8 g_FwData[MAX_UPDATE_FIRMWARE_BUFFER_SIZE][1024];
+extern u32 g_FwDataCount;
+
+extern struct mutex g_Mutex;
+
+extern u16 DEMO_MODE_PACKET_LENGTH; 
+extern u16 DEBUG_MODE_PACKET_LENGTH;
+extern u16 MAX_TOUCH_NUM; 
+
+extern u16 FIRMWARE_MODE_UNKNOWN_MODE;
+extern u16 FIRMWARE_MODE_DEMO_MODE;
+extern u16 FIRMWARE_MODE_DEBUG_MODE;
+extern u16 FIRMWARE_MODE_RAW_DATA_MODE;
+
+extern struct kobject *g_TouchKObj;
+extern u8 g_IsSwitchModeByAPK;
+
+extern u8 IS_FIRMWARE_DATA_LOG_ENABLED;
+extern u8 IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED;
+
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA // for MSG26xxM/MSG28xx
+extern u16 g_FwPacketDataAddress;
+extern u16 g_FwPacketFlagAddress;
+
+extern u8 g_FwSupportSegment;
+#endif //CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+extern struct kobject *g_GestureKObj;
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+extern u32 g_IsEnableReportRate;
+extern u32 g_InterruptCount;
+extern u32 g_ValidTouchCount;
+
+extern struct timeval g_StartTime;
+#endif //CONFIG_ENABLE_COUNT_REPORT_RATE
+
+#ifdef CONFIG_ENABLE_HOTKNOT // for MSG26xxM/MSG28xx
+extern u8 g_HotKnotState;
+#endif //CONFIG_ENABLE_HOTKNOT
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+extern u32 g_IsInMpTest;
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+/*=============================================================*/
+// LOCAL VARIABLE DEFINITION
+/*=============================================================*/
+
+static u8 _gTpVendorCode[3] = {0}; // for MSG22xx/MSG28xx
+
+static u8 _gOneDimenFwData[MSG28XX_FIRMWARE_WHOLE_SIZE*1024] = {0}; // for MSG22xx : array size = MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE*1024+MSG22XX_FIRMWARE_INFO_BLOCK_SIZE, for MSG28xx : array size = MSG28XX_FIRMWARE_WHOLE_SIZE*1024
+
+static u8 _gFwDataBuf[MSG28XX_FIRMWARE_WHOLE_SIZE*1024] = {0}; // for update firmware from SD card
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+/*
+ * Note.
+ * Please modify the name of the below .h depends on the vendor TP that you are using.
+ */
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+#include "msg21xxa_xxxx_update_bin.h" // for MSG21xxA
+#include "msg21xxa_yyyy_update_bin.h"
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+#include "msg22xx_xxxx_update_bin.h" // for MSG22xx
+#include "msg22xx_yyyy_update_bin.h"
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+#include "msg26xxm_xxxx_update_bin.h" // for MSG26xxM
+#include "msg26xxm_yyyy_update_bin.h"
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+#include "msg28xx_xxxx_update_bin.h" // for MSG28xx
+#include "msg28xx_yyyy_update_bin.h"
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+static u32 _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+static u32 _gIsUpdateInfoBlockFirst = 0;
+static struct work_struct _gUpdateFirmwareBySwIdWork;
+static struct workqueue_struct *_gUpdateFirmwareBySwIdWorkQueue = NULL;
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+static u8 _gTempData[1024]; 
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+
+#else
+
+static u8 _gDwIicInfoData[1024]; // for MSG21xxA
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+static u32 _gGestureWakeupValue[2] = {0};
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA // for MSG26xxM/MSG28xx
+static u8 _gTouchPacketFlag[2] = {0};
+#endif //CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION
+static u8 _gChargerPlugIn = 0;
+#endif //CONFIG_ENABLE_CHARGER_DETECTION
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+static u8 _gCurrPress[SELF_MAX_TOUCH_NUM] = {0}; // for MSG21xxA/MSG22xx
+static u8 _gPrevTouchStatus = 0;
+
+static u8 _gPreviousTouch[MUTUAL_MAX_TOUCH_NUM] = {0}; // for MSG26xxM/MSG28xx
+static u8 _gCurrentTouch[MUTUAL_MAX_TOUCH_NUM] = {0};
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+static u8 _gIsDisableFinagerTouch = 0;
+
+static u16 _gSFR_ADDR3_BYTE0_1_VALUE = 0x0000; // for MSG28xx
+static u16 _gSFR_ADDR3_BYTE2_3_VALUE = 0x0000;
+
+/*=============================================================*/
+// GLOBAL VARIABLE DEFINITION
+/*=============================================================*/
+
+u8 g_ChipType = 0;
+u8 g_DemoModePacket[MUTUAL_DEMO_MODE_PACKET_LENGTH] = {0}; // for MSG21xxA/MSG22xx : DEMO_MODE_PACKET_LENGTH = SELF_DEMO_MODE_PACKET_LENGTH, for MSG26xxM/MSG28xx : DEMO_MODE_PACKET_LENGTH = MUTUAL_DEMO_MODE_PACKET_LENGTH
+
+#ifdef CONFIG_ENABLE_HOTKNOT // for MSG28xx
+u8 g_DemoModeHotKnotSndRetPacket[DEMO_HOTKNOT_SEND_RET_LEN] = {0};
+u8 g_DebugModeHotKnotSndRetPacket[DEBUG_HOTKNOT_SEND_RET_LEN] = {0};
+#endif //CONFIG_ENABLE_HOTKNOT
+
+MutualFirmwareInfo_t g_MutualFirmwareInfo;
+SelfFirmwareInfo_t g_SelfFirmwareInfo;
+u8 g_LogModePacket[MUTUAL_DEBUG_MODE_PACKET_LENGTH] = {0}; // for MSG21xxA/MSG22xx : DEBUG_MODE_PACKET_LENGTH = SELF_DEBUG_MODE_PACKET_LENGTH, for MSG26xxM/MSG28xx : DEBUG_MODE_PACKET_LENGTH = MUTUAL_DEBUG_MODE_PACKET_LENGTH
+u16 g_FirmwareMode;
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+#if defined(CONFIG_ENABLE_GESTURE_DEBUG_MODE)
+u8 _gGestureWakeupPacket[GESTURE_DEBUG_MODE_PACKET_LENGTH] = {0};
+#elif defined(CONFIG_ENABLE_GESTURE_INFORMATION_MODE)
+u8 _gGestureWakeupPacket[GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH] = {0};
+#else
+u8 _gGestureWakeupPacket[GESTURE_WAKEUP_PACKET_LENGTH] = {0}; // for MSG21xxA : packet length = DEMO_MODE_PACKET_LENGTH, for MSG22xx/MSG26xxM/MSG28xx : packet length = GESTURE_WAKEUP_PACKET_LENGTH
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+u8 g_GestureDebugFlag = 0x00;
+u8 g_GestureDebugMode = 0x00;
+u8 g_LogGestureDebug[GESTURE_DEBUG_MODE_PACKET_LENGTH] = {0};
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+u32 g_LogGestureInfor[GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH] = {0};
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+
+#ifdef CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE // support at most 64 types of gesture wakeup mode
+u32 g_GestureWakeupMode[2] = {0xFFFFFFFF, 0xFFFFFFFF};
+#else                                              // support at most 16 types of gesture wakeup mode
+u32 g_GestureWakeupMode[2] = {0x00000000, 0x00000000};
+#endif //CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+
+u8 g_GestureWakeupFlag = 0;
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+u8 g_EnableTpProximity = 0;
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+u8 g_FaceClosingTp = 0; // for QCOM platform -> 1 : close to, 0 : far away 
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+u8 g_FaceClosingTp = 1; // for MTK platform -> 0 : close to, 1 : far away 
+#endif
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION
+u8 g_ForceUpdate = 0;
+#endif //CONFIG_ENABLE_CHARGER_DETECTION
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+u8 g_IsHwResetByDriver = 0;
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+
+u8 g_IsUpdateFirmware = 0x00;
+u8 g_Msg22xxChipRevision = 0x00;
+
+/*=============================================================*/
+// LOCAL FUNCTION DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+static void _DrvFwCtrlUpdateFirmwareBySwIdDoWork(struct work_struct *pWork);
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+static s32 _DrvFwCtrlMsg21xxaUpdateFirmwareBySwId(u8 szFwData[][1024], EmemType_e eEmemType);
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+static void _DrvFwCtrlCoordinate(u8 *pRawData, u32 *pTranX, u32 *pTranY);
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifndef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+static s32 _DrvFwCtrlUpdateFirmwareC33(u8 szFwData[][1024], EmemType_e eEmemType);
+static s32 _DrvFwCtrlUpdateFirmwareC32(u8 szFwData[][1024], EmemType_e eEmemType);
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+static s32 _DrvFwCtrlMsg22xxUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType);
+static void _DrvFwCtrlReadReadDQMemStart(void);
+static void _DrvFwCtrlReadReadDQMemEnd(void);
+
+/*=============================================================*/
+// LOCAL FUNCTION DEFINITION
+/*=============================================================*/
+
+static void _DrvFwCtrlEraseEmemC33(EmemType_e eEmemType)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // Stop MCU
+    RegSetLByteValue(0x0FE6, 0x01); 
+
+    // Disable watchdog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    // Set PROGRAM password
+    RegSetLByteValue(0x161A, 0xBA);
+    RegSetLByteValue(0x161B, 0xAB);
+
+    // Clear pce
+    RegSetLByteValue(0x1618, 0x80);
+
+    if (eEmemType == EMEM_ALL)
+    {
+        RegSetLByteValue(0x1608, 0x10); //mark
+    }
+
+    RegSetLByteValue(0x1618, 0x40);
+    mdelay(10);
+
+    RegSetLByteValue(0x1618, 0x80);
+
+    // erase trigger
+    if (eEmemType == EMEM_MAIN)
+    {
+        RegSetLByteValue(0x160E, 0x04); //erase main
+    }
+    else
+    {
+        RegSetLByteValue(0x160E, 0x08); //erase all block
+    }
+}
+
+static void _DrvFwCtrlMsg22xxGetTpVendorCode(u8 *pTpVendorCode)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        u16 nRegData1, nRegData2;
+
+        DrvPlatformLyrTouchDeviceResetHw();
+    
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+        
+        // Stop mcu
+        RegSetLByteValue(0x0FE6, 0x01); 
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+        // Exit flash low power mode
+        RegSetLByteValue(0x1619, BIT1); 
+
+        // Change PIU clock to 48MHz
+        RegSetLByteValue(0x1E23, BIT6); 
+
+        // Change mcu clock deglitch mux source
+        RegSetLByteValue(0x1E54, BIT0); 
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+        // Stop watchdog
+        RegSet16BitValue(0x3C60, 0xAA55);
+
+        // RIU password
+        RegSet16BitValue(0x161A, 0xABBA); 
+
+        RegSet16BitValue(0x1600, 0xC1E9); // Set start address for tp vendor code on info block(Actually, start reading from 0xC1E8)
+    
+        // Enable burst mode
+//        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+        RegSetLByteValue(0x160E, 0x01); 
+
+        nRegData1 = RegGet16BitValue(0x1604);
+        nRegData2 = RegGet16BitValue(0x1606);
+
+        pTpVendorCode[0] = ((nRegData1 >> 8) & 0xFF);
+        pTpVendorCode[1] = (nRegData2 & 0xFF);
+        pTpVendorCode[2] = ((nRegData2 >> 8) & 0xFF);
+
+        DBG(&g_I2cClient->dev, "pTpVendorCode[0] = 0x%x , %c \n", pTpVendorCode[0], pTpVendorCode[0]); 
+        DBG(&g_I2cClient->dev, "pTpVendorCode[1] = 0x%x , %c \n", pTpVendorCode[1], pTpVendorCode[1]); 
+        DBG(&g_I2cClient->dev, "pTpVendorCode[2] = 0x%x , %c \n", pTpVendorCode[2], pTpVendorCode[2]); 
+        
+        // Clear burst mode
+//        RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+        RegSet16BitValue(0x1600, 0x0000); 
+
+        // Clear RIU password
+        RegSet16BitValue(0x161A, 0x0000); 
+
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+
+        DrvPlatformLyrTouchDeviceResetHw();
+    }
+}
+
+static u16 _DrvFwCtrlMsg22xxGetTrimByte1(void)
+{
+    u16 nRegData = 0;
+    u16 nTrimByte1 = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    RegSet16BitValue(0x161E, 0xBEAF); 
+    RegSet16BitValue(0x1608, 0x0006); 
+    RegSet16BitValue(0x160E, 0x0010); 
+    RegSet16BitValue(0x1608, 0x1006); 
+    RegSet16BitValue(0x1600, 0x0001); 
+    RegSet16BitValue(0x160E, 0x0010);
+    
+    mdelay(10);
+    
+    RegSet16BitValue(0x1608, 0x1846);
+    RegSet16BitValue(0x160E, 0x0010);
+    
+    mdelay(10);
+
+    nRegData = RegGet16BitValue(0x1624);
+    nRegData = nRegData & 0xFF;
+
+    RegSet16BitValue(0x161E, 0x0000);
+
+    nTrimByte1 = nRegData;
+
+    DBG(&g_I2cClient->dev, "nTrimByte1 = 0x%X ***\n", nTrimByte1);
+    
+    return nTrimByte1;
+}
+
+static void _DrvFwCtrlMsg22xxChangeVoltage(void)
+{
+    u16 nTrimValue = 0;
+    u16 nNewTrimValue = 0;
+    u16 nTempValue = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    RegSet16BitValue(0x1840, 0xA55A);
+	
+    udelay(1000); // delay 1 ms
+
+    nTrimValue = RegGet16BitValue(0x1820);
+
+    udelay(1000); // delay 1 ms
+    
+    nTrimValue = nTrimValue & 0x1F;
+    nTempValue = 0x1F & nTrimValue;
+    nNewTrimValue = (nTempValue + 0x07);
+    
+    if (nNewTrimValue >= 0x20)
+    {
+        nNewTrimValue = nNewTrimValue - 0x20;
+    }
+    else
+    {
+        nNewTrimValue = nNewTrimValue;
+    }
+    
+    if ((nTempValue & 0x10) != 0x10)
+    {
+        if (nNewTrimValue >= 0x0F && nNewTrimValue < 0x1F)
+        {
+            nNewTrimValue = 0x0F;
+        }
+        else
+        {
+            nNewTrimValue = nNewTrimValue;
+        }
+    }
+
+    RegSet16BitValue(0x1842, nNewTrimValue);
+
+    udelay(1000); // delay 1 ms
+
+    RegSet16BitValueOn(0x1842, BIT5);
+
+    udelay(1000); // delay 1 ms
+}
+
+static void _DrvFwCtrlMsg22xxRestoreVoltage(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    RegSet16BitValueOff(0x1842, BIT5);
+
+    udelay(1000); // delay 1 ms
+
+    RegSet16BitValue(0x1840, 0x0000);
+
+    udelay(1000); // delay 1 ms
+}
+
+static u32 _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EmemType_e eEmemType) 
+{
+    u16 nCrcDown = 0;
+    u32 nTimeOut = 0;
+    u32 nRetVal = 0; 
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+    // Stop MCU
+    RegSetLByteValue(0x0FE6, 0x01); 
+    
+    // Exit flash low power mode
+    RegSetLByteValue(0x1619, BIT1); 
+
+    // Change PIU clock to 48MHz
+    RegSetLByteValue(0x1E23, BIT6); 
+
+    // Change mcu clock deglitch mux source
+    RegSetLByteValue(0x1E54, BIT0); 
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+    // RIU password
+    RegSet16BitValue(0x161A, 0xABBA);      
+
+    // Set PCE high
+    RegSetLByteValue(0x1618, 0x40);      
+
+    if (eEmemType == EMEM_MAIN)
+    {
+        // Set start address and end address for main block
+        RegSet16BitValue(0x1600, 0x0000);      
+        RegSet16BitValue(0x1640, 0xBFF8);      
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        // Set start address and end address for info block
+        RegSet16BitValue(0x1600, 0xC000);      
+        RegSet16BitValue(0x1640, 0xC1F8);      
+    }
+
+    // CRC reset
+    RegSet16BitValue(0x164E, 0x0001);      
+
+    RegSet16BitValue(0x164E, 0x0000);   
+    
+    // Trigger CRC check
+    RegSetLByteValue(0x160E, 0x20);   
+    mdelay(10);
+       
+    while (1)
+    {
+        DBG(&g_I2cClient->dev, "Wait CRC down\n");
+
+        nCrcDown = RegGet16BitValue(0x164E);
+        if (nCrcDown == 2)
+        {
+            break;		
+        }
+        mdelay(10);
+
+        if ((nTimeOut ++) > 30)
+        {
+            DBG(&g_I2cClient->dev, "Get CRC down failed. Timeout.\n");
+
+            goto GetCRCEnd;
+        }
+    }
+    
+    nRetVal = RegGet16BitValue(0x1652);
+    nRetVal = (nRetVal << 16) | RegGet16BitValue(0x1650);
+
+    GetCRCEnd:
+	
+    DBG(&g_I2cClient->dev, "Hardware CRC = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;	
+}
+
+static void _DrvFwCtrlMsg22xxConvertFwDataTwoDimenToOneDimen(u8 szTwoDimenFwData[][1024], u8* pOneDimenFwData)
+{
+    u32 i, j;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+    {
+        if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+        {
+            for (j = 0; j < 1024; j ++)
+            {
+                pOneDimenFwData[i*1024+j] = szTwoDimenFwData[i][j];
+            }
+        }
+        else // i == 48
+        {
+            for (j = 0; j < 512; j ++)
+            {
+                pOneDimenFwData[i*1024+j] = szTwoDimenFwData[i][j];
+            }
+        }
+    }
+}
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL 
+static u32 _DrvFwCtrlPointDistance(u16 nX, u16 nY, u16 nPrevX, u16 nPrevY)
+{ 
+    u32 nRetVal = 0;
+	
+    nRetVal = (((nX-nPrevX)*(nX-nPrevX))+((nY-nPrevY)*(nY-nPrevY)));
+    
+    return nRetVal;
+}
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+static s32 _DrvFwCtrlSelfParsePacket(u8 *pPacket, u16 nLength, SelfTouchInfo_t *pInfo) // for MSG21xxA/MSG22xx
+{
+    u8 nCheckSum = 0;
+    u32 nDeltaX = 0, nDeltaY = 0;
+    u32 nX = 0;
+    u32 nY = 0;
+#ifdef CONFIG_SWAP_X_Y
+    u32 nTempX;
+    u32 nTempY;
+#endif
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+    static u8 nPrevTouchNum = 0; 
+    static u16 szPrevX[SELF_MAX_TOUCH_NUM] = {0xFFFF, 0xFFFF};
+    static u16 szPrevY[SELF_MAX_TOUCH_NUM] = {0xFFFF, 0xFFFF};
+    static u8  szPrevPress[SELF_MAX_TOUCH_NUM] = {0};
+    u32 i = 0;
+    u16 szX[SELF_MAX_TOUCH_NUM] = {0};
+    u16 szY[SELF_MAX_TOUCH_NUM] = {0};
+    u16 nTemp = 0;
+    u8  nChangePoints = 0;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+    u8 nCheckSumIndex = nLength-1; //Set default checksum index for demo mode
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+    _gCurrPress[0] = 0;
+    _gCurrPress[1] = 0;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+    if (g_IsEnableReportRate == 1)
+    {
+        if (g_InterruptCount == 4294967295)
+        {
+            g_InterruptCount = 0; // Reset count if overflow
+            DBG(&g_I2cClient->dev, "g_InterruptCount reset to 0\n");
+        }	
+
+        if (g_InterruptCount == 0)
+        {
+            // Get start time
+            do_gettimeofday(&g_StartTime);
+    
+            DBG(&g_I2cClient->dev, "Start time : %lu sec, %lu msec\n", g_StartTime.tv_sec,  g_StartTime.tv_usec); 
+        }
+        
+        g_InterruptCount ++;
+
+        DBG(&g_I2cClient->dev, "g_InterruptCount = %d\n", g_InterruptCount);
+    }
+#endif //CONFIG_ENABLE_COUNT_REPORT_RATE
+
+    if (IS_FIRMWARE_DATA_LOG_ENABLED)
+    {
+        if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE)
+        {
+            nCheckSumIndex = 7;
+        }
+        else if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE || g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE)
+        {
+            nCheckSumIndex = 31;
+        }
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+        if (g_GestureWakeupFlag == 1)
+        {
+            nCheckSumIndex = nLength-1;
+        }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+    } //IS_FIRMWARE_DATA_LOG_ENABLED
+    
+    nCheckSum = DrvCommonCalculateCheckSum(&pPacket[0], nCheckSumIndex);
+    DBG(&g_I2cClient->dev, "check sum : [%x] == [%x]? \n", pPacket[nCheckSumIndex], nCheckSum);
+
+#ifdef CONFIG_ENABLE_ESD_PROTECTION
+    if (g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        if (pPacket[0] == 0xA7 && pPacket[1] == 0x00 && pPacket[2] == 0x08 && pPacket[3] == PACKET_TYPE_ESD_CHECK_HW_RESET && pPacket[4] == 0xFF && pPacket[5] == 0xFF && pPacket[6] == 0xFF)
+        {
+            DBG(&g_I2cClient->dev, "ESD HwReset check : g_IsUpdateFirmware=%d, g_IsHwResetByDriver=%d\n", g_IsUpdateFirmware, g_IsHwResetByDriver);
+
+            if (g_IsUpdateFirmware == 0
+                && g_IsHwResetByDriver == 0
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+                && g_IsInMpTest == 0
+#endif //CONFIG_ENABLE_ITO_MP_TEST            	
+            )
+            {
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+                if (g_EnableTpProximity == 1)
+                {
+                    DrvFwCtrlEnableProximity();
+				
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+                    g_FaceClosingTp = 0; // far away for SPRD/QCOM platform
+				           
+                    if (g_ProximityInputDevice != NULL)
+                    {
+                        input_report_abs(g_ProximityInputDevice, ABS_DISTANCE, 1);
+                        input_sync(g_ProximityInputDevice);
+                    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+                    {
+                        int nErr;
+                        hwm_sensor_data tSensorData;
+				
+                        g_FaceClosingTp = 1; // far away for MTK platform
+				
+                        // map and store data to hwm_sensor_data
+                        tSensorData.values[0] = DrvPlatformLyrGetTpPsData();
+                        tSensorData.value_divide = 1;
+                        tSensorData.status = SENSOR_STATUS_ACCURACY_MEDIUM;
+                        // let up layer to know
+                        if ((nErr = hwmsen_get_interrupt_data(ID_PROXIMITY, &tSensorData)))
+                        {
+                            DBG(&g_I2cClient->dev, "call hwmsen_get_interrupt_data() failed = %d\n", nErr);
+                        }
+                    }
+#endif               
+                }
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+/*
+                DrvPlatformLyrFingerTouchReleased(0, 0, 0); // Send touch end for clearing point touch
+                input_sync(g_InputDevice);
+*/
+            }
+            
+            g_IsHwResetByDriver = 0; //Reset check flag to 0 after HwReset check
+
+            return -1;
+        }
+    }
+#endif //CONFIG_ENABLE_ESD_PROTECTION
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (g_GestureWakeupFlag == 1)
+    {
+        u8 nWakeupMode = 0;
+        u8 bIsCorrectFormat = 0;
+
+        DBG(&g_I2cClient->dev, "received raw data from touch panel as following:\n");
+        DBG(&g_I2cClient->dev, "pPacket[0]=%x \n pPacket[1]=%x pPacket[2]=%x pPacket[3]=%x pPacket[4]=%x pPacket[5]=%x \n", \
+            pPacket[0], pPacket[1], pPacket[2], pPacket[3], pPacket[4], pPacket[5]);
+
+        if (g_ChipType == CHIP_TYPE_MSG22XX && pPacket[0] == 0xA7 && pPacket[1] == 0x00 && pPacket[2] == 0x06 && pPacket[3] == PACKET_TYPE_GESTURE_WAKEUP)
+        {
+            nWakeupMode = pPacket[4];
+            bIsCorrectFormat = 1;
+        } 
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+        else if (g_ChipType == CHIP_TYPE_MSG22XX && pPacket[0] == 0xA7 && pPacket[1] == 0x00 && pPacket[2] == 0x80 && pPacket[3] == PACKET_TYPE_GESTURE_DEBUG)
+        {
+            u32 a = 0;
+
+            nWakeupMode = pPacket[4];
+            bIsCorrectFormat = 1;
+            
+            for (a = 0; a < 0x80; a ++)
+            {
+                g_LogGestureDebug[a] = pPacket[a];
+            }
+            
+            if (!(pPacket[5] >> 7))// LCM Light Flag = 0
+            {
+                nWakeupMode = 0xFE;
+                DBG(&g_I2cClient->dev, "gesture debug mode LCM flag = 0\n");
+            }
+        }
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+        else if (g_ChipType == CHIP_TYPE_MSG22XX && pPacket[0] == 0xA7 && pPacket[1] == 0x00 && pPacket[2] == 0x80 && pPacket[3] == PACKET_TYPE_GESTURE_INFORMATION)
+        {
+            u32 a = 0;
+            u32 nTmpCount = 0;
+            u32 nWidth = 0;
+            u32 nHeight = 0;
+
+            nWakeupMode = pPacket[4];
+            bIsCorrectFormat = 1;
+
+            for (a = 0; a < 6; a ++)//header
+            {
+                g_LogGestureInfor[nTmpCount] = pPacket[a];
+                nTmpCount++;
+            }
+
+            for (a = 6; a < 126; a = a+3)//parse packet to coordinate
+            {
+                u32 nTranX = 0;
+                u32 nTranY = 0;
+                
+                _DrvFwCtrlCoordinate(&pPacket[a], &nTranX, &nTranY);
+                g_LogGestureInfor[nTmpCount] = nTranX;
+                nTmpCount++;
+                g_LogGestureInfor[nTmpCount] = nTranY;
+                nTmpCount++;
+            }
+            
+            nWidth = (((pPacket[12] & 0xF0) << 4) | pPacket[13]); //parse width & height
+            nHeight = (((pPacket[12] & 0x0F) << 8) | pPacket[14]);
+
+            DBG(&g_I2cClient->dev, "Before convert [width,height]=[%d,%d]\n", nWidth, nHeight);
+
+            if ((pPacket[12] == 0xFF) && (pPacket[13] == 0xFF) && (pPacket[14] == 0xFF))
+            {
+                nWidth = 0; 
+                nHeight = 0; 
+            }
+            else
+            {
+                nWidth = (nWidth * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+                nHeight = (nHeight * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG(&g_I2cClient->dev, "After convert [width,height]=[%d,%d]\n", nWidth, nHeight);
+            }
+
+            g_LogGestureInfor[10] = nWidth;
+            g_LogGestureInfor[11] = nHeight;
+            
+            g_LogGestureInfor[nTmpCount] = pPacket[126]; //Dummy
+            nTmpCount++;
+            g_LogGestureInfor[nTmpCount] = pPacket[127]; //checksum
+            nTmpCount++;
+            DBG(&g_I2cClient->dev, "gesture information mode Count = %d\n", nTmpCount);
+        }
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+        else if (g_ChipType == CHIP_TYPE_MSG21XXA && pPacket[0] == 0x52 && pPacket[1] == 0xFF && pPacket[2] == 0xFF && pPacket[3] == 0xFF && pPacket[4] == 0xFF && pPacket[6] == 0xFF)
+        {
+            nWakeupMode = pPacket[5];
+            bIsCorrectFormat = 1;
+        }
+        
+        if (bIsCorrectFormat) 
+        {
+
+            int keycode = 0;
+            DBG(&g_I2cClient->dev, "nWakeupMode = 0x%x\n", nWakeupMode);
+
+            switch (nWakeupMode)
+            {
+                case 0x58:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG)
+					{
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by DOUBLE_CLICK gesture wakeup.\n");
+						keycode = KEY_P;
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					 }
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;		
+                case 0x60:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG)
+					{
+						keycode = KEY_UP; 
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG;
+	                    
+	                    DBG(&g_I2cClient->dev, "Light up screen by UP_DIRECT gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_UP, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_UP, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					 }
+
+                    break;		
+                case 0x61:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG)
+					{
+						keycode = KEY_DOWN;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by DOWN_DIRECT gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_DOWN, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_DOWN, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					 }
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;		
+                case 0x62:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG)
+					{
+						keycode = KEY_LEFT;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by LEFT_DIRECT gesture wakeup.\n");
+
+	//                  input_report_key(g_InputDevice, KEY_LEFT, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_LEFT, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;		
+                case 0x63:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG)
+					{
+						keycode = KEY_RIGHT;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by RIGHT_DIRECT gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_RIGHT, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_RIGHT, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;		
+                case 0x64:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG)
+					{
+						keycode = KEY_M;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by m_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_M, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_M, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;		
+                case 0x65:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG)
+					{
+						keycode = KEY_W;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by W_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_W, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_W, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;		
+                case 0x66:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG)
+					{
+						keycode = KEY_C;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by C_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_C, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_C, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;
+                case 0x67:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG)
+					{
+						keycode = KEY_E;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by e_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_E, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_E, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;
+                case 0x68:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG)
+					{
+						keycode = KEY_V;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by V_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_V, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_V, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;
+                case 0x69:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG)
+					{
+						keycode = KEY_O;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by O_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_O, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_O, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;
+                case 0x6A:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG)
+					{
+						keycode = KEY_S;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by S_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_S, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_S, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;
+                case 0x6B:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG)
+					{
+						keycode = KEY_Z;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by Z_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_Z, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_Z, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;
+                case 0x6C:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE1_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE1_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER1, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER1, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x6D:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE2_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE2_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER2, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER2, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x6E:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE3_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE3_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER3, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER3, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+#ifdef CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+                case 0x6F:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE4_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE4_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER4, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER4, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x70:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE5_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE5_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER5, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER5, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x71:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE6_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE6_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER6, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER6, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x72:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE7_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE7_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER7, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER7, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x73:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE8_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE8_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER8, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER8, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x74:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE9_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE9_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER9, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER9, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x75:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE10_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE10_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER10, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER10, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x76:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE11_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE11_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER11, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER11, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x77:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE12_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE12_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER12, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER12, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x78:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE13_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE13_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER13, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER13, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x79:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE14_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE14_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER14, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER14, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x7A:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE15_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE15_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER15, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER15, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x7B:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE16_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE16_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER16, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER16, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x7C:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE17_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE17_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER17, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER17, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x7D:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE18_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE18_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER18, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER18, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x7E:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE19_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE19_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER19, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER19, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x7F:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE20_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE20_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER20, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER20, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x80:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE21_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE21_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER21, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER21, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x81:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE22_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE22_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER22, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER22, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x82:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE23_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE23_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER23, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER23, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x83:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE24_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE24_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER24, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER24, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x84:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE25_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE25_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER25, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER25, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x85:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE26_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE26_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER26, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER26, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x86:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE27_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE27_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER27, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER27, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x87:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE28_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE28_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER28, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER28, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x88:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE29_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE29_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER29, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER29, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x89:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE30_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE30_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER30, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER30, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x8A:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE31_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE31_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER31, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER31, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x8B:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE32_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE32_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER32, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER32, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x8C:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE33_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE33_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER33, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER33, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x8D:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE34_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE34_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER34, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER34, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x8E:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE35_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE35_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER35, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER35, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x8F:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE36_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE36_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER36, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER36, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x90:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE37_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE37_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER37, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER37, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x91:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE38_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE38_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER38, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER38, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x92:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE39_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE39_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER39, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER39, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x93:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE40_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE40_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER40, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER40, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x94:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE41_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE41_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER41, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER41, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x95:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE42_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE42_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER42, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER42, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x96:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE43_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE43_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER43, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER43, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x97:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE44_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE44_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER44, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER44, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x98:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE45_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE45_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER45, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER45, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x99:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE46_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE46_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER46, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER46, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x9A:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE47_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE47_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER47, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER47, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x9B:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE48_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE48_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER48, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER48, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x9C:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE49_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE49_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER49, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER49, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x9D:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE50_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE50_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER50, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER50, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x9E:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE51_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE51_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER51, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER51, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+#endif //CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+				case 0xFF://Gesture Fail
+	            	_gGestureWakeupValue[1] = 0xFF;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_FAIL gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER51, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER51, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+                default:
+                    _gGestureWakeupValue[0] = 0;
+                    _gGestureWakeupValue[1] = 0;
+                    DBG(&g_I2cClient->dev, "Un-supported gesture wakeup mode. Please check your device driver code.\n");
+                    break;		
+            }
+			if(keycode > 0)
+			{
+					//if(keycode != KEY_P)					
+					{
+						input_report_key(g_InputDevice, keycode, 1);
+						input_sync(g_InputDevice);
+						input_report_key(g_InputDevice, keycode, 0);
+						input_sync(g_InputDevice);
+					}
+			}
+
+            DBG(&g_I2cClient->dev, "msg2388 _gGestureWakeupValue[0] = 0x%x\n", _gGestureWakeupValue[0]);
+            DBG(&g_I2cClient->dev, "msg2388 _gGestureWakeupValue[1] = 0x%x\n", _gGestureWakeupValue[1]);
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "gesture wakeup packet format is incorrect.\n");
+        }
+        
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+        // Notify android application to retrieve log data mode packet from device driver by sysfs.
+        if (g_GestureKObj != NULL && pPacket[3] == PACKET_TYPE_GESTURE_DEBUG)
+        {
+            char *pEnvp[2];
+            s32 nRetVal = 0;
+
+            pEnvp[0] = "STATUS=GET_GESTURE_DEBUG";
+            pEnvp[1] = NULL;
+
+            nRetVal = kobject_uevent_env(g_GestureKObj, KOBJ_CHANGE, pEnvp);
+            DBG(&g_I2cClient->dev, "kobject_uevent_env() nRetVal = %d\n", nRetVal);
+        }
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+        return -1;
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+    DBG(&g_I2cClient->dev, "received raw data from touch panel as following:\n");
+    DBG(&g_I2cClient->dev, "pPacket[0]=%x \n pPacket[1]=%x pPacket[2]=%x pPacket[3]=%x pPacket[4]=%x \n pPacket[5]=%x pPacket[6]=%x pPacket[7]=%x \n", \
+                pPacket[0], pPacket[1], pPacket[2], pPacket[3], pPacket[4], pPacket[5], pPacket[6], pPacket[7]);
+
+    if ((pPacket[nCheckSumIndex] == nCheckSum) && (pPacket[0] == 0x52))   // check the checksum of packet
+    {
+        nX = (((pPacket[1] & 0xF0) << 4) | pPacket[2]);         // parse the packet to coordinate
+        nY = (((pPacket[1] & 0x0F) << 8) | pPacket[3]);
+
+        nDeltaX = (((pPacket[4] & 0xF0) << 4) | pPacket[5]);
+        nDeltaY = (((pPacket[4] & 0x0F) << 8) | pPacket[6]);
+
+        DBG(&g_I2cClient->dev, "[x,y]=[%d,%d]\n", nX, nY);
+        DBG(&g_I2cClient->dev, "[delta_x,delta_y]=[%d,%d]\n", nDeltaX, nDeltaY);
+
+#ifdef CONFIG_SWAP_X_Y
+        nTempY = nX;
+        nTempX = nY;
+        nX = nTempX;
+        nY = nTempY;
+        
+        nTempY = nDeltaX;
+        nTempX = nDeltaY;
+        nDeltaX = nTempX;
+        nDeltaY = nTempY;
+#endif
+
+#ifdef CONFIG_REVERSE_X
+        nX = 2047 - nX;
+        nDeltaX = 4095 - nDeltaX;
+#endif
+
+#ifdef CONFIG_REVERSE_Y
+        nY = 2047 - nY;
+        nDeltaY = 4095 - nDeltaY;
+#endif
+
+        /*
+         * pPacket[0]:id, pPacket[1]~pPacket[3]:the first point abs, pPacket[4]~pPacket[6]:the relative distance between the first point abs and the second point abs
+         * when pPacket[1]~pPacket[4], pPacket[6] is 0xFF, keyevent, pPacket[5] to judge which key press.
+         * pPacket[1]~pPacket[6] all are 0xFF, release touch
+        */
+        if ((pPacket[1] == 0xFF) && (pPacket[2] == 0xFF) && (pPacket[3] == 0xFF) && (pPacket[4] == 0xFF) && (pPacket[6] == 0xFF))
+        {
+            pInfo->tPoint[0].nX = 0; // final X coordinate
+            pInfo->tPoint[0].nY = 0; // final Y coordinate
+
+            if ((pPacket[5] != 0x00) && (pPacket[5] != 0xFF)) /* pPacket[5] is key value */
+            {   /* 0x00 is key up, 0xff is touch screen up */
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+                DBG(&g_I2cClient->dev, "g_EnableTpProximity = %d, pPacket[5] = 0x%x\n", g_EnableTpProximity, pPacket[5]);
+
+                if (g_EnableTpProximity && ((pPacket[5] == 0x80) || (pPacket[5] == 0x40)))
+                {
+                    if (pPacket[5] == 0x80) // close to
+                    {
+                        g_FaceClosingTp = 1;
+
+                        input_report_abs(g_ProximityInputDevice, ABS_DISTANCE, 0);
+                        input_sync(g_ProximityInputDevice);
+                    }
+                    else if (pPacket[5] == 0x40) // far away
+                    {
+                        g_FaceClosingTp = 0;
+
+                        input_report_abs(g_ProximityInputDevice, ABS_DISTANCE, 1);
+                        input_sync(g_ProximityInputDevice);
+                    }
+
+                    DBG(&g_I2cClient->dev, "g_FaceClosingTp = %d\n", g_FaceClosingTp);
+                   
+                    return -1;
+                }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+                if (g_EnableTpProximity && ((pPacket[5] == 0x80) || (pPacket[5] == 0x40)))
+                {
+                    int nErr;
+                    hwm_sensor_data tSensorData;
+
+                    if (pPacket[5] == 0x80) // close to
+                    {
+                        g_FaceClosingTp = 0;
+                    }
+                    else if (pPacket[5] == 0x40) // far away
+                    {
+                        g_FaceClosingTp = 1;
+                    }
+                    
+                    DBG(&g_I2cClient->dev, "g_FaceClosingTp = %d\n", g_FaceClosingTp);
+
+                    // map and store data to hwm_sensor_data
+                    tSensorData.values[0] = DrvPlatformLyrGetTpPsData();
+                    tSensorData.value_divide = 1;
+                    tSensorData.status = SENSOR_STATUS_ACCURACY_MEDIUM;
+                    // let up layer to know
+                    if ((nErr = hwmsen_get_interrupt_data(ID_PROXIMITY, &tSensorData)))
+                    {
+                        DBG(&g_I2cClient->dev, "call hwmsen_get_interrupt_data() failed = %d\n", nErr);
+                    }
+                    
+                    return -1;
+                }
+#endif               
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+                /* 0x00 is key up, 0xff is touch screen up */
+                DBG(&g_I2cClient->dev, "touch key down pPacket[5]=%d\n", pPacket[5]);
+
+                pInfo->nFingerNum = 1;
+                pInfo->nTouchKeyCode = pPacket[5];
+                pInfo->nTouchKeyMode = 1;
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+                pInfo->nFingerNum = 1;
+                pInfo->nTouchKeyCode = 0;
+                pInfo->nTouchKeyMode = 0;
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+                if (tpd_dts_data.use_tpd_button)
+                {
+              	  DBG(&g_I2cClient->dev, "use_tpd_button.\n");
+                    if (pPacket[5] == 4) // TOUCH_KEY_HOME
+                    {
+                        pInfo->tPoint[0].nX = tpd_dts_data.tpd_key_dim_local[1].key_x;
+                        pInfo->tPoint[0].nY = tpd_dts_data.tpd_key_dim_local[1].key_y;
+                    }
+                    else if (pPacket[5] == 1) // TOUCH_KEY_MENU
+                    {
+                        pInfo->tPoint[0].nX = tpd_dts_data.tpd_key_dim_local[0].key_x;
+                        pInfo->tPoint[0].nY = tpd_dts_data.tpd_key_dim_local[0].key_y;
+                    }           
+                    else if (pPacket[5] == 2) // TOUCH_KEY_BACK
+                    {
+                        pInfo->tPoint[0].nX = tpd_dts_data.tpd_key_dim_local[2].key_x;
+                        pInfo->tPoint[0].nY = tpd_dts_data.tpd_key_dim_local[2].key_y;
+                    }           
+                    else if (pPacket[5] == 8) // TOUCH_KEY_SEARCH 
+                    {	
+                        pInfo->tPoint[0].nX = tpd_dts_data.tpd_key_dim_local[3].key_x;
+                        pInfo->tPoint[0].nY = tpd_dts_data.tpd_key_dim_local[3].key_y;
+                    }
+                    else
+                    {
+                        DBG(&g_I2cClient->dev, "multi-key is pressed.\n");
+
+                        return -1;
+                    }
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+                    _gCurrPress[0] = 1;
+                    _gCurrPress[1] = 0;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+                }
+#else
+                if (pPacket[5] == 4) // TOUCH_KEY_HOME
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[1][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[1][1];
+                }
+                else if (pPacket[5] == 1) // TOUCH_KEY_MENU
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[0][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[0][1];
+                }           
+                else if (pPacket[5] == 2) // TOUCH_KEY_BACK
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[2][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[2][1];
+                }           
+                else if (pPacket[5] == 8) // TOUCH_KEY_SEARCH 
+                {	
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[3][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[3][1];
+                }
+                else
+                {
+                    DBG(&g_I2cClient->dev, "multi-key is pressed.\n");
+
+                    return -1;
+                }
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+                _gCurrPress[0] = 1;
+                _gCurrPress[1] = 0;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+            }
+            else
+            {   /* key up or touch up */
+                DBG(&g_I2cClient->dev, "touch end\n");
+                pInfo->nFingerNum = 0; //touch end
+                pInfo->nTouchKeyCode = 0;
+                pInfo->nTouchKeyMode = 0;    
+            }
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+            _gPrevTouchStatus = 0;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL 
+        }
+        else
+        {
+            pInfo->nTouchKeyMode = 0; //Touch on screen...
+
+//            if ((nDeltaX == 0) && (nDeltaY == 0))
+            if (
+#ifdef CONFIG_REVERSE_X
+                (nDeltaX == 4095)
+#else
+                (nDeltaX == 0)
+#endif
+                &&
+#ifdef CONFIG_REVERSE_Y
+                (nDeltaY == 4095)
+#else
+                (nDeltaY == 0)
+#endif
+                )
+            {   /* one touch point */
+                pInfo->nFingerNum = 1; // one touch
+                pInfo->tPoint[0].nX = (nX * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+                pInfo->tPoint[0].nY = (nY * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG(&g_I2cClient->dev, "[%s]: [x,y]=[%d,%d]\n", __func__, nX, nY);
+                DBG(&g_I2cClient->dev, "[%s]: point[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[0].nX, pInfo->tPoint[0].nY);
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+                _gCurrPress[0] = 1;
+                _gCurrPress[1] = 0;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+            }
+            else
+            {   /* two touch points */
+                u32 nX2, nY2;
+                
+                pInfo->nFingerNum = 2; // two touch
+                /* Finger 1 */
+                pInfo->tPoint[0].nX = (nX * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+                pInfo->tPoint[0].nY = (nY * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG(&g_I2cClient->dev, "[%s]: point1[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[0].nX, pInfo->tPoint[0].nY);
+                /* Finger 2 */
+                if (nDeltaX > 2048)     // transform the unsigned value to signed value
+                {
+                    nDeltaX -= 4096;
+                }
+                
+                if (nDeltaY > 2048)
+                {
+                    nDeltaY -= 4096;
+                }
+
+                nX2 = (u32)(nX + nDeltaX);
+                nY2 = (u32)(nY + nDeltaY);
+
+                pInfo->tPoint[1].nX = (nX2 * TOUCH_SCREEN_X_MAX) / TPD_WIDTH; 
+                pInfo->tPoint[1].nY = (nY2 * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG(&g_I2cClient->dev, "[%s]: point2[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[1].nX, pInfo->tPoint[1].nY);
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+                _gCurrPress[0] = 1;
+                _gCurrPress[1] = 1;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+            }
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+            if (_gPrevTouchStatus == 1)
+            {
+                for (i = 0; i < MAX_TOUCH_NUM; i ++)
+                {
+                    szX[i] = pInfo->tPoint[i].nX;
+                    szY[i] = pInfo->tPoint[i].nY;
+                }
+			
+                if (/*(pInfo->nFingerNum == 1)&&*/(nPrevTouchNum == 2))
+                {
+                    if (_DrvFwCtrlPointDistance(szX[0], szY[0], szPrevX[0], szPrevY[0]) > _DrvFwCtrlPointDistance(szX[0], szY[0], szPrevX[1], szPrevY[1]))
+                    {
+                        nChangePoints = 1;
+                    }
+                }
+                else if ((pInfo->nFingerNum == 2) && (nPrevTouchNum == 1))
+                {
+                    if (szPrevPress[0] == 1)
+                    {
+                        if(_DrvFwCtrlPointDistance(szX[0], szY[0], szPrevX[0] ,szPrevY[0]) > _DrvFwCtrlPointDistance(szX[1], szY[1], szPrevX[0], szPrevY[0]))
+                        {
+                            nChangePoints = 1;
+                        }
+                    }
+                    else
+                    {
+                        if (_DrvFwCtrlPointDistance(szX[0], szY[0], szPrevX[1], szPrevY[1]) < _DrvFwCtrlPointDistance(szX[1], szY[1], szPrevX[1], szPrevY[1]))
+                        {
+                            nChangePoints = 1;
+                        }
+                    }
+                }
+                else if ((pInfo->nFingerNum == 1) && (nPrevTouchNum == 1))
+                {
+                    if (_gCurrPress[0] != szPrevPress[0])
+                    {
+                        nChangePoints = 1;
+                    }
+                }
+//                else if ((pInfo->nFingerNum == 2) && (nPrevTouchNum == 2))
+//                {
+//                }
+
+                if (nChangePoints == 1)
+                {
+                    nTemp = _gCurrPress[0];
+                    _gCurrPress[0] = _gCurrPress[1];
+                    _gCurrPress[1] = nTemp;
+
+                    nTemp = pInfo->tPoint[0].nX;
+                    pInfo->tPoint[0].nX = pInfo->tPoint[1].nX;
+                    pInfo->tPoint[1].nX = nTemp;
+
+                    nTemp = pInfo->tPoint[0].nY;
+                    pInfo->tPoint[0].nY = pInfo->tPoint[1].nY;
+                    pInfo->tPoint[1].nY = nTemp;
+                }
+            }
+
+            // Save current status
+            for (i = 0; i < MAX_TOUCH_NUM; i ++)
+            {
+                szPrevPress[i] = _gCurrPress[i];
+                szPrevX[i] = pInfo->tPoint[i].nX;
+                szPrevY[i] = pInfo->tPoint[i].nY;
+            }
+            nPrevTouchNum = pInfo->nFingerNum;
+
+            _gPrevTouchStatus = 1;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+        }
+    }
+    else if (pPacket[nCheckSumIndex] == nCheckSum && pPacket[0] == 0x62)
+    {
+        nX = ((pPacket[1] << 8) | pPacket[2]);  // Position_X
+        nY = ((pPacket[3] << 8) | pPacket[4]);  // Position_Y
+
+        nDeltaX = ((pPacket[13] << 8) | pPacket[14]); // Distance_X
+        nDeltaY = ((pPacket[15] << 8) | pPacket[16]); // Distance_Y
+
+        DBG(&g_I2cClient->dev, "[x,y]=[%d,%d]\n", nX, nY);
+        DBG(&g_I2cClient->dev, "[delta_x,delta_y]=[%d,%d]\n", nDeltaX, nDeltaY);
+
+#ifdef CONFIG_SWAP_X_Y
+        nTempY = nX;
+        nTempX = nY;
+        nX = nTempX;
+        nY = nTempY;
+        
+        nTempY = nDeltaX;
+        nTempX = nDeltaY;
+        nDeltaX = nTempX;
+        nDeltaY = nTempY;
+#endif
+
+#ifdef CONFIG_REVERSE_X
+        nX = 2047 - nX;
+        nDeltaX = 4095 - nDeltaX;
+#endif
+
+#ifdef CONFIG_REVERSE_Y
+        nY = 2047 - nY;
+        nDeltaY = 4095 - nDeltaY;
+#endif
+
+        /*
+         * pPacket[0]:id, pPacket[1]~pPacket[4]:the first point abs, pPacket[13]~pPacket[16]:the relative distance between the first point abs and the second point abs
+         * when pPacket[1]~pPacket[7] is 0xFF, keyevent, pPacket[8] to judge which key press.
+         * pPacket[1]~pPacket[8] all are 0xFF, release touch
+         */
+        if ((pPacket[1] == 0xFF) && (pPacket[2] == 0xFF) && (pPacket[3] == 0xFF) && (pPacket[4] == 0xFF) && (pPacket[5] == 0xFF) && (pPacket[6] == 0xFF) && (pPacket[7] == 0xFF))
+        {
+            pInfo->tPoint[0].nX = 0; // final X coordinate
+            pInfo->tPoint[0].nY = 0; // final Y coordinate
+
+            if ((pPacket[8] != 0x00) && (pPacket[8] != 0xFF)) /* pPacket[8] is key value */
+            {   /* 0x00 is key up, 0xff is touch screen up */
+                DBG(&g_I2cClient->dev, "touch key down pPacket[8]=%d\n", pPacket[8]);
+                pInfo->nFingerNum = 1;
+                pInfo->nTouchKeyCode = pPacket[8];
+                pInfo->nTouchKeyMode = 1;
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+                pInfo->nFingerNum = 1;
+                pInfo->nTouchKeyCode = 0;
+                pInfo->nTouchKeyMode = 0;
+
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+                if (tpd_dts_data.use_tpd_button)
+                {
+                    if (pPacket[8] == 4) // TOUCH_KEY_HOME
+                    {
+                        pInfo->tPoint[0].nX = tpd_dts_data.tpd_key_dim_local[1].key_x;
+                        pInfo->tPoint[0].nY = tpd_dts_data.tpd_key_dim_local[1].key_y;
+                    }
+                    else if (pPacket[8] == 1) // TOUCH_KEY_MENU
+                    {
+                        pInfo->tPoint[0].nX = tpd_dts_data.tpd_key_dim_local[0].key_x;
+                        pInfo->tPoint[0].nY = tpd_dts_data.tpd_key_dim_local[0].key_y;
+                    }           
+                    else if (pPacket[8] == 2) // TOUCH_KEY_BACK
+                    {
+                        pInfo->tPoint[0].nX = tpd_dts_data.tpd_key_dim_local[2].key_x;
+                        pInfo->tPoint[0].nY = tpd_dts_data.tpd_key_dim_local[2].key_y;
+                    }           
+                    else if (pPacket[8] == 8) // TOUCH_KEY_SEARCH 
+                    {	
+                        pInfo->tPoint[0].nX = tpd_dts_data.tpd_key_dim_local[3].key_x;
+                        pInfo->tPoint[0].nY = tpd_dts_data.tpd_key_dim_local[3].key_y;
+                    }
+                    else
+                    {
+                        DBG(&g_I2cClient->dev, "multi-key is pressed.\n");
+
+                        return -1;
+                    }
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+                    _gCurrPress[0] = 1;
+                    _gCurrPress[1] = 0;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+                }
+#else
+                if (pPacket[8] == 4) // TOUCH_KEY_HOME
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[1][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[1][1];
+                }
+                else if (pPacket[8] == 1) // TOUCH_KEY_MENU
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[0][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[0][1];
+                }           
+                else if (pPacket[8] == 2) // TOUCH_KEY_BACK
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[2][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[2][1];
+                }           
+                else if (pPacket[8] == 8) // TOUCH_KEY_SEARCH 
+                {	
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[3][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[3][1];
+                }
+                else
+                {
+                    DBG(&g_I2cClient->dev, "multi-key is pressed.\n");
+
+                    return -1;
+                }
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+                _gCurrPress[0] = 1;
+                _gCurrPress[1] = 0;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+            }
+            else
+            {   /* key up or touch up */
+                DBG(&g_I2cClient->dev, "touch end\n");
+                pInfo->nFingerNum = 0; //touch end
+                pInfo->nTouchKeyCode = 0;
+                pInfo->nTouchKeyMode = 0;    
+            }
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+            _gPrevTouchStatus = 0;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL 
+        }
+        else
+        {
+            pInfo->nTouchKeyMode = 0; //Touch on screen...
+
+//            if ((nDeltaX == 0) && (nDeltaY == 0))
+            if (
+#ifdef CONFIG_REVERSE_X
+                (nDeltaX == 4095)
+#else
+                (nDeltaX == 0)
+#endif
+                &&
+#ifdef CONFIG_REVERSE_Y
+                (nDeltaY == 4095)
+#else
+                (nDeltaY == 0)
+#endif
+                )
+            {   /* one touch point */
+                pInfo->nFingerNum = 1; // one touch
+                pInfo->tPoint[0].nX = (nX * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+                pInfo->tPoint[0].nY = (nY * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG(&g_I2cClient->dev, "[%s]: [x,y]=[%d,%d]\n", __func__, nX, nY);
+                DBG(&g_I2cClient->dev, "[%s]: point[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[0].nX, pInfo->tPoint[0].nY);
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+                _gCurrPress[0] = 1;
+                _gCurrPress[1] = 0;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+            }
+            else
+            {   /* two touch points */
+                u32 nX2, nY2;
+                
+                pInfo->nFingerNum = 2; // two touch
+                /* Finger 1 */
+                pInfo->tPoint[0].nX = (nX * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+                pInfo->tPoint[0].nY = (nY * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG(&g_I2cClient->dev, "[%s]: point1[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[0].nX, pInfo->tPoint[0].nY);
+                /* Finger 2 */
+                if (nDeltaX > 2048)     // transform the unsigned value to signed value
+                {
+                    nDeltaX -= 4096;
+                }
+                
+                if (nDeltaY > 2048)
+                {
+                    nDeltaY -= 4096;
+                }
+
+                nX2 = (u32)(nX + nDeltaX);
+                nY2 = (u32)(nY + nDeltaY);
+
+                pInfo->tPoint[1].nX = (nX2 * TOUCH_SCREEN_X_MAX) / TPD_WIDTH; 
+                pInfo->tPoint[1].nY = (nY2 * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG(&g_I2cClient->dev, "[%s]: point2[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[1].nX, pInfo->tPoint[1].nY);
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+                _gCurrPress[0] = 1;
+                _gCurrPress[1] = 1;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+            }
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+            if (_gPrevTouchStatus == 1)
+            {
+                for (i = 0; i < MAX_TOUCH_NUM; i ++)
+                {
+                    szX[i] = pInfo->tPoint[i].nX;
+                    szY[i] = pInfo->tPoint[i].nY;
+                }
+			
+                if (/*(pInfo->nFingerNum == 1)&&*/(nPrevTouchNum == 2))
+                {
+                    if (_DrvFwCtrlPointDistance(szX[0], szY[0], szPrevX[0], szPrevY[0]) > _DrvFwCtrlPointDistance(szX[0], szY[0], szPrevX[1], szPrevY[1]))
+                    {
+                        nChangePoints = 1;
+                    }
+                }
+                else if ((pInfo->nFingerNum == 2) && (nPrevTouchNum == 1))
+                {
+                    if (szPrevPress[0] == 1)
+                    {
+                        if(_DrvFwCtrlPointDistance(szX[0], szY[0], szPrevX[0] ,szPrevY[0]) > _DrvFwCtrlPointDistance(szX[1], szY[1], szPrevX[0], szPrevY[0]))
+                        {
+                            nChangePoints = 1;
+                        }
+                    }
+                    else
+                    {
+                        if (_DrvFwCtrlPointDistance(szX[0], szY[0], szPrevX[1], szPrevY[1]) < _DrvFwCtrlPointDistance(szX[1], szY[1], szPrevX[1], szPrevY[1]))
+                        {
+                            nChangePoints = 1;
+                        }
+                    }
+                }
+                else if ((pInfo->nFingerNum == 1) && (nPrevTouchNum == 1))
+                {
+                    if (_gCurrPress[0] != szPrevPress[0])
+                    {
+                        nChangePoints = 1;
+                    }
+                }
+//                else if ((pInfo->nFingerNum == 2) && (nPrevTouchNum == 2))
+//                {
+//                }
+
+                if (nChangePoints == 1)
+                {
+                    nTemp = _gCurrPress[0];
+                    _gCurrPress[0] = _gCurrPress[1];
+                    _gCurrPress[1] = nTemp;
+
+                    nTemp = pInfo->tPoint[0].nX;
+                    pInfo->tPoint[0].nX = pInfo->tPoint[1].nX;
+                    pInfo->tPoint[1].nX = nTemp;
+
+                    nTemp = pInfo->tPoint[0].nY;
+                    pInfo->tPoint[0].nY = pInfo->tPoint[1].nY;
+                    pInfo->tPoint[1].nY = nTemp;
+                }
+            }
+
+            // Save current status
+            for (i = 0; i < MAX_TOUCH_NUM; i ++)
+            {
+                szPrevPress[i] = _gCurrPress[i];
+                szPrevX[i] = pInfo->tPoint[i].nX;
+                szPrevY[i] = pInfo->tPoint[i].nY;
+            }
+            nPrevTouchNum = pInfo->nFingerNum;
+
+            _gPrevTouchStatus = 1;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+            // Notify android application to retrieve log data mode packet from device driver by sysfs.   
+            if (g_TouchKObj != NULL)
+            {
+                char *pEnvp[2];
+                s32 nRetVal = 0; 
+
+                pEnvp[0] = "STATUS=GET_PACKET";  
+                pEnvp[1] = NULL;  
+    
+                nRetVal = kobject_uevent_env(g_TouchKObj, KOBJ_CHANGE, pEnvp); 
+                DBG(&g_I2cClient->dev, "kobject_uevent_env() nRetVal = %d\n", nRetVal);
+            }
+        }
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "pPacket[0]=0x%x, pPacket[7]=0x%x, nCheckSum=0x%x\n", pPacket[0], pPacket[7], nCheckSum);
+
+        if (pPacket[nCheckSumIndex] != nCheckSum)
+        {
+            DBG(&g_I2cClient->dev, "WRONG CHECKSUM\n");
+            return -1;
+        }
+
+        if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE && pPacket[0] != 0x52)
+        {
+            DBG(&g_I2cClient->dev, "WRONG DEMO MODE HEADER\n");
+            return -1;
+        }
+        else if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE && pPacket[0] != 0x62)
+        {
+            DBG(&g_I2cClient->dev, "WRONG DEBUG MODE HEADER\n");
+            return -1;
+        }
+        else if (g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE && pPacket[0] != 0x62)
+        {
+            DBG(&g_I2cClient->dev, "WRONG RAW DATA MODE HEADER\n");
+            return -1;
+        }
+    }
+
+    return 0;
+}
+#ifdef CONFIG_ENABLE_APK_PRINT_FW_LOG
+#define N_BYTES_EVERY_TIME (MUTUAL_DEMO_MODE_PACKET_LENGTH-2)
+u8 bCallApkToGetFwLog = 0;
+ unsigned char szPrint[256] = {0};
+void notifyApk(unsigned char *pFwLog)
+{
+	printk("APK_PRINT_FW_LOG:%s\n",pFwLog);
+	if (g_TouchKObj != NULL)
+	{
+	    char *pEnvp[2];
+
+	    pEnvp[0] = "STATUS=GET_FW_LOG";  
+	    pEnvp[1] = NULL;  
+		
+	     bCallApkToGetFwLog = 1;
+	     kobject_uevent_env(g_TouchKObj, KOBJ_CHANGE, pEnvp); 
+	}
+}
+int printFunc(unsigned char *pPacket)
+{
+	int i = 0;
+	static int cnt = 0;
+	 if (pPacket[0] == 0x2C)
+	{
+		if(pPacket[1]==1)
+		{
+			for(i=0;i<N_BYTES_EVERY_TIME;i++)
+			{
+				szPrint[i+cnt*N_BYTES_EVERY_TIME] = pPacket[2+i];
+			}
+			notifyApk(szPrint);
+			cnt=0;
+		}
+		else
+		{
+			for(i=0;i<N_BYTES_EVERY_TIME;i++)
+			{
+				szPrint[i+cnt*N_BYTES_EVERY_TIME] = pPacket[2+i];
+			}
+			cnt++;
+		}
+		return 0;
+	}
+	
+	 return -1;
+}
+#endif
+static s32 _DrvFwCtrlMutualParsePacket(u8 *pPacket, u16 nLength, MutualTouchInfo_t *pInfo) // for MSG26xxM/MSG28xx
+{
+    u32 i;
+    u8 nCheckSum = 0;
+    u32 nX = 0, nY = 0;
+#ifdef ESD_RESET_FLAG
+ static u8 n_ESDCnt = 0;
+#endif
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+    if (g_IsEnableReportRate == 1)
+    {
+        if (g_InterruptCount == 4294967295)
+        {
+            g_InterruptCount = 0; // Reset count if overflow
+            DBG(&g_I2cClient->dev, "g_InterruptCount reset to 0\n");
+        }	
+
+        if (g_InterruptCount == 0)
+        {
+            // Get start time
+            do_gettimeofday(&g_StartTime);
+    
+            DBG(&g_I2cClient->dev, "Start time : %lu sec, %lu msec\n", g_StartTime.tv_sec,  g_StartTime.tv_usec); 
+        }
+        
+        g_InterruptCount ++;
+
+        DBG(&g_I2cClient->dev, "g_InterruptCount = %d\n", g_InterruptCount);
+    }
+#endif //CONFIG_ENABLE_COUNT_REPORT_RATE
+
+    DBG(&g_I2cClient->dev, "received raw data from touch panel as following:\n");
+    DBG(&g_I2cClient->dev, "pPacket[0]=%x \n pPacket[1]=%x pPacket[2]=%x pPacket[3]=%x pPacket[4]=%x \n pPacket[5]=%x pPacket[6]=%x pPacket[7]=%x pPacket[8]=%x \n", \
+                pPacket[0], pPacket[1], pPacket[2], pPacket[3], pPacket[4], pPacket[5], pPacket[6], pPacket[7], pPacket[8]);
+
+    nCheckSum = DrvCommonCalculateCheckSum(&pPacket[0], (nLength-1));
+    DBG(&g_I2cClient->dev, "checksum : [%x] == [%x]? \n", pPacket[nLength-1], nCheckSum);
+
+#ifdef CONFIG_ENABLE_APK_PRINT_FW_LOG
+if(0==printFunc(pPacket))
+{
+        printk("APK_PRINT_FW_LOG\n");
+        return -1;
+}
+#endif
+#ifdef ESD_RESET_FLAG
+ if ((pPacket[nLength-1] != nCheckSum) && (pPacket[nLength-1] == 0xFF))
+#else
+    if (pPacket[nLength-1] != nCheckSum)
+#endif
+    {
+ #ifdef ESD_RESET_FLAG
+      if(n_ESDCnt < ESD_RESET_FLAG)
+	  	n_ESDCnt++;
+	else
+	{
+		n_ESDCnt = 0;
+		DrvPlatformLyrTouchDeviceResetHw();		
+	}
+#endif
+        DBG(&g_I2cClient->dev, "WRONG CHECKSUM\n");
+        return -1;
+    }
+ #ifdef ESD_RESET_FLAG
+	else
+	{
+		n_ESDCnt = 0;		
+	}
+#endif
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (g_GestureWakeupFlag == 1)
+    {
+        u8 nWakeupMode = 0;
+        u8 bIsCorrectFormat = 0;
+
+        DBG(&g_I2cClient->dev, "received raw data from touch panel as following:\n");
+        DBG(&g_I2cClient->dev, "pPacket[0]=%x \n pPacket[1]=%x pPacket[2]=%x pPacket[3]=%x pPacket[4]=%x pPacket[5]=%x \n", \
+                pPacket[0], pPacket[1], pPacket[2], pPacket[3], pPacket[4], pPacket[5]);
+
+        if (pPacket[0] == 0xA7 && pPacket[1] == 0x00 && pPacket[2] == 0x06 && pPacket[3] == PACKET_TYPE_GESTURE_WAKEUP) 
+        {
+            nWakeupMode = pPacket[4];
+            bIsCorrectFormat = 1;
+        }
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+        else if (pPacket[0] == 0xA7 && pPacket[1] == 0x00 && pPacket[2] == 0x80 && pPacket[3] == PACKET_TYPE_GESTURE_DEBUG)
+        {
+            u32 a = 0;
+
+            nWakeupMode = pPacket[4];
+            bIsCorrectFormat = 1;
+            
+            for (a = 0; a < 0x80; a ++)
+            {
+                g_LogGestureDebug[a] = pPacket[a];
+            }
+
+            if (!(pPacket[5] >> 7))// LCM Light Flag = 0
+            {
+                nWakeupMode = 0xFE;
+                DBG(&g_I2cClient->dev, "gesture debug mode LCM flag = 0\n");
+            }
+        }
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+        else if (pPacket[0] == 0xA7 && pPacket[1] == 0x00 && pPacket[2] == 0x80 && pPacket[3] == PACKET_TYPE_GESTURE_INFORMATION)
+        {
+            u32 a = 0;
+            u32 nTmpCount = 0;
+            u32 nWidth = 0;
+            u32 nHeight = 0;
+
+            nWakeupMode = pPacket[4];
+            bIsCorrectFormat = 1;
+
+            for (a = 0; a < 6; a ++)//header
+            {
+                g_LogGestureInfor[nTmpCount] = pPacket[a];
+                nTmpCount++;
+            }
+
+            for (a = 6; a < 126; a = a+3)//parse packet to coordinate
+            {
+                u32 nTranX = 0;
+                u32 nTranY = 0;
+				
+                _DrvFwCtrlCoordinate(&pPacket[a], &nTranX, &nTranY);
+                g_LogGestureInfor[nTmpCount] = nTranX;
+                nTmpCount++;
+                g_LogGestureInfor[nTmpCount] = nTranY;
+                nTmpCount++;
+            }
+						
+            nWidth = (((pPacket[12] & 0xF0) << 4) | pPacket[13]); //parse width & height
+            nHeight = (((pPacket[12] & 0x0F) << 8) | pPacket[14]);
+
+            DBG(&g_I2cClient->dev, "Before convert [width,height]=[%d,%d]\n", nWidth, nHeight);
+
+            if ((pPacket[12] == 0xFF) && (pPacket[13] == 0xFF) && (pPacket[14] == 0xFF))
+            {
+                nWidth = 0; 
+                nHeight = 0; 
+            }
+            else
+            {
+                nWidth = (nWidth * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+                nHeight = (nHeight * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG(&g_I2cClient->dev, "After convert [width,height]=[%d,%d]\n", nWidth, nHeight);
+            }
+
+            g_LogGestureInfor[10] = nWidth;
+            g_LogGestureInfor[11] = nHeight;
+    
+            g_LogGestureInfor[nTmpCount] = pPacket[126]; //Dummy
+            nTmpCount++;
+            g_LogGestureInfor[nTmpCount] = pPacket[127]; //checksum
+            nTmpCount++;
+            DBG(&g_I2cClient->dev, "gesture information mode Count = %d\n", nTmpCount);
+        }
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+
+        if (bIsCorrectFormat)
+        {
+        	int keycode = 0;
+            DBG(&g_I2cClient->dev, "nWakeupMode = 0x%x\n", nWakeupMode);
+
+            switch (nWakeupMode)
+            {
+                case 0x58:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG)
+					{
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by DOUBLE_CLICK gesture wakeup.\n");
+						keycode = KEY_P;
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					 }
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;		
+                case 0x60:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG)
+					{
+						keycode = KEY_UP; 
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG;
+	                    
+	                    DBG(&g_I2cClient->dev, "Light up screen by UP_DIRECT gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_UP, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_UP, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					 }
+
+                    break;		
+                case 0x61:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG)
+					{
+						keycode = KEY_DOWN;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by DOWN_DIRECT gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_DOWN, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_DOWN, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					 }
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;		
+                case 0x62:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG)
+					{
+						keycode = KEY_LEFT;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by LEFT_DIRECT gesture wakeup.\n");
+
+	//                  input_report_key(g_InputDevice, KEY_LEFT, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_LEFT, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;		
+                case 0x63:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG)
+					{
+						keycode = KEY_RIGHT;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by RIGHT_DIRECT gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_RIGHT, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_RIGHT, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;		
+                case 0x64:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG)
+					{
+						keycode = KEY_M;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by m_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_M, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_M, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;		
+                case 0x65:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG)
+					{
+						keycode = KEY_W;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by W_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_W, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_W, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;		
+                case 0x66:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG)
+					{
+						keycode = KEY_C;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by C_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_C, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_C, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;
+                case 0x67:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG)
+					{
+						keycode = KEY_E;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by e_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_E, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_E, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;
+                case 0x68:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG)
+					{
+						keycode = KEY_V;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by V_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_V, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_V, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;
+                case 0x69:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG)
+					{
+						keycode = KEY_O;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by O_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_O, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_O, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;
+                case 0x6A:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG)
+					{
+						keycode = KEY_S;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by S_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_S, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_S, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;
+                case 0x6B:
+					if(g_GestureWakeupMode[0] & GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG)
+					{
+						keycode = KEY_Z;
+
+	                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG;
+
+	                    DBG(&g_I2cClient->dev, "Light up screen by Z_CHARACTER gesture wakeup.\n");
+
+	//                    input_report_key(g_InputDevice, KEY_Z, 1);
+	                    input_report_key(g_InputDevice, KEY_POWER, 1);
+	                    input_sync(g_InputDevice);
+	//                    input_report_key(g_InputDevice, KEY_Z, 0);
+	                    input_report_key(g_InputDevice, KEY_POWER, 0);
+	                    input_sync(g_InputDevice);
+					}
+					 else
+					 {
+						_gGestureWakeupValue[0] = 0;
+						_gGestureWakeupValue[1] = 0;
+					}
+
+                    break;
+                case 0x6C:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE1_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE1_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER1, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER1, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x6D:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE2_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE2_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER2, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER2, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x6E:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE3_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE3_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER3, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER3, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+#ifdef CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+                case 0x6F:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE4_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE4_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER4, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER4, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x70:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE5_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE5_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER5, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER5, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x71:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE6_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE6_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER6, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER6, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x72:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE7_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE7_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER7, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER7, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x73:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE8_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE8_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER8, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER8, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x74:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE9_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE9_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER9, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER9, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x75:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE10_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE10_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER10, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER10, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x76:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE11_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE11_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER11, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER11, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x77:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE12_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE12_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER12, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER12, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x78:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE13_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE13_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER13, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER13, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x79:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE14_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE14_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER14, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER14, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x7A:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE15_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE15_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER15, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER15, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x7B:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE16_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE16_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER16, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER16, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x7C:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE17_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE17_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER17, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER17, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x7D:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE18_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE18_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER18, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER18, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x7E:
+                    _gGestureWakeupValue[0] = GESTURE_WAKEUP_MODE_RESERVE19_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE19_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER19, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER19, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x7F:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE20_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE20_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER20, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER20, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x80:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE21_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE21_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER21, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER21, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x81:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE22_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE22_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER22, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER22, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x82:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE23_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE23_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER23, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER23, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x83:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE24_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE24_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER24, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER24, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x84:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE25_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE25_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER25, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER25, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x85:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE26_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE26_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER26, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER26, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x86:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE27_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE27_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER27, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER27, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x87:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE28_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE28_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER28, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER28, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x88:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE29_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE29_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER29, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER29, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x89:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE30_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE30_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER30, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER30, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x8A:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE31_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE31_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER31, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER31, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x8B:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE32_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE32_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER32, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER32, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x8C:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE33_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE33_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER33, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER33, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x8D:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE34_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE34_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER34, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER34, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x8E:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE35_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE35_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER35, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER35, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x8F:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE36_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE36_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER36, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER36, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x90:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE37_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE37_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER37, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER37, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x91:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE38_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE38_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER38, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER38, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x92:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE39_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE39_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER39, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER39, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x93:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE40_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE40_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER40, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER40, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x94:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE41_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE41_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER41, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER41, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x95:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE42_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE42_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER42, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER42, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x96:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE43_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE43_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER43, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER43, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x97:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE44_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE44_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER44, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER44, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x98:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE45_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE45_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER45, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER45, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x99:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE46_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE46_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER46, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER46, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x9A:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE47_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE47_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER47, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER47, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x9B:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE48_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE48_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER48, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER48, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x9C:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE49_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE49_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER49, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER49, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x9D:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE50_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE50_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER50, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER50, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x9E:
+                    _gGestureWakeupValue[1] = GESTURE_WAKEUP_MODE_RESERVE51_FLAG;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_RESERVE51_FLAG gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER51, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER51, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+#endif //CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+                case 0xFF://Gesture Fail
+                    _gGestureWakeupValue[1] = 0xFF;
+
+                    DBG(&g_I2cClient->dev, "Light up screen by GESTURE_WAKEUP_MODE_FAIL gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, RESERVER51, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, RESERVER51, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+                default:
+                    _gGestureWakeupValue[0] = 0;
+                    _gGestureWakeupValue[1] = 0;
+                    DBG(&g_I2cClient->dev, "Un-supported gesture wakeup mode. Please check your device driver code.\n");
+                    break;		
+            }
+			
+			 if(keycode > 0)
+			{
+					if(keycode != KEY_P)					
+					{
+						input_report_key(g_InputDevice, keycode, 1);
+						input_sync(g_InputDevice);
+						input_report_key(g_InputDevice, keycode, 0);
+						input_sync(g_InputDevice);
+					}
+			}	
+
+            DBG(&g_I2cClient->dev, "_gGestureWakeupValue = 0x%x, 0x%x\n", _gGestureWakeupValue[0], _gGestureWakeupValue[1]);
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "gesture wakeup packet format is incorrect.\n");
+        }
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+        // Notify android application to retrieve log data mode packet from device driver by sysfs.
+        if (g_GestureKObj != NULL && pPacket[3] == PACKET_TYPE_GESTURE_DEBUG)
+        {
+            char *pEnvp[2];
+            s32 nRetVal = 0;
+
+            pEnvp[0] = "STATUS=GET_GESTURE_DEBUG";
+            pEnvp[1] = NULL;
+
+            nRetVal = kobject_uevent_env(g_GestureKObj, KOBJ_CHANGE, pEnvp);
+            DBG(&g_I2cClient->dev, "kobject_uevent_env() STATUS=GET_GESTURE_DEBUG, nRetVal = %d\n", nRetVal);
+        }
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+        return -1;
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+
+    if (IS_FIRMWARE_DATA_LOG_ENABLED)
+    {    	
+        if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE && pPacket[0] != 0x5A)
+        {
+#ifdef CONFIG_ENABLE_HOTKNOT 
+            if (pPacket[3] != HOTKNOT_PACKET_TYPE && pPacket[3] != HOTKNOT_RECEIVE_PACKET_TYPE)
+#endif //CONFIG_ENABLE_HOTKNOT 
+            {
+                DBG(&g_I2cClient->dev, "WRONG DEMO MODE HEADER\n");
+                return -1;
+            }
+        }
+        else if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE && pPacket[0] != 0xA5 && pPacket[0] != 0xAB && (pPacket[0] != 0xA7 && pPacket[3] != PACKET_TYPE_TOOTH_PATTERN))
+        {
+            DBG(&g_I2cClient->dev, "WRONG DEBUG MODE HEADER\n");
+            return -1;
+        }
+    }
+    else
+    {
+        if (pPacket[0] != 0x5A)
+        {
+#ifdef CONFIG_ENABLE_HOTKNOT 
+            if (pPacket[3] != HOTKNOT_PACKET_TYPE && pPacket[3] != HOTKNOT_RECEIVE_PACKET_TYPE)
+#endif //CONFIG_ENABLE_HOTKNOT            
+            {
+                DBG(&g_I2cClient->dev, "WRONG DEMO MODE HEADER\n");
+                return -1;        
+            }
+        }
+    } //IS_FIRMWARE_DATA_LOG_ENABLED
+
+    // Process raw data...
+    if (pPacket[0] == 0x5A)
+    {
+#ifdef CONFIG_ENABLE_HOTKNOT
+        if (((DemoHotKnotCmdRet_t*)pPacket)->nIdentify == DEMO_PD_PACKET_IDENTIFY)
+        {
+            ReportHotKnotCmd(pPacket, nLength);				                       
+            return -1;    //return 0 will run key procedure  
+        }
+        else  
+#endif //CONFIG_ENABLE_HOTKNOT  
+        {
+            for (i = 0; i < MAX_TOUCH_NUM; i ++)
+            {
+                if ((pPacket[(4*i)+1] == 0xFF) && (pPacket[(4*i)+2] == 0xFF) && (pPacket[(4*i)+3] == 0xFF))
+                {
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+                    _gCurrentTouch[i] = 0;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+                    
+                    continue;
+                }
+		
+                nX = (((pPacket[(4*i)+1] & 0xF0) << 4) | (pPacket[(4*i)+2]));
+                nY = (((pPacket[(4*i)+1] & 0x0F) << 8) | (pPacket[(4*i)+3]));
+                
+                pInfo->tPoint[pInfo->nCount].nX = nX * TOUCH_SCREEN_X_MAX / TPD_WIDTH;
+                pInfo->tPoint[pInfo->nCount].nY = nY * TOUCH_SCREEN_Y_MAX / TPD_HEIGHT;
+                pInfo->tPoint[pInfo->nCount].nP = pPacket[4*(i+1)];
+                pInfo->tPoint[pInfo->nCount].nId = i;
+		
+                DBG(&g_I2cClient->dev, "[x,y]=[%d,%d]\n", nX, nY);
+                DBG(&g_I2cClient->dev, "point[%d] : (%d,%d) = %d\n", pInfo->tPoint[pInfo->nCount].nId, pInfo->tPoint[pInfo->nCount].nX, pInfo->tPoint[pInfo->nCount].nY, pInfo->tPoint[pInfo->nCount].nP);
+		
+                pInfo->nCount ++;
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+                _gCurrentTouch[i] = 1;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+            }
+
+            // Notify android application to retrieve demo mode packet from device driver by sysfs.   
+            if (g_TouchKObj != NULL)
+            {
+                char *pEnvp[2];
+                s32 nRetVal = 0;  
+
+                pEnvp[0] = "STATUS=GET_DEMO_MODE_PACKET";  
+                pEnvp[1] = NULL;  
+            
+                nRetVal = kobject_uevent_env(g_TouchKObj, KOBJ_CHANGE, pEnvp); 
+                DBG(&g_I2cClient->dev, "kobject_uevent_env() STATUS=GET_DEMO_MODE_PACKET, nRetVal = %d\n", nRetVal);
+            }
+        }
+    }
+    else if (pPacket[0] == 0xA5 || pPacket[0] == 0xAB)
+    {
+        for (i = 0; i < MAX_TOUCH_NUM; i ++)
+        {
+            if ((pPacket[(3*i)+4] == 0xFF) && (pPacket[(3*i)+5] == 0xFF) && (pPacket[(3*i)+6] == 0xFF))
+            {
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+                _gCurrentTouch[i] = 0;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+                continue;
+            }
+		
+            nX = (((pPacket[(3*i)+4] & 0xF0) << 4) | (pPacket[(3*i)+5]));
+            nY = (((pPacket[(3*i)+4] & 0x0F) << 8) | (pPacket[(3*i)+6]));
+
+            pInfo->tPoint[pInfo->nCount].nX = nX * TOUCH_SCREEN_X_MAX / TPD_WIDTH;
+            pInfo->tPoint[pInfo->nCount].nY = nY * TOUCH_SCREEN_Y_MAX / TPD_HEIGHT;
+            pInfo->tPoint[pInfo->nCount].nP = 1;
+            pInfo->tPoint[pInfo->nCount].nId = i;
+		
+            DBG(&g_I2cClient->dev, "[x,y]=[%d,%d]\n", nX, nY);
+            DBG(&g_I2cClient->dev, "point[%d] : (%d,%d) = %d\n", pInfo->tPoint[pInfo->nCount].nId, pInfo->tPoint[pInfo->nCount].nX, pInfo->tPoint[pInfo->nCount].nY, pInfo->tPoint[pInfo->nCount].nP);
+		
+            pInfo->nCount ++;
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+            _gCurrentTouch[i] = 1;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+        }
+
+        // Notify android application to retrieve debug mode packet from device driver by sysfs.   
+        if (g_TouchKObj != NULL)
+        {
+            char *pEnvp[2];
+            s32 nRetVal = 0;  
+
+            pEnvp[0] = "STATUS=GET_DEBUG_MODE_PACKET";  
+            pEnvp[1] = NULL;  
+            
+            nRetVal = kobject_uevent_env(g_TouchKObj, KOBJ_CHANGE, pEnvp); 
+            DBG(&g_I2cClient->dev, "kobject_uevent_env() STATUS=GET_DEBUG_MODE_PACKET, nRetVal = %d\n", nRetVal);
+        }
+    }
+    else if (pPacket[0] == 0xA7 && pPacket[3] == PACKET_TYPE_TOOTH_PATTERN)
+    {
+        for (i = 0; i < MAX_TOUCH_NUM; i ++)
+        {
+            if ((pPacket[(3*i)+5] == 0xFF) && (pPacket[(3*i)+6] == 0xFF) && (pPacket[(3*i)+7] == 0xFF))
+            {
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+                _gCurrentTouch[i] = 0;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+                continue;
+            }
+		
+            nX = (((pPacket[(3*i)+5] & 0xF0) << 4) | (pPacket[(3*i)+6]));
+            nY = (((pPacket[(3*i)+5] & 0x0F) << 8) | (pPacket[(3*i)+7]));
+
+            pInfo->tPoint[pInfo->nCount].nX = nX * TOUCH_SCREEN_X_MAX / TPD_WIDTH;
+            pInfo->tPoint[pInfo->nCount].nY = nY * TOUCH_SCREEN_Y_MAX / TPD_HEIGHT;
+            pInfo->tPoint[pInfo->nCount].nP = 1;
+            pInfo->tPoint[pInfo->nCount].nId = i;
+		
+            DBG(&g_I2cClient->dev, "[x,y]=[%d,%d]\n", nX, nY);
+            DBG(&g_I2cClient->dev, "point[%d] : (%d,%d) = %d\n", pInfo->tPoint[pInfo->nCount].nId, pInfo->tPoint[pInfo->nCount].nX, pInfo->tPoint[pInfo->nCount].nY, pInfo->tPoint[pInfo->nCount].nP);
+		
+            pInfo->nCount ++;
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+            _gCurrentTouch[i] = 1;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+        }
+
+        // Notify android application to retrieve debug mode packet from device driver by sysfs.   
+        if (g_TouchKObj != NULL)
+        {
+            char *pEnvp[2];
+            s32 nRetVal = 0;  
+
+            pEnvp[0] = "STATUS=GET_DEBUG_MODE_PACKET";  
+            pEnvp[1] = NULL;  
+            
+            nRetVal = kobject_uevent_env(g_TouchKObj, KOBJ_CHANGE, pEnvp); 
+            DBG(&g_I2cClient->dev, "kobject_uevent_env() STATUS=GET_DEBUG_MODE_PACKET, nRetVal = %d\n", nRetVal);
+        }
+    }
+#ifdef CONFIG_ENABLE_HOTKNOT
+    else if (pPacket[0] == 0xA7)
+    {
+        if (pPacket[3] == HOTKNOT_PACKET_TYPE || pPacket[3] == HOTKNOT_RECEIVE_PACKET_TYPE)
+        {
+            ReportHotKnotCmd(pPacket, nLength); 								   
+            return -1;    //return 0 will run key procedure  
+        }
+    }
+#endif //CONFIG_ENABLE_HOTKNOT
+
+
+#ifdef CONFIG_TP_HAVE_KEY
+DBG(&g_I2cClient->dev, "pPacket[0]000000 = %x\n", pPacket[0]);
+    if (pPacket[0] == 0x5A)
+    {
+        u8 nButton = pPacket[nLength-2]; //Since the key value is stored in 0th~3th bit of variable "button", we can only retrieve 0th~3th bit of it. 
+	DBG(&g_I2cClient->dev, "button111111111 = %x\n", nButton);
+//        if (nButton)
+        if (nButton != 0xFF)
+        {
+            DBG(&g_I2cClient->dev, "button = %x\n", nButton);
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+            DBG(&g_I2cClient->dev, "g_EnableTpProximity = %d, pPacket[nLength-2] = 0x%x\n", g_EnableTpProximity, pPacket[nLength-2]);
+
+            if (g_EnableTpProximity && ((pPacket[nLength-2] == 0x80) || (pPacket[nLength-2] == 0x40)))
+            {
+                if (pPacket[nLength-2] == 0x80) // close to
+                {
+                    g_FaceClosingTp = 1;
+
+                    input_report_abs(g_ProximityInputDevice, ABS_DISTANCE, 0);
+                    input_sync(g_ProximityInputDevice);
+                }
+                else if (pPacket[nLength-2] == 0x40) // far away
+                {
+                    g_FaceClosingTp = 0;
+
+                    input_report_abs(g_ProximityInputDevice, ABS_DISTANCE, 1);
+                    input_sync(g_ProximityInputDevice);
+                }
+
+                DBG(&g_I2cClient->dev, "g_FaceClosingTp = %d\n", g_FaceClosingTp);
+               
+                return -1;
+            }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+            if (g_EnableTpProximity && ((pPacket[nLength-2] == 0x80) || (pPacket[nLength-2] == 0x40)))
+            {
+                int nErr;
+                hwm_sensor_data tSensorData;
+
+                if (pPacket[nLength-2] == 0x80) // close to
+                {
+                    g_FaceClosingTp = 0;
+                }
+                else if (pPacket[nLength-2] == 0x40) // far away
+                {
+                    g_FaceClosingTp = 1;
+                }
+                
+                DBG(&g_I2cClient->dev, "g_FaceClosingTp = %d\n", g_FaceClosingTp);
+
+                // map and store data to hwm_sensor_data
+                tSensorData.values[0] = DrvPlatformLyrGetTpPsData();
+                tSensorData.value_divide = 1;
+                tSensorData.status = SENSOR_STATUS_ACCURACY_MEDIUM;
+                // let up layer to know
+                if ((nErr = hwmsen_get_interrupt_data(ID_PROXIMITY, &tSensorData)))
+                {
+                    DBG(&g_I2cClient->dev, "call hwmsen_get_interrupt_data() failed = %d\n", nErr);
+                }
+                
+                return -1;
+            }
+#endif               
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+            for (i = 0; i < MAX_KEY_NUM; i ++)
+            {
+                if ((nButton & (1<<i)) == (1<<i))
+                {
+                    if (pInfo->nKeyCode == 0)
+                    {
+                        pInfo->nKeyCode = i;
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+                        DBG(&g_I2cClient->dev, "key[%d]=%d ...\n", i, g_TpVirtualKey[i]);
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+                      DBG(&g_I2cClient->dev, "tpd_dts_data.use_tpd_button =%d ...\n",tpd_dts_data.use_tpd_button);
+                        if (tpd_dts_data.use_tpd_button)
+                        {
+                            DBG(&g_I2cClient->dev, "key[%d]=%d ...\n", i, tpd_dts_data.tpd_key_local[i]);
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+                            pInfo->nKeyCode = 0xFF;
+                            pInfo->nCount = 1;
+                            pInfo->tPoint[0].nX = tpd_dts_data.tpd_key_dim_local[i].key_x;
+                            pInfo->tPoint[0].nY = tpd_dts_data.tpd_key_dim_local[i].key_y;
+                            pInfo->tPoint[0].nP = 1;
+                            pInfo->tPoint[0].nId = 0;
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+                        }
+#else
+                        DBG(&g_I2cClient->dev, "key[%d]=%d ...\n", i, g_TpVirtualKey[i]);
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+                        pInfo->nKeyCode = 0xFF;
+                        pInfo->nCount = 1;
+                        pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[i][0];
+                        pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[i][1];
+                        pInfo->tPoint[0].nP = 1;
+                        pInfo->tPoint[0].nId = 0;
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#endif 
+                    }
+                    else
+                    {
+                        /// if pressing multi-key => no report
+                        DBG(&g_I2cClient->dev, "pInfo->nKeyCode =%d ...\n",pInfo->nKeyCode);
+                        pInfo->nKeyCode = 0xFF;
+                    }
+                }
+            }
+        }
+        else
+        {
+            pInfo->nKeyCode = 0xFF;
+        }
+    }
+    else if (pPacket[0] == 0xA5 || pPacket[0] == 0xAB || (pPacket[0] == 0xA7 && pPacket[3] == PACKET_TYPE_TOOTH_PATTERN))
+    {
+    		// TODO : waiting for firmware define the virtual key
+
+        if (pPacket[0] == 0xA5)
+        {
+        	  // Do nothing	because of 0xA5 not define virtual key in the packet
+        }
+        else if (pPacket[0] == 0xAB || (pPacket[0] == 0xA7 && pPacket[3] == PACKET_TYPE_TOOTH_PATTERN))
+        {
+            u8 nButton = 0xFF;
+
+            if (pPacket[0] == 0xAB)
+            {
+                nButton = pPacket[3]; // The pressed virtual key is stored in 4th byte for debug mode packet 0xAB.
+            }
+            else if (pPacket[0] == 0xA7 && pPacket[3] == PACKET_TYPE_TOOTH_PATTERN)
+            {
+                nButton = pPacket[4]; // The pressed virtual key is stored in 5th byte for debug mode packet 0xA7.
+            }
+
+            if (nButton != 0xFF)
+            {
+                DBG(&g_I2cClient->dev, "button = %x\n", nButton);
+
+                for (i = 0; i < MAX_KEY_NUM; i ++)
+                {
+                    if ((nButton & (1<<i)) == (1<<i))
+                    {
+                        if (pInfo->nKeyCode == 0)
+                        {
+                            pInfo->nKeyCode = i;
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+                            DBG(&g_I2cClient->dev, "key[%d]=%d ...\n", i, g_TpVirtualKey[i]);
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+                            if (tpd_dts_data.use_tpd_button)
+                            {
+                                DBG(&g_I2cClient->dev, "key[%d]=%d ...\n", i, tpd_dts_data.tpd_key_local[i]);
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+                                pInfo->nKeyCode = 0xFF;
+                                pInfo->nCount = 1;
+                                pInfo->tPoint[0].nX = tpd_dts_data.tpd_key_dim_local[i].key_x;
+                                pInfo->tPoint[0].nY = tpd_dts_data.tpd_key_dim_local[i].key_y;
+                                pInfo->tPoint[0].nP = 1;
+                                pInfo->tPoint[0].nId = 0;
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+                            }
+#else
+                            DBG(&g_I2cClient->dev, "key[%d]=%d ...\n", i, g_TpVirtualKey[i]);
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+                            pInfo->nKeyCode = 0xFF;
+                            pInfo->nCount = 1;
+                            pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[i][0];
+                            pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[i][1];
+                            pInfo->tPoint[0].nP = 1;
+                            pInfo->tPoint[0].nId = 0;
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#endif 
+                        }
+                        else
+                        {
+                            /// if pressing multi-key => no report
+                            pInfo->nKeyCode = 0xFF;
+                        }
+                    }
+                }
+            }
+            else
+            {
+                pInfo->nKeyCode = 0xFF;
+            }
+        }
+    }
+#endif //CONFIG_TP_HAVE_KEY
+
+    return 0;
+}
+
+static void _DrvFwCtrlStoreFirmwareData(u8 *pBuf, u32 nSize)
+{
+    u32 nCount = nSize / 1024;
+    u32 nRemainder = nSize % 1024;
+    u32 i;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (nCount > 0) // nSize >= 1024
+   	{
+        for (i = 0; i < nCount; i ++)
+        {
+            memcpy(g_FwData[g_FwDataCount], pBuf+(i*1024), 1024);
+
+            g_FwDataCount ++;
+        }
+
+        if (nRemainder > 0) // Handle special firmware size like MSG22XX(48.5KB)
+        {
+            DBG(&g_I2cClient->dev, "nRemainder = %d\n", nRemainder);
+
+            memcpy(g_FwData[g_FwDataCount], pBuf+(i*1024), nRemainder);
+
+            g_FwDataCount ++;
+        }
+    }
+    else // nSize < 1024
+    {
+        if (nSize > 0)
+        {
+            memcpy(g_FwData[g_FwDataCount], pBuf, nSize);
+
+            g_FwDataCount ++;
+        }
+    }
+
+    DBG(&g_I2cClient->dev, "*** g_FwDataCount = %d ***\n", g_FwDataCount);
+
+    if (pBuf != NULL)
+    {
+        DBG(&g_I2cClient->dev, "*** buf[0] = %c ***\n", pBuf[0]);
+    }
+}
+
+static u16 _DrvFwCtrlMsg21xxaGetSwId(EmemType_e eEmemType) 
+{
+    u16 nRetVal = 0; 
+    u16 nRegData = 0;
+    u8 szDbBusTxData[5] = {0};
+    u8 szDbBusRxData[4] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    // cmd
+    RegSet16BitValue(0x3CE4, 0xA4AB); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start MCU
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    mdelay(100);
+
+    // Polling 0x3CE4 is 0x5B58
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+    } while (nRegData != 0x5B58);
+
+    szDbBusTxData[0] = 0x72;
+    if (eEmemType == EMEM_MAIN) // Read SW ID from main block
+    {
+        szDbBusTxData[1] = 0x7F;
+        szDbBusTxData[2] = 0x55;
+    }
+    else if (eEmemType == EMEM_INFO) // Read SW ID from info block
+    {
+        szDbBusTxData[1] = 0x83;
+        szDbBusTxData[2] = 0x00;
+    }
+    szDbBusTxData[3] = 0x00;
+    szDbBusTxData[4] = 0x04;
+
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+    IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+    DBG(&g_I2cClient->dev, "szDbBusRxData[0,1,2,3] = 0x%x,0x%x,0x%x,0x%x\n", szDbBusRxData[0], szDbBusRxData[1], szDbBusRxData[2], szDbBusRxData[3]);
+
+    if ((szDbBusRxData[0] >= 0x30 && szDbBusRxData[0] <= 0x39)
+        &&(szDbBusRxData[1] >= 0x30 && szDbBusRxData[1] <= 0x39)
+        &&(szDbBusRxData[2] >= 0x31 && szDbBusRxData[2] <= 0x39))  
+    {
+        nRetVal = (szDbBusRxData[0]-0x30)*100+(szDbBusRxData[1]-0x30)*10+(szDbBusRxData[2]-0x30);
+    }
+    
+    DBG(&g_I2cClient->dev, "SW ID = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;		
+}		
+
+static u16 _DrvFwCtrlMsg22xxGetSwId(EmemType_e eEmemType) 
+{
+    u16 nRetVal = 0; 
+    u16 nRegData1 = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+    // Stop MCU
+    RegSetLByteValue(0x0FE6, 0x01); 
+    
+    // Exit flash low power mode
+    RegSetLByteValue(0x1619, BIT1); 
+
+    // Change PIU clock to 48MHz
+    RegSetLByteValue(0x1E23, BIT6); 
+
+    // Change mcu clock deglitch mux source
+    RegSetLByteValue(0x1E54, BIT0); 
+#else
+    // Stop MCU
+    RegSetLByteValue(0x0FE6, 0x01); 
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55);
+
+    // RIU password
+    RegSet16BitValue(0x161A, 0xABBA); 
+
+    if (eEmemType == EMEM_MAIN) // Read SW ID from main block
+    {
+        RegSet16BitValue(0x1600, 0xBFF4); // Set start address for main block SW ID
+    }
+    else if (eEmemType == EMEM_INFO) // Read SW ID from info block
+    {
+        RegSet16BitValue(0x1600, 0xC1EC); // Set start address for info block SW ID
+    }
+
+    /*
+      Ex. SW ID in Main Block :
+          Major low byte at address 0xBFF4
+          Major high byte at address 0xBFF5
+          
+          SW ID in Info Block :
+          Major low byte at address 0xC1EC
+          Major high byte at address 0xC1ED
+    */
+    
+    // Enable burst mode
+//    RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+    RegSetLByteValue(0x160E, 0x01); 
+
+    nRegData1 = RegGet16BitValue(0x1604);
+//    nRegData2 = RegGet16BitValue(0x1606);
+
+    nRetVal = ((nRegData1 >> 8) & 0xFF) << 8;
+    nRetVal |= (nRegData1 & 0xFF);
+    
+    // Clear burst mode
+//    RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+    RegSet16BitValue(0x1600, 0x0000); 
+
+    // Clear RIU password
+    RegSet16BitValue(0x161A, 0x0000); 
+    
+    DBG(&g_I2cClient->dev, "SW ID = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;		
+}
+
+static u16 _DrvFwCtrlMsg26xxmGetSwId(EmemType_e eEmemType)
+{
+    u16 nRetVal = 0; 
+    u16 nRegData = 0;
+    u8 szDbBusTxData[5] = {0};
+    u8 szDbBusRxData[4] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    // cmd
+    RegSet16BitValue(0x3CE4, 0xA4AB); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start mcu
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    mdelay(100);
+
+    // Polling 0x3CE4 is 0x5B58
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+    } while (nRegData != 0x5B58);
+
+    szDbBusTxData[0] = 0x72;
+    if (eEmemType == EMEM_MAIN) // Read SW ID from main block
+    {
+        szDbBusTxData[1] = 0x00;
+        szDbBusTxData[2] = 0x2A;
+    }
+    else if (eEmemType == EMEM_INFO) // Read SW ID from info block
+    {
+        szDbBusTxData[1] = 0x80;
+        szDbBusTxData[2] = 0x04;
+    }
+    szDbBusTxData[3] = 0x00;
+    szDbBusTxData[4] = 0x04;
+
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+    IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+    /*
+      Ex. SW ID in Main Block :
+          Major low byte at address 0x002A
+          Major high byte at address 0x002B
+          
+          SW ID in Info Block :
+          Major low byte at address 0x8004
+          Major high byte at address 0x8005
+    */
+
+    nRetVal = szDbBusRxData[1];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[0];
+    
+    DBG(&g_I2cClient->dev, "SW ID = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;		
+}
+
+static s32 _DrvFwCtrlMsg26xxmUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+    u32 i, j;
+    u32 nCrcMain, nCrcMainTp;
+    u32 nCrcInfo, nCrcInfoTp;
+    u16 nRegData = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    nCrcMain = 0xffffffff;
+    nCrcInfo = 0xffffffff;
+
+    g_IsUpdateFirmware = 0x01; // Set flag to 0x01 for indicating update firmware is processing
+
+    /////////////////////////
+    // Erase
+    /////////////////////////
+
+    DBG(&g_I2cClient->dev, "erase 0\n");
+
+    DrvPlatformLyrTouchDeviceResetHw(); 
+    
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    DBG(&g_I2cClient->dev, "erase 1\n");
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    // Set PROGRAM password
+    RegSet16BitValue(0x161A, 0xABBA); //bank:emem, addr:h000D
+
+    // Clear pce
+    RegSetLByteValue(0x1618, 0x80); //bank:emem, addr:h000C
+
+    DBG(&g_I2cClient->dev, "erase 2\n");
+    // Clear setting
+    RegSetLByteValue(0x1618, 0x40); //bank:emem, addr:h000C
+    
+    mdelay(10);
+    
+    // Clear pce
+    RegSetLByteValue(0x1618, 0x80); //bank:emem, addr:h000C
+
+    DBG(&g_I2cClient->dev, "erase 3\n");
+    // Trigger erase
+    if (eEmemType == EMEM_ALL)
+    {
+        RegSetLByteValue(0x160E, 0x08); //all chip //bank:emem, addr:h0007
+    }
+    else
+    {
+        RegSetLByteValue(0x160E, 0x04); //sector //bank:emem, addr:h0007
+    }
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+    
+    mdelay(1000);
+    DBG(&g_I2cClient->dev, "erase OK\n");
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+
+    DBG(&g_I2cClient->dev, "program 0\n");
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    DBG(&g_I2cClient->dev, "program 1\n");
+
+    // Check_Loader_Ready: Polling 0x3CE4 is 0x1C70
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+    } while (nRegData != 0x1C70);
+
+    DBG(&g_I2cClient->dev, "program 2\n");
+
+    RegSet16BitValue(0x3CE4, 0xE38F);  //all chip
+    mdelay(100);
+
+    // Check_Loader_Ready2Program: Polling 0x3CE4 is 0x2F43
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x2F43);
+
+    DBG(&g_I2cClient->dev, "program 3\n");
+
+    // prepare CRC & send data
+    DrvCommonCrcInitTable();
+
+    for (i = 0; i < MSG26XXM_FIRMWARE_WHOLE_SIZE; i ++) // Main : 32KB + Info : 8KB
+    {
+        if (i > 31)
+        {
+            for (j = 0; j < 1024; j ++)
+            {
+                nCrcInfo = DrvCommonCrcGetValue(szFwData[i][j], nCrcInfo);
+            }
+        }
+        else if (i < 31)
+        {
+            for (j = 0; j < 1024; j ++)
+            {
+                nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+            }
+        }
+        else ///if (i == 31)
+        {
+            szFwData[i][1014] = 0x5A;
+            szFwData[i][1015] = 0xA5;
+
+            for (j = 0; j < 1016; j ++)
+            {
+                nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+            }
+        }
+
+        for (j = 0; j < 8; j ++)
+        {
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &szFwData[i][j*128], 128);
+        }
+        mdelay(100);
+
+        // Check_Program_Done: Polling 0x3CE4 is 0xD0BC
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0xD0BC);
+
+        // Continue_Program
+        RegSet16BitValue(0x3CE4, 0x2F43);
+    }
+
+    DBG(&g_I2cClient->dev, "program 4\n");
+
+    // Notify_Write_Done
+    RegSet16BitValue(0x3CE4, 0x1380);
+    mdelay(100);
+
+    DBG(&g_I2cClient->dev, "program 5\n");
+
+    // Check_CRC_Done: Polling 0x3CE4 is 0x9432
+    do
+    {
+       nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x9432);
+
+    DBG(&g_I2cClient->dev, "program 6\n");
+    DBG(&g_I2cClient->dev, "program OK\n");
+
+    // check CRC
+    nCrcMain = nCrcMain ^ 0xffffffff;
+    nCrcInfo = nCrcInfo ^ 0xffffffff;
+
+    // read CRC from TP
+    nCrcMainTp = RegGet16BitValue(0x3C80);
+    nCrcMainTp = (nCrcMainTp << 16) | RegGet16BitValue(0x3C82);
+    nCrcInfoTp = RegGet16BitValue(0x3CA0);
+    nCrcInfoTp = (nCrcInfoTp << 16) | RegGet16BitValue(0x3CA2);
+
+    DBG(&g_I2cClient->dev, "nCrcMain=0x%x, nCrcInfo=0x%x, nCrcMainTp=0x%x, nCrcInfoTp=0x%x\n",
+               nCrcMain, nCrcInfo, nCrcMainTp, nCrcInfoTp);
+
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    mdelay(300);
+
+    g_IsUpdateFirmware = 0x00; // Set flag to 0x00 for indicating update firmware is finished
+
+    if ((nCrcMainTp != nCrcMain) || (nCrcInfoTp != nCrcInfo))
+    {
+        DBG(&g_I2cClient->dev, "Update FAILED\n");
+
+        return -1;
+    }
+
+    DBG(&g_I2cClient->dev, "Update SUCCESS\n");
+
+    return 0;
+}
+
+static void _DrvFwCtrlMsg28xxConvertFwDataTwoDimenToOneDimen(u8 szTwoDimenFwData[][1024], u8* pOneDimenFwData)
+{
+    u32 i, j;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    for (i = 0; i < MSG28XX_FIRMWARE_WHOLE_SIZE; i ++)
+    {
+        for (j = 0; j < 1024; j ++)
+        {
+            pOneDimenFwData[i*1024+j] = szTwoDimenFwData[i][j];
+        }
+    }
+}
+
+static u32 _DrvFwCtrlMsg28xxCalculateCrc(u8 *pFwData, u32 nOffset, u32 nSize)
+{
+    u32 i;
+    u32 nData = 0, nCrc = 0;
+    u32 nCrcRule = 0x0C470C06; // 0000 1100 0100 0111 0000 1100 0000 0110
+
+    for (i = 0; i < nSize; i += 4)
+    {
+   	    nData = (pFwData[nOffset+i]) | (pFwData[nOffset+i+1] << 8) | (pFwData[nOffset+i+2] << 16) | (pFwData[nOffset+i+3] << 24);
+   	    nCrc = (nCrc >> 1) ^ (nCrc << 1) ^ (nCrc & nCrcRule) ^ nData;
+    }
+    
+    return nCrc;
+}
+
+static void _DrvFwCtrlMsg28xxAccessEFlashInit(void)
+{
+    // Disable watchdog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    // Disable cpu read flash
+    RegSetLByteValue(0x1606, 0x20);
+    RegSetLByteValue(0x1608, 0x20);
+
+    // Clear PROGRAM erase password
+    RegSet16BitValue(0x1618, 0xA55A);
+}
+
+static void _DrvFwCtrlMsg28xxIspBurstWriteEFlashStart(u16 nStartAddr, u8 *pFirstData, u32 nBlockSize, u16 nPageNum, EmemType_e eEmemType)
+{
+    u16 nWriteAddr = nStartAddr/4;
+    u8  szDbBusTxData[3] = {0};
+    
+    DBG(&g_I2cClient->dev, "*** %s() nStartAddr = 0x%x, nBlockSize = %d, nPageNum = %d, eEmemType = %d ***\n", __func__, nStartAddr, nBlockSize, nPageNum, eEmemType);
+
+    // Disable cpu read flash
+    RegSetLByteValue(0x1608, 0x20);
+    RegSetLByteValue(0x1606, 0x20);
+    
+    // Set e-flash mode to page write mode
+    RegSet16BitValue(0x1606, 0x0080);
+
+    // Set data align
+    RegSetLByteValue(0x1640, 0x01);
+    
+    if (eEmemType == EMEM_INFO) 
+    {
+        RegSetLByteValue(0x1607, 0x08);
+    }
+    
+    // Set double buffer
+    RegSetLByteValue(0x1604, 0x01);
+        
+    // Set page write number
+    RegSet16BitValue(0x161A, nPageNum);
+
+    // Set e-flash mode trigger(Trigger write mode)
+    RegSetLByteValue(0x1606, 0x81);
+
+    // Set init data
+    RegSetLByteValue(0x1602, pFirstData[0]);
+    RegSetLByteValue(0x1602, pFirstData[1]);
+    RegSetLByteValue(0x1602, pFirstData[2]);
+    RegSetLByteValue(0x1602, pFirstData[3]);
+
+    // Set initial address(for latch SA, CA)
+    RegSet16BitValue(0x1600, nWriteAddr);
+
+    // Set initial address(for latch PA)
+    RegSet16BitValue(0x1600, nWriteAddr);
+    
+    // Enable burst mode
+    RegSetLByteValue(0x1608, 0x21);
+    
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x16;
+    szDbBusTxData[2] = 0x02;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);
+
+    szDbBusTxData[0] = 0x20;
+//    szDbBusTxData[1] = 0x00;
+//    szDbBusTxData[2] = 0x00;    
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);
+}	
+
+static void _DrvFwCtrlMsg28xxIspBurstWriteEFlashDoWrite(u8 *pBufferData, u32 nLength)
+{
+    u32 i;
+    u8  szDbBusTxData[3+MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() nLength = %d ***\n", __func__, nLength);
+
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x16;
+    szDbBusTxData[2] = 0x02;
+        
+    for (i = 0; i < nLength; i ++)
+    {
+        szDbBusTxData[3+i] = pBufferData[i];
+    }
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+nLength);
+}	
+
+static void _DrvFwCtrlMsg28xxIspBurstWriteEFlashEnd(void)
+{
+    u8 szDbBusTxData[1] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    szDbBusTxData[0] = 0x21;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+
+    szDbBusTxData[0] = 0x7E;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+
+    // Clear burst mode
+    RegSetLByteValue(0x1608, 0x20);
+}
+
+static void _DrvFwCtrlMsg28xxWriteEFlashStart(u16 nStartAddr, u8 *pFirstData, EmemType_e eEmemType)
+{
+    u16 nWriteAddr = nStartAddr/4;
+    
+    DBG(&g_I2cClient->dev, "*** %s() nStartAddr = 0x%x, eEmemType = %d ***\n", __func__, nStartAddr, eEmemType);
+
+    // Disable cpu read flash
+    RegSetLByteValue(0x1608, 0x20);
+    RegSetLByteValue(0x1606, 0x20);
+    
+    // Set e-flash mode to write mode
+    RegSet16BitValue(0x1606, 0x0040);
+
+    // Set data align
+    RegSetLByteValue(0x1640, 0x01);
+    
+    if (eEmemType == EMEM_INFO) 
+    {
+        RegSetLByteValue(0x1607, 0x08);
+    }
+
+    // Set double buffer
+    RegSetLByteValue(0x1604, 0x01);
+        
+    // Set e-flash mode trigger(Trigger write mode)
+    RegSetLByteValue(0x1606, 0x81);
+
+    // Set init data
+    RegSetLByteValue(0x1602, pFirstData[0]);
+    RegSetLByteValue(0x1602, pFirstData[1]);
+    RegSetLByteValue(0x1602, pFirstData[2]);
+    RegSetLByteValue(0x1602, pFirstData[3]);
+
+    // Set initial address(for latch SA, CA)
+    RegSet16BitValue(0x1600, nWriteAddr);
+
+    // Set initial address(for latch PA)
+    RegSet16BitValue(0x1600, nWriteAddr);
+}	
+
+static void _DrvFwCtrlMsg28xxWriteEFlashDoWrite(u16 nStartAddr, u8 *pBufferData)
+{
+    u16 nWriteAddr = nStartAddr/4;
+
+    DBG(&g_I2cClient->dev, "*** %s() nWriteAddr = %d ***\n", __func__, nWriteAddr);
+
+    // Write data
+    RegSetLByteValue(0x1602, pBufferData[0]);
+    RegSetLByteValue(0x1602, pBufferData[1]);
+    RegSetLByteValue(0x1602, pBufferData[2]);
+    RegSetLByteValue(0x1602, pBufferData[3]);
+
+    // Set address
+    RegSet16BitValue(0x1600, nWriteAddr);
+}	
+
+static void _DrvFwCtrlMsg28xxWriteEFlashEnd(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    // Do nothing
+}
+
+static void _DrvFwCtrlMsg28xxReadEFlashStart(u16 nStartAddr, EmemType_e eEmemType)
+{
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    // Disable cpu read flash
+    RegSetLByteValue(0x1608, 0x20);
+    RegSetLByteValue(0x1606, 0x20);
+
+    RegSetLByteValue(0x1606, 0x02);
+
+    RegSet16BitValue(0x1600, nStartAddr);
+    
+    if (eEmemType == EMEM_MAIN)
+    {
+        // Set main block
+        RegSetLByteValue(0x1607, 0x00);
+
+        // Set main double buffer
+        RegSetLByteValue(0x1604, 0x01);
+
+        // Set e-flash mode to read mode for main
+        RegSet16BitValue(0x1606, 0x0001);
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        // Set info block 
+        RegSetLByteValue(0x1607, 0x08);
+        
+        // Set info double buffer
+        RegSetLByteValue(0x1604, 0x01);
+        
+        // Set e-flash mode to read mode for info
+        RegSet16BitValue(0x1606, 0x0801);
+    }
+}
+
+static void _DrvFwCtrlMsg28xxReadEFlashDoRead(u16 nReadAddr, u8 *pReadData)
+{
+    u16 nRegData1 = 0, nRegData2 = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() nReadAddr = 0x%x ***\n", __func__, nReadAddr);
+
+    // Set read address
+    RegSet16BitValue(0x1600, nReadAddr);
+
+    // Read 16+16 bits
+    nRegData1 = RegGet16BitValue(0x160A);
+    nRegData2 = RegGet16BitValue(0x160C);
+
+    pReadData[0] = nRegData1 & 0xFF;
+    pReadData[1] = (nRegData1 >> 8) & 0xFF;
+    pReadData[2] = nRegData2 & 0xFF;
+    pReadData[3] = (nRegData2 >> 8) & 0xFF;
+}	
+
+static void _DrvFwCtrlMsg28xxReadEFlashEnd(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    // Set read done
+    RegSetLByteValue(0x1606, 0x02);
+
+    // Unset info flag
+    RegSetLByteValue(0x1607, 0x00);
+
+    // Clear address
+    RegSet16BitValue(0x1600, 0x0000);
+}
+
+/*
+static void _DrvFwCtrlMsg28xxGetTpVendorCode(u8 *pTpVendorCode)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        u16 nReadAddr = 0;
+        u8  szTmpData[4] = {0};
+
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+
+        // Stop MCU
+        RegSetLByteValue(0x0FE6, 0x01); 
+
+        // Stop watchdog
+        RegSet16BitValue(0x3C60, 0xAA55);
+
+        _DrvFwCtrlMsg28xxReadEFlashStart(0x81FA, EMEM_INFO);
+        nReadAddr = 0x81FA;
+
+        _DrvFwCtrlMsg28xxReadEFlashDoRead(nReadAddr, &szTmpData[0]);
+
+        DBG(&g_I2cClient->dev, "szTmpData[0] = 0x%x\n", szTmpData[0]); // add for debug
+        DBG(&g_I2cClient->dev, "szTmpData[1] = 0x%x\n", szTmpData[1]); // add for debug
+        DBG(&g_I2cClient->dev, "szTmpData[2] = 0x%x\n", szTmpData[2]); // add for debug
+        DBG(&g_I2cClient->dev, "szTmpData[3] = 0x%x\n", szTmpData[3]); // add for debug
+   
+        _DrvFwCtrlMsg28xxReadEFlashEnd();
+
+        pTpVendorCode[0] = szTmpData[1];
+        pTpVendorCode[1] = szTmpData[2];
+        pTpVendorCode[2] = szTmpData[3];
+
+        DBG(&g_I2cClient->dev, "pTpVendorCode[0] = 0x%x , %c \n", pTpVendorCode[0], pTpVendorCode[0]); 
+        DBG(&g_I2cClient->dev, "pTpVendorCode[1] = 0x%x , %c \n", pTpVendorCode[1], pTpVendorCode[1]); 
+        DBG(&g_I2cClient->dev, "pTpVendorCode[2] = 0x%x , %c \n", pTpVendorCode[2], pTpVendorCode[2]); 
+
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+    }
+}
+*/
+
+static void _DrvFwCtrlMsg28xxGetSfrAddr3Value(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // Disable cpu read flash
+    RegSetLByteValue(0x1608, 0x20);
+    RegSetLByteValue(0x1606, 0x20);
+
+    // Set e-flash mode to read mode
+    RegSetLByteValue(0x1606, 0x01);
+    RegSetLByteValue(0x1610, 0x01);
+    RegSetLByteValue(0x1607, 0x20);
+
+    // Set read address
+    RegSetLByteValue(0x1600, 0x03);
+    RegSetLByteValue(0x1601, 0x00);
+
+    _gSFR_ADDR3_BYTE0_1_VALUE = RegGet16BitValue(0x160A);
+    _gSFR_ADDR3_BYTE2_3_VALUE = RegGet16BitValue(0x160C);
+
+    DBG(&g_I2cClient->dev, "_gSFR_ADDR3_BYTE0_1_VALUE = 0x%4X, _gSFR_ADDR3_BYTE2_3_VALUE = 0x%4X\n", _gSFR_ADDR3_BYTE0_1_VALUE, _gSFR_ADDR3_BYTE2_3_VALUE);
+}
+
+static void _DrvFwCtrlMsg28xxUnsetProtectBit(void)
+{
+    u8 nB0, nB1, nB2, nB3;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    _DrvFwCtrlMsg28xxGetSfrAddr3Value();
+    
+    nB0 = _gSFR_ADDR3_BYTE0_1_VALUE & 0xFF;
+    nB1 = (_gSFR_ADDR3_BYTE0_1_VALUE & 0xFF00) >> 8;
+
+    nB2 = _gSFR_ADDR3_BYTE2_3_VALUE & 0xFF;
+    nB3 = (_gSFR_ADDR3_BYTE2_3_VALUE & 0xFF00) >> 8;
+
+    DBG(&g_I2cClient->dev, "nB0 = 0x%2X, nB1 = 0x%2X, nB2 = 0x%2X, nB3 = 0x%2X\n", nB0, nB1, nB2, nB3);
+
+    nB2 = nB2 & 0xBF; // 10111111
+    nB3 = nB3 & 0xFC; // 11111100
+
+    DBG(&g_I2cClient->dev, "nB0 = 0x%2X, nB1 = 0x%2X, nB2 = 0x%2X, nB3 = 0x%2X\n", nB0, nB1, nB2, nB3);
+
+    // Disable cpu read flash
+    RegSetLByteValue(0x1608, 0x20);
+    RegSetLByteValue(0x1606, 0x20);
+    RegSetLByteValue(0x1610, 0x80);
+    RegSetLByteValue(0x1607, 0x10);
+
+    // Trigger SFR write
+    RegSetLByteValue(0x1606, 0x01);
+
+    // Set write data
+    RegSetLByteValue(0x1602, nB0);
+    RegSetLByteValue(0x1602, nB1);
+    RegSetLByteValue(0x1602, nB2);
+    RegSetLByteValue(0x1602, nB3);
+
+    // Set write address
+    RegSetLByteValue(0x1600, 0x03);
+    RegSetLByteValue(0x1601, 0x00);
+
+    // Set TM mode = 0
+    RegSetLByteValue(0x1607, 0x00);
+
+#ifdef CONFIG_ENABLE_HIGH_SPEED_ISP_MODE
+    RegSetLByteValue(0x1606, 0x01);
+    RegSetLByteValue(0x1606, 0x20);
+#endif //CONFIG_ENABLE_HIGH_SPEED_ISP_MODE
+}
+
+static void _DrvFwCtrlMsg28xxSetProtectBit(void)
+{
+    u8 nB0, nB1, nB2, nB3;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nB0 = _gSFR_ADDR3_BYTE0_1_VALUE & 0xFF;
+    nB1 = (_gSFR_ADDR3_BYTE0_1_VALUE & 0xFF00) >> 8;
+
+    nB2 = _gSFR_ADDR3_BYTE2_3_VALUE & 0xFF;
+    nB3 = (_gSFR_ADDR3_BYTE2_3_VALUE & 0xFF00) >> 8;
+
+    DBG(&g_I2cClient->dev, "nB0 = 0x%2X, nB1 = 0x%2X, nB2 = 0x%2X, nB3 = 0x%2X\n", nB0, nB1, nB2, nB3);
+
+    // Disable cpu read flash
+    RegSetLByteValue(0x1608, 0x20);
+    RegSetLByteValue(0x1606, 0x20);
+    RegSetLByteValue(0x1610, 0x80);
+    RegSetLByteValue(0x1607, 0x10);
+
+    // Trigger SFR write
+    RegSetLByteValue(0x1606, 0x01);
+
+    // Set write data
+    RegSetLByteValue(0x1602, nB0);
+    RegSetLByteValue(0x1602, nB1);
+    RegSetLByteValue(0x1602, nB2);
+    RegSetLByteValue(0x1602, nB3);
+
+    // Set write address
+    RegSetLByteValue(0x1600, 0x03);
+    RegSetLByteValue(0x1601, 0x00);
+    RegSetLByteValue(0x1606, 0x02);
+}
+
+static void _DrvFwCtrlMsg28xxEraseEmem(EmemType_e eEmemType)
+{
+    u32 nInfoAddr = 0x20;
+    u32 nTimeOut = 0;
+    u8 nRegData = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    DBG(&g_I2cClient->dev, "Erase start\n");
+
+    _DrvFwCtrlMsg28xxAccessEFlashInit();
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01);
+
+    // Set PROGRAM erase password
+    RegSet16BitValue(0x1618, 0x5AA5);
+    
+    _DrvFwCtrlMsg28xxUnsetProtectBit();
+
+    if (eEmemType == EMEM_MAIN) // 128KB
+    {
+        DBG(&g_I2cClient->dev, "Erase main block\n");
+
+        // Set main block
+        RegSetLByteValue(0x1607, 0x00);
+
+        // Set e-flash mode to erase mode
+        RegSetLByteValue(0x1606, 0xC0);
+
+        // Set page erase main
+        RegSetLByteValue(0x1607, 0x03);
+
+        // e-flash mode trigger
+        RegSetLByteValue(0x1606, 0xC1);
+
+        nTimeOut = 0;
+        while (1) // Wait erase done
+        {
+            nRegData = RegGetLByteValue(0x160E);
+            nRegData = (nRegData & BIT3);
+            
+            DBG(&g_I2cClient->dev, "Wait erase done flag nRegData = 0x%x\n", nRegData);
+
+            if (nRegData == BIT3)
+            {
+                break;
+            }
+
+            mdelay(10);
+            
+            if ((nTimeOut ++) > 10)
+            {
+                DBG(&g_I2cClient->dev, "Erase main block failed. Timeout.\n");
+
+                goto EraseEnd;
+            }
+        }
+    }
+    else if (eEmemType == EMEM_INFO) // 2KB
+    {
+        DBG(&g_I2cClient->dev, "Erase info block\n");
+        
+        // Set info block
+        RegSetLByteValue(0x1607, 0x08);
+
+        // Set info double buffer
+        RegSetLByteValue(0x1604, 0x01);
+
+        // Set e-flash mode to erase mode
+        RegSetLByteValue(0x1606, 0xC0);
+
+        // Set page erase info
+        RegSetLByteValue(0x1607, 0x09);
+        
+        for (nInfoAddr = 0x20; nInfoAddr <= MSG28XX_EMEM_INFO_MAX_ADDR; nInfoAddr += 0x20)
+        {
+            DBG(&g_I2cClient->dev, "nInfoAddr = 0x%x\n", nInfoAddr); // add for debug
+
+            // Set address
+            RegSet16BitValue(0x1600, nInfoAddr);
+
+            // e-flash mode trigger
+            RegSetLByteValue(0x1606, 0xC1);
+
+            nTimeOut = 0;
+            while (1) // Wait erase done
+            {
+                nRegData = RegGetLByteValue(0x160E);
+                nRegData = (nRegData & BIT3);
+
+                DBG(&g_I2cClient->dev, "Wait erase done flag nRegData = 0x%x\n", nRegData);
+            
+                if (nRegData == BIT3)
+                {
+                    break;
+                }
+
+                mdelay(10);
+            
+                if ((nTimeOut ++) > 10)
+                {
+                    DBG(&g_I2cClient->dev, "Erase info block failed. Timeout.\n");
+
+                    // Set main block
+                    RegSetLByteValue(0x1607, 0x00);
+
+                    goto EraseEnd;
+                }
+            }        	
+        }
+
+        // Set main block
+        RegSetLByteValue(0x1607, 0x00);
+    }
+    
+    EraseEnd:
+    
+    _DrvFwCtrlMsg28xxSetProtectBit();
+
+    RegSetLByteValue(0x1606, 0x00);
+    RegSetLByteValue(0x1607, 0x00);
+		
+    // Clear PROGRAM erase password
+    RegSet16BitValue(0x1618, 0xA55A);
+
+    DBG(&g_I2cClient->dev, "Erase end\n");
+    
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+}
+
+static void _DrvFwCtrlMsg28xxProgramEmem(EmemType_e eEmemType)
+{
+    u32 i, j;
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_8_BYTE_EACH_TIME) || defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_32_BYTE_EACH_TIME)
+    u32 k;
+#endif
+    u32 nPageNum = 0, nLength = 0, nIndex = 0, nWordNum = 0;
+    u32 nRetryTime = 0;
+    u8  nRegData = 0;
+    u8  szFirstData[MSG28XX_EMEM_SIZE_BYTES_ONE_WORD] = {0};
+    u8  szBufferData[MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE] = {0};
+#ifdef CONFIG_ENABLE_HIGH_SPEED_ISP_MODE
+    u8  szWriteData[3+MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE*2] = {0};
+#endif //CONFIG_ENABLE_HIGH_SPEED_ISP_MODE
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    DBG(&g_I2cClient->dev, "Program start\n");
+
+    _DrvFwCtrlMsg28xxAccessEFlashInit();
+    
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); 
+    
+    // Set PROGRAM erase password
+    RegSet16BitValue(0x1618, 0x5AA5);
+
+    _DrvFwCtrlMsg28xxUnsetProtectBit();
+    
+    if (eEmemType == EMEM_MAIN) // Program main block
+    {
+        DBG(&g_I2cClient->dev, "Program main block\n");
+
+#ifdef CONFIG_ENABLE_HIGH_SPEED_ISP_MODE
+        nPageNum = (MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024) / MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE; // 128*1024/128=1024
+
+        // Set ISP mode
+        RegSet16BitValueOn(0x1EBE, BIT15);
+
+        RegSetLByteValue(0x1604, 0x01);
+        
+        RegSet16BitValue(0x161A, nPageNum);
+        RegSet16BitValue(0x1600, 0x0000); // Set initial address
+        RegSet16BitValueOn(0x3C00, BIT0); // Disable INT GPIO mode
+        RegSet16BitValueOn(0x1EA0, BIT1); // Set ISP INT enable
+        RegSet16BitValue(0x1E34, 0x0000); // Set DQMem start address
+
+        _DrvFwCtrlReadReadDQMemStart();
+        
+        szWriteData[0] = 0x10;
+        szWriteData[1] = 0x00;
+        szWriteData[2] = 0x00;
+        
+        nLength = MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE*2; //128*2=256
+        
+        for (j = 0; j < nLength; j ++)
+        {
+            szWriteData[3+j] = g_FwData[0][j];
+        }
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szWriteData[0], 3+nLength); // Write the first two pages(page 0 & page 1)
+        
+        _DrvFwCtrlReadReadDQMemEnd();
+
+        RegSet16BitValueOn(0x1EBE, BIT15); // Set ISP mode
+        RegSet16BitValueOn(0x1608, BIT0); // Set burst mode
+        RegSet16BitValueOn(0x161A, BIT13); // Set ISP trig
+
+        udelay(2000); // delay about 2ms
+
+        _DrvFwCtrlReadReadDQMemStart();
+
+        nLength = MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE; //128
+
+        for (i = 2; i < nPageNum; i ++) 
+        {
+            if (i == 2)
+            {
+                szWriteData[0] = 0x10;
+                szWriteData[1] = 0x00;
+                szWriteData[2] = 0x00;
+
+                for (j = 0; j < nLength; j ++)
+                {
+                    szWriteData[3+j] = g_FwData[i/8][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE*(i-(8*(i/8)))+j];
+                }
+
+                IicWriteData(SLAVE_I2C_ID_DBBUS, &szWriteData[0], 3+nLength); 
+            }
+            else if (i == (nPageNum - 1))
+            {
+                szWriteData[0] = 0x10;
+                szWriteData[1] = 0x00;
+                szWriteData[2] = 0x80;
+
+                for (j = 0; j < nLength; j ++)
+                {
+                    szWriteData[3+j] = g_FwData[i/8][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE*(i-(8*(i/8)))+j];
+                }
+
+                szWriteData[3+128] = 0xFF;
+                szWriteData[3+129] = 0xFF;
+                szWriteData[3+130] = 0xFF;
+                szWriteData[3+131] = 0xFF;
+
+                IicWriteData(SLAVE_I2C_ID_DBBUS, &szWriteData[0], 3+nLength+4); 
+            }           
+            else
+            {
+//                szWriteData[0] = 0x10;
+//                szWriteData[1] = 0x00;
+                if (szWriteData[2] == 0x00)
+                {
+                    szWriteData[2] = 0x80;
+                }
+                else // szWriteData[2] == 0x80
+                {
+                		szWriteData[2] = 0x00;
+                }
+
+                for (j = 0; j < nLength; j ++)
+                {
+                    szWriteData[3+j] = g_FwData[i/8][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE*(i-(8*(i/8)))+j];
+                }
+
+                IicWriteData(SLAVE_I2C_ID_DBBUS, &szWriteData[0], 3+nLength); 
+            }
+        }
+
+        _DrvFwCtrlReadReadDQMemEnd();
+
+#else
+
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_8_BYTE_EACH_TIME)
+        nPageNum = (MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024) / 8; // 128*1024/8=16384 
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_32_BYTE_EACH_TIME)
+        nPageNum = (MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024) / 32; // 128*1024/32=4096 
+#else // UPDATE FIRMWARE WITH 128 BYTE EACH TIME
+        nPageNum = (MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024) / MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE; // 128*1024/128=1024
+#endif 
+     
+        nIndex = 0;
+        
+        for (i = 0; i < nPageNum; i ++) 
+        {
+            if (i == 0)
+            {
+                // Read first data 4 bytes
+                nLength = MSG28XX_EMEM_SIZE_BYTES_ONE_WORD;
+
+                szFirstData[0] = g_FwData[0][0];
+                szFirstData[1] = g_FwData[0][1];
+                szFirstData[2] = g_FwData[0][2];
+                szFirstData[3] = g_FwData[0][3];
+            
+                _DrvFwCtrlMsg28xxIspBurstWriteEFlashStart(nIndex, &szFirstData[0], MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE*1024, nPageNum, EMEM_MAIN);
+
+                nIndex += nLength;
+            
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_8_BYTE_EACH_TIME)
+                nLength = 8 - MSG28XX_EMEM_SIZE_BYTES_ONE_WORD; // 4 = 8 - 4 
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_32_BYTE_EACH_TIME)
+                nLength = 32 - MSG28XX_EMEM_SIZE_BYTES_ONE_WORD; // 28 = 32 - 4 
+#else // UPDATE FIRMWARE WITH 128 BYTE EACH TIME
+                nLength = MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE - MSG28XX_EMEM_SIZE_BYTES_ONE_WORD; // 124 = 128 - 4
+#endif
+
+                for (j = 0; j < nLength; j ++)
+                {
+                    szBufferData[j] = g_FwData[0][4+j];
+                }
+            }
+            else
+            {
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_8_BYTE_EACH_TIME)
+                nLength = 8; 
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_32_BYTE_EACH_TIME)
+                nLength = 32; 
+#else // UPDATE FIRMWARE WITH 128 BYTE EACH TIME
+                nLength = MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE; // 128
+#endif 
+
+                for (j = 0; j < nLength; j ++)
+                {
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_8_BYTE_EACH_TIME)
+                    szBufferData[j] = g_FwData[i/128][8*(i-(128*(i/128)))+j]; 
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_32_BYTE_EACH_TIME)
+                    szBufferData[j] = g_FwData[i/32][32*(i-(32*(i/32)))+j]; 
+#else // UPDATE FIRMWARE WITH 128 BYTE EACH TIME
+                    szBufferData[j] = g_FwData[i/8][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE*(i-(8*(i/8)))+j];
+#endif
+                }
+            }
+
+            _DrvFwCtrlMsg28xxIspBurstWriteEFlashDoWrite(&szBufferData[0], nLength);
+            
+            udelay(2000); // delay about 2ms
+        
+            nIndex += nLength;
+        }
+
+        _DrvFwCtrlMsg28xxIspBurstWriteEFlashEnd();
+
+        // Set write done
+        RegSet16BitValueOn(0x1606, BIT2);
+
+        // Check RBB
+        nRegData = RegGetLByteValue(0x160E);
+        nRetryTime = 0;
+    
+        while ((nRegData & BIT3) != BIT3)
+        {
+            mdelay(10);
+
+            nRegData = RegGetLByteValue(0x160E);
+    
+            if (nRetryTime ++ > 100)
+            {
+                DBG(&g_I2cClient->dev, "main block can't wait write to done.\n");
+
+                goto ProgramEnd;
+            }
+        }
+#endif //CONFIG_ENABLE_HIGH_SPEED_ISP_MODE
+    }
+    else if (eEmemType == EMEM_INFO) // Program info block
+    {
+        DBG(&g_I2cClient->dev, "Program info block\n");
+
+        nPageNum = (MSG28XX_FIRMWARE_INFO_BLOCK_SIZE * 1024) / MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE; // 2*1024/128=16
+
+        nIndex = 0;
+        nIndex += MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE; //128
+
+        // Skip firt page(page 0) & Update page 1~14 by isp burst write mode
+        for (i = 1; i < (nPageNum - 1); i ++) // Skip the first 128 byte and the last 128 byte of info block
+        {
+            if (i == 1)
+            {
+                // Read first data 4 bytes
+                nLength = MSG28XX_EMEM_SIZE_BYTES_ONE_WORD;
+            
+                szFirstData[0] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE];
+                szFirstData[1] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE+1];
+                szFirstData[2] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE+2];
+                szFirstData[3] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE+3];
+            
+                _DrvFwCtrlMsg28xxIspBurstWriteEFlashStart(nIndex, &szFirstData[0], MSG28XX_FIRMWARE_INFO_BLOCK_SIZE*1024, nPageNum-1, EMEM_INFO);
+            
+                nIndex += nLength;
+            
+                nLength = MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE - MSG28XX_EMEM_SIZE_BYTES_ONE_WORD; // 124 = 128 - 4
+
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_8_BYTE_EACH_TIME)
+                for (j = 0; j < (nLength/8); j ++) // 124/8 = 15
+                {
+                    for (k = 0; k < 8; k ++)
+                    {
+                        szBufferData[k] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE+4+(8*j)+k];
+                    }
+                    
+                    _DrvFwCtrlMsg28xxIspBurstWriteEFlashDoWrite(&szBufferData[0], 8);
+
+                    udelay(2000); // delay about 2ms 
+                }
+
+                for (k = 0; k < (nLength%8); k ++) // 124%8 = 4
+                {
+                    szBufferData[k] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE+4+(8*j)+k];
+                }
+
+                _DrvFwCtrlMsg28xxIspBurstWriteEFlashDoWrite(&szBufferData[0], (nLength%8)); // 124%8 = 4
+
+                udelay(2000); // delay about 2ms 
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_32_BYTE_EACH_TIME)
+                for (j = 0; j < (nLength/32); j ++) // 124/8 = 3
+                {
+                    for (k = 0; k < 32; k ++)
+                    {
+                        szBufferData[k] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE+4+(32*j)+k];
+                    }
+                    
+                    _DrvFwCtrlMsg28xxIspBurstWriteEFlashDoWrite(&szBufferData[0], 32);
+
+                    udelay(2000); // delay about 2ms 
+                }
+
+                for (k = 0; k < (nLength%32); k ++) // 124%32 = 28
+                {
+                    szBufferData[k] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE+4+(32*j)+k];
+                }
+
+                _DrvFwCtrlMsg28xxIspBurstWriteEFlashDoWrite(&szBufferData[0], (nLength%32)); // 124%8 = 28
+
+                udelay(2000); // delay about 2ms 
+#else // UPDATE FIRMWARE WITH 128 BYTE EACH TIME
+                for (j = 0; j < nLength; j ++)
+                {
+                    szBufferData[j] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE+4+j];
+                }
+#endif
+            }
+            else
+            {
+                nLength = MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE; //128
+
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_8_BYTE_EACH_TIME)
+                if (i < 8) // 1 < i < 8
+                {
+                    for (j = 0; j < (nLength/8); j ++) // 128/8 = 16
+                    {
+                        for (k = 0; k < 8; k ++)
+                        {
+                            szBufferData[k] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE*i+(8*j)+k];
+                        }
+                    
+                        _DrvFwCtrlMsg28xxIspBurstWriteEFlashDoWrite(&szBufferData[0], 8);
+
+                        udelay(2000); // delay about 2ms 
+                    }
+                }
+                else // i >= 8
+                {
+                    for (j = 0; j < (nLength/8); j ++) // 128/8 = 16
+                    {
+                        for (k = 0; k < 8; k ++)
+                        {
+                            szBufferData[k] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE+1][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE*(i-8)+(8*j)+k];
+                        }
+                    
+                        _DrvFwCtrlMsg28xxIspBurstWriteEFlashDoWrite(&szBufferData[0], 8);
+
+                        udelay(2000); // delay about 2ms 
+                    }
+                }
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_32_BYTE_EACH_TIME)
+                if (i < 8) // 1 < i < 8
+                {
+                    for (j = 0; j < (nLength/32); j ++) // 128/32 = 4
+                    {
+                        for (k = 0; k < 32; k ++)
+                        {
+                            szBufferData[k] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE*i+(32*j)+k];
+                        }
+                    
+                        _DrvFwCtrlMsg28xxIspBurstWriteEFlashDoWrite(&szBufferData[0], 32);
+
+                        udelay(2000); // delay about 2ms 
+                    }
+                }
+                else // i >= 8
+                {
+                    for (j = 0; j < (nLength/32); j ++) // 128/32 = 4
+                    {
+                        for (k = 0; k < 32; k ++)
+                        {
+                            szBufferData[k] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE+1][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE*(i-8)+(32*j)+k];
+                        }
+                    
+                        _DrvFwCtrlMsg28xxIspBurstWriteEFlashDoWrite(&szBufferData[0], 32);
+
+                        udelay(2000); // delay about 2ms 
+                    }
+                }
+#else // UPDATE FIRMWARE WITH 128 BYTE EACH TIME
+                if (i < 8) // 1 < i < 8
+                {
+                    for (j = 0; j < nLength; j ++)
+                    {
+                        szBufferData[j] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE*i+j];
+                    }
+                }
+                else // i >= 8
+                {
+                    for (j = 0; j < nLength; j ++)
+                    {
+                        szBufferData[j] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE+1][MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE*(i-8)+j];
+                    }
+                }
+#endif
+            }
+        
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_8_BYTE_EACH_TIME) || defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_32_BYTE_EACH_TIME)
+            // Do nothing here
+#else
+            _DrvFwCtrlMsg28xxIspBurstWriteEFlashDoWrite(&szBufferData[0], nLength);
+
+            udelay(2000); // delay about 2ms 
+#endif        
+            nIndex += nLength;
+        }
+
+        _DrvFwCtrlMsg28xxIspBurstWriteEFlashEnd();
+    
+        // Set write done
+        RegSet16BitValueOn(0x1606, BIT2);
+            
+        // Check RBB
+        nRegData = RegGetLByteValue(0x160E);
+        nRetryTime = 0;
+    
+        while ((nRegData & BIT3) != BIT3)
+        {
+            mdelay(10);
+
+            nRegData = RegGetLByteValue(0x160E);
+    
+            if (nRetryTime ++ > 100)
+            {
+                DBG(&g_I2cClient->dev, "Info block page 1~14 can't wait write to done.\n");
+
+                goto ProgramEnd;
+            }
+        }
+
+        RegSet16BitValueOff(0x1EBE, BIT15); 
+
+        // Update page 15 by write mode
+        nIndex = 15 * MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE;
+        nWordNum = MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE / MSG28XX_EMEM_SIZE_BYTES_ONE_WORD; // 128/4=32
+        nLength = MSG28XX_EMEM_SIZE_BYTES_ONE_WORD;
+
+        for (i = 0; i < nWordNum; i ++) 
+        {
+            if (i == 0)
+            {
+                szFirstData[0] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE+1][7*MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE];
+                szFirstData[1] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE+1][7*MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE+1];
+                szFirstData[2] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE+1][7*MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE+2];
+                szFirstData[3] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE+1][7*MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE+3];
+
+                _DrvFwCtrlMsg28xxWriteEFlashStart(nIndex, &szFirstData[0], EMEM_INFO);
+            }
+            else
+            {
+                for (j = 0; j < nLength; j ++)
+                {
+                    szFirstData[j] = g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE+1][7*MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE+(4*i)+j];
+                }
+
+                _DrvFwCtrlMsg28xxWriteEFlashDoWrite(nIndex, &szFirstData[0]);            			
+            }
+
+            udelay(2000); // delay about 2ms 
+
+            nIndex += nLength;
+        }
+        
+        _DrvFwCtrlMsg28xxWriteEFlashEnd();
+
+        // Set write done
+        RegSet16BitValueOn(0x1606, BIT2);
+            
+        // Check RBB
+        nRegData = RegGetLByteValue(0x160E);
+        nRetryTime = 0;
+    
+        while ((nRegData & BIT3) != BIT3)
+        {
+            mdelay(10);
+
+            nRegData = RegGetLByteValue(0x160E);
+    
+            if (nRetryTime ++ > 100)
+            {
+                DBG(&g_I2cClient->dev, "Info block page 15 can't wait write to done.\n");
+                
+                goto ProgramEnd;
+            }
+        }
+    }
+
+    ProgramEnd:
+    
+    _DrvFwCtrlMsg28xxSetProtectBit();
+
+    // Clear PROGRAM erase password
+    RegSet16BitValue(0x1618, 0xA55A);
+
+    DBG(&g_I2cClient->dev, "Program end\n");
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+}
+
+static u16 _DrvFwCtrlMsg28xxGetSwId(EmemType_e eEmemType) 
+{
+    u16 nRetVal = 0; 
+    u16 nReadAddr = 0;
+    u8  szTmpData[4] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop MCU
+    RegSetLByteValue(0x0FE6, 0x01); 
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55);
+
+    if (eEmemType == EMEM_MAIN) // Read SW ID from main block
+    {
+        _DrvFwCtrlMsg28xxReadEFlashStart(0x7FFD, EMEM_MAIN); 
+        nReadAddr = 0x7FFD;
+    }
+    else if (eEmemType == EMEM_INFO) // Read SW ID from info block
+    {
+        _DrvFwCtrlMsg28xxReadEFlashStart(0x81FB, EMEM_INFO);
+        nReadAddr = 0x81FB;
+    }
+
+    _DrvFwCtrlMsg28xxReadEFlashDoRead(nReadAddr, &szTmpData[0]);
+
+    _DrvFwCtrlMsg28xxReadEFlashEnd();
+
+    /*
+      Ex. SW ID in Main Block :
+          Major low byte at address 0x7FFD
+          
+          SW ID in Info Block :
+          Major low byte at address 0x81FB
+    */
+
+    nRetVal = (szTmpData[1] << 8);
+    nRetVal |= szTmpData[0];
+    
+    DBG(&g_I2cClient->dev, "SW ID = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;		
+}
+
+static u32 _DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EmemType_e eEmemType) 
+{
+    u32 nRetVal = 0; 
+    u32 nRetryTime = 0;
+    u32 nCrcEndAddr = 0;
+    u16 nCrcDown = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    _DrvFwCtrlMsg28xxAccessEFlashInit();
+
+    if (eEmemType == EMEM_MAIN)
+    {
+        // Disable cpu read flash
+        RegSetLByteValue(0x1608, 0x20);
+        RegSetLByteValue(0x1606, 0x20);
+        
+        // Set read flag
+        RegSet16BitValue(0x1610, 0x0001);
+    		
+        // Mode reset main block
+        RegSet16BitValue(0x1606, 0x0000);
+
+        // CRC reset
+        RegSet16BitValue(0x1620, 0x0002);
+
+        RegSet16BitValue(0x1620, 0x0000);
+        
+        // Set CRC e-flash block start address => Main Block : 0x0000 ~ 0x7FFE
+        RegSet16BitValue(0x1600, 0x0000);
+        
+        nCrcEndAddr = (MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE*1024)/4-2;
+
+        RegSet16BitValue(0x1622, nCrcEndAddr);
+        
+        // Trigger CRC check
+        RegSet16BitValue(0x1620, 0x0001);
+        
+        nCrcDown = RegGet16BitValue(0x1620);
+        
+        nRetryTime = 0;
+        while ((nCrcDown >> 15) == 0)
+        {
+            mdelay(10);
+
+            nCrcDown = RegGet16BitValue(0x1620);
+            nRetryTime ++;
+            
+            if (nRetryTime > 30)
+            {
+                DBG(&g_I2cClient->dev, "Wait main block nCrcDown failed.\n");
+                break;
+            }
+        }
+        
+        nRetVal = RegGet16BitValue(0x1626);
+        nRetVal = (nRetVal << 16) | RegGet16BitValue(0x1624);
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        // Disable cpu read flash
+        RegSetLByteValue(0x1608, 0x20);
+        RegSetLByteValue(0x1606, 0x20);
+        
+        // Set read flag
+        RegSet16BitValue(0x1610, 0x0001);
+    		
+        // Mode reset info block
+        RegSet16BitValue(0x1606, 0x0800);
+
+        RegSetLByteValue(0x1604, 0x01);
+
+        // CRC reset
+        RegSet16BitValue(0x1620, 0x0002);
+
+        RegSet16BitValue(0x1620, 0x0000);
+        
+        // Set CRC e-flash block start address => Info Block : 0x0020 ~ 0x01FE
+        RegSet16BitValue(0x1600, 0x0020);
+        RegSet16BitValue(0x1622, 0x01FE);
+
+        // Trigger CRC check
+        RegSet16BitValue(0x1620, 0x0001);
+        
+        nCrcDown = RegGet16BitValue(0x1620);
+        
+        nRetryTime = 0;
+        while ((nCrcDown >> 15) == 0)
+        {
+            mdelay(10);
+
+            nCrcDown = RegGet16BitValue(0x1620);
+            nRetryTime ++;
+            
+            if (nRetryTime > 30)
+            {
+                DBG(&g_I2cClient->dev, "Wait info block nCrcDown failed.\n");
+                break;
+            }
+        }
+        
+        nRetVal = RegGet16BitValue(0x1626);
+        nRetVal = (nRetVal << 16) | RegGet16BitValue(0x1624);
+    }
+
+    DBG(&g_I2cClient->dev, "Hardware CRC = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;	
+}
+
+static u32 _DrvFwCtrlMsg28xxRetrieveFirmwareCrcFromEFlash(EmemType_e eEmemType) 
+{
+    u32 nRetVal = 0; 
+    u16 nReadAddr = 0;
+    u8  szTmpData[4] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop MCU
+    RegSetLByteValue(0x0FE6, 0x01); 
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55);
+
+    if (eEmemType == EMEM_MAIN) // Read main block CRC(128KB-4) from main block
+    {
+        _DrvFwCtrlMsg28xxReadEFlashStart(0x7FFF, EMEM_MAIN);
+        nReadAddr = 0x7FFF;
+    }
+    else if (eEmemType == EMEM_INFO) // Read info block CRC(2KB-MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE-4) from info block
+    {
+        _DrvFwCtrlMsg28xxReadEFlashStart(0x81FF, EMEM_INFO);
+        nReadAddr = 0x81FF;
+    }
+
+    _DrvFwCtrlMsg28xxReadEFlashDoRead(nReadAddr, &szTmpData[0]);
+
+    DBG(&g_I2cClient->dev, "szTmpData[0] = 0x%x\n", szTmpData[0]); // add for debug
+    DBG(&g_I2cClient->dev, "szTmpData[1] = 0x%x\n", szTmpData[1]); // add for debug
+    DBG(&g_I2cClient->dev, "szTmpData[2] = 0x%x\n", szTmpData[2]); // add for debug
+    DBG(&g_I2cClient->dev, "szTmpData[3] = 0x%x\n", szTmpData[3]); // add for debug
+   
+    _DrvFwCtrlMsg28xxReadEFlashEnd();
+
+    nRetVal = (szTmpData[3] << 24);
+    nRetVal |= (szTmpData[2] << 16);
+    nRetVal |= (szTmpData[1] << 8);
+    nRetVal |= szTmpData[0];
+    
+    DBG(&g_I2cClient->dev, "CRC = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;	
+}
+
+static u32 _DrvFwCtrlMsg28xxRetrieveFrimwareCrcFromBinFile(u8 szTmpBuf[][1024], EmemType_e eEmemType) 
+{
+    u32 nRetVal = 0; 
+    
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+    
+    if (szTmpBuf != NULL)
+    {
+        if (eEmemType == EMEM_MAIN) 
+        {
+            nRetVal = szTmpBuf[127][1023];
+            nRetVal = (nRetVal << 8) | szTmpBuf[127][1022];
+            nRetVal = (nRetVal << 8) | szTmpBuf[127][1021];
+            nRetVal = (nRetVal << 8) | szTmpBuf[127][1020];
+        }
+        else if (eEmemType == EMEM_INFO) 
+        {
+            nRetVal = szTmpBuf[129][1023];
+            nRetVal = (nRetVal << 8) | szTmpBuf[129][1022];
+            nRetVal = (nRetVal << 8) | szTmpBuf[129][1021];
+            nRetVal = (nRetVal << 8) | szTmpBuf[129][1020];
+        }
+    }
+
+    return nRetVal;
+}
+
+static s32 _DrvFwCtrlMsg28xxCheckFirmwareBinIntegrity(u8 szFwData[][1024])
+{
+    u32 nCrcMain = 0, nCrcMainBin = 0;
+    u32 nCrcInfo = 0, nCrcInfoBin = 0;
+    u32 nRetVal = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+	
+    _DrvFwCtrlMsg28xxConvertFwDataTwoDimenToOneDimen(szFwData, _gOneDimenFwData);
+    
+    /* Calculate main block CRC & info block CRC by device driver itself */
+    nCrcMain = _DrvFwCtrlMsg28xxCalculateCrc(_gOneDimenFwData, 0, MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE*1024-MSG28XX_EMEM_SIZE_BYTES_ONE_WORD);
+    nCrcInfo = _DrvFwCtrlMsg28xxCalculateCrc(_gOneDimenFwData, MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE*1024+MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE, MSG28XX_FIRMWARE_INFO_BLOCK_SIZE*1024-MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE-MSG28XX_EMEM_SIZE_BYTES_ONE_WORD);
+
+    /* Read main block CRC & info block CRC from firmware bin file */
+    nCrcMainBin = _DrvFwCtrlMsg28xxRetrieveFrimwareCrcFromBinFile(szFwData, EMEM_MAIN);
+    nCrcInfoBin = _DrvFwCtrlMsg28xxRetrieveFrimwareCrcFromBinFile(szFwData, EMEM_INFO);
+
+    DBG(&g_I2cClient->dev, "nCrcMain=0x%x, nCrcInfo=0x%x, nCrcMainBin=0x%x, nCrcInfoBin=0x%x\n",
+               nCrcMain, nCrcInfo, nCrcMainBin, nCrcInfoBin);
+
+    if ((nCrcMainBin != nCrcMain) || (nCrcInfoBin != nCrcInfo))
+    {
+        DBG(&g_I2cClient->dev, "CHECK FIRMWARE BIN FILE INTEGRITY FAILED. CANCEL UPDATE FIRMWARE.\n");
+      
+        nRetVal = -1;
+    } 
+    else
+    {
+        DBG(&g_I2cClient->dev, "CHECK FIRMWARE BIN FILE INTEGRITY SUCCESS. PROCEED UPDATE FIRMWARE.\n");
+
+        nRetVal = 0;
+    }
+
+    return nRetVal;
+}
+
+static s32 _DrvFwCtrlMsg28xxUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+    u32 nCrcMain = 0, nCrcMainHardware = 0, nCrcMainEflash = 0;
+    u32 nCrcInfo = 0, nCrcInfoHardware = 0, nCrcInfoEflash = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    if (_DrvFwCtrlMsg28xxCheckFirmwareBinIntegrity(szFwData) < 0)
+    {
+        DBG(&g_I2cClient->dev, "CHECK FIRMWARE BIN FILE INTEGRITY FAILED. CANCEL UPDATE FIRMWARE.\n");
+
+        g_FwDataCount = 0; // Reset g_FwDataCount to 0 
+
+        DrvPlatformLyrTouchDeviceResetHw();
+
+        return -1;	
+    }
+
+    g_IsUpdateFirmware = 0x01; // Set flag to 0x01 for indicating update firmware is processing
+    
+    /////////////////////////
+    // Erase
+    /////////////////////////
+
+    if (eEmemType == EMEM_ALL)
+    {
+        _DrvFwCtrlMsg28xxEraseEmem(EMEM_MAIN);
+        _DrvFwCtrlMsg28xxEraseEmem(EMEM_INFO);
+    }
+    else if (eEmemType == EMEM_MAIN)
+    {
+        _DrvFwCtrlMsg28xxEraseEmem(EMEM_MAIN);
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        _DrvFwCtrlMsg28xxEraseEmem(EMEM_INFO);
+    }
+
+    DBG(&g_I2cClient->dev, "erase OK\n");
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+
+    if (eEmemType == EMEM_ALL)
+    {
+        _DrvFwCtrlMsg28xxProgramEmem(EMEM_MAIN);
+        _DrvFwCtrlMsg28xxProgramEmem(EMEM_INFO);
+    }
+    else if (eEmemType == EMEM_MAIN)
+    {
+        _DrvFwCtrlMsg28xxProgramEmem(EMEM_MAIN);
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        _DrvFwCtrlMsg28xxProgramEmem(EMEM_INFO);
+    }
+    
+    DBG(&g_I2cClient->dev, "program OK\n");
+
+    /* Calculate main block CRC & info block CRC by device driver itself */
+    _DrvFwCtrlMsg28xxConvertFwDataTwoDimenToOneDimen(szFwData, _gOneDimenFwData);
+    
+    /* Read main block CRC & info block CRC from TP */
+    if (eEmemType == EMEM_ALL)
+    {
+        nCrcMain = _DrvFwCtrlMsg28xxCalculateCrc(_gOneDimenFwData, 0, MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE*1024-MSG28XX_EMEM_SIZE_BYTES_ONE_WORD);
+        nCrcInfo = _DrvFwCtrlMsg28xxCalculateCrc(_gOneDimenFwData, MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE*1024+MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE, MSG28XX_FIRMWARE_INFO_BLOCK_SIZE*1024-MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE-MSG28XX_EMEM_SIZE_BYTES_ONE_WORD);
+
+        nCrcMainHardware = _DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EMEM_MAIN);
+        nCrcInfoHardware = _DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EMEM_INFO);
+
+        nCrcMainEflash = _DrvFwCtrlMsg28xxRetrieveFirmwareCrcFromEFlash(EMEM_MAIN);
+        nCrcInfoEflash = _DrvFwCtrlMsg28xxRetrieveFirmwareCrcFromEFlash(EMEM_INFO);
+    }
+    else if (eEmemType == EMEM_MAIN)
+    {
+        nCrcMain = _DrvFwCtrlMsg28xxCalculateCrc(_gOneDimenFwData, 0, MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE*1024-MSG28XX_EMEM_SIZE_BYTES_ONE_WORD);
+        nCrcMainHardware = _DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EMEM_MAIN);
+        nCrcMainEflash = _DrvFwCtrlMsg28xxRetrieveFirmwareCrcFromEFlash(EMEM_MAIN);
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        nCrcInfo = _DrvFwCtrlMsg28xxCalculateCrc(_gOneDimenFwData, MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE*1024+MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE, MSG28XX_FIRMWARE_INFO_BLOCK_SIZE*1024-MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE-MSG28XX_EMEM_SIZE_BYTES_ONE_WORD);
+        nCrcInfoHardware = _DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EMEM_INFO);
+        nCrcInfoEflash = _DrvFwCtrlMsg28xxRetrieveFirmwareCrcFromEFlash(EMEM_INFO);
+    }
+
+    DBG(&g_I2cClient->dev, "nCrcMain=0x%x, nCrcInfo=0x%x, nCrcMainHardware=0x%x, nCrcInfoHardware=0x%x, nCrcMainEflash=0x%x, nCrcInfoEflash=0x%x\n",
+               nCrcMain, nCrcInfo, nCrcMainHardware, nCrcInfoHardware, nCrcMainEflash, nCrcInfoEflash);
+
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    mdelay(300);
+
+    g_IsUpdateFirmware = 0x00; // Set flag to 0x00 for indicating update firmware is finished
+
+    if (eEmemType == EMEM_ALL)
+    {
+        if ((nCrcMainHardware != nCrcMain) || (nCrcInfoHardware != nCrcInfo) || (nCrcMainEflash != nCrcMain) || (nCrcInfoEflash != nCrcInfo))
+        {
+            DBG(&g_I2cClient->dev, "Update FAILED\n");
+          
+            return -1;
+        } 
+    }
+    else if (eEmemType == EMEM_MAIN)
+    {
+        if ((nCrcMainHardware != nCrcMain) || (nCrcMainEflash != nCrcMain))
+        {
+            DBG(&g_I2cClient->dev, "Update FAILED\n");
+          
+            return -1;
+        } 
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        if ((nCrcInfoHardware != nCrcInfo) || (nCrcInfoEflash != nCrcInfo))
+        {
+            DBG(&g_I2cClient->dev, "Update FAILED\n");
+          
+            return -1;
+        } 
+    }
+
+    DBG(&g_I2cClient->dev, "Update SUCCESS\n");
+
+    return 0;
+}
+
+static s32 _DrvFwCtrlUpdateFirmwareCash(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DBG(&g_I2cClient->dev, "g_ChipType = 0x%x\n", g_ChipType);
+    
+    if (g_ChipType == CHIP_TYPE_MSG21XXA) // (0x02)
+    {
+        u8 nChipVersion = 0;
+
+        DrvPlatformLyrTouchDeviceResetHw();
+
+        // Erase TP Flash first
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+    
+        // Stop MCU
+        RegSetLByteValue(0x0FE6, 0x01);
+
+        // Disable watchdog
+        RegSet16BitValue(0x3C60, 0xAA55);
+    
+        /////////////////////////
+        // Difference between C2 and C3
+        /////////////////////////
+        // c2:MSG2133(1) c32:MSG2133A(2) c33:MSG2138A(2)
+            
+        // check ic version
+        nChipVersion = RegGet16BitValue(0x3CEA) & 0xFF;
+
+        DBG(&g_I2cClient->dev, "chip version = 0x%x\n", nChipVersion);
+        
+        if (nChipVersion == 3)
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+            return _DrvFwCtrlMsg21xxaUpdateFirmwareBySwId(szFwData, EMEM_MAIN);
+#else
+            g_FwDataCount = 0; // Reset g_FwDataCount to 0
+            
+            return -1;
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA            
+#else
+            return _DrvFwCtrlUpdateFirmwareC33(szFwData, EMEM_MAIN);
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID   
+        }
+        else
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+            return _DrvFwCtrlMsg21xxaUpdateFirmwareBySwId(szFwData, EMEM_MAIN);
+#else
+            g_FwDataCount = 0; // Reset g_FwDataCount to 0
+            
+            return -1;
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA            
+#else
+            return _DrvFwCtrlUpdateFirmwareC32(szFwData, EMEM_ALL);
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID        
+        }
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG22XX) // (0x7A)
+    {
+        _DrvFwCtrlMsg22xxGetTpVendorCode(_gTpVendorCode);
+        
+        if (_gTpVendorCode[0] == 'C' && _gTpVendorCode[1] == 'N' && _gTpVendorCode[2] == 'T') // for specific TP vendor which store some important information in info block, only update firmware for main block, do not update firmware for info block.
+        {
+            return _DrvFwCtrlMsg22xxUpdateFirmware(szFwData, EMEM_MAIN);
+        }
+        else
+        {
+            return _DrvFwCtrlMsg22xxUpdateFirmware(szFwData, EMEM_ALL);
+        }
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG26XXM) // (0x03)
+    {
+        return _DrvFwCtrlMsg26xxmUpdateFirmware(szFwData, eEmemType);
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG28XX) // (0x85)
+    {
+        DBG(&g_I2cClient->dev, "IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED = %d\n", IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED);
+
+        if (IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED) // Force to update firmware, do not check whether the vendor id of the update firmware bin file is equal to the vendor id on e-flash.
+        {
+            return _DrvFwCtrlMsg28xxUpdateFirmware(szFwData, EMEM_MAIN);
+        }
+        else
+        {
+            u16 eSwId = 0x0000;
+            u16 eVendorId = 0x0000;
+
+            eVendorId = szFwData[129][1005] << 8 | szFwData[129][1004]; // Retrieve major from info block
+            eSwId = _DrvFwCtrlMsg28xxGetSwId(EMEM_INFO);
+
+            DBG(&g_I2cClient->dev, "eVendorId = 0x%x, eSwId = 0x%x\n", eVendorId, eSwId);
+    		
+            // Check if the vendor id of the update firmware bin file is equal to the vendor id on e-flash. YES => allow update, NO => not allow update
+            if (eSwId != eVendorId)
+            {
+                DrvPlatformLyrTouchDeviceResetHw(); // Reset HW here to avoid touch may be not worked after get sw id. 
+
+                DBG(&g_I2cClient->dev, "The vendor id of the update firmware bin file is different from the vendor id on e-flash. Not allow to update.\n");
+                g_FwDataCount = 0; // Reset g_FwDataCount to 0
+
+                return -1;
+            }
+            else
+            {
+                return _DrvFwCtrlMsg28xxUpdateFirmware(szFwData, EMEM_MAIN);
+            }
+        }
+    }
+    else 
+    {
+        DBG(&g_I2cClient->dev, "Undefined chip type.\n");
+        g_FwDataCount = 0; // Reset g_FwDataCount to 0
+
+        return -1;
+    }	
+}
+
+static s32 _DrvFwCtrlUpdateFirmwareBySdCard(const char *pFilePath)
+{
+    s32 nRetVal = 0;
+    struct file *pfile = NULL;
+    struct inode *inode;
+    s32 fsize = 0;
+    mm_segment_t old_fs;
+    loff_t pos;
+    u16 eSwId = 0x0000;
+    u16 eVendorId = 0x0000;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    pfile = filp_open(pFilePath, O_RDONLY, 0);
+    if (IS_ERR(pfile))
+    {
+        DBG(&g_I2cClient->dev, "Error occurred while opening file %s.\n", pFilePath);
+        return -1;
+    }
+
+    inode = pfile->f_dentry->d_inode;
+    fsize = inode->i_size;
+
+    DBG(&g_I2cClient->dev, "fsize = %d\n", fsize);
+
+    if (fsize <= 0)
+    {
+        filp_close(pfile, NULL);
+        return -1;
+    }
+
+    // read firmware
+    memset(_gFwDataBuf, 0, MSG28XX_FIRMWARE_WHOLE_SIZE*1024);
+
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+  
+    pos = 0;
+    vfs_read(pfile, _gFwDataBuf, fsize, &pos);
+  
+    filp_close(pfile, NULL);
+    set_fs(old_fs);
+
+    _DrvFwCtrlStoreFirmwareData(_gFwDataBuf, fsize);
+
+    DrvPlatformLyrDisableFingerTouchReport();
+    
+    if (g_ChipType == CHIP_TYPE_MSG21XXA)    
+    {
+        eVendorId = g_FwData[31][0x34F] <<8 | g_FwData[31][0x34E];
+        eSwId = _DrvFwCtrlMsg21xxaGetSwId(EMEM_MAIN);
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG22XX)    
+    {
+        eVendorId = g_FwData[47][1013] <<8 | g_FwData[47][1012];
+        eSwId = _DrvFwCtrlMsg22xxGetSwId(EMEM_MAIN);
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG26XXM)    
+    {
+        eVendorId = g_FwData[0][0x2B] <<8 | g_FwData[0][0x2A];
+        eSwId = _DrvFwCtrlMsg26xxmGetSwId(EMEM_MAIN);
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG28XX)    
+    {
+        eVendorId = g_FwData[129][1005] << 8 | g_FwData[129][1004]; // Retrieve major from info block
+        eSwId = _DrvFwCtrlMsg28xxGetSwId(EMEM_INFO);
+    }
+
+    DBG(&g_I2cClient->dev, "eVendorId = 0x%x, eSwId = 0x%x\n", eVendorId, eSwId);
+    DBG(&g_I2cClient->dev, "IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED = %d\n", IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED);
+    		
+    if ((eSwId == eVendorId) || (IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED))
+    {
+        if ((g_ChipType == CHIP_TYPE_MSG21XXA && fsize == 33792/* 33KB */) || (g_ChipType == CHIP_TYPE_MSG22XX && fsize == 49664/* 48.5KB */) || (g_ChipType == CHIP_TYPE_MSG26XXM && fsize == 40960/* 40KB */))
+        {
+    	      nRetVal = _DrvFwCtrlUpdateFirmwareCash(g_FwData, EMEM_ALL);
+        }
+        else if (g_ChipType == CHIP_TYPE_MSG28XX && fsize == 133120/* 130KB */)
+        {
+    	      nRetVal = _DrvFwCtrlUpdateFirmwareCash(g_FwData, EMEM_MAIN); // For MSG28xx sine mode requirement, update main block only, do not update info block.
+        }
+        else
+       	{
+            DrvPlatformLyrTouchDeviceResetHw();
+
+            DBG(&g_I2cClient->dev, "The file size of the update firmware bin file is not supported, fsize = %d\n", fsize);
+            nRetVal = -1;
+        }
+    }
+    else 
+    {
+        DrvPlatformLyrTouchDeviceResetHw();
+
+        DBG(&g_I2cClient->dev, "The vendor id of the update firmware bin file is different from the vendor id on e-flash. Not allow to update.\n");
+        nRetVal = -1;
+    }
+ 
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+    
+    DrvPlatformLyrEnableFingerTouchReport();
+
+    return nRetVal;
+}
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+void DrvFwCtrlOpenGestureWakeup(u32 *pMode)
+{
+    u8 szDbBusTxData[4] = {0};
+    u32 i = 0;
+    s32 rc;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DBG(&g_I2cClient->dev, "wakeup mode 0 = 0x%x\n", pMode[0]);
+    DBG(&g_I2cClient->dev, "wakeup mode 1 = 0x%x\n", pMode[1]);
+
+#ifdef CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+    szDbBusTxData[0] = 0x59;
+    szDbBusTxData[1] = 0x00;
+    szDbBusTxData[2] = ((pMode[1] & 0xFF000000) >> 24);
+    szDbBusTxData[3] = ((pMode[1] & 0x00FF0000) >> 16);
+
+    while (i < 5)
+    {
+        mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE); // delay 20ms
+        rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 4);
+        if (rc > 0)
+        {
+            DBG(&g_I2cClient->dev, "Enable gesture wakeup index 0 success\n");
+            break;
+        }
+
+        i++;
+    }
+    if (i == 5)
+    {
+        DBG(&g_I2cClient->dev, "Enable gesture wakeup index 0 failed\n");
+    }
+
+    szDbBusTxData[0] = 0x59;
+    szDbBusTxData[1] = 0x01;
+    szDbBusTxData[2] = ((pMode[1] & 0x0000FF00) >> 8);
+    szDbBusTxData[3] = ((pMode[1] & 0x000000FF) >> 0);
+	
+    while (i < 5)
+    {
+        mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE); // delay 20ms
+        rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 4);
+        if (rc > 0)
+        {
+            DBG(&g_I2cClient->dev, "Enable gesture wakeup index 1 success\n");
+            break;
+        }
+
+        i++;
+    }
+    if (i == 5)
+    {
+        DBG(&g_I2cClient->dev, "Enable gesture wakeup index 1 failed\n");
+    }
+
+    szDbBusTxData[0] = 0x59;
+    szDbBusTxData[1] = 0x02;
+    szDbBusTxData[2] = ((pMode[0] & 0xFF000000) >> 24);
+    szDbBusTxData[3] = ((pMode[0] & 0x00FF0000) >> 16);
+    
+    while (i < 5)
+    {
+        mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE); // delay 20ms
+        rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 4);
+        if (rc > 0)
+        {
+            DBG(&g_I2cClient->dev, "Enable gesture wakeup index 2 success\n");
+            break;
+        }
+
+        i++;
+    }
+    if (i == 5)
+    {
+        DBG(&g_I2cClient->dev, "Enable gesture wakeup index 2 failed\n");
+    }
+
+    szDbBusTxData[0] = 0x59;
+    szDbBusTxData[1] = 0x03;
+    szDbBusTxData[2] = ((pMode[0] & 0x0000FF00) >> 8);
+    szDbBusTxData[3] = ((pMode[0] & 0x000000FF) >> 0);
+    
+    while (i < 5)
+    {
+        mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE); // delay 20ms
+        rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 4);
+        if (rc > 0)
+        {
+            DBG(&g_I2cClient->dev, "Enable gesture wakeup index 3 success\n");
+            break;
+        }
+
+        i++;
+    }
+    if (i == 5)
+    {
+        DBG(&g_I2cClient->dev, "Enable gesture wakeup index 3 failed\n");
+    }
+
+    g_GestureWakeupFlag = 1; // gesture wakeup is enabled
+
+#else
+	
+    szDbBusTxData[0] = 0x58;
+    szDbBusTxData[1] = ((pMode[0] & 0x0000FF00) >> 8);
+    szDbBusTxData[2] = ((pMode[0] & 0x000000FF) >> 0);
+
+    while (i < 5)
+    {
+        mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE); // delay 20ms
+        rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+        if (rc > 0)
+        {
+            DBG(&g_I2cClient->dev, "Enable gesture wakeup success\n");
+            break;
+        }
+
+        i++;
+    }
+    if (i == 5)
+    {
+        DBG(&g_I2cClient->dev, "Enable gesture wakeup failed\n");
+    }
+
+    g_GestureWakeupFlag = 1; // gesture wakeup is enabled
+#endif //CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+}
+
+void DrvFwCtrlCloseGestureWakeup(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    g_GestureWakeupFlag = 0; // gesture wakeup is disabled
+}
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+void DrvFwCtrlOpenGestureDebugMode(u8 nGestureFlag)
+{
+    u8 szDbBusTxData[3] = {0};
+    s32 rc;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DBG(&g_I2cClient->dev, "Gesture Flag = 0x%x\n", nGestureFlag);
+
+    szDbBusTxData[0] = 0x30;
+    szDbBusTxData[1] = 0x01;
+    szDbBusTxData[2] = nGestureFlag;
+
+    mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+    rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+    if (rc < 0)
+    {
+        DBG(&g_I2cClient->dev, "Enable gesture debug mode failed\n");
+    }
+    else
+    {
+        g_GestureDebugMode = 1; // gesture debug mode is enabled
+
+        DBG(&g_I2cClient->dev, "Enable gesture debug mode success\n");
+    }
+}
+
+void DrvFwCtrlCloseGestureDebugMode(void)
+{
+    u8 szDbBusTxData[3] = {0};
+    s32 rc;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    szDbBusTxData[0] = 0x30;
+    szDbBusTxData[1] = 0x00;
+    szDbBusTxData[2] = 0x00;
+
+    mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+    rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+    if (rc < 0)
+    {
+        DBG(&g_I2cClient->dev, "Disable gesture debug mode failed\n");
+    }
+    else
+    {
+        g_GestureDebugMode = 0; // gesture debug mode is disabled
+
+        DBG(&g_I2cClient->dev, "Disable gesture debug mode success\n");
+    }
+}
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+static void _DrvFwCtrlCoordinate(u8 *pRawData, u32 *pTranX, u32 *pTranY)
+{
+   	u32 nX;
+   	u32 nY;
+#ifdef CONFIG_SWAP_X_Y
+   	u32 nTempX;
+   	u32 nTempY;
+#endif
+
+   	nX = (((pRawData[0] & 0xF0) << 4) | pRawData[1]);         // parse the packet to coordinate
+    nY = (((pRawData[0] & 0x0F) << 8) | pRawData[2]);
+
+    DBG(&g_I2cClient->dev, "[x,y]=[%d,%d]\n", nX, nY);
+
+#ifdef CONFIG_SWAP_X_Y
+    nTempY = nX;
+   	nTempX = nY;
+    nX = nTempX;
+    nY = nTempY;
+#endif
+
+#ifdef CONFIG_REVERSE_X
+    nX = 2047 - nX;
+#endif
+
+#ifdef CONFIG_REVERSE_Y
+    nY = 2047 - nY;
+#endif
+
+   	/*
+   	 * pRawData[0]~pRawData[2] : the point abs,
+   	 * pRawData[0]~pRawData[2] all are 0xFF, release touch
+   	 */
+    if ((pRawData[0] == 0xFF) && (pRawData[1] == 0xFF) && (pRawData[2] == 0xFF))
+    {
+   	    *pTranX = 0; // final X coordinate
+        *pTranY = 0; // final Y coordinate
+    }
+    else
+    {
+     	  /* one touch point */
+        *pTranX = (nX * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+        *pTranY = (nY * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+        DBG(&g_I2cClient->dev, "[%s]: [x,y]=[%d,%d]\n", __func__, nX, nY);
+        DBG(&g_I2cClient->dev, "[%s]: point[x,y]=[%d,%d]\n", __func__, *pTranX, *pTranY);
+    }
+}
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+static void _DrvFwCtrlReadReadDQMemStart(void)
+{
+    u8 nParCmdSelUseCfg = 0x7F;
+    u8 nParCmdAdByteEn0 = 0x50;
+    u8 nParCmdAdByteEn1 = 0x51;
+    u8 nParCmdDaByteEn0 = 0x54;
+    u8 nParCmdUSetSelB0 = 0x80;
+    u8 nParCmdUSetSelB1 = 0x82;
+    u8 nParCmdSetSelB2  = 0x85;
+    u8 nParCmdIicUse    = 0x35;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdSelUseCfg, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdAdByteEn0, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdAdByteEn1, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdDaByteEn0, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdUSetSelB0, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdUSetSelB1, 1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdSetSelB2,  1);
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdIicUse,    1);
+}
+
+static void _DrvFwCtrlReadReadDQMemEnd(void)
+{
+    u8 nParCmdNSelUseCfg = 0x7E;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdNSelUseCfg, 1);
+}
+
+u32 DrvFwCtrlReadDQMemValue(u16 nAddr)
+{
+    if (g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        u8 tx_data[3] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF};
+        u8 rx_data[4] = {0};
+
+        DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+        DBG(&g_I2cClient->dev, "DQMem Addr = 0x%x\n", nAddr);
+
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+
+        // Stop mcu
+        RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+        mdelay(100);
+
+        _DrvFwCtrlReadReadDQMemStart();
+
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+        IicReadData(SLAVE_I2C_ID_DBBUS, &rx_data[0], 4);
+
+        _DrvFwCtrlReadReadDQMemEnd();
+
+        // Start mcu
+        RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+
+        return (rx_data[3] <<24 | rx_data[2] <<16 | rx_data[1] << 8 | rx_data[0]);
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+        // TODO : not support yet
+    
+        return 0;	
+    }
+}
+
+void DrvFwCtrlWriteDQMemValue(u16 nAddr, u32 nData)
+{
+    if (g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        u8 szDbBusTxData[7] = {0};
+
+        DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+        DBG(&g_I2cClient->dev, "DQMem Addr = 0x%x\n", nAddr);
+
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+    
+        // Stop mcu
+        RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+        mdelay(100);
+
+        _DrvFwCtrlReadReadDQMemStart();
+    
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = ((nAddr >> 8) & 0xff);
+        szDbBusTxData[2] = (nAddr & 0xff);
+        szDbBusTxData[3] = nData & 0x000000FF;
+        szDbBusTxData[4] = ((nData & 0x0000FF00) >> 8);
+        szDbBusTxData[5] = ((nData & 0x00FF0000) >> 16);
+        szDbBusTxData[6] = ((nData & 0xFF000000) >> 24);
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 7);
+
+        _DrvFwCtrlReadReadDQMemEnd();
+
+    	  // Start mcu
+        RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+        mdelay(100);
+
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+        // TODO : not support yet
+    }
+}
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+//-------------------------Start of SW ID for MSG22XX----------------------------//
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+static void _DrvFwCtrlMsg22xxEraseEmem(EmemType_e eEmemType)
+{
+    u32 i = 0;
+    u32 nEraseCount = 0;
+    u32 nMaxEraseTimes = 0;
+    u32 nTimeOut = 0;
+    u16 nRegData = 0;
+    u16 nTrimByte1 = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    DBG(&g_I2cClient->dev, "Erase start\n");
+
+    // Stop MCU
+    RegSetLByteValue(0x0FE6, 0x01); 
+    
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+    // Exit flash low power mode
+    RegSetLByteValue(0x1619, BIT1); 
+
+    // Change PIU clock to 48MHz
+    RegSetLByteValue(0x1E23, BIT6); 
+
+    // Change mcu clock deglitch mux source
+    RegSetLByteValue(0x1E54, BIT0); 
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+    nTrimByte1 = _DrvFwCtrlMsg22xxGetTrimByte1();
+    
+    _DrvFwCtrlMsg22xxChangeVoltage();
+
+    // Disable watchdog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    // Set PROGRAM password
+    RegSetLByteValue(0x161A, 0xBA);
+    RegSetLByteValue(0x161B, 0xAB);
+
+    if (nTrimByte1 == 0xCA)
+    {
+        nMaxEraseTimes = MSG22XX_MAX_ERASE_EFLASH_TIMES;
+    }
+    else
+    {
+        nMaxEraseTimes = 1;	
+    }
+
+    for (nEraseCount = 0; nEraseCount < nMaxEraseTimes; nEraseCount ++)
+    {
+        if (eEmemType == EMEM_ALL) // 48KB + 512Byte
+        {
+            DBG(&g_I2cClient->dev, "Erase all block %d times\n", nEraseCount);
+
+            // Clear pce
+            RegSetLByteValue(0x1618, 0x80);
+            mdelay(100);
+
+            // Chip erase
+            RegSet16BitValue(0x160E, BIT3);
+
+            DBG(&g_I2cClient->dev, "Wait erase done flag\n");
+
+            while (1) // Wait erase done flag
+            {
+                nRegData = RegGet16BitValue(0x1610); // Memory status
+                nRegData = nRegData & BIT1;
+            
+                DBG(&g_I2cClient->dev, "Wait erase done flag nRegData = 0x%x\n", nRegData);
+
+                if (nRegData == BIT1)
+                {
+                    break;		
+                }
+
+                mdelay(50);
+
+                if ((nTimeOut ++) > 30)
+                {
+                    DBG(&g_I2cClient->dev, "Erase all block %d times failed. Timeout.\n", nEraseCount);
+
+                    if (nEraseCount == (nMaxEraseTimes - 1))
+                    {
+                        goto EraseEnd;
+                    }
+                }
+            }
+        }
+        else if (eEmemType == EMEM_MAIN) // 48KB (32+8+8)
+        {
+            DBG(&g_I2cClient->dev, "Erase main block %d times\n", nEraseCount);
+
+            for (i = 0; i < 3; i ++)
+            {
+                // Clear pce
+                RegSetLByteValue(0x1618, 0x80);
+                mdelay(10);
+ 
+                if (i == 0)
+                {
+                    RegSet16BitValue(0x1600, 0x0000);
+                }
+                else if (i == 1)
+                {
+                    RegSet16BitValue(0x1600, 0x8000);
+                }
+                else if (i == 2)
+                {
+                    RegSet16BitValue(0x1600, 0xA000);
+                }
+
+                // Sector erase
+                RegSet16BitValue(0x160E, (RegGet16BitValue(0x160E) | BIT2));
+
+                DBG(&g_I2cClient->dev, "Wait erase done flag\n");
+
+                nRegData = 0;
+                nTimeOut = 0;
+
+                while (1) // Wait erase done flag
+                {
+                    nRegData = RegGet16BitValue(0x1610); // Memory status
+                    nRegData = nRegData & BIT1;
+            
+                    DBG(&g_I2cClient->dev, "Wait erase done flag nRegData = 0x%x\n", nRegData);
+
+                    if (nRegData == BIT1)
+                    {
+                        break;		
+                    }
+                    mdelay(50);
+
+                    if ((nTimeOut ++) > 30)
+                    {
+                        DBG(&g_I2cClient->dev, "Erase main block %d times failed. Timeout.\n", nEraseCount);
+
+                        if (nEraseCount == (nMaxEraseTimes - 1))
+                        {
+                            goto EraseEnd;
+                        }
+                    }
+                }
+            }   
+        }
+        else if (eEmemType == EMEM_INFO) // 512Byte
+        {
+            DBG(&g_I2cClient->dev, "Erase info block %d times\n", nEraseCount);
+
+            // Clear pce
+            RegSetLByteValue(0x1618, 0x80);
+            mdelay(10);
+
+            RegSet16BitValue(0x1600, 0xC000);
+        
+            // Sector erase
+            RegSet16BitValue(0x160E, (RegGet16BitValue(0x160E) | BIT2));
+
+            DBG(&g_I2cClient->dev, "Wait erase done flag\n");
+
+            while (1) // Wait erase done flag
+            {
+                nRegData = RegGet16BitValue(0x1610); // Memory status
+                nRegData = nRegData & BIT1;
+            
+                DBG(&g_I2cClient->dev, "Wait erase done flag nRegData = 0x%x\n", nRegData);
+
+                if (nRegData == BIT1)
+                {
+                    break;		
+                }
+                mdelay(50);
+
+                if ((nTimeOut ++) > 30)
+                {
+                    DBG(&g_I2cClient->dev, "Erase info block %d times failed. Timeout.\n", nEraseCount);
+
+                    if (nEraseCount == (nMaxEraseTimes - 1))
+                    {
+                        goto EraseEnd;
+                    }
+                }
+            }
+        }
+    }
+    
+    _DrvFwCtrlMsg22xxRestoreVoltage();
+
+    EraseEnd:
+    
+    DBG(&g_I2cClient->dev, "Erase end\n");
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+}
+
+static void _DrvFwCtrlMsg22xxProgramEmem(EmemType_e eEmemType) 
+{
+    u32 i, j; 
+    u32 nRemainSize = 0, nBlockSize = 0, nSize = 0, index = 0;
+    u32 nTimeOut = 0;
+    u16 nRegData = 0;
+    s32 rc = 0;
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    u8 szDbBusTxData[128] = {0};
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+    u32 nSizePerWrite = 1;
+#else 
+    u32 nSizePerWrite = 125;
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+    u8 szDbBusTxData[1024] = {0};
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+    u32 nSizePerWrite = 1;
+#else
+    u32 nSizePerWrite = 1021;
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+#endif
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+    if (g_Msg22xxChipRevision >= CHIP_TYPE_MSG22XX_REVISION_U05) 
+    {
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A)
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        nSizePerWrite = 41; // 123/3=41
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        nSizePerWrite = 340; // 1020/3=340
+#endif
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_B)
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        nSizePerWrite = 31; // 124/4=31
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        nSizePerWrite = 255; // 1020/4=255
+#endif
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A
+    }
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+    
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Hold reset pin before program
+    RegSetLByteValue(0x1E06, 0x00);
+
+    DBG(&g_I2cClient->dev, "Program start\n");
+
+    RegSet16BitValue(0x161A, 0xABBA);
+    RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+    if (eEmemType == EMEM_MAIN)
+    {
+        DBG(&g_I2cClient->dev, "Program main block\n");
+
+        RegSet16BitValue(0x1600, 0x0000); // Set start address of main block
+        nRemainSize = MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024; //48KB
+        index = 0;
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        DBG(&g_I2cClient->dev, "Program info block\n");
+
+        RegSet16BitValue(0x1600, 0xC000); // Set start address of info block
+        nRemainSize = MSG22XX_FIRMWARE_INFO_BLOCK_SIZE; //512Byte
+        index = MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024;
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "eEmemType = %d is not supported for program e-memory.\n", eEmemType);
+        return;
+    }
+
+    RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01)); // Enable burst mode
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+    if (g_Msg22xxChipRevision >= CHIP_TYPE_MSG22XX_REVISION_U05) 
+    {
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A)
+        RegSet16BitValueOn(0x160A, BIT0); // Set Bit0 = 1 for enable I2C 400KHz burst write mode, let e-flash discard the last 2 dummy byte.
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_B)
+        RegSet16BitValueOn(0x160A, BIT0);
+        RegSet16BitValueOn(0x160A, BIT1); // Set Bit0 = 1, Bit1 = 1 for enable I2C 400KHz burst write mode, let e-flash discard the last 3 dummy byte.
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A
+    }
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+    // Program start
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x16;
+    szDbBusTxData[2] = 0x02;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);    
+
+    szDbBusTxData[0] = 0x20;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+
+    i = 0;
+    
+    while (nRemainSize > 0)
+    {
+        if (nRemainSize > nSizePerWrite)
+        {
+            nBlockSize = nSizePerWrite;
+        }
+        else
+        {
+            nBlockSize = nRemainSize;
+        }
+
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = 0x16;
+        szDbBusTxData[2] = 0x02;
+
+        nSize = 3;
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+        if (g_Msg22xxChipRevision >= CHIP_TYPE_MSG22XX_REVISION_U05)
+        {
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A)
+            u32 k = 0;
+
+            for (j = 0; j < nBlockSize; j ++)
+            {
+                for (k = 0; k < 3; k ++)
+                {
+                    szDbBusTxData[3+(j*3)+k] = _gOneDimenFwData[index+(i*nSizePerWrite)+j];
+                }
+                nSize = nSize + 3;
+            }
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_B)
+            u32 k = 0;
+
+            for (j = 0; j < nBlockSize; j ++)
+            {
+                for (k = 0; k < 4; k ++)
+                {
+                    szDbBusTxData[3+(j*4)+k] = _gOneDimenFwData[index+(i*nSizePerWrite)+j];
+                }
+                nSize = nSize + 4;
+            }
+#else //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_C
+            for (j = 0; j < nBlockSize; j ++)
+            {
+                szDbBusTxData[3+j] = _gOneDimenFwData[index+(i*nSizePerWrite)+j];
+                nSize ++; 
+            }
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A
+        }
+        else
+        {
+            for (j = 0; j < nBlockSize; j ++)
+            {
+                szDbBusTxData[3+j] = _gOneDimenFwData[index+(i*nSizePerWrite)+j];
+                nSize ++; 
+            }
+        }
+#else
+        for (j = 0; j < nBlockSize; j ++)
+        {
+            szDbBusTxData[3+j] = _gOneDimenFwData[index+(i*nSizePerWrite)+j];
+            nSize ++; 
+        }
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+        i ++;
+
+        rc = IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], nSize);
+        if (rc < 0)
+        {
+            DBG(&g_I2cClient->dev, "Write firmware data failed, rc = %d. Exit program procedure.\n", rc);
+
+            goto ProgramEnd;
+        }
+
+        nRemainSize = nRemainSize - nBlockSize;
+    }
+
+    // Program end
+    szDbBusTxData[0] = 0x21;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+    if (g_Msg22xxChipRevision >= CHIP_TYPE_MSG22XX_REVISION_U05) 
+    {
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A)
+        RegSet16BitValueOff(0x160A, BIT0); // Set Bit0 = 0 for disable I2C 400KHz burst write mode, let e-flash discard the last 2 dummy byte.
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_B)
+        RegSet16BitValueOff(0x160A, BIT0);
+        RegSet16BitValueOff(0x160A, BIT1); // Set Bit0 = 0, Bit1 = 0 for disable I2C 400KHz burst write mode, let e-flash discard the last 3 dummy byte.
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A
+    }
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+    RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01)); // Clear burst mode
+
+    DBG(&g_I2cClient->dev, "Wait write done flag\n");
+
+    while (1) // Wait write done flag
+    {
+        // Polling 0x1610 is 0x0002
+        nRegData = RegGet16BitValue(0x1610); // Memory status
+        nRegData = nRegData & BIT1;
+    
+        DBG(&g_I2cClient->dev, "Wait write done flag nRegData = 0x%x\n", nRegData);
+
+        if (nRegData == BIT1)
+        {
+            break;		
+        }
+        mdelay(10);
+
+        if ((nTimeOut ++) > 30)
+        {
+            DBG(&g_I2cClient->dev, "Write failed. Timeout.\n");
+
+            goto ProgramEnd;
+        }
+    }
+
+    ProgramEnd:
+
+    DBG(&g_I2cClient->dev, "Program end\n");
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+}
+
+static u32 _DrvFwCtrlMsg22xxRetrieveFirmwareCrcFromEFlash(EmemType_e eEmemType) 
+{
+    u32 nRetVal = 0; 
+    u16 nRegData1 = 0, nRegData2 = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+    // Stop MCU
+    RegSetLByteValue(0x0FE6, 0x01); 
+    
+    // Exit flash low power mode
+    RegSetLByteValue(0x1619, BIT1); 
+
+    // Change PIU clock to 48MHz
+    RegSetLByteValue(0x1E23, BIT6); 
+
+    // Change mcu clock deglitch mux source
+    RegSetLByteValue(0x1E54, BIT0); 
+#else
+    // Stop MCU
+    RegSetLByteValue(0x0FE6, 0x01); 
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55);
+
+    // RIU password
+    RegSet16BitValue(0x161A, 0xABBA); 
+
+    if (eEmemType == EMEM_MAIN) // Read main block CRC(48KB-4) from main block
+    {
+        RegSet16BitValue(0x1600, 0xBFFC); // Set start address for main block CRC
+    }
+    else if (eEmemType == EMEM_INFO) // Read info block CRC(512Byte-4) from info block
+    {
+        RegSet16BitValue(0x1600, 0xC1FC); // Set start address for info block CRC
+    }
+    
+    // Enable burst mode
+    RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+    RegSetLByteValue(0x160E, 0x01); 
+
+    nRegData1 = RegGet16BitValue(0x1604);
+    nRegData2 = RegGet16BitValue(0x1606);
+
+    nRetVal  = ((nRegData2 >> 8) & 0xFF) << 24;
+    nRetVal |= (nRegData2 & 0xFF) << 16;
+    nRetVal |= ((nRegData1 >> 8) & 0xFF) << 8;
+    nRetVal |= (nRegData1 & 0xFF);
+    
+    DBG(&g_I2cClient->dev, "CRC = 0x%x\n", nRetVal);
+
+    // Clear burst mode
+    RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+    RegSet16BitValue(0x1600, 0x0000); 
+
+    // Clear RIU password
+    RegSet16BitValue(0x161A, 0x0000); 
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;	
+}
+
+static u32 _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(u8 szTmpBuf[], EmemType_e eEmemType) 
+{
+    u32 nRetVal = 0; 
+    
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+    
+    if (szTmpBuf != NULL)
+    {
+        if (eEmemType == EMEM_MAIN) // Read main block CRC(48KB-4) from bin file
+        {
+            nRetVal  = szTmpBuf[0xBFFF] << 24;
+            nRetVal |= szTmpBuf[0xBFFE] << 16;
+            nRetVal |= szTmpBuf[0xBFFD] << 8;
+            nRetVal |= szTmpBuf[0xBFFC];
+        }
+        else if (eEmemType == EMEM_INFO) // Read info block CRC(512Byte-4) from bin file
+        {
+            nRetVal  = szTmpBuf[0xC1FF] << 24;
+            nRetVal |= szTmpBuf[0xC1FE] << 16;
+            nRetVal |= szTmpBuf[0xC1FD] << 8;
+            nRetVal |= szTmpBuf[0xC1FC];
+        }
+    }
+
+    return nRetVal;
+}
+
+static s32 _DrvFwCtrlMsg22xxUpdateFirmwareBySwId(void) 
+{
+    s32 nRetVal = -1;
+    u32 nCrcInfoA = 0, nCrcInfoB = 0, nCrcMainA = 0, nCrcMainB = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    DBG(&g_I2cClient->dev, "_gIsUpdateInfoBlockFirst = %d, g_IsUpdateFirmware = 0x%x\n", _gIsUpdateInfoBlockFirst, g_IsUpdateFirmware);
+
+    _DrvFwCtrlMsg22xxConvertFwDataTwoDimenToOneDimen(g_FwData, _gOneDimenFwData);
+    
+    if (_gIsUpdateInfoBlockFirst == 1)
+    {
+        if ((g_IsUpdateFirmware & 0x10) == 0x10)
+        {
+            _DrvFwCtrlMsg22xxEraseEmem(EMEM_INFO);
+            _DrvFwCtrlMsg22xxProgramEmem(EMEM_INFO);
+ 
+            nCrcInfoA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_INFO);
+            nCrcInfoB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_INFO);
+
+            DBG(&g_I2cClient->dev, "nCrcInfoA = 0x%x, nCrcInfoB = 0x%x\n", nCrcInfoA, nCrcInfoB);
+        
+            if (nCrcInfoA == nCrcInfoB)
+            {
+                _DrvFwCtrlMsg22xxEraseEmem(EMEM_MAIN);
+                _DrvFwCtrlMsg22xxProgramEmem(EMEM_MAIN);
+
+                nCrcMainA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_MAIN);
+                nCrcMainB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_MAIN);
+
+                DBG(&g_I2cClient->dev, "nCrcMainA = 0x%x, nCrcMainB = 0x%x\n", nCrcMainA, nCrcMainB);
+        		
+                if (nCrcMainA == nCrcMainB)
+                {
+                    g_IsUpdateFirmware = 0x00;
+                    nRetVal = 0;
+                }
+                else
+                {
+                    g_IsUpdateFirmware = 0x01;
+                }
+            }
+            else
+            {
+                g_IsUpdateFirmware = 0x11;
+            }
+        }
+        else if ((g_IsUpdateFirmware & 0x01) == 0x01)
+        {
+            _DrvFwCtrlMsg22xxEraseEmem(EMEM_MAIN);
+            _DrvFwCtrlMsg22xxProgramEmem(EMEM_MAIN);
+
+            nCrcMainA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_MAIN);
+            nCrcMainB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_MAIN);
+
+            DBG(&g_I2cClient->dev, "nCrcMainA=0x%x, nCrcMainB=0x%x\n", nCrcMainA, nCrcMainB);
+    		
+            if (nCrcMainA == nCrcMainB)
+            {
+                g_IsUpdateFirmware = 0x00;
+                nRetVal = 0;
+            }
+            else
+            {
+                g_IsUpdateFirmware = 0x01;
+            }
+        }
+    }
+    else //_gIsUpdateInfoBlockFirst == 0
+    {
+        if ((g_IsUpdateFirmware & 0x10) == 0x10)
+        {
+            _DrvFwCtrlMsg22xxEraseEmem(EMEM_MAIN);
+            _DrvFwCtrlMsg22xxProgramEmem(EMEM_MAIN);
+
+            nCrcMainA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_MAIN);
+            nCrcMainB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_MAIN);
+
+            DBG(&g_I2cClient->dev, "nCrcMainA=0x%x, nCrcMainB=0x%x\n", nCrcMainA, nCrcMainB);
+
+            if (nCrcMainA == nCrcMainB)
+            {
+                _DrvFwCtrlMsg22xxEraseEmem(EMEM_INFO);
+                _DrvFwCtrlMsg22xxProgramEmem(EMEM_INFO);
+
+                nCrcInfoA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_INFO);
+                nCrcInfoB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_INFO);
+                
+                DBG(&g_I2cClient->dev, "nCrcInfoA=0x%x, nCrcInfoB=0x%x\n", nCrcInfoA, nCrcInfoB);
+
+                if (nCrcInfoA == nCrcInfoB)
+                {
+                    g_IsUpdateFirmware = 0x00;
+                    nRetVal = 0;
+                }
+                else
+                {
+                    g_IsUpdateFirmware = 0x01;
+                }
+            }
+            else
+            {
+                g_IsUpdateFirmware = 0x11;
+            }
+        }
+        else if ((g_IsUpdateFirmware & 0x01) == 0x01)
+        {
+            _DrvFwCtrlMsg22xxEraseEmem(EMEM_INFO);
+            _DrvFwCtrlMsg22xxProgramEmem(EMEM_INFO);
+
+            nCrcInfoA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_INFO);
+            nCrcInfoB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_INFO);
+
+            DBG(&g_I2cClient->dev, "nCrcInfoA=0x%x, nCrcInfoB=0x%x\n", nCrcInfoA, nCrcInfoB);
+
+            if (nCrcInfoA == nCrcInfoB)
+            {
+                g_IsUpdateFirmware = 0x00;
+                nRetVal = 0;
+            }
+            else
+            {
+                g_IsUpdateFirmware = 0x01;
+            }
+        }    		
+    }
+    
+    return nRetVal;	
+}
+
+void _DrvFwCtrlMsg22xxCheckFirmwareUpdateBySwId(void)
+{
+    u32 nCrcMainA, nCrcInfoA, nCrcMainB, nCrcInfoB;
+    u32 i;
+    u16 nUpdateBinMajor = 0, nUpdateBinMinor = 0;
+    u16 nMajor = 0, nMinor = 0;
+    u8 *pVersion = NULL;
+    Msg22xxSwId_e eSwId = MSG22XX_SW_ID_UNDEFINED;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DBG(&g_I2cClient->dev, "*** g_Msg22xxChipRevision = 0x%x ***\n", g_Msg22xxChipRevision);
+
+    DrvPlatformLyrDisableFingerTouchReport();
+
+    nCrcMainA = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_MAIN);
+    nCrcMainB = _DrvFwCtrlMsg22xxRetrieveFirmwareCrcFromEFlash(EMEM_MAIN);
+
+    nCrcInfoA = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_INFO);
+    nCrcInfoB = _DrvFwCtrlMsg22xxRetrieveFirmwareCrcFromEFlash(EMEM_INFO);
+    
+    _gUpdateFirmwareBySwIdWorkQueue = create_singlethread_workqueue("update_firmware_by_sw_id");
+    INIT_WORK(&_gUpdateFirmwareBySwIdWork, _DrvFwCtrlUpdateFirmwareBySwIdDoWork);
+
+    DBG(&g_I2cClient->dev, "nCrcMainA=0x%x, nCrcInfoA=0x%x, nCrcMainB=0x%x, nCrcInfoB=0x%x\n", nCrcMainA, nCrcInfoA, nCrcMainB, nCrcInfoB);
+               
+    if (nCrcMainA == nCrcMainB && nCrcInfoA == nCrcInfoB) // Case 1. Main Block:OK, Info Block:OK
+    {
+        eSwId = _DrvFwCtrlMsg22xxGetSwId(EMEM_MAIN);
+    		
+        if (eSwId == MSG22XX_SW_ID_XXXX)
+        {
+            nUpdateBinMajor = msg22xx_xxxx_update_bin[0xBFF5]<<8 | msg22xx_xxxx_update_bin[0xBFF4];
+            nUpdateBinMinor = msg22xx_xxxx_update_bin[0xBFF7]<<8 | msg22xx_xxxx_update_bin[0xBFF6];
+        }
+        else if (eSwId == MSG22XX_SW_ID_YYYY)
+        {
+            nUpdateBinMajor = msg22xx_yyyy_update_bin[0xBFF5]<<8 | msg22xx_yyyy_update_bin[0xBFF4];
+            nUpdateBinMinor = msg22xx_yyyy_update_bin[0xBFF7]<<8 | msg22xx_yyyy_update_bin[0xBFF6];
+        }
+        else //eSwId == MSG22XX_SW_ID_UNDEFINED
+        {
+            DBG(&g_I2cClient->dev, "eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+            eSwId = MSG22XX_SW_ID_UNDEFINED;
+            nUpdateBinMajor = 0;
+            nUpdateBinMinor = 0;    		        						
+        }
+    		
+        DrvFwCtrlGetCustomerFirmwareVersion(&nMajor, &nMinor, &pVersion);
+
+        DBG(&g_I2cClient->dev, "eSwId=0x%x, nMajor=%d, nMinor=%d, nUpdateBinMajor=%d, nUpdateBinMinor=%d\n", eSwId, nMajor, nMinor, nUpdateBinMajor, nUpdateBinMinor);
+
+        if (nUpdateBinMinor > nMinor)
+        {
+            if (eSwId == MSG22XX_SW_ID_XXXX)
+            {
+                for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+                {
+                    if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg22xx_xxxx_update_bin[i*1024]), 1024);
+                    }
+                    else // i == 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg22xx_xxxx_update_bin[i*1024]), 512);
+                    }
+                }
+            }
+            else if (eSwId == MSG22XX_SW_ID_YYYY)
+            {
+                for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+                {
+                    if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg22xx_yyyy_update_bin[i*1024]), 1024);
+                    }
+                    else // i == 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg22xx_yyyy_update_bin[i*1024]), 512);
+                    }
+                }
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+                eSwId = MSG22XX_SW_ID_UNDEFINED;
+            }
+
+            if (eSwId < MSG22XX_SW_ID_UNDEFINED && eSwId != 0x0000 && eSwId != 0xFFFF)
+            {
+                g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+                _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+                _gIsUpdateInfoBlockFirst = 1; // Set 1 for indicating main block is complete 
+                g_IsUpdateFirmware = 0x11;
+                queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+                return;
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "The sw id is invalid.\n");
+                DBG(&g_I2cClient->dev, "Go to normal boot up process.\n");
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "The update bin version is older than or equal to the current firmware version on e-flash.\n");
+            DBG(&g_I2cClient->dev, "Go to normal boot up process.\n");
+        }
+    }
+    else if (nCrcMainA == nCrcMainB && nCrcInfoA != nCrcInfoB) // Case 2. Main Block:OK, Info Block:FAIL
+    {
+        eSwId = _DrvFwCtrlMsg22xxGetSwId(EMEM_MAIN);
+    		
+        DBG(&g_I2cClient->dev, "eSwId=0x%x\n", eSwId);
+
+        if (eSwId == MSG22XX_SW_ID_XXXX)
+        {
+            for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+            {
+                if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                {
+                    _DrvFwCtrlStoreFirmwareData(&(msg22xx_xxxx_update_bin[i*1024]), 1024);
+                }
+                else // i == 48
+                {
+                    _DrvFwCtrlStoreFirmwareData(&(msg22xx_xxxx_update_bin[i*1024]), 512);
+                }
+            }
+        }
+        else if (eSwId == MSG22XX_SW_ID_YYYY)
+        {
+            for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+            {
+                if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                {
+                    _DrvFwCtrlStoreFirmwareData(&(msg22xx_yyyy_update_bin[i*1024]), 1024);
+                }
+                else // i == 48
+                {
+                    _DrvFwCtrlStoreFirmwareData(&(msg22xx_yyyy_update_bin[i*1024]), 512);
+                }
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+            eSwId = MSG22XX_SW_ID_UNDEFINED;
+        }
+
+        if (eSwId < MSG22XX_SW_ID_UNDEFINED && eSwId != 0x0000 && eSwId != 0xFFFF)
+        {
+            g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+            _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+            _gIsUpdateInfoBlockFirst = 1; // Set 1 for indicating main block is complete 
+            g_IsUpdateFirmware = 0x11;
+            queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+            return;
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "The sw id is invalid.\n");
+            DBG(&g_I2cClient->dev, "Go to normal boot up process.\n");
+        }
+    }
+    else if (nCrcMainA != nCrcMainB && nCrcInfoA == nCrcInfoB) // Case 3. Main Block:FAIL, Info Block:OK
+    {
+        eSwId = _DrvFwCtrlMsg22xxGetSwId(EMEM_INFO);
+		
+        DBG(&g_I2cClient->dev, "eSwId=0x%x\n", eSwId);
+
+        if (eSwId == MSG22XX_SW_ID_XXXX)
+        {
+            for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+            {
+                if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                {
+                    _DrvFwCtrlStoreFirmwareData(&(msg22xx_xxxx_update_bin[i*1024]), 1024);
+                }
+                else // i == 48
+                {
+                    _DrvFwCtrlStoreFirmwareData(&(msg22xx_xxxx_update_bin[i*1024]), 512);
+                }
+            }
+        }
+        else if (eSwId == MSG22XX_SW_ID_YYYY)
+        {
+            for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+            {
+                if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                {
+                    _DrvFwCtrlStoreFirmwareData(&(msg22xx_yyyy_update_bin[i*1024]), 1024);
+                }
+                else // i == 48
+                {
+                    _DrvFwCtrlStoreFirmwareData(&(msg22xx_yyyy_update_bin[i*1024]), 512);
+                }
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+            eSwId = MSG22XX_SW_ID_UNDEFINED;
+        }
+
+        if (eSwId < MSG22XX_SW_ID_UNDEFINED && eSwId != 0x0000 && eSwId != 0xFFFF)
+        {
+            g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+            _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+            _gIsUpdateInfoBlockFirst = 0; // Set 0 for indicating main block is broken 
+            g_IsUpdateFirmware = 0x11;
+            queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+            return;
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "The sw id is invalid.\n");
+            DBG(&g_I2cClient->dev, "Go to normal boot up process.\n");
+        }
+    }
+    else // Case 4. Main Block:FAIL, Info Block:FAIL
+    {
+        DBG(&g_I2cClient->dev, "Main block and Info block are broken.\n");
+        DBG(&g_I2cClient->dev, "Go to normal boot up process.\n");
+    }
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DrvPlatformLyrEnableFingerTouchReport();
+}
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+
+//-------------------------End of SW ID for MSG22XX----------------------------//
+
+//-------------------------Start of SW ID for MSG21XXA----------------------------//
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+static u32 _DrvFwCtrlMsg21xxaCalculateMainCrcFromEFlash(void) 
+{
+    u32 nRetVal = 0; 
+    u16 nRegData = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop Watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    // cmd
+    RegSet16BitValue(0x3CE4, 0xDF4C); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start MCU
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    mdelay(100);
+
+    // Polling 0x3CE4 is 0x9432
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+//        DBG(&g_I2cClient->dev, "*** reg(0x3C, 0xE4) = 0x%x ***\n", nRegData); // add for debug
+
+    } while (nRegData != 0x9432);
+
+    // Read calculated main block CRC from register
+    nRetVal = RegGet16BitValue(0x3C80);
+    nRetVal = (nRetVal << 16) | RegGet16BitValue(0x3C82);
+        
+    DBG(&g_I2cClient->dev, "Main Block CRC = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;	
+}
+
+static u32 _DrvFwCtrlMsg21xxaRetrieveMainCrcFromMainBlock(void) 
+{
+    u32 nRetVal = 0; 
+    u16 nRegData = 0;
+    u8 szDbBusTxData[5] = {0};
+    u8 szDbBusRxData[4] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    // cmd
+    RegSet16BitValue(0x3CE4, 0xA4AB); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start MCU
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    mdelay(100);
+
+    // Polling 0x3CE4 is 0x5B58
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+    } while (nRegData != 0x5B58);
+
+     // Read main block CRC from main block
+    szDbBusTxData[0] = 0x72;
+    szDbBusTxData[1] = 0x7F;
+    szDbBusTxData[2] = 0xFC;
+    szDbBusTxData[3] = 0x00;
+    szDbBusTxData[4] = 0x04;
+    
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+    IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+    nRetVal = szDbBusRxData[0];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[1];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[2];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[3];
+   
+    DBG(&g_I2cClient->dev, "CRC = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;	
+}
+
+static s32 _DrvFwCtrlMsg21xxaUpdateFirmwareBySwId(u8 szFwData[][1024], EmemType_e eEmemType) 
+{
+    u32 i, j, nCalculateCrcSize;
+    u32 nCrcMain = 0, nCrcMainTp = 0;
+    u32 nCrcInfo = 0, nCrcInfoTp = 0;
+    u32 nCrcTemp = 0;
+    u16 nRegData = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nCrcMain = 0xffffffff;
+    nCrcInfo = 0xffffffff;
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    g_IsUpdateFirmware = 0x01; // Set flag to 0x01 for indicating update firmware is processing
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // erase main
+    _DrvFwCtrlEraseEmemC33(EMEM_MAIN);
+    mdelay(1000);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+
+    // Polling 0x3CE4 is 0x1C70
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0x1C70);
+    }
+
+    switch (eEmemType)
+    {
+        case EMEM_ALL:
+            RegSet16BitValue(0x3CE4, 0xE38F);  // for all blocks
+            break;
+        case EMEM_MAIN:
+            RegSet16BitValue(0x3CE4, 0x7731);  // for main block
+            break;
+        case EMEM_INFO:
+            RegSet16BitValue(0x3CE4, 0x7731);  // for info block
+
+            RegSetLByteValue(0x0FE6, 0x01);
+
+            RegSetLByteValue(0x3CE4, 0xC5); 
+            RegSetLByteValue(0x3CE5, 0x78); 
+
+            RegSetLByteValue(0x1E04, 0x9F);
+            RegSetLByteValue(0x1E05, 0x82);
+
+            RegSetLByteValue(0x0FE6, 0x00);
+            mdelay(100);
+            break;
+    }
+
+    // Polling 0x3CE4 is 0x2F43
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x2F43);
+
+    // Calculate CRC 32
+    DrvCommonCrcInitTable();
+
+    if (eEmemType == EMEM_ALL)
+    {
+        nCalculateCrcSize = MSG21XXA_FIRMWARE_WHOLE_SIZE;
+    }
+    else if (eEmemType == EMEM_MAIN)
+    {
+        nCalculateCrcSize = MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE;
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        nCalculateCrcSize = MSG21XXA_FIRMWARE_INFO_BLOCK_SIZE;
+    }
+    else
+    {
+        nCalculateCrcSize = 0;
+    }
+		
+    for (i = 0; i < nCalculateCrcSize; i ++)
+    {
+        if (eEmemType == EMEM_INFO)
+        {
+            i = 32;
+        }
+
+        if (i < 32)   // emem_main
+        {
+            if (i == 31)
+            {
+                szFwData[i][1014] = 0x5A;
+                szFwData[i][1015] = 0xA5;
+
+                for (j = 0; j < 1016; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+
+                nCrcTemp = nCrcMain;
+                nCrcTemp = nCrcTemp ^ 0xffffffff;
+
+                DBG(&g_I2cClient->dev, "nCrcTemp=%x\n", nCrcTemp); // add for debug
+
+                for (j = 0; j < 4; j ++)
+                {
+                    szFwData[i][1023-j] = ((nCrcTemp>>(8*j)) & 0xFF);
+
+                    DBG(&g_I2cClient->dev, "((nCrcTemp>>(8*%d)) & 0xFF)=%x\n", j, ((nCrcTemp>>(8*j)) & 0xFF)); // add for debug
+                    DBG(&g_I2cClient->dev, "Update main clock crc32 into bin buffer szFwData[%d][%d]=%x\n", i, (1020+j), szFwData[i][1020+j]);
+                }
+            }
+            else
+            {
+                for (j = 0; j < 1024; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+            }
+        }
+        else  // emem_info
+        {
+            for (j = 0; j < 1024; j ++)
+            {
+                nCrcInfo = DrvCommonCrcGetValue(szFwData[i][j], nCrcInfo);
+            }
+            
+            if (eEmemType == EMEM_MAIN)
+            {
+                break;
+            }
+        }
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        for (j = 0; j < 8; j ++)
+        {
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &szFwData[i][j*128], 128);
+        }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        IicWriteData(SLAVE_I2C_ID_DWI2C, szFwData[i], 1024);
+#endif
+
+        // Polling 0x3CE4 is 0xD0BC
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0xD0BC);
+
+        RegSet16BitValue(0x3CE4, 0x2F43);
+    }
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // write file done and check crc
+        RegSet16BitValue(0x3CE4, 0x1380);
+    }
+    mdelay(10);
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // Polling 0x3CE4 is 0x9432
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0x9432);
+    }
+
+    nCrcMain = nCrcMain ^ 0xffffffff;
+    nCrcInfo = nCrcInfo ^ 0xffffffff;
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // CRC Main from TP
+        nCrcMainTp = RegGet16BitValue(0x3C80);
+        nCrcMainTp = (nCrcMainTp << 16) | RegGet16BitValue(0x3C82);
+    }
+
+    if (eEmemType == EMEM_ALL)
+    {
+        // CRC Info from TP
+        nCrcInfoTp = RegGet16BitValue(0x3CA0);
+        nCrcInfoTp = (nCrcInfoTp << 16) | RegGet16BitValue(0x3CA2);
+    }
+
+    DBG(&g_I2cClient->dev, "nCrcMain=0x%x, nCrcInfo=0x%x, nCrcMainTp=0x%x, nCrcInfoTp=0x%x\n", nCrcMain, nCrcInfo, nCrcMainTp, nCrcInfoTp);
+
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+    g_IsUpdateFirmware = 0x00; // Set flag to 0x00 for indicating update firmware is finished
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        if (nCrcMainTp != nCrcMain)
+        {
+            DBG(&g_I2cClient->dev, "Update FAILED\n");
+
+            return -1;
+        }
+    }
+
+    if (eEmemType == EMEM_ALL)
+    {
+        if (nCrcInfoTp != nCrcInfo)
+        {
+            DBG(&g_I2cClient->dev, "Update FAILED\n");
+
+            return -1;
+        }
+    }
+
+    DBG(&g_I2cClient->dev, "Update SUCCESS\n");
+
+    return 0;
+} 
+
+void _DrvFwCtrlMsg21xxaCheckFirmwareUpdateBySwId(void) 
+{
+    u32 nCrcMainA, nCrcMainB;
+    u32 i;
+    u16 nUpdateBinMajor = 0, nUpdateBinMinor = 0;
+    u16 nMajor = 0, nMinor = 0;
+    u8 nIsCompareVersion = 0;
+    u8 *pVersion = NULL; 
+    Msg21xxaSwId_e eMainSwId = MSG21XXA_SW_ID_UNDEFINED, eInfoSwId = MSG21XXA_SW_ID_UNDEFINED, eSwId = MSG21XXA_SW_ID_UNDEFINED;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvPlatformLyrDisableFingerTouchReport();
+
+    nCrcMainA = _DrvFwCtrlMsg21xxaCalculateMainCrcFromEFlash();
+    nCrcMainB = _DrvFwCtrlMsg21xxaRetrieveMainCrcFromMainBlock();
+
+    _gUpdateFirmwareBySwIdWorkQueue = create_singlethread_workqueue("update_firmware_by_sw_id");
+    INIT_WORK(&_gUpdateFirmwareBySwIdWork, _DrvFwCtrlUpdateFirmwareBySwIdDoWork);
+
+    DBG(&g_I2cClient->dev, "nCrcMainA=0x%x, nCrcMainB=0x%x\n", nCrcMainA, nCrcMainB);
+               
+    if (nCrcMainA == nCrcMainB) 
+    {
+        eMainSwId = _DrvFwCtrlMsg21xxaGetSwId(EMEM_MAIN);
+        eInfoSwId = _DrvFwCtrlMsg21xxaGetSwId(EMEM_INFO);
+    		
+        DBG(&g_I2cClient->dev, "Check firmware integrity success\n");
+        DBG(&g_I2cClient->dev, "eMainSwId=0x%x, eInfoSwId=0x%x\n", eMainSwId, eInfoSwId);
+
+        if (eMainSwId == eInfoSwId)
+        {
+        		eSwId = eMainSwId;
+        		nIsCompareVersion = 1;
+        }
+        else
+        {
+        		eSwId = eInfoSwId;
+        		nIsCompareVersion = 0;
+        }
+        
+        if (eSwId == MSG21XXA_SW_ID_XXXX)
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+            nUpdateBinMajor = msg21xxa_xxxx_update_bin[31][0x34F]<<8 | msg21xxa_xxxx_update_bin[31][0x34E];
+            nUpdateBinMinor = msg21xxa_xxxx_update_bin[31][0x351]<<8 | msg21xxa_xxxx_update_bin[31][0x350];
+#else // By one dimensional array
+            nUpdateBinMajor = msg21xxa_xxxx_update_bin[0x7F4F]<<8 | msg21xxa_xxxx_update_bin[0x7F4E];
+            nUpdateBinMinor = msg21xxa_xxxx_update_bin[0x7F51]<<8 | msg21xxa_xxxx_update_bin[0x7F50];
+#endif
+        }
+        else if (eSwId == MSG21XXA_SW_ID_YYYY)
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+            nUpdateBinMajor = msg21xxa_yyyy_update_bin[31][0x34F]<<8 | msg21xxa_yyyy_update_bin[31][0x34E];
+            nUpdateBinMinor = msg21xxa_yyyy_update_bin[31][0x351]<<8 | msg21xxa_yyyy_update_bin[31][0x350];
+#else // By one dimensional array
+            nUpdateBinMajor = msg21xxa_yyyy_update_bin[0x7F4F]<<8 | msg21xxa_yyyy_update_bin[0x7F4E];
+            nUpdateBinMinor = msg21xxa_yyyy_update_bin[0x7F51]<<8 | msg21xxa_yyyy_update_bin[0x7F50];
+#endif
+        }
+        else //eSwId == MSG21XXA_SW_ID_UNDEFINED
+        {
+            DBG(&g_I2cClient->dev, "eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+            eSwId = MSG21XXA_SW_ID_UNDEFINED;
+            nUpdateBinMajor = 0;
+            nUpdateBinMinor = 0;    		        						
+        }
+
+        DrvFwCtrlGetCustomerFirmwareVersion(&nMajor, &nMinor, &pVersion);
+    		        
+        DBG(&g_I2cClient->dev, "eSwId=0x%x, nMajor=%d, nMinor=%d, nUpdateBinMajor=%d, nUpdateBinMinor=%d\n", eSwId, nMajor, nMinor, nUpdateBinMajor, nUpdateBinMinor);
+
+        if ((nUpdateBinMinor > nMinor && nIsCompareVersion == 1) || (nIsCompareVersion == 0))
+        {
+            if (eSwId == MSG21XXA_SW_ID_XXXX)
+            {
+                for (i = 0; i < MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE; i ++)
+                {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                    _DrvFwCtrlStoreFirmwareData(msg21xxa_xxxx_update_bin[i], 1024);
+#else // By one dimensional array
+                    _DrvFwCtrlStoreFirmwareData(&(msg21xxa_xxxx_update_bin[i*1024]), 1024);
+#endif
+                }
+            }
+            else if (eSwId == MSG21XXA_SW_ID_YYYY)
+            {
+                for (i = 0; i < MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE; i ++)
+                {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                    _DrvFwCtrlStoreFirmwareData(msg21xxa_yyyy_update_bin[i], 1024);
+#else // By one dimensional array
+                    _DrvFwCtrlStoreFirmwareData(&(msg21xxa_yyyy_update_bin[i*1024]), 1024);
+#endif
+                }
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+                eSwId = MSG21XXA_SW_ID_UNDEFINED;
+            }
+
+            if (eSwId < MSG21XXA_SW_ID_UNDEFINED && eSwId != 0xFFFF)
+            {
+                g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+                _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+                queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+                return;
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "The sw id is invalid.\n");
+                DBG(&g_I2cClient->dev, "Go to normal boot up process.\n");
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "The update bin version is older than or equal to the current firmware version on e-flash.\n");
+            DBG(&g_I2cClient->dev, "Go to normal boot up process.\n");
+        }
+    }
+    else
+    {
+        eSwId = _DrvFwCtrlMsg21xxaGetSwId(EMEM_INFO);
+    		
+        DBG(&g_I2cClient->dev, "Check firmware integrity failed\n");
+        DBG(&g_I2cClient->dev, "eSwId=0x%x\n", eSwId);
+
+        if (eSwId == MSG21XXA_SW_ID_XXXX)
+        {
+            for (i = 0; i < MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE; i ++)
+            {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                _DrvFwCtrlStoreFirmwareData(msg21xxa_xxxx_update_bin[i], 1024);
+#else // By one dimensional array
+                _DrvFwCtrlStoreFirmwareData(&(msg21xxa_xxxx_update_bin[i*1024]), 1024);
+#endif
+            }
+        }
+        else if (eSwId == MSG21XXA_SW_ID_YYYY)
+        {
+            for (i = 0; i < MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE; i ++)
+            {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                _DrvFwCtrlStoreFirmwareData(msg21xxa_yyyy_update_bin[i], 1024);
+#else // By one dimensional array
+                _DrvFwCtrlStoreFirmwareData(&(msg21xxa_yyyy_update_bin[i*1024]), 1024);
+#endif
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+            eSwId = MSG21XXA_SW_ID_UNDEFINED;
+        }
+
+        if (eSwId < MSG21XXA_SW_ID_UNDEFINED && eSwId != 0xFFFF)
+        {
+            g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+            _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+            queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+            return;
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "The sw id is invalid.\n");
+            DBG(&g_I2cClient->dev, "Go to normal boot up process.\n");
+        }
+    }
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+    DrvPlatformLyrEnableFingerTouchReport();
+}
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+
+//-------------------------End of SW ID for MSG21XXA----------------------------//
+
+//-------------------------Start of SW ID for MSG26XXM----------------------------//
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+static u32 _DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(EmemType_e eEmemType, u8 nIsNeedResetHW)
+{
+    u32 nRetVal = 0; 
+    u16 nRegData = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d, nIsNeedResetHW = %d ***\n", __func__, eEmemType, nIsNeedResetHW);
+
+    if (1 == nIsNeedResetHW)
+    {
+        DrvPlatformLyrTouchDeviceResetHw();
+    }
+    
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    RegSet16BitValue(0x3CE4, 0xDF4C); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start mcu
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    mdelay(100);
+
+    // Polling 0x3CE4 is 0x9432
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+    } while (nRegData != 0x9432);
+
+    if (eEmemType == EMEM_MAIN) // Read calculated main block CRC(32K-8) from register
+    {
+        nRetVal = RegGet16BitValue(0x3C80);
+        nRetVal = (nRetVal << 16) | RegGet16BitValue(0x3C82);
+        
+        DBG(&g_I2cClient->dev, "Main Block CRC = 0x%x\n", nRetVal);
+    }
+    else if (eEmemType == EMEM_INFO) // Read calculated info block CRC(8K) from register
+    {
+        nRetVal = RegGet16BitValue(0x3CA0);
+        nRetVal = (nRetVal << 16) | RegGet16BitValue(0x3CA2);
+
+        DBG(&g_I2cClient->dev, "Info Block CRC = 0x%x\n", nRetVal);
+    }
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;	
+}
+
+static u32 _DrvFwCtrlMsg26xxmRetrieveFirmwareCrcFromMainBlock(EmemType_e eEmemType)
+{
+    u32 nRetVal = 0; 
+    u16 nRegData = 0;
+    u8 szDbBusTxData[5] = {0};
+    u8 szDbBusRxData[4] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    RegSet16BitValue(0x3CE4, 0xA4AB); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start mcu
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    mdelay(100);
+
+    // Polling 0x3CE4 is 0x5B58
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+    } while (nRegData != 0x5B58);
+
+    szDbBusTxData[0] = 0x72;
+    if (eEmemType == EMEM_MAIN) // Read main block CRC(32K-8) from main block
+    {
+        szDbBusTxData[1] = 0x7F;
+        szDbBusTxData[2] = 0xF8;
+    }
+    else if (eEmemType == EMEM_INFO) // Read info block CRC(8K) from main block
+    {
+        szDbBusTxData[1] = 0x7F;
+        szDbBusTxData[2] = 0xFC;
+    }
+    szDbBusTxData[3] = 0x00;
+    szDbBusTxData[4] = 0x04;
+
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+    IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+    /*
+      The order of 4 bytes [ 0 : 1 : 2 : 3 ]
+      Ex. CRC32 = 0x12345678
+          0x7FF8 = 0x78, 0x7FF9 = 0x56,
+          0x7FFA = 0x34, 0x7FFB = 0x12
+    */
+
+    nRetVal = szDbBusRxData[3];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[2];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[1];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[0];
+    
+    DBG(&g_I2cClient->dev, "CRC = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;	
+}
+
+static u32 _DrvFwCtrlMsg26xxmRetrieveInfoCrcFromInfoBlock(void)
+{
+    u32 nRetVal = 0; 
+    u16 nRegData = 0;
+    u8 szDbBusTxData[5] = {0};
+    u8 szDbBusRxData[4] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    RegSet16BitValue(0x3CE4, 0xA4AB); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start mcu
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    mdelay(100);
+
+    // Polling 0x3CE4 is 0x5B58
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+    } while (nRegData != 0x5B58);
+
+
+    // Read info CRC(8K-4) from info block
+    szDbBusTxData[0] = 0x72;
+    szDbBusTxData[1] = 0x80;
+    szDbBusTxData[2] = 0x00;
+    szDbBusTxData[3] = 0x00;
+    szDbBusTxData[4] = 0x04;
+
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+    IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+    nRetVal = szDbBusRxData[3];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[2];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[1];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[0];
+    
+    DBG(&g_I2cClient->dev, "CRC = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+    
+    return nRetVal;	
+}
+
+static u32 _DrvFwCtrlMsg26xxmRetrieveFrimwareCrcFromBinFile(u8 szTmpBuf[][1024], EmemType_e eEmemType)
+{
+    u32 nRetVal = 0; 
+    
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+    
+    if (szTmpBuf != NULL)
+    {
+        if (eEmemType == EMEM_MAIN) // Read main block CRC(32K-8) from bin file
+        {
+            nRetVal = szTmpBuf[31][1019];
+            nRetVal = (nRetVal << 8) | szTmpBuf[31][1018];
+            nRetVal = (nRetVal << 8) | szTmpBuf[31][1017];
+            nRetVal = (nRetVal << 8) | szTmpBuf[31][1016];
+        }
+        else if (eEmemType == EMEM_INFO) // Read info block CRC(8K) from bin file
+        {
+            nRetVal = szTmpBuf[31][1023];
+            nRetVal = (nRetVal << 8) | szTmpBuf[31][1022];
+            nRetVal = (nRetVal << 8) | szTmpBuf[31][1021];
+            nRetVal = (nRetVal << 8) | szTmpBuf[31][1020];
+        }
+    }
+
+    return nRetVal;
+}
+
+static u32 _DrvFwCtrlMsg26xxmCalculateInfoCrcByDeviceDriver(void)
+{
+    u32 nRetVal = 0xffffffff; 
+    u32 i, j;
+    u16 nRegData = 0;
+    u8 szDbBusTxData[5] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    // cmd
+    RegSet16BitValue(0x3CE4, 0xA4AB); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start mcu
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    mdelay(100);
+
+    // Polling 0x3CE4 is 0x5B58
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+    } while (nRegData != 0x5B58);
+
+    DrvCommonCrcInitTable();
+
+    // Read info data(8K) from info block
+    szDbBusTxData[0] = 0x72;
+    szDbBusTxData[3] = 0x00; // read 128 bytes
+    szDbBusTxData[4] = 0x80;
+
+    for (i = 0; i < 8; i ++)
+    {
+        for (j = 0; j < 8; j ++)
+        {
+            szDbBusTxData[1] = 0x80 + (i*0x04) + (((j*128)&0xff00)>>8);
+            szDbBusTxData[2] = (j*128)&0x00ff;
+
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+
+            // Receive info data
+            IicReadData(SLAVE_I2C_ID_DWI2C, &_gTempData[j*128], 128); 
+        }
+     
+        if (i == 0)
+        {
+            for (j = 4; j < 1024; j ++)
+            {
+                nRetVal = DrvCommonCrcGetValue(_gTempData[j], nRetVal);
+            }
+        }
+        else
+        {
+            for (j = 0; j < 1024; j ++)
+            {
+                nRetVal = DrvCommonCrcGetValue(_gTempData[j], nRetVal);
+            }
+        }
+    }
+
+    nRetVal = nRetVal ^ 0xffffffff;
+
+    DBG(&g_I2cClient->dev, "Info(8K-4) CRC = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;	
+}
+
+static s32 _DrvFwCtrlMsg26xxmCompare8BytesForCrc(u8 szTmpBuf[][1024])
+{
+    s32 nRetVal = -1;
+    u16 nRegData = 0;
+    u8 szDbBusTxData[5] = {0};
+    u8 szDbBusRxData[8] = {0};
+    u8 crc[8] = {0}; 
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    // Read 8 bytes from bin file
+    if (szTmpBuf != NULL)
+    {
+        crc[0] = szTmpBuf[31][1016];
+        crc[1] = szTmpBuf[31][1017];
+        crc[2] = szTmpBuf[31][1018];
+        crc[3] = szTmpBuf[31][1019];
+        crc[4] = szTmpBuf[31][1020];
+        crc[5] = szTmpBuf[31][1021];
+        crc[6] = szTmpBuf[31][1022];
+        crc[7] = szTmpBuf[31][1023];
+    }
+
+    // Read 8 bytes from the firmware on e-flash
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    RegSet16BitValue(0x3CE4, 0xA4AB); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start mcu
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    mdelay(100);
+
+    // Polling 0x3CE4 is 0x5B58
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+    } while (nRegData != 0x5B58);
+
+    szDbBusTxData[0] = 0x72;
+    szDbBusTxData[1] = 0x7F;
+    szDbBusTxData[2] = 0xF8;
+    szDbBusTxData[3] = 0x00;
+    szDbBusTxData[4] = 0x08;
+
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+    IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 8);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+    
+    if (crc[0] == szDbBusRxData[0]
+        && crc[1] == szDbBusRxData[1]
+        && crc[2] == szDbBusRxData[2]
+        && crc[3] == szDbBusRxData[3]
+        && crc[4] == szDbBusRxData[4]
+        && crc[5] == szDbBusRxData[5]
+        && crc[6] == szDbBusRxData[6]
+        && crc[7] == szDbBusRxData[7])
+    {
+        nRetVal = 0;		
+    }
+    else
+    {
+        nRetVal = -1;		
+    }
+    
+    DBG(&g_I2cClient->dev, "compare 8bytes for CRC = %d\n", nRetVal);
+
+    return nRetVal;
+}
+
+static void _DrvFwCtrlMsg26xxmEraseFirmwareOnEFlash(EmemType_e eEmemType)
+{
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DBG(&g_I2cClient->dev, "erase 0\n");
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    // cmd
+    RegSet16BitValue(0x3CE4, 0x78C5); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start mcu
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    mdelay(100);
+        
+    DBG(&g_I2cClient->dev, "erase 1\n");
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    // Set PROGRAM password
+    RegSet16BitValue(0x161A, 0xABBA); //bank:emem, addr:h000D
+
+    if (eEmemType == EMEM_INFO)
+    {
+        RegSet16BitValue(0x1600, 0x8000); //bank:emem, addr:h0000
+    }
+
+    // Clear pce
+    RegSetLByteValue(0x1618, 0x80); //bank:emem, addr:h000C
+
+    DBG(&g_I2cClient->dev, "erase 2\n");
+
+    // Clear setting
+    RegSetLByteValue(0x1618, 0x40); //bank:emem, addr:h000C
+    
+    mdelay(10);
+    
+    // Clear pce
+    RegSetLByteValue(0x1618, 0x80); //bank:emem, addr:h000C
+
+    DBG(&g_I2cClient->dev, "erase 3\n");
+
+    // Trigger erase
+    if (eEmemType == EMEM_ALL)
+    {
+        RegSetLByteValue(0x160E, 0x08); //all chip //bank:emem, addr:h0007
+    }
+    else if (eEmemType == EMEM_MAIN || eEmemType == EMEM_INFO)
+    {
+        RegSetLByteValue(0x160E, 0x04); //sector //bank:emem, addr:h0007
+    }
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+    
+    mdelay(200);	
+    
+    DBG(&g_I2cClient->dev, "erase OK\n");
+}
+
+static void _DrvFwCtrlMsg26xxmProgramFirmwareOnEFlash(EmemType_e eEmemType)
+{
+    u32 nStart = 0, nEnd = 0; 
+    u32 i, j; 
+    u16 nRegData = 0;
+//    u16 nRegData2 = 0, nRegData3 = 0; // add for debug
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    DBG(&g_I2cClient->dev, "program 0\n");
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    if (eEmemType == EMEM_INFO || eEmemType == EMEM_MAIN)
+    {
+        // Stop mcu
+        RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+        // Stop watchdog
+        RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+        // cmd
+        RegSet16BitValue(0x3CE4, 0x78C5); //bank:reg_PIU_MISC_0, addr:h0072
+
+        // TP SW reset
+        RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+        RegSet16BitValue(0x1E04, 0x829F);
+        
+        nRegData = RegGet16BitValue(0x1618);
+//        DBG(&g_I2cClient->dev, "*** reg(0x16, 0x18)  = 0x%x ***\n", nRegData); // add for debug
+        
+        nRegData |= 0x40;
+//        DBG(&g_I2cClient->dev, "*** nRegData  = 0x%x ***\n", nRegData); // add for debug
+        
+        RegSetLByteValue(0x1618, nRegData);
+
+        // Start mcu
+        RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+        mdelay(100);
+    }
+
+    DBG(&g_I2cClient->dev, "program 1\n");
+
+    RegSet16BitValue(0x0F52, 0xDB00); // add for analysis
+
+    // Check_Loader_Ready: Polling 0x3CE4 is 0x1C70
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+//        DBG(&g_I2cClient->dev, "*** reg(0x3C, 0xE4) = 0x%x ***\n", nRegData); // add for debug
+
+//        nRegData2 = RegGet16BitValue(0x0F00); // add for debug
+//        DBG(&g_I2cClient->dev, "*** reg(0x0F, 0x00) = 0x%x ***\n", nRegData2);
+
+//        nRegData3 = RegGet16BitValue(0x1E04); // add for debug
+//        DBG(&g_I2cClient->dev, "*** reg(0x1E, 0x04) = 0x%x ***\n", nRegData3);
+
+    } while (nRegData != 0x1C70);
+
+    DBG(&g_I2cClient->dev, "program 2\n");
+
+    if (eEmemType == EMEM_ALL)
+    {
+        RegSet16BitValue(0x3CE4, 0xE38F);  //all chip
+
+        nStart = 0;
+        nEnd = MSG26XXM_FIRMWARE_WHOLE_SIZE; //32K + 8K
+    }
+    else if (eEmemType == EMEM_MAIN)
+    {
+        RegSet16BitValue(0x3CE4, 0x7731);  //main block
+
+        nStart = 0;
+        nEnd = MSG26XXM_FIRMWARE_MAIN_BLOCK_SIZE; //32K
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        RegSet16BitValue(0x3CE4, 0xB9D6);  //info block
+
+        nStart = MSG26XXM_FIRMWARE_MAIN_BLOCK_SIZE;
+        nEnd = MSG26XXM_FIRMWARE_MAIN_BLOCK_SIZE + MSG26XXM_FIRMWARE_INFO_BLOCK_SIZE;
+    }
+
+    // Check_Loader_Ready2Program: Polling 0x3CE4 is 0x2F43
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x2F43);
+
+    DBG(&g_I2cClient->dev, "program 3\n");
+
+    for (i = nStart; i < nEnd; i ++)
+    {
+        for (j = 0; j < 8; j ++)
+        {
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &g_FwData[i][j*128], 128);
+        }
+
+        mdelay(100);
+
+        // Check_Program_Done: Polling 0x3CE4 is 0xD0BC
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0xD0BC);
+
+        // Continue_Program
+        RegSet16BitValue(0x3CE4, 0x2F43);
+    }
+
+    DBG(&g_I2cClient->dev, "program 4\n");
+
+    // Notify_Write_Done
+    RegSet16BitValue(0x3CE4, 0x1380);
+    mdelay(100);
+
+    DBG(&g_I2cClient->dev, "program 5\n");
+
+    // Check_CRC_Done: Polling 0x3CE4 is 0x9432
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x9432);
+
+    DBG(&g_I2cClient->dev, "program 6\n");
+
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    mdelay(300);
+
+    DBG(&g_I2cClient->dev, "program OK\n");
+}
+
+static s32 _DrvFwCtrlMsg26xxmUpdateFirmwareBySwId(void)
+{
+    s32 nRetVal = -1;
+    u32 nCrcInfoA = 0, nCrcInfoB = 0, nCrcMainA = 0, nCrcMainB = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    DBG(&g_I2cClient->dev, "_gIsUpdateInfoBlockFirst = %d, g_IsUpdateFirmware = 0x%x\n", _gIsUpdateInfoBlockFirst, g_IsUpdateFirmware);
+    
+    if (_gIsUpdateInfoBlockFirst == 1)
+    {
+        if ((g_IsUpdateFirmware & 0x10) == 0x10)
+        {
+            _DrvFwCtrlMsg26xxmEraseFirmwareOnEFlash(EMEM_INFO);
+            _DrvFwCtrlMsg26xxmProgramFirmwareOnEFlash(EMEM_INFO);
+ 
+            nCrcInfoA = _DrvFwCtrlMsg26xxmRetrieveFrimwareCrcFromBinFile(g_FwData, EMEM_INFO);
+            nCrcInfoB = _DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(EMEM_INFO, 0);
+
+            DBG(&g_I2cClient->dev, "nCrcInfoA = 0x%x, nCrcInfoB = 0x%x\n", nCrcInfoA, nCrcInfoB);
+        
+            if (nCrcInfoA == nCrcInfoB)
+            {
+                _DrvFwCtrlMsg26xxmEraseFirmwareOnEFlash(EMEM_MAIN);
+                _DrvFwCtrlMsg26xxmProgramFirmwareOnEFlash(EMEM_MAIN);
+
+                nCrcMainA = _DrvFwCtrlMsg26xxmRetrieveFrimwareCrcFromBinFile(g_FwData, EMEM_MAIN);
+                nCrcMainB = _DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(EMEM_MAIN, 0);
+
+                DBG(&g_I2cClient->dev, "nCrcMainA = 0x%x, nCrcMainB = 0x%x\n", nCrcMainA, nCrcMainB);
+        		
+                if (nCrcMainA == nCrcMainB)
+                {
+                    nRetVal = _DrvFwCtrlMsg26xxmCompare8BytesForCrc(g_FwData);
+                    
+                    if (nRetVal == 0)
+                    {
+                        g_IsUpdateFirmware = 0x00;
+                    }
+                    else
+                    {
+                        g_IsUpdateFirmware = 0x11;
+                    }
+                }
+                else
+                {
+                    g_IsUpdateFirmware = 0x01;
+                }
+            }
+            else
+            {
+                g_IsUpdateFirmware = 0x11;
+            }
+        }
+        else if ((g_IsUpdateFirmware & 0x01) == 0x01)
+        {
+            _DrvFwCtrlMsg26xxmEraseFirmwareOnEFlash(EMEM_MAIN);
+            _DrvFwCtrlMsg26xxmProgramFirmwareOnEFlash(EMEM_MAIN);
+
+            nCrcMainA = _DrvFwCtrlMsg26xxmRetrieveFrimwareCrcFromBinFile(g_FwData, EMEM_MAIN);
+            nCrcMainB = _DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(EMEM_MAIN, 0);
+
+            DBG(&g_I2cClient->dev, "nCrcMainA=0x%x, nCrcMainB=0x%x\n", nCrcMainA, nCrcMainB);
+    		
+            if (nCrcMainA == nCrcMainB)
+            {
+                nRetVal = _DrvFwCtrlMsg26xxmCompare8BytesForCrc(g_FwData);
+
+                if (nRetVal == 0)
+                {
+                    g_IsUpdateFirmware = 0x00;
+                }
+                else
+                {
+                    g_IsUpdateFirmware = 0x11;
+                }
+            }
+            else
+            {
+                g_IsUpdateFirmware = 0x01;
+            }
+        }
+    }
+    else //_gIsUpdateInfoBlockFirst == 0
+    {
+        if ((g_IsUpdateFirmware & 0x10) == 0x10)
+        {
+            _DrvFwCtrlMsg26xxmEraseFirmwareOnEFlash(EMEM_MAIN);
+            _DrvFwCtrlMsg26xxmProgramFirmwareOnEFlash(EMEM_MAIN);
+
+            nCrcMainA = _DrvFwCtrlMsg26xxmRetrieveFrimwareCrcFromBinFile(g_FwData, EMEM_MAIN);
+            nCrcMainB = _DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(EMEM_MAIN, 0);
+
+            DBG(&g_I2cClient->dev, "nCrcMainA=0x%x, nCrcMainB=0x%x\n", nCrcMainA, nCrcMainB);
+
+            if (nCrcMainA == nCrcMainB)
+            {
+                _DrvFwCtrlMsg26xxmEraseFirmwareOnEFlash(EMEM_INFO);
+                _DrvFwCtrlMsg26xxmProgramFirmwareOnEFlash(EMEM_INFO);
+
+                nCrcInfoA = _DrvFwCtrlMsg26xxmRetrieveFrimwareCrcFromBinFile(g_FwData, EMEM_INFO);
+                nCrcInfoB = _DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(EMEM_INFO, 0);
+                
+                DBG(&g_I2cClient->dev, "nCrcInfoA=0x%x, nCrcInfoB=0x%x\n", nCrcInfoA, nCrcInfoB);
+
+                if (nCrcInfoA == nCrcInfoB)
+                {
+                    nRetVal = _DrvFwCtrlMsg26xxmCompare8BytesForCrc(g_FwData);
+                    
+                    if (nRetVal == 0)
+                    {
+                        g_IsUpdateFirmware = 0x00;
+                    }
+                    else
+                    {
+                        g_IsUpdateFirmware = 0x11;
+                    }
+                }
+                else
+                {
+                    g_IsUpdateFirmware = 0x01;
+                }
+            }
+            else
+            {
+                g_IsUpdateFirmware = 0x11;
+            }
+        }
+        else if ((g_IsUpdateFirmware & 0x01) == 0x01)
+        {
+            _DrvFwCtrlMsg26xxmEraseFirmwareOnEFlash(EMEM_INFO);
+            _DrvFwCtrlMsg26xxmProgramFirmwareOnEFlash(EMEM_INFO);
+
+            nCrcInfoA = _DrvFwCtrlMsg26xxmRetrieveFrimwareCrcFromBinFile(g_FwData, EMEM_INFO);
+            nCrcInfoB = _DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(EMEM_INFO, 0);
+
+            DBG(&g_I2cClient->dev, "nCrcInfoA=0x%x, nCrcInfoB=0x%x\n", nCrcInfoA, nCrcInfoB);
+
+            if (nCrcInfoA == nCrcInfoB)
+            {
+                nRetVal = _DrvFwCtrlMsg26xxmCompare8BytesForCrc(g_FwData);
+                
+                if (nRetVal == 0)
+                {
+                    g_IsUpdateFirmware = 0x00;
+                }
+                else
+                {
+                    g_IsUpdateFirmware = 0x11;
+                }
+            }
+            else
+            {
+                g_IsUpdateFirmware = 0x01;
+            }
+        }    		
+    }
+    
+    return nRetVal;	
+}
+
+void _DrvFwCtrlMsg26xxmCheckFirmwareUpdateBySwId(void)
+{
+    u32 nCrcMainA, nCrcInfoA, nCrcMainB, nCrcInfoB;
+    u32 i;
+    u16 nUpdateBinMajor = 0, nUpdateBinMinor = 0;
+    u16 nMajor = 0, nMinor = 0;
+    u8 *pVersion = NULL;
+    Msg26xxmSwId_e eSwId = MSG26XXM_SW_ID_UNDEFINED;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvPlatformLyrDisableFingerTouchReport();
+
+    nCrcMainA = _DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(EMEM_MAIN, 1);
+    nCrcMainB = _DrvFwCtrlMsg26xxmRetrieveFirmwareCrcFromMainBlock(EMEM_MAIN);
+
+    nCrcInfoA = _DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(EMEM_INFO, 1);
+    nCrcInfoB = _DrvFwCtrlMsg26xxmRetrieveFirmwareCrcFromMainBlock(EMEM_INFO);
+    
+    _gUpdateFirmwareBySwIdWorkQueue = create_singlethread_workqueue("update_firmware_by_sw_id");
+    INIT_WORK(&_gUpdateFirmwareBySwIdWork, _DrvFwCtrlUpdateFirmwareBySwIdDoWork);
+
+    DBG(&g_I2cClient->dev, "nCrcMainA=0x%x, nCrcInfoA=0x%x, nCrcMainB=0x%x, nCrcInfoB=0x%x\n", nCrcMainA, nCrcInfoA, nCrcMainB, nCrcInfoB);
+               
+    if (nCrcMainA == nCrcMainB && nCrcInfoA == nCrcInfoB) // Case 1. Main Block:OK, Info Block:OK
+    {
+        eSwId = _DrvFwCtrlMsg26xxmGetSwId(EMEM_MAIN);
+
+        DBG(&g_I2cClient->dev, "eSwId=0x%x\n", eSwId);
+    		
+        if (eSwId == MSG26XXM_SW_ID_XXXX)
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+            nUpdateBinMajor = msg26xxm_xxxx_update_bin[0][0x2B]<<8 | msg26xxm_xxxx_update_bin[0][0x2A];
+            nUpdateBinMinor = msg26xxm_xxxx_update_bin[0][0x2D]<<8 | msg26xxm_xxxx_update_bin[0][0x2C];
+#else // By one dimensional array
+            nUpdateBinMajor = msg26xxm_xxxx_update_bin[0x002B]<<8 | msg26xxm_xxxx_update_bin[0x002A];
+            nUpdateBinMinor = msg26xxm_xxxx_update_bin[0x002D]<<8 | msg26xxm_xxxx_update_bin[0x002C];
+#endif
+        }
+        else if (eSwId == MSG26XXM_SW_ID_YYYY)
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+            nUpdateBinMajor = msg26xxm_yyyy_update_bin[0][0x2B]<<8 | msg26xxm_yyyy_update_bin[0][0x2A];
+            nUpdateBinMinor = msg26xxm_yyyy_update_bin[0][0x2D]<<8 | msg26xxm_yyyy_update_bin[0][0x2C];
+#else // By one dimensional array
+            nUpdateBinMajor = msg26xxm_yyyy_update_bin[0x002B]<<8 | msg26xxm_yyyy_update_bin[0x002A];
+            nUpdateBinMinor = msg26xxm_yyyy_update_bin[0x002D]<<8 | msg26xxm_yyyy_update_bin[0x002C];
+#endif
+        }
+        else //eSwId == MSG26XXM_SW_ID_UNDEFINED
+        {
+            DBG(&g_I2cClient->dev, "eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+            eSwId = MSG26XXM_SW_ID_UNDEFINED;
+            nUpdateBinMajor = 0;
+            nUpdateBinMinor = 0;    		        						
+        }
+    		
+        DrvFwCtrlGetCustomerFirmwareVersion(&nMajor, &nMinor, &pVersion);
+
+        DBG(&g_I2cClient->dev, "eSwId=0x%x, nMajor=%d, nMinor=%d, nUpdateBinMajor=%d, nUpdateBinMinor=%d\n", eSwId, nMajor, nMinor, nUpdateBinMajor, nUpdateBinMinor);
+
+        if (nUpdateBinMinor > nMinor)
+        {
+            if (eSwId == MSG26XXM_SW_ID_XXXX)
+            {
+                for (i = 0; i < MSG26XXM_FIRMWARE_WHOLE_SIZE; i ++)
+                {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                    _DrvFwCtrlStoreFirmwareData(msg26xxm_xxxx_update_bin[i], 1024);
+#else // By one dimensional array
+                    _DrvFwCtrlStoreFirmwareData(&(msg26xxm_xxxx_update_bin[i*1024]), 1024);
+#endif
+                }
+            }
+            else if (eSwId == MSG26XXM_SW_ID_YYYY)
+            {
+                for (i = 0; i < MSG26XXM_FIRMWARE_WHOLE_SIZE; i ++)
+                {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                    _DrvFwCtrlStoreFirmwareData(msg26xxm_yyyy_update_bin[i], 1024);
+#else // By one dimensional array
+                    _DrvFwCtrlStoreFirmwareData(&(msg26xxm_yyyy_update_bin[i*1024]), 1024);
+#endif
+                }
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+                eSwId = MSG26XXM_SW_ID_UNDEFINED;
+            }
+
+            if (eSwId < MSG26XXM_SW_ID_UNDEFINED && eSwId != 0x0000 && eSwId != 0xFFFF)
+            {
+                g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+                _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+                _gIsUpdateInfoBlockFirst = 1; // Set 1 for indicating main block is complete 
+                g_IsUpdateFirmware = 0x11;
+                queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+                return;
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "The sw id is invalid.\n");
+                DBG(&g_I2cClient->dev, "Go to normal boot up process.\n");
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "The update bin version is older than or equal to the current firmware version on e-flash.\n");
+            DBG(&g_I2cClient->dev, "Go to normal boot up process.\n");
+        }
+    }
+    else if (nCrcMainA == nCrcMainB && nCrcInfoA != nCrcInfoB) // Case 2. Main Block:OK, Info Block:FAIL
+    {
+        eSwId = _DrvFwCtrlMsg26xxmGetSwId(EMEM_MAIN);
+    		
+        DBG(&g_I2cClient->dev, "eSwId=0x%x\n", eSwId);
+
+        if (eSwId == MSG26XXM_SW_ID_XXXX)
+        {
+            for (i = 0; i < MSG26XXM_FIRMWARE_WHOLE_SIZE; i ++)
+            {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                _DrvFwCtrlStoreFirmwareData(msg26xxm_xxxx_update_bin[i], 1024);
+#else // By one dimensional array
+                _DrvFwCtrlStoreFirmwareData(&(msg26xxm_xxxx_update_bin[i*1024]), 1024);
+#endif
+            }
+        }
+        else if (eSwId == MSG26XXM_SW_ID_YYYY)
+        {
+            for (i = 0; i < MSG26XXM_FIRMWARE_WHOLE_SIZE; i ++)
+            {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                _DrvFwCtrlStoreFirmwareData(msg26xxm_yyyy_update_bin[i], 1024);
+#else // By one dimensional array
+                _DrvFwCtrlStoreFirmwareData(&(msg26xxm_yyyy_update_bin[i*1024]), 1024);
+#endif
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+            eSwId = MSG26XXM_SW_ID_UNDEFINED;
+        }
+
+        if (eSwId < MSG26XXM_SW_ID_UNDEFINED && eSwId != 0x0000 && eSwId != 0xFFFF)
+        {
+            g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+            _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+            _gIsUpdateInfoBlockFirst = 1; // Set 1 for indicating main block is complete 
+            g_IsUpdateFirmware = 0x11;
+            queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+            return;
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "The sw id is invalid.\n");
+            DBG(&g_I2cClient->dev, "Go to normal boot up process.\n");
+        }
+    }
+    else // Case 3. Main Block:FAIL, Info Block:FAIL/OK
+    {
+        nCrcInfoA = _DrvFwCtrlMsg26xxmRetrieveInfoCrcFromInfoBlock();
+        nCrcInfoB = _DrvFwCtrlMsg26xxmCalculateInfoCrcByDeviceDriver();
+        
+        DBG(&g_I2cClient->dev, "8K-4 : nCrcInfoA=0x%x, nCrcInfoB=0x%x\n", nCrcInfoA, nCrcInfoB);
+
+        if (nCrcInfoA == nCrcInfoB) // Check if info block is actually OK.
+        {
+            eSwId = _DrvFwCtrlMsg26xxmGetSwId(EMEM_INFO);
+
+            DBG(&g_I2cClient->dev, "eSwId=0x%x\n", eSwId);
+
+            if (eSwId == MSG26XXM_SW_ID_XXXX)
+            {
+                for (i = 0; i < MSG26XXM_FIRMWARE_WHOLE_SIZE; i ++)
+                {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                    _DrvFwCtrlStoreFirmwareData(msg26xxm_xxxx_update_bin[i], 1024);
+#else // By one dimensional array
+                    _DrvFwCtrlStoreFirmwareData(&(msg26xxm_xxxx_update_bin[i*1024]), 1024);
+#endif
+                }
+            }
+            else if (eSwId == MSG26XXM_SW_ID_YYYY)
+            {
+                for (i = 0; i < MSG26XXM_FIRMWARE_WHOLE_SIZE; i ++)
+                {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                    _DrvFwCtrlStoreFirmwareData(msg26xxm_yyyy_update_bin[i], 1024);
+#else // By one dimensional array
+                    _DrvFwCtrlStoreFirmwareData(&(msg26xxm_yyyy_update_bin[i*1024]), 1024);
+#endif
+                }
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+                eSwId = MSG26XXM_SW_ID_UNDEFINED;
+            }
+
+            if (eSwId < MSG26XXM_SW_ID_UNDEFINED && eSwId != 0x0000 && eSwId != 0xFFFF)
+            {
+                g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+                _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+                _gIsUpdateInfoBlockFirst = 0; // Set 0 for indicating main block is broken 
+                g_IsUpdateFirmware = 0x11;
+                queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+                return;
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "The sw id is invalid.\n");
+                DBG(&g_I2cClient->dev, "Go to normal boot up process.\n");
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "Info block is broken.\n");
+        }
+    }
+
+    DrvPlatformLyrTouchDeviceResetHw(); 
+
+    DrvPlatformLyrEnableFingerTouchReport();
+}
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+
+//-------------------------End of SW ID for MSG26XXM----------------------------//
+
+//-------------------------Start of SW ID for MSG28XX----------------------------//
+
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+/*
+static s32 _DrvFwCtrlMsg28xxUpdateFirmwareBySwId(void) 
+{
+    s32 nRetVal = -1;
+    u32 nCrcInfoA = 0, nCrcInfoB = 0, nCrcMainA = 0, nCrcMainB = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    DBG(&g_I2cClient->dev, "_gIsUpdateInfoBlockFirst = %d, g_IsUpdateFirmware = 0x%x\n", _gIsUpdateInfoBlockFirst, g_IsUpdateFirmware);
+
+    if (_gIsUpdateInfoBlockFirst == 1)
+    {
+        if ((g_IsUpdateFirmware & 0x10) == 0x10)
+        {
+            _DrvFwCtrlMsg28xxEraseEmem(EMEM_INFO);
+            _DrvFwCtrlMsg28xxProgramEmem(EMEM_INFO);
+ 
+            nCrcInfoA = _DrvFwCtrlMsg28xxRetrieveFrimwareCrcFromBinFile(g_FwData, EMEM_INFO);
+            nCrcInfoB = _DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EMEM_INFO);
+
+            DBG(&g_I2cClient->dev, "nCrcInfoA = 0x%x, nCrcInfoB = 0x%x\n", nCrcInfoA, nCrcInfoB);
+        
+            if (nCrcInfoA == nCrcInfoB)
+            {
+                _DrvFwCtrlMsg28xxEraseEmem(EMEM_MAIN);
+                _DrvFwCtrlMsg28xxProgramEmem(EMEM_MAIN);
+
+                nCrcMainA = _DrvFwCtrlMsg28xxRetrieveFrimwareCrcFromBinFile(g_FwData, EMEM_MAIN);
+                nCrcMainB = _DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EMEM_MAIN);
+
+                DBG(&g_I2cClient->dev, "nCrcMainA = 0x%x, nCrcMainB = 0x%x\n", nCrcMainA, nCrcMainB);
+        		
+                if (nCrcMainA == nCrcMainB)
+                {
+                    g_IsUpdateFirmware = 0x00;
+                    nRetVal = 0;
+                }
+                else
+                {
+                    g_IsUpdateFirmware = 0x01;
+                }
+            }
+            else
+            {
+                g_IsUpdateFirmware = 0x11;
+            }
+        }
+        else if ((g_IsUpdateFirmware & 0x01) == 0x01)
+        {
+            _DrvFwCtrlMsg28xxEraseEmem(EMEM_MAIN);
+            _DrvFwCtrlMsg28xxProgramEmem(EMEM_MAIN);
+
+            nCrcMainA = _DrvFwCtrlMsg28xxRetrieveFrimwareCrcFromBinFile(g_FwData, EMEM_MAIN);
+            nCrcMainB = _DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EMEM_MAIN);
+
+            DBG(&g_I2cClient->dev, "nCrcMainA=0x%x, nCrcMainB=0x%x\n", nCrcMainA, nCrcMainB);
+    		
+            if (nCrcMainA == nCrcMainB)
+            {
+                g_IsUpdateFirmware = 0x00;
+                nRetVal = 0;
+            }
+            else
+            {
+                g_IsUpdateFirmware = 0x01;
+            }
+        }
+    }
+    else //_gIsUpdateInfoBlockFirst == 0
+    {
+        if ((g_IsUpdateFirmware & 0x10) == 0x10)
+        {
+            _DrvFwCtrlMsg28xxEraseEmem(EMEM_MAIN);
+            _DrvFwCtrlMsg28xxProgramEmem(EMEM_MAIN);
+
+            nCrcMainA = _DrvFwCtrlMsg28xxRetrieveFrimwareCrcFromBinFile(g_FwData, EMEM_MAIN);
+            nCrcMainB = _DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EMEM_MAIN);
+
+            DBG(&g_I2cClient->dev, "nCrcMainA=0x%x, nCrcMainB=0x%x\n", nCrcMainA, nCrcMainB);
+
+            if (nCrcMainA == nCrcMainB)
+            {
+                _DrvFwCtrlMsg28xxEraseEmem(EMEM_INFO);
+                _DrvFwCtrlMsg28xxProgramEmem(EMEM_INFO);
+
+                nCrcInfoA = _DrvFwCtrlMsg28xxRetrieveFrimwareCrcFromBinFile(g_FwData, EMEM_INFO);
+                nCrcInfoB = _DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EMEM_INFO);
+                
+                DBG(&g_I2cClient->dev, "nCrcInfoA=0x%x, nCrcInfoB=0x%x\n", nCrcInfoA, nCrcInfoB);
+
+                if (nCrcInfoA == nCrcInfoB)
+                {
+                    g_IsUpdateFirmware = 0x00;
+                    nRetVal = 0;
+                }
+                else
+                {
+                    g_IsUpdateFirmware = 0x01;
+                }
+            }
+            else
+            {
+                g_IsUpdateFirmware = 0x11;
+            }
+        }
+        else if ((g_IsUpdateFirmware & 0x01) == 0x01)
+        {
+            _DrvFwCtrlMsg28xxEraseEmem(EMEM_INFO);
+            _DrvFwCtrlMsg28xxProgramEmem(EMEM_INFO);
+
+            nCrcInfoA = _DrvFwCtrlMsg28xxRetrieveFrimwareCrcFromBinFile(g_FwData, EMEM_INFO);
+            nCrcInfoB = _DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EMEM_INFO);
+
+            DBG(&g_I2cClient->dev, "nCrcInfoA=0x%x, nCrcInfoB=0x%x\n", nCrcInfoA, nCrcInfoB);
+
+            if (nCrcInfoA == nCrcInfoB)
+            {
+                g_IsUpdateFirmware = 0x00;
+                nRetVal = 0;
+            }
+            else
+            {
+                g_IsUpdateFirmware = 0x01;
+            }
+        }    		
+    }
+    
+    return nRetVal;	
+}
+*/
+
+void _DrvFwCtrlMsg28xxCheckFirmwareUpdateBySwId(void) 
+{
+    u32 nCrcMainA, nCrcMainB;
+    u32 i;
+    u16 nUpdateBinMajor = 0, nUpdateBinMinor = 0;
+    u16 nMajor = 0, nMinor = 0;
+    u8 *pVersion = NULL;
+    Msg28xxSwId_e eMainSwId = MSG28XX_SW_ID_UNDEFINED, eSwId = MSG28XX_SW_ID_UNDEFINED;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DrvPlatformLyrDisableFingerTouchReport();
+
+    nCrcMainA = _DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EMEM_MAIN);
+    nCrcMainB = _DrvFwCtrlMsg28xxRetrieveFirmwareCrcFromEFlash(EMEM_MAIN);
+
+    DBG(&g_I2cClient->dev, "nCrcMainA=0x%x, nCrcMainB=0x%x\n", nCrcMainA, nCrcMainB);
+
+#ifdef CONFIG_ENABLE_CODE_FOR_DEBUG  // TODO : add for debug 
+    if (nCrcMainA != nCrcMainB) 
+    {
+        for (i = 0; i < 5; i ++)
+        {
+            nCrcMainA = _DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EMEM_MAIN);
+            nCrcMainB = _DrvFwCtrlMsg28xxRetrieveFirmwareCrcFromEFlash(EMEM_MAIN);
+    
+            DBG(&g_I2cClient->dev, "*** Retry[%d] : nCrcMainA=0x%x, nCrcMainB=0x%x ***\n", i, nCrcMainA, nCrcMainB);
+
+            if (nCrcMainA == nCrcMainB)
+            {
+                break;            
+            }
+
+            mdelay(50);
+        }
+    }
+#endif //CONFIG_ENABLE_CODE_FOR_DEBUG
+
+    _gUpdateFirmwareBySwIdWorkQueue = create_singlethread_workqueue("update_firmware_by_sw_id");
+    INIT_WORK(&_gUpdateFirmwareBySwIdWork, _DrvFwCtrlUpdateFirmwareBySwIdDoWork);
+
+    if (nCrcMainA == nCrcMainB) 
+    {
+        eMainSwId = _DrvFwCtrlMsg28xxGetSwId(EMEM_MAIN);
+    		
+        DBG(&g_I2cClient->dev, "eMainSwId=0x%x\n", eMainSwId);
+
+        eSwId = eMainSwId;
+
+        if (eSwId == MSG28XX_SW_ID_XXXX)
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+            nUpdateBinMajor = msg28xx_xxxx_update_bin[127][1013]<<8 | msg28xx_xxxx_update_bin[127][1012]; 
+            nUpdateBinMinor = msg28xx_xxxx_update_bin[127][1015]<<8 | msg28xx_xxxx_update_bin[127][1014];
+#else // By one dimensional array
+            nUpdateBinMajor = msg28xx_xxxx_update_bin[0x1FFF5]<<8 | msg28xx_xxxx_update_bin[0x1FFF4];
+            nUpdateBinMinor = msg28xx_xxxx_update_bin[0x1FFF7]<<8 | msg28xx_xxxx_update_bin[0x1FFF6];
+#endif
+        }
+        else if (eSwId == MSG28XX_SW_ID_YYYY)
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+            nUpdateBinMajor = msg28xx_yyyy_update_bin[127][1013]<<8 | msg28xx_yyyy_update_bin[127][1012]; 
+            nUpdateBinMinor = msg28xx_yyyy_update_bin[127][1015]<<8 | msg28xx_yyyy_update_bin[127][1014];
+#else // By one dimensional array
+            nUpdateBinMajor = msg28xx_yyyy_update_bin[0x1FFF5]<<8 | msg28xx_yyyy_update_bin[0x1FFF4];
+            nUpdateBinMinor = msg28xx_yyyy_update_bin[0x1FFF7]<<8 | msg28xx_yyyy_update_bin[0x1FFF6];
+#endif
+        }
+        else //eSwId == MSG28XX_SW_ID_UNDEFINED
+        {
+            DBG(&g_I2cClient->dev, "eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+            eSwId = MSG28XX_SW_ID_UNDEFINED;
+            nUpdateBinMajor = 0;
+            nUpdateBinMinor = 0;    		        						
+        }
+
+        DrvFwCtrlGetCustomerFirmwareVersionByDbBus(EMEM_MAIN, &nMajor, &nMinor, &pVersion);
+
+        DBG(&g_I2cClient->dev, "eSwId=0x%x, nMajor=%d, nMinor=%d, nUpdateBinMajor=%d, nUpdateBinMinor=%d\n", eSwId, nMajor, nMinor, nUpdateBinMajor, nUpdateBinMinor);
+
+        if (nUpdateBinMinor > nMinor)
+        {
+            if (eSwId == MSG28XX_SW_ID_XXXX)
+            {
+                for (i = 0; i < MSG28XX_FIRMWARE_WHOLE_SIZE; i ++)
+                {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                    _DrvFwCtrlStoreFirmwareData(msg28xx_xxxx_update_bin[i], 1024);
+#else // By one dimensional array
+                    _DrvFwCtrlStoreFirmwareData(&(msg28xx_xxxx_update_bin[i*1024]), 1024);
+#endif
+                }
+            }
+            else if (eSwId == MSG28XX_SW_ID_YYYY)
+            {
+                for (i = 0; i < MSG28XX_FIRMWARE_WHOLE_SIZE; i ++)
+                {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                    _DrvFwCtrlStoreFirmwareData(msg28xx_yyyy_update_bin[i], 1024);
+#else // By one dimensional array
+                    _DrvFwCtrlStoreFirmwareData(&(msg28xx_yyyy_update_bin[i*1024]), 1024);
+#endif
+                }
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+                eSwId = MSG28XX_SW_ID_UNDEFINED;
+            }
+
+            if (eSwId < MSG28XX_SW_ID_UNDEFINED && eSwId != 0x0000 && eSwId != 0xFFFF)
+            {
+                g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+                _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+                _gIsUpdateInfoBlockFirst = 1; // Set 1 for indicating main block is complete 
+                g_IsUpdateFirmware = 0x11;
+                queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+                return;
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "The sw id is invalid.\n");
+                DBG(&g_I2cClient->dev, "Go to normal boot up process.\n");
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "The update bin version is older than or equal to the current firmware version on e-flash.\n");
+            DBG(&g_I2cClient->dev, "Go to normal boot up process.\n");
+        }
+    }
+    else 
+    {
+        eSwId = _DrvFwCtrlMsg28xxGetSwId(EMEM_INFO);
+		
+        DBG(&g_I2cClient->dev, "eSwId=0x%x\n", eSwId);
+
+        if (eSwId == MSG28XX_SW_ID_XXXX)
+        {
+            for (i = 0; i < MSG28XX_FIRMWARE_WHOLE_SIZE; i ++)
+            {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                _DrvFwCtrlStoreFirmwareData(msg28xx_xxxx_update_bin[i], 1024);
+#else // By one dimensional array
+                _DrvFwCtrlStoreFirmwareData(&(msg28xx_xxxx_update_bin[i*1024]), 1024);
+#endif
+            }
+        }
+        else if (eSwId == MSG28XX_SW_ID_YYYY)
+        {
+            for (i = 0; i < MSG28XX_FIRMWARE_WHOLE_SIZE; i ++)
+            {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                _DrvFwCtrlStoreFirmwareData(msg28xx_yyyy_update_bin[i], 1024);
+#else // By one dimensional array
+                _DrvFwCtrlStoreFirmwareData(&(msg28xx_yyyy_update_bin[i*1024]), 1024);
+#endif
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+            eSwId = MSG28XX_SW_ID_UNDEFINED;
+        }
+
+        if (eSwId < MSG28XX_SW_ID_UNDEFINED && eSwId != 0x0000 && eSwId != 0xFFFF)
+        {
+            g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+            _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+            _gIsUpdateInfoBlockFirst = 0; // Set 0 for indicating main block is broken 
+            g_IsUpdateFirmware = 0x11;
+            queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+            return;
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "The sw id is invalid.\n");
+            DBG(&g_I2cClient->dev, "Go to normal boot up process.\n");
+        }
+    }
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DrvPlatformLyrEnableFingerTouchReport();
+}
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+
+//-------------------------End of SW ID for MSG28XX----------------------------//
+
+static void _DrvFwCtrlUpdateFirmwareBySwIdDoWork(struct work_struct *pWork)
+{
+    s32 nRetVal = -1;
+    
+    DBG(&g_I2cClient->dev, "*** %s() _gUpdateRetryCount = %d ***\n", __func__, _gUpdateRetryCount);
+
+    if (g_ChipType == CHIP_TYPE_MSG21XXA)   
+    {
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+        nRetVal = _DrvFwCtrlMsg21xxaUpdateFirmwareBySwId(g_FwData, EMEM_MAIN);
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG22XX)    
+    {
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+        _DrvFwCtrlMsg22xxGetTpVendorCode(_gTpVendorCode);
+        
+        if (_gTpVendorCode[0] == 'C' && _gTpVendorCode[1] == 'N' && _gTpVendorCode[2] == 'T') // for specific TP vendor which store some important information in info block, only update firmware for main block, do not update firmware for info block.
+        {
+            nRetVal = _DrvFwCtrlMsg22xxUpdateFirmware(g_FwData, EMEM_MAIN);
+        }
+        else
+        {
+            nRetVal = _DrvFwCtrlMsg22xxUpdateFirmwareBySwId();
+        }
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG26XXM)   
+    {
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+        nRetVal = _DrvFwCtrlMsg26xxmUpdateFirmwareBySwId();
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG28XX)    
+    {
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+        nRetVal = _DrvFwCtrlMsg28xxUpdateFirmware(g_FwData, EMEM_MAIN);
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "This chip type (0x%x) does not support update firmware by sw id\n", g_ChipType);
+
+        DrvPlatformLyrTouchDeviceResetHw(); 
+
+        DrvPlatformLyrEnableFingerTouchReport();
+
+        nRetVal = -1;
+        return;
+    }
+    
+    DBG(&g_I2cClient->dev, "*** update firmware by sw id result = %d ***\n", nRetVal);
+    
+    if (nRetVal == 0)
+    {
+        DBG(&g_I2cClient->dev, "update firmware by sw id success\n");
+
+        DrvPlatformLyrTouchDeviceResetHw();
+
+        DrvPlatformLyrEnableFingerTouchReport();
+
+        if (g_ChipType == CHIP_TYPE_MSG22XX || g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)    
+        {
+            _gIsUpdateInfoBlockFirst = 0;
+            g_IsUpdateFirmware = 0x00;
+        }
+    }
+    else //nRetVal == -1
+    {
+        _gUpdateRetryCount --;
+        if (_gUpdateRetryCount > 0)
+        {
+            DBG(&g_I2cClient->dev, "_gUpdateRetryCount = %d\n", _gUpdateRetryCount);
+            queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "update firmware by sw id failed\n");
+
+            DrvPlatformLyrTouchDeviceResetHw();
+
+            DrvPlatformLyrEnableFingerTouchReport();
+
+            if (g_ChipType == CHIP_TYPE_MSG22XX || g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)    
+            {
+                _gIsUpdateInfoBlockFirst = 0;
+                g_IsUpdateFirmware = 0x00;
+            }
+        }
+    }
+}
+
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+//------------------------------------------------------------------------------//
+
+#ifndef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+static void _DrvFwCtrlEraseEmemC32(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    /////////////////////////
+    //Erase  all
+    /////////////////////////
+    
+    // Enter gpio mode
+    RegSet16BitValue(0x161E, 0xBEAF);
+
+    // Before gpio mode, set the control pin as the orginal status
+    RegSet16BitValue(0x1608, 0x0000);
+    RegSetLByteValue(0x160E, 0x10);
+    mdelay(10); 
+
+    // ptrim = 1, h'04[2]
+    RegSetLByteValue(0x1608, 0x04);
+    RegSetLByteValue(0x160E, 0x10);
+    mdelay(10); 
+
+    // ptm = 6, h'04[12:14] = b'110
+    RegSetLByteValue(0x1609, 0x60);
+    RegSetLByteValue(0x160E, 0x10);
+
+    // pmasi = 1, h'04[6]
+    RegSetLByteValue(0x1608, 0x44);
+    // pce = 1, h'04[11]
+    RegSetLByteValue(0x1609, 0x68);
+    // perase = 1, h'04[7]
+    RegSetLByteValue(0x1608, 0xC4);
+    // pnvstr = 1, h'04[5]
+    RegSetLByteValue(0x1608, 0xE4);
+    // pwe = 1, h'04[9]
+    RegSetLByteValue(0x1609, 0x6A);
+    // trigger gpio load
+    RegSetLByteValue(0x160E, 0x10);
+}
+
+static void _DrvFwCtrlReadInfoC33(void)
+{
+    u8 szDbBusTxData[5] = {0};
+    u16 nRegData = 0;
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    u32 i;
+#endif 
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    mdelay(300);
+
+    // Stop Watchdog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    RegSet16BitValue(0x3CE4, 0xA4AB);
+
+    RegSet16BitValue(0x1E04, 0x7d60);
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x829F);
+    mdelay(1);
+    
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x0F;
+    szDbBusTxData[2] = 0xE6;
+    szDbBusTxData[3] = 0x00;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, szDbBusTxData, 4);    
+    mdelay(100);
+
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x5B58);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    szDbBusTxData[0] = 0x72;
+    szDbBusTxData[3] = 0x00;
+    szDbBusTxData[4] = 0x80; // read 128 bytes
+
+    for (i = 0; i < 8; i ++)
+    {
+        szDbBusTxData[1] = 0x80 + (((i*128)&0xff00)>>8);
+        szDbBusTxData[2] = (i*128)&0x00ff;
+
+        IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+
+        mdelay(50);
+
+        // Receive info data
+        IicReadData(SLAVE_I2C_ID_DWI2C, &_gDwIicInfoData[i*128], 128);
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+    szDbBusTxData[0] = 0x72;
+    szDbBusTxData[1] = 0x80;
+    szDbBusTxData[2] = 0x00;
+    szDbBusTxData[3] = 0x04; // read 1024 bytes
+    szDbBusTxData[4] = 0x00;
+    
+    IicWriteData(SLAVE_I2C_ID_DWI2C, szDbBusTxData, 5);
+
+    mdelay(50);
+
+    // Receive info data
+    IicReadData(SLAVE_I2C_ID_DWI2C, &_gDwIicInfoData[0], 1024);
+#endif
+}
+
+static s32 _DrvFwCtrlUpdateFirmwareC32(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+    u32 i, j;
+    u32 nCrcMain, nCrcMainTp;
+    u32 nCrcInfo, nCrcInfoTp;
+    u32 nCrcTemp;
+    u16 nRegData = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nCrcMain = 0xffffffff;
+    nCrcInfo = 0xffffffff;
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    g_IsUpdateFirmware = 0x01; // Set flag to 0x01 for indicating update firmware is processing
+
+    /////////////////////////
+    // Erase  all
+    /////////////////////////
+    _DrvFwCtrlEraseEmemC32();
+    mdelay(1000); 
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Reset watch dog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+
+    // Polling 0x3CE4 is 0x1C70
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x1C70);
+
+    RegSet16BitValue(0x3CE4, 0xE38F);  // for all-blocks
+
+    // Polling 0x3CE4 is 0x2F43
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x2F43);
+
+    // Calculate CRC 32
+    DrvCommonCrcInitTable();
+
+    for (i = 0; i < 33; i ++) // total  33 KB : 2 byte per R/W
+    {
+        if (i < 32)   // emem_main
+        {
+            if (i == 31)
+            {
+                szFwData[i][1014] = 0x5A;
+                szFwData[i][1015] = 0xA5;
+
+                for (j = 0; j < 1016; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+
+                nCrcTemp = nCrcMain;
+                nCrcTemp = nCrcTemp ^ 0xffffffff;
+
+                DBG(&g_I2cClient->dev, "nCrcTemp=%x\n", nCrcTemp); // add for debug
+
+                for (j = 0; j < 4; j ++)
+                {
+                    szFwData[i][1023-j] = ((nCrcTemp>>(8*j)) & 0xFF);
+
+                    DBG(&g_I2cClient->dev, "((nCrcTemp>>(8*%d)) & 0xFF)=%x\n", j, ((nCrcTemp>>(8*j)) & 0xFF)); // add for debug
+                    DBG(&g_I2cClient->dev, "Update main clock crc32 into bin buffer szFwData[%d][%d]=%x\n", i, (1020+j), szFwData[i][1020+j]);
+                }
+            }
+            else
+            {
+                for (j = 0; j < 1024; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+            }
+        }
+        else  // emem_info
+        {
+            for (j = 0; j < 1024; j ++)
+            {
+                nCrcInfo = DrvCommonCrcGetValue(szFwData[i][j], nCrcInfo);
+            }
+        }
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        for (j = 0; j < 8; j ++)
+        {
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &szFwData[i][j*128], 128);
+        }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        IicWriteData(SLAVE_I2C_ID_DWI2C, szFwData[i], 1024);
+#endif
+
+        // Polling 0x3CE4 is 0xD0BC
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0xD0BC);
+
+        RegSet16BitValue(0x3CE4, 0x2F43);
+    }
+
+    // Write file done
+    RegSet16BitValue(0x3CE4, 0x1380);
+
+    mdelay(10); 
+    // Polling 0x3CE4 is 0x9432
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x9432);
+
+    nCrcMain = nCrcMain ^ 0xffffffff;
+    nCrcInfo = nCrcInfo ^ 0xffffffff;
+
+    // CRC Main from TP
+    nCrcMainTp = RegGet16BitValue(0x3C80);
+    nCrcMainTp = (nCrcMainTp << 16) | RegGet16BitValue(0x3C82);
+ 
+    // CRC Info from TP
+    nCrcInfoTp = RegGet16BitValue(0x3CA0);
+    nCrcInfoTp = (nCrcInfoTp << 16) | RegGet16BitValue(0x3CA2);
+
+    DBG(&g_I2cClient->dev, "nCrcMain=0x%x, nCrcInfo=0x%x, nCrcMainTp=0x%x, nCrcInfoTp=0x%x\n",
+               nCrcMain, nCrcInfo, nCrcMainTp, nCrcInfoTp);
+
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    g_IsUpdateFirmware = 0x00; // Set flag to 0x00 for indicating update firmware is finished
+
+    if ((nCrcMainTp != nCrcMain) || (nCrcInfoTp != nCrcInfo))
+    {
+        DBG(&g_I2cClient->dev, "Update FAILED\n");
+
+        return -1;
+    }
+
+    DBG(&g_I2cClient->dev, "Update SUCCESS\n");
+
+    return 0;
+}
+
+static s32 _DrvFwCtrlUpdateFirmwareC33(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+    u8 szLifeCounter[2];
+    u32 i, j;
+    u32 nCrcMain, nCrcMainTp;
+    u32 nCrcInfo, nCrcInfoTp;
+    u32 nCrcTemp;
+    u16 nRegData = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    nCrcMain = 0xffffffff;
+    nCrcInfo = 0xffffffff;
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    g_IsUpdateFirmware = 0x01; // Set flag to 0x01 for indicating update firmware is processing
+
+    _DrvFwCtrlReadInfoC33();
+
+    if (_gDwIicInfoData[0] == 'M' && _gDwIicInfoData[1] == 'S' && _gDwIicInfoData[2] == 'T' && _gDwIicInfoData[3] == 'A' && _gDwIicInfoData[4] == 'R' && _gDwIicInfoData[5] == 'T' && _gDwIicInfoData[6] == 'P' && _gDwIicInfoData[7] == 'C')
+    {
+        _gDwIicInfoData[8] = szFwData[32][8];
+        _gDwIicInfoData[9] = szFwData[32][9];
+        _gDwIicInfoData[10] = szFwData[32][10];
+        _gDwIicInfoData[11] = szFwData[32][11];
+        // updata life counter
+        szLifeCounter[1] = ((((_gDwIicInfoData[13] << 8) | _gDwIicInfoData[12]) + 1) >> 8) & 0xFF;
+        szLifeCounter[0] = (((_gDwIicInfoData[13] << 8) | _gDwIicInfoData[12]) + 1) & 0xFF;
+        _gDwIicInfoData[12] = szLifeCounter[0];
+        _gDwIicInfoData[13] = szLifeCounter[1];
+        
+        RegSet16BitValue(0x3CE4, 0x78C5);
+        RegSet16BitValue(0x1E04, 0x7d60);
+        // TP SW reset
+        RegSet16BitValue(0x1E04, 0x829F);
+
+        mdelay(50);
+
+        // Polling 0x3CE4 is 0x2F43
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0x2F43);
+
+        // Transmit lk info data
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        for (j = 0; j < 8; j ++)
+        {
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &_gDwIicInfoData[j*128], 128);
+        }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        IicWriteData(SLAVE_I2C_ID_DWI2C, &_gDwIicInfoData[0], 1024);
+#endif
+
+        // Polling 0x3CE4 is 0xD0BC
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0xD0BC);
+    }
+
+    // erase main
+    _DrvFwCtrlEraseEmemC33(EMEM_MAIN);
+    mdelay(1000);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+
+    // Polling 0x3CE4 is 0x1C70
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0x1C70);
+    }
+
+    switch (eEmemType)
+    {
+        case EMEM_ALL:
+            RegSet16BitValue(0x3CE4, 0xE38F);  // for all blocks
+            break;
+        case EMEM_MAIN:
+            RegSet16BitValue(0x3CE4, 0x7731);  // for main block
+            break;
+        case EMEM_INFO:
+            RegSet16BitValue(0x3CE4, 0x7731);  // for info block
+
+            RegSetLByteValue(0x0FE6, 0x01);
+
+            RegSetLByteValue(0x3CE4, 0xC5); 
+            RegSetLByteValue(0x3CE5, 0x78); 
+
+            RegSetLByteValue(0x1E04, 0x9F);
+            RegSetLByteValue(0x1E05, 0x82);
+
+            RegSetLByteValue(0x0FE6, 0x00);
+            mdelay(100);
+            break;
+    }
+
+    // Polling 0x3CE4 is 0x2F43
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x2F43);
+
+    // Calculate CRC 32
+    DrvCommonCrcInitTable();
+
+    for (i = 0; i < 33; i ++) // total 33 KB : 2 byte per R/W
+    {
+        if (eEmemType == EMEM_INFO)
+        {
+            i = 32;
+        }
+
+        if (i < 32)   // emem_main
+        {
+            if (i == 31)
+            {
+                szFwData[i][1014] = 0x5A;
+                szFwData[i][1015] = 0xA5;
+
+                for (j = 0; j < 1016; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+
+                nCrcTemp = nCrcMain;
+                nCrcTemp = nCrcTemp ^ 0xffffffff;
+
+                DBG(&g_I2cClient->dev, "nCrcTemp=%x\n", nCrcTemp); // add for debug
+
+                for (j = 0; j < 4; j ++)
+                {
+                    szFwData[i][1023-j] = ((nCrcTemp>>(8*j)) & 0xFF);
+
+                    DBG(&g_I2cClient->dev, "((nCrcTemp>>(8*%d)) & 0xFF)=%x\n", j, ((nCrcTemp>>(8*j)) & 0xFF)); // add for debug
+                    DBG(&g_I2cClient->dev, "Update main clock crc32 into bin buffer szFwData[%d][%d]=%x\n", i, (1020+j), szFwData[i][1020+j]); // add for debug
+                }
+            }
+            else
+            {
+                for (j = 0; j < 1024; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+            }
+        }
+        else  // emem_info
+        {
+            for (j = 0; j < 1024; j ++)
+            {
+                nCrcInfo = DrvCommonCrcGetValue(_gDwIicInfoData[j], nCrcInfo);
+            }
+            
+            if (eEmemType == EMEM_MAIN)
+            {
+                break;
+            }
+        }
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        for (j = 0; j < 8; j ++)
+        {
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &szFwData[i][j*128], 128);
+        }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        IicWriteData(SLAVE_I2C_ID_DWI2C, szFwData[i], 1024);
+#endif
+
+        // Polling 0x3CE4 is 0xD0BC
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0xD0BC);
+
+        RegSet16BitValue(0x3CE4, 0x2F43);
+    }
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // write file done and check crc
+        RegSet16BitValue(0x3CE4, 0x1380);
+    }
+    mdelay(10);
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // Polling 0x3CE4 is 0x9432
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0x9432);
+    }
+
+    nCrcMain = nCrcMain ^ 0xffffffff;
+    nCrcInfo = nCrcInfo ^ 0xffffffff;
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // CRC Main from TP
+        nCrcMainTp = RegGet16BitValue(0x3C80);
+        nCrcMainTp = (nCrcMainTp << 16) | RegGet16BitValue(0x3C82);
+
+        // CRC Info from TP
+        nCrcInfoTp = RegGet16BitValue(0x3CA0);
+        nCrcInfoTp = (nCrcInfoTp << 16) | RegGet16BitValue(0x3CA2);
+    }
+    DBG(&g_I2cClient->dev, "nCrcMain=0x%x, nCrcInfo=0x%x, nCrcMainTp=0x%x, nCrcInfoTp=0x%x\n", nCrcMain, nCrcInfo, nCrcMainTp, nCrcInfoTp);
+
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    g_IsUpdateFirmware = 0x00; // Set flag to 0x00 for indicating update firmware is finished
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        if ((nCrcMainTp != nCrcMain) || (nCrcInfoTp != nCrcInfo))
+        {
+            DBG(&g_I2cClient->dev, "Update FAILED\n");
+
+            return -1;
+        }
+    }
+    
+    DBG(&g_I2cClient->dev, "Update SUCCESS\n");
+
+    return 0;
+}
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+static s32 _DrvFwCtrlMsg22xxUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+    u32 i = 0, index = 0;
+    u32 nEraseCount = 0;
+    u32 nMaxEraseTimes = 0;
+    u32 nCrcMain = 0, nCrcMainTp = 0;
+    u32 nCrcInfo = 0, nCrcInfoTp = 0;
+    u32 nRemainSize, nBlockSize, nSize;
+    u32 nTimeOut = 0;
+    u16 nRegData = 0;
+    u16 nTrimByte1 = 0;
+    s32 rc = 0;
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    u8 szDbBusTxData[128] = {0};
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+    u32 nSizePerWrite = 1;
+#else 
+    u32 nSizePerWrite = 125;
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+    u8 szDbBusTxData[1024] = {0};
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+    u32 nSizePerWrite = 1;
+#else
+    u32 nSizePerWrite = 1021;
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+#endif
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    DBG(&g_I2cClient->dev, "*** g_Msg22xxChipRevision = 0x%x ***\n", g_Msg22xxChipRevision);
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+    if (g_Msg22xxChipRevision >= CHIP_TYPE_MSG22XX_REVISION_U05)
+    {
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A)
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        nSizePerWrite = 41; // 123/3=41
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        nSizePerWrite = 340; // 1020/3=340
+#endif
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_B)
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        nSizePerWrite = 31; //124/4=31
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        nSizePerWrite = 255; // 1020/4=255
+#endif
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A
+    }
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+    g_IsUpdateFirmware = 0x01; // Set flag to 0x01 for indicating update firmware is processing
+
+    _DrvFwCtrlMsg22xxConvertFwDataTwoDimenToOneDimen(szFwData, _gOneDimenFwData);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    
+    DBG(&g_I2cClient->dev, "Erase start\n");
+
+    // Stop MCU
+    RegSetLByteValue(0x0FE6, 0x01); 
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+    // Exit flash low power mode
+    RegSetLByteValue(0x1619, BIT1); 
+
+    // Change PIU clock to 48MHz
+    RegSetLByteValue(0x1E23, BIT6); 
+
+    // Change mcu clock deglitch mux source
+    RegSetLByteValue(0x1E54, BIT0); 
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+    nTrimByte1 = _DrvFwCtrlMsg22xxGetTrimByte1();
+    
+    _DrvFwCtrlMsg22xxChangeVoltage();
+
+    // Disable watchdog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    // Set PROGRAM password
+    RegSetLByteValue(0x161A, 0xBA);
+    RegSetLByteValue(0x161B, 0xAB);
+
+    if (nTrimByte1 == 0xCA)
+    {
+        nMaxEraseTimes = MSG22XX_MAX_ERASE_EFLASH_TIMES;
+    }
+    else
+    {
+        nMaxEraseTimes = 1;	
+    }
+    
+    for (nEraseCount = 0; nEraseCount < nMaxEraseTimes; nEraseCount ++)
+    {
+        if (eEmemType == EMEM_ALL) // 48KB + 512Byte
+        {
+            DBG(&g_I2cClient->dev, "Erase all block %d times\n", nEraseCount);
+
+            // Clear pce
+            RegSetLByteValue(0x1618, 0x80);
+            mdelay(100);
+
+            // Chip erase
+            RegSet16BitValue(0x160E, BIT3);
+
+            DBG(&g_I2cClient->dev, "Wait erase done flag\n");
+
+            while (1) // Wait erase done flag
+            {
+                nRegData = RegGet16BitValue(0x1610); // Memory status
+                nRegData = nRegData & BIT1;
+            
+                DBG(&g_I2cClient->dev, "Wait erase done flag nRegData = 0x%x\n", nRegData);
+
+                if (nRegData == BIT1)
+                {
+                    break;		
+                }
+
+                mdelay(50);
+
+                if ((nTimeOut ++) > 30)
+                {
+                    DBG(&g_I2cClient->dev, "Erase all block %d times failed. Timeout.\n", nEraseCount);
+
+                    if (nEraseCount == (nMaxEraseTimes - 1))
+                    {
+                        goto UpdateEnd;
+                    }
+                }
+            }
+        }
+        else if (eEmemType == EMEM_MAIN) // 48KB (32+8+8)
+        {
+            DBG(&g_I2cClient->dev, "Erase main block %d times\n", nEraseCount);
+
+            for (i = 0; i < 3; i ++)
+            {
+                // Clear pce
+                RegSetLByteValue(0x1618, 0x80);
+                mdelay(10);
+ 
+                if (i == 0)
+                {
+                    RegSet16BitValue(0x1600, 0x0000);
+                }
+                else if (i == 1)
+                {
+                    RegSet16BitValue(0x1600, 0x8000);
+                }
+                else if (i == 2)
+                {
+                    RegSet16BitValue(0x1600, 0xA000);
+                }
+
+                // Sector erase
+                RegSet16BitValue(0x160E, (RegGet16BitValue(0x160E) | BIT2));
+
+                DBG(&g_I2cClient->dev, "Wait erase done flag\n");
+
+                nRegData = 0;
+                nTimeOut = 0;
+
+                while (1) // Wait erase done flag
+                {
+                    nRegData = RegGet16BitValue(0x1610); // Memory status
+                    nRegData = nRegData & BIT1;
+            
+                    DBG(&g_I2cClient->dev, "Wait erase done flag nRegData = 0x%x\n", nRegData);
+
+                    if (nRegData == BIT1)
+                    {
+                        break;		
+                    }
+                    mdelay(50);
+
+                    if ((nTimeOut ++) > 30)
+                    {
+                        DBG(&g_I2cClient->dev, "Erase main block %d times failed. Timeout.\n", nEraseCount);
+
+                        if (nEraseCount == (nMaxEraseTimes - 1))
+                        {
+                            goto UpdateEnd;
+                        }
+                    }
+                }
+            }   
+        }
+        else if (eEmemType == EMEM_INFO) // 512Byte
+        {
+            DBG(&g_I2cClient->dev, "Erase info block %d times\n", nEraseCount);
+
+            // Clear pce
+            RegSetLByteValue(0x1618, 0x80);
+            mdelay(10);
+
+            RegSet16BitValue(0x1600, 0xC000);
+        
+            // Sector erase
+            RegSet16BitValue(0x160E, (RegGet16BitValue(0x160E) | BIT2));
+
+            DBG(&g_I2cClient->dev, "Wait erase done flag\n");
+
+            while (1) // Wait erase done flag
+            {
+                nRegData = RegGet16BitValue(0x1610); // Memory status
+                nRegData = nRegData & BIT1;
+            
+                DBG(&g_I2cClient->dev, "Wait erase done flag nRegData = 0x%x\n", nRegData);
+
+                if (nRegData == BIT1)
+                {
+                    break;		
+                }
+                mdelay(50);
+
+                if ((nTimeOut ++) > 30)
+                {
+                    DBG(&g_I2cClient->dev, "Erase info block %d times failed. Timeout.\n", nEraseCount);
+
+                    if (nEraseCount == (nMaxEraseTimes - 1))
+                    {
+                        goto UpdateEnd;
+                    }
+                }
+            }
+        }
+    }
+
+    _DrvFwCtrlMsg22xxRestoreVoltage();
+    
+    DBG(&g_I2cClient->dev, "Erase end\n");
+    
+    // Hold reset pin before program
+    RegSetLByteValue(0x1E06, 0x00); 
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+
+    if (eEmemType == EMEM_ALL || eEmemType == EMEM_MAIN) // 48KB
+    {
+        DBG(&g_I2cClient->dev, "Program main block start\n");
+		
+        // Program main block
+        RegSet16BitValue(0x161A, 0xABBA);
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+		
+        RegSet16BitValue(0x1600, 0x0000); // Set start address of main block
+        
+        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01)); // Enable burst mode
+		
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+        if (g_Msg22xxChipRevision >= CHIP_TYPE_MSG22XX_REVISION_U05) 
+        {
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A)
+            RegSet16BitValueOn(0x160A, BIT0); // Set Bit0 = 1 for enable I2C 400KHz burst write mode, let e-flash discard the last 2 dummy byte.
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_B)
+            RegSet16BitValueOn(0x160A, BIT0);
+            RegSet16BitValueOn(0x160A, BIT1); // Set Bit0 = 1, Bit1 = 1 for enable I2C 400KHz burst write mode, let e-flash discard the last 3 dummy byte.
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A
+        }
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+        // Program start
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = 0x16;
+        szDbBusTxData[2] = 0x02;
+		
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);    
+		
+        szDbBusTxData[0] = 0x20;
+		
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+		
+        nRemainSize = MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024; //48KB
+        index = 0;
+		    
+        while (nRemainSize > 0)
+        {
+            if (nRemainSize > nSizePerWrite)
+            {
+                nBlockSize = nSizePerWrite;
+            }
+            else
+            {
+                nBlockSize = nRemainSize;
+            }
+		
+            szDbBusTxData[0] = 0x10;
+            szDbBusTxData[1] = 0x16;
+            szDbBusTxData[2] = 0x02;
+		
+            nSize = 3;
+		
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+            if (g_Msg22xxChipRevision >= CHIP_TYPE_MSG22XX_REVISION_U05)
+            {
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A)
+                u32 j = 0;
+
+                for (i = 0; i < nBlockSize; i ++)
+                {
+                    for (j = 0; j < 3; j ++)
+                    {
+                        szDbBusTxData[3+(i*3)+j] = _gOneDimenFwData[index*nSizePerWrite+i];
+                    }
+                    nSize = nSize + 3;
+                }
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_B)
+                u32 j = 0;
+
+                for (i = 0; i < nBlockSize; i ++)
+                {
+                    for (j = 0; j < 4; j ++)
+                    {
+                        szDbBusTxData[3+(i*4)+j] = _gOneDimenFwData[index*nSizePerWrite+i];
+                    }
+                    nSize = nSize + 4;
+                }
+#else //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_C
+                for (i = 0; i < nBlockSize; i ++)
+                {
+                    szDbBusTxData[3+i] = _gOneDimenFwData[index*nSizePerWrite+i];
+                    nSize ++; 
+                }
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A
+            }
+            else
+            {
+                for (i = 0; i < nBlockSize; i ++)
+                {
+                    szDbBusTxData[3+i] = _gOneDimenFwData[index*nSizePerWrite+i];
+                    nSize ++; 
+                }
+            }
+#else
+            for (i = 0; i < nBlockSize; i ++)
+            {
+                szDbBusTxData[3+i] = _gOneDimenFwData[index*nSizePerWrite+i];
+                nSize ++; 
+            }
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+            index ++;
+		
+            rc = IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], nSize);
+            if (rc < 0)
+            {
+                DBG(&g_I2cClient->dev, "Write firmware data failed, rc = %d. Exit program procedure.\n", rc);
+
+                goto UpdateEnd;
+            }
+		        
+            nRemainSize = nRemainSize - nBlockSize;
+        }
+		
+        // Program end
+        szDbBusTxData[0] = 0x21;
+		
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+		
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+        if (g_Msg22xxChipRevision >= CHIP_TYPE_MSG22XX_REVISION_U05) 
+        {
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A)
+            RegSet16BitValueOff(0x160A, BIT0); // Set Bit0 = 0 for disable I2C 400KHz burst write mode, let e-flash discard the last 2 dummy byte.
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_B)
+            RegSet16BitValueOff(0x160A, BIT0);
+            RegSet16BitValueOff(0x160A, BIT1); // Set Bit0 = 0, Bit1 = 0 for disable I2C 400KHz burst write mode, let e-flash discard the last 3 dummy byte.
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A
+        }
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+        RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01)); // Clear burst mode
+
+        DBG(&g_I2cClient->dev, "Wait main block write done flag\n");
+		
+        nRegData = 0;
+        nTimeOut = 0;
+
+        while (1) // Wait write done flag
+        {
+            // Polling 0x1610 is 0x0002
+            nRegData = RegGet16BitValue(0x1610); // Memory status
+            nRegData = nRegData & BIT1;
+    
+            DBG(&g_I2cClient->dev, "Wait write done flag nRegData = 0x%x\n", nRegData);
+
+            if (nRegData == BIT1)
+            {
+                break;		
+            }
+            mdelay(10);
+
+            if ((nTimeOut ++) > 30)
+            {
+                DBG(&g_I2cClient->dev, "Write failed. Timeout.\n");
+
+                goto UpdateEnd;
+            }
+        }
+    
+        DBG(&g_I2cClient->dev, "Program main block end\n");
+    }
+    
+    if (eEmemType == EMEM_ALL || eEmemType == EMEM_INFO) // 512 Byte
+    {
+        DBG(&g_I2cClient->dev, "Program info block start\n");
+
+        // Program info block
+        RegSet16BitValue(0x161A, 0xABBA);
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+        RegSet16BitValue(0x1600, 0xC000); // Set start address of info block
+        
+        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01)); // Enable burst mode
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+        if (g_Msg22xxChipRevision >= CHIP_TYPE_MSG22XX_REVISION_U05) 
+        {
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A)
+            RegSet16BitValueOn(0x160A, BIT0); // Set Bit0 = 1 for enable I2C 400KHz burst write mode, let e-flash discard the last 2 dummy byte.
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_B)
+            RegSet16BitValueOn(0x160A, BIT0);
+            RegSet16BitValueOn(0x160A, BIT1); // Set Bit0 = 1, Bit1 = 1 for enable I2C 400KHz burst write mode, let e-flash discard the last 3 dummy byte.
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A
+        }
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+        // Program start
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = 0x16;
+        szDbBusTxData[2] = 0x02;
+
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);    
+
+        szDbBusTxData[0] = 0x20;
+
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+
+        nRemainSize = MSG22XX_FIRMWARE_INFO_BLOCK_SIZE; //512Byte
+        index = 0;
+    
+        while (nRemainSize > 0)
+        {
+            if (nRemainSize > nSizePerWrite)
+            {
+                nBlockSize = nSizePerWrite;
+            }
+            else
+            {
+                nBlockSize = nRemainSize;
+            }
+
+            szDbBusTxData[0] = 0x10;
+            szDbBusTxData[1] = 0x16;
+            szDbBusTxData[2] = 0x02;
+
+            nSize = 3;
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+            if (g_Msg22xxChipRevision >= CHIP_TYPE_MSG22XX_REVISION_U05)
+            {
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A)
+                u32 j = 0;
+
+                for (i = 0; i < nBlockSize; i ++)
+                {
+                    for (j = 0; j < 3; j ++)
+                    {
+                        szDbBusTxData[3+(i*3)+j] = _gOneDimenFwData[(MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE*1024)+(index*nSizePerWrite)+i];
+                    }
+                    nSize = nSize + 3;
+                }
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_B)
+                u32 j = 0;
+
+                for (i = 0; i < nBlockSize; i ++)
+                {
+                    for (j = 0; j < 4; j ++)
+                    {
+                        szDbBusTxData[3+(i*4)+j] = _gOneDimenFwData[(MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE*1024)+(index*nSizePerWrite)+i];
+                    }
+                    nSize = nSize + 4;
+                }
+#else //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_C
+                for (i = 0; i < nBlockSize; i ++)
+                {
+                    szDbBusTxData[3+i] = _gOneDimenFwData[(MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE*1024)+(index*nSizePerWrite)+i];
+                    nSize ++; 
+                }
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A
+            }
+            else
+            {
+                for (i = 0; i < nBlockSize; i ++)
+                {
+                    szDbBusTxData[3+i] = _gOneDimenFwData[(MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE*1024)+(index*nSizePerWrite)+i];
+                    nSize ++; 
+                }
+            }
+#else
+            for (i = 0; i < nBlockSize; i ++)
+            {
+                szDbBusTxData[3+i] = _gOneDimenFwData[(MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE*1024)+(index*nSizePerWrite)+i];
+                nSize ++; 
+            }
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+            index ++;
+
+            IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], nSize);
+        
+            nRemainSize = nRemainSize - nBlockSize;
+        }
+
+        // Program end
+        szDbBusTxData[0] = 0x21;
+
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+        if (g_Msg22xxChipRevision >= CHIP_TYPE_MSG22XX_REVISION_U05) 
+        {
+#if defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A)
+            RegSet16BitValueOff(0x160A, BIT0); // Set Bit0 = 0 for disable I2C 400KHz burst write mode, let e-flash discard the last 2 dummy byte.
+#elif defined(CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_B)
+            RegSet16BitValueOff(0x160A, BIT0);
+            RegSet16BitValueOff(0x160A, BIT1); // Set Bit0 = 0, Bit1 = 0 for disable I2C 400KHz burst write mode, let e-flash discard the last 3 dummy byte.
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K_BY_METHOD_A
+        }
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+        RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01)); // Clear burst mode
+
+        DBG(&g_I2cClient->dev, "Wait info block write done flag\n");
+
+        nRegData = 0;
+        nTimeOut = 0;
+
+        while (1) // Wait write done flag
+        {
+            // Polling 0x1610 is 0x0002
+            nRegData = RegGet16BitValue(0x1610); // Memory status
+            nRegData = nRegData & BIT1;
+    
+            DBG(&g_I2cClient->dev, "Wait write done flag nRegData = 0x%x\n", nRegData);
+
+            if (nRegData == BIT1)
+            {
+                break;		
+            }
+            mdelay(10);
+
+            if ((nTimeOut ++) > 30)
+            {
+                DBG(&g_I2cClient->dev, "Write failed. Timeout.\n");
+
+                goto UpdateEnd;
+            }
+        }
+
+        DBG(&g_I2cClient->dev, "Program info block end\n");
+    }
+    
+    UpdateEnd:
+
+    if (eEmemType == EMEM_ALL || eEmemType == EMEM_MAIN)
+    {
+        // Get CRC 32 from updated firmware bin file
+        nCrcMain  = _gOneDimenFwData[0xBFFF] << 24;
+        nCrcMain |= _gOneDimenFwData[0xBFFE] << 16;
+        nCrcMain |= _gOneDimenFwData[0xBFFD] << 8;
+        nCrcMain |= _gOneDimenFwData[0xBFFC];
+
+        // CRC Main from TP
+        DBG(&g_I2cClient->dev, "Get Main CRC from TP\n");
+
+        nCrcMainTp = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_MAIN);
+    
+        DBG(&g_I2cClient->dev, "nCrcMain=0x%x, nCrcMainTp=0x%x\n", nCrcMain, nCrcMainTp);
+    }
+
+    if (eEmemType == EMEM_ALL || eEmemType == EMEM_INFO)
+    {
+        nCrcInfo  = _gOneDimenFwData[0xC1FF] << 24;
+        nCrcInfo |= _gOneDimenFwData[0xC1FE] << 16;
+        nCrcInfo |= _gOneDimenFwData[0xC1FD] << 8;
+        nCrcInfo |= _gOneDimenFwData[0xC1FC];
+
+        // CRC Info from TP
+        DBG(&g_I2cClient->dev, "Get Info CRC from TP\n");
+
+        nCrcInfoTp = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_INFO);
+
+        DBG(&g_I2cClient->dev, "nCrcInfo=0x%x, nCrcInfoTp=0x%x\n", nCrcInfo, nCrcInfoTp);
+    }
+
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    g_IsUpdateFirmware = 0x00; // Set flag to 0x00 for indicating update firmware is finished
+
+    if (eEmemType == EMEM_ALL)
+    {
+        if ((nCrcMainTp != nCrcMain) || (nCrcInfoTp != nCrcInfo))
+        {
+            DBG(&g_I2cClient->dev, "Update FAILED\n");
+          
+            return -1;
+        } 
+    }
+    else if (eEmemType == EMEM_MAIN)
+    {
+        if (nCrcMainTp != nCrcMain)
+        {
+            DBG(&g_I2cClient->dev, "Update FAILED\n");
+          
+            return -1;
+        } 
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        if (nCrcInfoTp != nCrcInfo)
+        {
+            DBG(&g_I2cClient->dev, "Update FAILED\n");
+          
+            return -1;
+        } 
+    }
+    
+    DBG(&g_I2cClient->dev, "Update SUCCESS\n");
+
+    return 0;
+}
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+void DrvFwCtrlVariableInitialize(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (g_ChipType == CHIP_TYPE_MSG21XXA)
+    {
+//        FIRMWARE_MODE_UNKNOWN_MODE = MSG21XXA_FIRMWARE_MODE_UNKNOWN_MODE;
+        FIRMWARE_MODE_DEMO_MODE = MSG21XXA_FIRMWARE_MODE_DEMO_MODE;
+        FIRMWARE_MODE_DEBUG_MODE = MSG21XXA_FIRMWARE_MODE_DEBUG_MODE;
+        FIRMWARE_MODE_RAW_DATA_MODE = MSG21XXA_FIRMWARE_MODE_RAW_DATA_MODE;
+
+        g_FirmwareMode = FIRMWARE_MODE_DEMO_MODE;
+        
+        DEMO_MODE_PACKET_LENGTH = SELF_DEMO_MODE_PACKET_LENGTH;
+        DEBUG_MODE_PACKET_LENGTH = SELF_DEBUG_MODE_PACKET_LENGTH;
+        MAX_TOUCH_NUM = SELF_MAX_TOUCH_NUM;
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+//        FIRMWARE_MODE_UNKNOWN_MODE = MSG22XX_FIRMWARE_MODE_UNKNOWN_MODE;
+        FIRMWARE_MODE_DEMO_MODE = MSG22XX_FIRMWARE_MODE_DEMO_MODE;
+        FIRMWARE_MODE_DEBUG_MODE = MSG22XX_FIRMWARE_MODE_DEBUG_MODE;
+        FIRMWARE_MODE_RAW_DATA_MODE = MSG22XX_FIRMWARE_MODE_RAW_DATA_MODE;
+
+        g_FirmwareMode = FIRMWARE_MODE_DEMO_MODE;
+
+        DEMO_MODE_PACKET_LENGTH = SELF_DEMO_MODE_PACKET_LENGTH;
+        DEBUG_MODE_PACKET_LENGTH = SELF_DEBUG_MODE_PACKET_LENGTH;
+        MAX_TOUCH_NUM = SELF_MAX_TOUCH_NUM;
+    }	
+    else if (g_ChipType == CHIP_TYPE_MSG26XXM)
+    {
+        FIRMWARE_MODE_UNKNOWN_MODE = MSG26XXM_FIRMWARE_MODE_UNKNOWN_MODE;
+        FIRMWARE_MODE_DEMO_MODE = MSG26XXM_FIRMWARE_MODE_DEMO_MODE;
+        FIRMWARE_MODE_DEBUG_MODE = MSG26XXM_FIRMWARE_MODE_DEBUG_MODE;
+//        FIRMWARE_MODE_RAW_DATA_MODE = MSG26XXM_FIRMWARE_MODE_RAW_DATA_MODE;
+
+        g_FirmwareMode = FIRMWARE_MODE_DEMO_MODE;
+
+        DEMO_MODE_PACKET_LENGTH = MUTUAL_DEMO_MODE_PACKET_LENGTH;
+        DEBUG_MODE_PACKET_LENGTH = MUTUAL_DEBUG_MODE_PACKET_LENGTH;
+        MAX_TOUCH_NUM = MUTUAL_MAX_TOUCH_NUM;
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        FIRMWARE_MODE_UNKNOWN_MODE = MSG28XX_FIRMWARE_MODE_UNKNOWN_MODE;
+        FIRMWARE_MODE_DEMO_MODE = MSG28XX_FIRMWARE_MODE_DEMO_MODE;
+        FIRMWARE_MODE_DEBUG_MODE = MSG28XX_FIRMWARE_MODE_DEBUG_MODE;
+//        FIRMWARE_MODE_RAW_DATA_MODE = MSG28XX_FIRMWARE_MODE_RAW_DATA_MODE;
+
+        g_FirmwareMode = FIRMWARE_MODE_DEMO_MODE;
+
+        DEMO_MODE_PACKET_LENGTH = MUTUAL_DEMO_MODE_PACKET_LENGTH;
+        DEBUG_MODE_PACKET_LENGTH = MUTUAL_DEBUG_MODE_PACKET_LENGTH;
+        MAX_TOUCH_NUM = MUTUAL_MAX_TOUCH_NUM;
+    }	
+}	
+
+void DrvFwCtrlOptimizeCurrentConsumption(void)
+{
+    u32 i;
+    u8 szDbBusTxData[35] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    DBG(&g_I2cClient->dev, "g_ChipType = 0x%x\n", g_ChipType);
+    
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (g_GestureWakeupFlag == 1)
+    {
+        return;
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+    if (g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        mutex_lock(&g_Mutex);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+        DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+        DrvPlatformLyrTouchDeviceResetHw(); 
+
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+        // Enable burst mode
+        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = 0x11;
+        szDbBusTxData[2] = 0xA0; //bank:0x11, addr:h0050
+    
+        for (i = 0; i < 24; i ++)
+        {
+            szDbBusTxData[i+3] = 0x11;
+        }
+		
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+24);  // Write 0x11 for reg 0x1150~0x115B
+
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = 0x11;
+        szDbBusTxData[2] = 0xB8; //bank:0x11, addr:h005C
+    
+        for (i = 0; i < 6; i ++)
+        {
+            szDbBusTxData[i+3] = 0xFF;
+        }
+		
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+6);   // Write 0xFF for reg 0x115C~0x115E 
+    
+        // Clear burst mode
+        RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01)); 
+    
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+
+        mutex_unlock(&g_Mutex);
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        mutex_lock(&g_Mutex);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+        DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+        DrvPlatformLyrTouchDeviceResetHw(); 
+
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+
+        // Enable burst mode
+        RegSetLByteValue(0x1608, 0x21);
+
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = 0x15;
+        szDbBusTxData[2] = 0x20; //bank:0x15, addr:h0010
+    
+        for (i = 0; i < 8; i ++)
+        {
+            szDbBusTxData[i+3] = 0xFF;
+        }
+		
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+8);  // Write 0xFF for reg 0x1510~0x1513
+
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = 0x15;
+        szDbBusTxData[2] = 0x28; //bank:0x15, addr:h0014
+    
+        for (i = 0; i < 16; i ++)
+        {
+            szDbBusTxData[i+3] = 0x00;
+        }
+		
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+16);   // Write 0x00 for reg 0x1514~0x151B
+    
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = 0x21;
+        szDbBusTxData[2] = 0x40; //bank:0x21, addr:h0020
+    
+        for (i = 0; i < 8; i ++)
+        {
+            szDbBusTxData[i+3] = 0xFF;
+        }
+		
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+8);  // Write 0xFF for reg 0x2120~0x2123
+
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = 0x21;
+        szDbBusTxData[2] = 0x20; //bank:0x21, addr:h0010
+    
+        for (i = 0; i < 32; i ++)
+        {
+            szDbBusTxData[i+3] = 0xFF;
+        }
+		
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+32);  // Write 0xFF for reg 0x2110~0x211F
+
+        // Clear burst mode
+        RegSetLByteValue(0x1608, 0x20);
+    
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+
+        mutex_unlock(&g_Mutex);
+    }
+}
+
+u8 DrvFwCtrlGetChipType(void)
+{
+    s32 rc =0;
+    u8 nChipType = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    // Erase TP Flash first
+    rc = DbBusEnterSerialDebugMode();
+    if (rc < 0)
+    {
+        DBG(&g_I2cClient->dev, "*** DbBusEnterSerialDebugMode() failed, rc = %d ***\n", rc);
+        return nChipType;
+    }
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Stop MCU
+    RegSetLByteValue(0x0FE6, 0x01);
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K // for MSG22xx only
+    // Exit flash low power mode
+    RegSetLByteValue(0x1619, BIT1); 
+
+    // Change PIU clock to 48MHz
+    RegSetLByteValue(0x1E23, BIT6); 
+
+    // Change mcu clock deglitch mux source
+    RegSetLByteValue(0x1E54, BIT0); 
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+    // Disable watchdog
+    RegSet16BitValue(0x3C60, 0xAA55);
+    
+    nChipType = RegGet16BitValue(0x1ECC) & 0xFF;
+
+    if (nChipType != CHIP_TYPE_MSG21XX &&   // (0x01) 
+        nChipType != CHIP_TYPE_MSG21XXA &&  // (0x02) 
+        nChipType != CHIP_TYPE_MSG26XXM &&  // (0x03) 
+        nChipType != CHIP_TYPE_MSG22XX &&   // (0x7A)
+        nChipType != CHIP_TYPE_MSG28XX)     // (0x85)
+    {
+        nChipType = 0;
+    }
+    
+    if (nChipType == CHIP_TYPE_MSG22XX)  // (0x7A)
+    {
+        g_Msg22xxChipRevision = RegGetHByteValue(0x1ECE);
+    		
+        DBG(&g_I2cClient->dev, "*** g_Msg22xxChipRevision = 0x%x ***\n", g_Msg22xxChipRevision);
+    }
+
+    DBG(&g_I2cClient->dev, "*** Chip Type = 0x%x ***\n", nChipType);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nChipType;
+}	
+
+void DrvFwCtrlGetCustomerFirmwareVersionByDbBus(EmemType_e eEmemType, u16 *pMajor, u16 *pMinor, u8 **ppVersion) // support MSG28xx only
+{
+    u16 nReadAddr = 0;
+    u8  szTmpData[4] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    if (g_ChipType == CHIP_TYPE_MSG28XX)   
+    {
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+
+        // Stop mcu
+        RegSetLByteValue(0x0FE6, 0x01); 
+
+        // Stop watchdog
+        RegSet16BitValue(0x3C60, 0xAA55);
+
+        if (eEmemType == EMEM_MAIN) // Read SW ID from main block
+        {
+            _DrvFwCtrlMsg28xxReadEFlashStart(0x7FFD, EMEM_MAIN); 
+            nReadAddr = 0x7FFD;
+        }
+        else if (eEmemType == EMEM_INFO) // Read SW ID from info block
+        {
+            _DrvFwCtrlMsg28xxReadEFlashStart(0x81FB, EMEM_INFO);
+            nReadAddr = 0x81FB;
+        }
+
+        _DrvFwCtrlMsg28xxReadEFlashDoRead(nReadAddr, &szTmpData[0]);
+
+        _DrvFwCtrlMsg28xxReadEFlashEnd();
+
+        /*
+          Ex. Major in Main Block :
+              Major low byte at address 0x7FFD
+          
+              Major in Info Block :
+              Major low byte at address 0x81FB
+        */
+
+        *pMajor = (szTmpData[1] << 8);
+        *pMajor |= szTmpData[0];
+        *pMinor = (szTmpData[3] << 8);
+        *pMinor |= szTmpData[2];
+
+        DBG(&g_I2cClient->dev, "*** Major = %d ***\n", *pMajor);
+        DBG(&g_I2cClient->dev, "*** Minor = %d ***\n", *pMinor);
+    
+        if (*ppVersion == NULL)
+        {
+            *ppVersion = kzalloc(sizeof(u8)*11, GFP_KERNEL);
+        }
+
+        sprintf(*ppVersion, "%05d.%05d", *pMajor, *pMinor);
+
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+    }
+}	
+
+void DrvFwCtrlGetCustomerFirmwareVersion(u16 *pMajor, u16 *pMinor, u8 **ppVersion)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG21XX)
+    {
+        u8 szDbBusTxData[3] = {0};
+        u8 szDbBusRxData[4] = {0};
+
+        szDbBusTxData[0] = 0x53;
+        szDbBusTxData[1] = 0x00;
+
+        if (g_ChipType == CHIP_TYPE_MSG21XXA)
+        {    
+            szDbBusTxData[2] = 0x2A;
+        }
+        else if (g_ChipType == CHIP_TYPE_MSG21XX)
+        {
+            szDbBusTxData[2] = 0x74;
+        }
+        else
+        {
+            szDbBusTxData[2] = 0x2A;
+        }
+
+        mutex_lock(&g_Mutex);
+
+        DrvPlatformLyrTouchDeviceResetHw();
+
+        IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+        IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+        mutex_unlock(&g_Mutex);
+
+        *pMajor = (szDbBusRxData[1]<<8) + szDbBusRxData[0];
+        *pMinor = (szDbBusRxData[3]<<8) + szDbBusRxData[2];
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        u16 nRegData1, nRegData2;
+
+        mutex_lock(&g_Mutex);
+
+        DrvPlatformLyrTouchDeviceResetHw();
+    
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+        
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+        // Stop MCU
+        RegSetLByteValue(0x0FE6, 0x01); 
+    
+        // Exit flash low power mode
+        RegSetLByteValue(0x1619, BIT1); 
+
+        // Change PIU clock to 48MHz
+        RegSetLByteValue(0x1E23, BIT6); 
+
+        // Change mcu clock deglitch mux source
+        RegSetLByteValue(0x1E54, BIT0); 
+#else
+        // Stop MCU
+        RegSetLByteValue(0x0FE6, 0x01); 
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+        // Stop watchdog
+        RegSet16BitValue(0x3C60, 0xAA55);
+
+        // RIU password
+        RegSet16BitValue(0x161A, 0xABBA); 
+
+        RegSet16BitValue(0x1600, 0xBFF4); // Set start address for customer firmware version on main block
+    
+        // Enable burst mode
+//        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+        RegSetLByteValue(0x160E, 0x01); 
+
+        nRegData1 = RegGet16BitValue(0x1604);
+        nRegData2 = RegGet16BitValue(0x1606);
+
+        *pMajor = (((nRegData1 >> 8) & 0xFF) << 8) + (nRegData1 & 0xFF);
+        *pMinor = (((nRegData2 >> 8) & 0xFF) << 8) + (nRegData2 & 0xFF);
+
+        // Clear burst mode
+//        RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+        RegSet16BitValue(0x1600, 0x0000); 
+
+        // Clear RIU password
+        RegSet16BitValue(0x161A, 0x0000); 
+
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+
+        DrvPlatformLyrTouchDeviceResetHw();
+
+        mutex_unlock(&g_Mutex);
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG26XXM)   
+    {
+        u8 szDbBusTxData[3] = {0};
+        u8 szDbBusRxData[4] = {0};
+
+        szDbBusTxData[0] = 0x53;
+        szDbBusTxData[1] = 0x00;
+        szDbBusTxData[2] = 0x2A;
+    
+        mutex_lock(&g_Mutex);
+
+        DrvPlatformLyrTouchDeviceResetHw();
+
+        IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+        IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+        mutex_unlock(&g_Mutex);
+
+        DBG(&g_I2cClient->dev, "szDbBusRxData[0] = 0x%x\n", szDbBusRxData[0]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[1] = 0x%x\n", szDbBusRxData[1]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[2] = 0x%x\n", szDbBusRxData[2]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[3] = 0x%x\n", szDbBusRxData[3]); // add for debug
+
+        *pMajor = (szDbBusRxData[1]<<8) + szDbBusRxData[0];
+        *pMinor = (szDbBusRxData[3]<<8) + szDbBusRxData[2];
+    }    
+    else if (g_ChipType == CHIP_TYPE_MSG28XX)   
+    {
+        u8 szDbBusTxData[3] = {0};
+        u8 szDbBusRxData[4] = {0};
+
+        szDbBusTxData[0] = 0x03;
+
+        mutex_lock(&g_Mutex);
+    
+        DrvPlatformLyrTouchDeviceResetHw();
+
+        IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 1);
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        mdelay(I2C_SMBUS_READ_COMMAND_DELAY_FOR_SPRD_PLATFORM);
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM
+        IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+        mutex_unlock(&g_Mutex);
+
+        DBG(&g_I2cClient->dev, "szDbBusRxData[0] = 0x%x\n", szDbBusRxData[0]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[1] = 0x%x\n", szDbBusRxData[1]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[2] = 0x%x\n", szDbBusRxData[2]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[3] = 0x%x\n", szDbBusRxData[3]); // add for debug
+
+        *pMajor = (szDbBusRxData[1]<<8) + szDbBusRxData[0];
+        *pMinor = (szDbBusRxData[3]<<8) + szDbBusRxData[2];
+    }
+
+    DBG(&g_I2cClient->dev, "*** Major = %d ***\n", *pMajor);
+    DBG(&g_I2cClient->dev, "*** Minor = %d ***\n", *pMinor);
+
+    if (*ppVersion == NULL)
+    {
+        *ppVersion = kzalloc(sizeof(u8)*11, GFP_KERNEL);
+    }
+
+    sprintf(*ppVersion, "%05d.%05d", *pMajor, *pMinor);
+}
+
+void DrvFwCtrlGetPlatformFirmwareVersion(u8 **ppVersion)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (g_ChipType == CHIP_TYPE_MSG22XX) 
+    {
+        u32 i;
+        u16 nRegData1, nRegData2;
+        u8 szDbBusRxData[12] = {0};
+
+        mutex_lock(&g_Mutex);
+
+        DrvPlatformLyrTouchDeviceResetHw();
+    
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+        // Stop MCU
+        RegSetLByteValue(0x0FE6, 0x01); 
+    
+        // Exit flash low power mode
+        RegSetLByteValue(0x1619, BIT1); 
+
+        // Change PIU clock to 48MHz
+        RegSetLByteValue(0x1E23, BIT6); 
+
+        // Change mcu clock deglitch mux source
+        RegSetLByteValue(0x1E54, BIT0); 
+#else
+        // Stop MCU
+        RegSetLByteValue(0x0FE6, 0x01); 
+#endif //CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K
+
+        // Stop watchdog
+        RegSet16BitValue(0x3C60, 0xAA55);
+
+        // RIU password
+        RegSet16BitValue(0x161A, 0xABBA); 
+
+        RegSet16BitValue(0x1600, 0xC1F2); // Set start address for platform firmware version on info block(Actually, start reading from 0xC1F0)
+    
+        // Enable burst mode
+        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+        for (i = 0; i < 3; i ++)
+        {
+            RegSetLByteValue(0x160E, 0x01); 
+
+            nRegData1 = RegGet16BitValue(0x1604);
+            nRegData2 = RegGet16BitValue(0x1606);
+
+            szDbBusRxData[i*4+0] = (nRegData1 & 0xFF);
+            szDbBusRxData[i*4+1] = ((nRegData1 >> 8 ) & 0xFF);
+            
+//            DBG(&g_I2cClient->dev, "szDbBusRxData[%d] = 0x%x , %c \n", i*4+0, szDbBusRxData[i*4+0], szDbBusRxData[i*4+0]); // add for debug
+//            DBG(&g_I2cClient->dev, "szDbBusRxData[%d] = 0x%x , %c \n", i*4+1, szDbBusRxData[i*4+1], szDbBusRxData[i*4+1]); // add for debug
+            
+            szDbBusRxData[i*4+2] = (nRegData2 & 0xFF);
+            szDbBusRxData[i*4+3] = ((nRegData2 >> 8 ) & 0xFF);
+
+//            DBG(&g_I2cClient->dev, "szDbBusRxData[%d] = 0x%x , %c \n", i*4+2, szDbBusRxData[i*4+2], szDbBusRxData[i*4+2]); // add for debug
+//            DBG(&g_I2cClient->dev, "szDbBusRxData[%d] = 0x%x , %c \n", i*4+3, szDbBusRxData[i*4+3], szDbBusRxData[i*4+3]); // add for debug
+        }
+
+        // Clear burst mode
+        RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+        RegSet16BitValue(0x1600, 0x0000); 
+
+        // Clear RIU password
+        RegSet16BitValue(0x161A, 0x0000); 
+
+        if (*ppVersion == NULL)
+        {
+            *ppVersion = kzalloc(sizeof(u8)*10, GFP_KERNEL);
+        }
+    
+        sprintf(*ppVersion, "%c%c%c%c%c%c%c%c%c%c", szDbBusRxData[2], szDbBusRxData[3], szDbBusRxData[4],
+            szDbBusRxData[5], szDbBusRxData[6], szDbBusRxData[7], szDbBusRxData[8], szDbBusRxData[9], szDbBusRxData[10], szDbBusRxData[11]);
+
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+
+        DrvPlatformLyrTouchDeviceResetHw();
+
+        mutex_unlock(&g_Mutex);
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG26XXM)   
+    {
+        u32 i;
+        u16 nRegData = 0;
+        u8 szDbBusTxData[5] = {0};
+        u8 szDbBusRxData[16] = {0};
+
+        mutex_lock(&g_Mutex);
+
+        DrvPlatformLyrTouchDeviceResetHw();
+
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+
+        // Stop mcu
+        RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+        // Stop watchdog
+        RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+        RegSet16BitValue(0x3CE4, 0xA4AB); //bank:reg_PIU_MISC_0, addr:h0072
+
+        // TP SW reset
+        RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+        RegSet16BitValue(0x1E04, 0x829F);
+
+        // Start mcu
+        RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    
+        mdelay(100);
+
+        // Polling 0x3CE4 is 0x5B58
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+        } while (nRegData != 0x5B58);
+
+        // Read platform firmware version from info block
+        szDbBusTxData[0] = 0x72;
+        szDbBusTxData[3] = 0x00;
+        szDbBusTxData[4] = 0x08;
+
+        for (i = 0; i < 2; i ++)
+        {
+            szDbBusTxData[1] = 0x80;
+            szDbBusTxData[2] = 0x10 + ((i*8)&0x00ff);
+
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+
+            mdelay(50);
+
+            IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[i*8], 8);
+        }
+
+        if (*ppVersion == NULL)
+        {
+            *ppVersion = kzalloc(sizeof(u8)*16, GFP_KERNEL);
+        }
+    
+        sprintf(*ppVersion, "%.16s", szDbBusRxData);
+
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+
+        DrvPlatformLyrTouchDeviceResetHw();
+        mdelay(100);
+
+        mutex_unlock(&g_Mutex);
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG28XX)   
+    {
+        u8 szDbBusTxData[1] = {0};
+        u8 szDbBusRxData[10] = {0};
+    
+        szDbBusTxData[0] = 0x04;
+
+        mutex_lock(&g_Mutex);
+    
+        DrvPlatformLyrTouchDeviceResetHw();
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+        DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+        IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 1);
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        mdelay(I2C_SMBUS_READ_COMMAND_DELAY_FOR_SPRD_PLATFORM);
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM
+        IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 10);
+
+        mutex_unlock(&g_Mutex);
+           
+        DBG(&g_I2cClient->dev, "szDbBusRxData[0] = 0x%x , %c \n", szDbBusRxData[0], szDbBusRxData[0]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[1] = 0x%x , %c \n", szDbBusRxData[1], szDbBusRxData[1]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[2] = 0x%x , %c \n", szDbBusRxData[2], szDbBusRxData[2]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[3] = 0x%x , %c \n", szDbBusRxData[3], szDbBusRxData[3]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[4] = 0x%x , %c \n", szDbBusRxData[4], szDbBusRxData[4]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[5] = 0x%x , %c \n", szDbBusRxData[5], szDbBusRxData[5]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[6] = 0x%x , %c \n", szDbBusRxData[6], szDbBusRxData[6]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[7] = 0x%x , %c \n", szDbBusRxData[7], szDbBusRxData[7]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[8] = 0x%x , %c \n", szDbBusRxData[8], szDbBusRxData[8]); // add for debug
+        DBG(&g_I2cClient->dev, "szDbBusRxData[9] = 0x%x , %c \n", szDbBusRxData[9], szDbBusRxData[9]); // add for debug
+
+        if (*ppVersion == NULL)
+        {
+            *ppVersion = kzalloc(sizeof(u8)*10, GFP_KERNEL);
+        }
+
+        sprintf(*ppVersion, "%.10s", szDbBusRxData);
+    }
+    else
+    {
+        if (*ppVersion == NULL)
+        {
+            *ppVersion = kzalloc(sizeof(u8)*10, GFP_KERNEL);
+        }
+    
+        sprintf(*ppVersion, "%s", "N/A");
+    }
+
+    DBG(&g_I2cClient->dev, "*** platform firmware version = %s ***\n", *ppVersion);
+}
+
+s32 DrvFwCtrlUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    return _DrvFwCtrlUpdateFirmwareCash(szFwData, eEmemType);
+}	
+
+s32 DrvFwCtrlUpdateFirmwareBySdCard(const char *pFilePath)
+{
+    s32 nRetVal = -1;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX || g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)    
+    {
+        nRetVal = _DrvFwCtrlUpdateFirmwareBySdCard(pFilePath);
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "This chip type (0x%x) does not support update firmware by sd card\n", g_ChipType);
+    }
+    
+    return nRetVal;
+}	
+
+//------------------------------------------------------------------------------//
+
+u16 DrvFwCtrlGetFirmwareMode(void) // use for MSG26XXM only
+{
+    u16 nMode = 0;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (g_ChipType == CHIP_TYPE_MSG26XXM)   
+    {
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+
+        nMode = RegGet16BitValue(0x3CF4); //bank:reg_PIU_MISC0, addr:h007a
+
+        DBG(&g_I2cClient->dev, "firmware mode = 0x%x\n", nMode);
+
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+    }
+    
+    return nMode;
+}
+
+u16 DrvFwCtrlChangeFirmwareMode(u16 nMode)
+{
+    DBG(&g_I2cClient->dev, "*** %s() *** nMode = 0x%x\n", __func__, nMode);
+
+    if (g_ChipType == CHIP_TYPE_MSG26XXM)   
+    {
+        DrvPlatformLyrTouchDeviceResetHw(); 
+
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+
+        RegSet16BitValue(0x3CF4, nMode); //bank:reg_PIU_MISC0, addr:h007a
+        nMode = RegGet16BitValue(0x3CF4); 
+
+        DBG(&g_I2cClient->dev, "firmware mode = 0x%x\n", nMode);
+
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX || g_ChipType == CHIP_TYPE_MSG28XX)  
+    {
+        u8 szDbBusTxData[2] = {0};
+        u32 i = 0;
+        s32 rc;
+
+        _gIsDisableFinagerTouch = 1; // Disable finger touch ISR handling temporarily for device driver can send change firmware mode i2c command to firmware. 
+
+        szDbBusTxData[0] = 0x02;
+        szDbBusTxData[1] = (u8)nMode;
+
+        mutex_lock(&g_Mutex);
+        DBG(&g_I2cClient->dev, "*** %s() *** mutex_lock(&g_Mutex)\n", __func__);  // add for debug
+
+        while (i < 5)
+        {
+            mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+            rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 2);
+            if (rc > 0)
+            {
+                DBG(&g_I2cClient->dev, "Change firmware mode success\n");
+                break;
+            }
+
+            i++;
+        }
+        if (i == 5)
+        {
+            DBG(&g_I2cClient->dev, "Change firmware mode failed, rc = %d\n", rc);
+        }
+
+        DBG(&g_I2cClient->dev, "*** %s() *** mutex_unlock(&g_Mutex)\n", __func__);  // add for debug
+        mutex_unlock(&g_Mutex);
+
+        _gIsDisableFinagerTouch = 0;
+    }
+
+    return nMode;
+}
+
+void DrvFwCtrlSelfGetFirmwareInfo(SelfFirmwareInfo_t *pInfo) // for MSG21xxA/MSG22xx
+{
+    u8 szDbBusTxData[1] = {0};
+    u8 szDbBusRxData[8] = {0};
+    u32 i = 0;
+    s32 rc;
+    
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    _gIsDisableFinagerTouch = 1; // Disable finger touch ISR handling temporarily for device driver can send get firmware info i2c command to firmware. 
+
+    szDbBusTxData[0] = 0x01;
+
+    mutex_lock(&g_Mutex);
+    
+    while (i < 5)
+    {
+        mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+        rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 1);
+        if (rc > 0)
+        {
+            DBG(&g_I2cClient->dev, "Get firmware info IicWriteData() success\n");
+        }
+        mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+        rc = IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 8);
+        if (rc > 0)
+        {
+            DBG(&g_I2cClient->dev, "Get firmware info IicReadData() success\n");
+            break;
+        }
+
+        i++;
+    }
+    if (i == 5)
+    {
+        DBG(&g_I2cClient->dev, "Get firmware info failed, rc = %d\n", rc);
+    }
+
+    mutex_unlock(&g_Mutex);
+    
+    if ((szDbBusRxData[1] & 0x80) == 0x80)
+    {
+        pInfo->nIsCanChangeFirmwareMode = 0;	
+    }
+    else
+    {
+        pInfo->nIsCanChangeFirmwareMode = 1;	
+    }
+    
+    pInfo->nFirmwareMode = szDbBusRxData[1] & 0x7F;
+    pInfo->nLogModePacketHeader = szDbBusRxData[2];
+    pInfo->nLogModePacketLength = (szDbBusRxData[3]<<8) + szDbBusRxData[4];
+
+    DBG(&g_I2cClient->dev, "pInfo->nFirmwareMode=0x%x, pInfo->nLogModePacketHeader=0x%x, pInfo->nLogModePacketLength=%d, pInfo->nIsCanChangeFirmwareMode=%d\n", pInfo->nFirmwareMode, pInfo->nLogModePacketHeader, pInfo->nLogModePacketLength, pInfo->nIsCanChangeFirmwareMode);
+
+    _gIsDisableFinagerTouch = 0;
+}
+
+void DrvFwCtrlMutualGetFirmwareInfo(MutualFirmwareInfo_t *pInfo) // for MSG26xxM/MSG28xx
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    if (g_ChipType == CHIP_TYPE_MSG26XXM)   
+    {
+        u8 szDbBusTxData[3] = {0};
+        u8 szDbBusRxData[8] = {0};
+        u32 i = 0;
+        s32 rc;
+
+        _gIsDisableFinagerTouch = 1; // Disable finger touch ISR handling temporarily for device driver can send get firmware info i2c command to firmware. 
+
+        szDbBusTxData[0] = 0x53;
+        szDbBusTxData[1] = 0x00;
+        szDbBusTxData[2] = 0x48;
+
+        mutex_lock(&g_Mutex);
+    
+        while (i < 5)
+        {
+            mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+            rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+            if (rc > 0)
+            {
+                DBG(&g_I2cClient->dev, "Get firmware info IicWriteData() success\n");
+            }
+
+            mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+            rc = IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 8);
+            if (rc > 0)
+            {
+                DBG(&g_I2cClient->dev, "Get firmware info IicReadData() success\n");
+                break;
+            }
+
+            i++;
+        }
+        if (i == 5)
+        {
+            DBG(&g_I2cClient->dev, "Get firmware info failed, rc = %d\n", rc);
+        }
+
+        mutex_unlock(&g_Mutex);
+
+        if (szDbBusRxData[0] == 8 && szDbBusRxData[1] == 0 && szDbBusRxData[2] == 9 && szDbBusRxData[3] == 0)
+        {
+            DBG(&g_I2cClient->dev, "*** Debug Mode Packet Header is 0xA5 ***\n");
+/*
+            DbBusEnterSerialDebugMode();
+            DbBusStopMCU();
+            DbBusIICUseBus();
+            DbBusIICReshape();
+            mdelay(100);
+*/
+            pInfo->nLogModePacketHeader = 0xA5;
+            pInfo->nMy = 0;
+            pInfo->nMx = 0;
+//            *pDriveLineNumber = AnaGetMutualSubframeNum();
+//            *pSenseLineNumber = AnaGetMutualChannelNum();
+
+/*        
+            DbBusIICNotUseBus();
+            DbBusNotStopMCU();
+            DbBusExitSerialDebugMode();
+            mdelay(100);
+*/
+        }
+        else if (szDbBusRxData[0] == 0xAB)
+        {
+            DBG(&g_I2cClient->dev, "*** Debug Mode Packet Header is 0xAB ***\n");
+
+            pInfo->nLogModePacketHeader = szDbBusRxData[0];
+            pInfo->nMy = szDbBusRxData[1];
+            pInfo->nMx = szDbBusRxData[2];
+//            pInfo->nSd = szDbBusRxData[1];
+//            pInfo->nSs = szDbBusRxData[2];
+        }
+        else if (szDbBusRxData[0] == 0xA7 && szDbBusRxData[3] == PACKET_TYPE_TOOTH_PATTERN) 
+        {
+            DBG(&g_I2cClient->dev, "*** Debug Packet Header is 0xA7 ***\n");
+
+            pInfo->nLogModePacketHeader = szDbBusRxData[0];
+            pInfo->nType = szDbBusRxData[3];
+            pInfo->nMy = szDbBusRxData[4];
+            pInfo->nMx = szDbBusRxData[5];
+            pInfo->nSd = szDbBusRxData[6];
+            pInfo->nSs = szDbBusRxData[7];
+        }
+
+        if (pInfo->nLogModePacketHeader == 0xA5)
+        {
+            if (pInfo->nMy != 0 && pInfo->nMx != 0)
+            {
+                // for parsing debug mode packet 0xA5 
+                pInfo->nLogModePacketLength = 1+1+1+1+10*3+pInfo->nMx*pInfo->nMy*2+1;
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "Failed to retrieve channel number or subframe number for debug mode packet 0xA5.\n");
+            }
+        }
+        else if (pInfo->nLogModePacketHeader == 0xAB)
+        {
+            if (pInfo->nMy != 0 && pInfo->nMx != 0)
+            {
+                // for parsing debug mode packet 0xAB 
+                pInfo->nLogModePacketLength = 1+1+1+1+10*3+pInfo->nMy*pInfo->nMx*2+pInfo->nMy*2+pInfo->nMx*2+2*2+8*2+1;
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "Failed to retrieve channel number or subframe number for debug mode packet 0xAB.\n");
+            }
+        }
+        else if (pInfo->nLogModePacketHeader == 0xA7 && pInfo->nType == PACKET_TYPE_TOOTH_PATTERN)
+        {
+            if (pInfo->nMy != 0 && pInfo->nMx != 0 && pInfo->nSd != 0 && pInfo->nSs != 0)
+            {
+                // for parsing debug mode packet 0xA7  
+                pInfo->nLogModePacketLength = 1+1+1+1+1+10*3+pInfo->nMy*pInfo->nMx*2+pInfo->nSd*2+pInfo->nSs*2+10*2+1;
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "Failed to retrieve channel number or subframe number for debug mode packet 0xA7.\n");
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "Undefined debug mode packet header = 0x%x\n", pInfo->nLogModePacketHeader);
+        }
+    
+        DBG(&g_I2cClient->dev, "*** debug mode packet header = 0x%x ***\n", pInfo->nLogModePacketHeader);
+        DBG(&g_I2cClient->dev, "*** debug mode packet length = %d ***\n", pInfo->nLogModePacketLength);
+        DBG(&g_I2cClient->dev, "*** Type = 0x%x ***\n", pInfo->nType);
+        DBG(&g_I2cClient->dev, "*** My = %d ***\n", pInfo->nMy);
+        DBG(&g_I2cClient->dev, "*** Mx = %d ***\n", pInfo->nMx);
+        DBG(&g_I2cClient->dev, "*** Sd = %d ***\n", pInfo->nSd);
+        DBG(&g_I2cClient->dev, "*** Ss = %d ***\n", pInfo->nSs);
+
+        _gIsDisableFinagerTouch = 0;
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG28XX)   
+    {
+        u8 szDbBusTxData[1] = {0};
+        u8 szDbBusRxData[10] = {0};
+        u32 i = 0;
+        s32 rc;
+    
+        _gIsDisableFinagerTouch = 1; // Disable finger touch ISR handling temporarily for device driver can send get firmware info i2c command to firmware. 
+        
+        szDbBusTxData[0] = 0x01;
+
+        mutex_lock(&g_Mutex);
+        DBG(&g_I2cClient->dev, "*** %s() *** mutex_lock(&g_Mutex)\n", __func__);  // add for debug
+    
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+        DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+        while (i < 5)
+        {
+            mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+            rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 1);
+            if (rc > 0)
+            {
+                DBG(&g_I2cClient->dev, "Get firmware info IicWriteData() success\n");
+            }
+            
+            mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+            rc = IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 10);
+            if (rc > 0)
+            {
+                DBG(&g_I2cClient->dev, "Get firmware info IicReadData() success\n");
+
+                if (szDbBusRxData[1] == FIRMWARE_MODE_DEMO_MODE || szDbBusRxData[1] == FIRMWARE_MODE_DEBUG_MODE)
+                {
+                    break;
+                }
+                else
+                {
+                    i = 0;
+                }
+            }
+
+            i++;
+        }
+        if (i == 5)
+        {
+            DBG(&g_I2cClient->dev, "Get firmware info failed, rc = %d\n", rc);
+        }
+
+        DBG(&g_I2cClient->dev, "*** %s() *** mutex_unlock(&g_Mutex)\n", __func__);  // add for debug
+        mutex_unlock(&g_Mutex);
+    
+        // Add protection for incorrect firmware info check
+        if ((szDbBusRxData[1] == FIRMWARE_MODE_DEBUG_MODE && szDbBusRxData[2] == 0xA7 && szDbBusRxData[5] == PACKET_TYPE_TOOTH_PATTERN) || (szDbBusRxData[1] == FIRMWARE_MODE_DEMO_MODE && szDbBusRxData[2] == 0x5A))
+        {
+            pInfo->nFirmwareMode = szDbBusRxData[1];
+            DBG(&g_I2cClient->dev, "pInfo->nFirmwareMode = 0x%x\n", pInfo->nFirmwareMode);
+
+            pInfo->nLogModePacketHeader = szDbBusRxData[2]; 
+            pInfo->nLogModePacketLength = (szDbBusRxData[3]<<8) + szDbBusRxData[4]; 
+            pInfo->nType = szDbBusRxData[5];
+            pInfo->nMy = szDbBusRxData[6];
+            pInfo->nMx = szDbBusRxData[7];
+            pInfo->nSd = szDbBusRxData[8];
+            pInfo->nSs = szDbBusRxData[9];
+
+            DBG(&g_I2cClient->dev, "pInfo->nLogModePacketHeader = 0x%x\n", pInfo->nLogModePacketHeader);
+            DBG(&g_I2cClient->dev, "pInfo->nLogModePacketLength = %d\n", pInfo->nLogModePacketLength);
+            DBG(&g_I2cClient->dev, "pInfo->nType = 0x%x\n", pInfo->nType);
+            DBG(&g_I2cClient->dev, "pInfo->nMy = %d\n", pInfo->nMy);
+            DBG(&g_I2cClient->dev, "pInfo->nMx = %d\n", pInfo->nMx);
+            DBG(&g_I2cClient->dev, "pInfo->nSd = %d\n", pInfo->nSd);
+            DBG(&g_I2cClient->dev, "pInfo->nSs = %d\n", pInfo->nSs);
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "Firmware info before correcting :\n");
+            
+            DBG(&g_I2cClient->dev, "FirmwareMode = 0x%x\n", szDbBusRxData[1]);
+            DBG(&g_I2cClient->dev, "LogModePacketHeader = 0x%x\n", szDbBusRxData[2]);
+            DBG(&g_I2cClient->dev, "LogModePacketLength = %d\n", (szDbBusRxData[3]<<8) + szDbBusRxData[4]);
+            DBG(&g_I2cClient->dev, "Type = 0x%x\n", szDbBusRxData[5]);
+            DBG(&g_I2cClient->dev, "My = %d\n", szDbBusRxData[6]);
+            DBG(&g_I2cClient->dev, "Mx = %d\n", szDbBusRxData[7]);
+            DBG(&g_I2cClient->dev, "Sd = %d\n", szDbBusRxData[8]);
+            DBG(&g_I2cClient->dev, "Ss = %d\n", szDbBusRxData[9]);
+
+            // Set firmware mode to demo mode(default)
+            pInfo->nFirmwareMode = FIRMWARE_MODE_DEMO_MODE;
+            pInfo->nLogModePacketHeader = 0x5A; 
+            pInfo->nLogModePacketLength = DEMO_MODE_PACKET_LENGTH; 
+            pInfo->nType = 0;
+            pInfo->nMy = 0;
+            pInfo->nMx = 0;
+            pInfo->nSd = 0;
+            pInfo->nSs = 0;
+
+            DBG(&g_I2cClient->dev, "Firmware info after correcting :\n");
+
+            DBG(&g_I2cClient->dev, "pInfo->nFirmwareMode = 0x%x\n", pInfo->nFirmwareMode);
+            DBG(&g_I2cClient->dev, "pInfo->nLogModePacketHeader = 0x%x\n", pInfo->nLogModePacketHeader);
+            DBG(&g_I2cClient->dev, "pInfo->nLogModePacketLength = %d\n", pInfo->nLogModePacketLength);
+            DBG(&g_I2cClient->dev, "pInfo->nType = 0x%x\n", pInfo->nType);
+            DBG(&g_I2cClient->dev, "pInfo->nMy = %d\n", pInfo->nMy);
+            DBG(&g_I2cClient->dev, "pInfo->nMx = %d\n", pInfo->nMx);
+            DBG(&g_I2cClient->dev, "pInfo->nSd = %d\n", pInfo->nSd);
+            DBG(&g_I2cClient->dev, "pInfo->nSs = %d\n", pInfo->nSs);
+        }
+        
+        _gIsDisableFinagerTouch = 0;
+    }
+}
+
+void DrvFwCtrlRestoreFirmwareModeToLogDataMode(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() g_IsSwitchModeByAPK = %d ***\n", __func__, g_IsSwitchModeByAPK);
+
+    if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        if (g_IsSwitchModeByAPK == 1)
+        {
+            SelfFirmwareInfo_t tInfo;
+    
+            memset(&tInfo, 0x0, sizeof(SelfFirmwareInfo_t));
+
+            DrvFwCtrlSelfGetFirmwareInfo(&tInfo);
+
+            DBG(&g_I2cClient->dev, "g_FirmwareMode = 0x%x, tInfo.nFirmwareMode = 0x%x\n", g_FirmwareMode, tInfo.nFirmwareMode);
+
+            // Since reset_hw() will reset the firmware mode to demo mode, we must reset the firmware mode again after reset_hw().
+            if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE && FIRMWARE_MODE_DEBUG_MODE != tInfo.nFirmwareMode)
+            {
+                g_FirmwareMode = DrvFwCtrlChangeFirmwareMode(FIRMWARE_MODE_DEBUG_MODE);
+            }
+            else if (g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE && FIRMWARE_MODE_RAW_DATA_MODE != tInfo.nFirmwareMode)
+            {
+                g_FirmwareMode = DrvFwCtrlChangeFirmwareMode(FIRMWARE_MODE_RAW_DATA_MODE);
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "firmware mode is not restored\n");
+            }
+        }
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG26XXM)
+    {
+        if (g_IsSwitchModeByAPK == 1)
+        {
+            DBG(&g_I2cClient->dev, "g_FirmwareMode = 0x%x\n", g_FirmwareMode);
+
+            // Since reset_hw() will reset the firmware mode to demo mode, we must reset the firmware mode again after reset_hw().
+            if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE && FIRMWARE_MODE_DEMO_MODE == DrvFwCtrlGetFirmwareMode())
+            {
+                g_FirmwareMode = DrvFwCtrlChangeFirmwareMode(FIRMWARE_MODE_DEBUG_MODE);
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "firmware mode is not restored\n");
+            }
+        }
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        if (g_IsSwitchModeByAPK == 1)
+        {
+            MutualFirmwareInfo_t tInfo;
+    
+            memset(&tInfo, 0x0, sizeof(MutualFirmwareInfo_t));
+
+            DrvFwCtrlMutualGetFirmwareInfo(&tInfo);
+
+            DBG(&g_I2cClient->dev, "g_FirmwareMode = 0x%x, tInfo.nFirmwareMode = 0x%x\n", g_FirmwareMode, tInfo.nFirmwareMode);
+
+            // Since reset_hw() will reset the firmware mode to demo mode, we must reset the firmware mode again after reset_hw().
+            if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE && FIRMWARE_MODE_DEBUG_MODE != tInfo.nFirmwareMode)
+            {
+                g_FirmwareMode = DrvFwCtrlChangeFirmwareMode(FIRMWARE_MODE_DEBUG_MODE);
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "firmware mode is not restored\n");
+            }
+        }
+    }
+}	
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+void DrvFwCtrlCheckFirmwareUpdateBySwId(void)
+{
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+    
+    if (g_ChipType == CHIP_TYPE_MSG21XXA)   
+    {
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+        _DrvFwCtrlMsg21xxaCheckFirmwareUpdateBySwId();
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG21XXA
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG22XX)    
+    {
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG22XX
+        _DrvFwCtrlMsg22xxCheckFirmwareUpdateBySwId();
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG22XX        
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG26XXM)   
+    {
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG26XXM
+        _DrvFwCtrlMsg26xxmCheckFirmwareUpdateBySwId();
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG26XXM        
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG28XX)    
+    {
+#ifdef CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+        _DrvFwCtrlMsg28xxCheckFirmwareUpdateBySwId();
+#endif //CONFIG_ENABLE_CHIP_TYPE_MSG28XX
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "This chip type (0x%x) does not support update firmware by sw id\n", g_ChipType);
+    }
+}	
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+void DrvFwCtrlGetTouchPacketAddress(u16* pDataAddress, u16* pFlagAddress)
+{
+    s32 rc = 0;
+    u32 i = 0;
+    u8 szDbBusTxData[1] = {0};
+    u8 szDbBusRxData[4] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    szDbBusTxData[0] = 0x05;
+
+    mutex_lock(&g_Mutex);
+    DBG(&g_I2cClient->dev, "*** %s() *** mutex_lock(&g_Mutex)\n", __func__);  // add for debug
+
+    while (i < 5)
+    {
+        mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+        rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 1);
+        if (rc > 0)
+        {
+            DBG(&g_I2cClient->dev, "Get touch packet address IicWriteData() success\n");
+        }
+
+        mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+        rc = IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+        if (rc > 0)
+        {
+            DBG(&g_I2cClient->dev, "Get touch packet address IicReadData() success\n");
+            break;
+        }
+
+        i++;
+    }
+    if (i == 5)
+    {
+        DBG(&g_I2cClient->dev, "Get touch packet address failed, rc = %d\n", rc);
+    }
+
+    if (rc < 0)
+    {
+        g_FwSupportSegment = 0;
+    }
+    else
+    {
+        *pDataAddress = (szDbBusRxData[0]<<8) + szDbBusRxData[1];
+        *pFlagAddress = (szDbBusRxData[2]<<8) + szDbBusRxData[3];
+
+        g_FwSupportSegment = 1;
+
+        DBG(&g_I2cClient->dev, "*** *pDataAddress = 0x%2X ***\n", *pDataAddress); // add for debug
+        DBG(&g_I2cClient->dev, "*** *pFlagAddress = 0x%2X ***\n", *pFlagAddress); // add for debug
+    }
+
+    DBG(&g_I2cClient->dev, "*** %s() *** mutex_unlock(&g_Mutex)\n", __func__);  // add for debug
+    mutex_unlock(&g_Mutex);
+}
+
+static int _DrvFwCtrlCheckFingerTouchPacketFlagBit1(void)
+{
+    u8 szDbBusTxData[3] = {0};
+    s32 nRetVal;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    szDbBusTxData[0] = 0x53;
+    szDbBusTxData[1] = (g_FwPacketFlagAddress >> 8) & 0xFF;
+    szDbBusTxData[2] = g_FwPacketFlagAddress & 0xFF;
+
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+    IicReadData(SLAVE_I2C_ID_DWI2C, &_gTouchPacketFlag[0], 2);
+
+    if ((_gTouchPacketFlag[0] & BIT1) == 0x00)
+    {
+        nRetVal = 0; // Bit1 is 0
+    }
+    else
+    {
+        nRetVal = 1; // Bit1 is 1
+    }
+    DBG(&g_I2cClient->dev, "Bit1 = %d\n", nRetVal);
+
+    return nRetVal;
+}
+
+static void _DrvFwCtrlResetFingerTouchPacketFlagBit1(void)
+{
+    u8 szDbBusTxData[4] = {0};
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    szDbBusTxData[0] = 0x52;
+    szDbBusTxData[1] = (g_FwPacketFlagAddress >> 8) & 0xFF;
+    szDbBusTxData[2] = g_FwPacketFlagAddress & 0xFF;
+    szDbBusTxData[3] = _gTouchPacketFlag[0] | BIT1;
+
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 4);
+}
+#endif //CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+
+s32 DrvFwCtrlEnableProximity(void)
+{
+    u8 szDbBusTxData[4] = {0};
+    u32 i = 0;
+    s32 rc;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    szDbBusTxData[0] = 0x52;
+    szDbBusTxData[1] = 0x00;
+    
+    if (g_ChipType == CHIP_TYPE_MSG21XX)
+    {
+        szDbBusTxData[2] = 0x62; 
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        szDbBusTxData[2] = 0x4a; 
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        szDbBusTxData[2] = 0x47; 
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "*** Un-recognized chip type = 0x%x ***\n", g_ChipType);
+        return -1;
+    }
+    
+    szDbBusTxData[3] = 0xa0;
+
+    while (i < 5)
+    {
+        mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE); // delay 20ms
+        rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 4);
+        if (rc > 0)
+        {
+            g_EnableTpProximity = 1;
+
+            DBG(&g_I2cClient->dev, "Enable proximity detection success\n");
+            break;
+        }
+
+        i++;
+    }
+    if (i == 5)
+    {
+        DBG(&g_I2cClient->dev, "Enable proximity detection failed, rc = %d\n", rc);
+    }
+    	
+    return rc;
+}
+
+s32 DrvFwCtrlDisableProximity(void)
+{
+    u8 szDbBusTxData[4] = {0};
+    u32 i = 0;
+    s32 rc;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    szDbBusTxData[0] = 0x52;
+    szDbBusTxData[1] = 0x00;
+
+    if (g_ChipType == CHIP_TYPE_MSG21XX)
+    {
+        szDbBusTxData[2] = 0x62; 
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        szDbBusTxData[2] = 0x4a; 
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        szDbBusTxData[2] = 0x47; 
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "*** Un-recognized chip type = 0x%x ***\n", g_ChipType);
+        return -1;
+    }
+
+    szDbBusTxData[3] = 0xa1;
+    
+    while (i < 5)
+    {
+        mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+        rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 4);
+        if (rc > 0)
+        {
+            g_EnableTpProximity = 0;
+
+            DBG(&g_I2cClient->dev, "Disable proximity detection success\n");
+            break;
+        }
+
+        i++;
+    }
+    if (i == 5)
+    {
+        DBG(&g_I2cClient->dev, "Disable proximity detection failed, rc = %d\n", rc);
+    }
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    g_FaceClosingTp = 0;
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM || CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM
+
+    return rc;
+}
+
+#endif //CONFIG_ENABLE_PROXIMITY_DETECTION
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+void DrvFwCtrlOpenGloveMode(void) // used for MSG28xx only
+{
+    s32 rc = 0;
+    u8 szDbBusTxData[3] = {0};
+    u32 i = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    _gIsDisableFinagerTouch = 1; // Disable finger touch ISR handling temporarily for device driver can send change firmware mode i2c command to firmware.
+
+    szDbBusTxData[0] = 0x06;
+    szDbBusTxData[1] = 0x01;
+    szDbBusTxData[2] = 0x01;
+
+    mutex_lock(&g_Mutex);
+
+    while (i < 5)
+    {
+       mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+       rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+       if (rc > 0)
+       {
+           DBG(&g_I2cClient->dev, "Open glove mode success\n");
+           break;
+       }
+
+       i++;
+    }
+    if (i == 5)
+    {
+      	DBG(&g_I2cClient->dev, "Open glove mode failed, rc = %d\n", rc);
+    }
+
+    mutex_unlock(&g_Mutex);
+
+    _gIsDisableFinagerTouch = 0;
+}
+
+void DrvFwCtrlCloseGloveMode(void) // used for MSG28xx only
+{
+    s32 rc = 0;
+    u8 szDbBusTxData[3] = {0};
+    u32 i = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    _gIsDisableFinagerTouch = 1; // Disable finger touch ISR handling temporarily for device driver can send change firmware mode i2c command to firmware.
+
+    szDbBusTxData[0] = 0x06;
+    szDbBusTxData[1] = 0x01;
+    szDbBusTxData[2] = 0x00;
+
+    mutex_lock(&g_Mutex);
+
+    while (i < 5)
+    {
+       mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+       rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+       if (rc > 0)
+       {
+           DBG(&g_I2cClient->dev, "Close glove mode success\n");
+           break;
+       }
+
+       i++;
+    }
+    if (i == 5)
+    {
+      	DBG(&g_I2cClient->dev, "Close glove mode failed, rc = %d\n", rc);
+    }
+
+    mutex_unlock(&g_Mutex);
+
+    _gIsDisableFinagerTouch = 0;
+}
+
+void DrvFwCtrlGetGloveInfo(u8 *pGloveMode) // used for MSG28xx only
+{
+    u8 szDbBusTxData[3] = {0};
+    u8 szDbBusRxData[2] = {0};
+    u32 i = 0;
+    s32 rc;
+
+    _gIsDisableFinagerTouch = 1; // Disable finger touch ISR handling temporarily for device driver can send get firmware info i2c command to firmware.
+
+    szDbBusTxData[0] = 0x06;
+    szDbBusTxData[1] = 0x01;
+    szDbBusTxData[2] = 0x02;
+
+    mutex_lock(&g_Mutex);
+
+    while (i < 5)
+    {
+        mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+        rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+        if (rc > 0)
+        {
+            DBG(&g_I2cClient->dev, "Get glove info IicWriteData() success\n");
+        }
+        
+        mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+        rc = IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 1);
+        if (rc > 0)
+        {
+            DBG(&g_I2cClient->dev, "Get glove info IicReadData() success\n");
+
+            if (szDbBusRxData[0] == 0x00 || szDbBusRxData[0] == 0x01)
+            {
+                break;
+            }
+            else
+            {
+                i = 0;
+            }
+        }
+
+        i++;
+    }
+    if (i == 5)
+    {
+        DBG(&g_I2cClient->dev, "Get glove info failed, rc = %d\n", rc);
+    }
+
+    mutex_unlock(&g_Mutex);
+
+    *pGloveMode = szDbBusRxData[0];
+    
+    DBG(&g_I2cClient->dev, "pGloveMode = 0x%x\n", *pGloveMode);
+
+    _gIsDisableFinagerTouch = 0;
+}
+
+#endif //CONFIG_ENABLE_GLOVE_MODE
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION
+
+void DrvFwCtrlChargerDetection(u8 nChargerStatus)
+{
+    u32 i = 0;
+    u8 szDbBusTxData[2] = {0};
+    s32 rc = 0;
+
+    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);
+
+    DBG(&g_I2cClient->dev, "_gChargerPlugIn = %d, nChargerStatus = %d, g_ForceUpdate = %d\n", _gChargerPlugIn, nChargerStatus, g_ForceUpdate);
+
+    mutex_lock(&g_Mutex);
+    
+    szDbBusTxData[0] = 0x09;
+
+    if (nChargerStatus) // charger plug in
+    {
+        if (_gChargerPlugIn == 0 || g_ForceUpdate == 1)
+        {
+          	szDbBusTxData[1] = 0xA5;
+            
+            while (i < 5)
+            {
+                mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+                rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 2);
+                if (rc > 0)
+                {
+                    _gChargerPlugIn = 1;
+
+                    DBG(&g_I2cClient->dev, "Update status for charger plug in success.\n");
+                    break;
+                }
+
+                i ++;
+            }
+            if (i == 5)
+            {
+                DBG(&g_I2cClient->dev, "Update status for charger plug in failed, rc = %d\n", rc);
+            }
+
+            g_ForceUpdate = 0; // Clear flag after force update charger status
+        }
+    }
+    else  // charger plug out
+    {
+        if (_gChargerPlugIn == 1 || g_ForceUpdate == 1)
+        {
+          	szDbBusTxData[1] = 0x5A;
+            
+            while (i < 5)
+            {
+                mdelay(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+                rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 2);
+                if (rc > 0)
+                {
+                    _gChargerPlugIn = 0;
+
+                    DBG(&g_I2cClient->dev, "Update status for charger plug out success.\n");
+                    break;
+                }
+                
+                i ++;
+            }
+            if (i == 5)
+            {
+                DBG(&g_I2cClient->dev, "Update status for charger plug out failed, rc = %d\n", rc);
+            }
+
+            g_ForceUpdate = 0; // Clear flag after force update charger status
+        }
+    }	
+
+    mutex_unlock(&g_Mutex);
+}	
+
+#endif //CONFIG_ENABLE_CHARGER_DETECTION
+
+//------------------------------------------------------------------------------//
+
+static s32 _DrvFwCtrlReadFingerTouchData(u8 *pPacket, u16 nReportPacketLength)
+{
+    s32 rc;
+
+    if (IS_FIRMWARE_DATA_LOG_ENABLED)
+    {	
+        if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE)
+        {
+            rc = IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+            if (rc < 0)
+            {
+                DBG(&g_I2cClient->dev, "I2C read packet data failed, rc = %d\n", rc);
+                return -1;
+            }
+        }
+        else if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE)
+        {
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+            DBG(&g_I2cClient->dev, "*** g_FwPacketDataAddress = 0x%2X ***\n", g_FwPacketDataAddress); // add for debug
+            DBG(&g_I2cClient->dev, "*** g_FwPacketFlagAddress = 0x%2X ***\n", g_FwPacketFlagAddress); // add for debug
+
+            if (g_FwSupportSegment == 0)
+            {
+                DBG(&g_I2cClient->dev, "g_FwPacketDataAddress & g_FwPacketFlagAddress is un-initialized\n");
+                return -1;
+            }
+
+            if (_gIsDisableFinagerTouch == 1)
+            {
+                DBG(&g_I2cClient->dev, "Skip finger touch for handling get firmware info or change firmware mode\n");
+                return -1;
+            }
+
+            rc = IicSegmentReadDataBySmBus(g_FwPacketDataAddress, &pPacket[0], nReportPacketLength, MAX_I2C_TRANSACTION_LENGTH_LIMIT);
+
+            _DrvFwCtrlCheckFingerTouchPacketFlagBit1();
+            _DrvFwCtrlResetFingerTouchPacketFlagBit1();
+
+            if (rc < 0)
+            {
+                DBG(&g_I2cClient->dev, "I2C read debug mode packet data failed, rc = %d\n", rc);
+                return -1;
+            }
+#else
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+            mdelay(I2C_SMBUS_READ_COMMAND_DELAY_FOR_SPRD_PLATFORM);
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM
+
+            rc = IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+            if (rc < 0)
+            {
+                DBG(&g_I2cClient->dev, "I2C read packet data failed, rc = %d\n", rc);
+                return -1;
+            }
+#endif //CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA    		
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "WRONG FIRMWARE MODE : 0x%x\n", g_FirmwareMode);
+            return -1;
+        }
+    }
+    else
+    {	
+        rc = IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+        if (rc < 0)
+        {
+            DBG(&g_I2cClient->dev, "I2C read packet data failed, rc = %d\n", rc);
+            return -1;
+        }
+    } //IS_FIRMWARE_DATA_LOG_ENABLED	
+
+    return 0;
+}
+
+//------------------------------------------------------------------------------//
+
+void _DrvFwCtrlSelfHandleFingerTouch(void) // for MSG21xxA/MSG22xx
+{
+    SelfTouchInfo_t tInfo;
+    u32 i;
+#ifdef CONFIG_TP_HAVE_KEY
+    u8 nTouchKeyCode = 0;
+#endif //CONFIG_TP_HAVE_KEY
+    static u32 nLastKeyCode = 0;
+    u8 *pPacket = NULL;
+    u16 nReportPacketLength = 0;
+    s32 rc;
+
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);  // add for debug
+    
+    if (_gIsDisableFinagerTouch == 1)
+    {
+        DBG(&g_I2cClient->dev, "Skip finger touch for handling get firmware info or change firmware mode\n");
+        return;
+    }
+    
+    mutex_lock(&g_Mutex);
+//    DBG(&g_I2cClient->dev, "*** %s() *** mutex_lock(&g_Mutex)\n", __func__);  // add for debug
+
+    memset(&tInfo, 0x0, sizeof(SelfTouchInfo_t));
+
+    if (IS_FIRMWARE_DATA_LOG_ENABLED)
+    { 	
+        if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE)
+        {
+            DBG(&g_I2cClient->dev, "FIRMWARE_MODE_DEMO_MODE\n");
+
+            nReportPacketLength = DEMO_MODE_PACKET_LENGTH;
+            pPacket = g_DemoModePacket;
+        }
+        else if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE)
+        {
+            DBG(&g_I2cClient->dev, "FIRMWARE_MODE_DEBUG_MODE\n");
+
+            if (g_SelfFirmwareInfo.nLogModePacketHeader != 0x62)
+            {
+                DBG(&g_I2cClient->dev, "WRONG DEBUG MODE HEADER : 0x%x\n", g_SelfFirmwareInfo.nLogModePacketHeader);
+                goto TouchHandleEnd;		
+            }
+
+            nReportPacketLength = g_SelfFirmwareInfo.nLogModePacketLength;
+            pPacket = g_LogModePacket;
+        }
+        else if (g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE)
+        {
+            DBG(&g_I2cClient->dev, "FIRMWARE_MODE_RAW_DATA_MODE\n");
+
+            if (g_SelfFirmwareInfo.nLogModePacketHeader != 0x62)
+            {
+                DBG(&g_I2cClient->dev, "WRONG RAW DATA MODE HEADER : 0x%x\n", g_SelfFirmwareInfo.nLogModePacketHeader);
+                goto TouchHandleEnd;		
+            }
+
+            nReportPacketLength = g_SelfFirmwareInfo.nLogModePacketLength;
+            pPacket = g_LogModePacket;
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "WRONG FIRMWARE MODE : 0x%x\n", g_FirmwareMode);
+            goto TouchHandleEnd;		
+        }
+    }
+    else
+    {
+        DBG(&g_I2cClient->dev, "FIRMWARE_MODE_DEMO_MODE\n");
+
+        nReportPacketLength = DEMO_MODE_PACKET_LENGTH;
+        pPacket = g_DemoModePacket;
+    } //IS_FIRMWARE_DATA_LOG_ENABLED
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+    if (g_GestureDebugMode == 1 && g_GestureWakeupFlag == 1)
+    {
+        DBG(&g_I2cClient->dev, "Set gesture debug mode packet length, g_ChipType=0x%x\n", g_ChipType);
+
+        if (g_ChipType == CHIP_TYPE_MSG22XX)
+        {
+            nReportPacketLength = GESTURE_DEBUG_MODE_PACKET_LENGTH;
+            pPacket = _gGestureWakeupPacket;
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "This chip type does not support gesture debug mode.\n");
+            goto TouchHandleEnd;		
+        }
+    }
+    else if (g_GestureWakeupFlag == 1)
+    {
+        DBG(&g_I2cClient->dev, "Set gesture wakeup packet length, g_ChipType=0x%x\n", g_ChipType);
+      
+        if (g_ChipType == CHIP_TYPE_MSG22XX)
+        {
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+            nReportPacketLength = GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH;
+#else
+            nReportPacketLength = GESTURE_WAKEUP_PACKET_LENGTH;
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+            pPacket = _gGestureWakeupPacket;
+        }
+        else if (g_ChipType == CHIP_TYPE_MSG21XXA)
+        {
+            nReportPacketLength = DEMO_MODE_PACKET_LENGTH;
+            pPacket = _gGestureWakeupPacket;
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "This chip type does not support gesture wakeup.\n");
+            goto TouchHandleEnd;
+        }
+    }
+
+#else
+
+    if (g_GestureWakeupFlag == 1)
+    {
+        DBG(&g_I2cClient->dev, "Set gesture wakeup packet length, g_ChipType=0x%x\n", g_ChipType);
+        
+        if (g_ChipType == CHIP_TYPE_MSG22XX)
+        {
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+            nReportPacketLength = GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH;
+#else
+            nReportPacketLength = GESTURE_WAKEUP_PACKET_LENGTH;
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+
+            pPacket = _gGestureWakeupPacket;
+        } 
+        else if (g_ChipType == CHIP_TYPE_MSG21XXA)
+        {
+            nReportPacketLength = DEMO_MODE_PACKET_LENGTH;
+            pPacket = _gGestureWakeupPacket;
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "This chip type does not support gesture wakeup.\n");
+            goto TouchHandleEnd;		
+        }
+    }
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (g_GestureWakeupFlag == 1)
+    {
+        u32 i = 0;
+        
+        while (i < 5)
+        {
+            mdelay(50);
+
+            rc = IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+            
+            if (rc > 0)
+            {
+                break;
+            }
+            
+            i ++;
+        }
+        if (i == 5)
+        {
+            DBG(&g_I2cClient->dev, "I2C read packet data failed, rc = %d\n", rc);
+            goto TouchHandleEnd;		
+        }
+    }
+    else
+    {
+        rc = IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+        if (rc < 0)
+        {
+            DBG(&g_I2cClient->dev, "I2C read packet data failed, rc = %d\n", rc);
+            goto TouchHandleEnd;		
+        }
+    }
+#else
+    rc = IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+    if (rc < 0)
+    {
+        DBG(&g_I2cClient->dev, "I2C read packet data failed, rc = %d\n", rc);
+        goto TouchHandleEnd;		
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP   
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    rc = IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+    if (rc < 0)
+    {
+        DBG(&g_I2cClient->dev, "I2C read packet data failed, rc = %d\n", rc);
+        goto TouchHandleEnd;		
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    if (nReportPacketLength > 8)
+    {
+#ifdef CONFIG_ENABLE_DMA_IIC
+        DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+        rc = IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+    }
+    else
+    {
+        rc = IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+    }
+
+    if (rc < 0)
+    {
+        DBG(&g_I2cClient->dev, "I2C read packet data failed, rc = %d\n", rc);
+        goto TouchHandleEnd;		
+    }
+#endif
+    
+    if (0 == _DrvFwCtrlSelfParsePacket(pPacket, nReportPacketLength, &tInfo))
+    {
+        //report...
+        if ((tInfo.nFingerNum) == 0)   //touch end
+        {
+            if (nLastKeyCode != 0)
+            {
+                DBG(&g_I2cClient->dev, "key touch released\n");
+
+                input_report_key(g_InputDevice, BTN_TOUCH, 0);
+                input_report_key(g_InputDevice, nLastKeyCode, 0);
+
+                input_sync(g_InputDevice);
+                    
+                nLastKeyCode = 0; //clear key status..
+            }
+            else
+            {
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL // TYPE B PROTOCOL
+                for (i = 0; i < MAX_TOUCH_NUM; i ++) 
+                {
+                    DrvPlatformLyrFingerTouchReleased(0, 0, i);
+                }
+
+                input_report_key(g_InputDevice, BTN_TOUCH, 0);
+                input_report_key(g_InputDevice, BTN_TOOL_FINGER, 0);
+#else // TYPE A PROTOCOL
+                DrvPlatformLyrFingerTouchReleased(0, 0, 0);
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+                input_sync(g_InputDevice);
+            }
+        }
+        else //touch on screen
+        {
+            if (tInfo.nTouchKeyCode != 0)
+            {
+#ifdef CONFIG_TP_HAVE_KEY
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+                if (tInfo.nTouchKeyCode == 4) // TOUCH_KEY_HOME
+                {
+                    nTouchKeyCode = g_TpVirtualKey[1];           
+                }
+                else if (tInfo.nTouchKeyCode == 1) // TOUCH_KEY_MENU
+                {
+                    nTouchKeyCode = g_TpVirtualKey[0];
+                }           
+                else if (tInfo.nTouchKeyCode == 2) // TOUCH_KEY_BACK
+                {
+                    nTouchKeyCode = g_TpVirtualKey[2];
+                }           
+                else if (tInfo.nTouchKeyCode == 8) // TOUCH_KEY_SEARCH 
+                {	
+                    nTouchKeyCode = g_TpVirtualKey[3];           
+                }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+                if (tpd_dts_data.use_tpd_button)
+                {
+                    if (tInfo.nTouchKeyCode == 4) // TOUCH_KEY_HOME
+                    {
+                        nTouchKeyCode = tpd_dts_data.tpd_key_local[1];           
+                    }
+                    else if (tInfo.nTouchKeyCode == 1) // TOUCH_KEY_MENU
+                    {
+                        nTouchKeyCode = tpd_dts_data.tpd_key_local[0];
+                    }           
+                    else if (tInfo.nTouchKeyCode == 2) // TOUCH_KEY_BACK
+                    {
+                        nTouchKeyCode = tpd_dts_data.tpd_key_local[2];
+                    }           
+                    else if (tInfo.nTouchKeyCode == 8) // TOUCH_KEY_SEARCH 
+                    {	
+                        nTouchKeyCode = tpd_dts_data.tpd_key_local[3];           
+                    }
+                }
+#else
+                if (tInfo.nTouchKeyCode == 4) // TOUCH_KEY_HOME
+                {
+                    nTouchKeyCode = g_TpVirtualKey[1];           
+                }
+                else if (tInfo.nTouchKeyCode == 1) // TOUCH_KEY_MENU
+                {
+                    nTouchKeyCode = g_TpVirtualKey[0];
+                }           
+                else if (tInfo.nTouchKeyCode == 2) // TOUCH_KEY_BACK
+                {
+                    nTouchKeyCode = g_TpVirtualKey[2];
+                }           
+                else if (tInfo.nTouchKeyCode == 8) // TOUCH_KEY_SEARCH 
+                {	
+                    nTouchKeyCode = g_TpVirtualKey[3];           
+                }
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#endif
+
+                if (nLastKeyCode != nTouchKeyCode)
+                {
+                    DBG(&g_I2cClient->dev, "key touch pressed\n");
+                    DBG(&g_I2cClient->dev, "nTouchKeyCode = %d, nLastKeyCode = %d\n", nTouchKeyCode, nLastKeyCode);
+                    
+                    nLastKeyCode = nTouchKeyCode;
+
+                    input_report_key(g_InputDevice, BTN_TOUCH, 1);
+                    input_report_key(g_InputDevice, nTouchKeyCode, 1);
+
+                    input_sync(g_InputDevice);
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL 
+                    _gPrevTouchStatus = 0;
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+                }
+#endif //CONFIG_TP_HAVE_KEY
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "tInfo->nFingerNum = %d...............\n", tInfo.nFingerNum);
+                
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+                for (i = 0; i < MAX_TOUCH_NUM; i ++) 
+                {
+                    if (tInfo.nFingerNum != 0)
+                    {
+                        if (_gCurrPress[i])
+                        {
+                            DrvPlatformLyrFingerTouchPressed(tInfo.tPoint[i].nX, tInfo.tPoint[i].nY, 0, i);
+
+                            input_report_key(g_InputDevice, BTN_TOUCH, 1);
+                            input_report_key(g_InputDevice, BTN_TOOL_FINGER, 1);
+                        }
+                        else
+                        {
+                            DrvPlatformLyrFingerTouchReleased(0, 0, i);
+                        }
+                    }
+                }
+#else // TYPE A PROTOCOL
+                for (i = 0; i < tInfo.nFingerNum; i ++) 
+                {
+                    DrvPlatformLyrFingerTouchPressed(tInfo.tPoint[i].nX, tInfo.tPoint[i].nY, 0, 0);
+                }
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+                input_sync(g_InputDevice);
+            }
+        }
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+        if (g_IsEnableReportRate == 1)
+        {
+            if (g_ValidTouchCount == 4294967295)
+            {
+                g_ValidTouchCount = 0; // Reset count if overflow
+                DBG(&g_I2cClient->dev, "g_ValidTouchCount reset to 0\n");
+            } 	
+
+            g_ValidTouchCount ++;
+
+            DBG(&g_I2cClient->dev, "g_ValidTouchCount = %d\n", g_ValidTouchCount);
+        }
+#endif //CONFIG_ENABLE_COUNT_REPORT_RATE
+    }
+
+    TouchHandleEnd: 
+    	
+//    DBG(&g_I2cClient->dev, "*** %s() *** mutex_unlock(&g_Mutex)\n", __func__);  // add for debug
+    mutex_unlock(&g_Mutex);
+}
+
+void _DrvFwCtrlMutualHandleFingerTouch(void) // for MSG26xxM/MSG28xx
+{
+    MutualTouchInfo_t tInfo;
+    u32 i = 0;
+#ifdef CONFIG_TP_HAVE_KEY
+    static u32 nLastKeyCode = 0xFF;
+#endif //CONFIG_TP_HAVE_KEY
+    static u32 nLastCount = 0;
+    u8 *pPacket = NULL;
+    u16 nReportPacketLength = 0;
+
+//    DBG(&g_I2cClient->dev, "*** %s() ***\n", __func__);  // add for debug
+    
+    if (_gIsDisableFinagerTouch == 1)
+    {
+        DBG(&g_I2cClient->dev, "Skip finger touch for handling get firmware info or change firmware mode\n");
+        return;
+    }
+
+    mutex_lock(&g_Mutex); 
+//    DBG(&g_I2cClient->dev, "*** %s() *** mutex_lock(&g_Mutex)\n", __func__);  // add for debug
+
+    memset(&tInfo, 0x0, sizeof(MutualTouchInfo_t));
+
+    if (IS_FIRMWARE_DATA_LOG_ENABLED)
+    {	
+        if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE)
+        {
+#ifdef CONFIG_ENABLE_HOTKNOT    //demo mode
+            if (g_HotKnotState == HOTKNOT_TRANS_STATE)             
+            {
+                nReportPacketLength = DEMO_HOTKNOT_SEND_RET_LEN;
+                pPacket = g_DemoModeHotKnotSndRetPacket;
+            }
+            else
+#endif //CONFIG_ENABLE_HOTKNOT		
+            {
+                DBG(&g_I2cClient->dev, "FIRMWARE_MODE_DEMO_MODE\n");
+
+                nReportPacketLength = DEMO_MODE_PACKET_LENGTH;
+                pPacket = g_DemoModePacket;
+            }
+        }
+        else if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE)
+        {
+            DBG(&g_I2cClient->dev, "FIRMWARE_MODE_DEBUG_MODE\n");
+
+            if (g_MutualFirmwareInfo.nLogModePacketHeader != 0xA5 && g_MutualFirmwareInfo.nLogModePacketHeader != 0xAB && g_MutualFirmwareInfo.nLogModePacketHeader != 0xA7)
+            {
+                DBG(&g_I2cClient->dev, "WRONG DEBUG MODE HEADER : 0x%x\n", g_MutualFirmwareInfo.nLogModePacketHeader);
+                goto TouchHandleEnd;		
+            }
+        
+#ifdef CONFIG_ENABLE_HOTKNOT    //debug mode
+            if (g_HotKnotState == HOTKNOT_TRANS_STATE)             
+            {
+                nReportPacketLength = DEBUG_HOTKNOT_SEND_RET_LEN;
+                pPacket = g_DebugModeHotKnotSndRetPacket;        
+            }
+            else
+#endif //CONFIG_ENABLE_HOTKNOT	            
+            {
+                nReportPacketLength = g_MutualFirmwareInfo.nLogModePacketLength;
+                pPacket = g_LogModePacket;
+            }
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "WRONG FIRMWARE MODE : 0x%x\n", g_FirmwareMode);
+            goto TouchHandleEnd;		
+        }
+    }
+    else
+    {
+#ifdef CONFIG_ENABLE_HOTKNOT    //demo mode
+        if (g_HotKnotState == HOTKNOT_TRANS_STATE)			  
+        {
+            nReportPacketLength = DEMO_HOTKNOT_SEND_RET_LEN;
+            pPacket = g_DemoModeHotKnotSndRetPacket;
+        }
+        else
+#endif //CONFIG_ENABLE_HOTKNOT        
+        {
+            DBG(&g_I2cClient->dev, "FIRMWARE_MODE_DEMO_MODE\n");
+
+            nReportPacketLength = DEMO_MODE_PACKET_LENGTH;
+            pPacket = g_DemoModePacket;
+        }
+    } //IS_FIRMWARE_DATA_LOG_ENABLED
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+    if (g_GestureDebugMode == 1 && g_GestureWakeupFlag == 1)
+    {
+        DBG(&g_I2cClient->dev, "Set gesture debug mode packet length, g_ChipType=0x%x\n", g_ChipType);
+
+        if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX) 
+        {
+            nReportPacketLength = GESTURE_DEBUG_MODE_PACKET_LENGTH;
+            pPacket = _gGestureWakeupPacket;
+        }
+        else
+        {
+            DBG(&g_I2cClient->dev, "This chip type does not support gesture debug mode.\n");
+            goto TouchHandleEnd;		
+        }
+    }
+    else if (g_GestureWakeupFlag == 1)
+    {
+        DBG(&g_I2cClient->dev, "Set gesture wakeup packet length\n");
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+        nReportPacketLength = GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH;
+#else
+        nReportPacketLength = GESTURE_WAKEUP_PACKET_LENGTH;
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+
+        pPacket = _gGestureWakeupPacket;
+    }
+
+#else
+
+    if (g_GestureWakeupFlag == 1)
+    {
+        DBG(&g_I2cClient->dev, "Set gesture wakeup packet length\n");
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+        nReportPacketLength = GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH;
+#else
+        nReportPacketLength = GESTURE_WAKEUP_PACKET_LENGTH;
+#endif //CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+
+        pPacket = _gGestureWakeupPacket;
+    }
+#endif //CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (g_GestureWakeupFlag == 1)
+    {
+        s32 rc;
+        
+        while (i < 5)
+        {
+            mdelay(50);
+
+            rc = IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+            if (rc > 0)
+            {
+                break;
+            }
+            
+            i ++;
+        }
+        if (i == 5)
+        {
+            DBG(&g_I2cClient->dev, "I2C read packet data failed, rc = %d\n", rc);
+            goto TouchHandleEnd;		
+        }
+    }
+    else
+    {
+        if (0 != _DrvFwCtrlReadFingerTouchData(&pPacket[0], nReportPacketLength))
+        {
+            goto TouchHandleEnd;		
+        }
+    }
+#else
+    if (0 != _DrvFwCtrlReadFingerTouchData(&pPacket[0], nReportPacketLength))
+    {
+         goto TouchHandleEnd;		
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP   
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    if (0 != _DrvFwCtrlReadFingerTouchData(&pPacket[0], nReportPacketLength))
+    {
+        goto TouchHandleEnd;		
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    {
+        s32 nRetVal = 0;
+        
+#ifdef CONFIG_ENABLE_DMA_IIC
+        DmaReset();
+#endif //CONFIG_ENABLE_DMA_IIC
+        
+        nRetVal = _DrvFwCtrlReadFingerTouchData(&pPacket[0], nReportPacketLength);
+        if (0 != nRetVal)
+        {
+            goto TouchHandleEnd;		
+        }
+    }
+#endif
+
+    if (0 == _DrvFwCtrlMutualParsePacket(pPacket, nReportPacketLength, &tInfo))
+    {
+#ifdef CONFIG_TP_HAVE_KEY
+        if (tInfo.nKeyCode != 0xFF)   //key touch pressed
+        {
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+            DBG(&g_I2cClient->dev, "tInfo.nKeyCode=%x, nLastKeyCode=%x, g_TpVirtualKey[%d]=%d\n", tInfo.nKeyCode, nLastKeyCode, tInfo.nKeyCode, g_TpVirtualKey[tInfo.nKeyCode]);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+            if (tpd_dts_data.use_tpd_button)
+            {
+                DBG(&g_I2cClient->dev, "tInfo.nKeyCode=%x, nLastKeyCode=%x, tpd_dts_data.tpd_key_local[%d]=%d\n", tInfo.nKeyCode, nLastKeyCode, tInfo.nKeyCode, tpd_dts_data.tpd_key_local[tInfo.nKeyCode]);
+            }
+#else
+            DBG(&g_I2cClient->dev, "tInfo.nKeyCode=%x, nLastKeyCode=%x, g_TpVirtualKey[%d]=%d\n", tInfo.nKeyCode, nLastKeyCode, tInfo.nKeyCode, g_TpVirtualKey[tInfo.nKeyCode]);
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#endif   
+         
+            if (tInfo.nKeyCode < MAX_KEY_NUM)
+            {
+                if (tInfo.nKeyCode != nLastKeyCode)
+                {
+                    DBG(&g_I2cClient->dev, "key touch pressed\n");
+
+                    input_report_key(g_InputDevice, BTN_TOUCH, 1);
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+                    input_report_key(g_InputDevice, g_TpVirtualKey[tInfo.nKeyCode], 1);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+                    if (tpd_dts_data.use_tpd_button)
+                    {
+                        input_report_key(g_InputDevice, tpd_dts_data.tpd_key_local[tInfo.nKeyCode], 1);
+                    }
+#else
+                    input_report_key(g_InputDevice, g_TpVirtualKey[tInfo.nKeyCode], 1);
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#endif   
+                    input_sync(g_InputDevice);
+
+                    nLastKeyCode = tInfo.nKeyCode;
+                }
+                else
+                {
+                    /// pass duplicate key-pressing
+                    DBG(&g_I2cClient->dev, "REPEATED KEY\n");
+                }
+            }
+            else
+            {
+                DBG(&g_I2cClient->dev, "WRONG KEY\n");
+            }
+        }
+        else                        //key touch released
+        {
+            if (nLastKeyCode != 0xFF)
+            {
+                DBG(&g_I2cClient->dev, "key touch released\n");
+
+                input_report_key(g_InputDevice, BTN_TOUCH, 0);
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+                input_report_key(g_InputDevice, g_TpVirtualKey[nLastKeyCode], 0);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+#ifdef CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+                if (tpd_dts_data.use_tpd_button)
+                {
+                    input_report_key(g_InputDevice, tpd_dts_data.tpd_key_local[nLastKeyCode], 0);
+                }
+#else
+                input_report_key(g_InputDevice, g_TpVirtualKey[nLastKeyCode], 0);
+#endif //CONFIG_PLATFORM_USE_ANDROID_SDK_6_UPWARD
+#endif   
+                input_sync(g_InputDevice);
+                
+                nLastKeyCode = 0xFF;
+            }
+        }
+#endif //CONFIG_TP_HAVE_KEY
+
+        DBG(&g_I2cClient->dev, "tInfo.nCount = %d, nLastCount = %d\n", tInfo.nCount, nLastCount);
+
+        if (tInfo.nCount > 0)          //point touch pressed
+        {
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+            for (i = 0; i < tInfo.nCount; i ++)
+            {
+                DrvPlatformLyrFingerTouchPressed(tInfo.tPoint[i].nX, tInfo.tPoint[i].nY, tInfo.tPoint[i].nP, tInfo.tPoint[i].nId);
+
+                input_report_key(g_InputDevice, BTN_TOUCH, 1); 
+                input_report_key(g_InputDevice, BTN_TOOL_FINGER, 1); 	
+            }
+
+            for (i = 0; i < MAX_TOUCH_NUM; i ++)
+            {
+                DBG(&g_I2cClient->dev, "_gPreviousTouch[%d]=%d, _gCurrentTouch[%d]=%d\n", i, _gPreviousTouch[i], i, _gCurrentTouch[i]); // TODO : add for debug
+
+                if (_gCurrentTouch[i] == 0 && _gPreviousTouch[i] == 1)
+                {
+                    DrvPlatformLyrFingerTouchReleased(0, 0, i);
+                }
+                _gPreviousTouch[i] = _gCurrentTouch[i];
+            }
+#else // TYPE A PROTOCOL
+            for (i = 0; i < tInfo.nCount; i ++)
+            {
+                DrvPlatformLyrFingerTouchPressed(tInfo.tPoint[i].nX, tInfo.tPoint[i].nY, tInfo.tPoint[i].nP, tInfo.tPoint[i].nId);
+            }
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+            input_sync(g_InputDevice);
+
+            nLastCount = tInfo.nCount;
+        }
+        else                        //point touch released
+        {
+            if (nLastCount > 0)
+            {
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL // TYPE B PROTOCOL
+                for (i = 0; i < MAX_TOUCH_NUM; i ++)
+                {
+                    DBG(&g_I2cClient->dev, "_gPreviousTouch[%d]=%d, _gCurrentTouch[%d]=%d\n", i, _gPreviousTouch[i], i, _gCurrentTouch[i]); // TODO : add for debug
+
+                    if (_gCurrentTouch[i] == 0 && _gPreviousTouch[i] == 1)
+                    {
+                        DrvPlatformLyrFingerTouchReleased(0, 0, i);
+                    }
+                    _gPreviousTouch[i] = _gCurrentTouch[i];
+                }
+
+                input_report_key(g_InputDevice, BTN_TOUCH, 0);                      
+                input_report_key(g_InputDevice, BTN_TOOL_FINGER, 0); 	
+#else // TYPE A PROTOCOL
+                DrvPlatformLyrFingerTouchReleased(0, 0, 0);
+#endif //CONFIG_ENABLE_TYPE_B_PROTOCOL
+    
+                input_sync(g_InputDevice);
+
+                nLastCount = 0;
+            }
+        }
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+        if (g_IsEnableReportRate == 1)
+        {
+            if (g_ValidTouchCount == 4294967295)
+            {
+                g_ValidTouchCount = 0; // Reset count if overflow
+                DBG(&g_I2cClient->dev, "g_ValidTouchCount reset to 0\n");
+            } 	
+
+            g_ValidTouchCount ++;
+
+            DBG(&g_I2cClient->dev, "g_ValidTouchCount = %d\n", g_ValidTouchCount);
+        }
+#endif //CONFIG_ENABLE_COUNT_REPORT_RATE
+    }
+
+    TouchHandleEnd: 
+    	
+//    DBG(&g_I2cClient->dev, "*** %s() *** mutex_unlock(&g_Mutex)\n", __func__);  // add for debug
+    mutex_unlock(&g_Mutex);
+}
+
+void DrvFwCtrlHandleFingerTouch(void)
+{
+    if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        _DrvFwCtrlSelfHandleFingerTouch();
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG26XXM || g_ChipType == CHIP_TYPE_MSG28XX)
+    {
+        _DrvFwCtrlMutualHandleFingerTouch();
+    }
+}
\ No newline at end of file
