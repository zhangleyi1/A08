Index: kernel/kernel/events/core.c
===================================================================
--- kernel/kernel/events/core.c	(revision 182213)
+++ kernel/kernel/events/core.c	(revision 182214)
@@ -6229,7 +6229,6 @@
 		__perf_event_init_context(&cpuctx->ctx);
 		lockdep_set_class(&cpuctx->ctx.mutex, &cpuctx_mutex);
 		lockdep_set_class(&cpuctx->ctx.lock, &cpuctx_lock);
-		cpuctx->ctx.type = cpu_context;
 		cpuctx->ctx.pmu = pmu;
 		cpuctx->jiffies_interval = 1;
 		INIT_LIST_HEAD(&cpuctx->rotation_list);
@@ -6839,8 +6838,20 @@
 		 * task or CPU context:
 		 */
 		if (move_group) {
-			if (group_leader->ctx->type != ctx->type)
+			/*
+			 * Make sure we're both on the same task, or both
+			 * per-cpu events.
+			 */
+			if (group_leader->ctx->task != ctx->task)
 				goto err_context;
+
+			/*
+			 * Make sure we're both events for the same CPU;
+			 * grouping events for different CPUs is broken; since
+			 * you can never concurrently schedule them anyhow.
+			 */
+			if (group_leader->cpu != event->cpu)
+				goto err_context;
 		} else {
 			if (group_leader->ctx != ctx)
 				goto err_context;
Index: kernel/kernel/fork.c
===================================================================
--- kernel/kernel/fork.c	(revision 182213)
+++ kernel/kernel/fork.c	(revision 182214)
@@ -722,8 +722,7 @@
 
 	mm = get_task_mm(task);
 	if (mm && mm != current->mm &&
-			!ptrace_may_access(task, mode) &&
-			!capable(CAP_SYS_RESOURCE)) {
+			!ptrace_may_access(task, mode)) {
 		mmput(mm);
 		mm = ERR_PTR(-EACCES);
 	}
Index: kernel/kernel/cpu.c
===================================================================
--- kernel/kernel/cpu.c	(revision 182213)
+++ kernel/kernel/cpu.c	(revision 182214)
@@ -295,9 +295,15 @@
 {
 	struct take_cpu_down_param *param = _param;
 	int err;
+	int ret = 0;
 #ifdef CONFIG_TRUSTY
-	int ret = 0;
 	unsigned int cpu = smp_processor_id();
+
+	ret = trusty_fast_call32_power(SMC_FC_CPU_DOWN, cpu, 0, 0);
+	if (ret < 0) {
+		pr_warn("trusty_fast_call32_power: SMC_FC_CPU_DOWN failed!, ret = %d\n", ret);
+		return ret;
+	}
 #endif
 
 	/* Ensure this CPU doesn't handle any more interrupts. */
@@ -308,12 +314,7 @@
 	cpu_notify(CPU_DYING | param->mod, param->hcpu);
 	/* Park the stopper thread */
 	kthread_park(current);
-#ifdef CONFIG_TRUSTY
-	ret = trusty_fast_call32_power(SMC_FC_CPU_DOWN, cpu, 0, 0);
-	if (ret < 0)
-		pr_warn("trusty_fast_call32_power: SMC_FC_CPU_DOWN failed!, ret = %d\n", ret);
-#endif
-	return 0;
+	return ret;
 }
 
 /* Requires cpu_add_remove_lock to be held */
Index: kernel/kernel/trace/trace_printk.c
===================================================================
--- kernel/kernel/trace/trace_printk.c	(revision 182213)
+++ kernel/kernel/trace/trace_printk.c	(revision 182214)
@@ -272,7 +272,7 @@
 	const char *str = *fmt;
 	int i;
 
-	seq_printf(m, "0x%lx : \"", *(unsigned long *)fmt);
+	seq_printf(m, "0x%lx : \"", 0L);
 
 	/*
 	 * Tabs and new lines need to be converted.
Index: kernel/kernel/trace/trace.c
===================================================================
--- kernel/kernel/trace/trace.c	(revision 182213)
+++ kernel/kernel/trace/trace.c	(revision 182214)
@@ -1481,7 +1481,7 @@
 	arch_spin_lock(&trace_cmdline_lock);
 	map = map_pid_to_cmdline[pid];
 	if (map != NO_CMDLINE_MAP)
-		strcpy(comm, saved_cmdlines[map]);
+		strlcpy(comm, saved_cmdlines[map], TASK_COMM_LEN-1);
 	else
 		strcpy(comm, "<...>");
 
Index: kernel/fs/timerfd.c
===================================================================
--- kernel/fs/timerfd.c	(revision 182213)
+++ kernel/fs/timerfd.c	(revision 182214)
@@ -39,6 +39,7 @@
 	int clockid;
 	struct rcu_head rcu;
 	struct list_head clist;
+	spinlock_t cancel_lock;
 	bool might_cancel;
 };
 
@@ -111,7 +112,7 @@
 	rcu_read_unlock();
 }
 
-static void timerfd_remove_cancel(struct timerfd_ctx *ctx)
+static void __timerfd_remove_cancel(struct timerfd_ctx *ctx)
 {
 	if (ctx->might_cancel) {
 		ctx->might_cancel = false;
@@ -121,6 +122,13 @@
 	}
 }
 
+static void timerfd_remove_cancel(struct timerfd_ctx *ctx)
+{
+	spin_lock(&ctx->cancel_lock);
+	__timerfd_remove_cancel(ctx);
+	spin_unlock(&ctx->cancel_lock);
+}
+
 static bool timerfd_canceled(struct timerfd_ctx *ctx)
 {
 	if (!ctx->might_cancel || ctx->moffs.tv64 != KTIME_MAX)
@@ -131,6 +139,7 @@
 
 static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)
 {
+	spin_lock(&ctx->cancel_lock);
 	if ((ctx->clockid == CLOCK_REALTIME ||
 	     ctx->clockid == CLOCK_REALTIME_ALARM) &&
 	    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {
@@ -140,9 +149,10 @@
 			list_add_rcu(&ctx->clist, &cancel_list);
 			spin_unlock(&cancel_lock);
 		}
-	} else if (ctx->might_cancel) {
-		timerfd_remove_cancel(ctx);
+	} else {
+		__timerfd_remove_cancel(ctx);
 	}
+	spin_unlock(&ctx->cancel_lock);
 }
 
 static ktime_t timerfd_get_remaining(struct timerfd_ctx *ctx)
@@ -326,6 +336,7 @@
 		return -ENOMEM;
 
 	init_waitqueue_head(&ctx->wqh);
+	spin_lock_init(&ctx->cancel_lock);
 	ctx->clockid = clockid;
 
 	if (isalarm(ctx))
Index: kernel/include/soc/sprd/__board-sp9832a_7c20_volte.h
===================================================================
--- kernel/include/soc/sprd/__board-sp9832a_7c20_volte.h	(revision 0)
+++ kernel/include/soc/sprd/__board-sp9832a_7c20_volte.h	(revision 182214)
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2012 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __GPIO_SC8810_H__
+#define __GPIO_SC8810_H__
+
+#ifndef __ASM_ARCH_BOARD_H
+#error  "Don't include this file directly, include <mach/board.h>"
+#endif
+
+#define GPIO_TOUCH_RESET         145
+#define GPIO_TOUCH_IRQ           144
+
+#define GPIO_MAIN_SENSOR_RESET   44
+#define GPIO_MAIN_SENSOR_PWN     46
+#define GPIO_SUB_SENSOR_RESET    45
+#define GPIO_SUB_SENSOR_PWN      47
+
+#define USB_OTG_CABLE_DETECT     126
+
+#define SPRD_FLASH_OFST          0x890
+#define SPRD_FLASH_CTRL_BIT      0x8000
+#define SPRD_FLASH_LOW_VAL       0x3
+#define SPRD_FLASH_HIGH_VAL      0xF
+#define SPRD_FLASH_LOW_CUR       110
+#define SPRD_FLASH_HIGH_CUR      470
+
+#define GPIO_KEY_VOLUMEDOWN 124
+#define GPIO_KEY_VOLUMEUP 125
+
+#define EIC_CHARGER_DETECT		(A_EIC_START + 0)
+#define EIC_POWER_PBINT2        (A_EIC_START + 1)
+#define EIC_POWER_PBINT         (A_EIC_START + 2)
+#define EIC_AUD_HEAD_BUTTON     (A_EIC_START + 3)
+#define EIC_CHG_CV_STATE       (A_EIC_START + 4)
+#define EIC_AUD_HEAD_INST      (A_EIC_START + 5)
+#define EIC_VCHG_OVI            (A_EIC_START + 6)
+#define EIC_VBAT_OVI            (A_EIC_START + 7)
+#define EIC_AUD_HEAD_INST2      (A_EIC_START + 8)
+
+#define EIC_KEY_POWER           (EIC_POWER_PBINT)
+
+#define HEADSET_BUTTON_GPIO		(EIC_AUD_HEAD_BUTTON)
+#define HEADSET_DETECT_GPIO		(EIC_AUD_HEAD_INST2)
+#define HEADSET_SWITCH_GPIO	0
+
+#define HEADSET_IRQ_TRIGGER_LEVEL_DETECT 1
+#define HEADSET_IRQ_TRIGGER_LEVEL_BUTTON 1
+
+#define HEADSET_ADC_MIN_KEY_MEDIA 0
+#define HEADSET_ADC_MAX_KEY_MEDIA 170
+#define HEADSET_ADC_MIN_KEY_VOLUMEUP 171
+#define HEADSET_ADC_MAX_KEY_VOLUMEUP 430
+#define HEADSET_ADC_MIN_KEY_VOLUMEDOWN 431
+#define HEADSET_ADC_MAX_KEY_VOLUMEDOWN 760
+#define HEADSET_ADC_THRESHOLD_3POLE_DETECT 100
+#define HEADSET_ADC_THRESHOLD_4POLE_DETECT 3100
+#define HEADSET_IRQ_THRESHOLD_BUTTON 1
+#define HEADSET_HEADMICBIAS_VOLTAGE 3000000
+
+#define SPI0_CMMB_CS_GPIO        32
+#define SPI1_WIFI_CS_GPIO        44
+
+#define GPIO_BK                  143
+#define MSENSOR_DRDY_GPIO        53
+#define GPIO_PLSENSOR_IRQ	213
+/*For bcm4343 power on/off and sleep/wake */
+#define GPIO_BT_RESET 122
+#define GPIO_BT_POWER 131
+#define GPIO_BT2AP_WAKE 133
+#define GPIO_AP2BT_WAKE 132
+
+/*#define GPIO_BT_RESET		194 */
+#define GPIO_WIFI_POWERON	189
+#define GPIO_WIFI_SHUTDOWN	130
+#define GPIO_WIFI_IRQ		97
+
+#define GPIO_PROX_INT       140
+#define GPIO_GPS_ONOFF	        174
+
+#define GPIO_SDIO_DETECT      75
+
+#define SPRD_PIN_SDIO0_OFFSET     0x01E0
+#define SPRD_PIN_SDIO0_SIZE       7
+#define SPRD_PIN_SDIO0_D3_INDEX 0
+#define SPRD_PIN_SDIO0_D3_GPIO 100
+#define SPRD_PIN_SDIO0_SD_FUNC 0
+#define SPRD_PIN_SDIO0_GPIO_FUNC 3
+
+/*#define CP related featrue */
+#define SIPC_SMEM_ADDR		(CONFIG_PHYS_OFFSET + 120 * SZ_1M)
+
+#define CPT_START_ADDR		(CONFIG_PHYS_OFFSET + 128 * SZ_1M)
+#define CPT_TOTAL_SIZE		(SZ_1M * 18)
+#define CPT_RING_ADDR		(CPT_START_ADDR + CPT_TOTAL_SIZE - SZ_4K)
+#define CPT_RING_SIZE		(SZ_4K)
+#define CPT_SMEM_SIZE		(SZ_1M * 2)
+
+#define CPW_START_ADDR		(CONFIG_PHYS_OFFSET + 150* SZ_1M)
+#define CPW_TOTAL_SIZE		(SZ_1M * 33)
+#define CPW_RING_ADDR		(CPW_START_ADDR + CPW_TOTAL_SIZE - SZ_4K)
+#define CPW_RING_SIZE		(SZ_4K)
+#define CPW_SMEM_SIZE		(SZ_1M * 2)
+
+#define WCN_START_ADDR		(CONFIG_PHYS_OFFSET + 320 * SZ_1M)
+#define WCN_TOTAL_SIZE		(SZ_1M * 5)
+#define WCN_RING_ADDR		(WCN_START_ADDR + WCN_TOTAL_SIZE - SZ_4K)
+#define WCN_RING_SIZE		(SZ_4K)
+#define WCN_SMEM_SIZE		(SZ_1M * 2)
+
+#define GGE_START_ADDR		(CONFIG_PHYS_OFFSET + 128 * SZ_1M)
+#define GGE_TOTAL_SIZE		(SZ_1M * 22)
+#define GGE_RING_ADDR		(GGE_START_ADDR + GGE_TOTAL_SIZE - SZ_4K)
+#define GGE_RING_SIZE		(SZ_4K)
+#define GGE_SMEM_SIZE		(SZ_1M * 2)
+
+#define LTE_START_ADDR		(CONFIG_PHYS_OFFSET + 150 * SZ_1M)
+#define LTE_TOTAL_SIZE		(SZ_1M * 63 + SZ_512K)
+#define LTE_RING_ADDR		(LTE_START_ADDR + LTE_TOTAL_SIZE - SZ_4K)
+#define LTE_RING_SIZE		(SZ_4K)
+#define LTE_SMEM_SIZE		(SZ_1M * 2)
+
+#endif
Index: kernel/include/soc/sprd/__board-sp9832a_2h12_volte.h
===================================================================
--- kernel/include/soc/sprd/__board-sp9832a_2h12_volte.h	(revision 0)
+++ kernel/include/soc/sprd/__board-sp9832a_2h12_volte.h	(revision 182214)
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2012 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __GPIO_SC8810_H__
+#define __GPIO_SC8810_H__
+
+#ifndef __ASM_ARCH_BOARD_H
+#error  "Don't include this file directly, include <mach/board.h>"
+#endif
+
+#define GPIO_TOUCH_RESET         145
+#define GPIO_TOUCH_IRQ           144
+
+#define GPIO_MAIN_SENSOR_RESET   44
+#define GPIO_MAIN_SENSOR_PWN     46
+#define GPIO_SUB_SENSOR_RESET    45
+#define GPIO_SUB_SENSOR_PWN      47
+
+#define USB_OTG_CABLE_DETECT     126
+
+#define SPRD_FLASH_OFST          0x890
+#define SPRD_FLASH_CTRL_BIT      0x8000
+#define SPRD_FLASH_LOW_VAL       0x3
+#define SPRD_FLASH_HIGH_VAL      0xF
+#define SPRD_FLASH_LOW_CUR       110
+#define SPRD_FLASH_HIGH_CUR      470
+
+#define GPIO_KEY_VOLUMEDOWN 124
+#define GPIO_KEY_VOLUMEUP 125
+
+#define EIC_CHARGER_DETECT		(A_EIC_START + 0)
+#define EIC_POWER_PBINT2        (A_EIC_START + 1)
+#define EIC_POWER_PBINT         (A_EIC_START + 2)
+#define EIC_AUD_HEAD_BUTTON     (A_EIC_START + 3)
+#define EIC_CHG_CV_STATE       (A_EIC_START + 4)
+#define EIC_AUD_HEAD_INST      (A_EIC_START + 5)
+#define EIC_VCHG_OVI            (A_EIC_START + 6)
+#define EIC_VBAT_OVI            (A_EIC_START + 7)
+#define EIC_AUD_HEAD_INST2      (A_EIC_START + 8)
+
+#define EIC_KEY_POWER           (EIC_POWER_PBINT)
+
+#define HEADSET_BUTTON_GPIO		(EIC_AUD_HEAD_BUTTON)
+#define HEADSET_DETECT_GPIO		(EIC_AUD_HEAD_INST2)
+#define HEADSET_SWITCH_GPIO	0
+
+#define HEADSET_IRQ_TRIGGER_LEVEL_DETECT 1
+#define HEADSET_IRQ_TRIGGER_LEVEL_BUTTON 1
+
+#define HEADSET_ADC_MIN_KEY_MEDIA 0
+#define HEADSET_ADC_MAX_KEY_MEDIA 170
+#define HEADSET_ADC_MIN_KEY_VOLUMEUP 171
+#define HEADSET_ADC_MAX_KEY_VOLUMEUP 430
+#define HEADSET_ADC_MIN_KEY_VOLUMEDOWN 431
+#define HEADSET_ADC_MAX_KEY_VOLUMEDOWN 760
+#define HEADSET_ADC_THRESHOLD_3POLE_DETECT 100
+#define HEADSET_ADC_THRESHOLD_4POLE_DETECT 3100
+#define HEADSET_IRQ_THRESHOLD_BUTTON 1
+#define HEADSET_HEADMICBIAS_VOLTAGE 3000000
+
+#define SPI0_CMMB_CS_GPIO        32
+#define SPI1_WIFI_CS_GPIO        44
+
+#define GPIO_BK                  143
+#define MSENSOR_DRDY_GPIO        53
+#define GPIO_PLSENSOR_IRQ	213
+/*For bcm4343 power on/off and sleep/wake */
+#define GPIO_BT_RESET 122
+#define GPIO_BT_POWER 131
+#define GPIO_BT2AP_WAKE 133
+#define GPIO_AP2BT_WAKE 132
+
+/*#define GPIO_BT_RESET		194 */
+#define GPIO_WIFI_POWERON	189
+#define GPIO_WIFI_SHUTDOWN	130
+#define GPIO_WIFI_IRQ		97
+
+#define GPIO_PROX_INT       140
+#define GPIO_GPS_ONOFF	        174
+
+#define GPIO_SDIO_DETECT      75
+
+#define SPRD_PIN_SDIO0_OFFSET     0x01E0
+#define SPRD_PIN_SDIO0_SIZE       7
+#define SPRD_PIN_SDIO0_D3_INDEX 0
+#define SPRD_PIN_SDIO0_D3_GPIO 100
+#define SPRD_PIN_SDIO0_SD_FUNC 0
+#define SPRD_PIN_SDIO0_GPIO_FUNC 3
+
+/*#define CP related featrue */
+#define SIPC_SMEM_ADDR		(CONFIG_PHYS_OFFSET + 120 * SZ_1M)
+
+#define CPT_START_ADDR		(CONFIG_PHYS_OFFSET + 128 * SZ_1M)
+#define CPT_TOTAL_SIZE		(SZ_1M * 18)
+#define CPT_RING_ADDR		(CPT_START_ADDR + CPT_TOTAL_SIZE - SZ_4K)
+#define CPT_RING_SIZE		(SZ_4K)
+#define CPT_SMEM_SIZE		(SZ_1M * 2)
+
+#define CPW_START_ADDR		(CONFIG_PHYS_OFFSET + 150* SZ_1M)
+#define CPW_TOTAL_SIZE		(SZ_1M * 33)
+#define CPW_RING_ADDR		(CPW_START_ADDR + CPW_TOTAL_SIZE - SZ_4K)
+#define CPW_RING_SIZE		(SZ_4K)
+#define CPW_SMEM_SIZE		(SZ_1M * 2)
+
+#define WCN_START_ADDR		(CONFIG_PHYS_OFFSET + 320 * SZ_1M)
+#define WCN_TOTAL_SIZE		(SZ_1M * 5)
+#define WCN_RING_ADDR		(WCN_START_ADDR + WCN_TOTAL_SIZE - SZ_4K)
+#define WCN_RING_SIZE		(SZ_4K)
+#define WCN_SMEM_SIZE		(SZ_1M * 2)
+
+#define GGE_START_ADDR		(CONFIG_PHYS_OFFSET + 128 * SZ_1M)
+#define GGE_TOTAL_SIZE		(SZ_1M * 22)
+#define GGE_RING_ADDR		(GGE_START_ADDR + GGE_TOTAL_SIZE - SZ_4K)
+#define GGE_RING_SIZE		(SZ_4K)
+#define GGE_SMEM_SIZE		(SZ_1M * 2)
+
+#define LTE_START_ADDR		(CONFIG_PHYS_OFFSET + 150 * SZ_1M)
+#define LTE_TOTAL_SIZE		(SZ_1M * 63 + SZ_512K)
+#define LTE_RING_ADDR		(LTE_START_ADDR + LTE_TOTAL_SIZE - SZ_4K)
+#define LTE_RING_SIZE		(SZ_4K)
+#define LTE_SMEM_SIZE		(SZ_1M * 2)
+
+#endif
Index: kernel/include/soc/sprd/busmonitor.h
===================================================================
--- kernel/include/soc/sprd/busmonitor.h	(revision 182213)
+++ kernel/include/soc/sprd/busmonitor.h	(revision 182214)
@@ -14,8 +14,10 @@
 #ifndef __SPRD_BUSMONITOR_H__
 #define __SPRD_BUSMONITOR_H__
 
-#define MPU_DUMP_ADDR				(0xbd9ff000)
+#define MPU_DUMP_ADDR_2G			(0xfd7ff000)
+#define MPU_DUMP_ADDR_1G			(0xbd9ff000)
 #define MPU_DUMP_LEN				(0x1000)
+
 #define AXI_BM_INTC_REG				0x00
 #define AXI_BM_CFG_REG				0x04
 #define AXI_BM_ADDR_MIN_REG			0x08
Index: kernel/include/soc/sprd/board.h
===================================================================
--- kernel/include/soc/sprd/board.h	(revision 182213)
+++ kernel/include/soc/sprd/board.h	(revision 182214)
@@ -349,6 +349,18 @@
 #include "__board-sp9832a_2h11_volte.h"
 #endif
 
+#ifdef CONFIG_MACH_SP9832A_2H12_VOLTE
+#include "__board-sp9832a_2h12_volte.h"
+#endif
+
+#ifdef CONFIG_MACH_SP9832A_7C10_VOLTE
+#include "__board-sp9832a_7c10_volte.h"
+#endif
+
+#ifdef CONFIG_MACH_SP9832A_7C20_VOLTE
+#include "__board-sp9832a_7c20_volte.h"
+#endif
+
 #ifdef CONFIG_MACH_SP9832A2_VOL_13CAM
 #include "__board-sp9832a2_vol_13cam.h"
 #endif
Index: kernel/include/soc/sprd/__board-sp9832a_7c10_volte.h
===================================================================
--- kernel/include/soc/sprd/__board-sp9832a_7c10_volte.h	(revision 0)
+++ kernel/include/soc/sprd/__board-sp9832a_7c10_volte.h	(revision 182214)
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2012 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __GPIO_SC8810_H__
+#define __GPIO_SC8810_H__
+
+#ifndef __ASM_ARCH_BOARD_H
+#error  "Don't include this file directly, include <mach/board.h>"
+#endif
+
+#define GPIO_TOUCH_RESET         145
+#define GPIO_TOUCH_IRQ           144
+
+#define GPIO_MAIN_SENSOR_RESET   44
+#define GPIO_MAIN_SENSOR_PWN     46
+#define GPIO_SUB_SENSOR_RESET    45
+#define GPIO_SUB_SENSOR_PWN      47
+
+#define USB_OTG_CABLE_DETECT     126
+
+#define SPRD_FLASH_OFST          0x890
+#define SPRD_FLASH_CTRL_BIT      0x8000
+#define SPRD_FLASH_LOW_VAL       0x3
+#define SPRD_FLASH_HIGH_VAL      0xF
+#define SPRD_FLASH_LOW_CUR       110
+#define SPRD_FLASH_HIGH_CUR      470
+
+#define GPIO_KEY_VOLUMEDOWN 124
+#define GPIO_KEY_VOLUMEUP 125
+
+#define EIC_CHARGER_DETECT		(A_EIC_START + 0)
+#define EIC_POWER_PBINT2        (A_EIC_START + 1)
+#define EIC_POWER_PBINT         (A_EIC_START + 2)
+#define EIC_AUD_HEAD_BUTTON     (A_EIC_START + 3)
+#define EIC_CHG_CV_STATE       (A_EIC_START + 4)
+#define EIC_AUD_HEAD_INST      (A_EIC_START + 5)
+#define EIC_VCHG_OVI            (A_EIC_START + 6)
+#define EIC_VBAT_OVI            (A_EIC_START + 7)
+#define EIC_AUD_HEAD_INST2      (A_EIC_START + 8)
+
+#define EIC_KEY_POWER           (EIC_POWER_PBINT)
+
+#define HEADSET_BUTTON_GPIO		(EIC_AUD_HEAD_BUTTON)
+#define HEADSET_DETECT_GPIO		(EIC_AUD_HEAD_INST2)
+#define HEADSET_SWITCH_GPIO	0
+
+#define HEADSET_IRQ_TRIGGER_LEVEL_DETECT 1
+#define HEADSET_IRQ_TRIGGER_LEVEL_BUTTON 1
+
+#define HEADSET_ADC_MIN_KEY_MEDIA 0
+#define HEADSET_ADC_MAX_KEY_MEDIA 170
+#define HEADSET_ADC_MIN_KEY_VOLUMEUP 171
+#define HEADSET_ADC_MAX_KEY_VOLUMEUP 430
+#define HEADSET_ADC_MIN_KEY_VOLUMEDOWN 431
+#define HEADSET_ADC_MAX_KEY_VOLUMEDOWN 760
+#define HEADSET_ADC_THRESHOLD_3POLE_DETECT 100
+#define HEADSET_ADC_THRESHOLD_4POLE_DETECT 3100
+#define HEADSET_IRQ_THRESHOLD_BUTTON 1
+#define HEADSET_HEADMICBIAS_VOLTAGE 3000000
+
+#define SPI0_CMMB_CS_GPIO        32
+#define SPI1_WIFI_CS_GPIO        44
+
+#define GPIO_BK                  143
+#define MSENSOR_DRDY_GPIO        53
+#define GPIO_PLSENSOR_IRQ	213
+/*For bcm4343 power on/off and sleep/wake */
+#define GPIO_BT_RESET 122
+#define GPIO_BT_POWER 131
+#define GPIO_BT2AP_WAKE 133
+#define GPIO_AP2BT_WAKE 132
+
+/*#define GPIO_BT_RESET		194 */
+#define GPIO_WIFI_POWERON	189
+#define GPIO_WIFI_SHUTDOWN	130
+#define GPIO_WIFI_IRQ		97
+
+#define GPIO_PROX_INT       140
+#define GPIO_GPS_ONOFF	        174
+
+#define GPIO_SDIO_DETECT      75
+
+#define SPRD_PIN_SDIO0_OFFSET     0x01E0
+#define SPRD_PIN_SDIO0_SIZE       7
+#define SPRD_PIN_SDIO0_D3_INDEX 0
+#define SPRD_PIN_SDIO0_D3_GPIO 100
+#define SPRD_PIN_SDIO0_SD_FUNC 0
+#define SPRD_PIN_SDIO0_GPIO_FUNC 3
+
+/*#define CP related featrue */
+#define SIPC_SMEM_ADDR		(CONFIG_PHYS_OFFSET + 120 * SZ_1M)
+
+#define CPT_START_ADDR		(CONFIG_PHYS_OFFSET + 128 * SZ_1M)
+#define CPT_TOTAL_SIZE		(SZ_1M * 18)
+#define CPT_RING_ADDR		(CPT_START_ADDR + CPT_TOTAL_SIZE - SZ_4K)
+#define CPT_RING_SIZE		(SZ_4K)
+#define CPT_SMEM_SIZE		(SZ_1M * 2)
+
+#define CPW_START_ADDR		(CONFIG_PHYS_OFFSET + 150* SZ_1M)
+#define CPW_TOTAL_SIZE		(SZ_1M * 33)
+#define CPW_RING_ADDR		(CPW_START_ADDR + CPW_TOTAL_SIZE - SZ_4K)
+#define CPW_RING_SIZE		(SZ_4K)
+#define CPW_SMEM_SIZE		(SZ_1M * 2)
+
+#define WCN_START_ADDR		(CONFIG_PHYS_OFFSET + 320 * SZ_1M)
+#define WCN_TOTAL_SIZE		(SZ_1M * 5)
+#define WCN_RING_ADDR		(WCN_START_ADDR + WCN_TOTAL_SIZE - SZ_4K)
+#define WCN_RING_SIZE		(SZ_4K)
+#define WCN_SMEM_SIZE		(SZ_1M * 2)
+
+#define GGE_START_ADDR		(CONFIG_PHYS_OFFSET + 128 * SZ_1M)
+#define GGE_TOTAL_SIZE		(SZ_1M * 22)
+#define GGE_RING_ADDR		(GGE_START_ADDR + GGE_TOTAL_SIZE - SZ_4K)
+#define GGE_RING_SIZE		(SZ_4K)
+#define GGE_SMEM_SIZE		(SZ_1M * 2)
+
+#define LTE_START_ADDR		(CONFIG_PHYS_OFFSET + 150 * SZ_1M)
+#define LTE_TOTAL_SIZE		(SZ_1M * 63 + SZ_512K)
+#define LTE_RING_ADDR		(LTE_START_ADDR + LTE_TOTAL_SIZE - SZ_4K)
+#define LTE_RING_SIZE		(SZ_4K)
+#define LTE_SMEM_SIZE		(SZ_1M * 2)
+
+#endif
Index: kernel/include/linux/mm.h
===================================================================
--- kernel/include/linux/mm.h	(revision 182213)
+++ kernel/include/linux/mm.h	(revision 182214)
@@ -1762,6 +1762,7 @@
 #define FOLL_HWPOISON	0x100	/* check page is hwpoisoned */
 #define FOLL_NUMA	0x200	/* force NUMA hinting page fault */
 #define FOLL_MIGRATION	0x400	/* wait for page to replace migration entry */
+#define FOLL_COW	0x4000	/* internal GUP flag */
 
 typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,
 			void *data);
Index: kernel/include/linux/perf_event.h
===================================================================
--- kernel/include/linux/perf_event.h	(revision 182213)
+++ kernel/include/linux/perf_event.h	(revision 182214)
@@ -430,11 +430,6 @@
 #endif /* CONFIG_PERF_EVENTS */
 };
 
-enum perf_event_context_type {
-	task_context,
-	cpu_context,
-};
-
 /**
  * struct perf_event_context - event context structure
  *
@@ -442,7 +437,6 @@
  */
 struct perf_event_context {
 	struct pmu			*pmu;
-	enum perf_event_context_type	type;
 	/*
 	 * Protect the states of the events in the list,
 	 * nr_active, and the list:
Index: kernel/include/linux/i2c/af8133.h
===================================================================
--- kernel/include/linux/i2c/af8133.h	(revision 0)
+++ kernel/include/linux/i2c/af8133.h	(revision 182214)
@@ -0,0 +1,62 @@
+/******************** (C) COPYRIGHT Voltafield 2014 ********************
+*
+* File Name          : af8133.h
+* Authors            : Production, CAE Team
+*                    : Gary Huang
+* Date               : 2015/Mar/26
+* Description        : AF7133E/AF8133i Magneto sensor Driver header file
+*
+************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+/*******************************************************************************
+Version History.
+
+20150326  1st version
+20150706  new arch. for qcom
+*******************************************************************************/
+
+#ifndef __AF8133_H__
+#define __AF8133_H__
+
+#define AF8133_I2C_DEV_NAME            "af8133"
+#define AF8133_INPUT_DEV_NAME          "compass"
+#define AF8133_SYS_CLS_NAME            "compass"
+#define AF8133_SYS_DEV_NAME            "msensor"
+
+struct af8133_platform_data {
+
+        unsigned int poll_interval;
+
+        u8 axis_map_x;
+        u8 axis_map_y;
+        u8 axis_map_z;
+
+        u8 negate_x;
+        u8 negate_y;
+        u8 negate_z;
+
+       u8 reg33;
+
+       int offset[3];  
+
+        int (*init)(void);
+        void (*exit)(void);
+        int (*power_on)(void);
+        int (*power_off)(void);
+};
+
+#endif  /* __AF8133_H__ */
+
Index: kernel/include/linux/i2c/mc3xx0.h
===================================================================
--- kernel/include/linux/i2c/mc3xx0.h	(revision 0)
+++ kernel/include/linux/i2c/mc3xx0.h	(revision 182214)
@@ -0,0 +1,74 @@
+/*****************************************************************************
+ *
+ * Copyright (c) 2013 mCube, Inc.  All rights reserved.
+ *
+ * This source is subject to the mCube Software License.
+ * This software is protected by Copyright and the information and source code
+ * contained herein is confidential. The software including the source code
+ * may not be copied and the information contained herein may not be used or
+ * disclosed except with the written permission of mCube Inc.
+ *
+ * All other rights reserved.
+ *
+ * This code and information are provided "as is" without warranty of any
+ * kind, either expressed or implied, including but not limited to the
+ * implied warranties of merchantability and/or fitness for a
+ * particular purpose.
+ *
+ * The following software/firmware and/or related documentation ("mCube Software")
+ * have been modified by mCube Inc. All revisions are subject to any receiver's
+ * applicable license agreements with mCube Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ *****************************************************************************/
+
+#ifndef __MC3XX0_H__
+#define __MC3XX0_H__
+		  
+#include <linux/ioctl.h>	  
+
+#define MC3XX0_ACC_I2C_ADDR     0x4C
+#define MC3XX0_ACC_I2C_NAME     "mc3xx0"
+
+typedef struct {
+	unsigned short	x;		/**< X axis */
+	unsigned short	y;		/**< Y axis */
+	unsigned short	z;		/**< Z axis */
+} GSENSOR_VECTOR3D;
+
+typedef struct{
+	int x;
+	int y;
+	int z;
+} SENSOR_DATA;
+
+#define GSENSOR                                0x95
+#define GSENSOR_IOCTL_INIT                     _IO(GSENSOR,  0x01)
+#define GSENSOR_IOCTL_READ_CHIPINFO            _IOR(GSENSOR, 0x02, int)
+#define GSENSOR_IOCTL_READ_SENSORDATA          _IOR(GSENSOR, 0x03, int)
+#define GSENSOR_IOCTL_READ_OFFSET              _IOR(GSENSOR, 0x04, GSENSOR_VECTOR3D)
+#define GSENSOR_IOCTL_READ_GAIN                _IOR(GSENSOR, 0x05, GSENSOR_VECTOR3D)
+#define GSENSOR_IOCTL_READ_RAW_DATA            _IOR(GSENSOR, 0x06, int)
+#define GSENSOR_IOCTL_GET_CALI                 _IOW(GSENSOR, 0x07, SENSOR_DATA)
+#define GSENSOR_IOCTL_CLR_CALI                 _IO(GSENSOR, 0x08)
+#define GSENSOR_MCUBE_IOCTL_READ_RBM_DATA      _IOR(GSENSOR, 0x09, SENSOR_DATA)
+#define GSENSOR_MCUBE_IOCTL_SET_RBM_MODE       _IO(GSENSOR, 0x0a)
+#define GSENSOR_MCUBE_IOCTL_CLEAR_RBM_MODE     _IO(GSENSOR, 0x0b)
+#define GSENSOR_MCUBE_IOCTL_SET_CALI           _IOW(GSENSOR, 0x0c, SENSOR_DATA)
+#define GSENSOR_MCUBE_IOCTL_REGISTER_MAP       _IO(GSENSOR, 0x0d)
+#define GSENSOR_IOCTL_SET_CALI_MODE            _IOW(GSENSOR, 0x0e,int)
+#define GSENSOR_MCUBE_IOCTL_READ_PRODUCT_ID    _IOR(GSENSOR, 0x11, int)
+#define GSENSOR_MCUBE_IOCTL_READ_CHIP_ID       _IOR(GSENSOR, 0x12, int)
+#define GSENSOR_MCUBE_IOCTL_READ_FILEPATH      _IOR(GSENSOR, 0x13, char[256])
+
+#endif
+
Index: kernel/net/ims_bridge/imsbr_sipc.c
===================================================================
--- kernel/net/ims_bridge/imsbr_sipc.c	(revision 182213)
+++ kernel/net/ims_bridge/imsbr_sipc.c	(revision 182214)
@@ -37,7 +37,7 @@
 module_param_call(volte_video_apsk, volte_video_apsk_set, param_get_uint,
 		  &volte_video_apsk, 0644);
 
-static int imsbr_notify_ltevideo_apsk(void)
+int imsbr_notify_ltevideo_apsk(void)
 {
 	u32 enable = volte_video_apsk;
 	struct sblock blk;
Index: kernel/net/ims_bridge/imsbr_sipc.h
===================================================================
--- kernel/net/ims_bridge/imsbr_sipc.h	(revision 182213)
+++ kernel/net/ims_bridge/imsbr_sipc.h	(revision 182214)
@@ -29,6 +29,7 @@
 extern struct imsbr_sipc imsbr_data;
 extern struct imsbr_sipc imsbr_ctrl;
 
+int imsbr_notify_ltevideo_apsk(void);
 int imsbr_build_cmd(const char *cmd, struct sblock *blk,
 		    void *payload, int paylen);
 
Index: kernel/net/ims_bridge/imsbr_core.c
===================================================================
--- kernel/net/ims_bridge/imsbr_core.c	(revision 182213)
+++ kernel/net/ims_bridge/imsbr_core.c	(revision 182214)
@@ -45,6 +45,7 @@
 
 static void imsbr_cptuple_update(struct imsbr_msghdr *msg, unsigned long add);
 static void imsbr_cptuple_reset(struct imsbr_msghdr *msg, unsigned long unused);
+static void imsbr_cp_reset(struct imsbr_msghdr *msg, unsigned long unused);
 static void imsbr_echo_ping(struct imsbr_msghdr *msg, unsigned long unused);
 static void imsbr_echo_pong(struct imsbr_msghdr *msg, unsigned long unused);
 
@@ -72,6 +73,11 @@
 		.req_len = sizeof(u32),
 	},
 	{
+		.name = "cp-reset",
+		.doit = imsbr_cp_reset,
+		.req_len = sizeof('\0'),
+	},
+	{
 		.name = "echo-ping",
 		.doit = imsbr_echo_ping,
 		.req_len = sizeof('\0'),
@@ -401,6 +407,11 @@
 	imsbr_flow_reset(IMSBR_FLOW_CPTUPLE, *sim_card, false);
 }
 
+static void imsbr_cp_reset(struct imsbr_msghdr *msg, unsigned long unused)
+{
+	imsbr_notify_ltevideo_apsk();
+}
+
 static void imsbr_echo_ping(struct imsbr_msghdr *msg, unsigned long unused)
 {
 	struct sblock blk;
Index: kernel/net/ipv4/tcp.c
===================================================================
--- kernel/net/ipv4/tcp.c	(revision 182213)
+++ kernel/net/ipv4/tcp.c	(revision 182214)
@@ -729,6 +729,13 @@
 				ret = -EAGAIN;
 				break;
 			}
+			
+			/* if __tcp_splice_read() got nothing while we have
+			 * an skb in receive queue, we do not want to loop.
+			 * This might happen with URG data.
+			 */
+			if (!skb_queue_empty(&sk->sk_receive_queue))
+				break;
 			sk_wait_data(sk, &timeo);
 			if (signal_pending(current)) {
 				ret = sock_intr_errno(timeo);
Index: kernel/net/ipv4/ip_sockglue.c
===================================================================
--- kernel/net/ipv4/ip_sockglue.c	(revision 182213)
+++ kernel/net/ipv4/ip_sockglue.c	(revision 182214)
@@ -1046,7 +1046,14 @@
 		pktinfo->ipi_ifindex = 0;
 		pktinfo->ipi_spec_dst.s_addr = 0;
 	}
-	skb_dst_drop(skb);
+	/* We need to keep the dst for __ip_options_echo()
+	 * We could restrict the test to opt.ts_needtime || opt.srr,
+	 * but the following is good enough as IP options are not often used.
+	 */
+	if (unlikely(IPCB(skb)->opt.optlen))
+		skb_dst_force(skb);
+	else
+		skb_dst_drop(skb);
 }
 
 int ip_setsockopt(struct sock *sk, int level,
Index: kernel/net/ipv6/ip6_gre.c
===================================================================
--- kernel/net/ipv6/ip6_gre.c	(revision 182213)
+++ kernel/net/ipv6/ip6_gre.c	(revision 182214)
@@ -364,36 +364,38 @@
 
 
 static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
-		u8 type, u8 code, int offset, __be32 info)
+		       u8 type, u8 code, int offset, __be32 info)
 {
-	const struct ipv6hdr *ipv6h = (const struct ipv6hdr *)skb->data;
-	__be16 *p = (__be16 *)(skb->data + offset);
-	int grehlen = offset + 4;
+	const struct gre_base_hdr *greh;
+	const struct ipv6hdr *ipv6h;
+	int grehlen = sizeof(*greh);
 	struct ip6_tnl *t;
+	int key_off = 0;
 	__be16 flags;
+	__be32 key;
 
-	flags = p[0];
-	if (flags&(GRE_CSUM|GRE_KEY|GRE_SEQ|GRE_ROUTING|GRE_VERSION)) {
-		if (flags&(GRE_VERSION|GRE_ROUTING))
-			return;
-		if (flags&GRE_KEY) {
-			grehlen += 4;
-			if (flags&GRE_CSUM)
-				grehlen += 4;
-		}
+	if (!pskb_may_pull(skb, offset + grehlen))
+		return;
+	greh = (const struct gre_base_hdr *)(skb->data + offset);
+	flags = greh->flags;
+	if (flags & (GRE_VERSION | GRE_ROUTING))
+		return;
+	if (flags & GRE_CSUM)
+		grehlen += 4;
+	if (flags & GRE_KEY) {
+		key_off = grehlen + offset;
+		grehlen += 4;
 	}
 
-	/* If only 8 bytes returned, keyed message will be dropped here */
-	if (!pskb_may_pull(skb, grehlen))
+	if (!pskb_may_pull(skb, offset + grehlen))
 		return;
 	ipv6h = (const struct ipv6hdr *)skb->data;
-	p = (__be16 *)(skb->data + offset);
+	greh = (const struct gre_base_hdr *)(skb->data + offset);
+	key = key_off ? *(__be32 *)(skb->data + key_off) : 0;
 
 	t = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,
-				flags & GRE_KEY ?
-				*(((__be32 *)p) + (grehlen / 4) - 1) : 0,
-				p[1]);
-	if (t == NULL)
+				 key, greh->protocol);
+	if (!t)
 		return;
 
 	switch (type) {
Index: kernel/net/packet/af_packet.c
===================================================================
--- kernel/net/packet/af_packet.c	(revision 182213)
+++ kernel/net/packet/af_packet.c	(revision 182214)
@@ -3663,8 +3663,8 @@
 		if (unlikely(req->tp_block_size & (PAGE_SIZE - 1)))
 			goto out;
 		if (po->tp_version >= TPACKET_V3 &&
-		    (int)(req->tp_block_size -
-			  BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)) <= 0)
+		    req->tp_block_size <=
+			  BLK_PLUS_PRIV((u64)req_u->req3.tp_sizeof_priv))
 			goto out;
 		if (unlikely(req->tp_frame_size < po->tp_hdrlen +
 					po->tp_reserve))
Index: kernel/net/dccp/input.c
===================================================================
--- kernel/net/dccp/input.c	(revision 182213)
+++ kernel/net/dccp/input.c	(revision 182214)
@@ -606,7 +606,8 @@
 			if (inet_csk(sk)->icsk_af_ops->conn_request(sk,
 								    skb) < 0)
 				return 1;
-			goto discard;
+			consume_skb(skb);
+			return 0;
 		}
 		if (dh->dccph_type == DCCP_PKT_RESET)
 			goto discard;
Index: kernel/net/xfrm/xfrm_user.c
===================================================================
--- kernel/net/xfrm/xfrm_user.c	(revision 182213)
+++ kernel/net/xfrm/xfrm_user.c	(revision 182214)
@@ -393,6 +393,9 @@
 	if (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)
 		return -EINVAL;
 
+	if (up->replay_window > up->bmp_len * sizeof(__u32) * 8)
+		return -EINVAL;
+
 	return 0;
 }
 
Index: kernel/net/xfrm/xfrm_output.c
===================================================================
--- kernel/net/xfrm/xfrm_output.c	(revision 182213)
+++ kernel/net/xfrm/xfrm_output.c	(revision 182214)
@@ -23,10 +23,10 @@
 
 #ifdef CONFIG_XFRM_SPRD_VOWIFI_FRAGMENT
 #define SPRD_VOWIFI_DEFAULT_MTU 1400
-extern int ip4_sprd_fragment(struct sk_buff *skb,int pmtu,int (*output)(struct sk_buff *));
-extern int ip6_sprd_fragment(struct sk_buff *skb,int pmtu, int (*output)(struct sk_buff *));
+extern int ip4_sprd_fragment(struct sk_buff *skb, int pmtu, int (*output)(struct sk_buff *));
+extern int ip6_sprd_fragment(struct sk_buff *skb, int pmtu, int (*output)(struct sk_buff *));
 
-static int xfrm_output_resume_sprd(struct sk_buff *skb,int err);
+static int xfrm_output_resume_sprd(struct sk_buff *skb, int err);
 extern int sprd_enable_vowifi_fragment;
 
 #endif
@@ -140,7 +140,7 @@
 	 * err=1 the normal processing flow.
 	 * author:junjie.wang@spreadtrum.com@6704
 	 */
-	if(sprd_enable_vowifi_fragment){
+	if (sprd_enable_vowifi_fragment) {
 		return xfrm_output_resume_sprd(skb, err);
 	}
 #endif
@@ -174,13 +174,13 @@
 
 static inline int ipv4v6_skb_dst_mtu(struct sk_buff *skb)
 {
-    struct iphdr *iph = ip_hdr(skb);
-    if(iph->version == 0x04){
-	struct inet_sock *inet = skb->sk ? inet_sk(skb->sk) : NULL;
-	return (inet && inet->pmtudisc == IP_PMTUDISC_PROBE) ? skb_dst(skb)->dev->mtu : dst_mtu(skb_dst(skb));
-    }else{
-	struct ipv6_pinfo *np = skb->sk ? inet6_sk(skb->sk) : NULL;
-	return (np && np->pmtudisc == IPV6_PMTUDISC_PROBE) ? skb_dst(skb)->dev->mtu : dst_mtu(skb_dst(skb));
+	struct iphdr *iph = ip_hdr(skb);
+	if (iph->version == 0x04) {
+		struct inet_sock *inet = skb->sk ? inet_sk(skb->sk) : NULL;
+		return (inet && inet->pmtudisc == IP_PMTUDISC_PROBE) ? skb_dst(skb)->dev->mtu : dst_mtu(skb_dst(skb));
+	} else {
+		struct ipv6_pinfo *np = skb->sk ? inet6_sk(skb->sk) : NULL;
+		return (np && np->pmtudisc == IPV6_PMTUDISC_PROBE) ? skb_dst(skb)->dev->mtu : dst_mtu(skb_dst(skb));
     }
 }
 
@@ -189,10 +189,10 @@
  */
 static int __xfrm_output_resume_ss_once(struct sk_buff *skb, int err)
 {
-	if(likely((err = xfrm_output_one(skb, err)) == 0)) {
+	if (likely((err = xfrm_output_one(skb, err)) == 0)) {
 		nf_reset(skb);
 
-		err = skb_dst(skb)->ops->local_out(skb); //->__ip_local_out
+		err = skb_dst(skb)->ops->local_out(skb);
 		if (unlikely(err != 1))
 			goto out;
 
@@ -201,14 +201,14 @@
 
 		err = nf_hook(skb_dst(skb)->ops->family,
 			    NF_INET_POST_ROUTING, skb,
-			    NULL, skb_dst(skb)->dev, xfrm_output2); //nf_hook  !->xfrm_output2
+			    NULL, skb_dst(skb)->dev, xfrm_output2);
 
-		if(unlikely(err != 1))
+		if (unlikely(err != 1))
 			goto out;
 	}
 
 	if (err == -EINPROGRESS)
-	    err = 0;
+		err = 0;
 
 out:
 	return err;
@@ -225,60 +225,98 @@
  * parameter:
  *  pmtu:the minimal mtu in data path.
  * */
-static int xfrm_output_resume_sprd_sub(struct sk_buff *skb,int pmtu,int err,int *exit)
+static int xfrm_output_resume_sprd_sub(struct sk_buff *skb, int pmtu, int err, int *exit)
 {
 	struct dst_entry *dst = skb_dst(skb);
 	struct xfrm_state *x = dst->xfrm;
 	*exit = 0;
 
-	if(skb_dst(skb)->child && !((skb_dst(skb)->child)->xfrm)){
-		// it is external xfrm,when done,exit the loop while
+	if (skb_dst(skb)->child && !((skb_dst(skb)->child)->xfrm)) {
+		/*it is external xfrm,when done,exit the loop while*/
 		*exit = 1;
 	}
-	//do  the fragment,must meet the condition
-	//1. tunnel mode
-	//2. len > mtu
-	//3.no gso
-	//4.the return err is bigger than 0.
-	//printk(KERN_ERR "mtu=%d mode=%d err=%d exit=%d,len=%d gso(%d)\n",pmtu,x->props.mode,err,*exit,skb->len,!skb_is_gso(skb));
+	/*do the fragment,must meet the condition
+	 *1. tunnel mode
+	 *2. len > mtu
+	 *3.no gso
+	 *4.the return err is bigger than 0.
+	 */
 	pmtu = pmtu - x->props.header_len - x->props.trailer_len;
-	if(unlikely(pmtu<0)){
-		printk_ratelimited(KERN_ERR "The mtu is too small, pmtu=%d,to keep communication,set the pmtu quals  to 1400\n",pmtu);
-		pmtu = SPRD_VOWIFI_DEFAULT_MTU  - x->props.header_len - x->props.trailer_len;
+	if (unlikely(pmtu < 0)) {
+		printk_ratelimited(KERN_ERR
+		"The mtu is too small, pmtu=%d,to keep communication,set the pmtu quals to 1400\n", pmtu);
+		pmtu = SPRD_VOWIFI_DEFAULT_MTU
+			- x->props.header_len
+			- x->props.trailer_len;
 	}
-	if(((x->props.mode == XFRM_MODE_TUNNEL)&&
-	     (skb->len > pmtu && !skb_is_gso(skb)))&&
+	if (((x->props.mode == XFRM_MODE_TUNNEL) &&
+	     (skb->len > pmtu && !skb_is_gso(skb))) &&
 	     err > 0 &&
-	    (*exit == 1)){
+	    (*exit == 1)) {
 		struct iphdr *iph = ip_hdr(skb);
-		//according to ip headr type v4 or v6 to choose which fragement to be done.
-		if(iph->version == 0x04){
-		    if(iph->protocol == IPPROTO_ESP && skb->local_df==0)//if skb payload is esp,do fragment.even tht esp payload is tcp.
-			skb->local_df = 1;
+		int segs = 0;
+		int seg_pmtu = 0;
+		/*according to ip headr type v4 or v6 to
+		 *choose which fragement to be done.
+		 */
+		printk_ratelimited(KERN_ERR "The pmtu is %d, (%d,%d)\n",
+				   pmtu, x->props.header_len, x->props.trailer_len);
+		/*bug 707083 avoid too small pkt,
+		 *so be average divided into serval parts.
+		 */
+		segs = skb->len / pmtu;
+		segs++;
+		seg_pmtu = skb->len / segs;
+		seg_pmtu = (seg_pmtu / 4 + 1) * 4;
+		if (iph->version == 0x04) {
+		/*if skb payload is esp,do fragment.even tht esp payload is tcp.*/
+			if (iph->protocol == IPPROTO_ESP && skb->local_df == 0)
+				skb->local_df = 1;
 
-		    return  ip4_sprd_fragment(skb,pmtu,__xfrm_output_resume_ss_after_frag);
-		}else{
-		    struct ipv6hdr *ip6h = ipv6_hdr(skb);
-		    if(ip6h->nexthdr == IPPROTO_ESP && skb->local_df==0)//if skb payload is esp,do fragment.even tht esp payload is tcp.
-			skb->local_df = 1;
- 
-		    return  ip6_sprd_fragment(skb,pmtu,__xfrm_output_resume_ss_after_frag);
+			seg_pmtu += iph->ihl * 4;
+			if (seg_pmtu > pmtu)
+				seg_pmtu = pmtu;
+			printk_ratelimited(KERN_ERR
+		"IPv4:The pkt is average divided into %d parts with mtu %d.\n",
+			segs, seg_pmtu);
+			return  ip4_sprd_fragment(skb, seg_pmtu,
+					__xfrm_output_resume_ss_after_frag);
+		} else {
+			struct ipv6hdr *ip6h = ipv6_hdr(skb);
+			unsigned int hlen = 0;
+			u8 *prevhdr = 0;
+			/*if skb payload is esp,do fragment.
+			 *even tht esp payload is tcp.
+			 */
+			hlen = ip6_find_1stfragopt(skb, &prevhdr);
+			seg_pmtu += sizeof(struct frag_hdr) + hlen;
+			if (seg_pmtu > pmtu)
+				seg_pmtu = pmtu;
+			printk_ratelimited(KERN_ERR
+		"IPv6:The pkt is average divided into %d parts with mtu %d.\n",
+			segs, seg_pmtu);
+		/*if skb payload is esp,do fragment.even tht esp payload is tcp.*/
+			if (ip6h->nexthdr == IPPROTO_ESP && skb->local_df == 0)
+				skb->local_df = 1;
+
+			return  ip6_sprd_fragment(skb, seg_pmtu,
+					__xfrm_output_resume_ss_after_frag);
 		}
 	}
-	return __xfrm_output_resume_ss_once(skb,err);
+	return __xfrm_output_resume_ss_once(skb, err);
 }
 
-static int xfrm_output_resume_sprd(struct sk_buff *skb,int err)
+static int xfrm_output_resume_sprd(struct sk_buff *skb, int err)
 {
 	int exit = 0;
 	int pmtu = SPRD_VOWIFI_DEFAULT_MTU;
 	pmtu = ipv4v6_skb_dst_mtu(skb);
-	while(1){
-		err = xfrm_output_resume_sprd_sub(skb,pmtu,err,&exit);
-		if(err == 1 && exit == 0){
+	while (1) {
+		err = xfrm_output_resume_sprd_sub(skb, pmtu, err, &exit);
+		if (err == 1 && exit == 0) {
 			pmtu = ipv4v6_skb_dst_mtu(skb);
 			continue;
-		}else
+		} else
 			break;
 	}
 	return err;
@@ -286,7 +324,7 @@
 #endif
 static int xfrm_output2(struct sk_buff *skb)
 {
-    return xfrm_output_resume(skb, 1);
+	return xfrm_output_resume(skb, 1);
 }
 
 static int xfrm_output_gso(struct sk_buff *skb)
Index: kernel/net/xfrm/xfrm_algo.c
===================================================================
--- kernel/net/xfrm/xfrm_algo.c	(revision 182213)
+++ kernel/net/xfrm/xfrm_algo.c	(revision 182214)
@@ -316,6 +316,7 @@
 },
 {
 	.name = "xcbc(aes)",
+	.compat = "xcbc-aes",
 
 	.uinfo = {
 		.auth = {
Index: kernel/net/netfilter/nf_conntrack_sip.c
===================================================================
--- kernel/net/netfilter/nf_conntrack_sip.c	(revision 182213)
+++ kernel/net/netfilter/nf_conntrack_sip.c	(revision 182214)
@@ -1490,9 +1490,12 @@
 		handler = &sip_handlers[i];
 		if (handler->request == NULL)
 			continue;
-		if (*datalen < handler->len ||
+		if (*datalen < handler->len + 2 ||
 		    strnicmp(*dptr, handler->method, handler->len))
 			continue;
+		if ((*dptr)[handler->len] != ' ' ||
+		    !isalpha((*dptr)[handler->len+1]))
+			continue;
 
 		if (ct_sip_get_header(ct, *dptr, 0, *datalen, SIP_HDR_CSEQ,
 				      &matchoff, &matchlen) <= 0) {
Index: kernel/net/ipx/af_ipx.c
===================================================================
--- kernel/net/ipx/af_ipx.c	(revision 182213)
+++ kernel/net/ipx/af_ipx.c	(revision 182214)
@@ -1183,11 +1183,10 @@
 		sipx->sipx_network	= ipxif->if_netnum;
 		memcpy(sipx->sipx_node, ipxif->if_node,
 			sizeof(sipx->sipx_node));
-		rc = -EFAULT;
+		rc = 0;
 		if (copy_to_user(arg, &ifr, sizeof(ifr)))
-			break;
+			rc = -EFAULT;
 		ipxitf_put(ipxif);
-		rc = 0;
 		break;
 	}
 	case SIOCAIPXITFCRT:
Index: kernel/mm/mempolicy.c
===================================================================
--- kernel/mm/mempolicy.c	(revision 182213)
+++ kernel/mm/mempolicy.c	(revision 182214)
@@ -1537,7 +1537,6 @@
 asmlinkage long compat_sys_set_mempolicy(int mode, compat_ulong_t __user *nmask,
 				     compat_ulong_t maxnode)
 {
-	long err = 0;
 	unsigned long __user *nm = NULL;
 	unsigned long nr_bits, alloc_size;
 	DECLARE_BITMAP(bm, MAX_NUMNODES);
@@ -1546,14 +1545,13 @@
 	alloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;
 
 	if (nmask) {
-		err = compat_get_bitmap(bm, nmask, nr_bits);
+		if (compat_get_bitmap(bm, nmask, nr_bits))
+			return -EFAULT;
 		nm = compat_alloc_user_space(alloc_size);
-		err |= copy_to_user(nm, bm, alloc_size);
+		if (copy_to_user(nm, bm, alloc_size))
+			return -EFAULT;
 	}
 
-	if (err)
-		return -EFAULT;
-
 	return sys_set_mempolicy(mode, nm, nr_bits+1);
 }
 
@@ -1561,7 +1559,6 @@
 			     compat_ulong_t mode, compat_ulong_t __user *nmask,
 			     compat_ulong_t maxnode, compat_ulong_t flags)
 {
-	long err = 0;
 	unsigned long __user *nm = NULL;
 	unsigned long nr_bits, alloc_size;
 	nodemask_t bm;
@@ -1570,14 +1567,13 @@
 	alloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;
 
 	if (nmask) {
-		err = compat_get_bitmap(nodes_addr(bm), nmask, nr_bits);
+		if (compat_get_bitmap(nodes_addr(bm), nmask, nr_bits))
+			return -EFAULT;
 		nm = compat_alloc_user_space(alloc_size);
-		err |= copy_to_user(nm, nodes_addr(bm), alloc_size);
+		if (copy_to_user(nm, nodes_addr(bm), alloc_size))
+			return -EFAULT;
 	}
 
-	if (err)
-		return -EFAULT;
-
 	return sys_mbind(start, len, mode, nm, nr_bits+1, flags);
 }
 
Index: kernel/mm/memory.c
===================================================================
--- kernel/mm/memory.c	(revision 182213)
+++ kernel/mm/memory.c	(revision 182214)
@@ -1469,6 +1469,16 @@
 }
 EXPORT_SYMBOL_GPL(zap_vma_ptes);
 
+/*
+ * FOLL_FORCE can write to even unwritable pte's, but only
+ * after we've gone through a COW cycle and they are dirty.
+ */
+static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)
+{
+	return pte_write(pte) ||
+		((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));
+}
+
 /**
  * follow_page_mask - look up a page descriptor from a user-virtual address
  * @vma: vm_area_struct mapping @address
@@ -1576,7 +1586,7 @@
 	}
 	if ((flags & FOLL_NUMA) && pte_numa(pte))
 		goto no_page;
-	if ((flags & FOLL_WRITE) && !pte_write(pte))
+	if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags))
 		goto unlock;
 
 	page = vm_normal_page(vma, address, pte);
@@ -1883,7 +1893,7 @@
 				 */
 				if ((ret & VM_FAULT_WRITE) &&
 				    !(vma->vm_flags & VM_WRITE))
-					foll_flags &= ~FOLL_WRITE;
+					foll_flags |= FOLL_COW;
 
 				cond_resched();
 			}
Index: kernel/drivers/video/sprdfb/sprdfb_dsi.c
===================================================================
--- kernel/drivers/video/sprdfb/sprdfb_dsi.c	(revision 182213)
+++ kernel/drivers/video/sprdfb/sprdfb_dsi.c	(revision 182214)
@@ -873,6 +873,16 @@
 #define LCM_SEND(len) ((1 << 24)| len)
 #define LCM_TAG_MASK  ((1 << 24) -1)
 
+#ifdef CONFIG_FB_LCD_ILI9881C_1_MIPI
+static unsigned char set_bl_seq2[] = {
+#ifndef CONFIG_MACH_TSHARK2TABE
+       0x53, 0x24,
+	3,0,0x51,0xff,0xff
+#else
+	0xF5, 0x8B
+#endif
+};
+#endif
 static unsigned char set_bl_seq[] = {
 #ifndef CONFIG_MACH_TSHARK2TABE
        0x53, 0x20,
@@ -881,13 +891,40 @@
 	0xF5, 0x8B
 #endif
 };
-
+#ifdef CONFIG_FB_LCD_ILI9881C_1_MIPI
+static int init_brigtness =0;
+static int ret = 0;
+extern char *sprd_lcd_name;
+#endif
 void backlight_control(int brigtness)
 {
+#ifdef CONFIG_FB_LCD_ILI9881C_1_MIPI
+	if(init_brigtness == 0)
+	{
+		init_brigtness = 1;
+		ret = strncmp(sprd_lcd_name,"lcd_ili9881",11);
+		printk("lcd_ili9881:sprd_lcd_name = %s,ret = %d\n",sprd_lcd_name,ret);
+	}
+	if(!ret){
+		//if(brigtness<20)
+		//brigtness = 20;
+		set_bl_seq2[5] = ((brigtness * 4095)/255)>>8;
+		set_bl_seq2[6] = ((brigtness * 4095)/255) & 0xFF;
+		//printk("sprdfb BACKLIGHT brightness 3,0,0x51,0x%x,0x%x\n",set_bl_seq2[5],set_bl_seq2[6]);
+		//sprdfb_dsi_gen_write(&set_bl_seq2[0], LCM_SEND(2) & LCM_TAG_MASK);
+		sprdfb_dsi_gen_write(&set_bl_seq2[2], LCM_SEND(5) & LCM_TAG_MASK);
+	}else{
+		//if(brigtness<20)
+		//brigtness = 20;
+		//sprdfb_dsi_gen_write(&set_bl_seq[0], LCM_SEND(2) & LCM_TAG_MASK);
+		set_bl_seq[3] = brigtness;
+		sprdfb_dsi_gen_write(&set_bl_seq[2], LCM_SEND(2) & LCM_TAG_MASK);
+	}
+#else
 	set_bl_seq[3] = brigtness;
 	sprdfb_dsi_gen_write(&set_bl_seq[0], LCM_SEND(2) & LCM_TAG_MASK);
 	sprdfb_dsi_gen_write(&set_bl_seq[2], LCM_SEND(2) & LCM_TAG_MASK);
-
+#endif
 }
 EXPORT_SYMBOL(backlight_control);
 
Index: kernel/drivers/video/sprdfb/lcd/lcd_ili9881c_1_mipi.c
===================================================================
--- kernel/drivers/video/sprdfb/lcd/lcd_ili9881c_1_mipi.c	(revision 0)
+++ kernel/drivers/video/sprdfb/lcd/lcd_ili9881c_1_mipi.c	(revision 182214)
@@ -0,0 +1,435 @@
+/* drivers/video/sc8825/lcd_ili9881c_1_mipi.c
+ *
+ * Support for ili9881c_1 mipi LCD device
+ *
+ * Copyright (C) 2010 Spreadtrum
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+
+#include <linux/delay.h>
+#include "../sprdfb_panel.h"
+
+//#define LCD_Delay(ms)  uDelay(ms*1000)
+///#define printk printf
+
+#define  LCD_DEBUG
+#ifdef LCD_DEBUG
+#define LCD_PRINT printk
+#else
+#define LCD_PRINT(...)
+#endif
+
+#define MAX_DATA   56
+
+typedef struct LCM_Init_Code_tag {
+	unsigned int tag;
+	unsigned char data[MAX_DATA];
+}LCM_Init_Code;
+
+typedef struct LCM_force_cmd_code_tag{
+	unsigned int datatype;
+	LCM_Init_Code real_cmd_code;
+}LCM_Force_Cmd_Code;
+
+#define LCM_TAG_SHIFT 24
+#define LCM_TAG_MASK  ((1 << 24) -1)
+#define LCM_SEND(len) ((1 << LCM_TAG_SHIFT)| len)
+#define LCM_SLEEP(ms) ((2 << LCM_TAG_SHIFT)| ms)
+//#define ARRAY_SIZE(array) ( sizeof(array) / sizeof(array[0]))
+
+#define LCM_TAG_SEND  (1<< 0)
+#define LCM_TAG_SLEEP (1 << 1)
+
+static LCM_Init_Code init_data[] = {
+{LCM_SEND(6), {4,0,0xFF,0x98,0x81,0x03 }},
+{LCM_SEND(2), {0x01,0x00}},
+{LCM_SEND(2), {0x02,0x00}},
+{LCM_SEND(2), {0x03,0x53}},
+{LCM_SEND(2), {0x04,0x54}},
+{LCM_SEND(2), {0x05,0x14}},
+{LCM_SEND(2), {0x06,0x04}},
+{LCM_SEND(2), {0x07,0x03}},
+{LCM_SEND(2), {0x08,0x01}},
+{LCM_SEND(2), {0x09,0x00}},
+{LCM_SEND(2), {0x0a,0x64}},
+{LCM_SEND(2), {0x0b,0x64}},
+{LCM_SEND(2), {0x0c,0x00}},
+{LCM_SEND(2), {0x0d,0x00}},
+{LCM_SEND(2), {0x0e,0x00}},
+{LCM_SEND(2), {0x0f,0x00}},
+{LCM_SEND(2), {0x10,0x00}},
+{LCM_SEND(2), {0x11,0x00}},
+{LCM_SEND(2), {0x12,0x00}},
+{LCM_SEND(2), {0x13,0x00}},
+{LCM_SEND(2), {0x14,0x00}},
+{LCM_SEND(2), {0x15,0x00}},
+{LCM_SEND(2), {0x16,0x00}},
+{LCM_SEND(2), {0x17,0x00}},
+{LCM_SEND(2), {0x18,0x00}},
+{LCM_SEND(2), {0x19,0x00}},
+{LCM_SEND(2), {0x1a,0x00}},
+{LCM_SEND(2), {0x1b,0x00}},
+{LCM_SEND(2), {0x1c,0x00}},
+{LCM_SEND(2), {0x1d,0x00}},
+{LCM_SEND(2), {0x1e,0xC0}},
+{LCM_SEND(2), {0x1f,0x80}},
+{LCM_SEND(2), {0x20,0x02}},
+{LCM_SEND(2), {0x21,0x09}},
+{LCM_SEND(2), {0x22,0x00}},
+{LCM_SEND(2), {0x23,0x00}},
+{LCM_SEND(2), {0x24,0x00}},
+{LCM_SEND(2), {0x25,0x00}},
+{LCM_SEND(2), {0x26,0x00}},
+{LCM_SEND(2), {0x27,0x00}},
+{LCM_SEND(2), {0x28,0x55}},
+{LCM_SEND(2), {0x29,0x03}},
+{LCM_SEND(2), {0x2a,0x00}},
+{LCM_SEND(2), {0x2b,0x00}},
+{LCM_SEND(2), {0x2c,0x00}},
+{LCM_SEND(2), {0x2d,0x00}},
+{LCM_SEND(2), {0x2e,0x00}},
+{LCM_SEND(2), {0x2f,0x00}},
+{LCM_SEND(2), {0x30,0x00}},
+{LCM_SEND(2), {0x31,0x00}},
+{LCM_SEND(2), {0x32,0x00}},
+{LCM_SEND(2), {0x33,0x00}},
+{LCM_SEND(2), {0x34,0x03}},
+{LCM_SEND(2), {0x35,0x00}},
+{LCM_SEND(2), {0x36,0x05}},
+{LCM_SEND(2), {0x37,0x00}},
+{LCM_SEND(2), {0x38,0x01}},
+{LCM_SEND(2), {0x39,0x00}},
+{LCM_SEND(2), {0x3a,0x00}},
+{LCM_SEND(2), {0x3b,0x00}},
+{LCM_SEND(2), {0x3c,0x00}},
+{LCM_SEND(2), {0x3d,0x00}},
+{LCM_SEND(2), {0x3e,0x00}},
+{LCM_SEND(2), {0x3f,0x00}},
+{LCM_SEND(2), {0x40,0x00}},
+{LCM_SEND(2), {0x41,0x00}},
+{LCM_SEND(2), {0x42,0x00}},
+{LCM_SEND(2), {0x43,0x00}},
+{LCM_SEND(2), {0x44,0x00}},
+{LCM_SEND(2), {0x50,0x01}},
+{LCM_SEND(2), {0x51,0x23}},
+{LCM_SEND(2), {0x52,0x45}},
+{LCM_SEND(2), {0x53,0x67}},
+{LCM_SEND(2), {0x54,0x89}},
+{LCM_SEND(2), {0x55,0xab}},
+{LCM_SEND(2), {0x56,0x01}},
+{LCM_SEND(2), {0x57,0x23}},
+{LCM_SEND(2), {0x58,0x45}},
+{LCM_SEND(2), {0x59,0x67}},
+{LCM_SEND(2), {0x5a,0x89}},
+{LCM_SEND(2), {0x5b,0xab}},
+{LCM_SEND(2), {0x5c,0xcd}},
+{LCM_SEND(2), {0x5d,0xef}},
+{LCM_SEND(2), {0x5e,0x01}},
+{LCM_SEND(2), {0x5f,0x14}},
+{LCM_SEND(2), {0x60,0x15}},
+{LCM_SEND(2), {0x61,0x0C}},
+{LCM_SEND(2), {0x62,0x0D}},
+{LCM_SEND(2), {0x63,0x0E}},
+{LCM_SEND(2), {0x64,0x0F}},
+{LCM_SEND(2), {0x65,0x10}},
+{LCM_SEND(2), {0x66,0x11}},
+{LCM_SEND(2), {0x67,0x08}},
+{LCM_SEND(2), {0x68,0x02}},
+{LCM_SEND(2), {0x69,0x0A}},
+{LCM_SEND(2), {0x6a,0x02}},
+{LCM_SEND(2), {0x6b,0x02}},
+{LCM_SEND(2), {0x6c,0x02}},
+{LCM_SEND(2), {0x6d,0x02}},
+{LCM_SEND(2), {0x6e,0x02}},
+{LCM_SEND(2), {0x6f,0x02}},
+{LCM_SEND(2), {0x70,0x02}},
+{LCM_SEND(2), {0x71,0x02}},
+{LCM_SEND(2), {0x72,0x06}},
+{LCM_SEND(2), {0x73,0x02}},
+{LCM_SEND(2), {0x74,0x02}},
+{LCM_SEND(2), {0x75,0x14}},
+{LCM_SEND(2), {0x76,0x15}},
+{LCM_SEND(2), {0x77,0x0F}},
+{LCM_SEND(2), {0x78,0x0E}},
+{LCM_SEND(2), {0x79,0x0D}},
+{LCM_SEND(2), {0x7a,0x0C}},
+{LCM_SEND(2), {0x7b,0x11}},
+{LCM_SEND(2), {0x7c,0x10}},
+{LCM_SEND(2), {0x7d,0x06}},
+{LCM_SEND(2), {0x7e,0x02}},
+{LCM_SEND(2), {0x7f,0x0A}},
+{LCM_SEND(2), {0x80,0x02}},
+{LCM_SEND(2), {0x81,0x02}},
+{LCM_SEND(2), {0x82,0x02}},
+{LCM_SEND(2), {0x83,0x02}},
+{LCM_SEND(2), {0x84,0x02}},
+{LCM_SEND(2), {0x85,0x02}},
+{LCM_SEND(2), {0x86,0x02}},
+{LCM_SEND(2), {0x87,0x02}},
+{LCM_SEND(2), {0x88,0x08}},
+{LCM_SEND(2), {0x89,0x02}},
+{LCM_SEND(2), {0x8A,0x02}},
+{LCM_SEND(6), {4,0,0xFF,0x98,0x81,0x04 }},
+{LCM_SEND(2), {0x6C,0x15}},
+{LCM_SEND(2), {0x6E,0x2F}},
+{LCM_SEND(2), {0x6F,0x55}},
+{LCM_SEND(2), {0x3A,0xA4}},
+{LCM_SEND(2), {0x8D,0x1F}},
+{LCM_SEND(2), {0x87,0xBA}},
+{LCM_SEND(2), {0x26,0x76}},
+{LCM_SEND(2), {0xB2,0xD1}},
+{LCM_SEND(2), {0x88,0x0B}},
+{LCM_SEND(6), {4,0,0xFF,0x98,0x81,0x01 }},
+{LCM_SEND(2), {0x22,0x0A}},
+{LCM_SEND(2), {0x31,0x00}},
+{LCM_SEND(2), {0x53,0x8A}},
+{LCM_SEND(2), {0x55,0x88}},
+{LCM_SEND(2), {0x50,0xC0}},
+{LCM_SEND(2), {0x51,0xC0}},
+{LCM_SEND(2), {0x60,0x30}},
+{LCM_SEND(2), {0xA0,0x08}},
+{LCM_SEND(2), {0xA1,0x1E}},
+{LCM_SEND(2), {0xA2,0x2C}},
+{LCM_SEND(2), {0xA3,0x15}},
+{LCM_SEND(2), {0xA4,0x18}},
+{LCM_SEND(2), {0xA5,0x2A}},
+{LCM_SEND(2), {0xA6,0x1F}},
+{LCM_SEND(2), {0xA7,0x1F}},
+{LCM_SEND(2), {0xA8,0x85}},
+{LCM_SEND(2), {0xA9,0x1C}},
+{LCM_SEND(2), {0xAA,0x2A}},
+{LCM_SEND(2), {0xAB,0x72}},
+{LCM_SEND(2), {0xAC,0x1A}},
+{LCM_SEND(2), {0xAD,0x18}},
+{LCM_SEND(2), {0xAE,0x4C}},
+{LCM_SEND(2), {0xAF,0x20}},
+{LCM_SEND(2), {0xB0,0x26}},
+{LCM_SEND(2), {0xB1,0x4A}},
+{LCM_SEND(2), {0xB2,0x57}},
+{LCM_SEND(2), {0xB3,0x2C}},
+{LCM_SEND(2), {0xC0,0x08}},
+{LCM_SEND(2), {0xC1,0x1B}},
+{LCM_SEND(2), {0xC2,0x27}},
+{LCM_SEND(2), {0xC3,0x12}},
+{LCM_SEND(2), {0xC4,0x14}},
+{LCM_SEND(2), {0xC5,0x25}},
+{LCM_SEND(2), {0xC6,0x1A}},
+{LCM_SEND(2), {0xC7,0x1D}},
+{LCM_SEND(2), {0xC8,0x7A}},
+{LCM_SEND(2), {0xC9,0x1A}},
+{LCM_SEND(2), {0xCA,0x28}},
+{LCM_SEND(2), {0xCB,0x6B}},
+{LCM_SEND(2), {0xCC,0x1F}},
+{LCM_SEND(2), {0xCD,0x1D}},
+{LCM_SEND(2), {0xCE,0x52}},
+{LCM_SEND(2), {0xCF,0x24}},
+{LCM_SEND(2), {0xD0,0x2D}},
+{LCM_SEND(2), {0xD1,0x47}},
+{LCM_SEND(2), {0xD2,0x55}},
+{LCM_SEND(2), {0xD3,0x2C}},
+{LCM_SEND(6), {4,0,0xFF,0x98,0x81,0x00 }},
+{LCM_SEND(2), {0x11,0x00}},
+{LCM_SLEEP(120)},
+{LCM_SEND(2), {0x29,0x00}},
+{LCM_SEND(5), {3,0,0x51,0x00,0x00}},
+{LCM_SEND(2), {0x53,0x24}},
+{LCM_SLEEP(20)},
+};
+
+static LCM_Init_Code disp_on =  {LCM_SEND(1), {0x29}};
+
+static LCM_Init_Code sleep_in[] =  {
+	//{LCM_SEND(1), {0x10}},
+	{LCM_SEND(1), {0x28}},
+    {LCM_SLEEP(120)},
+    {LCM_SEND(1), {0x10}},
+    {LCM_SLEEP(10)},
+	
+	};
+
+static LCM_Init_Code sleep_out[] =  {
+	//{LCM_SEND(1), {0x11}},
+	{LCM_SEND(1), {0x11}},
+    {LCM_SLEEP(120)},
+    {LCM_SEND(1), {0x29}},
+    {LCM_SLEEP(20)},
+	};
+
+static int32_t ili9881c_1_mipi_init(struct panel_spec *self)
+{
+	int32_t i;
+	LCM_Init_Code *init = init_data;
+	unsigned int tag;
+
+	mipi_set_cmd_mode_t mipi_set_cmd_mode = self->info.mipi->ops->mipi_set_cmd_mode;
+	mipi_gen_write_t mipi_gen_write = self->info.mipi->ops->mipi_gen_write;
+
+	LCD_PRINT("ili9881c_1_init\n");
+
+	mipi_set_cmd_mode();
+
+	for(i = 0; i < ARRAY_SIZE(init_data); i++){
+		tag = (init->tag >>24);
+		if(tag & LCM_TAG_SEND){
+			mipi_gen_write(init->data, (init->tag & LCM_TAG_MASK));
+		}else if(tag & LCM_TAG_SLEEP){
+			mdelay((init->tag & LCM_TAG_MASK));
+		}
+		init++;
+	}
+	return 0;
+}
+
+static LCM_Force_Cmd_Code rd_prep_code[]={
+        {0x39, {LCM_SEND(6), {0x6, 0, 0xFF, 0x98, 0x81, 0x01}}},
+        {0x37, {LCM_SEND(2), {0x3, 0}}},
+};
+
+static uint32_t ili9881c_1_readid(struct panel_spec *self)
+{
+        /*Jessica TODO: need read id*/
+        int32_t i = 0;
+        uint32_t j =0;
+        LCM_Force_Cmd_Code * rd_prepare = rd_prep_code;
+        uint8_t read_data[3] = {0};
+        int32_t read_rtn = 0;
+        unsigned int tag = 0;
+        mipi_set_cmd_mode_t mipi_set_cmd_mode = self->info.mipi->ops->mipi_set_cmd_mode;
+        mipi_force_write_t mipi_force_write = self->info.mipi->ops->mipi_force_write;
+        mipi_force_read_t mipi_force_read = self->info.mipi->ops->mipi_force_read;
+        mipi_eotp_set_t mipi_eotp_set = self->info.mipi->ops->mipi_eotp_set;
+ 
+
+        LCD_PRINT("lcd_ili9881c_1_mipi read id!\n");
+ 
+
+        mipi_set_cmd_mode();
+        for(j = 0; j < 4; j++){
+                rd_prepare = rd_prep_code;
+                for(i = 0; i < ARRAY_SIZE(rd_prep_code); i++){
+                        tag = (rd_prepare->real_cmd_code.tag >> 24);
+                        if(tag & LCM_TAG_SEND){
+                                mipi_force_write(rd_prepare->datatype, rd_prepare->real_cmd_code.data, (rd_prepare->real_cmd_code.tag & LCM_TAG_MASK));
+                        }else if(tag & LCM_TAG_SLEEP){
+                                mdelay((rd_prepare->real_cmd_code.tag & LCM_TAG_MASK));
+                        }
+                        rd_prepare++;
+                }
+                mipi_eotp_set(0,0);
+                read_rtn = mipi_force_read(0x00, 1,(uint8_t *)&read_data[0]);
+                read_rtn = mipi_force_read(0x01, 1,(uint8_t *)&read_data[1]);
+                mipi_eotp_set(1,1);
+                LCD_PRINT("lcd_ili9881c_1_mipi read id 0x00 value is 0x%x, 0x%x, 0x%x!\n", read_data[0], read_data[1], read_data[2]);
+ 
+
+                if((0x98 == read_data[0])&&(0x81 == read_data[1])){
+                        LCD_PRINT("lcd_ili9881c_1_mipi read id success!\n");
+                        return 0x98811;
+                }
+        }
+        
+        return 0;
+}
+
+static int32_t ili9881c_1_enter_sleep(struct panel_spec *self, uint8_t is_sleep)
+{
+	int32_t i;
+	LCM_Init_Code *sleep_in_out = NULL;
+	unsigned int tag;
+	int32_t size = 0;
+
+	mipi_gen_write_t mipi_gen_write = self->info.mipi->ops->mipi_gen_write;
+	mipi_eotp_set_t mipi_eotp_set = self->info.mipi->ops->mipi_eotp_set;
+
+	printk(KERN_DEBUG "ili9881c_1_enter_sleep, is_sleep = %d\n", is_sleep);
+
+	if(is_sleep){
+		sleep_in_out = sleep_in;
+		size = ARRAY_SIZE(sleep_in);
+	}else{
+		sleep_in_out = sleep_out;
+		size = ARRAY_SIZE(sleep_out);
+	}
+	mipi_eotp_set(1,0);
+
+	for(i = 0; i <size ; i++){
+		tag = (sleep_in_out->tag >>24);
+		if(tag & LCM_TAG_SEND){
+			mipi_gen_write(sleep_in_out->data, (sleep_in_out->tag & LCM_TAG_MASK));
+		}else if(tag & LCM_TAG_SLEEP){
+			//udelay((sleep_in_out->tag & LCM_TAG_MASK) * 1000);
+			msleep((sleep_in_out->tag & LCM_TAG_MASK));
+		}
+		sleep_in_out++;
+	}
+	return 0;
+}
+
+
+static struct panel_operations lcd_ili9881c_1_mipi_operations = {
+	.panel_init = ili9881c_1_mipi_init,
+	.panel_readid = ili9881c_1_readid,
+	.panel_enter_sleep = ili9881c_1_enter_sleep,
+};
+
+static struct timing_rgb lcd_ili9881c_1_mipi_timing = {
+	.hfp = 30,  /* unit: pixel */
+	.hbp = 30,
+	.hsync = 20,
+	.vfp = 20, /*unit: line*/
+	.vbp = 20,
+	.vsync = 6,
+};
+
+static struct info_mipi lcd_ili9881c_1_mipi_info = {
+	.work_mode  = SPRDFB_MIPI_MODE_VIDEO,
+	.video_bus_width = 24, /*18,16*/
+	.lan_number = 4,
+	.phy_feq = 500*1000,
+	.h_sync_pol = SPRDFB_POLARITY_POS,
+	.v_sync_pol = SPRDFB_POLARITY_POS,
+	.de_pol = SPRDFB_POLARITY_POS,
+	.te_pol = SPRDFB_POLARITY_POS,
+	.color_mode_pol = SPRDFB_POLARITY_NEG,
+	.shut_down_pol = SPRDFB_POLARITY_NEG,
+	.timing = &lcd_ili9881c_1_mipi_timing,
+	.ops = NULL,
+};
+
+struct panel_spec lcd_ili9881c_1_mipi_spec = {
+	.width = 720,
+	.height = 1280,
+	.fps = 60,
+	.type = LCD_MODE_DSI,
+	.direction = LCD_DIRECT_NORMAL,
+	.info = {
+		.mipi = &lcd_ili9881c_1_mipi_info
+	},
+	.ops = &lcd_ili9881c_1_mipi_operations,
+	.suspend_mode = SEND_SLEEP_CMD,
+};
+
+struct panel_cfg lcd_ili9881c_1_mipi = {
+	/* this panel can only be main lcd */
+	.dev_id = SPRDFB_MAINLCD_ID,
+	.lcd_id = 0x98811,
+	.lcd_name = "lcd_ili9881c_1_mipi",
+	.panel = &lcd_ili9881c_1_mipi_spec,
+};
+
+static int __init lcd_ili9881c_1_mipi_init(void)
+{
+	return sprdfb_panel_register(&lcd_ili9881c_1_mipi);
+}
+
+subsys_initcall(lcd_ili9881c_1_mipi_init);
Index: kernel/drivers/video/sprdfb/lcd/Makefile
===================================================================
--- kernel/drivers/video/sprdfb/lcd/Makefile	(revision 182213)
+++ kernel/drivers/video/sprdfb/lcd/Makefile	(revision 182214)
@@ -37,6 +37,7 @@
 obj-$(CONFIG_FB_LCD_ILI9806E_2_MIPI_HSD) += lcd_ili9806e_2_mipi_hsd.o
 obj-$(CONFIG_FB_LCD_ILI9806E_2_MIPI_TXD) += lcd_ili9806e_2_mipi_txd.o
 obj-$(CONFIG_FB_LCD_ILI9881C_MIPI) += lcd_ili9881c_mipi.o
+obj-$(CONFIG_FB_LCD_ILI9881C_1_MIPI) += lcd_ili9881c_1_mipi.o
 obj-$(CONFIG_FB_LCD_T8861_MIPI)  += lcd_t8861_mipi.o
 obj-$(CONFIG_FB_LCD_HX8379A_MIPI)  += lcd_hx8379a_mipi.o
 obj-$(CONFIG_FB_LCD_HX8389C_MIPI) += lcd_hx8389c_mipi.o
Index: kernel/drivers/video/sprdfb/Kconfig
===================================================================
--- kernel/drivers/video/sprdfb/Kconfig	(revision 182213)
+++ kernel/drivers/video/sprdfb/Kconfig	(revision 182214)
@@ -378,6 +378,11 @@
     boolean "support ili9881c mipi panel"
     default n
 
+config FB_LCD_ILI9881C_1_MIPI
+    boolean "support ili9881c_1 mipi panel"
+    default n
+
+
 config FB_LCD_AMS549HQ01_MIPI
         boolean "support ams549hq01 mipi panel"
         default n
