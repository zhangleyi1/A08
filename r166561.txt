Index: kernel/drivers/power/sprd_charge_helper.c
===================================================================
--- kernel/drivers/power/sprd_charge_helper.c	(revision 166560)
+++ kernel/drivers/power/sprd_charge_helper.c	(revision 166561)
@@ -302,7 +302,7 @@
 	return result;
 }
 
-
+#if 0
 int sprdchg_read_temp_adc(void)
 {
 #define SAMPLE_NUM  15
@@ -348,7 +348,127 @@
 		return 3000;
 	}
 }
+#else
+#define TEMPERATURE_BUFFER_COUNT		24
+static int temperature_buffer[TEMPERATURE_BUFFER_COUNT];
 
+static int temperature_array[][2] =
+{
+//	1#				2#
+	{3106,  -200},	//3134
+	{2988,  -150},	//3016
+	{2842,  -100},	//2890
+	{2711,  -50},		//2760
+	{2557,    0},		//2606
+	{2415,    50},		//2440
+	{2245,   100},		//2277
+	{2060,   150},		//2100
+	{1883,   200},		//1920
+	{1721,   250},		//1748
+	{1555,   300},		//1582
+	{1403,   350},		//1430
+	{1249,   400},		//1279
+	{1116,   450},		//1140
+	{950,   500},		//1020
+	{833,   540},		//55: 916
+	{670,   600},		//806
+};
+
+int sprdchg_read_temp_adc(void)
+{
+	return sci_adc_get_value(ADC_CHANNEL_0, false);
+}
+
+static int sprdchg_get_true_temp(void)
+{
+	int adc_value;
+	int temp;
+	uint32_t i, j;
+	uint32_t count;
+
+	adc_value = sprdchg_read_temp_adc();
+	count = sizeof(temperature_array)/sizeof(int)/2;
+	for(i=0; i<count; i++)
+	{
+		if(adc_value >= temperature_array[i][0])
+		{
+			break;
+		}
+	}
+
+	if(i == 0)
+	{
+		j = 0;
+		i = 1;
+	}
+	else if(i >= count)
+	{
+		j = count -2;
+		i = count-1;
+	}
+	else
+	{
+		j = i-1;
+	}
+
+	temp = temperature_array[i][1]
+			+ (adc_value-temperature_array[i][0])
+			*(temperature_array[j][1]-temperature_array[i][1])
+			/(temperature_array[j][0]-temperature_array[i][0]);
+
+	printk("sprdchg_get_true_temp adc = %d, temp = %d\r\n", adc_value, temp);
+
+	return temp;
+}
+
+static int sprdchg_get_temp(void)
+{
+	uint32_t i;
+	int sum = 0;
+	static uint8_t discard_cnt = 1;
+
+	if(discard_cnt == 0)
+	{
+		for(i=0; i<TEMPERATURE_BUFFER_COUNT-1; i++)
+		{
+			temperature_buffer[i] = temperature_buffer[i+1];
+		}
+
+		temperature_buffer[TEMPERATURE_BUFFER_COUNT-1] = sprdchg_get_true_temp();
+	}
+	else
+	{
+		if(--discard_cnt == 0)
+		{
+			for(i=0; i<TEMPERATURE_BUFFER_COUNT; i++)
+			{
+				temperature_buffer[i] = sprdchg_get_true_temp();
+			}
+		}
+		else
+		{
+			return 200;
+		}
+	}
+
+	for(i=0; i<TEMPERATURE_BUFFER_COUNT; i++)
+	{
+		sum += temperature_buffer[i];
+	}
+
+	sum /= TEMPERATURE_BUFFER_COUNT;
+
+	return sum;
+}
+
+int sprdchg_read_temp(void)
+{
+	return sprdchg_get_temp();
+//	return 200;
+}
+
+#endif
+
 static int sprdchg_temp_vol_comp(int vol)
 {
 	int bat_cur = sprdfgu_read_batcurrent();
@@ -408,6 +528,7 @@
 }
 
 #define TEMP_BUFF_EN
+#if 0
 int sprdchg_read_temp(void)
 {
 	if (pbat_data->temp_support) {
@@ -434,7 +555,7 @@
 		return 200;
 	}
 }
-
+#endif
 uint32_t sprdchg_read_vchg_vol(void)
 {
 	int vchg_value;
Index: kernel/drivers/power/fan54015_charge.c
===================================================================
--- kernel/drivers/power/fan54015_charge.c	(revision 166560)
+++ kernel/drivers/power/fan54015_charge.c	(revision 166561)
@@ -8,314 +8,611 @@
 #include "sprd_battery.h"
 #include "fan54015.h"
 
-#define SPRDCHG__DEBUG
-#ifdef SPRDCHG__DEBUG
-#define SPRDCHG_54015_DEBUG(format, arg...) printk( "sprd 54015: " "@@@" format, ## arg)
-#else
-#define SPRDCHG_54015_DEBUG(format, arg...)
-#endif
+#define SPRDCHG_DEBUG(format, arg...) pr_info("hl7059: " format, ## arg)
 
-void sprdchg_fan54015_set_vindpm(int vin)
+static struct sprd_battery_platform_data *bat_drv_data;
+
+void sprdchg_hl7059_set_vindpm(int vin)
 {
-	SPRDCHG_54015_DEBUG("sprdchg_fan54015_set_vindpm vin =%d\n",vin);
-	BYTE reg_val = 0x0;
-	if(vin <= 4213){
+	unsigned char reg_val = 0x0;
+
+	SPRDCHG_DEBUG("%s vin =%d\n", __func__, vin);
+
+	if (vin <= 3880 )
 		reg_val = 0x0;
-	}else if (vin >= 4773){
-		reg_val = 0x7;
-	}else{
-		reg_val = (vin -4213) / 80 +1;
-	}
-	fan54015_set_vindpm(reg_val);
+	else if (vin >= 5080)
+		reg_val = 0x0f;
+	else
+		reg_val = (vin - 3880) / 80;
+
+	hl7059_set_vindpm(reg_val);
 }
-void  sprdchg_fan54015_termina_cur_set(int cur)
+
+void sprdchg_hl7059_termina_cur_set(uint32_t cur)
 {
-	BYTE reg_val = 0x0;
-	SPRDCHG_54015_DEBUG("sprdchg_fan54015_termina_cur_set cur =%d\n",cur);
-	if(cur <= 49){
+#if 1
+	unsigned char reg_val = 0x0;
+
+	SPRDCHG_DEBUG("%s cur =%d\n", __func__, cur);
+
+	if (cur <= 128)
 		reg_val = 0x0;
-	}else if( cur >= 388){
-		reg_val = 0x7;
-	}else{
-		reg_val = (cur -48) /48;
-	}
-	fan54015_termina_cur_set(reg_val);
+	else if (cur >= 2048)
+		reg_val = 0xf;
+	else
+		reg_val = (cur - 128) / 128;
+
+	hl7059_set_iterm(reg_val);
+#endif
 }
-void sprdchg_fan54015_termina_vol_set(int vol)
+
+void sprdchg_hl7059_termina_vol_set(uint32_t vol)
 {
-	BYTE reg_val = 0x0;
-	SPRDCHG_54015_DEBUG("sprdchg_fan54015_termina_vol_set vol =%d\n",vol);
-	if(vol <= 3500){
+	unsigned char reg_val = 0x0;
+
+	//SPRDCHG_DEBUG("%s vol =%d\n", __func__, vol);
+#if 0
+	if (vol <= 3504)
 		reg_val = 0x0;
-	}else if( vol >= 4440){
-		reg_val = 0x2e;
-	}else{
-		reg_val = (vol -3499)/20;
-	}
-	fan54015_termina_vol_set(reg_val);
+	else if (vol >= 4440)
+		reg_val = 0x38;
+	else
+		reg_val = (vol - 3504) / 16;
+#endif
+	
+	hl7059_set_vreg(vol);
 }
-void sprdchg_fan54015_set_safety_vol(int vol)
+
+void sprdchg_hl7059_set_safety_vol(int vol)
 {
-	BYTE reg_val = 0x0;
-	if(vol < 4200 )
+#if 0	
+	unsigned char reg_val = 0x0;
+
+	SPRDCHG_DEBUG("%s vol =%d\n", __func__, vol);
+
+	if (vol < 4200)
 		vol = 4200;
-	if(vol > 4440)
+	if (vol > 4440)
 		vol = 4440;
 	reg_val = (vol - 4200) / 20 + 1;
-	fan54015_set_safety_vol(reg_val);
+
+	hl7059_set_safety_vol(reg_val);
+#endif 
 }
-void sprdchg_fan54015_set_safety_cur(int cur)
+
+void sprdchg_hl7059_set_safety_cur(int cur)
 {
-	BYTE reg_val = 0x7;
-	fan54015_set_safety_cur(reg_val);
+#if 0	
+	unsigned char reg_val = 0x7;
+
+	SPRDCHG_DEBUG("%s cur = max\n", __func__);
+	hl7059_set_safety_cur(reg_val);
+#endif
 }
 
-BYTE sprdchg_fan54015_cur2reg(int cur)
+unsigned char sprdchg_hl7059_cur2reg(uint32_t cur)
 {
-	BYTE reg_val;
-	if(cur < 650)
-		reg_val = 0;
-	if((cur >= 650) && (cur < 750))
-		reg_val = 1;
-	if((cur >= 750) && (cur < 850))
-		reg_val = 2;
-	if((cur >= 850) && (cur < 1050))
-		reg_val = 3;
-	if((cur >= 1050) && (cur <1150))
-		reg_val = 4;
-	if((cur >= 1150) && (cur < 1350))
-		reg_val = 5;
-	if((cur >= 1350) && (cur < 1450))
-		reg_val = 6;
-	if(cur >= 1450)
-		reg_val = 7;
+	unsigned char reg_val;
+
+	if (cur < 512)
+	reg_val = 0;
+	if ((cur >= 512) && (cur < 576))
+	reg_val = 0;
+	if ((cur >= 576) && (cur < 640))
+	reg_val = 1;
+	if ((cur >= 640) && (cur < 704))
+	reg_val = 2;
+	if ((cur >= 704) && (cur < 768))
+	reg_val = 3;
+	if ((cur >= 768) && (cur < 832))
+	reg_val = 4;
+	if ((cur >= 832) && (cur < 896))
+	reg_val = 5;
+	if ((cur >= 896) && (cur < 960))
+	reg_val = 6;
+	if ((cur >= 960) && (cur < 1024))
+	reg_val = 7;
+	if ((cur >= 1024) && (cur < 1088))
+	reg_val = 8;
+	if ((cur >= 1088) && (cur < 1152))
+	reg_val = 9;
+	if ((cur >= 1152) && (cur < 1216))
+	reg_val = 10;
+	if ((cur >= 1216) && (cur < 1280))
+	reg_val = 11;
+	if ((cur >= 1280) && (cur < 1344))
+	reg_val = 12;
+	if ((cur >= 1344) && (cur < 1408))
+	reg_val = 13;
+	if ((cur >= 1408) && (cur < 1472))
+	reg_val = 14;
+	if ((cur >= 1472) && (cur < 1536))
+	reg_val = 15;
+	if ((cur >= 1536) && (cur < 1600))
+	reg_val = 16;
+	if ((cur >= 1600) && (cur < 1664))
+	reg_val = 17;
+	if ((cur >= 1664) && (cur < 1728))
+	reg_val = 18;
+	if ((cur >= 1728) && (cur < 1792))
+	reg_val = 19;
+	if ((cur >= 1792) && (cur < 1856))
+	reg_val = 20;
+	if ((cur >= 1856) && (cur < 1920))
+	reg_val = 21;
+	if ((cur >= 1920) && (cur < 1984))
+	reg_val = 22;
+	if (cur >= 1984)
+	reg_val = 23;
+
+
+	
 	return reg_val;
 }
-int sprdchg_fan54015_reg2cur(BYTE reg_val)
+
+unsigned int sprdchg_hl7059_reg2cur(unsigned char reg_val)
 {
-	int cur = 0;
-	switch (reg_val){
-		case 0:
-			cur = 550;
-			break;
-		case 1:
-			cur = 650;
-			break;
-		case 2:
-			cur = 750;
-			break;
-		case 3:
-			cur = 850;
-			break;
-		case 4 :
-			cur = 1050;
-			break;
-		case 5:
-			cur = 1150;
-			break;
-		case 6:
-			cur = 1350;
-			break;
-		case 7:
-			cur = 1450;
-			break;
-		default :
-			cur = 550;
+	unsigned int cur = 0;
+
+	switch (reg_val) {
+	case 0:
+	cur = 512;
+	break;
+	case 1:
+	cur = 576;
+	break;
+	case 2:
+	cur = 640;
+	break;
+	case 3:
+	cur = 704;
+	break;
+	case 4:
+	cur = 768;
+	break;
+	case 5:
+	cur = 832;
+	break;
+	case 6:
+	cur = 896;
+	break;
+	case 7:
+	cur = 960;
+	break;
+	case 8:
+	cur = 1024;
+	break;
+	case 9:
+	cur = 1088;
+	break;
+	case 10:
+	cur = 1152;
+	break;
+	case 11:
+	cur = 1216;
+	break;
+	case 12:
+	cur = 1280;
+	break;
+	case 13:
+	cur = 1344;
+	break;
+	case 14:
+	cur = 1408;
+	break;
+	case 15:
+	cur = 1472;
+	break;
+	case 16:
+	cur = 1536;
+	break;
+	case 17:
+	cur = 1600;
+	break;
+	case 18:
+	cur = 1664;
+	break;
+	case 19:
+	cur = 1728;
+	break;
+	case 20:
+	cur = 1792;
+	break;
+	case 21:
+	cur = 1856;
+	break;
+	case 22:
+	cur = 1920;
+	break;
+	case 23:
+	cur = 1984;
+	break;
+	case 24:
+	cur = 2048;
+	break;
+	case 25:
+	cur = 2112;
+	break;
+	case 26:
+	cur = 2176;
+	break;
+	case 27:
+	cur = 2240;
+	break;
+	case 28:
+	cur = 2304;
+	break;
+	case 29:
+	cur = 2368;
+	break;
+	case 30:
+	cur = 2432;
+	break;
+	case 31:
+	cur = 2496;
+	break;
+	case 32:
+	cur = 2560;
+	break;
+	case 33:
+	cur = 2624;
+	break;
+	case 34:
+	cur = 2688;
+	break;
+	case 35:
+	cur = 2752;
+	break;
+	case 36:
+	cur = 2816;
+	break;
+	case 37:
+	cur = 2880;
+	break;
+	case 38:
+	cur = 2944;
+	break;
+	case 39:
+	cur = 3008;
+	break;
+	case 40:
+	cur = 3072;
+	break;
+	case 41:
+	cur = 3136;
+	break;
+	case 42:
+	cur = 3200;
+	break;
+	case 43:
+	cur = 3264;
+	break;
+	case 44:
+	cur = 3328;
+	break;
+	case 45:
+	cur = 3392;
+	break;
+	case 46:
+	cur = 3456;
+	break;
+	case 47:
+	cur = 3520;
+	break;
+	case 48:
+	cur = 3584;
+	break;
+	case 49:
+	cur = 3648;
+	break;
+	case 50:
+	cur = 3712;
+	break;
+	case 51:
+	cur = 3776;
+	break;
+	case 52:
+	cur = 3840;
+	break;
+	case 53:
+	cur = 3904;
+	break;
+	case 54:
+	cur = 3968;
+	break;
+	case 55:
+	cur = 4032;
+	break;
+	case 56:
+	cur = 4096;
+	break;
+	case 57:
+	cur = 4160;
+	break;
+	case 58:
+	cur = 4224;
+	break;
+	case 59:
+	cur = 4288;
+	break;
+	case 60:
+	cur = 4352;
+	break;
+	case 61:
+	cur = 4416;
+	break;
+	case 62:
+	cur = 4480;
+	break;
+	case 63:
+	cur = 4544;
+	break;
+	case 64:
+	cur = 4544;
+	break;		
+	default:
+	cur = 2048;
 	}
 	return cur;
 }
-int sprdchg_tq24157_reg2cur(BYTE reg_val)
+
+void sprdchg_hl7059_reset_timer(void)
 {
-	return (550 + reg_val * 100);
+	hl7059_reset_timer();
 }
-BYTE sprdchg_tq24157_cur2reg(int cur)
+
+void sprdchg_hl7059_otg_enable(int enable)
 {
-	BYTE reg_val;
-	SPRDCHG_54015_DEBUG("sprdchg_tq24157_cur2reg\n");
-	if(cur < 650){
-		reg_val = 0;
-	}else if(cur >= 1250){
-		reg_val = 7;
-	}else{
-		reg_val = (cur -550)/100;
-	}
-	return reg_val;
+	hl7059_otg_enable(enable);
 }
-void  sprdchg_fan54015_reset_timer(void)
+
+void sprdchg_hl7059_stop_charging(void)
 {
-	fan54015_reset_timer();
+	hl7059_set_chg_config(0);
 }
-EXPORT_SYMBOL_GPL(sprdchg_fan54015_reset_timer);
-void sprdchg_fan54015_otg_enable(int enable)
-{
-	fan54015_otg_enable(enable);
-}
-EXPORT_SYMBOL_GPL(sprdchg_fan54015_otg_enable);
 
-void sprdchg_fan54015_stop_charging(void)
+int sprdchg_hl7059_get_charge_status(void)
 {
-	fan54015_stop_charging();
-}
-EXPORT_SYMBOL_GPL(sprdchg_fan54015_stop_charging);
+#if 1
+	unsigned char chg_status = hl7059_get_chrg_stat();
 
-int sprdchg_fan54015_get_charge_status(void)
-{
-	BYTE chg_status = 0;
-	chg_status = fan54015_get_chg_status();
-	switch(chg_status){
-		case CHG_READY:
-			SPRDCHG_54015_DEBUG("fan54015 charge ready\n");
-			return POWER_SUPPLY_STATUS_NOT_CHARGING;
-		case CHG_CHGING:
-			SPRDCHG_54015_DEBUG("fan54015 is charging\n");
-			return POWER_SUPPLY_STATUS_CHARGING;
-		case CHG_DONE:
-			SPRDCHG_54015_DEBUG("fan54015 charge full\n");
-			return POWER_SUPPLY_STATUS_FULL;
-		default:
-			SPRDCHG_54015_DEBUG("fan54015 charge fault\n");
-			return POWER_SUPPLY_STATUS_DISCHARGING;
+	switch (chg_status) {
+	case CHG_READY:
+		SPRDCHG_DEBUG("hl7059 charge ready\n");
+		return POWER_SUPPLY_STATUS_NOT_CHARGING;
+	case CHG_CHGING:
+		SPRDCHG_DEBUG("hl7059 is charging\n");
+		return POWER_SUPPLY_STATUS_CHARGING;
+	case CHG_DONE:
+		SPRDCHG_DEBUG("hl7059 charge full\n");
+		return POWER_SUPPLY_STATUS_FULL;
+	default:
+		SPRDCHG_DEBUG("hl7059 charge fault\n");
+		return POWER_SUPPLY_STATUS_DISCHARGING;
 	}
+#else
+	return POWER_SUPPLY_STATUS_CHARGING;
+#endif
 }
-EXPORT_SYMBOL_GPL(sprdchg_fan54015_get_charge_status);
 
-int sprdchg_fan54015_get_charge_fault(void)
+int sprdchg_hl7059_get_charge_fault(void)
 {
-	BYTE fault_val = 0,ret = 0;
-	fault_val = fan54015_get_fault_val();
-	switch(fault_val){
-		case CHG_NO_FAULT:
-			SPRDCHG_54015_DEBUG("no fault\n");
-			ret = SPRDBAT_CHG_END_NONE_BIT;
-			break;
-		case CHG_THM_SHUTDOWN:
-			SPRDCHG_54015_DEBUG("chg hot\n");
-			ret = SPRDBAT_CHG_END_OTP_OVERHEAT_BIT;
-			break;
-		case CHG_VBAT_OVP:
-			SPRDCHG_54015_DEBUG("chg vbat ovp\n");
-			ret = SPRDBAT_CHG_END_BAT_OVP_BIT;
-			break;
-		default:
-			SPRDCHG_54015_DEBUG("chg unspec fault\n");
-			ret = SPRDBAT_CHG_END_UNSPEC;
+#if 1
+	unsigned char fault_val = 0;
+	int ret = 0;
+
+        fault_val = hl7059_get_fault_status();
+	switch (fault_val) {
+	case CHG_NO_FAULT: //0
+		SPRDCHG_DEBUG("no fault\n");
+		ret = SPRDBAT_CHG_END_NONE_BIT;
+		break;
+	case CHG_THM_SHUTDOWN: //11
+		SPRDCHG_DEBUG("chg hot\n");
+		ret = SPRDBAT_CHG_END_OTP_OVERHEAT_BIT;
+		break;
+	case CHG_VBAT_OVP: //9
+		SPRDCHG_DEBUG("chg vbat ovp\n");
+		ret = SPRDBAT_CHG_END_BAT_OVP_BIT;
+		break;
+	case NTC_FAULT: //3//3
+		SPRDCHG_DEBUG("ntc fault\n");
+		ret = SPRDBAT_CHG_END_BAT_OVP_BIT;
+		break; 
+	case BAT_FAULT: //3//4
+		SPRDCHG_DEBUG("bat_fault\n");
+		ret = SPRDBAT_CHG_END_BAT_OVP_BIT;
+		break;
+	case CHRG_FAULT: //5
+	        SPRDCHG_DEBUG("chrg_fault\n");
+		ret = SPRDBAT_CHG_END_BAT_OVP_BIT;
+		 break;
+	case OTG_FAULT: //6
+	      SPRDCHG_DEBUG("otg_fault\n");
+		ret = SPRDBAT_CHG_END_BAT_OVP_BIT;
+		break;
+	case WATCHDOG_FAULT:
+		SPRDCHG_DEBUG("catchdog_fault1\n");
+		ret = SPRDBAT_CHG_END_BAT_OVP_BIT;
+		break;
+	default:
+		SPRDCHG_DEBUG("chg unspec fault\n");
+		ret = SPRDBAT_CHG_END_UNSPEC;
 	}
 	return ret;
+#else
+	return 0;
+#endif
 }
-EXPORT_SYMBOL_GPL(sprdchg_fan54015_get_charge_fault);
 
- void sprdchg_fan54015_start_chg(int cur)
+void sprdchg_hl7059_set_cur(uint32_t cur)
 {
-	BYTE reg_val = 0,vendor_id = VENDOR_FAN54015;
-	SPRDCHG_54015_DEBUG("sprdchg_fan54015_start_chg cur =%d\n",cur);
-	vendor_id = fan54015_get_vendor_id();
-	if(vendor_id == VENDOR_FAN54015){
-		reg_val = sprdchg_fan54015_cur2reg(cur);
-	}
-	if(vendor_id == VENDOR_TQ24157){
-		reg_val = sprdchg_tq24157_cur2reg(cur);
-	}
-	SPRDCHG_54015_DEBUG("sprdchg_fan54015_start_chg,reg_val=%d\n",reg_val);
-	fan54015_set_chg_current(reg_val);
-	fan54015_enable_chg();
+	unsigned char reg_val = 0;
+
+	if (NULL == bat_drv_data)
+		return;
+	SPRDCHG_DEBUG("%s cur =%d\n", __func__, cur);
+
+	reg_val = sprdchg_hl7059_cur2reg(cur);
+
+	SPRDCHG_DEBUG("%s reg_val=%d\n", __func__, reg_val);
+	hl7059_set_chg_current(reg_val);
 }
-EXPORT_SYMBOL_GPL(sprdchg_fan54015_start_chg);
 
- int sprdchg_fan54015_get_chgcur(void)
+void sprdchg_hl7059_enable_chg(int cur)
 {
-	BYTE reg_val = 0, vendor_id = VENDOR_FAN54015;
-	int cur = 550;
-	reg_val = fan54015_get_chg_current();
-	vendor_id = fan54015_get_vendor_id();
+#if 1
+	sprdchg_hl7059_set_cur(cur);
+	hl7059_enable_chg();
+#endif
+}
 
-	if(vendor_id == VENDOR_FAN54015){
-		cur = sprdchg_fan54015_reg2cur(reg_val);
-	}
-	if(vendor_id == VENDOR_TQ24157){
-		cur = sprdchg_tq24157_reg2cur(reg_val);
-	}
-	SPRDCHG_54015_DEBUG("sprdchg_fan54015_get_chgcur cur =%d\n",cur);
+unsigned int sprdchg_hl7059_get_chgcur(void)
+{
+#if 1
+	unsigned char reg_val = 0;
+	unsigned int cur = 550;
+
+	reg_val = hl7059_get_chg_current();
+
+	cur = sprdchg_hl7059_reg2cur(reg_val);
+
+	SPRDCHG_DEBUG("%s cur =%d\n", __func__, cur);
 	return cur;
+#else
+	return 1000;
+#endif
 }
-EXPORT_SYMBOL_GPL(sprdchg_fan54015_get_chgcur);
-void sprdchg_fan54015_adjust_cur(int adjust)
+
+void sprdchg_hl7059_adjust_cur(int adjust)
 {
-	BYTE reg_val = fan54015_get_chg_current();
-	if(adjust > 0){
-		if(reg_val == 7)
+	unsigned char reg_val = hl7059_get_chg_current();
+
+	if (adjust > 0) {
+		if (reg_val == 7)
 			return;
+
 		reg_val++;
-	}else{
-		if(!reg_val)
+	} else {
+		if (!reg_val)
 			return;
+
 		reg_val--;
 	}
-	fan54015_set_chg_current(reg_val);
-	fan54015_enable_chg();
+	hl7059_set_chg_current(reg_val);
+	hl7059_enable_chg();
 }
-EXPORT_SYMBOL_GPL(sprdchg_fan54015_adjust_cur);
-int sprdchg_fan54015_get_chgcur_step(int cur, int increase)
+
+int sprdchg_hl7059_get_chgcur_step(int cur, int increase)
 {
-	BYTE reg_val = fan54015_get_chg_current(),vendor_id = VENDOR_FAN54015;
+#if 1
+	unsigned char reg_val = hl7059_get_chg_current();
 	int new_cur = 0;
-	if(increase > 0){
-		if(reg_val == 7)
+
+	if (increase > 0) {
+		if (reg_val == 7)
 			return 0;
+
 		reg_val++;
-	}else{
-		if(!reg_val)
+	} else {
+		if (!reg_val)
 			return 0;
+
 		reg_val--;
 	}
-	vendor_id = fan54015_get_vendor_id();
+    
+	new_cur = sprdchg_hl7059_reg2cur(reg_val);
 
-	if(vendor_id == VENDOR_FAN54015){
-		new_cur = sprdchg_fan54015_reg2cur(reg_val);
-	}
-	if(vendor_id == VENDOR_TQ24157){
-		new_cur = sprdchg_tq24157_reg2cur(reg_val);
-	}
-	if(increase > 0){
-		return (new_cur -cur);
-	}else{
-		return (cur-new_cur);
-	}
+	if (increase > 0)
+		return (new_cur - cur);
+
+	else
+		return (cur - new_cur);
+#endif
 }
-EXPORT_SYMBOL_GPL(sprdchg_fan54015_get_chgcur_step);
 
-void sprdchg_fan54015_init(struct sprd_battery_platform_data * pdata)
+#define EN_HIZ 0x0
+#define SYS_MIN 0x5 //Minimum system voltage 3.5V	
+
+#define WTD_TIME_40S 0x1 
+#define WTD_TIME_80S 0x2
+
+#define EN_TIME 0x0 //Disable charge timer
+#define INT_MASK_1 0x0 //Disable fault interrupt
+
+#define IINLIMSET_2P5_A 0x7
+#define IINLIMSET_2_A 0x6
+#define IINLIMSET_1P5_A 0x5
+#define IINLIMSET_1P2_A 0x4
+#define IINLIMSET_900_MA 0x3
+#define IINLIMSET_500_MA 0x2
+
+void hl7059_ic_init(void)
 {
-	sprdchg_fan54015_set_safety_vol(pdata->chg_end_vol_pure);
-	sprdchg_fan54015_set_safety_cur(pdata->adp_dcp_cur);
-	fan54015_init();
-	sprdchg_fan54015_set_vindpm(pdata->chg_end_vol_pure);
-	if(pdata->chg_full_condition == FROM_EXT_IC){
-		fan54015_enable_cur_terminal(1);
-		sprdchg_fan54015_termina_cur_set(pdata->chg_end_cur);
-	}else{
-		fan54015_enable_cur_terminal(0);
-		//sprdchg_fan54015_termina_cur_set(0);
+        hl7059_set_en_hiz(EN_HIZ);
+        //hl7059_set_reg_rst(1);
+        hl7059_set_reg_rst(0x0);
+        hl7059_reset_timer();
+        hl7059_set_iinlim(IINLIMSET_2P5_A);
+
+        hl7059_set_sys_min( SYS_MIN);
+        
+        hl7059_set_en_timer( EN_TIME);
+
+        hl7059_set_en_term(0x2); //Enable termination
+
+        hl7059_set_watchdog( WTD_TIME_40S);
+
+        hl7059_set_int_mask( INT_MASK_1);  
+
+ 		hl7059_set_vrechg(0x1);
+
+		sprdchg_hl7059_termina_vol_set(4352);		
+}
+
+void sprdchg_hl7059_init(struct sprd_battery_platform_data *bdata)
+{
+
+	if (NULL == bdata)
+		return;
+	bat_drv_data = bdata;
+
+      hl7059_ic_init();
+        
+	sprdchg_hl7059_set_safety_vol(bat_drv_data->chg_end_vol_pure);
+	sprdchg_hl7059_set_safety_cur(bat_drv_data->adp_dcp_cur);
+	sprdchg_hl7059_set_vindpm(4440);//(bat_drv_data->chg_end_vol_pure);
+	hl7059_set_iprechg(4);	//512ma
+	//hl7059_set_vreg(4350);
+
+	
+
+	if (bat_drv_data->chg_full_condition == FROM_EXT_IC) {
+		//hl7059_enable_cur_terminal(1);
+		sprdchg_hl7059_termina_cur_set(bat_drv_data->chg_end_cur);
+	} else {
+		//hl7059_enable_cur_terminal(0);
 	}
-	sprdchg_fan54015_termina_vol_set(pdata->chg_end_vol_pure);
+      show_regs_value();
+	//sprdchg_hl7059_termina_vol_set(bat_drv_data->pdata->chg_end_vol_pure);
 }
-EXPORT_SYMBOL_GPL(sprdchg_fan54015_init);
 
-
-struct sprd_ext_ic_operations sprd_extic_op ={
-	.ic_init = sprdchg_fan54015_init,
-	.charge_start_ext = sprdchg_fan54015_start_chg,
-	.charge_stop_ext = sprdchg_fan54015_stop_charging,
-	.get_charging_status = sprdchg_fan54015_get_charge_status,
-	.get_charging_fault =  sprdchg_fan54015_get_charge_fault,
-	.timer_callback_ext = sprdchg_fan54015_reset_timer,
-	.otg_charge_ext = sprdchg_fan54015_otg_enable,
-	.get_charge_cur_ext = sprdchg_fan54015_get_chgcur,
-	.set_termina_cur_ext = sprdchg_fan54015_termina_cur_set,
-	.set_termina_vol_ext = sprdchg_fan54015_termina_vol_set,
-	.get_chgcur_step = sprdchg_fan54015_get_chgcur_step,
+struct sprd_ext_ic_operations sprdchg_hl7059_op = {
+	.ic_init = sprdchg_hl7059_init,
+	.charge_start_ext = sprdchg_hl7059_enable_chg,
+	//.set_charge_cur = sprdchg_hl7059_set_cur,
+	.charge_stop_ext = sprdchg_hl7059_stop_charging,
+	.get_charging_status = sprdchg_hl7059_get_charge_status,
+	.get_charging_fault = sprdchg_hl7059_get_charge_fault,
+	.timer_callback_ext = sprdchg_hl7059_reset_timer,
+	.otg_charge_ext = sprdchg_hl7059_otg_enable,
+	.get_charge_cur_ext = sprdchg_hl7059_get_chgcur,
+	.set_termina_cur_ext = sprdchg_hl7059_termina_cur_set,
+	.set_termina_vol_ext = sprdchg_hl7059_termina_vol_set,
+	.get_chgcur_step = sprdchg_hl7059_get_chgcur_step,
 };
 
-const struct sprd_ext_ic_operations *sprd_get_ext_ic_ops(void){
-	return &sprd_extic_op;
+struct sprd_ext_ic_operations *sprd_get_hl7059_ops(void)
+{
+	return &sprdchg_hl7059_op;
 }
-
Index: kernel/drivers/power/sprd_ext_ic_power.c
===================================================================
--- kernel/drivers/power/sprd_ext_ic_power.c	(revision 166560)
+++ kernel/drivers/power/sprd_ext_ic_power.c	(revision 166561)
@@ -547,6 +547,13 @@
 	case POWER_SUPPLY_PROP_TEMP:
 		val->intval = data->bat_info.cur_temp;
 		break;
+				
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
+		val->intval = sprdfgu_read_batcurrent();
+		//pr_err("POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT val->intval:%d\n",val->intval);
+		if(val->intval < 0) val->intval = 0;
+		break;	
+
 	default:
 		ret = -EINVAL;
 		break;
@@ -563,6 +570,7 @@
 	POWER_SUPPLY_PROP_CAPACITY,
 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
 	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,
 };
 
 static enum power_supply_property sprdbat_ac_props[] = {
Index: kernel/drivers/power/fan54015.c
===================================================================
--- kernel/drivers/power/fan54015.c	(revision 166560)
+++ kernel/drivers/power/fan54015.c	(revision 166561)
@@ -10,273 +10,420 @@
 #include <linux/stat.h>
 #include <linux/irq.h>
 #include <linux/of_gpio.h>
-#include "fan54015.h"
 #include <soc/sprd/sci.h>
 #include <soc/sprd/sci_glb_regs.h>
 #include <soc/sprd/adi.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include "fan54015.h"
+#include "sprd_charge_helper.h"
 
-#define FAN_54015_DEBUG
-#ifdef FAN_54015_DEBUG
-#define SPRD_EX_DEBUG(format, arg...) printk("fan54015: " "@@@" format, ## arg)
-#else
-#define SPRD_EX_DEBUG(format, arg...)
-#endif
-#define FAN_54015_DEBUG_FS
-#ifndef CONFIG_SPRD_USB_DEVICE_ONLY
-extern int usb_get_id_state(void);
-extern int usb_get_vbus_state(void);
-#endif
-static struct fan54015 *fan54015_data = NULL;
-static int fan54015_write_reg(int reg, u8 val)
+#define SPRD_EX_DEBUG(format, arg...) pr_info("hl7059: " format, ## arg)
+#define BIT_DP_DM_SW_EN                      BIT(0)
+
+static struct hl7059 *hl7059_data;
+#define TRUE 1
+#define FALSE 0 
+
+static int hl7059_write_reg(int reg, u8 val)
 {
 	int ret;
-	SPRD_EX_DEBUG("#### writereg reg = %d val = %d\n",reg,val);
-	ret = i2c_smbus_write_byte_data(fan54015_data->client, reg, val);
 
+	SPRD_EX_DEBUG("#### writereg reg = %d val = %d,hl7059_data->client:0x%x\n", reg, val,hl7059_data->client->addr);
+	ret = i2c_smbus_write_byte_data(hl7059_data->client, reg, val);
+
 	if (ret < 0)
-	{
 		SPRD_EX_DEBUG("%s: error = %d", __func__, ret);
-	}
-    return ret;
+
+	return ret;
+
 }
 
-int fan54015_read_reg(int reg, u8 *dest)
+int hl7059_read_reg(int reg, u8 *dest)
 {
 	int ret;
 
-	ret = i2c_smbus_read_byte_data(fan54015_data->client, reg);
+	ret = i2c_smbus_read_byte_data(hl7059_data->client, reg);
 	if (ret < 0) {
 		SPRD_EX_DEBUG("%s reg(0x%x), ret(%d)\n", __func__, reg, ret);
 		return ret;
 	}
 
-	ret &= 0xff;
-	*dest = ret;
-	SPRD_EX_DEBUG("######fan54015readreg reg  = %d value =%d/%x\n",reg, ret, ret);
+	*dest = (u8)(ret & 0xff);
+	SPRD_EX_DEBUG("%s reg  = %d value =%d/%x\n", __func__, reg, ret, ret);
 	return 0;
 }
 
-static void fan54015_set_value(BYTE reg, BYTE reg_bit,BYTE reg_shift, BYTE val)
+static void hl7059_set_value(unsigned char reg,unsigned char val, unsigned char reg_bit,
+		unsigned char reg_shift)
 {
-	BYTE tmp;
-	fan54015_read_reg(reg, &tmp);
-	tmp = tmp & (~reg_bit) |(val << reg_shift);
-	if((0x04 == reg)&&(FAN5405_RESET != reg_bit)){
-		tmp &= 0x7f;
-	}
-	SPRD_EX_DEBUG("setvalue  =0x%x,val=0x%x\n",tmp,val);
-	fan54015_write_reg(reg,tmp);
+	unsigned char tmp = 0x0;
+
+	hl7059_read_reg(reg, &tmp);
+	tmp = (tmp & (~reg_bit)) | (val << reg_shift);
+
+	SPRD_EX_DEBUG("setvalue  =0x%x,val=0x%x\n", tmp, val);
+	hl7059_write_reg(reg, tmp);
 }
 
-static BYTE fan54015_get_value(BYTE reg, BYTE reg_bit, BYTE reg_shift)
+static unsigned char hl7059_get_value(unsigned char reg,
+		unsigned char reg_bit, unsigned char reg_shift)
 {
-	BYTE data = 0;
-	int ret = 0 ;
-	ret = fan54015_read_reg(reg, &data);
+	unsigned char data = 0;
+	int ret = 0;
+
+	ret = hl7059_read_reg(reg, &data);
+	if (ret < 0) {
+		SPRD_EX_DEBUG("%s reg(0x%x), ret(%d)\n", __func__, reg, ret);
+		return 0;
+	}
 	ret = (data & reg_bit) >> reg_shift;
 
 	return ret;
 }
 
-void  fan54015_reset_timer(void)
+/**********************************************************
+  *
+  *   [Internal Function] 
+  *
+  *********************************************************/
+//CON0----------------------------------------------------
+
+void hl7059_set_en_hiz(BYTE val)
 {
-	SPRD_EX_DEBUG("fan54015 reset timer\n");
-	fan54015_set_value(FAN5405_REG_CONTROL0, FAN5405_TMR_RST_OTG,FAN5405_TMR_RST_OTG_SHIFT, RESET32S);
+    hl7059_set_value(hl7059_CON0, val, CON0_EN_HIZ_MASK, CON0_EN_HIZ_SHIFT );
 }
-EXPORT_SYMBOL_GPL(fan54015_reset_timer);
-void  fan54015_sw_reset(void)
+
+void hl7059_set_vindpm(BYTE val)
 {
-	SPRD_EX_DEBUG("fan54015_sw_reset\n");
-	fan54015_set_value(FAN5405_REG_IBAT, FAN5405_RESET, FAN5405_RESET_SHIFT, 1);
+    hl7059_set_value(hl7059_CON0, val, CON0_VINDPM_MASK, CON0_VINDPM_SHIFT );
 }
-EXPORT_SYMBOL_GPL(fan54015_sw_reset);
-void fan54015_enable_cur_terminal(int enable){
-	if(enable)
-		fan54015_set_value(FAN5405_REG_CONTROL1, FAN5405_TE,FAN5405_TE_SHIFT, ENTE);
-	else
-		fan54015_set_value(FAN5405_REG_CONTROL1, FAN5405_TE,FAN5405_TE_SHIFT, DISTE);
+
+void hl7059_set_iinlim(BYTE val)
+{
+    hl7059_set_value(hl7059_CON0, val, CON0_IINLIM_MASK, CON0_IINLIM_SHIFT );
 }
-EXPORT_SYMBOL_GPL(fan54015_enable_cur_terminal);
-void fan54015_set_vindpm(BYTE reg_val)
+
+//CON1----------------------------------------------------
+
+void hl7059_set_reg_rst(BYTE val)
 {
-	fan54015_set_value(FAN5405_REG_SP_CHARGER, FAN5405_VSP,FAN5405_VSP_SHIFT, reg_val);
+    hl7059_set_value(hl7059_CON1, val, CON1_REG_RST_MASK, CON1_REG_RST_SHIFT );
 }
-EXPORT_SYMBOL_GPL(fan54015_set_vindpm);
 
-void fan54015_termina_cur_set(BYTE reg_val)
+void hl7059_set_wdt_rst(BYTE val)
 {
-	fan54015_set_value(FAN5405_REG_IBAT, FAN5405_ITERM,FAN5405_ITERM_SHIFT, reg_val);
+   hl7059_set_value(hl7059_CON1, val, CON1_WDT_RST_MASK, CON1_WDT_RST_SHIFT );
 }
-EXPORT_SYMBOL_GPL(fan54015_termina_cur_set);
 
-void fan54015_termina_vol_set(BYTE reg_val)
+void hl7059_set_otg_config(BYTE val)
 {
-	fan54015_set_value(FAN5405_REG_OREG, FAN5405_OREG,FAN5405_OREG_SHIFT, reg_val);
+
+    hl7059_set_value(hl7059_CON1, val, CON1_OTG_CONFIG_MASK, CON1_OTG_CONFIG_SHIFT );
 }
-EXPORT_SYMBOL_GPL(fan54015_termina_vol_set);
-static void fan54015_15s_work(unsigned long data)
+
+void hl7059_set_chg_config(BYTE val)
 {
-	fan54015_reset_timer();
-	schedule_delayed_work(&fan54015_data->feed_watchdog_work, HZ*15);
+    hl7059_set_value(hl7059_CON1, val, CON1_CHG_CONFIG_MASK, CON1_CHG_CONFIG_SHIFT );
 }
-static void fan54015_vbus_det_work(unsigned long data)
+
+void hl7059_set_sys_min(BYTE val)
 {
-#ifndef CONFIG_SPRD_USB_DEVICE_ONLY
-	int usb_state = usb_get_id_state();
-	int vbus_state = usb_get_vbus_state();
-	if(usb_state)
-		return;
-	if((!usb_state) && ( !vbus_state)){
-		SPRD_EX_DEBUG("restart otg\n");
-		fan54015_set_value(FAN5405_REG_OREG, FAN5405_OTG_EN,FAN5405_OTG_EN_SHIFT, 0);
-		fan54015_set_value(FAN5405_REG_OREG, FAN5405_OTG_EN,FAN5405_OTG_EN_SHIFT, 1);
-		return ;
-	}
-	schedule_delayed_work(&fan54015_data->vbus_detect_work,msecs_to_jiffies(1500));
-#endif
-	return ;
+
+    hl7059_set_value(hl7059_CON1, val, CON1_SYS_MIN_MASK, CON1_SYS_MIN_SHIFT );
 }
-void fan54015_init(void)
+
+void hl7059_set_boost_lim(BYTE val)
 {
-	BYTE data = 0;
-	int i = 0;
-	SPRD_EX_DEBUG("fan54015_init\n");
+    hl7059_set_value(hl7059_CON1, val, CON1_BOOST_LIM_MASK, CON1_BOOST_LIM_SHIFT );
+}
 
-	fan54015_sw_reset();
+//CON2----------------------------------------------------
 
-	fan54015_set_value(FAN5405_REG_CONTROL1, FAN5405_VLOWV, FAN5405_VLOWV_SHIFT,VLOWV3P4);  // VLOWV = 3.4V
-	fan54015_set_value(FAN5405_REG_SP_CHARGER, FAN5405_IO_LEVEL,FAN5405_IO_LEVEL_SHIFT, ENIOLEVEL);  //IO_LEVEL is 0. Output current is controlled by IOCHARGE bits.
-	for(i = 0;  i < 15;  i++){
-		fan54015_read_reg(i, &data);
-		SPRD_EX_DEBUG("fan54015_ReadReg1 i = %d, data = %x\n",i,data);
+void hl7059_set_ichg(int  val)
+{		
+    hl7059_set_value(hl7059_CON2, val,CON2_ICHG_MASK, CON2_ICHG_SHIFT);//0~64 
+}
+
+void hl7059_set_bcold(BYTE val)
+{
+
+    hl7059_set_value(hl7059_CON2, val, CON2_BCOLD_MASK, CON2_BCOLD_SHIFT );
+}
+void hl7059_set_force_20pct(BYTE val)
+{
+   hl7059_set_value(hl7059_CON2, val, CON2_FORCE_20PCT_MASK, CON2_FORCE_20PCT_SHIFT
+                                    );
+}
+
+//CON3----------------------------------------------------
+
+void hl7059_set_iprechg(BYTE val)
+{
+
+    hl7059_set_value(hl7059_CON3, val, CON3_IPRECHG_MASK, CON3_IPRECHG_SHIFT );
+}
+
+void hl7059_set_iterm(BYTE val)
+{
+    hl7059_set_value(hl7059_CON3, val, CON3_ITERM_MASK, CON3_ITERM_SHIFT );
+}
+
+//CON4----------------------------------------------------
+
+void hl7059_set_vreg(int val)
+{
+	BYTE regval;
+	
+	if (val > 4400)
+	{
+		val =4400;
 	}
+	
+	regval = (val -3504) / 16;
+    hl7059_set_value(hl7059_CON4, regval, CON4_VREG_MASK, CON4_VREG_SHIFT );
 }
-EXPORT_SYMBOL_GPL(fan54015_init);
 
-void fan54015_set_safety_vol(BYTE reg_val )
+void hl7059_set_batlowv(BYTE val)
 {
-	fan54015_set_value(FAN5405_REG_SAFETY, FAN5405_VSAFE,FAN5405_VSAFE_SHIFT, reg_val);
+    hl7059_set_value(hl7059_CON4,  val, CON4_BATLOWV_MASK, CON4_BATLOWV_SHIFT );
 }
 
-EXPORT_SYMBOL_GPL(fan54015_set_safety_vol);
+void hl7059_set_vrechg(BYTE val)
+{
+    hl7059_set_value(hl7059_CON4,  val,  CON4_VRECHG_MASK, CON4_VRECHG_SHIFT );
+}
 
-void fan54015_set_safety_cur(BYTE reg_val )
+//CON5----------------------------------------------------
+
+void hl7059_set_en_term(BYTE val)
 {
-	fan54015_set_value(FAN5405_REG_SAFETY, FAN5405_ISAFE, FAN5405_ISAFE_SHIFT, reg_val);
+    hl7059_set_value(hl7059_CON5, val, CON5_EN_TERM_MASK, CON5_EN_TERM_SHIFT );
 }
 
-EXPORT_SYMBOL_GPL(fan54015_set_safety_cur);
+void hl7059_set_watchdog(BYTE val)
+{
+    hl7059_set_value(hl7059_CON5, val, CON5_WATCHDOG_MASK,  CON5_WATCHDOG_SHIFT );
+}
 
-void fan54015_otg_enable(int enable)
+void hl7059_set_en_timer(BYTE val)
 {
-	SPRD_EX_DEBUG("fan54015_OTG_Enable enable =%d\n",enable);
-	if(enable)
-		sci_adi_set(ANA_REG_GLB_CHGR_DET_FGU_CTRL, BIT_DP_DM_SW_EN);
-	else
-		sci_adi_clr(ANA_REG_GLB_CHGR_DET_FGU_CTRL, BIT_DP_DM_SW_EN);
+    hl7059_set_value(hl7059_CON5, val, CON5_EN_TIMER_MASK, CON5_EN_TIMER_SHIFT );
+}
 
-	fan54015_set_value(FAN5405_REG_CONTROL1, FAN5405_OPA_MODE,FAN5405_OPA_MODE_SHIFT, enable);
+void hl7059_set_chg_timer(BYTE val)
+{
+    hl7059_set_value(hl7059_CON5, val, CON5_CHG_TIMER_MASK, CON5_CHG_TIMER_SHIFT );
+}
 
-	if(enable){
-		fan54015_set_value(FAN5405_REG_OREG, FAN5405_OTG_EN,FAN5405_OTG_EN_SHIFT, enable);
-		schedule_work(&fan54015_data->feed_watchdog_work);
-		schedule_delayed_work(&fan54015_data->vbus_detect_work,msecs_to_jiffies(500));
-	}else{
-		cancel_delayed_work_sync(&fan54015_data->feed_watchdog_work);
-		cancel_delayed_work_sync(&fan54015_data->vbus_detect_work);
-		fan54015_set_value(FAN5405_REG_OREG, FAN5405_OTG_EN,FAN5405_OTG_EN_SHIFT, enable);
-		//fan54015_init();
-	}
+//CON6----------------------------------------------------
+
+void hl7059_set_treg(BYTE val)
+{
+    hl7059_set_value(hl7059_CON6,  val, CON6_TREG_MASK, CON6_TREG_SHIFT );
 }
-EXPORT_SYMBOL_GPL(fan54015_otg_enable);
-void fan54015_stop_charging(void)
+
+void hl7059_set_boostv(BYTE val)
 {
-	 fan54015_set_value(FAN5405_REG_CONTROL1, FAN5405_CE_N,FAN5405_CE_N_SHIFT, DISCHARGER);
+    hl7059_set_value(hl7059_CON6, val, CON6_BOOSTV_MASK, CON6_BOOSTV_SHIFT);
 }
-EXPORT_SYMBOL_GPL(fan54015_stop_charging);
 
-BYTE fan54015_get_vendor_id(void)
+void hl7059_set_bhot(BYTE val)
 {
-	return fan54015_get_value(FAN5405_REG_IC_INFO, FAN5405_VENDOR_CODE, FAN5405_VENDOR_CODE_SHIFT);
+    hl7059_set_value(hl7059_CON6, val, CON6_BHOT_MASK, CON6_BHOT_SHIFT );
 }
 
-EXPORT_SYMBOL_GPL(fan54015_get_vendor_id);
+//CON7----------------------------------------------------
 
+void hl7059_set_tmr2x_en(BYTE val)
+{
+    hl7059_set_value(hl7059_CON7, val, CON7_TMR2X_EN_MASK, CON7_TMR2X_EN_SHIFT );
+}
 
-BYTE fan54015_get_chg_status(void)
+void hl7059_set_batfet_disable(BYTE val)
 {
-	return fan54015_get_value(FAN5405_REG_CONTROL0, FAN5405_STAT, FAN5405_STAT_SHIFT);
+   hl7059_set_value(hl7059_CON7, val, CON7_BATFET_Disable_MASK, CON7_BATFET_Disable_SHIFT );
 }
 
-EXPORT_SYMBOL_GPL(fan54015_get_chg_status);
+void hl7059_set_int_mask(BYTE val)
+{
+    hl7059_set_value(hl7059_CON7, val, CON7_INT_MASK_MASK, CON7_INT_MASK_SHIFT);
+}
 
-BYTE fan54015_get_fault_val(void)
+//CON8----------------------------------------------------
+
+BYTE hl7059_get_system_status(void)
 {
-	return fan54015_get_value(FAN5405_REG_CONTROL0, FAN5405_FAULT, FAN5405_FAULT_SHIFT);
+    BYTE val=0;
+
+    val=hl7059_get_value(hl7059_CON8, 0xFF, 0x0);
+    return val;
 }
 
-EXPORT_SYMBOL_GPL(fan54015_get_fault_val);
+BYTE hl7059_get_vbus_stat(void)
+{
+    BYTE val=0;
 
- void fan54015_enable_chg()
+    val=hl7059_get_value(hl7059_CON8,  CON8_VBUS_STAT_MASK, CON8_VBUS_STAT_SHIFT );
+    return val;
+}
+
+BYTE hl7059_get_chrg_stat(void)
 {
-	fan54015_set_value(FAN5405_REG_CONTROL1, FAN5405_CE_N,FAN5405_CE_N_SHIFT, DISCHARGER);
-	fan54015_set_value(FAN5405_REG_CONTROL1, FAN5405_CE_N,FAN5405_CE_N_SHIFT, ENCHARGER);
+    BYTE val=0;
+
+    val=hl7059_get_value(hl7059_CON8, CON8_CHRG_STAT_MASK, CON8_CHRG_STAT_SHIFT );
+    return val;
 }
-EXPORT_SYMBOL_GPL(fan54015_enable_chg);
- void fan54015_set_chg_current(BYTE reg_val)
+
+BYTE hl7059_get_vsys_stat(void)
 {
-	if(reg_val == 0){
-		fan54015_set_value(FAN5405_REG_CONTROL1, FAN5405_IINLIM, FAN5405_IINLIM_SHIFT,IINLIM500);  // INLIM = 500mA
+    BYTE val=0;
+
+    val=hl7059_get_value(hl7059_CON8, CON8_VSYS_STAT_MASK, CON8_VSYS_STAT_SHIFT );
+    return val;
+}
+
+BYTE hl7059_get_fault_status(void)
+{
+    BYTE val=0;
+
+    val=hl7059_get_value(hl7059_CON9, 0xFF, 0x0 );
+
+    if (!val)
+        return 0; //nomal
+   else if (val&0x80)
+        return 7;     //watchdog fault 
+   else if (val&0x40)
+        return 6;     //otg fault 
+   else if  (val&0x30)
+        return 5;    //chg fault 
+   else if (val&0x08)
+        return 4;    //bat fault
+   else
+        return 3;   //NTC fault
+}
+/////////////////////////////////////////////////////////////////////////////////////////
+
+void hl7059_reset_timer(void)
+{
+	hl7059_set_wdt_rst(1);
+}
+
+void show_regs_value(void)
+{
+    int i = 0;
+    BYTE data = 0;
+	for(i = 0;  i < 11;  i++){
+		hl7059_read_reg(i, &data);
+		pr_err("######i:%d,data:0x%x\n", i, data);
+	}
+}
+#ifndef BQ_TEST
+
+static void hl7059_15s_work(struct work_struct *work)
+{
+	hl7059_reset_timer();
+	schedule_delayed_work(&hl7059_data->feed_watchdog_work, HZ * 15);
+}
+
+static void hl7059_vbus_det_work(struct work_struct *work)
+{
+#if defined(CONFIG_USB_SPRD_DWC) && !defined(CONFIG_SPRD_USB_DEVICE_ONLY)
+	int usb_state = usb_get_id_state();
+	int vbus_state = usb_get_vbus_state();
+
+	if (usb_state)
+		return;
+	if ((!usb_state) && (!vbus_state)) {
+		SPRD_EX_DEBUG("restart otg\n");
+		hl7059_set_otg_config(1);
+		return;
+	}
+	schedule_delayed_work(&hl7059_data->vbus_detect_work,
+			      msecs_to_jiffies(1500));
+#endif
+}
+#endif
+
+void hl7059_otg_enable(int enable)
+{
+	SPRD_EX_DEBUG("%s enable =%d\n", __func__, enable);
+	gpio_direction_output(135,1);
+	gpio_set_value(135, 1);
+	if(enable)
+	{
+		hl7059_set_otg_config(1);
+	}
+	else
+	{
+		hl7059_set_otg_config(0);
+	}
+	if(enable){
+		schedule_work(&hl7059_data->feed_watchdog_work);
+		schedule_delayed_work(&hl7059_data->vbus_detect_work,msecs_to_jiffies(500));
 	}else{
-		fan54015_set_value(FAN5405_REG_CONTROL1, FAN5405_IINLIM, FAN5405_IINLIM_SHIFT,NOLIMIT);  // no limit
+		cancel_delayed_work_sync(&hl7059_data->feed_watchdog_work);
+		cancel_delayed_work_sync(&hl7059_data->vbus_detect_work);
 	}
-	fan54015_set_value(FAN5405_REG_IBAT, FAN5405_IOCHARGE,FAN5405_IOCHARGE_SHIFT, reg_val);
+
 }
-EXPORT_SYMBOL_GPL(fan54015_set_chg_current);
-BYTE fan54015_get_chg_current(void)
+
+void hl7059_enable_chg(void)
 {
-	return fan54015_get_value(FAN5405_REG_IBAT, FAN5405_IOCHARGE, FAN5405_IOCHARGE_SHIFT);
+	gpio_direction_output(142,0);
+	gpio_set_value(142, 0);
+	hl7059_set_chg_config(1); 
 }
-EXPORT_SYMBOL_GPL(fan54015_get_chg_current);
 
-#ifdef  FAN_54015_DEBUG_FS
+void hl7059_set_chg_current(unsigned char reg_val)
+{
+	hl7059_set_ichg(reg_val); 
+}
 
+unsigned char hl7059_get_chg_current(void)
+{
+    return hl7059_get_value(hl7059_CON2, CON2_ICHG_MASK, CON2_ICHG_SHIFT);
+}
+
 static ssize_t set_regs_store(struct device *dev,
-		struct device_attribute *attr,
-		const char *buf, size_t count)
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
 {
 	unsigned long set_value;
-	int reg;  // bit 16:8
-	int val;  //bit7:0
-	int ret;
-	set_value = simple_strtoul(buf, NULL, 16);
+	int reg, val, ret;
 
+	if (kstrtoul(buf, 16, &set_value))
+		return -EINVAL;
+
 	reg = (set_value & 0xff00) >> 8;
 	val = set_value & 0xff;
-	printk("fan54015 set reg = %d value = %d\n",reg, val);
-	ret = fan54015_write_reg(reg, val);
+	SPRD_EX_DEBUG("set reg = %d value = %d\n", reg, val);
+	ret = hl7059_write_reg(reg, val);
 
-	if (ret < 0){
-		printk("set_regs_store error\n");
+	if (ret < 0) {
+		pr_err("set_regs_store error\n");
 		return -EINVAL;
-		}
+	}
 
 	return count;
 }
 
 
-static ssize_t dump_regs_show(struct device *dev, struct device_attribute *attr,
-                char *buf)
+static ssize_t dump_regs_show(struct device *dev,
+			      struct device_attribute *attr, char *buf)
 {
-	const int regaddrs[] = {0x00, 0x01, 0x02, 0x03, 0x4, 0x05, 0x06, 0x07,0x08,0x09,0x10 };
-	const char str[] = "0123456789abcdef";
-	BYTE fan54015_regs[0x60];
-
+	int regaddrs[] = { 0x00, 0x01, 0x02, 0x03, 0x4, 0x05,
+		0x06, 0x07, 0x08, 0x09, 0x10
+	};
+	char str[] = "0123456789abcdef";
+	unsigned char hl7059_regs[0x60];
 	int i = 0, index;
 	char val = 0;
-	for (i=0; i<0x60; i++) {
-		if ((i%3)==2)
-			buf[i]=' ';
+
+	for (i = 0; i < 0x60; i++) {
+		if ((i % 3) == 2)
+			buf[i] = ' ';
 		else
 			buf[i] = 'x';
 	}
@@ -284,148 +431,127 @@
 	buf[0x5e] = 0;
 	buf[0x5f] = 0;
 
-	for ( i = 0; i < 11; i++) {
-		 fan54015_read_reg(i,&fan54015_regs[i]);
-	}
+	for (i = 0; i < 11; i++)
+		hl7059_read_reg(i, &hl7059_regs[i]);
 
-	for (i=0; i<ARRAY_SIZE(regaddrs); i++) {
+	for (i = 0; i < ARRAY_SIZE(regaddrs); i++) {
 		index = regaddrs[i];
-		val = fan54015_regs[index];
-		buf[3*index] = str[(val&0xf0)>>4];
-		buf[3*index+1] = str[val&0x0f];
-		buf[3*index+1] = str[val&0x0f];
+		val = hl7059_regs[index];
+		buf[3 * index] = str[(val & 0xf0) >> 4];
+		buf[3 * index + 1] = str[val & 0x0f];
+		buf[3 * index + 1] = str[val & 0x0f];
 	}
 
 	return 0x60;
 }
 
+static DEVICE_ATTR_RO(dump_regs);
+static DEVICE_ATTR_WO(set_regs);
 
-static DEVICE_ATTR(dump_regs, S_IRUGO, dump_regs_show, NULL);
-static DEVICE_ATTR(set_regs, S_IWUSR, NULL, set_regs_store);
-#endif
-static int fan54015_probe(
-	struct i2c_client *client, const struct i2c_device_id *id)
+static struct attribute *hl7059_class_attrs[] = {
+	&dev_attr_dump_regs.attr,
+	&dev_attr_set_regs.attr,
+	NULL,
+};
+
+ATTRIBUTE_GROUPS(hl7059_class);
+
+extern void sprdbat_register_ext_ops(const struct sprd_ext_ic_operations * ops);
+static int hl7059_probe(struct i2c_client *client,
+			  const struct i2c_device_id *id)
 {
+	int ret = 0;
+  
+	struct sprd_ext_ic_operations *hl7059_ops = NULL;
 
-	int rc = 0;
-	int err = -1;
-	int value;
-	struct fan54015_platform_data *pdata = client->dev.platform_data;
-	SPRD_EX_DEBUG("@@@@@@@fan54015_probe\n");
-#ifdef CONFIG_OF
-		struct device_node *np = client->dev.of_node;
-		if (np && !pdata){
-			pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
-			if(!pdata){
-				err = -ENOMEM;
-				goto exit_alloc_platform_data_failed;
-			}
-		}
-#else
-	if (pdata == NULL) {
-		pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
-		if (pdata == NULL) {
-			rc = -ENOMEM;
-			pr_err("%s: platform data is NULL\n", __func__);
-			goto err_alloc_data_failed;
-		}
+	SPRD_EX_DEBUG("hl7059 probe enter\n");
+	hl7059_ops = sprd_get_hl7059_ops();
+	if (!hl7059_ops)
+		return -EINVAL;
+
+	hl7059_data = devm_kzalloc(&client->dev,
+				     sizeof(struct hl7059), GFP_KERNEL);
+	if (!hl7059_data) {
+		SPRD_EX_DEBUG("kzalloc failed!\n");
+		return -ENOMEM;
 	}
+    
+	sprdbat_register_ext_ops(hl7059_ops);
+	hl7059_data->client = client;
+#ifndef BQ_TEST
+	INIT_DELAYED_WORK(&hl7059_data->feed_watchdog_work,
+			  hl7059_15s_work);
+	INIT_DELAYED_WORK(&hl7059_data->vbus_detect_work,
+			  hl7059_vbus_det_work);
 #endif
-	fan54015_data = kzalloc(sizeof(struct fan54015), GFP_KERNEL);
-	if (!fan54015_data) {
-		SPRD_EX_DEBUG("kzalloc failed!\n");
-		rc = -ENOMEM;
-		goto err_alloc_data_failed;
-	}
-	pdata->fan54015_ops = sprd_get_ext_ic_ops();
-	sprdbat_register_ext_ops(pdata->fan54015_ops);
-	i2c_set_clientdata(client, pdata);
-	fan54015_data->client = client;
-	INIT_DELAYED_WORK(&fan54015_data->feed_watchdog_work, fan54015_15s_work);
-	INIT_DELAYED_WORK(&fan54015_data->vbus_detect_work, fan54015_vbus_det_work);
-
-	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+	if (!i2c_check_functionality(client->adapter,
+		I2C_FUNC_SMBUS_BYTE_DATA)) {
 		pr_err("%s: i2c check functionality error\n", __func__);
-		rc = -ENODEV;
-		goto check_funcionality_failed;
+		return -ENODEV;
 	}
-#ifdef FAN_54015_DEBUG_FS
-	device_create_file(&client->dev, &dev_attr_dump_regs);
-	device_create_file(&client->dev, &dev_attr_set_regs);
-#endif
-	SPRD_EX_DEBUG("@@@@@@@fan54015_probe ok\n");
-	return rc;
 
-check_funcionality_failed:
-	kfree(fan54015_data);
-	fan54015_data = NULL;
-err_alloc_data_failed:
-#ifdef CONFIG_OF
-	kfree(pdata);
-exit_alloc_platform_data_failed:
-	SPRD_EX_DEBUG("@@@@@@@fan54015_probe fail\n");
-	return err;
-#endif
+	ret = sysfs_create_group(&client->dev.kobj,
+		hl7059_class_groups[0]);
+	if (ret)
+		pr_err("failed to create 54015 sysfs device attributes\n");
+
+	SPRD_EX_DEBUG("hl7059 probe ok\n");
+	return ret;
 }
-static int fan54015_remove(struct i2c_client *client)
+
+static int hl7059_remove(struct i2c_client *client)
 {
-	struct fan54015_platform_data *pdata = i2c_get_clientdata(client);
-	SPRD_EX_DEBUG("@@@@@@@fan54015_remove \n");
-	kfree(pdata);
 	flush_scheduled_work();
-	kfree(fan54015_data);
-	fan54015_data = NULL;
+	sysfs_remove_group(&client->dev.kobj, hl7059_class_groups[0]);
 	return 0;
 }
 
-static int  fan54015_suspend(struct i2c_client *client, pm_message_t message)
+#ifdef CONFIG_PM
+static int hl7059_suspend(struct device *dev)
 {
 	return 0;
 }
 
-static int fan54015_resume(struct i2c_client *client)
+static int hl7059_resume(struct device *dev)
 {
 	return 0;
 }
+#endif
 
-static const struct i2c_device_id fan54015_i2c_id[] = {
-	{ "fan54015_chg", 0 },
-	{ }
+static UNIVERSAL_DEV_PM_OPS(hl7059_pm, hl7059_suspend, hl7059_resume, NULL);
+
+static const struct i2c_device_id hl7059_i2c_id[] = {
+	{"bq24259_chg", 0},
+	{}
 };
 
-#ifdef CONFIG_OF
-static const struct of_device_id fan54015_of_match[] = {
-	{.compatible = "fairchild, fan54015_chg",},
+static const struct of_device_id hl7059_of_match[] = {
+	{.compatible = "fairchild, bq24259_chg",},
 	{}
 };
-#endif
 
-static struct i2c_driver fan54015_i2c_driver = {
+static struct i2c_driver hl7059_i2c_driver = {
 	.driver = {
-		.name = "fan54015_chg",
-		.owner = THIS_MODULE,
-#ifdef CONFIG_OF
-		.of_match_table = of_match_ptr(fan54015_of_match),
-#endif
-	},
-	.probe    = fan54015_probe,
-	.remove   = fan54015_remove,
-	.suspend  = fan54015_suspend,
-	.resume = fan54015_resume,
-	.id_table = fan54015_i2c_id,
+		   .name = "bq24259_chg",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(hl7059_of_match),
+		   .pm	= &hl7059_pm,
+		   },
+	.probe = hl7059_probe,
+	.remove = hl7059_remove,
+	.id_table = hl7059_i2c_id,
 };
 
-static __init int fan54015_i2c_init(void)
+static int __init hl7059_i2c_init(void)
 {
-	SPRD_EX_DEBUG("@@@@@@@fan54015_i2c_init \n");
-	return i2c_add_driver(&fan54015_i2c_driver);
+	SPRD_EX_DEBUG("hl7059_i2c_init\n");
+	return i2c_add_driver(&hl7059_i2c_driver);
 }
 
-static __exit fan54015_i2c_exit(void)
+static void __exit hl7059_i2c_exit(void)
 {
-	i2c_del_driver(&fan54015_i2c_driver);
+	i2c_del_driver(&hl7059_i2c_driver);
 }
 
-subsys_initcall_sync(fan54015_i2c_init);
-module_exit(fan54015_i2c_exit);
-
+subsys_initcall_sync(hl7059_i2c_init);
+module_exit(hl7059_i2c_exit);
Index: kernel/drivers/power/fan54015.h
===================================================================
--- kernel/drivers/power/fan54015.h	(revision 166560)
+++ kernel/drivers/power/fan54015.h	(revision 166561)
@@ -1,279 +1,303 @@
-#ifndef __LINUX_SPRD2701_H
-#define __LINUX_SPRD2701_H
+#ifndef __LINUX_HL7059_H
+#define __LINUX_HL7059_H
 
-#include <linux/ioctl.h>
-#include "sprd_battery.h"
-
 typedef unsigned char BYTE;
 
-#define VENDOR_FAN54015					(0x4)
-#define VENDOR_TQ24157					(0x2)
-/******************************************************************************
-* Register addresses
-******************************************************************************/
-#define FAN5405_REG_CONTROL0			(0x0)
-#define FAN5405_REG_CONTROL1			(0x1)
-#define FAN5405_REG_OREG				(0x2)
-#define FAN5405_REG_IC_INFO				(0x3)
-#define FAN5405_REG_IBAT					(0x4)
-#define FAN5405_REG_SP_CHARGER			(0x5)
-#define FAN5405_REG_SAFETY				(0x6)
-#define FAN5405_REG_MONITOR				(0x10)
+#define hl7059_CON0      0x00
+#define hl7059_CON1      0x01
+#define hl7059_CON2      0x02
+#define hl7059_CON3      0x03
+#define hl7059_CON4      0x04
+#define hl7059_CON5      0x05
+#define hl7059_CON6      0x06
+#define hl7059_CON7      0x07
+#define hl7059_CON8      0x08
+#define hl7059_CON9      0x09
+#define hl7059_CON10      0x0A
+#define hl7059_CON11      0x0B
+/**********************************************************
+  *
+  *   [MASK/SHIFT] 
+  *
+  *********************************************************/
+//CON0
+#define CON0_EN_HIZ_MASK   0x01 << 7
+#define CON0_EN_HIZ_SHIFT  7
 
-/******************************************************************************
-* Register bits
-******************************************************************************/
-/* FAN5405_REG_CONTROL0 (0x00) */
-#define FAN5405_FAULT				(0x07)
-#define FAN5405_FAULT_SHIFT			(0)
-#define FAN5405_BOOST				(0x01 << 3)
-#define FAN5405_BOOST_SHIFT			(3)
-#define FAN5405_STAT					(0x3 <<  4)
-#define FAN5405_STAT_SHIFT			(4)
-#define FAN5405_EN_STAT				(0x01 << 6)
-#define FAN5405_EN_STAT_SHIFT		(6)
-#define FAN5405_TMR_RST_OTG			(0x01 << 7)  // writing a 1 resets the t32s timer, writing a 0 has no effect
-#define FAN5405_TMR_RST_OTG_SHIFT	(7)
+#define CON0_VINDPM_MASK       0x0F << 3
+#define CON0_VINDPM_SHIFT      3
 
-/* FAN5405_REG_CONTROL1 (0x01) */
-#define FAN5405_OPA_MODE			(0x01)
-#define FAN5405_OPA_MODE_SHIFT		(0)
-#define FAN5405_HZ_MODE				(0x01 << 1)
-#define FAN5405_HZ_MODE_SHIFT		(1)
-#define FAN5405_CE_N					(0x01 << 2)
-#define FAN5405_CE_N_SHIFT			(2)
-#define FAN5405_TE					(0x01 << 3)
-#define FAN5405_TE_SHIFT				(3)
-#define FAN5405_VLOWV				(0x03 << 4)
-#define FAN5405_VLOWV_SHIFT			(4)
-#define FAN5405_IINLIM				(0x03 << 6)
-#define FAN5405_IINLIM_SHIFT			(6)
+#define CON0_IINLIM_MASK   0x07
+#define CON0_IINLIM_SHIFT  0
 
-/* FAN5405_REG_OREG (0x02) */
-#define FAN5405_OTG_EN				(0x01)
-#define FAN5405_OTG_EN_SHIFT			(0)
-#define FAN5405_OTG_PL				(0x01 << 1)
-#define FAN5405_OTG_PL_SHIFT			(1)
-#define FAN5405_OREG					(0x3f << 2)
-#define FAN5405_OREG_SHIFT			(2)
+//CON1
+#define CON1_REG_RST_MASK     0x01 << 7
+#define CON1_REG_RST_SHIFT    7
 
-/* FAN5405_REG_IC_INFO (0x03) */
-#define FAN5405_REV					(0x03)
-#define FAN5405_REV_SHIFT			(0)
-#define FAN5405_PN					(0x07 << 2)
-#define FAN5405_PN_SHIFT				(2)
-#define FAN5405_VENDOR_CODE		(0x07 << 5)
-#define FAN5405_VENDOR_CODE_SHIFT	(5)
+#define CON1_WDT_RST_MASK     0x01 << 6
+#define CON1_WDT_RST_SHIFT    6
+#define CON1_OTG_CONFIG_MASK        0x01 << 5
+#define CON1_OTG_CONFIG_SHIFT       5
 
-/* FAN5405_REG_IBAT (0x04) */
-#define FAN5405_ITERM				(0x07)
-#define FAN5405_ITERM_SHIFT			(0)
-#define FAN5405_IOCHARGE				(0x07 << 4)
-#define FAN5405_IOCHARGE_SHIFT		(4)
-#define FAN5405_RESET				(0x01 << 7)
-#define FAN5405_RESET_SHIFT			(7)
+#define CON1_CHG_CONFIG_MASK        0x01 << 4
+#define CON1_CHG_CONFIG_SHIFT       4
 
-/* FAN5405_REG_SP_CHARGER (0x05) */
-#define FAN5405_VSP                     (0x07)
-#define FAN5405_VSP_SHIFT                    0
-#define FAN5405_EN_LEVEL           (0x01 << 3)
-#define FAN5405_EN_LEVEL_SHIFT               3
-#define FAN5405_SP                 (0x01 << 4)
-#define FAN5405_SP_SHIFT                     4
-#define FAN5405_IO_LEVEL           (0x01 << 5)
-#define FAN5405_IO_LEVEL_SHIFT               5
-#define FAN5405_DIS_VREG           (0x01 << 6)
-#define FAN5405_DIS_VREG_SHIFT               6
+#define CON1_SYS_MIN_MASK        0x07 << 1
+#define CON1_SYS_MIN_SHIFT       1
 
-/* FAN5405_REG_SAFETY (0x06) */
-#define FAN5405_VSAFE                   (0x0f)
-#define FAN5405_VSAFE_SHIFT                  0
-#define FAN5405_ISAFE              (0x07 << 4)
-#define FAN5405_ISAFE_SHIFT                  4
+#define CON1_BOOST_LIM_MASK   0x01
+#define CON1_BOOST_LIM_SHIFT  0
 
-/* FAN5405_REG_MONITOR (0x10) */
-#define FAN5405_CV                      (0x01)
-#define FAN5405_CV_SHIFT                     0
-#define FAN5405_VBUS_VALID         (0x01 << 1)
-#define FAN5405_VBUS_VALID_SHIFT             1
-#define FAN5405_IBUS               (0x01 << 2)
-#define FAN5405_IBUS_SHIFT                   2
-#define FAN5405_ICHG               (0x01 << 3)
-#define FAN5405_ICHG_SHIFT                   3
-#define FAN5405_T_120              (0x01 << 4)
-#define FAN5405_T_120_SHIFT                  4
-#define FAN5405_LINCHG             (0x01 << 5)
-#define FAN5405_LINCHG_SHIFT                 5
-#define FAN5405_VBAT_CMP           (0x01 << 6)
-#define FAN5405_VBAT_CMP_SHIFT               6
-#define FAN5405_ITERM_CMP          (0x01 << 7)
-#define FAN5405_ITERM_CMP_SHIFT              7
+//CON2
+#define CON2_ICHG_MASK    0x3F << 2
+#define CON2_ICHG_SHIFT   2
 
-/******************************************************************************
-* bit definitions
-******************************************************************************/
-/********** FAN5405_REG_CONTROL0 (0x00) **********/
-// EN_STAT [6]
-#define ENSTAT 1
-#define DISSTAT 0
-// TMR_RST [7]
-#define RESET32S 1
+#define CON2_BCOLD_MASK    0x1 << 1
+#define CON2_BCOLD_SHIFT   1
+#define CON2_FORCE_20PCT_MASK    0x1
+#define CON2_FORCE_20PCT_SHIFT   0
 
-/********** FAN5405_REG_CONTROL1 (0x01) **********/
-// OPA_MODE [0]
-#define CHARGEMODE 0
-#define BOOSTMODE 1
-//HZ_MODE [1]
-#define NOTHIGHIMP 0
-#define HIGHIMP 1
-// CE/ [2]
-#define ENCHARGER 0
-#define DISCHARGER 1
-// TE [3]
-#define DISTE 0
-#define ENTE 1
-// VLOWV [5:4]
-#define VLOWV3P4 0
-#define VLOWV3P5 1
-#define VLOWV3P6 2
-#define VLOWV3P7 3
-// IINLIM [7:6]
-#define IINLIM100 0
-#define IINLIM500 1
-#define IINLIM800 2
-#define NOLIMIT 3
+//CON3
+#define CON3_IPRECHG_MASK   0x0F << 4
+#define CON3_IPRECHG_SHIFT  4
 
-/********** FAN5405_REG_OREG (0x02) **********/
-// OTG_EN [0]
-#define DISOTG 0
-#define ENOTG 1
-// OTG_PL [1]
-#define OTGACTIVELOW 0
-#define OTGACTIVEHIGH 1
-// OREG [7:2]
-#define VOREG4P2 35  // refer to table 3
+#define CON3_ITERM_MASK           0x0F
+#define CON3_ITERM_SHIFT          0
+//CON4
+#define CON4_VREG_MASK     0x3F << 2
+#define CON4_VREG_SHIFT    2
 
-/********** FAN5405_REG_IC_INFO (0x03) **********/
+#define CON4_BATLOWV_MASK     0x01 << 1
+#define CON4_BATLOWV_SHIFT    1
 
-/********** FAN5405_REG_IBAT (0x04) **********/
-// ITERM [2:0] - 68mOhm
-#define ITERM49 0
-#define ITERM97 1
-#define ITERM146 2
-#define ITERM194 3
-#define ITERM243 4
-#define ITERM291 5
-#define ITERM340 6
-#define ITERM388 7
-// IOCHARGE [6:4] - 68mOhm
-#define IOCHARGE550 0
-#define IOCHARGE650 1
-#define IOCHARGE750 2
-#define IOCHARGE850 3
-#define IOCHARGE1050 4
-#define IOCHARGE1150 5
-#define IOCHARGE1350 6
-#define IOCHARGE1450 7
+#define CON4_VRECHG_MASK    0x01
+#define CON4_VRECHG_SHIFT   0
+//CON5
+#define CON5_EN_TERM_MASK      0x01 << 7
+#define CON5_EN_TERM_SHIFT     7
 
-/********** FAN5405_REG_SP_CHARGER (0x05) **********/
-// VSP [2:0]
-#define VSP4P213 0
-#define VSP4P293 1
-#define VSP4P373 2
-#define VSP4P453 3
-#define VSP4P533 4
-#define VSP4P613 5
-#define VSP4P693 6
-#define VSP4P773 7
-// IO_LEVEL [5]
-#define ENIOLEVEL 0
-#define DISIOLEVEL 1
-// DIS_VREG [6]
-#define VREGON 0
-#define VREGOFF 1
+#define CON5_WATCHDOG_MASK     0x03 << 4
+#define CON5_WATCHDOG_SHIFT    4
 
-/********** FAN5405_REG_SAFETY (0x06) **********/
-// VSAFE [3:0]
-#define VSAFE4P20 0
-#define VSAFE4P22 1
-#define VSAFE4P24 2
-#define VSAFE4P26 3
-#define VSAFE4P28 4
-#define VSAFE4P30 5
-#define VSAFE4P32 6
-#define VSAFE4P34 7
-#define VSAFE4P36 8
-#define VSAFE4P38 9
-#define VSAFE4P40 10
-#define VSAFE4P42 11
-#define VSAFE4P44 12
-// ISAFE [6:4] - 68mOhm
-#define ISAFE550 0
-#define ISAFE650 1
-#define ISAFE750 2
-#define ISAFE850 3
-#define ISAFE1050 4
-#define ISAFE1150 5
-#define ISAFE1350 6
-#define ISAFE1450 7
+#define CON5_EN_TIMER_MASK      0x01 << 3
+#define CON5_EN_TIMER_SHIFT     3
+#define CON5_CHG_TIMER_MASK           0x03 << 1
+#define CON5_CHG_TIMER_SHIFT          1
 
-typedef enum{
-	FAN5405_MONITOR_NONE,
-	FAN5405_MONITOR_CV,
-	FAN5405_MONITOR_VBUS_VALID,
-	FAN5405_MONITOR_IBUS,
-	FAN5405_MONITOR_ICHG,
-	FAN5405_MONITOR_T_120,
-	FAN5405_MONITOR_LINCHG,
-	FAN5405_MONITOR_VBAT_CMP,
-	FAN5405_MONITOR_ITERM_CMP
-}fan5405_monitor_status;
+//CON6
+#define CON6_BOOSTV_MASK         0xF << 4
+#define CON6_BOOSTV_SHIFT        4
+#define CON6_BHOT_MASK           0x3 << 2
+#define CON6_BHOT_SHIFT          2
+#define CON6_TREG_MASK     0x03
+#define CON6_TREG_SHIFT    0
+//CON7
 
-enum charge_fault{
+#define CON7_DPDM_EN_MASK      0x01 << 7
+#define CON7_DPDM_EN_SHIFT     7
+
+#define CON7_TMR2X_EN_MASK      0x01 << 6
+#define CON7_TMR2X_EN_SHIFT     6
+
+#define CON7_BATFET_Disable_MASK      0x01 << 5
+#define CON7_BATFET_Disable_SHIFT     5
+#define CON7_INT_MASK_MASK     0x03
+#define CON7_INT_MASK_SHIFT    0
+
+//CON8
+#define CON8_VBUS_STAT_MASK      0x03 << 6
+#define CON8_VBUS_STAT_SHIFT     6 
+
+#define CON8_CHRG_STAT_MASK           0x03 << 4
+#define CON8_CHRG_STAT_SHIFT          4
+
+#define CON8_DPM_STAT_MASK           0x01 << 3
+#define CON8_DPM_STAT_SHIFT          3
+
+#define CON8_PG_STAT_MASK           0x01 << 2
+#define CON8_PG_STAT_SHIFT          2
+
+#define CON8_THERM_STAT_MASK           0x01 << 1
+#define CON8_THERM_STAT_SHIFT          1
+#define CON8_VSYS_STAT_MASK           0x01 
+#define CON8_VSYS_STAT_SHIFT          0
+//CON9
+#define CON9_WATCHDOG_FAULT_MASK      0x01 << 7
+#define CON9_WATCHDOG_FAULT_SHIFT     7
+#define CON9_OTG_FAULT_MASK           0x01
+#define CON9_OTG_FAULT_SHIFT          6
+#define CON9_CHRG_FAULT_MASK           0x03 << 4
+#define CON9_CHRG_FAULT_SHIFT          4
+#define CON9_BAT_FAULT_MASK           0x01 << 3
+#define CON9_BAT_FAULT_SHIFT          3
+
+#define CON9_NTC_FAULT_MASK           0x07
+#define CON9_NTC_FAULT_SHIFT          0
+//CON10
+#define CON10_PN_MASK      0x07 << 3
+#define CON10_PN_SHIFT     3
+
+#define CON10_Rev_MASK           0x07
+#define CON10_Rev_SHIFT          0
+
+//CON11
+#define CON11_TSR_MASK      0x03 << 6
+#define CON11_TSR_SHIFT     6
+
+#define CON11_TRSP_MASK           0x01 << 5
+#define CON11_TRSP_SHIFT          5
+
+#define CON11_DIS_RECONNECT_MASK           0x01 << 4
+#define CON11_DIS_RECONNECT_SHIFT          4
+
+#define CON11_DIS_SR_INCHG_MASK           0x01 << 3
+#define CON11_DIS_SR_INCHG_SHIFT          3
+
+#define CON11_TSHIP_MASK           0x07 
+#define CON11_TSHIP_SHIFT          0
+
+enum charge_fault {
 	CHG_NO_FAULT = 0,
 	CHG_VBUS_OVP,
 	CHG_SLEEP_MODE,
+	NTC_FAULT,
+	BAT_FAULT,
+	CHRG_FAULT,
+	OTG_FAULT,
+	WATCHDOG_FAULT,
 	CHG_POOR_INPUT,
 	CHG_VBAT_OVP,
 	CHG_THM_SHUTDOWN,
 	CHG_TIMER_FAULT,
-	CHG_NO_BAT,
+	CHG_NO_BAT	
 };
-enum charge_status{
-	CHG_READY= 0,
+
+enum charge_status {
+	CHG_READY = 0,
 	CHG_CHGING,
 	CHG_DONE,
 	CHG_FAULT,
 };
 
-struct fan54015{
+struct hl7059 {
 	struct i2c_client *client;
 	struct delayed_work feed_watchdog_work;
 	struct delayed_work vbus_detect_work;
 };
-struct fan54015_platform_data {
-	uint16_t version;
-	const struct sprd_ext_ic_operations * fan54015_ops;
-	//int irq_gpio_number;
-};
 
-extern void fan54015_reset_timer(void);
-extern void fan54015_sw_reset(void);
-extern void fan54015_enable_cur_terminal(int enable);
-extern void fan54015_set_vindpm(BYTE reg_val);
-extern void fan54015_termina_cur_set(BYTE reg_val);
-extern void fan54015_termina_vol_set(BYTE reg_val);
-extern void fan54015_set_safety_vol(BYTE reg_val);
-extern void fan54015_set_safety_cur(BYTE reg_val);
-extern void fan54015_init(void);
-extern void fan54015_otg_enable(int enable);
-extern void fan54015_stop_charging(void);
-extern BYTE fan54015_get_vendor_id(void);
-extern BYTE fan54015_get_chg_status(void);
-extern BYTE fan54015_get_fault_val(void);
-extern void fan54015_enable_chg(void);
-extern void fan54015_set_chg_current(BYTE reg_val);
-extern BYTE fan54015_get_chg_current(void);
-extern int fan54015_register_notifier(struct notifier_block *nb);
-extern int fan54015_unregister_notifier(struct notifier_block *nb);
+
+/**********************************************************
+  *
+  *   [Extern Function] 
+  *
+  *********************************************************/
+//CON0----------------------------------------------------
+extern void hl7059_set_en_hiz(BYTE val);
+
+extern void hl7059_set_vindpm(BYTE val);
+
+extern void hl7059_set_iinlim(BYTE val);
+
+//CON1----------------------------------------------------
+
+extern void hl7059_set_reg_rst(BYTE val);
+
+extern void hl7059_set_wdt_rst(BYTE val);
+
+extern void hl7059_set_otg_config(BYTE val);
+
+extern void hl7059_set_chg_config(BYTE val);
+
+extern void hl7059_set_sys_min(BYTE val);
+
+extern void hl7059_set_boost_lim(BYTE val);
+
+//CON2----------------------------------------------------
+
+extern void hl7059_set_ichg(int  val);
+
+extern void hl7059_set_bcold(BYTE val);
+
+extern void hl7059_set_force_20pct(BYTE val);
+
+
+//CON3----------------------------------------------------
+
+extern void hl7059_set_iprechg(BYTE val);
+
+extern void hl7059_set_iterm(BYTE val);
+
+extern void hl7059_set_vreg(int val);
+
+extern void hl7059_set_batlowv(BYTE val);
+
+extern void hl7059_set_vrechg(BYTE val);
+
+
+//CON5----------------------------------------------------
+
+extern void hl7059_set_en_term(BYTE val);
+
+extern void hl7059_set_watchdog(BYTE val);
+
+extern void hl7059_set_en_timer(BYTE val);
+
+extern void hl7059_set_chg_timer(BYTE val);
+
+
+//CON6----------------------------------------------------
+
+extern void hl7059_set_treg(BYTE val);
+
+extern void hl7059_set_boostv(BYTE val);
+
+extern void hl7059_set_bhot(BYTE val);
+
+
+//CON7----------------------------------------------------
+
+extern void hl7059_set_tmr2x_en(BYTE val);
+
+extern void hl7059_set_batfet_disable(BYTE val);
+
+extern void hl7059_set_int_mask(BYTE val);
+
+
+//CON8----------------------------------------------------
+
+extern BYTE hl7059_get_system_status(void);
+
+extern BYTE hl7059_get_vbus_stat(void);
+
+extern BYTE hl7059_get_chrg_stat(void);
+
+extern BYTE hl7059_get_vsys_stat(void);
+
+extern BYTE hl7059_get_fault_status(void);
+
+extern void show_regs_value(void);
+
+extern void hl7059_reset_timer(void);
+//extern void hl7059_enable_cur_terminal(int enable);
+//extern void hl7059_termina_cur_set(unsigned char reg_val);
+//extern void hl7059_termina_vol_set(unsigned char reg_val);
+//extern void hl7059_set_safety_vol(unsigned char reg_val);
+//extern void hl7059_set_safety_cur(unsigned char reg_val);
+//extern void hl7059_init(void);
+extern void hl7059_otg_enable(int enable);
+//extern void hl7059_stop_charging(void);
+//extern unsigned char hl7059_get_vendor_id(void);
+//extern unsigned char hl7059_get_chg_status(void);
+//extern unsigned char hl7059_get_fault_val(void);
+extern void hl7059_enable_chg(void);
+extern void hl7059_set_chg_current(unsigned char reg_val);
+extern unsigned char hl7059_get_chg_current(void);
+//extern int hl7059_register_notifier(struct notifier_block *nb);
+//extern int hl7059_unregister_notifier(struct notifier_block *nb);
+extern struct sprd_ext_ic_operations *sprd_get_hl7059_ops(void);
+
+#ifndef CONFIG_SPRD_USB_DEVICE_ONLY
+extern int usb_get_id_state(void);
+extern int usb_get_vbus_state(void);
 #endif
+#endif
